quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Energy Efficiency," Firstly, we use; the adaptive kernel described in Moon et al. [2019] for; improved stability. Secondly, data diffusion is applied; in the PCA space, rather than the data space, for speed and; memory improvements.; More information and bug reports; here. For help, visit; <https://krishnaswamylab.org/get-help>. Parameters:. adata AnnDataAn anndata file with .raw attribute representing raw counts. name_list Union[Literal['all_genes', 'pca_only'], Sequence[str], None] (default: None)Denoised genes to return. The default 'all_genes'/None; may require a large amount of memory if the input data is sparse.; Another possibility is 'pca_only'. knn int (default: 5)number of nearest neighbors on which to build kernel. decay float | None (default: 1)sets decay rate of kernel tails.; If None, alpha decaying kernel is not used. knn_max int | None (default: None)maximum number of nearest neighbors with nonzero connection.; If None, will be set to 3 * knn. t Union[Literal['auto'], int] (default: 3)power to which the diffusion operator is powered.; This sets the level of diffusion. If ‘auto’, t is selected; according to the Procrustes disparity of the diffused data. n_pca int | None (default: 100)Number of principal components to use for calculating; neighborhoods. For extremely large datasets, using; n_pca < 20 allows neighborhoods to be calculated in; roughly log(n_samples) time. If None, no PCA is performed. solver Literal['exact', 'approximate'] (default: 'exact')Which solver to use. “exact” uses the implementation described; in van Dijk et al. [2018]. “approximate” uses a faster; implementation that performs imputation in the PCA space and then; projects back to the gene space. Note, the “approximate” solver may; return negative values. knn_dist str (default: 'euclidean')recommended values: ‘euclidean’, ‘cosine’, ‘precomputed’; Any metric from scipy.spatial.distance can be used; distance metric for building kNN graph. If ‘precomputed’,; data should be an n_samples x n_samples d",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.magic.html:10953,power,power,10953,en/stable/generated/scanpy.external.pp.magic.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.magic.html,2,['power'],"['power', 'powered']"
Energy Efficiency," If None, residuals are clipped to the interval [-sqrt(n_obs), sqrt(n_obs)], where n_obs is the number of cells in the dataset (default behavior).; If any scalar c, residuals are clipped to the interval [-c, c]. Set clip=np.inf for no clipping. n_top_genes int | None (default: None)Number of highly-variable genes to keep. Mandatory if flavor='seurat_v3' or; flavor='pearson_residuals'. batch_key str | None (default: None)If specified, highly-variable genes are selected within each batch separately; and merged. This simple process avoids the selection of batch-specific genes; and acts as a lightweight batch correction method. Genes are first sorted by; how many batches they are a HVG. If flavor='pearson_residuals', ties are; broken by the median rank (across batches) based on within-batch residual; variance. chunksize int (default: 1000)If flavor='pearson_residuals', this dertermines how many genes are processed at; once while computing the residual variance. Choosing a smaller value will reduce; the required memory. flavor Literal['pearson_residuals'] (default: 'pearson_residuals')Choose the flavor for identifying highly variable genes. In this experimental; version, only ‘pearson_residuals’ is functional. check_values bool (default: True)If True, checks if counts in selected layer are integers as expected by this; function, and return a warning if non-integers are found. Otherwise, proceed; without checking. Setting this to False can speed up code for large datasets. layer str | None (default: None)Layer to use as input instead of X. If None, X is used. subset bool (default: False)If True, subset the data to highly-variable genes after finding them.; Otherwise merely indicate highly variable genes in adata.var (see below). inplace bool (default: True)If True, update adata with results. Otherwise, return results. See below for; details of what is returned. Return type:; DataFrame | None. Returns:; If inplace=True, adata.var is updated with the following fields. Otherw",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.highly_variable_genes.html:11429,reduce,reduce,11429,en/stable/generated/scanpy.experimental.pp.highly_variable_genes.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.highly_variable_genes.html,1,['reduce'],['reduce']
Energy Efficiency," don’t need to sum all those extra zeros). You can convert from sparse to dense chunks via:; X = X.map_blocks(lambda x: x.toarray(), dtype=X.dtype, meta=np.array([])). And in reverse:; X = X.map_blocks(sparse.csr_matrix). Note that you will likely have to work with smaller chunks when doing this, via a rechunking operation. We suggest using a factor of the larger chunk size to achieve the most efficient rechunking. SPARSE_CHUNK_SIZE = 100_000; DENSE_CHUNK_SIZE = 10_000. Dask provides extensive tooling for monitoring your computation. You can access that via the dashboard started when using any of their distributed clusters. client. . Client; Client-d3384ee9-58e9-11ef-9bda-3868dd0e66a0. Connection method: Cluster object; Cluster type: distributed.LocalCluster. Dashboard: http://127.0.0.1:8787/status. Cluster Info. LocalCluster; 815df81e. Dashboard: http://127.0.0.1:8787/status. Workers: 3; . Total threads: 18; . Total memory: 128.00 GiB; . Status: running; Using processes: True. Scheduler Info. . Scheduler; Scheduler-d580fb0c-35e1-45f0-9394-837f45e7976c. Comm: tcp://127.0.0.1:37191; . Workers: 3; . Dashboard: http://127.0.0.1:8787/status. Total threads: 18; . Started: Just now; . Total memory: 128.00 GiB; . Workers. . Worker: 0. Comm: tcp://127.0.0.1:36805; . Total threads: 6; . Dashboard: http://127.0.0.1:45909/status. Memory: 42.67 GiB; . Nanny: tcp://127.0.0.1:39225; . Local directory: /tmp/dask-scratch-space/worker-pz4wcxmk; . . Worker: 1. Comm: tcp://127.0.0.1:35183; . Total threads: 6; . Dashboard: http://127.0.0.1:43387/status. Memory: 42.67 GiB; . Nanny: tcp://127.0.0.1:42555; . Local directory: /tmp/dask-scratch-space/worker-a11nkkx1; . . Worker: 2. Comm: tcp://127.0.0.1:36599; . Total threads: 6; . Dashboard: http://127.0.0.1:39033/status. Memory: 42.67 GiB; . Nanny: tcp://127.0.0.1:45463; . Local directory: /tmp/dask-scratch-space/worker-mcr71xvg; . We’ll convert the X representation to dask using anndata.experimental.read_elem_as_dask.; The file we’ve ret",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/dask.html:12655,Schedul,Scheduler,12655,en/stable/tutorials/experimental/dask.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/dask.html,1,['Schedul'],['Scheduler']
Energy Efficiency," normalized counts later. Further background on why to use the square-root transform here can be found in Wagner (2020). # keep raw and depth-normalized counts for later; adata_pbmc3k.layers[""raw""] = adata_pbmc3k.X.copy(); adata_pbmc3k.layers[""sqrt_norm""] = np.sqrt(; sc.pp.normalize_total(adata_pbmc3k, inplace=False)[""X""]; ). adata_pbmc10k.layers[""raw""] = adata_pbmc10k.X.copy(); adata_pbmc10k.layers[""sqrt_norm""] = np.sqrt(; sc.pp.normalize_total(adata_pbmc10k, inplace=False)[""X""]; ). normalizing counts per cell; finished (0:00:00); normalizing counts per cell; finished (0:00:00). Compute Pearson residuals#; This will transform the sparse raw counts in adata.X to a dense matrix of Pearson residuals. for adata in [adata_pbmc3k, adata_pbmc10k]:; sc.experimental.pp.normalize_pearson_residuals(adata). computing analytic Pearson residuals on adata.X; finished (0:00:00); computing analytic Pearson residuals on adata.X; finished (0:00:00). Compute PCA and t-SNE#; We now reduce the dimensionality of the data by running PCA on the Pearson residuals. On top, we run t-SNE for vizualisation. for adata in [adata_pbmc3k, adata_pbmc10k]:; sc.pp.pca(adata, n_comps=50); n_cells = len(adata); sc.tl.tsne(adata, use_rep=""X_pca""). computing PCA; with n_comps=50; finished (0:00:27); computing tSNE; using sklearn.manifold.TSNE; finished: added; 'X_tsne', tSNE coordinates (adata.obsm) (0:00:12); computing PCA; with n_comps=50; finished (0:00:15); computing tSNE; using sklearn.manifold.TSNE; finished: added; 'X_tsne', tSNE coordinates (adata.obsm) (0:00:27). Compute Neighborhood graph and Leiden clustering#; Based on the PCA of Pearson resisuals, we also run a clustering. for adata in [adata_pbmc3k, adata_pbmc10k]:; sc.pp.neighbors(adata, n_neighbors=10, n_pcs=50); sc.tl.leiden(adata, flavor=""igraph"", n_iterations=2, directed=False). computing neighbors; using 'X_pca' with n_pcs = 50; finished: added to `.uns['neighbors']`; `.obsp['distances']`, distances for each pair of neighbors; `.obsp['",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:25178,reduce,reduce,25178,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,2,['reduce'],['reduce']
Energy Efficiency," of nearest neighbors to be searched. If knn; is False, a Gaussian kernel width is set to the distance of the; n_neighbors neighbor.; ignored if ``transformer`` is an instance. n_pcs int | None (default: None)Use this many PCs. If n_pcs==0 use .X if use_rep is None. use_rep str | None (default: None)Use the indicated representation. 'X' or any key for .obsm is valid.; If None, the representation is chosen automatically:; For .n_vars < N_PCS (default: 50), .X is used, otherwise ‘X_pca’ is used.; If ‘X_pca’ is not present, it’s computed with default parameters or n_pcs if present. knn bool (default: True)If True, use a hard threshold to restrict the number of neighbors to; n_neighbors, that is, consider a knn graph. Otherwise, use a Gaussian; Kernel to assign low weights to neighbors more distant than the; n_neighbors nearest neighbor. method Literal['umap', 'gauss'] (default: 'umap')Use ‘umap’ [McInnes et al., 2018] or ‘gauss’ (Gauss kernel following Coifman et al. [2005]; with adaptive width Haghverdi et al. [2016]) for computing connectivities. transformer Union[KnnTransformerLike, Literal['pynndescent', 'sklearn', 'rapids'], None] (default: None)Approximate kNN search implementation following the API of; KNeighborsTransformer.; See Using other kNN libraries in Scanpy for more details.; Also accepts the following known options:. None (the default)Behavior depends on data size.; For small data, we will calculate exact kNN, otherwise we use; PyNNDescentTransformer. 'pynndescent'PyNNDescentTransformer. 'rapids'A transformer based on cuml.neighbors.NearestNeighbors. Deprecated since version 1.10.0: Use rapids_singlecell.pp.neighbors() instead. metric Union[Literal['cityblock', 'cosine', 'euclidean', 'l1', 'l2', 'manhattan'], Literal['braycurtis', 'canberra', 'chebyshev', 'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski', 'mahalanobis', 'minkowski', 'rogerstanimoto', 'russellrao', 'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean', 'yule'], Callable[[ndar",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pp.neighbors.html:11354,adapt,adaptive,11354,en/stable/api/generated/scanpy.pp.neighbors.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pp.neighbors.html,1,['adapt'],['adaptive']
Energy Efficiency," out any clusters with high doublet scores. See also; Alternative methods for doublet detection within the scverse ecosystem are DoubletDetection and SOLO. You can read more about these in the Doublet Detection chapter of Single Cell Best Practices. Normalization#; The next preprocessing step is normalization. A common approach is count depth scaling with subsequent log plus one (log1p) transformation. Count depth scaling normalizes the data to a “size factor” such as the median count depth in the dataset, ten thousand (CP10k) or one million (CPM, counts per million). The size factor for count depth scaling can be controlled via target_sum in pp.normalize_total. We are applying median count depth normalization with log1p transformation (AKA log1PF). # Saving count data; adata.layers[""counts""] = adata.X.copy(). # Normalizing to median total counts; sc.pp.normalize_total(adata); # Logarithmize the data; sc.pp.log1p(adata). Feature selection#; As a next step, we want to reduce the dimensionality of the dataset and only include the most informative genes. This step is commonly known as feature selection. The scanpy function pp.highly_variable_genes annotates highly variable genes by reproducing the implementations of Seurat [Satija et al., 2015], Cell Ranger [Zheng et al., 2017], and Seurat v3 [Stuart et al., 2019] depending on the chosen flavor. sc.pp.highly_variable_genes(adata, n_top_genes=2000, batch_key=""sample""). sc.pl.highly_variable_genes(adata). Dimensionality Reduction#; Reduce the dimensionality of the data by running principal component analysis (PCA), which reveals the main axes of variation and denoises the data. sc.tl.pca(adata). Let us inspect the contribution of single PCs to the total variance in the data. This gives us information about how many PCs we should consider in order to compute the neighborhood relations of cells, e.g. used in the clustering function leiden() or tsne(). In our experience, there does not seem to be signifigant downside to over",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering.html:14980,reduce,reduce,14980,en/stable/tutorials/basics/clustering.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering.html,2,['reduce'],['reduce']
Energy Efficiency,"'leiden', the cluster labels (adata.obs, categorical) (0:00:00). Plot the clusters, which agree quite well with the result of Seurat. sc.pl.umap(adata, color=[""leiden"", ""CST3"", ""NKG7""]). Save the result. adata.write(results_file). Finding marker genes#; Let us compute a ranking for the highly differential genes in each cluster. For this, by default, the .raw attribute of AnnData is used in case it has been initialized before. The simplest and fastest method to do so is the t-test. sc.tl.rank_genes_groups(adata, ""leiden"", method=""t-test""); sc.pl.rank_genes_groups(adata, n_genes=25, sharey=False). ranking genes; finished: added to `.uns['rank_genes_groups']`; 'names', sorted np.recarray to be indexed by group ids; 'scores', sorted np.recarray to be indexed by group ids; 'logfoldchanges', sorted np.recarray to be indexed by group ids; 'pvals', sorted np.recarray to be indexed by group ids; 'pvals_adj', sorted np.recarray to be indexed by group ids (0:00:00). sc.settings.verbosity = 2 # reduce the verbosity. The result of a Wilcoxon rank-sum (Mann-Whitney-U) test is very similar. We recommend using the latter in publications, see e.g., Sonison & Robinson (2018). You might also consider much more powerful differential testing packages like MAST, limma, DESeq2 and, for python, the recent diffxpy. sc.tl.rank_genes_groups(adata, ""leiden"", method=""wilcoxon""); sc.pl.rank_genes_groups(adata, n_genes=25, sharey=False). ranking genes; finished (0:00:03). Save the result. adata.write(results_file). As an alternative, let us rank genes using logistic regression. For instance, this has been suggested by Natranos et al. (2018). The essential difference is that here, we use a multi-variate appraoch whereas conventional differential tests are uni-variate. Clark et al. (2014) has more details. sc.tl.rank_genes_groups(adata, ""leiden"", method=""logreg"", max_iter=1000); sc.pl.rank_genes_groups(adata, n_genes=25, sharey=False). ranking genes; finished (0:00:32). With the exceptions of IL7R, ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering-2017.html:20055,reduce,reduce,20055,en/stable/tutorials/basics/clustering-2017.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering-2017.html,2,['reduce'],['reduce']
Energy Efficiency,")[source]#; Run Diffusion maps using the adaptive anisotropic kernel [Setty et al., 2019].; Palantir is an algorithm to align cells along differentiation trajectories.; Palantir models differentiation as a stochastic process where stem cells; differentiate to terminally differentiated cells by a series of steps through; a low dimensional phenotypic manifold. Palantir effectively captures the; continuity in cell states and the stochasticity in cell fate determination.; Palantir has been designed to work with multidimensional single cell data; from diverse technologies such as Mass cytometry and single cell RNA-seq. Note; More information and bug reports here. Parameters:. adata AnnDataAn AnnData object. n_components int (default: 10)Number of diffusion components. knn int (default: 30)Number of nearest neighbors for graph construction. alpha float (default: 0)Normalization parameter for the diffusion operator. use_adjacency_matrix bool (default: False)Use adaptive anisotropic adjacency matrix, instead of PCA projections; (default) to compute diffusion components. distances_key str | None (default: None)With use_adjacency_matrix=True, use the indicated distances key for .obsp.; If None, 'distances'. n_eigs int | None (default: None)Number of eigen vectors to use. If None specified, the number of eigen; vectors will be determined using eigen gap. Passed to; palantir.utils.determine_multiscale_space. impute_data bool (default: True)Impute data using MAGIC. n_steps int (default: 3)Number of steps in the diffusion operator. Passed to; palantir.utils.run_magic_imputation. copy bool (default: False)Return a copy instead of writing to adata. Return type:; AnnData | None. Returns:; Depending on copy, returns or updates adata with the following fields:. Diffusion maps,used for magic imputation, and to generate multi-scale data matrix,. X_palantir_diff_comp - ndarray (obsm, dtype float)Array of Diffusion components. palantir_EigenValues - ndarray (uns, dtype float)Array of corr",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.palantir.html:10459,adapt,adaptive,10459,en/stable/external/generated/scanpy.external.tl.palantir.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.palantir.html,2,['adapt'],['adaptive']
Energy Efficiency,"; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.external.tl.palantir. Contents . palantir(). scanpy.external.tl.palantir#. scanpy.external.tl.palantir(adata, *, n_components=10, knn=30, alpha=0, use_adjacency_matrix=False, distances_key=None, n_eigs=None, impute_data=True, n_steps=3, copy=False)[source]#; Run Diffusion maps using the adaptive anisotropic kernel [Setty et al., 2019].; Palantir is an algorithm to align cells along differentiation trajectories.; Palantir models differentiation as a stochastic process where stem cells; differentiate to terminally differentiated cells by a series of steps through; a low dimensional phenotypic manifold. Palantir effectively captures the; continuity in cell states and the stochasticity in cell fate determination.; Palantir has been designed to work with multidimensional single cell data; from diverse technologies such as Mass cytometry and single cell RNA-seq. Note; More information and bug reports here. Parameters:. adata AnnDataAn AnnData object. n_components int (default: 10)Number of diffusion components. knn int (default: 30)Number of nearest neighbors for graph construction. alpha float (default: 0)Normalization parameter for the diffusion operator. use_adjacency_matrix bool (default: False)",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.palantir.html:9531,adapt,adaptive,9531,en/stable/external/generated/scanpy.external.tl.palantir.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.palantir.html,2,['adapt'],['adaptive']
Energy Efficiency,"; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .md. .pdf. Tutorials. Contents . Basic workflows; Visualization; Trajectory inference; Spatial data; Experimental; Older tutorials. Tutorials#. See also; For more tutorials featureing scanpy and other scverse ecosystem tools, check out the curated set of tutorials at scverse.org/learn. Basic workflows#. Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Visualization#. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectory inference#. See also; For more powerful tools for analysing single cell dynamics, check out the Scverse ecosystem packages:. CellRank; Dynamo. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial data#. See also; For more up-to-date tutorials on working with spatial data, see:. SquidPy tutorials; SpatialData tutorials; Scverse ecosystem spatial tutorials. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental#. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Older tutorials#; A number of older tutorials can be found at:. The scanpy_usage repository. previous; Installation. next; Basics. Contents; . Basic workflows; Visualization; Trajectory inference; Spatial data; Experimental; Older tutorials. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/index.html:9766,power,powerful,9766,en/stable/tutorials/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/index.html,1,['power'],['powerful']
Energy Efficiency,"PCA coordinates, loadings and variance decomposition.; Uses the implementation of scikit-learn [Pedregosa et al., 2011]. Changed in version 1.5.0: In previous versions, computing a PCA on a sparse matrix would make; a dense copy of the array for mean centering.; As of scanpy 1.5.0, mean centering is implicit.; While results are extremely similar, they are not exactly the same.; If you would like to reproduce the old results, pass a dense array. Parameters:. data AnnData | ndarray | spmatrixThe (annotated) data matrix of shape n_obs × n_vars.; Rows correspond to cells and columns to genes. n_comps int | None (default: None)Number of principal components to compute. Defaults to 50, or 1 - minimum; dimension size of selected representation. layer str | None (default: None)If provided, which element of layers to use for PCA. zero_center bool | None (default: True)If True, compute standard PCA from covariance matrix.; If False, omit zero-centering variables; (uses scikit-learn TruncatedSVD or; dask-ml TruncatedSVD),; which allows to handle sparse input efficiently.; Passing None decides automatically based on sparseness of the data. svd_solver str | None (default: None)SVD solver to use:. NoneSee chunked and zero_center descriptions to determine which class will be used.; Depending on the class and the type of X different values for default will be set.; If scikit-learn PCA is used, will give 'arpack',; if scikit-learn TruncatedSVD is used, will give 'randomized',; if dask-ml PCA or IncrementalPCA is used, will give 'auto',; if dask-ml TruncatedSVD is used, will give 'tsqr'. 'arpack'for the ARPACK wrapper in SciPy (svds()); Not available with dask arrays. 'randomized'for the randomized algorithm due to Halko (2009). For dask arrays,; this will use svd_compressed(). 'auto'chooses automatically depending on the size of the problem. 'lobpcg'An alternative SciPy solver. Not available with dask arrays. 'tsqr'Only available with dask arrays. “tsqr”; algorithm from Benson et. al",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.pca.html:10633,efficient,efficiently,10633,en/stable/generated/scanpy.pp.pca.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.pca.html,1,['efficient'],['efficiently']
Energy Efficiency,"Pearson residuals for large datasets#; Raw scRNA UMI counts are usually sparse, and can thus be stored efficiently for large datasets. However, when the count matrix is transformed to Pearson residuals, the data becomes dense. To avoid memory problems, we recommend that you reduce the size of your count matrix by gene selection, before running normalize_pearson_residuals(adata) on the reduced data. To perform RAM-efficient gene selection, use highly_variable_genes(adata,flavor='pearson_residuals') with the chunksize argument: This will still use Pearson residual variance to identify variable genes, but won’t compute all residuals at once. Reduce the chunksize as needed if you run into RAM issues during gene selection. Note that a very small chunksize will slow down the computation, so try to set it as large as possible with your resources.; As an example, we used chunksize=1000 when processing a dataset with 2 million cells in a machine with 500 GB RAM. For smaller machines, we would recommend to reduce this below 100. Wrapper functions for Pearson residuals preprocessing#; The scanpy.experimental.pp module also ships two wrappers that run multiple pre-processing steps at once:. sc.experimental.pp.normalize_pearson_residuals_pca() performs normalization by Pearson residuals and PCA in one go. This function is helpful to quickly obtain a Pearson residual-based data representation when highly variable genes are already defined, as only those are used by default.; sc.experimental.pp.recipe_pearson_residuals() performs gene selection and normalization by Pearson residuals, and PCA on top. This is intended to make the full Pearson residual preprocessing available in one step. All hyperparameters of the individual steps can still be controlled using the wrapper functions’ arguments. See the documentation for details. References / See also#; Hafemeister & Satija (2019), Normalization and variance stabilization of single-cell RNA-seq data using regularized negative binomial ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:29774,reduce,reduce,29774,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,2,['reduce'],['reduce']
Energy Efficiency,"_integrate; scanpy.external.pp.hashsolo; scanpy.external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .md. .pdf. Contributing. Contributing#; Contributions to scanpy are welcome!; This section of the docs provides some guidelines and tips to follow when contributing. Contributing code; Development workflow; Code style. Getting set up; Working with git; Forking and cloning; pre-commit; Creating a branch for your feature; Open a pull request. Development environments. Tests; Running the tests; Miscellaneous tips. Writing tests; What to test; Performance; Plotting tests. Documentation; Building the docs; Adding to the docs; docstrings format; Plots in docstrings; Params section; Returns section; Examples. CI; Plotting tests; Viewing plots from failed tests on Azure pipelines; Misc. Versioning; Semantic versioning; Version numbers. Tooling; Technical details. Making a release; Preparing the release; Actually making the release; After making a release; Debugging the build process. Parts of the guidelines have been adapted from the pandas and MDAnalysis guides.; These are both excellent guides and we highly recommend checking them out. previous; News. next; Contributing code. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/dev/index.html:10132,adapt,adapted,10132,en/stable/dev/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/dev/index.html,1,['adapt'],['adapted']
Energy Efficiency,"ajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.pp.neighbors. Contents . neighbors(). scanpy.pp.neighbors#. scanpy.pp.neighbors(adata, n_neighbors=15, n_pcs=None, *, use_rep=None, knn=True, method='umap', transformer=None, metric='euclidean', metric_kwds=mappingproxy({}), random_state=0, key_added=None, copy=False)[source]#; Computes the nearest neighbors distance matrix and a neighborhood graph of observations [McInnes et al., 2018].; The neighbor search efficiency of this heavily relies on UMAP [McInnes et al., 2018],; which also provides a method for estimating connectivities of data points -; the connectivity of the manifold (method=='umap'). If method=='gauss',; connectivities are computed according to Coifman et al. [2005], in the adaption of; Haghverdi et al. [2016]. Parameters:. adata AnnDataAnnotated data matrix. n_neighbors int (default: 15)The size of local neighborhood (in terms of number of neighboring data; points) used for manifold approximation. Larger values result in more; global views of the manifold, while smaller values result in more local; data being preserved. In general values should be in the range 2 to 100.; If knn is True, number of nearest neighbors to be searched. If knn; is False, a Gaussian kernel width is set to the distance of the; n_neighbors neighbor.; ignored if ``transformer`` is an instance. n_pcs int | None (default: None)Use this many PCs. If n_pcs==0 use .X if use_rep is None. use_rep str | None (default: None)Use the indicated representation. 'X' or any key for .obsm is valid.; If None, the representation is chosen automatically:; For .n_vars < N_PCS (default: 50), .X is used, otherwise ‘X_pca’ is used.; If ‘X_pca’ is not present, it’s computed with default parameters or n_pcs if pr",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pp.neighbors.html:9934,adapt,adaption,9934,en/stable/api/generated/scanpy.pp.neighbors.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pp.neighbors.html,1,['adapt'],['adaption']
Energy Efficiency,"aphs in AnnData, sparse PCA, an interface with scvi, and others. Spatial data support#. Basic analysis Analysis and visualization of spatial transcriptomics data and integration with single cell data Integrating spatial data with scRNA-seq using scanorama G Palla; read_visium() read 10x Visium data pr1034 G Palla, P Angerer, I Virshup; visium_sge() load Visium data directly from 10x Genomics pr1013 M Mirkazemi, G Palla, P Angerer; spatial() plot spatial data pr1012 G Palla, P Angerer. New functionality#. Many functions, like neighbors() and umap(), now store cell-by-cell graphs in obsp pr1118 S Rybakov; scale() and log1p() can be used on any element in layers or obsm pr1173 I Virshup. External tools#. scanpy.external.pp.scvi for preprocessing with scVI pr1085 G Xing; Guide for using Scanpy in R pr1186 L Zappia. Performance#. pca() now uses efficient implicit centering for sparse matrices. This can lead to signifigantly improved performance for large datasets pr1066 A Tarashansky; score_genes() now has an efficient implementation for sparse matrices with missing values pr1196 redst4r. Warning; The new pca() implementation can result in slightly different results for sparse matrices. See the pr (pr1066) and documentation for more info. Code design#. stacked_violin() can now be used as a subplot pr1084 P Angerer; score_genes() has improved logging pr1119 G Eraslan; scale() now saves mean and standard deviation in the var pr1173 A Wolf; harmony_timeseries() pr1091 A Mousa. Bug fixes#. combat() now works when obs_names aren’t unique. pr1215 I Virshup; scale() can now be used on dense arrays without centering pr1160 simonwm; regress_out() now works when some features are constant pr1194 simonwm; normalize_total() errored if the passed object was a view pr1200 I Virshup; neighbors() sometimes ignored the n_pcs param pr1124 V Bergen; ebi_expression_atlas() which contained some out-of-date URLs pr1102 I Virshup; ingest() for UMAP 0.4 pr1165 S Rybakov; louvain() for Louvain 0.",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:38715,efficient,efficient,38715,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,1,['efficient'],['efficient']
Energy Efficiency,"behavior is desired, the overdispersion parameter can instead be set to infinity (theta=np.Inf). Clipping threshold clip#; When a gene is expressed in only very few cells, and missing in all others, it will generate very large residuals for these few cells. In turn, these cells might dominate in downstream processing. To avoid such unbalanced behavior, Hafemeister & Satija (2019) introduced a heuristic that clips all residuals to +-sqrt(n_cells). This is the default behavior of all functions for Pearson residuals discussed here. If desired, a different threshold can be set using the clip argument. If no clipping is desired, use clip=np.Inf. chunksize and best practice to obtain Pearson residuals for large datasets#; Raw scRNA UMI counts are usually sparse, and can thus be stored efficiently for large datasets. However, when the count matrix is transformed to Pearson residuals, the data becomes dense. To avoid memory problems, we recommend that you reduce the size of your count matrix by gene selection, before running normalize_pearson_residuals(adata) on the reduced data. To perform RAM-efficient gene selection, use highly_variable_genes(adata,flavor='pearson_residuals') with the chunksize argument: This will still use Pearson residual variance to identify variable genes, but won’t compute all residuals at once. Reduce the chunksize as needed if you run into RAM issues during gene selection. Note that a very small chunksize will slow down the computation, so try to set it as large as possible with your resources.; As an example, we used chunksize=1000 when processing a dataset with 2 million cells in a machine with 500 GB RAM. For smaller machines, we would recommend to reduce this below 100. Wrapper functions for Pearson residuals preprocessing#; The scanpy.experimental.pp module also ships two wrappers that run multiple pre-processing steps at once:. sc.experimental.pp.normalize_pearson_residuals_pca() performs normalization by Pearson residuals and PCA in one go. ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:29037,reduce,reduce,29037,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,4,['reduce'],"['reduce', 'reduced']"
Energy Efficiency,"calCluster(n_workers=3); client = dd.Client(cluster). Note; In this notebook we will be demonstrating some computations in scanpy that use scipy.sparse classes within each dask chunk. Be aware that this is currently poorly supported by dask, and that if you want to interact with the dask arrays in any way other than though the anndata and scanpy libraries you will likely need to densify each chunk.; All operations in scanpy and anndata that work with sparse chunks also work with dense chunks.; The advantage of using sparse chunks are:. The ability to work with fewer, larger chunks; Accelerated computations per chunk (e.g. don’t need to sum all those extra zeros). You can convert from sparse to dense chunks via:; X = X.map_blocks(lambda x: x.toarray(), dtype=X.dtype, meta=np.array([])). And in reverse:; X = X.map_blocks(sparse.csr_matrix). Note that you will likely have to work with smaller chunks when doing this, via a rechunking operation. We suggest using a factor of the larger chunk size to achieve the most efficient rechunking. SPARSE_CHUNK_SIZE = 100_000; DENSE_CHUNK_SIZE = 10_000. Dask provides extensive tooling for monitoring your computation. You can access that via the dashboard started when using any of their distributed clusters. client. . Client; Client-d3384ee9-58e9-11ef-9bda-3868dd0e66a0. Connection method: Cluster object; Cluster type: distributed.LocalCluster. Dashboard: http://127.0.0.1:8787/status. Cluster Info. LocalCluster; 815df81e. Dashboard: http://127.0.0.1:8787/status. Workers: 3; . Total threads: 18; . Total memory: 128.00 GiB; . Status: running; Using processes: True. Scheduler Info. . Scheduler; Scheduler-d580fb0c-35e1-45f0-9394-837f45e7976c. Comm: tcp://127.0.0.1:37191; . Workers: 3; . Dashboard: http://127.0.0.1:8787/status. Total threads: 18; . Started: Just now; . Total memory: 128.00 GiB; . Workers. . Worker: 0. Comm: tcp://127.0.0.1:36805; . Total threads: 6; . Dashboard: http://127.0.0.1:45909/status. Memory: 42.67 GiB; . Nanny: tcp",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/dask.html:12059,efficient,efficient,12059,en/stable/tutorials/experimental/dask.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/dask.html,2,['efficient'],['efficient']
Energy Efficiency,"canpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.tl.diffmap. Contents . diffmap(). scanpy.tl.diffmap#. scanpy.tl.diffmap(adata, n_comps=15, *, neighbors_key=None, random_state=0, copy=False)[source]#; Diffusion Maps [Coifman et al., 2005, Haghverdi et al., 2015, Wolf et al., 2018].; Diffusion maps [Coifman et al., 2005] has been proposed for visualizing single-cell; data by Haghverdi et al. [2015]. The tool uses the adapted Gaussian kernel suggested; by Haghverdi et al. [2016] in the implementation of Wolf et al. [2018].; The width (“sigma”) of the connectivity kernel is implicitly determined by; the number of neighbors used to compute the single-cell graph in; neighbors(). To reproduce the original implementation; using a Gaussian kernel, use method=='gauss' in; neighbors(). To use an exponential kernel, use the default; method=='umap'. Differences between these options shouldn’t usually be; dramatic. Parameters:. adata AnnDataAnnotated data matrix. n_comps int (default: 15)The number of dimensions of the representation. neighbors_key str | None (default: None)If not specified, diffmap looks .uns[‘neighbors’] for neighbors settings; and .obsp[‘connectivities’], .obsp[‘distances’] for connectivities and; distances respectively (default storage places for pp.neighbors).; If specified, diffmap looks .uns[neighbors_key] for neighbors settings and; .obsp[.uns[neighbors_key][‘connectivities_key’]],; .obsp[.uns[neighbors",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.diffmap.html:9604,adapt,adapted,9604,en/stable/generated/scanpy.tl.diffmap.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.diffmap.html,1,['adapt'],['adapted']
Energy Efficiency,"cency matrix. Parameters:. adata AnnDataThe annotated data matrix. resolution float | None (default: None)For the default flavor ('vtraag') or for `RAPIDS`, you can provide a; resolution (higher resolution means finding more and smaller clusters),; which defaults to 1.0.; See “Time as a resolution parameter” in Lambiotte et al. [2014]. random_state Union[int, RandomState, None] (default: 0)Change the initialization of the optimization. restrict_to tuple[str, Sequence[str]] | None (default: None)Restrict the clustering to the categories within the key for sample; annotation, tuple needs to contain (obs_key, list_of_categories). key_added str (default: 'louvain')Key under which to add the cluster labels. (default: 'louvain'). adjacency spmatrix | None (default: None)Sparse adjacency matrix of the graph, defaults to neighbors connectivities. flavor Literal['vtraag', 'igraph', 'rapids'] (default: 'vtraag')Choose between to packages for computing the clustering. 'vtraag'Much more powerful than 'igraph', and the default. 'igraph'Built in igraph method. 'rapids'GPU accelerated implementation. Deprecated since version 1.10.0: Use rapids_singlecell.tl.louvain() instead. directed bool (default: True)Interpret the adjacency matrix as directed graph?. use_weights bool (default: False)Use weights from knn graph. partition_type type[MutableVertexPartition] | None (default: None)Type of partition to use.; Only a valid argument if flavor is 'vtraag'. partition_kwargs Mapping[str, Any] (default: mappingproxy({}))Key word arguments to pass to partitioning,; if vtraag method is being used. neighbors_key str | None (default: None)Use neighbors connectivities as adjacency.; If not specified, louvain looks .obsp[‘connectivities’] for connectivities; (default storage place for pp.neighbors).; If specified, louvain looks; .obsp[.uns[neighbors_key][‘connectivities_key’]] for connectivities. obsp str | None (default: None)Use .obsp[obsp] as adjacency. You can’t specify both; obsp and neighbor",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.louvain.html:10923,power,powerful,10923,en/stable/generated/scanpy.tl.louvain.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.louvain.html,1,['power'],['powerful']
Energy Efficiency,"d 0 we set vmax to maximal absolut value and vmin to; # the negative value of maxabs; maxabs = max(abs(adata.obs[""B_cell_score""])); sc.pl.umap(; adata, color=""B_cell_score"", cmap=""coolwarm"", s=20, vmin=-maxabs, vmax=maxabs; ); adata.obs.drop(""B_cell_score"", axis=1, inplace=True). matplotlib also supports custom color palettes with scaling (e.g. log), value range normalisation, centering, and custom color combinations or dynamic ranges. # Log-scaled palette. # Make mock column with log-normally distirbuited values; adata.obs[""lognormal""] = np.random.lognormal(3, 1, adata.shape[0]). # Log scaling of the palette; norm = mcolors.LogNorm(); sc.pl.umap(adata, color=""lognormal"", s=20, norm=norm). adata.obs.drop(""lognormal"", axis=1, inplace=True). # Centered non-symmetric palette. # Make mock column for plotting, here we use B cell score; sc.tl.score_genes(adata, [""CD79A"", ""MS4A1""], score_name=""B_cell_score""). # Palette normalization with centering and adapted dynamic range to correspond to; # the distance of vmin and vmax from the cenetr; # Adapted from https://stackoverflow.com/a/50003503; class MidpointNormalize(mcolors.Normalize):; def __init__(self, vmin=None, vmax=None, midpoint=0, clip=False):; self.midpoint = midpoint; mcolors.Normalize.__init__(self, vmin, vmax, clip). def __call__(self, value, clip=None):; value = np.array(value).astype(float); normalized_min = max(; 0.0,; 0.5; * (1.0 - abs((self.midpoint - self.vmin) / (self.midpoint - self.vmax))),; ); normalized_max = min(; 1.0,; 0.5; * (1.0 + abs((self.vmax - self.midpoint) / (self.midpoint - self.vmin))),; ); normalized_mid = 0.5; x, y = (; [self.vmin, self.midpoint, self.vmax],; [normalized_min, normalized_mid, normalized_max],; ); return np.ma.masked_array(np.interp(value, x, y)). # Add padding arround vmin and vmax as Colorbar sets value limits to round numbers below and; # above the vmin and vmax, respectively, which means that they can not be assigned the correct; # color with our nomalisation function t",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/advanced.html:28171,adapt,adapted,28171,en/stable/tutorials/plotting/advanced.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/advanced.html,3,"['Adapt', 'adapt']","['Adapted', 'adapted']"
Energy Efficiency,"dense arrays without centering pr1160 simonwm; regress_out() now works when some features are constant pr1194 simonwm; normalize_total() errored if the passed object was a view pr1200 I Virshup; neighbors() sometimes ignored the n_pcs param pr1124 V Bergen; ebi_expression_atlas() which contained some out-of-date URLs pr1102 I Virshup; ingest() for UMAP 0.4 pr1165 S Rybakov; louvain() for Louvain 0.6 pr1197 I Virshup; highly_variable_genes() which could lead to incorrect results when the batch_key argument was used pr1180 G Eraslan; ingest() where an inconsistent number of neighbors was used pr1111 S Rybakov. Version 1.4#. 1.4.6 2020-03-17#. Functionality in external#. sam() self-assembling manifolds [Tarashansky et al., 2019] pr903 A Tarashansky; harmony_timeseries() for trajectory inference on discrete time points pr994 A Mousa; wishbone() for trajectory inference (bifurcations) pr1063 A Mousa. Code design#. violin now reads .uns['colors_...'] pr1029 michalk8. Bug fixes#. adapt ingest() for UMAP 0.4 pr1038 pr1106 S Rybakov; compat with matplotlib 3.1 and 3.2 pr1090 I Virshup, P Angerer; fix PAGA for new igraph pr1037 P Angerer; fix rapids compat of louvain pr1079 LouisFaure. 1.4.5 2019-12-30#; Please install scanpy==1.4.5.post3 instead of scanpy==1.4.5. New functionality#. ingest() maps labels and embeddings of reference data to new data Integrating data using ingest and BBKNN pr651 S Rybakov, A Wolf; queries recieved many updates including enrichment through gprofiler and more advanced biomart queries pr467 I Virshup; set_figure_params() allows setting figsize and accepts facecolor='white', useful for working in dark mode A Wolf. Code design#. downsample_counts now always preserves the dtype of it’s input, instead of converting floats to ints pr865 I Virshup; allow specifying a base for log1p() pr931 G Eraslan; run neighbors on a GPU using rapids pr830 T White; param docs from typed params P Angerer; embedding_density() now only takes one positional argument; simil",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:40283,adapt,adapt,40283,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,1,['adapt'],['adapt']
Energy Efficiency,"e or an empty list, the root; vertices are automatically calculated based on topological sorting. transitions str | None (default: None)Key for .uns['paga'] that specifies the matrix that stores the; arrows, for instance 'transitions_confidence'. solid_edges str (default: 'connectivities')Key for .uns['paga'] that specifies the matrix that stores the edges; to be drawn solid black. dashed_edges str | None (default: None)Key for .uns['paga'] that specifies the matrix that stores the edges; to be drawn dashed grey. If None, no dashed edges are drawn. single_component bool (default: False)Restrict to largest connected component. fontsize int | None (default: None)Font size for node labels. fontoutline int | None (default: None)Width of the white outline around fonts. text_kwds Mapping[str, Any] (default: mappingproxy({}))Keywords for text(). node_size_scale float (default: 1.0)Increase or decrease the size of the nodes. node_size_power float (default: 0.5)The power with which groups sizes influence the radius of the nodes. edge_width_scale float (default: 1.0)Edge with scale in units of rcParams['lines.linewidth']. min_edge_width float | None (default: None)Min width of solid edges. max_edge_width float | None (default: None)Max width of solid and dashed edges. arrowsize int (default: 30)For directed graphs, choose the size of the arrow head head’s length and; width. See :py:class: matplotlib.patches.FancyArrowPatch for attribute; mutation_scale for more info. export_to_gexf bool (default: False)Export to gexf format to be read by graph visualization programs such as; Gephi. normalize_to_color bool (default: False)Whether to normalize categorical plots to color or the underlying; grouping. cmap str | Colormap | None (default: None)The color map. cax Axes | None (default: None)A matplotlib axes object for a potential colorbar. cb_kwds Mapping[str, Any] (default: mappingproxy({}))Keyword arguments for Colorbar,; for instance, ticks. add_pos bool (default: True)Add the po",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pl.paga.html:13599,power,power,13599,en/stable/api/generated/scanpy.pl.paga.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pl.paga.html,1,['power'],['power']
Energy Efficiency,"e). ncol = 2; nrow = 1; figsize = 3; wspace = 1; # Adapt figure size based on number of rows and columns and added space between them; # (e.g. wspace between columns); fig, axs = plt.subplots(; nrow, ncol, figsize=(ncol * figsize + (ncol - 1) * wspace * figsize, nrow * figsize); ); plt.subplots_adjust(wspace=wspace); sc.pl.umap(adata, color=""louvain"", ax=axs[0], show=False); sc.pl.umap(adata, color=""phase"", ax=axs[1]). Adjust space between subplots#; When plotting multiple plots (e.g. with embedding) in the same row or column it may happen that the legend overlaps with the neighbouring plot. This can be overcomed by setting wspace (width) or hspace (height). These parameters can be likewise used when creating Axes for plotting (see the above section on using matplotlib Axes). # Default, legend is overlapping; sc.pl.umap(adata, color=[""bulk_labels"", ""phase""]). # Increase gap size between plots; sc.pl.umap(adata, color=[""bulk_labels"", ""phase""], wspace=1). Adapt axes appearance#; We can further modify the plot object (e.g. Axes) to change axis text, title size, font type (e.g. italic), font color, etc. For further details on customizing Axes and Figure objects see matplotlib documentation.; Some scanpy plotting functions already have predefined parameters for adjusting plot appearance. For example, embedding enables setting of titles with the title parameter and transparent plotting with the frameon parameter. # Set title with the title parameter; # Return Axes to further modify the plot; ax = sc.pl.umap(adata, color=""bulk_labels"", title=""Cell type"", show=False); # Modify xlabel; _ = ax.set_xlabel(""umap1"", fontsize=20). # Make title italic; ax = sc.pl.umap(adata, color=""IGJ"", show=False); _ = ax.set_title(""IGJ"", style=""italic""). # Transparent background and no borders/axis labels with frameon=False; sc.pl.umap(adata, color=""bulk_labels"", frameon=False). We can also change appearance (e.g color) of individual axis labels. This may be of special interest for plots like d",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/advanced.html:19427,Adapt,Adapt,19427,en/stable/tutorials/plotting/advanced.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/advanced.html,1,['Adapt'],['Adapt']
Energy Efficiency,"efine is largely arbitrary, and so is the resolution parameter that we use to control for it. As such, the number of clusters is ultimately bound to the stable and biologically-meaningful groups that we can ultimately distringuish, typically done by experts in the corresponding field or by using expert-curated prior knowledge in the form of markers. sc.pl.umap(; adata,; color=[""leiden_res_0.02"", ""leiden_res_0.50"", ""leiden_res_2.00""],; legend_loc=""on data"",; ). sc.pl.umap(; adata,; color=[""leiden_res_0.02"", ""leiden_res_0.50"", ""leiden_res_2.00""],; legend_loc=""on data"",; ). Though UMAPs should not be over-interpreted, here we can already see that in the highest resolution our data is over-clustered, while the lowest resolution is likely grouping cells which belong to distinct cell identities. Marker gene set#; Let’s define a set of marker genes for the main cell types that we expect to see in this dataset. These were adapted from Single Cell Best Practices annotation chapter, for a more detailed overview and best practices in cell type annotation, we refer the user to it. marker_genes = {; ""CD14+ Mono"": [""FCN1"", ""CD14""],; ""CD16+ Mono"": [""TCF7L2"", ""FCGR3A"", ""LYN""],; # Note: DMXL2 should be negative; ""cDC2"": [""CST3"", ""COTL1"", ""LYZ"", ""DMXL2"", ""CLEC10A"", ""FCER1A""],; ""Erythroblast"": [""MKI67"", ""HBA1"", ""HBB""],; # Note HBM and GYPA are negative markers; ""Proerythroblast"": [""CDK6"", ""SYNGR1"", ""HBM"", ""GYPA""],; ""NK"": [""GNLY"", ""NKG7"", ""CD247"", ""FCER1G"", ""TYROBP"", ""KLRG1"", ""FCGR3A""],; ""ILC"": [""ID2"", ""PLCG2"", ""GNLY"", ""SYNE1""],; ""Naive CD20+ B"": [""MS4A1"", ""IL4R"", ""IGHD"", ""FCRL1"", ""IGHM""],; # Note IGHD and IGHM are negative markers; ""B cells"": [; ""MS4A1"",; ""ITGB1"",; ""COL4A4"",; ""PRDM1"",; ""IRF4"",; ""PAX5"",; ""BCL11A"",; ""BLK"",; ""IGHD"",; ""IGHM"",; ],; ""Plasma cells"": [""MZB1"", ""HSP90B1"", ""FNDC3B"", ""PRDM1"", ""IGKC"", ""JCHAIN""],; # Note PAX5 is a negative marker; ""Plasmablast"": [""XBP1"", ""PRDM1"", ""PAX5""],; ""CD4+ T"": [""CD4"", ""IL7R"", ""TRBC2""],; ""CD8+ T"": [""CD8A"", ""CD8B"", ""GZMK"", ""GZMA"", ""CCL5"", ""GZMB""",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering.html:20894,adapt,adapted,20894,en/stable/tutorials/basics/clustering.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering.html,2,['adapt'],['adapted']
Energy Efficiency,"electing genes that vary strongly across batches pr622 G Eraslan. Bug fixes#. rank_genes_groups() t-test implementation doesn’t return NaN when variance is 0, also changed to scipy’s implementation pr621 I Virshup; umap() with init_pos='paga' detects correct dtype A Wolf; louvain() and leiden() auto-generate key_added=louvain_R upon passing restrict_to, which was temporarily changed in 1.4.1 A Wolf. Code design#. neighbors() and umap() got rid of UMAP legacy code and introduced UMAP as a dependency pr576 S Rybakov. 1.4.1 2019-04-26#. New functionality#. Scanpy has a command line interface again. Invoking it with scanpy somecommand [args] calls scanpy-somecommand [args], except for builtin commands (currently scanpy settings) pr604 P Angerer; ebi_expression_atlas() allows convenient download of EBI expression atlas I Virshup; marker_gene_overlap() computes overlaps of marker genes M Luecken; filter_rank_genes_groups() filters out genes based on fold change and fraction of cells expressing genes F Ramirez; normalize_total() replaces normalize_per_cell(), is more efficient and provides a parameter to only normalize using a fraction of expressed genes S Rybakov; downsample_counts() has been sped up, changed default value of replace parameter to False pr474 I Virshup; embedding_density() computes densities on embeddings pr543 M Luecken; palantir() interfaces Palantir [Setty et al., 2019] pr493 A Mousa. Code design#. .layers support of scatter plots F Ramirez; fix double-logarithmization in compute of log fold change in rank_genes_groups() A Muñoz-Rojas; fix return sections of docs P Angerer. Version 1.3#. 1.3.8 2019-02-05#. various documentation and dev process improvements; Added combat() function for batch effect correction [Johnson et al., 2006, Leek et al., 2017, Pedersen, 2012] pr398 M Lange. 1.3.7 2019-01-02#. API changed from import scanpy as sc to import scanpy.api as sc.; phenograph() wraps the graph clustering package Phenograph [Levine et al., 2015] thanks to ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:43551,efficient,efficient,43551,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,1,['efficient'],['efficient']
Energy Efficiency,"er genes#; Let us compute a ranking for the highly differential genes in each cluster. For this, by default, the .raw attribute of AnnData is used in case it has been initialized before. The simplest and fastest method to do so is the t-test. sc.tl.rank_genes_groups(adata, ""leiden"", method=""t-test""); sc.pl.rank_genes_groups(adata, n_genes=25, sharey=False). ranking genes; finished: added to `.uns['rank_genes_groups']`; 'names', sorted np.recarray to be indexed by group ids; 'scores', sorted np.recarray to be indexed by group ids; 'logfoldchanges', sorted np.recarray to be indexed by group ids; 'pvals', sorted np.recarray to be indexed by group ids; 'pvals_adj', sorted np.recarray to be indexed by group ids (0:00:00). sc.settings.verbosity = 2 # reduce the verbosity. The result of a Wilcoxon rank-sum (Mann-Whitney-U) test is very similar. We recommend using the latter in publications, see e.g., Sonison & Robinson (2018). You might also consider much more powerful differential testing packages like MAST, limma, DESeq2 and, for python, the recent diffxpy. sc.tl.rank_genes_groups(adata, ""leiden"", method=""wilcoxon""); sc.pl.rank_genes_groups(adata, n_genes=25, sharey=False). ranking genes; finished (0:00:03). Save the result. adata.write(results_file). As an alternative, let us rank genes using logistic regression. For instance, this has been suggested by Natranos et al. (2018). The essential difference is that here, we use a multi-variate appraoch whereas conventional differential tests are uni-variate. Clark et al. (2014) has more details. sc.tl.rank_genes_groups(adata, ""leiden"", method=""logreg"", max_iter=1000); sc.pl.rank_genes_groups(adata, n_genes=25, sharey=False). ranking genes; finished (0:00:32). With the exceptions of IL7R, which is only found by the t-test and FCER1A, which is only found by the other two appraoches, all marker genes are recovered in all approaches. Louvain Group; Markers; Cell Type. 0; IL7R; CD4 T cells. 1; CD14, LYZ; CD14+ Monocytes. 2; MS4A1; ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering-2017.html:20268,power,powerful,20268,en/stable/tutorials/basics/clustering-2017.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering-2017.html,2,['power'],['powerful']
Energy Efficiency,"er million). The size factor for count depth scaling can be controlled via target_sum in pp.normalize_total. We are applying median count depth normalization with log1p transformation (AKA log1PF). # Saving count data; adata.layers[""counts""] = adata.X.copy(). # Normalizing to median total counts; sc.pp.normalize_total(adata); # Logarithmize the data; sc.pp.log1p(adata). Feature selection#; As a next step, we want to reduce the dimensionality of the dataset and only include the most informative genes. This step is commonly known as feature selection. The scanpy function pp.highly_variable_genes annotates highly variable genes by reproducing the implementations of Seurat [Satija et al., 2015], Cell Ranger [Zheng et al., 2017], and Seurat v3 [Stuart et al., 2019] depending on the chosen flavor. sc.pp.highly_variable_genes(adata, n_top_genes=2000, batch_key=""sample""). sc.pl.highly_variable_genes(adata). Dimensionality Reduction#; Reduce the dimensionality of the data by running principal component analysis (PCA), which reveals the main axes of variation and denoises the data. sc.tl.pca(adata). Let us inspect the contribution of single PCs to the total variance in the data. This gives us information about how many PCs we should consider in order to compute the neighborhood relations of cells, e.g. used in the clustering function leiden() or tsne(). In our experience, there does not seem to be signifigant downside to overestimating the numer of principal components. sc.pl.pca_variance_ratio(adata, n_pcs=50, log=True). You can also plot the principal components to see if there are any potentially undesired features (e.g. batch, QC metrics) driving signifigant variation in this dataset. In this case, there isn’t anything too alarming, but it’s a good idea to explore this. sc.pl.pca(; adata,; color=[""sample"", ""sample"", ""pct_counts_mt"", ""pct_counts_mt""],; dimensions=[(0, 1), (2, 3), (0, 1), (2, 3)],; ncols=2,; size=2,; ). Nearest neighbor graph constuction and visualization#;",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering.html:15500,Reduce,Reduce,15500,en/stable/tutorials/basics/clustering.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering.html,1,['Reduce'],['Reduce']
Energy Efficiency,"erate very large residuals for these few cells. In turn, these cells might dominate in downstream processing. To avoid such unbalanced behavior, Hafemeister & Satija (2019) introduced a heuristic that clips all residuals to +-sqrt(n_cells). This is the default behavior of all functions for Pearson residuals discussed here. If desired, a different threshold can be set using the clip argument. If no clipping is desired, use clip=np.Inf. chunksize and best practice to obtain Pearson residuals for large datasets#; Raw scRNA UMI counts are usually sparse, and can thus be stored efficiently for large datasets. However, when the count matrix is transformed to Pearson residuals, the data becomes dense. To avoid memory problems, we recommend that you reduce the size of your count matrix by gene selection, before running normalize_pearson_residuals(adata) on the reduced data. To perform RAM-efficient gene selection, use highly_variable_genes(adata,flavor='pearson_residuals') with the chunksize argument: This will still use Pearson residual variance to identify variable genes, but won’t compute all residuals at once. Reduce the chunksize as needed if you run into RAM issues during gene selection. Note that a very small chunksize will slow down the computation, so try to set it as large as possible with your resources.; As an example, we used chunksize=1000 when processing a dataset with 2 million cells in a machine with 500 GB RAM. For smaller machines, we would recommend to reduce this below 100. Wrapper functions for Pearson residuals preprocessing#; The scanpy.experimental.pp module also ships two wrappers that run multiple pre-processing steps at once:. sc.experimental.pp.normalize_pearson_residuals_pca() performs normalization by Pearson residuals and PCA in one go. This function is helpful to quickly obtain a Pearson residual-based data representation when highly variable genes are already defined, as only those are used by default.; sc.experimental.pp.recipe_pearson_resi",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:29179,efficient,efficient,29179,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,2,['efficient'],['efficient']
Energy Efficiency,"es advantage of anndata updates 0.7.0 - 0.7.2. Highlights of this release include support for spatial data, dedicated handling of graphs in AnnData, sparse PCA, an interface with scvi, and others. Spatial data support#. Basic analysis Analysis and visualization of spatial transcriptomics data and integration with single cell data Integrating spatial data with scRNA-seq using scanorama G Palla; read_visium() read 10x Visium data pr1034 G Palla, P Angerer, I Virshup; visium_sge() load Visium data directly from 10x Genomics pr1013 M Mirkazemi, G Palla, P Angerer; spatial() plot spatial data pr1012 G Palla, P Angerer. New functionality#. Many functions, like neighbors() and umap(), now store cell-by-cell graphs in obsp pr1118 S Rybakov; scale() and log1p() can be used on any element in layers or obsm pr1173 I Virshup. External tools#. scanpy.external.pp.scvi for preprocessing with scVI pr1085 G Xing; Guide for using Scanpy in R pr1186 L Zappia. Performance#. pca() now uses efficient implicit centering for sparse matrices. This can lead to signifigantly improved performance for large datasets pr1066 A Tarashansky; score_genes() now has an efficient implementation for sparse matrices with missing values pr1196 redst4r. Warning; The new pca() implementation can result in slightly different results for sparse matrices. See the pr (pr1066) and documentation for more info. Code design#. stacked_violin() can now be used as a subplot pr1084 P Angerer; score_genes() has improved logging pr1119 G Eraslan; scale() now saves mean and standard deviation in the var pr1173 A Wolf; harmony_timeseries() pr1091 A Mousa. Bug fixes#. combat() now works when obs_names aren’t unique. pr1215 I Virshup; scale() can now be used on dense arrays without centering pr1160 simonwm; regress_out() now works when some features are constant pr1194 simonwm; normalize_total() errored if the passed object was a view pr1200 I Virshup; neighbors() sometimes ignored the n_pcs param pr1124 V Bergen; ebi_express",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:38547,efficient,efficient,38547,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,1,['efficient'],['efficient']
Energy Efficiency,"external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.pp.calculate_qc_metrics. Contents . calculate_qc_metrics(). scanpy.pp.calculate_qc_metrics#. scanpy.pp.calculate_qc_metrics(adata, *, expr_type='counts', var_type='genes', qc_vars=(), percent_top=(50, 100, 200, 500), layer=None, use_raw=False, inplace=False, log1p=True, parallel=None)[source]#; Calculate quality control metrics.; Calculates a number of qc metrics for an AnnData object, see section; Returns for specifics. Largely based on calculateQCMetrics from scater; [McCarthy et al., 2017]. Currently is most efficient on a sparse CSR or dense matrix.; Note that this method can take a while to compile on the first call. That; result is then cached to disk to be used later. Parameters:. adata AnnDataAnnotated data matrix. expr_type str (default: 'counts')Name of kind of values in X. var_type str (default: 'genes')The kind of thing the variables are. qc_vars Collection[str] | str (default: ())Keys for boolean columns of .var which identify variables you could; want to control for (e.g. “ERCC” or “mito”). percent_top Collection[int] | None (default: (50, 100, 200, 500))List of ranks (where genes are ranked by expression) at which the cumulative; proportion of expression will be reported as a percentage. This can be used to; assess library complexity. Ranks are considered 1-indexed, and if empty or None; don’t calculate.; E.g. percent_top=[50] finds cumulative proportion to the 50th most expressed gene. layer str | None (default: None)If provided, use adata.layers[layer] for expression values instead; of a",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.calculate_qc_metrics.html:9763,efficient,efficient,9763,en/stable/generated/scanpy.pp.calculate_qc_metrics.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.calculate_qc_metrics.html,1,['efficient'],['efficient']
Energy Efficiency,"g_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .md. .pdf. Tools: TL. Contents . Embeddings; Clustering and trajectory inference; Gene scores, Cell cycle. Tools: TL#. Embeddings#. tl.phate(adata[, n_components, k, a, ...]); PHATE [Moon et al., 2019]. tl.palantir(adata, *[, n_components, knn, ...]); Run Diffusion maps using the adaptive anisotropic kernel [Setty et al., 2019]. tl.trimap(adata[, n_components, n_inliers, ...]); TriMap: Large-scale Dimensionality Reduction Using Triplets [Amid and Warmuth, 2019]. tl.sam(adata, *[, max_iter, num_norm_avg, ...]); Self-Assembling Manifolds single-cell RNA sequencing analysis tool [Tarashansky et al., 2019]. Clustering and trajectory inference#. tl.phenograph(data[, clustering_algo, k, ...]); PhenoGraph clustering [Levine et al., 2015]. tl.harmony_timeseries(adata, tp, *[, ...]); Harmony time series for data visualization with augmented affinity matrix at discrete time points [Nowotschin et al., 2019]. tl.wishbone(adata, start_cell, *[, branch, ...]); Wishbone identifies bifurcating developmental trajectories from single-cell data [Setty et al., 2016]. tl.palantir(adata, *[, n_components, knn, ...]); Run Diffusion maps using the adaptive anisotropic kernel [Setty et al., 2019]. tl.palantir_results(adata, early_cell, *[, ...]); Running Palantir. Gene scores, Cell cycle#. tl.sandbag(adata[, annotation, fraction, ...]); Calculate marker pairs of genes [Fechtner, 2018, Scialdone et al., 2015]. tl.cyclone(adata[, marker_pairs, ...]); Assigns scores and predicted class to observations [Scialdone et al., 2015] [Fechtner, 2018]. previous; scanpy.external.pp.magic. next; scanpy.external.tl.phate. Contents; . Embeddings; Clustering and trajectory inference; Gene scores, Cell cycle. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/tools.html:10348,adapt,adaptive,10348,en/stable/external/tools.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/tools.html,1,['adapt'],['adaptive']
Energy Efficiency,"ged, restore the previous default model by passing model='v1.0'. Version 1.1#. 1.1.0 2018-06-01#. set_figure_params() by default passes vector_friendly=True and allows you to produce reasonablly sized pdfs by rasterizing large scatter plots A Wolf; draw_graph() defaults to the ForceAtlas2 layout [Chippada, 2018, Jacomy et al., 2014], which is often more visually appealing and whose computation is much faster S Wollock; scatter() also plots along variables axis MD Luecken; pca() and log1p() support chunk processing S Rybakov; regress_out() is back to multiprocessing F Ramirez; read() reads compressed text files G Eraslan; mitochondrial_genes() for querying mito genes FG Brundu; mnn_correct() for batch correction [Haghverdi et al., 2018, Kang, 2018]; phate() for low-dimensional embedding [Moon et al., 2019] S Gigante; sandbag(), cyclone() for scoring genes [Fechtner, 2018, Scialdone et al., 2015]. Version 1.0#. 1.0.0 2018-03-30#. Major updates#. Scanpy is much faster and more memory efficient: preprocess, cluster and; visualize 1.3M cells in 6h, 130K cells in 14min, and 68K cells in 3min A Wolf; the API gained a preprocessing function neighbors() and a; class Neighbors() to which all basic graph computations are; delegated A Wolf. Warning; Upgrading to 1.0 isn’t fully backwards compatible in the following changes. the graph-based tools louvain(); dpt() draw_graph(); umap() diffmap(); paga() require prior computation of the graph:; sc.pp.neighbors(adata, n_neighbors=5); sc.tl.louvain(adata) instead of; previously sc.tl.louvain(adata, n_neighbors=5); install numba via conda install numba, which replaces cython; the default connectivity measure (dpt will look different using default; settings) changed. setting method='gauss' in sc.pp.neighbors uses; gauss kernel connectivities and reproduces the previous behavior,; see, for instance in the example paul15.; namings of returned annotation have changed for less bloated AnnData; objects, which means that some of the unstructu",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:48178,efficient,efficient,48178,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,1,['efficient'],['efficient']
Energy Efficiency,"gend_loc=""on data"", title="""", frameon=False, save="".pdf""; ). WARNING: saving figure to file figures/umap.pdf. Now that we annotated the cell types, let us visualize the marker genes. sc.pl.dotplot(adata, marker_genes, groupby=""leiden"");. There is also a very compact violin plot. sc.pl.stacked_violin(adata, marker_genes, groupby=""leiden"");. During the course of this analysis, the AnnData accumlated the following annotations. adata. AnnData object with n_obs × n_vars = 2638 × 1838; obs: 'n_genes', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'leiden'; var: 'gene_ids', 'n_cells', 'mt', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'highly_variable', 'means', 'dispersions', 'dispersions_norm', 'mean', 'std'; uns: 'hvg', 'leiden', 'leiden_colors', 'log1p', 'neighbors', 'pca', 'rank_genes_groups', 'umap'; obsm: 'X_pca', 'X_umap'; varm: 'PCs'; obsp: 'connectivities', 'distances'. # `compression='gzip'` saves disk space, and slightly slows down writing and subsequent reading; adata.write(results_file, compression=""gzip""). Get a rough overview of the file using h5ls, which has many options - for more details see here. The file format might still be subject to further optimization in the future. All reading functions will remain backwards-compatible, though.; If you want to share this file with people who merely want to use it for visualization, a simple way to reduce the file size is by removing the dense scaled and corrected data matrix. The file still contains the raw data used in the visualizations in adata.raw. adata.raw.to_adata().write(""./write/pbmc3k_withoutX.h5ad""). previous; Preprocessing and clustering. next; Integrating data using ingest and BBKNN. Contents; . Preprocessing; Principal component analysis; Computing the neighborhood graph; Embedding the neighborhood graph; Clustering the neighborhood graph; Finding marker genes. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering-2017.html:25842,reduce,reduce,25842,en/stable/tutorials/basics/clustering-2017.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering-2017.html,2,['reduce'],['reduce']
Energy Efficiency,"he null model is designed not to predict biological differences between cells. As a result, it will deviate from the observed counts starkly whenever genes differ in their expression between subpopulations – and produce large residuals in return. This will even work for genes that mark only small subpopulations. An example of detecting a rare subpopulation consisting of just 50 cells with Pearson residuals is presented in Lause et al. (2021).; As a result, the transformed data will show less technical variability, and biological signals from variable genes will be amplified. Therefore, downstream processing like PCA will be dominated by biological rather then technical variances. This is why it makes sense to use Pearson residuals as basis for downstream processing.; After reducing the dataset to the most variable genes in the previous steps, we will now transform our raw counts to residuals by calling normalize_pearson_residuals(adata). In our example pipeline, we then apply PCA to reduce the dataset to the most relevant dimensions. We visualize this reduced representation with t-SNE and perform Leiden clustering, which is again taken from the PBMC3k tutorial.; This is just one of many possible pipelines: After PCA, you could also use UMAP or other embeddings to inspect the data, and cluster the data with a different algorithm than Leiden. Preparations#; Because we will transform the raw data in adata.X to residuals in the next step, we first save a copy of the raw counts to adata.layers['raw']. Also, we save a depth-normalized and square-root transformed version of the data to adata.layers['sqrt_norm'], so we can use them for plotting normalized counts later. Further background on why to use the square-root transform here can be found in Wagner (2020). # keep raw and depth-normalized counts for later; adata_pbmc3k.layers[""raw""] = adata_pbmc3k.X.copy(); adata_pbmc3k.layers[""sqrt_norm""] = np.sqrt(; sc.pp.normalize_total(adata_pbmc3k, inplace=False)[""X""]; ). adata_pb",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:23535,reduce,reduce,23535,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,2,['reduce'],['reduce']
Energy Efficiency,"he observed counts starkly whenever genes differ in their expression between subpopulations – and produce large residuals in return. This will even work for genes that mark only small subpopulations. An example of detecting a rare subpopulation consisting of just 50 cells with Pearson residuals is presented in Lause et al. (2021).; As a result, the transformed data will show less technical variability, and biological signals from variable genes will be amplified. Therefore, downstream processing like PCA will be dominated by biological rather then technical variances. This is why it makes sense to use Pearson residuals as basis for downstream processing.; After reducing the dataset to the most variable genes in the previous steps, we will now transform our raw counts to residuals by calling normalize_pearson_residuals(adata). In our example pipeline, we then apply PCA to reduce the dataset to the most relevant dimensions. We visualize this reduced representation with t-SNE and perform Leiden clustering, which is again taken from the PBMC3k tutorial.; This is just one of many possible pipelines: After PCA, you could also use UMAP or other embeddings to inspect the data, and cluster the data with a different algorithm than Leiden. Preparations#; Because we will transform the raw data in adata.X to residuals in the next step, we first save a copy of the raw counts to adata.layers['raw']. Also, we save a depth-normalized and square-root transformed version of the data to adata.layers['sqrt_norm'], so we can use them for plotting normalized counts later. Further background on why to use the square-root transform here can be found in Wagner (2020). # keep raw and depth-normalized counts for later; adata_pbmc3k.layers[""raw""] = adata_pbmc3k.X.copy(); adata_pbmc3k.layers[""sqrt_norm""] = np.sqrt(; sc.pp.normalize_total(adata_pbmc3k, inplace=False)[""X""]; ). adata_pbmc10k.layers[""raw""] = adata_pbmc10k.X.copy(); adata_pbmc10k.layers[""sqrt_norm""] = np.sqrt(; sc.pp.normalize_total(",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:23605,reduce,reduced,23605,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,2,['reduce'],['reduced']
Energy Efficiency,"hr = 0.5; _ = axs[1].axhline(thr, c=""r""); _ = axs[0].axvline(thr, c=""r""). # Compare PAGA with and without prunning; fig, axs = plt.subplots(1, 2, figsize=(6, 3)); sc.pl.paga(adata, ax=axs[0], title=""PAGA"", show=False); sc.pl.paga(adata, ax=axs[1], title=""PAGA - prunned"", threshold=thr). PAGA layout#; The layout used in PAGA is optimised to correspond to the PAGA connectivties (edge weighs). However, sometimes we would wish to have a different layout. For this we can use the pos argument. PAGA layout corresponding to UMAP#; Set PAGA dot centers to the mean of the UMAP embedding values of cells from the corresponding groups. # Compare UMAP and PAGA layouts; fig, axs = plt.subplots(1, 2, figsize=(6, 3)); sc.pl.umap(; adata, color=""louvain"", ax=axs[0], show=False, title=""UMAP"", legend_loc=""on data""; ); sc.pl.paga(adata, ax=axs[1], title=""PAGA""). # Define PAGA positions based on the UMAP layout -; # for each cluster we use the mean of the UMAP positions from the cells in that cluster; pos = pd.DataFrame(adata.obsm[""X_umap""], index=adata.obs_names); pos[""group""] = adata.obs[adata.uns[""paga""][""groups""]]; pos = pos.groupby(""group"", observed=True).mean(). # Plot UMAP in the background; ax = sc.pl.umap(adata, show=False); # Plot PAGA ontop of the UMAP; sc.pl.paga(; adata,; color=""louvain"",; threshold=thr,; node_size_scale=1,; edge_width_scale=0.7,; pos=pos.values,; random_state=0,; ax=ax,; ). previous; Core plotting functions. next; Trajectories. Contents; . Talking to matplotlib; Figure and Axes objects; Using matplotlib Axes to customize plot alignment; Plot size; Adjust space between subplots; Adapt axes appearance. Labels and legends; Customizing legends; Annotating scatter plots. Colors; Discrete palettes; Continous palettes; Colorblind friendly palettes. UMAP; Coloring cell subset; Cell ordering; Optimising UMAP layout. PAGA; Prune PAGA edges; PAGA layout; PAGA layout corresponding to UMAP. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/advanced.html:36251,Adapt,Adapt,36251,en/stable/tutorials/plotting/advanced.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/advanced.html,1,['Adapt'],['Adapt']
Energy Efficiency,"ids'` in `sc.read_10x_mtx`. adata. AnnData object with n_obs × n_vars = 2700 × 32738; var: 'gene_ids'. Preprocessing#; Show those genes that yield the highest fraction of counts in each single cell, across all cells. sc.pl.highest_expr_genes(adata, n_top=20). normalizing counts per cell; finished (0:00:00). Basic filtering:. sc.pp.filter_cells(adata, min_genes=200); sc.pp.filter_genes(adata, min_cells=3). filtered out 19024 genes that are detected in less than 3 cells. Let’s assemble some information about mitochondrial genes, which are important for quality control.; Citing from “Simple Single Cell” workflows (Lun, McCarthy & Marioni, 2017):. High proportions are indicative of poor-quality cells (Islam et al. 2014; Ilicic et al. 2016), possibly because of loss of cytoplasmic RNA from perforated cells. The reasoning is that mitochondria are larger than individual transcript molecules and less likely to escape through tears in the cell membrane. With pp.calculate_qc_metrics, we can compute many metrics very efficiently. # annotate the group of mitochondrial genes as ""mt""; adata.var[""mt""] = adata.var_names.str.startswith(""MT-""); sc.pp.calculate_qc_metrics(; adata, qc_vars=[""mt""], percent_top=None, log1p=False, inplace=True; ). A violin plot of some of the computed quality measures:. the number of genes expressed in the count matrix; the total counts per cell; the percentage of counts in mitochondrial genes. sc.pl.violin(; adata,; [""n_genes_by_counts"", ""total_counts"", ""pct_counts_mt""],; jitter=0.4,; multi_panel=True,; ). Remove cells that have too many mitochondrial genes expressed or too many total counts:. sc.pl.scatter(adata, x=""total_counts"", y=""pct_counts_mt""); sc.pl.scatter(adata, x=""total_counts"", y=""n_genes_by_counts""). Actually do the filtering by slicing the AnnData object. adata = adata[adata.obs.n_genes_by_counts < 2500, :]; adata = adata[adata.obs.pct_counts_mt < 5, :].copy(). Total-count normalize (library-size correct) the data matrix \(\mathbf{X}\) to 10",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering-2017.html:12944,efficient,efficiently,12944,en/stable/tutorials/basics/clustering-2017.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering-2017.html,2,['efficient'],['efficiently']
Energy Efficiency,"ip all computation, and these cases will kick off compute for all the delayed operations immediately. %%time; adata.layers[""counts""] = adata.X.copy() # Making sure we keep access to the raw counts; sc.pp.normalize_total(adata, target_sum=1e4). CPU times: user 7.1 ms, sys: 31 μs, total: 7.13 ms; Wall time: 7.49 ms. %%time; sc.pp.log1p(adata). CPU times: user 3.14 ms, sys: 2.03 ms, total: 5.17 ms; Wall time: 4.88 ms. Highly variable genes needs to add entries into obs, which currently does not support lazy column. So computation will occur immediately on call. %%time; sc.pp.highly_variable_genes(adata). CPU times: user 3.46 s, sys: 509 ms, total: 3.97 s; Wall time: 50 s. PCA currently does not support sparse data. So we will need to densify the expression matrix before passing it in. However, as we are working with only a subset of the data at a time, we are able to perform this operation with a lower memory overhead.; As this is a still a significant increase in memory usage per chunk, we will need to reduce the number of observations present in each chunk. adata.layers[""dense""] = adata.X.rechunk((DENSE_CHUNK_SIZE, -1)).map_blocks(; lambda x: x.toarray(), dtype=adata.X.dtype, meta=np.array([]); ). %%time; sc.pp.pca(adata, layer=""dense""). CPU times: user 9.31 s, sys: 1.19 s, total: 10.5 s; Wall time: 1min 27s. While most of the PCA computation runs immediately, the last step (computing the observation loadings) is lazy, so must be triggered manually to avoid recomputation. %%time; adata.obsm[""X_pca""] = adata.obsm[""X_pca""].compute(). CPU times: user 6.72 s, sys: 1.36 s, total: 8.08 s; Wall time: 1min 15s. adata. AnnData object with n_obs × n_vars = 1462702 × 27714; obs: 'celltype', 'majorType', 'City', 'sampleID', 'donor_id', 'Sample type', 'CoVID-19 severity', 'Sample time', 'Sampling day (Days after symptom onset)', 'BCR single cell sequencing', 'TCR single cell sequencing', 'Outcome', 'Comorbidities', 'COVID-19-related medication and anti-microbials', 'Leukocytes [G ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/dask.html:15433,reduce,reduce,15433,en/stable/tutorials/experimental/dask.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/dask.html,2,['reduce'],['reduce']
Energy Efficiency,"ipped:. If None, residuals are clipped to the interval [-sqrt(n_obs), sqrt(n_obs)], where n_obs is the number of cells in the dataset (default behavior).; If any scalar c, residuals are clipped to the interval [-c, c]. Set clip=np.inf for no clipping. n_top_genes int (default: 1000)Number of highly-variable genes to keep. Mandatory if flavor='seurat_v3' or; flavor='pearson_residuals'. batch_key str | None (default: None)If specified, highly-variable genes are selected within each batch separately; and merged. This simple process avoids the selection of batch-specific genes; and acts as a lightweight batch correction method. Genes are first sorted by; how many batches they are a HVG. If flavor='pearson_residuals', ties are; broken by the median rank (across batches) based on within-batch residual; variance. chunksize int (default: 1000)If flavor='pearson_residuals', this dertermines how many genes are processed at; once while computing the residual variance. Choosing a smaller value will reduce; the required memory. n_comps int | None (default: 50)Number of principal components to compute in the PCA step. random_state float | None (default: 0)Random seed for setting the initial states for the optimization in the PCA step. kwargs_pca dict (default: {})Dictionary of further keyword arguments passed on to scanpy.pp.pca(). check_values bool (default: True)If True, checks if counts in selected layer are integers as expected by this; function, and return a warning if non-integers are found. Otherwise, proceed; without checking. Setting this to False can speed up code for large datasets. inplace bool (default: True)If True, update adata with results. Otherwise, return results. See below for; details of what is returned. Return type:; tuple[AnnData, DataFrame] | None. Returns:; If inplace=False, separately returns the gene selection results (as; DataFrame) and Pearson residual-based PCA results (as; AnnData). If inplace=True, updates adata with the; following fields for gene ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.recipe_pearson_residuals.html:11297,reduce,reduce,11297,en/stable/generated/scanpy.experimental.pp.recipe_pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.recipe_pearson_residuals.html,1,['reduce'],['reduce']
Energy Efficiency,"ja (2019) introduced a heuristic that clips all residuals to +-sqrt(n_cells). This is the default behavior of all functions for Pearson residuals discussed here. If desired, a different threshold can be set using the clip argument. If no clipping is desired, use clip=np.Inf. chunksize and best practice to obtain Pearson residuals for large datasets#; Raw scRNA UMI counts are usually sparse, and can thus be stored efficiently for large datasets. However, when the count matrix is transformed to Pearson residuals, the data becomes dense. To avoid memory problems, we recommend that you reduce the size of your count matrix by gene selection, before running normalize_pearson_residuals(adata) on the reduced data. To perform RAM-efficient gene selection, use highly_variable_genes(adata,flavor='pearson_residuals') with the chunksize argument: This will still use Pearson residual variance to identify variable genes, but won’t compute all residuals at once. Reduce the chunksize as needed if you run into RAM issues during gene selection. Note that a very small chunksize will slow down the computation, so try to set it as large as possible with your resources.; As an example, we used chunksize=1000 when processing a dataset with 2 million cells in a machine with 500 GB RAM. For smaller machines, we would recommend to reduce this below 100. Wrapper functions for Pearson residuals preprocessing#; The scanpy.experimental.pp module also ships two wrappers that run multiple pre-processing steps at once:. sc.experimental.pp.normalize_pearson_residuals_pca() performs normalization by Pearson residuals and PCA in one go. This function is helpful to quickly obtain a Pearson residual-based data representation when highly variable genes are already defined, as only those are used by default.; sc.experimental.pp.recipe_pearson_residuals() performs gene selection and normalization by Pearson residuals, and PCA on top. This is intended to make the full Pearson residual preprocessing available ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:29409,Reduce,Reduce,29409,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,1,['Reduce'],['Reduce']
Energy Efficiency,"l.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.read_h5ad. Contents . read_h5ad(). scanpy.read_h5ad#. scanpy.read_h5ad(filename, backed=None, *, as_sparse=(), as_sparse_fmt=<class 'scipy.sparse._csr.csr_matrix'>, chunk_size=6000)[source]#; Read .h5ad-formatted hdf5 file. Parameters:. filename str | PathFile name of data file. backed Union[Literal['r', 'r+'], bool, None] (default: None)If 'r', load AnnData in backed mode; instead of fully loading it into memory (memory mode).; If you want to modify backed attributes of the AnnData object,; you need to choose 'r+'.; Currently, backed only support updates to X. That means any; changes to other slots like obs will not be written to disk in; backed mode. If you would like save changes made to these slots; of a backed AnnData, write them to a new file; (see write()). For an example, see; [here] (https://anndata-tutorials.readthedocs.io/en/latest/getting-started.html#Partial-reading-of-large-data). as_sparse Sequence[str] (default: ())If an array was saved as dense, passing its name here will read it as; a sparse_matrix, by chunk of size chunk_size. as_sparse_fmt type[spmatrix] (default: <class 'scipy.sparse._csr.csr_matrix'>)Sparse format class to read elements from as_sparse in as. chunk_size int (default: 6000)Used only when loading sparse dataset that is stored as dense.; Loading iterates through chunks of the dataset of this row size; until it reads the whole dataset.; Higher size means higher memory consumption and higher (to a point); loading speed. Return type:; AnnData. previous; scanpy.read_visium. next; scanpy.read_csv. Contents; . read_h5ad(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.read_h5ad.html:10657,consumption,consumption,10657,en/stable/generated/scanpy.read_h5ad.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.read_h5ad.html,1,['consumption'],['consumption']
Energy Efficiency,"lowing is just as well possible for a UMAP. sc.tl.draw_graph(adata, init_pos=""paga""). drawing single-cell graph using layout 'fa'; finished: added; 'X_draw_graph_fa', graph_drawing coordinates (adata.obsm) (0:00:13). Now we can see all marker genes also at single-cell resolution in a meaningful layout. sc.pl.draw_graph(; adata, color=[""louvain_anno"", ""Itga2b"", ""Prss34"", ""Cma1""], legend_loc=""on data""; ). Choose the colors of the clusters a bit more consistently. pl.figure(figsize=(8, 2)); for i in range(28):; pl.scatter(i, 1, c=sc.pl.palettes.zeileis_28[i], s=200); pl.show(). zeileis_colors = np.array(sc.pl.palettes.zeileis_28); new_colors = np.array(adata.uns[""louvain_anno_colors""]). new_colors[[16]] = zeileis_colors[[12]] # Stem colors / green; new_colors[[10, 17, 5, 3, 15, 6, 18, 13, 7, 12]] = zeileis_colors[ # Ery colors / red; [5, 5, 5, 5, 11, 11, 10, 9, 21, 21]; ]; new_colors[[20, 8]] = zeileis_colors[[17, 16]] # Mk early Ery colors / yellow; new_colors[[4, 0]] = zeileis_colors[[2, 8]] # lymph progenitors / grey; new_colors[[22]] = zeileis_colors[[18]] # Baso / turquoise; new_colors[[19, 14, 2]] = zeileis_colors[[6, 6, 6]] # Neu / light blue; new_colors[[24, 9, 1, 11]] = zeileis_colors[[0, 0, 0, 0]] # Mo / dark blue; new_colors[[21, 23]] = zeileis_colors[[25, 25]] # outliers / grey. adata.uns[""louvain_anno_colors""] = new_colors. And add some white space to some cluster names. The layout shown here differs from the one in the paper, which can be found here. These differences, however, are only cosmetic. We had to change the layout as we moved from a randomized PCA and float32 to float64 precision. sc.pl.paga_compare(; adata,; threshold=0.03,; title="""",; right_margin=0.2,; size=10,; edge_width_scale=0.5,; legend_fontsize=12,; fontsize=12,; frameon=False,; edges=True,; save=True,; ). --> added 'pos', the PAGA positions (adata.uns['paga']); WARNING: saving figure to file figures/paga_compare.pdf. Reconstructing gene changes along PAGA paths for a given set of genes",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/trajectories/paga-paul15.html:16809,green,green,16809,en/stable/tutorials/trajectories/paga-paul15.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/trajectories/paga-paul15.html,2,['green'],['green']
Energy Efficiency,"map; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.pp.scale. Contents . scale(). scanpy.pp.scale#. scanpy.pp.scale(data, *, zero_center=True, max_value=None, copy=False, layer=None, obsm=None, mask_obs=None)[source]#; Scale data to unit variance and zero mean. Note; Variables (genes) that do not display any variation (are constant across; all observations) are retained and (for zero_center==True) set to 0; during this operation. In the future, they might be set to NaNs. Parameters:. data AnnData | spmatrix | ndarray | ArrayThe (annotated) data matrix of shape n_obs × n_vars.; Rows correspond to cells and columns to genes. zero_center bool (default: True)If False, omit zero-centering variables, which allows to handle sparse; input efficiently. max_value float | None (default: None)Clip (truncate) to this value after scaling. If None, do not clip. copy bool (default: False)Whether this function should be performed inplace. If an AnnData object; is passed, this also determines if a copy is returned. layer str | None (default: None)If provided, which element of layers to scale. obsm str | None (default: None)If provided, which element of obsm to scale. mask_obs ndarray[Any, dtype[bool]] | str | None (default: None)Restrict both the derivation of scaling parameters and the scaling itself; to a certain set of observations. The mask is specified as a boolean array; or a string referring to an array in obs.; This will transform data from csc to csr format if issparse(data). Return type:; AnnData | spmatrix | ndarray | Array | None. Returns:; Returns None if copy=False, else returns an updated AnnData object. Sets the following fields:. adata.X | adata.layers[layer]numpy.",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.scale.html:9920,efficient,efficiently,9920,en/stable/generated/scanpy.pp.scale.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.scale.html,1,['efficient'],['efficiently']
Energy Efficiency,"of vmin and vmax from the cenetr; # Adapted from https://stackoverflow.com/a/50003503; class MidpointNormalize(mcolors.Normalize):; def __init__(self, vmin=None, vmax=None, midpoint=0, clip=False):; self.midpoint = midpoint; mcolors.Normalize.__init__(self, vmin, vmax, clip). def __call__(self, value, clip=None):; value = np.array(value).astype(float); normalized_min = max(; 0.0,; 0.5; * (1.0 - abs((self.midpoint - self.vmin) / (self.midpoint - self.vmax))),; ); normalized_max = min(; 1.0,; 0.5; * (1.0 + abs((self.vmax - self.midpoint) / (self.midpoint - self.vmin))),; ); normalized_mid = 0.5; x, y = (; [self.vmin, self.midpoint, self.vmax],; [normalized_min, normalized_mid, normalized_max],; ); return np.ma.masked_array(np.interp(value, x, y)). # Add padding arround vmin and vmax as Colorbar sets value limits to round numbers below and; # above the vmin and vmax, respectively, which means that they can not be assigned the correct; # color with our nomalisation function that is limited to vmin and vmax; # However, this padding reduces the dynamic range as we set a broad padding and; # then later discard values that are not needed for the rounding up and down; # of the vmin and vmax on the Colorbar, respectively; vmin = adata.obs[""B_cell_score""].min(); vmax = adata.obs[""B_cell_score""].max(); vpadding = (vmax - vmin) * 0.2; norm = MidpointNormalize(vmin=vmin - vpadding, vmax=vmax + vpadding, midpoint=0); # Plot umap; fig = sc.pl.umap(; adata,; color=""B_cell_score"",; cmap=""coolwarm"",; s=20,; norm=norm,; return_fig=True,; show=False,; ); # Adjust Colorbar ylim to be just outside of vmin,vmax and not far outside of this range; # as the padding we set initially may be too broad; cmap_yticklabels = np.array([t._y for t in fig.axes[1].get_yticklabels()]); fig.axes[1].set_ylim(; max(cmap_yticklabels[cmap_yticklabels < vmin]),; min(cmap_yticklabels[cmap_yticklabels > vmax]),; ). adata.obs.drop(""B_cell_score"", axis=1, inplace=True). Colorblind friendly palettes#; There are dif",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/advanced.html:29269,reduce,reduces,29269,en/stable/tutorials/plotting/advanced.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/advanced.html,2,['reduce'],['reduces']
Energy Efficiency,"orting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .md. .pdf. Usage Principles. Contents . Workflow; AnnData. Usage Principles#; Import Scanpy as:; import scanpy as sc. Workflow#; The typical workflow consists of subsequent calls of data analysis tools; in sc.tl, e.g.:; sc.tl.umap(adata, **tool_params) # embed a neighborhood graph of the data using UMAP. where adata is an AnnData object.; Each of these calls adds annotation to an expression matrix X,; which stores n_obs observations (cells) of n_vars variables (genes).; For each tool, there typically is an associated plotting function in sc.pl:; sc.pl.umap(adata, **plotting_params). If you pass show=False, a Axes instance is returned; and you have all of matplotlib’s detailed configuration possibilities.; To facilitate writing memory-efficient pipelines, by default,; Scanpy tools operate inplace on adata and return None –; this also allows to easily transition to out-of-memory pipelines.; If you want to return a copy of the AnnData object; and leave the passed adata unchanged, pass copy=True or inplace=False. AnnData#; Scanpy is based on anndata, which provides the AnnData class. At the most basic level, an AnnData object adata stores; a data matrix adata.X, annotation of observations; adata.obs and variables adata.var as pd.DataFrame and unstructured; annotation adata.uns as dict. Names of observations and; variables can be accessed via adata.obs_names and adata.var_names,; respectively. AnnData objects can be sliced like; dataframes, for example, adata_subset = adata[:, list_of_gene_names].; For more, see this blog post.; To read a data file to an AnnData object, call:; adata = sc.read(filename). to initialize an AnnData object. Possibly add further annotation using, e.g., pd.read_csv:; import pandas as pd; anno = pd.read_csv(filename_sample_annotation); adata.obs['cell_grou",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/usage-principles.html:9957,efficient,efficient,9957,en/stable/usage-principles.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/usage-principles.html,1,['efficient'],['efficient']
Energy Efficiency,"persion is controlled by the argument theta, where a smaller theta corresponds to larger overdispersion. Lause et al. (2021) recommend using the default theta=100, as noise in negative control data without biological variation was fit well by this value. If Poisson behavior is desired, the overdispersion parameter can instead be set to infinity (theta=np.Inf). Clipping threshold clip#; When a gene is expressed in only very few cells, and missing in all others, it will generate very large residuals for these few cells. In turn, these cells might dominate in downstream processing. To avoid such unbalanced behavior, Hafemeister & Satija (2019) introduced a heuristic that clips all residuals to +-sqrt(n_cells). This is the default behavior of all functions for Pearson residuals discussed here. If desired, a different threshold can be set using the clip argument. If no clipping is desired, use clip=np.Inf. chunksize and best practice to obtain Pearson residuals for large datasets#; Raw scRNA UMI counts are usually sparse, and can thus be stored efficiently for large datasets. However, when the count matrix is transformed to Pearson residuals, the data becomes dense. To avoid memory problems, we recommend that you reduce the size of your count matrix by gene selection, before running normalize_pearson_residuals(adata) on the reduced data. To perform RAM-efficient gene selection, use highly_variable_genes(adata,flavor='pearson_residuals') with the chunksize argument: This will still use Pearson residual variance to identify variable genes, but won’t compute all residuals at once. Reduce the chunksize as needed if you run into RAM issues during gene selection. Note that a very small chunksize will slow down the computation, so try to set it as large as possible with your resources.; As an example, we used chunksize=1000 when processing a dataset with 2 million cells in a machine with 500 GB RAM. For smaller machines, we would recommend to reduce this below 100. Wrapper funct",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:28865,efficient,efficiently,28865,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,2,['efficient'],['efficiently']
Energy Efficiency,"pression and other variables. Identification of clusters based on known marker genes; dotplot; violin plot; stacked-violin plot; matrixplot. Combining plots in subplots; Heatmaps; Tracksplot; Visualization of marker genes; Visualize marker genes using dotplot; Focusing on particular groups. Visualize marker genes using matrixplot; Visualize marker genes using stacked violin plots; Visualize marker genes using heatmap; Visualize marker genes using tracksplot. Comparison of marker genes using split violin plots; Dendrogram options; Plot correlation. Core plotting functions#; Author: Fidel Ramírez; This tutorial explores the visualization possibilities of scanpy and is divided into three sections:. Scatter plots for embeddings (eg. UMAP, t-SNE); Identification of clusters using known marker genes; Visualization of differentially expressed genes. In this tutorial, we will use a dataset from 10x containing 68k cells from PBMC. Scanpy, includes in its distribution a reduced sample of this dataset consisting of only 700 cells and 765 highly variable genes. This dataset has been already preprocessed and UMAP computed.; In this tutorial, we will also use the following literature markers:. B-cell: CD79A, MS4A1; Plasma: IGJ (JCHAIN); T-cell: CD3D; NK: GNLY, NKG7; Myeloid: CST3, LYZ; Monocytes: FCGR3A; Dendritic: FCER1A. Scatter plots for embeddings#; With scanpy, scatter plots for tSNE, UMAP and several other embeddings are readily available using the sc.pl.tsne, sc.pl.umap etc. functions. See here the list of options.; Those functions access the data stored in adata.obsm. For example sc.pl.umap uses the information stored in adata.obsm['X_umap']. For more flexibility, any key stored in adata.obsm can be used with the generic function sc.pl.embedding. import scanpy as sc; from matplotlib.pyplot import rc_context. sc.set_figure_params(dpi=100, color_map=""viridis_r""); sc.settings.verbosity = 0; sc.logging.print_header(). scanpy==1.10.0rc2.dev6+g14555ba4.d20240226 anndata==0.11.0",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/core.html:10318,reduce,reduced,10318,en/stable/tutorials/plotting/core.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/core.html,2,['reduce'],['reduced']
Energy Efficiency,"prune bool (default: False)prune=False, symmetrize by taking the average between the graph and its; transpose. prune=True, symmetrize by taking the product between the graph; and its transpose. min_cluster_size int (default: 10)Cells that end up in a cluster smaller than min_cluster_size are considered; outliers and are assigned to -1 in the cluster labels. jaccard bool (default: True)If True, use Jaccard metric between k-neighborhoods to build graph. If; False, use a Gaussian kernel. primary_metric Literal['euclidean', 'manhattan', 'correlation', 'cosine'] (default: 'euclidean')Distance metric to define nearest neighbors. Note that performance will be; slower for correlation and cosine. n_jobs int (default: -1)Nearest Neighbors and Jaccard coefficients will be computed in parallel using; n_jobs. If 1 is given, no parallelism is used. If set to -1, all CPUs are used.; For n_jobs below -1, n_cpus + 1 + n_jobs are used. q_tol float (default: 0.001)Tolerance, i.e. precision, for monitoring modularity optimization. louvain_time_limit int (default: 2000)Maximum number of seconds to run modularity optimization. If exceeded the best; result so far is returned. nn_method Literal['kdtree', 'brute'] (default: 'kdtree')Whether to use brute force or kdtree for nearest neighbor search.; For very large high-dimensional data sets, brute force, with parallel; computation, performs faster than kdtree. partition_type type[MutableVertexPartition] | None (default: None)Defaults to RBConfigurationVertexPartition. For the; available options, consult the documentation for; find_partition(). resolution_parameter float (default: 1)A parameter value controlling the coarseness of the clustering in Leiden. Higher; values lead to more clusters. Set to None if overriding partition_type to; one that does not accept a resolution_parameter. n_iterations int (default: -1)Number of iterations to run the Leiden algorithm. If the number of iterations is; negative, the Leiden algorithm is run until an it",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.phenograph.html:11740,monitor,monitoring,11740,en/stable/external/generated/scanpy.external.tl.phenograph.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.phenograph.html,2,['monitor'],['monitoring']
Energy Efficiency,"r by modifying them directly. rcParams[""figure.figsize""] = (2, 2); sc.pl.umap(adata, color=""bulk_labels""); # Set back to value selected above; rcParams[""figure.figsize""] = FIGSIZE. We can set rcParams for a single plot with a context manager which won’t change the setting for future plots. with plt.rc_context({""figure.figsize"": (5, 5)}):; sc.pl.umap(adata, color=""bulk_labels""). We can also create an Axes object with a predefined size and pass it to a scanpy plotting function. fig, ax = plt.subplots(figsize=(4, 4)); sc.pl.umap(adata, color=""bulk_labels"", ax=ax). The figsize is divided between all Axes and spaces between them. Thus, if we have multiple Axes (columns or rows) we must accordingly increase figsize.; However, if we do not pass Axes objects to the scanpy embedding function it will automatically create individual Axes with the size of the current global figsize (as specified by e.g. matplotlib figure.figsize). ncol = 2; nrow = 1; figsize = 3; wspace = 1; # Adapt figure size based on number of rows and columns and added space between them; # (e.g. wspace between columns); fig, axs = plt.subplots(; nrow, ncol, figsize=(ncol * figsize + (ncol - 1) * wspace * figsize, nrow * figsize); ); plt.subplots_adjust(wspace=wspace); sc.pl.umap(adata, color=""louvain"", ax=axs[0], show=False); sc.pl.umap(adata, color=""phase"", ax=axs[1]). Adjust space between subplots#; When plotting multiple plots (e.g. with embedding) in the same row or column it may happen that the legend overlaps with the neighbouring plot. This can be overcomed by setting wspace (width) or hspace (height). These parameters can be likewise used when creating Axes for plotting (see the above section on using matplotlib Axes). # Default, legend is overlapping; sc.pl.umap(adata, color=[""bulk_labels"", ""phase""]). # Increase gap size between plots; sc.pl.umap(adata, color=[""bulk_labels"", ""phase""], wspace=1). Adapt axes appearance#; We can further modify the plot object (e.g. Axes) to change axis text, title siz",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/advanced.html:18510,Adapt,Adapt,18510,en/stable/tutorials/plotting/advanced.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/advanced.html,1,['Adapt'],['Adapt']
Energy Efficiency,"rrect; scanpy.external.pp.scanorama_integrate; scanpy.external.pp.hashsolo; scanpy.external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .ipynb. .pdf. Customizing Scanpy plots. Contents . Talking to matplotlib; Figure and Axes objects; Using matplotlib Axes to customize plot alignment; Plot size; Adjust space between subplots; Adapt axes appearance. Labels and legends; Customizing legends; Annotating scatter plots. Colors; Discrete palettes; Continous palettes; Colorblind friendly palettes. UMAP; Coloring cell subset; Cell ordering; Optimising UMAP layout. PAGA; Prune PAGA edges; PAGA layout; PAGA layout corresponding to UMAP. Customizing Scanpy plots#; This is an advanced tutorial on customizing scanpy plots. For an introduction to scanpy plotting functions please see the introductory tutorial. import scanpy as sc; import pandas as pd; import numpy as np. import matplotlib.pyplot as plt; import seaborn as sns; import matplotlib.colors as mcolors. # Inital setting for plot size; from matplotlib import rcParams. FIGSIZE = (3, 3); rcParams[""figure.figsize""] = FIGSIZE. adata = sc.datasets.pbmc68k_reduced(). Talking to matplotlib#; This section provides general information on how to customize plots.; scanpy plots are based on matplotlib objects, which w",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/advanced.html:9414,Adapt,Adapt,9414,en/stable/tutorials/plotting/advanced.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/advanced.html,1,['Adapt'],['Adapt']
Energy Efficiency,"s). You can convert from sparse to dense chunks via:; X = X.map_blocks(lambda x: x.toarray(), dtype=X.dtype, meta=np.array([])). And in reverse:; X = X.map_blocks(sparse.csr_matrix). Note that you will likely have to work with smaller chunks when doing this, via a rechunking operation. We suggest using a factor of the larger chunk size to achieve the most efficient rechunking. SPARSE_CHUNK_SIZE = 100_000; DENSE_CHUNK_SIZE = 10_000. Dask provides extensive tooling for monitoring your computation. You can access that via the dashboard started when using any of their distributed clusters. client. . Client; Client-d3384ee9-58e9-11ef-9bda-3868dd0e66a0. Connection method: Cluster object; Cluster type: distributed.LocalCluster. Dashboard: http://127.0.0.1:8787/status. Cluster Info. LocalCluster; 815df81e. Dashboard: http://127.0.0.1:8787/status. Workers: 3; . Total threads: 18; . Total memory: 128.00 GiB; . Status: running; Using processes: True. Scheduler Info. . Scheduler; Scheduler-d580fb0c-35e1-45f0-9394-837f45e7976c. Comm: tcp://127.0.0.1:37191; . Workers: 3; . Dashboard: http://127.0.0.1:8787/status. Total threads: 18; . Started: Just now; . Total memory: 128.00 GiB; . Workers. . Worker: 0. Comm: tcp://127.0.0.1:36805; . Total threads: 6; . Dashboard: http://127.0.0.1:45909/status. Memory: 42.67 GiB; . Nanny: tcp://127.0.0.1:39225; . Local directory: /tmp/dask-scratch-space/worker-pz4wcxmk; . . Worker: 1. Comm: tcp://127.0.0.1:35183; . Total threads: 6; . Dashboard: http://127.0.0.1:43387/status. Memory: 42.67 GiB; . Nanny: tcp://127.0.0.1:42555; . Local directory: /tmp/dask-scratch-space/worker-a11nkkx1; . . Worker: 2. Comm: tcp://127.0.0.1:36599; . Total threads: 6; . Dashboard: http://127.0.0.1:39033/status. Memory: 42.67 GiB; . Nanny: tcp://127.0.0.1:45463; . Local directory: /tmp/dask-scratch-space/worker-mcr71xvg; . We’ll convert the X representation to dask using anndata.experimental.read_elem_as_dask.; The file we’ve retrieved from cellxgene has already been p",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/dask.html:12673,Schedul,Scheduler,12673,en/stable/tutorials/experimental/dask.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/dask.html,2,['Schedul'],"['Scheduler', 'Scheduler-']"
Energy Efficiency,"scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.pp.combat. Contents . combat(). scanpy.pp.combat#. scanpy.pp.combat(adata, key='batch', *, covariates=None, inplace=True)[source]#; ComBat function for batch effect correction [Johnson et al., 2006, Leek et al., 2017, Pedersen, 2012].; Corrects for batch effects by fitting linear models, gains statistical power; via an EB framework where information is borrowed across genes.; This uses the implementation combat.py [Pedersen, 2012]. Parameters:. adata AnnDataAnnotated data matrix. key str (default: 'batch')Key to a categorical annotation from obs; that will be used for batch effect removal. covariates Collection[str] | None (default: None)Additional covariates besides the batch variable such as adjustment; variables or biological condition. This parameter refers to the design; matrix X in Equation 2.1 in Johnson et al. [2006] and to the mod argument in; the original combat function in the sva R package.; Note that not including covariates may introduce bias or lead to the; removal of biological signal in unbalanced designs. inplace bool (default: True)Whether to replace adata.X or to return the corrected data. Return type:; ndarray | None. Returns:; Returns numpy.ndarray if inplace=True, else returns None and sets the following field in the adata object:. adata.Xnumpy.ndarray (dtype flo",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pp.combat.html:9539,power,power,9539,en/stable/api/generated/scanpy.pp.combat.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pp.combat.html,1,['power'],['power']
Energy Efficiency,"sing key=dendrogram_leiden_res_0.50). Running `sc.tl.dendrogram` with default parameters. For fine tuning it is recommended to run `sc.tl.dendrogram` independently. We can then use these genes to figure out what cell types we’re looking at. For example, Cluster 7 is expressing NKG7 and GNLY, suggesting these are NK cells.; To create your own plots, or use a more automated approach, the differentially expressed genes can be extracted in a convenient format with scanpy.get.rank_genes_groups_df(). sc.get.rank_genes_groups_df(adata, group=""7"").head(5). names; scores; logfoldchanges; pvals; pvals_adj. 0; NKG7; 35.376785; 6.544684; 3.885326e-274; 9.102153e-270. 1; KLRD1; 33.815022; 5.840619; 1.186288e-250; 1.389558e-246. 2; GNLY; 33.775005; 7.383827; 4.592379e-250; 3.586189e-246. 3; CST7; 33.003643; 5.238780; 7.201598e-239; 4.217796e-235. 4; PRF1; 32.752277; 5.397196; 2.817787e-235; 1.320246e-231. dc_cluster_genes = sc.get.rank_genes_groups_df(adata, group=""7"").head(5)[""names""]; sc.pl.umap(; adata,; color=[*dc_cluster_genes, ""leiden_res_0.50""],; legend_loc=""on data"",; frameon=False,; ncols=3,; ). You may have noticed that the p-values found here are extremely low. This is due to the statistical test being performed considering each cell as an independent sample. For a more conservative approach you may want to consider “pseudo-bulking” your data by sample (e.g. sc.get.aggregate(adata, by=[""sample"", ""cell_type""], func=""sum"", layer=""counts"")) and using a more powerful differential expression tool, like pydeseq2. previous; Basics. next; Preprocessing and clustering 3k PBMCs (legacy workflow). Contents; . Quality Control; Doublet detection. Normalization; Feature selection; Dimensionality Reduction; Nearest neighbor graph constuction and visualization; Clustering; Re-assess quality control and cell filtering; Manual cell-type annotation; Marker gene set; Differentially-expressed Genes as Markers. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering.html:25022,power,powerful,25022,en/stable/tutorials/basics/clustering.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering.html,2,['power'],['powerful']
Energy Efficiency,"st='euclidean', mds_dist='euclidean', mds='metric', n_jobs=None, random_state=None, verbose=None, copy=False, **kwargs)[source]#; PHATE [Moon et al., 2019].; Potential of Heat-diffusion for Affinity-based Trajectory Embedding (PHATE); embeds high dimensional single-cell data into two or three dimensions for; visualization of biological progressions.; For more information and access to the object-oriented interface, read the; PHATE documentation. For; tutorials, bug reports, and R/MATLAB implementations, visit the PHATE; GitHub page. For help; using PHATE, go here. Parameters:. adata AnnDataAnnotated data matrix. n_components int (default: 2)number of dimensions in which the data will be embedded. k int (default: 5)number of nearest neighbors on which to build kernel. a int (default: 15)sets decay rate of kernel tails.; If None, alpha decaying kernel is not used. n_landmark int (default: 2000)number of landmarks to use in fast PHATE. t int | str (default: 'auto')power to which the diffusion operator is powered; sets the level of diffusion. If ‘auto’, t is selected; according to the knee point in the Von Neumann Entropy of; the diffusion operator. gamma float (default: 1.0)Informational distance constant between -1 and 1.; gamma=1 gives the PHATE log potential, gamma=0 gives; a square root potential. n_pca int (default: 100)Number of principal components to use for calculating; neighborhoods. For extremely large datasets, using; n_pca < 20 allows neighborhoods to be calculated in; log(n_samples) time. knn_dist str (default: 'euclidean')recommended values: ‘euclidean’ and ‘cosine’; Any metric from scipy.spatial.distance can be used; distance metric for building kNN graph. mds_dist str (default: 'euclidean')recommended values: ‘euclidean’ and ‘cosine’; Any metric from scipy.spatial.distance can be used; distance metric for MDS. mds Literal['classic', 'metric', 'nonmetric'] (default: 'metric')Selects which MDS algorithm is used for dimensionality reduction. n_jobs int | ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.phate.html:10399,power,power,10399,en/stable/external/generated/scanpy.external.tl.phate.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.phate.html,4,['power'],"['power', 'powered']"
Energy Efficiency,"ting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.external.pp.magic. Contents . magic(). scanpy.external.pp.magic#. scanpy.external.pp.magic(adata, name_list=None, *, knn=5, decay=1, knn_max=None, t=3, n_pca=100, solver='exact', knn_dist='euclidean', random_state=None, n_jobs=None, verbose=False, copy=None, **kwargs)[source]#; Markov Affinity-based Graph Imputation of Cells (MAGIC) API [van Dijk et al., 2018].; MAGIC is an algorithm for denoising and transcript recover of single cells; applied to single-cell sequencing data. MAGIC builds a graph from the data; and uses diffusion to smooth out noise and recover the data manifold.; The algorithm implemented here has changed primarily in two ways; compared to the algorithm described in van Dijk et al. [2018]. Firstly, we use; the adaptive kernel described in Moon et al. [2019] for; improved stability. Secondly, data diffusion is applied; in the PCA space, rather than the data space, for speed and; memory improvements.; More information and bug reports; here. For help, visit; <https://krishnaswamylab.org/get-help>. Parameters:. adata AnnDataAn anndata file with .raw attribute representing raw counts. name_list Union[Literal['all_genes', 'pca_only'], Sequence[str], None] (default: None)Denoised genes to return. The default 'all_genes'/None; may require a large amount of memory if the input data is sparse.; Another possibility is 'pca_only'. knn int (default: 5)number of nearest neighbors on which to build kernel. decay float | None (default: 1)sets decay rate of kernel tails.; If None, alpha decaying kernel is not used. knn_max int | None (default: None)maximum number of nearest neighbors with nonzero connection.; If None, will be set to 3 * knn. t Union[Literal['auto'], int] (default: 3)power to which the diffusion opera",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.magic.html:9978,adapt,adaptive,9978,en/stable/generated/scanpy.external.pp.magic.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.magic.html,1,['adapt'],['adaptive']
Energy Efficiency,"tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .md. .pdf. Scanpy – Single-Cell Analysis in Python. Contents . News; rapids-singlecell brings scanpy to the GPU! 2024-03-18; Scanpy hits 100 contributors! 2022-03-31; New community channels 2022-03-31; Toolkit for spatial (squidpy) and multimodal (muon) published 2022-02-01. Scanpy – Single-Cell Analysis in Python#; Scanpy is a scalable toolkit for analyzing single-cell gene expression data; built jointly with anndata. It includes; preprocessing, visualization, clustering, trajectory inference and differential; expression testing. The Python-based implementation efficiently deals with; datasets of more than one million cells.; Discuss usage on the scverse Discourse. Read the documentation.; If you’d like to contribute by opening an issue or creating a pull request, please take a look at our contribution guide.; scanpy is part of the scverse project (website, governance) and is fiscally sponsored by NumFOCUS.; If you like scverse and want to support our mission, please consider making a donation to support our efforts. Installation ; New to scanpy? Check out the installation guide. Installation. Tutorials ; The tutorials walk you through real-world applications of scanpy. Tutorials. API reference ; The API reference contains a detailed description of; the scanpy API. API. Discussion ; Need help? Reach out on our forum to get your questions answered!. https://discourse.scverse.org. GitHub ; Find a bug? Interested in improving scanpy? Checkout our GitHub for the latest developments. https://github.com/scverse/scanpy. Other resources. Follow changes in the releas",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/index.html:9806,efficient,efficiently,9806,en/stable/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/index.html,1,['efficient'],['efficiently']
Energy Efficiency,"tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .md. .pdf. Tools: TL. Contents . Embeddings; Clustering and trajectory inference; Gene scores, Cell cycle. Tools: TL#. Embeddings#. tl.phate(adata[, n_components, k, a, ...]); PHATE [Moon et al., 2019]. tl.palantir(adata, *[, n_components, knn, ...]); Run Diffusion maps using the adaptive anisotropic kernel [Setty et al., 2019]. tl.trimap(adata[, n_components, n_inliers, ...]); TriMap: Large-scale Dimensionality Reduction Using Triplets [Amid and Warmuth, 2019]. tl.sam(adata, *[, max_iter, num_norm_avg, ...]); Self-Assembling Manifolds single-cell RNA sequencing analysis tool [Tarashansky et al., 2019]. Clustering and trajectory inference#. tl.phenograph(data[, clustering_algo, k, ...]); PhenoGraph clustering [Levine et al., 2015]. tl.harmony_timeseries(adata, tp, *[, ...]); Harmony time series for data visualization with augmented affinity matrix at discrete time points [Nowotschin et al., 2019]. tl.wishbone(adata, start_cell, *[, branch, ...]); Wishbone identifies bifurcating developmental trajectories from single-cell data [Setty et al., 2016]. tl.palantir(adata, *[, n_components, knn, ...]); Run Diffusion maps using the adaptive anisotropic kernel [Setty et al., 2019]. tl.palantir_results(adata, early_cell, *[, ...]); Running Palantir. Gene scores, Cell cycle#.",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/tools.html:9487,adapt,adaptive,9487,en/stable/external/tools.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/tools.html,1,['adapt'],['adaptive']
Energy Efficiency,"ts plotting functions A Wolf. 0.4.0 2017-12-23#. export to SPRING [Weinreb et al., 2017] for interactive visualization of data:; spring tutorial S Wollock. Version 0.3#. 0.3.2 2017-11-29#. finding marker genes via rank_genes_groups_violin() improved,; see issue51 F Ramirez. 0.3.0 2017-11-16#. AnnData gains method concatenate() A Wolf; AnnData is available as the separate anndata package P Angerer, A Wolf; results of PAGA simplified A Wolf. Version 0.2#. 0.2.9 2017-10-25#. Initial release of the new trajectory inference method PAGA#. paga() computes an abstracted, coarse-grained (PAGA) graph of the neighborhood graph A Wolf; paga_compare() plot this graph next an embedding A Wolf; paga_path() plots a heatmap through a node sequence in the PAGA graph A Wolf. 0.2.1 2017-07-24#; Scanpy includes preprocessing, visualization, clustering, pseudotime and; trajectory inference, differential expression testing and simulation of gene; regulatory networks. The implementation efficiently deals with datasets of more; than one million cells. A Wolf, P Angerer. Version 0.1#. 0.1.0 2017-05-17#; Scanpy computationally outperforms and allows reproducing both the Cell Ranger; R kit’s; and most of Seurat’s; clustering workflows. A Wolf, P Angerer. previous; Ecosystem. next; Community. Contents; . Version 1.10; 1.10.3 2024-09-17; Bug fixes. 1.10.2 2024-06-25; Development Process; Documentation; Bug fixes; Performance. 1.10.1 2024-04-09; Documentation; Bug fixes; Performance. 1.10.0 2024-03-26; Features; Documentation; Bug fixes; Development Process; Deprecations. Version 1.9; 1.9.8 2024-01-26; Bug fixes. 1.9.7 2024-01-25; Bug fixes. 1.9.6 2023-10-31; Bug fixes. 1.9.5 2023-09-08; Bug fixes. 1.9.4 2023-08-24; Bug fixes. 1.9.3 2023-03-02; Bug fixes. 1.9.2 2023-02-16; Bug fixes. 1.9.1 2022-04-05; Bug fixes. 1.9.0 2022-04-01; Tutorials; Experimental module; Features; Ecosystem; Bug fixes. Version 1.8; 1.8.2 2021-11-3; Documentation; Bug fixes; Ecosystem. 1.8.1 2021-07-07; Bug fixes. 1.8.0 202",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:52272,efficient,efficiently,52272,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,1,['efficient'],['efficiently']
Energy Efficiency,"use scipy.sparse classes within each dask chunk. Be aware that this is currently poorly supported by dask, and that if you want to interact with the dask arrays in any way other than though the anndata and scanpy libraries you will likely need to densify each chunk.; All operations in scanpy and anndata that work with sparse chunks also work with dense chunks.; The advantage of using sparse chunks are:. The ability to work with fewer, larger chunks; Accelerated computations per chunk (e.g. don’t need to sum all those extra zeros). You can convert from sparse to dense chunks via:; X = X.map_blocks(lambda x: x.toarray(), dtype=X.dtype, meta=np.array([])). And in reverse:; X = X.map_blocks(sparse.csr_matrix). Note that you will likely have to work with smaller chunks when doing this, via a rechunking operation. We suggest using a factor of the larger chunk size to achieve the most efficient rechunking. SPARSE_CHUNK_SIZE = 100_000; DENSE_CHUNK_SIZE = 10_000. Dask provides extensive tooling for monitoring your computation. You can access that via the dashboard started when using any of their distributed clusters. client. . Client; Client-d3384ee9-58e9-11ef-9bda-3868dd0e66a0. Connection method: Cluster object; Cluster type: distributed.LocalCluster. Dashboard: http://127.0.0.1:8787/status. Cluster Info. LocalCluster; 815df81e. Dashboard: http://127.0.0.1:8787/status. Workers: 3; . Total threads: 18; . Total memory: 128.00 GiB; . Status: running; Using processes: True. Scheduler Info. . Scheduler; Scheduler-d580fb0c-35e1-45f0-9394-837f45e7976c. Comm: tcp://127.0.0.1:37191; . Workers: 3; . Dashboard: http://127.0.0.1:8787/status. Total threads: 18; . Started: Just now; . Total memory: 128.00 GiB; . Workers. . Worker: 0. Comm: tcp://127.0.0.1:36805; . Total threads: 6; . Dashboard: http://127.0.0.1:45909/status. Memory: 42.67 GiB; . Nanny: tcp://127.0.0.1:39225; . Local directory: /tmp/dask-scratch-space/worker-pz4wcxmk; . . Worker: 1. Comm: tcp://127.0.0.1:35183; . Total thr",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/dask.html:12173,monitor,monitoring,12173,en/stable/tutorials/experimental/dask.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/dask.html,2,['monitor'],['monitoring']
Energy Efficiency,"with a sentence per line (for easier git diffs).; Check that the docs look like what you expect them too! It’s easy to forget to add a reference to function, be sure it got added and looks right. Look at sc.tl.louvain as an example for everything mentioned here. Plots in docstrings#; One of the most useful things you can include in a docstring is examples of how the function should be used.; These are a great way to demonstrate intended usage and give users a template they can copy and modify.; We’re able to include the plots produced by these snippets in the rendered docs using matplotlib’s plot directive.; For examples of this, see the Examples sections of dotplot() or calculate_qc_metrics().; Note that anything in these sections will need to be run when the docs are built, so please keep them computationally light. If you need computed features (e.g. an embedding, differential expression results) load data that has this precomputed.; Try to re-use datasets, this reduces the amount of data that needs to be downloaded to the CI server. Params section#; The Params abbreviation is a legit replacement for Parameters.; To document parameter types use type annotations on function parameters.; These will automatically populate the docstrings on import, and when the documentation is built.; Use the python standard library types (defined in collections.abc and typing modules) for containers, e.g.; Sequences (like list),; Iterables (like set), and; Mappings (like dict).; Always specify what these contain, e.g. {'a': (1, 2)} → Mapping[str, Tuple[int, int]].; If you can’t use one of those, use a concrete class like AnnData.; If your parameter only accepts an enumeration of strings, specify them like so: Literal['elem-1', 'elem-2']. Returns section#; There are three types of return sections – prose, tuple, and a mix of both. Prose is for simple cases.; Tuple return sections are formatted like parameters. Other than in numpydoc, each tuple is first characterized by the identifie",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/dev/documentation.html:12422,reduce,reduces,12422,en/stable/dev/documentation.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/dev/documentation.html,1,['reduce'],['reduces']
Energy Efficiency,"with correcting the data with sc.pp.regress_out and scaling it via sc.pp.scale, you can also get away without using .raw at all.; The result of the previous highly-variable-genes detection is stored as an annotation in .var.highly_variable and auto-detected by PCA and hence, sc.pp.neighbors and subsequent manifold/graph tools. In that case, the step actually do the filtering below is unnecessary, too. Actually do the filtering. adata = adata[:, adata.var.highly_variable]. Regress out effects of total counts per cell and the percentage of mitochondrial genes expressed. Scale the data to unit variance. sc.pp.regress_out(adata, [""total_counts"", ""pct_counts_mt""]). regressing out ['total_counts', 'pct_counts_mt']; sparse input is densified and may lead to high memory use; finished (0:00:02). Scale each gene to unit variance. Clip values exceeding standard deviation 10. sc.pp.scale(adata, max_value=10). Principal component analysis#; Reduce the dimensionality of the data by running principal component analysis (PCA), which reveals the main axes of variation and denoises the data. sc.tl.pca(adata, svd_solver=""arpack""). computing PCA; with n_comps=50; finished (0:01:01). We can make a scatter plot in the PCA coordinates, but we will not use that later on. sc.pl.pca(adata, color=""CST3""). Let us inspect the contribution of single PCs to the total variance in the data. This gives us information about how many PCs we should consider in order to compute the neighborhood relations of cells, e.g. used in the clustering function sc.tl.louvain() or tSNE sc.tl.tsne(). In our experience, often a rough estimate of the number of PCs does fine. sc.pl.pca_variance_ratio(adata, log=True). Save the result. adata.write(results_file). adata. AnnData object with n_obs × n_vars = 2638 × 1838; obs: 'n_genes', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt'; var: 'gene_ids', 'n_cells', 'mt', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'high",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering-2017.html:15819,Reduce,Reduce,15819,en/stable/tutorials/basics/clustering-2017.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering-2017.html,1,['Reduce'],['Reduce']
Integrability," 2006, Leek et al., 2017, Pedersen, 2012] pr398 M Lange. 1.3.7 2019-01-02#. API changed from import scanpy as sc to import scanpy.api as sc.; phenograph() wraps the graph clustering package Phenograph [Levine et al., 2015] thanks to A Mousa. 1.3.6 2018-12-11#. Major updates#. a new plotting gallery for visualizing-marker-genes F Ramirez; tutorials are integrated on ReadTheDocs, pbmc3k and paga-paul15 A Wolf. Interactive exploration of analysis results through manifold viewers#. CZI’s cellxgene directly reads .h5ad files the cellxgene developers; the UCSC Single Cell Browser requires exporting via cellbrowser() M Haeussler. Code design#. highly_variable_genes() supersedes filter_genes_dispersion(), it gives the same results but, by default, expects logarithmized data and doesn’t subset A Wolf. 1.3.5 2018-12-09#. uncountable figure improvements pr369 F Ramirez. 1.3.4 2018-11-24#. leiden() wraps the recent graph clustering package by Traag et al. [2019] K Polanski; bbknn() wraps the recent batch correction package [Polański et al., 2019] K Polanski; calculate_qc_metrics() caculates a number of quality control metrics, similar to calculateQCMetrics from Scater [McCarthy et al., 2017] I Virshup. 1.3.3 2018-11-05#. Major updates#. a fully distributed preprocessing backend T White and the Laserson Lab. Code design#. read_10x_h5() and read_10x_mtx() read Cell Ranger 3.0 outputs pr334 Q Gong. Note; Also see changes in anndata 0.6. changed default compression to None in write_h5ad() to speed up read and write, disk space use is usually less critical; performance gains in write_h5ad() due to better handling of strings and categories S Rybakov. 1.3.1 2018-09-03#. RNA velocity in single cells [La Manno et al., 2018]#. Scanpy and AnnData support loom’s layers so that computations for single-cell RNA velocity [La Manno et al., 2018] become feasible S Rybakov and V Bergen; scvelo harmonizes with Scanpy and is able to process loom files with splicing information produced by Velocyto",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:45226,wrap,wraps,45226,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,1,['wrap'],['wraps']
Integrability," AnnData, users; should recompute the neighbors using .obs['X_pca'] with; scanpy.pp.neighbors. .obsm['X_pca']The principal components output by SAM. .obsm['X_umap']The UMAP projection output by SAM. .layers['X_disp']The expression matrix used for nearest-neighbor averaging. .layers['X_knn_avg']The nearest-neighbor-averaged expression data used for computing the; spatial dispersions of genes. Example; >>> import scanpy.external as sce; >>> import scanpy as sc. * Running SAM *; Assuming we are given an AnnData object called adata, we can run the SAM; algorithm as follows:; >>> sam_obj = sce.tl.sam(adata,inplace=True). The input AnnData object should contain unstandardized, non-negative; expression values. Preferably, the data should be log-normalized and no; genes should be filtered out.; Please see the documentation for a description of all available parameters.; For more detailed tutorials, please visit the original Github repository:; atarashansky/self-assembling-manifold; * Plotting *; To visualize the output, we can use:; >>> sce.pl.sam(adata,projection='X_umap'). sce.pl.sam accepts all keyword arguments used in the; matplotlib.pyplot.scatter function.; * SAMGUI *; SAM comes with the SAMGUI module, a graphical-user interface written with; Plotly and ipythonwidgets for interactively exploring and annotating; the scRNAseq data and running SAM.; Dependencies can be installed with Anaconda by following the instructions in; the self-assembling-manifold Github README:; atarashansky/self-assembling-manifold; In a Jupyter notebook, execute the following to launch the interface:; >>> from samalg.gui import SAMGUI; >>> sam_gui = SAMGUI(sam_obj) # sam_obj is your SAM object; >>> sam_gui.SamPlot. This can also be enabled in Jupyer Lab by following the instructions in the; self-assembling-manifold README. previous; scanpy.external.tl.trimap. next; scanpy.external.tl.phenograph. Contents; . sam(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.sam.html:14663,interface,interface,14663,en/stable/external/generated/scanpy.external.tl.sam.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.sam.html,5,"['Depend', 'interface']","['Dependencies', 'interface']"
Integrability," Daniel Traum, Chengyang Liu, Kumar Vivek, Craig Dorrell, Ali Naji, Alvin C. Powers, Kyong-Mi Chang, Markus Grompe, and Klaus H. Kaestner. Single-cell mass cytometry analysis of the human endocrine pancreas. Cell Metabolism, 24(4):616–626, oct 2016. URL: https://doi.org/10.1016/j.cmet.2016.09.007, doi:10.1016/j.cmet.2016.09.007. [WBDrewokane+16]; Michael Waskom, Olga Botvinnik, Drewokane, Paul Hobson, , David, Yaroslav Halchenko, Saulius Lukauskas, John B. Cole, Jordi Warmenhoven, Julian De Ruiter, Stephan Hoyer, Jake Vanderplas, Santi Villalba, Gero Kunter, Eric Quintero, Marcel Martin, Alistair Miles, Kyle Meyer, Tom Augspurger, Tal Yarkoni, Pete Bachant, Mike Williams, Constantine Evans, Clark Fitzgerald, , Brian, Daniel Wehner, Gregory Hitz, Erik Ziegler, Adel Qalieh, and Antony Lee. Seaborn: v0.7.1 (june 2016). 2016. URL: https://zenodo.org/record/54844, doi:10.5281/ZENODO.54844. [WWK17]; Caleb Weinreb, Samuel Wolock, and Allon M Klein. Spring: a kinetic interface for visualizing high dimensional single-cell expression data. Bioinformatics, 34(7):1246–1248, dec 2017. URL: https://doi.org/10.1093/bioinformatics/btx792, doi:10.1093/bioinformatics/btx792. [WKSR+09]; Dominik M Wittmann, Jan Krumsiek, Julio Saez-Rodriguez, Douglas A Lauffenburger, Steffen Klamt, and Fabian J Theis. Transforming boolean models to continuous models: methodology and application to t-cell receptor signaling. BMC Systems Biology, sep 2009. URL: https://doi.org/10.1186/1752-0509-3-98, doi:10.1186/1752-0509-3-98. [WAT18]; F. Alexander Wolf, Philipp Angerer, and Fabian J. Theis. Scanpy: large-scale single-cell gene expression data analysis. Genome Biology, 19(1):15, feb 2018. URL: https://doi.org/10.1186/s13059-017-1382-0, doi:10.1186/s13059-017-1382-0. [WHP+19]; F. Alexander Wolf, Fiona K. Hamey, Mireya Plass, Jordi Solana, Joakim S. Dahlin, Berthold Göttgens, Nikolaus Rajewsky, Lukas Simon, and Fabian J. Theis. Paga: graph abstraction reconciles clustering with trajectory inference throug",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/references.html:27955,interface,interface,27955,en/stable/references.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/references.html,1,['interface'],['interface']
Integrability," PCA-based method for integrating data we call ingest and compares it with BBKNN [Polanski19]. BBKNN integrates well with the Scanpy workflow and is accessible through the bbknn function.; The ingest function assumes an annotated reference dataset that captures the biological variability of interest. The rational is to fit a model on the reference data and use it to project new data. For the time being, this model is a PCA combined with a neighbor lookup search tree, for which we use UMAP’s implementation [McInnes18]. Similar PCA-based integrations have been used before, for instance, in [Weinreb18]. As ingest is simple and the procedure clear, the workflow is transparent and fast.; Like BBKNN, ingest leaves the data matrix itself invariant.; Unlike BBKNN, ingest solves the label mapping problem (like scmap) and maintains an embedding that might have desired properties like specific clusters or trajectories. We refer to this asymmetric dataset integration as ingesting annotations from an annotated reference adata_ref into an adata that still lacks this annotation. It is different from learning a joint representation that integrates datasets in a symmetric way as BBKNN, Scanorma, Conos, CCA (e.g. in Seurat) or a conditional VAE (e.g. in scVI, trVAE) would do, but comparable to the initiall MNN implementation in scran. Take a look at tools in the external API or at the ecoystem page to get a start with other tools. import scanpy as sc; import pandas as pd. sc.settings.verbosity = 1 # verbosity: errors (0), warnings (1), info (2), hints (3); sc.logging.print_versions(); sc.settings.set_figure_params(dpi=80, frameon=False, figsize=(3, 3), facecolor=""white""). scanpy==1.5.0 anndata==0.7.1 umap==0.4.2 numpy==1.18.1 scipy==1.4.1 pandas==1.0.3 scikit-learn==0.22.1 statsmodels==0.11.0. PBMCs#; We consider an annotated reference dataset adata_ref and a dataset for which you want to query labels and embeddings adata. # this is an earlier version of the dataset from the pbmc3k tu",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/integrating-data-using-ingest.html:10668,integrat,integration,10668,en/stable/tutorials/basics/integrating-data-using-ingest.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/integrating-data-using-ingest.html,2,['integrat'],['integration']
Integrability," Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.pl.stacked_violin. Contents . stacked_violin(). scanpy.pl.stacked_violin#. scanpy.pl.stacked_violin(adata, var_names, groupby, *, log=False, use_raw=None, num_categories=7, title=None, colorbar_title='Median expression\\nin group', figsize=None, dendrogram=False, gene_symbols=None, var_group_positions=None, var_group_labels=None, standard_scale=None, var_group_rotation=None, layer=None, stripplot=False, jitter=False, size=1, scale='width', yticklabels=False, order=None, swap_axes=False, show=None, save=None, return_fig=False, row_palette=None, cmap='Blues', ax=None, vmin=None, vmax=None, vcenter=None, norm=None, **kwds)[source]#; Stacked violin plots.; Makes a compact image composed of individual violin plots; (from violinplot()) stacked on top of each other.; Useful to visualize gene expression per cluster.; Wraps seaborn.violinplot() for AnnData.; This function provides a convenient interface to the; StackedViolin class. If you need more flexibility,; you should use StackedViolin directly. Parameters:. adata AnnDataAnnotated data matrix. var_names Union[str, Sequence[str], Mapping[str, Union[str, Sequence[str]]]]var_names should be a valid subset of adata.var_names.; If var_names is a mapping, then the key is used as label; to group the values (see var_group_labels). The mapping values; should be sequences of valid adata.var_names. In this; case either coloring or ‘brackets’ are used for the grouping; of var names depending on the plot. When var_names is a mapping,; then the var_group_labels and var_group_positions are set. groupby str | Sequence[str]The key of the observation grouping to consider. use_raw bool | None (default: None)Use raw attribute of adata if present. log bool (default: False)Plot on logarithmic axis. num_categories int (default: 7)Only used if groupby observation is not categorical. This value; determines the number of groups into which the gr",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pl.stacked_violin.html:10138,interface,interface,10138,en/stable/generated/scanpy.pl.stacked_violin.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pl.stacked_violin.html,1,['interface'],['interface']
Integrability," and uses the same broadcasting rules as other arguments pr1538 I Virshup; print_versions() now uses session_info pr2089 P Angerer I Virshup. Ecosystem#; Multiple packages have been added to our ecosystem page, including:. decoupler a for footprint analysis and pathway enrichement pr2186 PB Mompel; dandelion for B-cell receptor analysis pr1953 Z Tuong; CIARA a feature selection tools for identifying rare cell types pr2175 M Stock. Bug fixes#. Fixed finding variables with use_raw=True and basis=None in scanpy.pl.scatter() pr2027 E Rice; Fixed scanpy.pp.scrublet() to address issue1957 FlMai and ensure raw counts are used for simulation; Functions in scanpy.datasets no longer throw OldFormatWarnings when using anndata 0.8 pr2096 I Virshup; Fixed use of scanpy.pp.neighbors() with method='rapids': RAPIDS cuML no longer returns a squared Euclidean distance matrix, so we should not square-root the kNN distance matrix. pr1828 M Zaslavsky; Removed pytables dependency by implementing read_10x_h5 with h5py due to installation errors on Windows pr2064; Fixed bug in scanpy.external.pp.hashsolo() where default value was set improperly pr2190 B Reiz; Fixed bug in scanpy.pl.embedding() functions where an error could be raised when there were missing values and large numbers of categories pr2187 I Virshup. Version 1.8#. 1.8.2 2021-11-3#. Documentation#. Update conda installation instructions pr1974 L Heumos. Bug fixes#. Fix plotting after scanpy.tl.filter_rank_genes_groups() pr1942 S Rybakov; Fix use_raw=None using anndata.AnnData.var_names if anndata.AnnData.raw; is present in scanpy.tl.score_genes() pr1999 M Klein; Fix compatibility with UMAP 0.5.2 pr2028 L Mcinnes; Fixed non-determinism in scanpy.pl.paga() node positions pr1922 I Virshup. Ecosystem#. Added PASTE (a tool to align and integrate spatial transcriptomics data) to scanpy ecosystem. 1.8.1 2021-07-07#. Bug fixes#. Fixed reproducibility of scanpy.tl.score_genes(). Calculation and output is now float64 type. pr1890 I Kucins",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:24764,depend,dependency,24764,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,1,['depend'],['dependency']
Integrability," basis='X_pca', adjusted_basis='X_scanorama', knn=20, sigma=15, approx=True, alpha=0.1, batch_size=5000, **kwargs)[source]#; Use Scanorama [Hie et al., 2019] to integrate different experiments.; Scanorama [Hie et al., 2019] is an algorithm for integrating single-cell; data from multiple experiments stored in an AnnData object. This; function should be run after performing PCA but before computing; the neighbor graph, as illustrated in the example below.; This uses the implementation of scanorama [Hie et al., 2019]. Parameters:. adata AnnDataThe annotated data matrix. key strThe name of the column in adata.obs that differentiates; among experiments/batches. Cells from the same batch must be; contiguously stored in adata. basis str (default: 'X_pca')The name of the field in adata.obsm where the PCA table is; stored. Defaults to 'X_pca', which is the default for; sc.pp.pca(). adjusted_basis str (default: 'X_scanorama')The name of the field in adata.obsm where the integrated; embeddings will be stored after running this function. Defaults; to X_scanorama. knn int (default: 20)Number of nearest neighbors to use for matching. sigma float (default: 15)Correction smoothing parameter on Gaussian kernel. approx bool (default: True)Use approximate nearest neighbors with Python annoy;; greatly speeds up matching runtime. alpha float (default: 0.1)Alignment score minimum cutoff. batch_size int (default: 5000)The batch size used in the alignment vector computation. Useful; when integrating very large (>100k samples) datasets. Set to; large value that runs within available memory. kwargsAny additional arguments will be passed to; scanorama.assemble(). Return type:; None. Returns:; Updates adata with the field adata.obsm[adjusted_basis],; containing Scanorama embeddings such that different experiments; are integrated. Example; First, load libraries and example dataset, and preprocess.; >>> import scanpy as sc; >>> import scanpy.external as sce; >>> adata = sc.datasets.pbmc3k(); >>> ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.scanorama_integrate.html:10390,integrat,integrated,10390,en/stable/generated/scanpy.external.pp.scanorama_integrate.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.scanorama_integrate.html,1,['integrat'],['integrated']
Integrability," comprehensive toolkit for working with spatial single cell omics data. PASTE Princeton. PASTE is a computational method to align and integrate spatial transcriptomics data across adjacent tissue slices by leveraging both gene expression similarity and spatial distances between spots. bento 🍱 UC San Diego. Bento is an accessible Python toolkit for performing subcellular analysis of spatial transcriptomics data. Multimodal integration#. MUON and MuData EMBL/ DKFZ. MUON, and it’s associated data structure MuData are designed to organise, analyse, visualise, and exchange multimodal data.; MUON enables a range of analyses for ATAC and CITE-seq, from data preprocessing to flexible multi-omics alignment. Adaptive immune receptor repertoire (AIRR)#. scirpy Medical University of Innsbruck. scirpy is a scanpy extension to expore single-cell T-cell receptor (TCR) and B-cell receptor (BCR) repertoires. dandelion University of Cambridge. dandelion is a single-cell BCR-seq network analysis package that integrates with transcriptomic data analyzed via scanpy. Long reads#. Swan UC Irvine. Swan is a Python library designed for the analysis and visualization of transcriptomes, especially with long-read transcriptomes in mind.; Users can add transcriptomes from different datasets and explore distinct splicing and expression patterns across datasets. Analysis methods#. scvi-tools#. scvi-tools Berkeley. scvi-tools hosts deep generative models (DGM) for end-to-end analysis of single-cell; omics data (e.g., scVI, scANVI, totalVI). It also contains several primitives to build novel DGMs. Fate mapping#. CellRank Helmholtz Munich. CellRank is a framework to uncover cellular dynamics based on single-cell data.; It incorporates modalities such as RNA velocity, pseudotime, developmental potential, real-time information, etc. Differential expression#. diffxpy Helmholtz Munich. Data integration#. scanaroma MIT. Modeling perturbations#. scGen / trVAE Helmholtz Munich. Feature selection#. triku 🦔 ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/ecosystem.html:11325,integrat,integrates,11325,en/stable/ecosystem.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/ecosystem.html,1,['integrat'],['integrates']
Integrability," counts to Pearson residuals; Preparations; Compute Pearson residuals; Compute PCA and t-SNE; Compute Neighborhood graph and Leiden clustering; Plot Leiden clusters on tSNE and PBMC marker genes. Optional input arguments; Overdispersion parameter theta; Clipping threshold clip; chunksize and best practice to obtain Pearson residuals for large datasets. Wrapper functions for Pearson residuals preprocessing; References / See also. How to preprocess UMI count data with analytic Pearson residuals#; With version 1.9, scanpy introduces new preprocessing functions based on Pearson residuals into the experimental.pp module. These functions implement the core steps of the preprocessing described and benchmarked in Lause et al. (2021).; In the first part, this tutorial introduces the new core functions by demonstrating their usage on two example datasets. In the second part, we briefly explain the optional arguments and their default settings. Finally, two wrapper functions that run the whole Pearson residual workflow at once are briefly discussed. Background#; In brief, Pearson residuals transform raw UMI counts into a representation where three aims are achieved:. remove the technical variation that comes from differences in total counts between cells; stabilize the mean-variance relationship across genes, i.e. ensure that biological signal from both low and high expression genes can contribute similarly to downstream processing; genes that are homogenously expressed (like housekeeping genes) have small variance, while genes that are differentially expressed (like marker genes) have high variance. Thus, computing Pearson residuals replace the common steps of explicitly normalizing by sequencing depth and log-transforming the data for variance stabilization.; The analytic Pearson residuals presented here are similar to Seurat’s scTransform model (Hafemeister & Satija, 2019), but use a simplified model that allows an analytic solution. See Lause et al. (2021) for details. Prep",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:10675,wrap,wrapper,10675,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,2,['wrap'],['wrapper']
Integrability," for PCA. zero_center bool | None (default: True)If True, compute standard PCA from covariance matrix.; If False, omit zero-centering variables; (uses scikit-learn TruncatedSVD or; dask-ml TruncatedSVD),; which allows to handle sparse input efficiently.; Passing None decides automatically based on sparseness of the data. svd_solver str | None (default: None)SVD solver to use:. NoneSee chunked and zero_center descriptions to determine which class will be used.; Depending on the class and the type of X different values for default will be set.; If scikit-learn PCA is used, will give 'arpack',; if scikit-learn TruncatedSVD is used, will give 'randomized',; if dask-ml PCA or IncrementalPCA is used, will give 'auto',; if dask-ml TruncatedSVD is used, will give 'tsqr'. 'arpack'for the ARPACK wrapper in SciPy (svds()); Not available with dask arrays. 'randomized'for the randomized algorithm due to Halko (2009). For dask arrays,; this will use svd_compressed(). 'auto'chooses automatically depending on the size of the problem. 'lobpcg'An alternative SciPy solver. Not available with dask arrays. 'tsqr'Only available with dask arrays. “tsqr”; algorithm from Benson et. al. (2013). Changed in version 1.9.3: Default value changed from 'arpack' to None. Changed in version 1.4.5: Default value changed from 'auto' to 'arpack'. Efficient computation of the principal components of a sparse matrix; currently only works with the 'arpack’ or 'lobpcg' solvers.; If X is a dask array, dask-ml classes PCA,; IncrementalPCA, or; TruncatedSVD will be used.; Otherwise their scikit-learn counterparts PCA,; IncrementalPCA, or; TruncatedSVD will be used. random_state Union[int, RandomState, None] (default: 0)Change to use different initial states for the optimization. return_info bool (default: False)Only relevant when not passing an AnnData:; see “Returns”. mask_var ndarray[Any, dtype[bool]] | str | None | Empty (default: _empty)To run only on a certain set of genes given by a boolean array; or a ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.pca.html:11388,depend,depending,11388,en/stable/generated/scanpy.pp.pca.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.pca.html,1,['depend'],['depending']
Integrability," for leiden clustering by scanpy.external.tl.phenograph() pr1080 A Mousa; Deprecate scanpy.external.pp.scvi pr1554 G Xing; Updated default params of sam() to work with larger data pr1540 A Tarashansky. Documentation#. New contribution guide pr1544 I Virshup; zsh installation instructions pr1444 P Angerer. Performance#. Speed up read_10x_h5() pr1402 P Weiler; Speed ups for obs_df() pr1499 F Ramirez. Bugfixes#. Consistent fold-change, fractions calculation for filter_rank_genes_groups pr1391 S Rybakov; Fixed bug where score_genes would error if one gene was passed pr1398 I Virshup; Fixed log1p inplace on integer dense arrays pr1400 I Virshup; Fix docstring formatting for rank_genes_groups() pr1417 P Weiler; Removed PendingDeprecationWarning`s from use of `np.matrix pr1424 P Weiler; Fixed indexing byg in ~scanpy.pp.highly_variable_genes pr1456 V Bergen; Fix default number of genes for marker_genes_overlap pr1464 MD Luecken; Fixed passing groupby and dendrogram_key to dendrogram() pr1465 M Varma; Fixed download path of pbmc3k_processed pr1472 D Strobl; Better error message when computing DE with a group of size 1 pr1490 J Manning; Update cugraph API usage for v0.16 pr1494 R Ilango; Fixed marker_gene_overlap default value for top_n_markers pr1464 MD Luecken; Pass random_state to RAPIDs UMAP pr1474 C Nolet; Fixed anndata version requirement for concat() (re-exported from scanpy as sc.concat) pr1491 I Virshup; Fixed the width of the progress bar when downloading data pr1507 M Klein; Updated link for moignard15 dataset pr1542 I Virshup; Fixed bug where calling set_figure_params could block if IPython was installed, but not used. pr1547 I Virshup; violin() no longer fails if .raw not present pr1548 I Virshup; spatial() refactoring and better handling of spatial data pr1512 G Palla; pca() works with chunked=True again pr1592 I Virshup; ingest() now works with umap-learn 0.5.0 pr1601 S Rybakov. Version 1.6#. 1.6.0 2020-08-15#; This release includes an overhaul of dotplot(), mat",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:33206,message,message,33206,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,1,['message'],['message']
Integrability," normalization should be performed prior to computing corrected expression values. svd_dim int | None (default: None)The number of dimensions to use for summarizing biological substructure; within each batch. If None, biological components will not be removed; from the correction vectors. var_adj bool (default: True)Whether to adjust variance of the correction vectors. Note this step; takes most computing time. compute_angle bool (default: False)Whether to compute the angle between each cell’s correction vector and; the biological subspace of the reference batch. mnn_order Sequence[int] | None (default: None)The order in which batches are to be corrected. When set to None, datas; are corrected sequentially. svd_mode Literal['svd', 'rsvd', 'irlb'] (default: 'rsvd')'svd' computes SVD using a non-randomized SVD-via-ID algorithm,; while 'rsvd' uses a randomized version. 'irlb' perfores; truncated SVD by implicitly restarted Lanczos bidiagonalization; (forked from airysen/irlbpy). do_concatenate bool (default: True)Whether to concatenate the corrected matrices or AnnData objects. Default is True. save_raw bool (default: False)Whether to save the original expression data in the; raw attribute. n_jobs int | None (default: None)The number of jobs. When set to None, automatically uses; scanpy._settings.ScanpyConfig.n_jobs. kwargsoptional keyword arguments for irlb. Return type:; tuple[ndarray | AnnData, list[DataFrame], list[tuple[float | None, int]] | None]. Returns:. datasndarray | AnnDataCorrected matrix/matrices or AnnData object/objects, depending on the; input type and do_concatenate. mnn_listlist[DataFrame]A list containing MNN pairing information as DataFrames in each iteration step. angle_listlist[tuple[float | None, int]] | NoneA list containing angles of each batch. previous; scanpy.external.pp.harmony_integrate. next; scanpy.external.pp.scanorama_integrate. Contents; . mnn_correct(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.mnn_correct.html:13194,depend,depending,13194,en/stable/generated/scanpy.external.pp.mnn_correct.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.mnn_correct.html,1,['depend'],['depending']
Integrability," scaling with subsequent log plus one (log1p) transformation. Count depth scaling normalizes the data to a “size factor” such as the median count depth in the dataset, ten thousand (CP10k) or one million (CPM, counts per million). The size factor for count depth scaling can be controlled via target_sum in pp.normalize_total. We are applying median count depth normalization with log1p transformation (AKA log1PF). # Saving count data; adata.layers[""counts""] = adata.X.copy(). # Normalizing to median total counts; sc.pp.normalize_total(adata); # Logarithmize the data; sc.pp.log1p(adata). Feature selection#; As a next step, we want to reduce the dimensionality of the dataset and only include the most informative genes. This step is commonly known as feature selection. The scanpy function pp.highly_variable_genes annotates highly variable genes by reproducing the implementations of Seurat [Satija et al., 2015], Cell Ranger [Zheng et al., 2017], and Seurat v3 [Stuart et al., 2019] depending on the chosen flavor. sc.pp.highly_variable_genes(adata, n_top_genes=2000, batch_key=""sample""). sc.pl.highly_variable_genes(adata). Dimensionality Reduction#; Reduce the dimensionality of the data by running principal component analysis (PCA), which reveals the main axes of variation and denoises the data. sc.tl.pca(adata). Let us inspect the contribution of single PCs to the total variance in the data. This gives us information about how many PCs we should consider in order to compute the neighborhood relations of cells, e.g. used in the clustering function leiden() or tsne(). In our experience, there does not seem to be signifigant downside to overestimating the numer of principal components. sc.pl.pca_variance_ratio(adata, n_pcs=50, log=True). You can also plot the principal components to see if there are any potentially undesired features (e.g. batch, QC metrics) driving signifigant variation in this dataset. In this case, there isn’t anything too alarming, but it’s a good idea to ex",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering.html:15331,depend,depending,15331,en/stable/tutorials/basics/clustering.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering.html,2,['depend'],['depending']
Integrability," scanpy._settings.ScanpyConfig.plot_suffix; scanpy._settings.ScanpyConfig.verbosity; scanpy._settings.ScanpyConfig.writedir; scanpy._settings.ScanpyConfig.N_PCS; scanpy._settings.ScanpyConfig.set_figure_params. scanpy.logging.print_header; scanpy.logging.print_versions. Datasets; scanpy.datasets.blobs; scanpy.datasets.ebi_expression_atlas; scanpy.datasets.krumsiek11; scanpy.datasets.moignard15; scanpy.datasets.pbmc3k; scanpy.datasets.pbmc3k_processed; scanpy.datasets.pbmc68k_reduced; scanpy.datasets.paul15; scanpy.datasets.toggleswitch; scanpy.datasets.visium_sge. Deprecated functions; scanpy.pp.filter_genes_dispersion; scanpy.pp.normalize_per_cell. External API; Preprocessing: PP; scanpy.external.pp.bbknn; scanpy.external.pp.harmony_integrate; scanpy.external.pp.mnn_correct; scanpy.external.pp.scanorama_integrate; scanpy.external.pp.hashsolo; scanpy.external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .md. .pdf. Spatial. Spatial#. Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. previous; Trajectory inference for hematopoiesis in mouse. next; Analysis and visualization of spatial transcriptomics data. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/index.html:9294,Integrat,Integrating,9294,en/stable/tutorials/spatial/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/index.html,1,['Integrat'],['Integrating']
Integrability," scanpy.external.pp.scanorama_integrate; scanpy.external.pp.hashsolo; scanpy.external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .ipynb. .pdf. Integrating spatial data with scRNA-seq using scanorama. Contents . Loading libraries; Reading the data; Data integration; Data integration and label transfer from scRNA-seq dataset. Integrating spatial data with scRNA-seq using scanorama#; Author: Giovanni Palla. Note; For up-to-date analysis tutorials, kindly check out SquidPy tutorials. This tutorial shows how to work with multiple Visium datasets and perform integration of scRNA-seq dataset with Scanpy. It follows the previous tutorial on analysis and visualization of spatial transcriptomics data.; We will use Scanorama paper - code to perform integration and label transfer. It has a convenient interface with scanpy and anndata.; To install the required libraries, type the following:; pip install git+https://github.com/theislab/scanpy.git; pip install git+https://github.com/theislab/anndata.git; pip install scanorama. Loading libraries#. import scanpy as sc; import anndata as an; import pandas as pd; import numpy as np; import matplotlib.pyplot as plt; import seaborn as sns; import scanorama. from pathlib import Path. sc.logging.print_versions(); sc.set_",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html:9377,integrat,integration,9377,en/stable/tutorials/spatial/integration-scanorama.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html,4,['integrat'],['integration']
Integrability," scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .md. .pdf. Ecosystem. Contents . Viewers; Portals; Modalities; RNA velocity; Spatial Transcriptomics Tools; Multimodal integration; Adaptive immune receptor repertoire (AIRR); Long reads. Analysis methods; scvi-tools; Fate mapping; Differential expression; Data integration; Modeling perturbations; Feature selection; Annotation/ Enrichment Analysis. Ecosystem#. Warning; We are no longer accepting new tools on this page.; Instead, please submit your tool to the scverse ecosystem package listing. Viewers#; Interactive manifold viewers. cellxgene via direct reading of .h5ad CZI; cirrocumulus via direct reading of .h5ad Broad Inst.; cell browser via exporing through cellbrowser() UCSC; SPRING via exporting through spring_project() Harvard Med; vitessce for purely browser based viewing of zarr formatted AnnData files Harvard Med. Portals#. the Gene Expression Analysis Resource U Maryland; the Galaxy Project for the Human Cell Atlas [tweet] U Freiburg; the Expression Atlas EMBL-EBI. Modalities#. RNA velocity#. scVelo Helmholtz Munich. Spatial Transcriptomics Tools#. squidpy Helmholtz Munich. Squidpy is a comprehensive toolkit for working with spatial single cell omics data. PASTE Princeton. PASTE is a computational method to align and integrate spatial tra",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/ecosystem.html:9468,integrat,integration,9468,en/stable/ecosystem.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/ecosystem.html,1,['integrat'],['integration']
Integrability," type 2 diabetes. Cell Metabolism, 24(4):593–607, oct 2016. URL: https://doi.org/10.1016/j.cmet.2016.08.020, doi:10.1016/j.cmet.2016.08.020. [SKL+19]; Manu Setty, Vaidotas Kiseliovas, Jacob Levine, Adam Gayoso, Linas Mazutis, and Dana Pe’er. Characterization of cell fate probabilities in single-cell data with palantir. Nature Biotechnology, 37(4):451–460, mar 2019. URL: https://doi.org/10.1038/s41587-019-0068-4, doi:10.1038/s41587-019-0068-4. [STRZ+16]; Manu Setty, Michelle D Tadmor, Shlomit Reich-Zeliger, Omer Angel, Tomer Meir Salame, Pooja Kathail, Kristy Choi, Sean Bendall, Nir Friedman, and Dana Pe’er. Wishbone identifies bifurcating developmental trajectories from single-cell data. Nature Biotechnology, 34(6):637–645, may 2016. URL: https://doi.org/10.1038/nbt.3569, doi:10.1038/nbt.3569. [SBH+19]; Tim Stuart, Andrew Butler, Paul Hoffman, Christoph Hafemeister, Efthymia Papalexi, William M. Mauck, Yuhan Hao, Marlon Stoeckius, Peter Smibert, and Rahul Satija. Comprehensive integration of single-cell data. Cell, 177(7):1888–1902.e21, jun 2019. URL: https://doi.org/10.1016/j.cell.2019.05.031, doi:10.1016/j.cell.2019.05.031. [TXL+19]; Alexander J Tarashansky, Yuan Xue, Pengyang Li, Stephen R Quake, and Bo Wang. Self-assembling manifolds in single-cell rna sequencing data. eLife, sep 2019. URL: https://doi.org/10.7554/eLife.48994, doi:10.7554/elife.48994. [TWvE19]; V. A. Traag, L. Waltman, and N. J. van Eck. From louvain to leiden: guaranteeing well-connected communities. Scientific Reports, mar 2019. URL: https://doi.org/10.1038/s41598-019-41695-z, doi:10.1038/s41598-019-41695-z. [Tra15]; Vincent Traag. Louvain-igraph: v0.5.3. 2015. URL: https://zenodo.org/record/35117, doi:10.5281/ZENODO.35117. [Uly16]; Dmitry Ulyanov. Multicore-tsne. DmitryUlyanov/Multicore-TSNE, 2016. URL: DmitryUlyanov/Multicore-TSNE. [vdMH08]; Laurens van der Maaten and Geoffrey Hinton. Visualizing data using t-sne. Journal of Machine Learning Research, 9(86):2579–2605, 2008. URL: http://jmlr.o",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/references.html:25435,integrat,integration,25435,en/stable/references.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/references.html,1,['integrat'],['integration']
Integrability,"(default: 'X_pca')The name of the field in adata.obsm where the PCA table is; stored. Defaults to 'X_pca', which is the default for; sc.pp.pca(). adjusted_basis str (default: 'X_scanorama')The name of the field in adata.obsm where the integrated; embeddings will be stored after running this function. Defaults; to X_scanorama. knn int (default: 20)Number of nearest neighbors to use for matching. sigma float (default: 15)Correction smoothing parameter on Gaussian kernel. approx bool (default: True)Use approximate nearest neighbors with Python annoy;; greatly speeds up matching runtime. alpha float (default: 0.1)Alignment score minimum cutoff. batch_size int (default: 5000)The batch size used in the alignment vector computation. Useful; when integrating very large (>100k samples) datasets. Set to; large value that runs within available memory. kwargsAny additional arguments will be passed to; scanorama.assemble(). Return type:; None. Returns:; Updates adata with the field adata.obsm[adjusted_basis],; containing Scanorama embeddings such that different experiments; are integrated. Example; First, load libraries and example dataset, and preprocess.; >>> import scanpy as sc; >>> import scanpy.external as sce; >>> adata = sc.datasets.pbmc3k(); >>> sc.pp.recipe_zheng17(adata); >>> sc.pp.pca(adata). We now arbitrarily assign a batch metadata variable to each cell; for the sake of example, but during real usage there would already; be a column in adata.obs giving the experiment each cell came; from.; >>> adata.obs['batch'] = 1350*['a'] + 1350*['b']. Finally, run Scanorama. Afterwards, there will be a new table in; adata.obsm containing the Scanorama embeddings.; >>> sce.pp.scanorama_integrate(adata, 'batch', verbose=1); Processing datasets a <=> b; >>> 'X_scanorama' in adata.obsm; True. previous; scanpy.external.pp.mnn_correct. next; scanpy.external.pp.hashsolo. Contents; . scanorama_integrate(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.scanorama_integrate.html:11237,integrat,integrated,11237,en/stable/generated/scanpy.external.pp.scanorama_integrate.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.scanorama_integrate.html,1,['integrat'],['integrated']
Integrability,"(default: None)Defaults to RBConfigurationVertexPartition. For the; available options, consult the documentation for; find_partition(). resolution_parameter float (default: 1)A parameter value controlling the coarseness of the clustering in Leiden. Higher; values lead to more clusters. Set to None if overriding partition_type to; one that does not accept a resolution_parameter. n_iterations int (default: -1)Number of iterations to run the Leiden algorithm. If the number of iterations is; negative, the Leiden algorithm is run until an iteration in which there was no; improvement. use_weights bool (default: True)Use vertices in the Leiden computation. seed int | None (default: None)Leiden initialization of the optimization. copy bool (default: False)Return a copy or write to adata. kargs AnyAdditional arguments passed to find_partition() and the; constructor of the partition_type. Return type:; tuple[ndarray | None, spmatrix, float | None] | None. Returns:; Depending on copy, returns or updates adata with the following fields:. communities - ndarray (obs, dtype int)integer array of community assignments for each row in data. graph - spmatrix (obsp, dtype float)the graph that was used for clustering. Q - float (uns, dtype float)the modularity score for communities on graph. Example; >>> from anndata import AnnData; >>> import scanpy as sc; >>> import scanpy.external as sce; >>> import numpy as np; >>> import pandas as pd. With annotated data as input:; >>> adata = sc.datasets.pbmc3k(); >>> sc.pp.normalize_per_cell(adata). Then do PCA:; >>> sc.pp.pca(adata, n_comps=100). Compute phenograph clusters:; Louvain community detection; >>> sce.tl.phenograph(adata, clustering_algo=""louvain"", k=30). Leiden community detection; >>> sce.tl.phenograph(adata, clustering_algo=""leiden"", k=30). Return only Graph object; >>> sce.tl.phenograph(adata, clustering_algo=None, k=30). Now to show phenograph on tSNE (for example):; Compute tSNE:; >>> sc.tl.tsne(adata, random_state=7). Plot phen",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.phenograph.html:13178,Depend,Depending,13178,en/stable/external/generated/scanpy.external.tl.phenograph.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.phenograph.html,1,['Depend'],['Depending']
Integrability,", float vector (adata.var); 'dispersions', float vector (adata.var); 'dispersions_norm', float vector (adata.var); normalizing counts per cell; finished (0:00:00); extracting highly variable genes; finished (0:00:00); --> added; 'highly_variable', boolean vector (adata.var); 'means', float vector (adata.var); 'dispersions', float vector (adata.var); 'dispersions_norm', float vector (adata.var). Data integration#; We are now ready to perform integration of the two dataset. As mentioned before, we will be using Scanorama for that. Scanorama returns two lists, one for the integrated embeddings and one for the corrected counts, for each dataset.; We would like to note that in this context using BBKNN or Ingest is also possible. adatas = [adata_spatial_anterior, adata_spatial_posterior]; adatas_cor = scanorama.correct_scanpy(adatas, return_dimred=True). Found 32285 genes among all datasets; [[0. 0.48882265]; [0. 0. ]]; Processing datasets (0, 1). We will concatenate the two datasets and save the integrated embeddings in adata_spatial.obsm['scanorama_embedding']. Furthermore we will compute UMAP to visualize the results and qualitatively assess the data integration task.; Notice that we are concatenating the two dataset with uns_merge=""unique"" strategy, in order to keep both images from the visium datasets in the concatenated anndata object. adata_spatial = sc.concat(; adatas_cor,; label=""library_id"",; uns_merge=""unique"",; keys=[; k; for d in [; adatas_cor[0].uns[""spatial""],; adatas_cor[1].uns[""spatial""],; ]; for k, v in d.items(); ],; index_unique=""-"",; ). sc.pp.neighbors(adata_spatial, use_rep=""X_scanorama""); sc.tl.umap(adata_spatial); sc.tl.leiden(; adata_spatial, key_added=""clusters"", n_iterations=2, flavor=""igraph"", directed=False; ). computing neighbors; finished: added to `.uns['neighbors']`; `.obsp['distances']`, distances for each pair of neighbors; `.obsp['connectivities']`, weighted adjacency matrix (0:00:02); computing UMAP; finished: added; 'X_umap', UMAP coo",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html:16492,integrat,integrated,16492,en/stable/tutorials/spatial/integration-scanorama.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html,2,['integrat'],['integrated']
Integrability,", jan 2000. URL: https://doi.org/10.1038/35002131, doi:10.1038/35002131. [HBT15]; Laleh Haghverdi, Florian Buettner, and Fabian J. Theis. Diffusion maps for high-dimensional single-cell analysis of differentiation data. Bioinformatics, 31(18):2989–2998, may 2015. URL: https://doi.org/10.1093/bioinformatics/btv325, doi:10.1093/bioinformatics/btv325. [HBW+16]; Laleh Haghverdi, Maren Büttner, F Alexander Wolf, Florian Buettner, and Fabian J Theis. Diffusion pseudotime robustly reconstructs lineage branching. Nature Methods, 13(10):845–848, aug 2016. URL: https://doi.org/10.1038/nmeth.3971, doi:10.1038/nmeth.3971. [HLMM18]; Laleh Haghverdi, Aaron T L Lun, Michael D Morgan, and John C Marioni. Batch effects in single-cell rna-sequencing data are corrected by matching mutual nearest neighbors. Nature Biotechnology, 36(5):421–427, apr 2018. URL: https://doi.org/10.1038/nbt.4091, doi:10.1038/nbt.4091. [HBB19]; Brian Hie, Bryan Bryson, and Bonnie Berger. Efficient integration of heterogeneous single-cell transcriptomes using scanorama. Nature Biotechnology, 37(6):685–691, may 2019. URL: https://doi.org/10.1038/s41587-019-0113-3, doi:10.1038/s41587-019-0113-3. [IKM+11]; Saiful Islam, Una Kjällquist, Annalena Moliner, Pawel Zajac, Jian-Bing Fan, Peter Lönnerberg, and Sten Linnarsson. Characterization of the single-cell transcriptional landscape by highly multiplex rna-seq. Genome Research, 21(7):1160–1167, may 2011. URL: https://doi.org/10.1101/gr.110882.110, doi:10.1101/gr.110882.110. [JVHB14]; Mathieu Jacomy, Tommaso Venturini, Sebastien Heymann, and Mathieu Bastian. Forceatlas2, a continuous graph layout algorithm for handy network visualization designed for the gephi software. PLoS ONE, 9(6):e98679, jun 2014. URL: https://doi.org/10.1371/journal.pone.0098679, doi:10.1371/journal.pone.0098679. [JLR06]; W. Evan Johnson, Cheng Li, and Ariel Rabinovic. Adjusting batch effects in microarray expression data using empirical bayes methods. Biostatistics, 8(1):118–127, apr 2006. URL",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/references.html:14290,integrat,integration,14290,en/stable/references.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/references.html,1,['integrat'],['integration']
Integrability,. Basics — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON; scanpy.pl.DotPlot.DEFAULT_D,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/index.html:182,Integrat,Integrating,182,en/stable/tutorials/basics/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/index.html,2,['Integrat'],['Integrating']
Integrability,. Core plotting functions — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON; scanpy.pl.,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/core.html:199,Integrat,Integrating,199,en/stable/tutorials/plotting/core.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/core.html,2,['Integrat'],['Integrating']
Integrability,. Experimental — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON; scanpy.pl.DotPlot.DEF,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/index.html:188,Integrat,Integrating,188,en/stable/tutorials/experimental/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/index.html,2,['Integrat'],['Integrating']
Integrability,. Integrating data using ingest and BBKNN — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLO,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/integrating-data-using-ingest.html:2,Integrat,Integrating,2,en/stable/tutorials/basics/integrating-data-using-ingest.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/integrating-data-using-ingest.html,3,['Integrat'],['Integrating']
Integrability,. Plotting — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON; scanpy.pl.DotPlot.DEFAULT,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/index.html:184,Integrat,Integrating,184,en/stable/tutorials/plotting/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/index.html,2,['Integrat'],['Integrating']
Integrability,. Preprocessing and clustering 3k PBMCs (legacy workflow) — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotP,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering-2017.html:231,Integrat,Integrating,231,en/stable/tutorials/basics/clustering-2017.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering-2017.html,2,['Integrat'],['Integrating']
Integrability,. Spatial — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON; scanpy.pl.DotPlot.DEFAULT_,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/index.html:183,Integrat,Integrating,183,en/stable/tutorials/spatial/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/index.html,2,['Integrat'],['Integrating']
Integrability,. Trajectories — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON; scanpy.pl.DotPlot.DEF,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/trajectories/index.html:188,Integrat,Integrating,188,en/stable/tutorials/trajectories/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/trajectories/index.html,2,['Integrat'],['Integrating']
Integrability,. Trajectory inference for hematopoiesis in mouse — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFA,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/trajectories/paga-paul15.html:223,Integrat,Integrating,223,en/stable/tutorials/trajectories/paga-paul15.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/trajectories/paga-paul15.html,2,['Integrat'],['Integrating']
Integrability,. Using dask with Scanpy — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON; scanpy.pl.D,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/dask.html:198,Integrat,Integrating,198,en/stable/tutorials/experimental/dask.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/dask.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.external.tl.cyclone — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON; scanpy.,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.cyclone.html:202,Integrat,Integrating,202,en/stable/external/generated/scanpy.external.tl.cyclone.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.cyclone.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.external.tl.harmony_timeseries — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.harmony_timeseries.html:213,Integrat,Integrating,213,en/stable/external/generated/scanpy.external.tl.harmony_timeseries.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.harmony_timeseries.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.external.tl.palantir — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON; scanpy,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.palantir.html:203,Integrat,Integrating,203,en/stable/external/generated/scanpy.external.tl.palantir.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.palantir.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.external.tl.palantir_results — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.palantir_results.html:211,Integrat,Integrating,211,en/stable/external/generated/scanpy.external.tl.palantir_results.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.palantir_results.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.external.tl.phate — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON; scanpy.pl,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.phate.html:200,Integrat,Integrating,200,en/stable/external/generated/scanpy.external.tl.phate.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.phate.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.external.tl.phenograph — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON; scan,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.phenograph.html:205,Integrat,Integrating,205,en/stable/external/generated/scanpy.external.tl.phenograph.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.phenograph.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.external.tl.sam — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON; scanpy.pl.D,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.sam.html:198,Integrat,Integrating,198,en/stable/external/generated/scanpy.external.tl.sam.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.sam.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.external.tl.sandbag — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON; scanpy.,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.sandbag.html:202,Integrat,Integrating,202,en/stable/external/generated/scanpy.external.tl.sandbag.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.sandbag.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.external.tl.trimap — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON; scanpy.p,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.trimap.html:201,Integrat,Integrating,201,en/stable/external/generated/scanpy.external.tl.trimap.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.trimap.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.external.tl.wishbone — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON; scanpy,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.wishbone.html:203,Integrat,Integrating,203,en/stable/external/generated/scanpy.external.tl.wishbone.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.wishbone.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.DotPlot — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON; scanpy.pl.DotPlo,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.html:193,Integrat,Integrating,193,en/stable/api/generated/classes/scanpy.pl.DotPlot.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_CO,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT.html:217,Integrat,Integrating,217,en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COL,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH.html:216,Integrat,Integrating,216,en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.DotPlot.DEFAULT_COLORMAP — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON;,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_COLORMAP.html:210,Integrat,Integrating,210,en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_COLORMAP.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_COLORMAP.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE.html:220,Integrat,Integrating,220,en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.DotPlot.DEFAULT_COLOR_ON — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON;,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_COLOR_ON.html:210,Integrat,Integrating,210,en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_COLOR_ON.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_COLOR_ON.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.DotPlot.DEFAULT_DOT_EDGECOLOR — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLO,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_DOT_EDGECOLOR.html:215,Integrat,Integrating,215,en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_DOT_EDGECOLOR.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_DOT_EDGECOLOR.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.DotPlot.DEFAULT_DOT_EDGELW — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_O,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_DOT_EDGELW.html:212,Integrat,Integrating,212,en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_DOT_EDGELW.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_DOT_EDGELW.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.DotPlot.DEFAULT_DOT_MAX — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON; ,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_DOT_MAX.html:209,Integrat,Integrating,209,en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_DOT_MAX.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_DOT_MAX.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.DotPlot.DEFAULT_DOT_MIN — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON; ,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_DOT_MIN.html:209,Integrat,Integrating,209,en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_DOT_MIN.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_DOT_MIN.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.DotPlot.DEFAULT_LARGEST_DOT — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_LARGEST_DOT.html:213,Integrat,Integrating,213,en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_LARGEST_DOT.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_LARGEST_DOT.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.DotPlot.DEFAULT_LEGENDS_WIDTH — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLO,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_LEGENDS_WIDTH.html:215,Integrat,Integrating,215,en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_LEGENDS_WIDTH.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_LEGENDS_WIDTH.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.DotPlot.DEFAULT_PLOT_X_PADDING — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COL,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_PLOT_X_PADDING.html:216,Integrat,Integrating,216,en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_PLOT_X_PADDING.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_PLOT_X_PADDING.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.DotPlot.DEFAULT_PLOT_Y_PADDING — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COL,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_PLOT_Y_PADDING.html:216,Integrat,Integrating,216,en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_PLOT_Y_PADDING.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_PLOT_Y_PADDING.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.DotPlot.DEFAULT_SAVE_PREFIX — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_SAVE_PREFIX.html:213,Integrat,Integrating,213,en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_SAVE_PREFIX.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_SAVE_PREFIX.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.DotPlot.DEFAULT_SIZE_EXPONENT — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLO,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_SIZE_EXPONENT.html:215,Integrat,Integrating,215,en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_SIZE_EXPONENT.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_SIZE_EXPONENT.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.DotPlot.DEFAULT_SIZE_LEGEND_TITLE — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_SIZE_LEGEND_TITLE.html:219,Integrat,Integrating,219,en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_SIZE_LEGEND_TITLE.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_SIZE_LEGEND_TITLE.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.DotPlot.DEFAULT_SMALLEST_DOT — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_SMALLEST_DOT.html:214,Integrat,Integrating,214,en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_SMALLEST_DOT.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_SMALLEST_DOT.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.DotPlot.DEFAULT_WSPACE — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON; s,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_WSPACE.html:208,Integrat,Integrating,208,en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_WSPACE.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.DEFAULT_WSPACE.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.DotPlot.MAX_NUM_CATEGORIES — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_O,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.MAX_NUM_CATEGORIES.html:212,Integrat,Integrating,212,en/stable/api/generated/classes/scanpy.pl.DotPlot.MAX_NUM_CATEGORIES.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.MAX_NUM_CATEGORIES.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.DotPlot.MIN_FIGURE_HEIGHT — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.MIN_FIGURE_HEIGHT.html:211,Integrat,Integrating,211,en/stable/api/generated/classes/scanpy.pl.DotPlot.MIN_FIGURE_HEIGHT.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.MIN_FIGURE_HEIGHT.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.DotPlot.add_dendrogram — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON; s,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.add_dendrogram.html:208,Integrat,Integrating,208,en/stable/api/generated/classes/scanpy.pl.DotPlot.add_dendrogram.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.add_dendrogram.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.DotPlot.add_totals — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON; scanp,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.add_totals.html:204,Integrat,Integrating,204,en/stable/api/generated/classes/scanpy.pl.DotPlot.add_totals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.add_totals.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.DotPlot.get_axes — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON; scanpy.,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.get_axes.html:202,Integrat,Integrating,202,en/stable/api/generated/classes/scanpy.pl.DotPlot.get_axes.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.get_axes.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.DotPlot.getdoc — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON; scanpy.pl,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.getdoc.html:200,Integrat,Integrating,200,en/stable/api/generated/classes/scanpy.pl.DotPlot.getdoc.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.getdoc.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.DotPlot.legend — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON; scanpy.pl,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.legend.html:200,Integrat,Integrating,200,en/stable/api/generated/classes/scanpy.pl.DotPlot.legend.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.legend.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.DotPlot.make_figure — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON; scan,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.make_figure.html:205,Integrat,Integrating,205,en/stable/api/generated/classes/scanpy.pl.DotPlot.make_figure.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.make_figure.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.DotPlot.savefig — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON; scanpy.p,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.savefig.html:201,Integrat,Integrating,201,en/stable/api/generated/classes/scanpy.pl.DotPlot.savefig.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.savefig.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.DotPlot.show — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON; scanpy.pl.D,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.show.html:198,Integrat,Integrating,198,en/stable/api/generated/classes/scanpy.pl.DotPlot.show.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.show.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.DotPlot.style — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON; scanpy.pl.,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.style.html:199,Integrat,Integrating,199,en/stable/api/generated/classes/scanpy.pl.DotPlot.style.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.style.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.DotPlot.swap_axes — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON; scanpy,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.swap_axes.html:203,Integrat,Integrating,203,en/stable/api/generated/classes/scanpy.pl.DotPlot.swap_axes.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.swap_axes.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.MatrixPlot — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON; scanpy.pl.Dot,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.MatrixPlot.html:196,Integrat,Integrating,196,en/stable/api/generated/classes/scanpy.pl.MatrixPlot.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.MatrixPlot.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.MatrixPlot.DEFAULT_CATEGORY_HEIGHT — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.MatrixPlot.DEFAULT_CATEGORY_HEIGHT.html:220,Integrat,Integrating,220,en/stable/api/generated/classes/scanpy.pl.MatrixPlot.DEFAULT_CATEGORY_HEIGHT.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.MatrixPlot.DEFAULT_CATEGORY_HEIGHT.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.MatrixPlot.DEFAULT_CATEGORY_WIDTH — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.MatrixPlot.DEFAULT_CATEGORY_WIDTH.html:219,Integrat,Integrating,219,en/stable/api/generated/classes/scanpy.pl.MatrixPlot.DEFAULT_CATEGORY_WIDTH.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.MatrixPlot.DEFAULT_CATEGORY_WIDTH.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.MatrixPlot.DEFAULT_COLORMAP — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.MatrixPlot.DEFAULT_COLORMAP.html:213,Integrat,Integrating,213,en/stable/api/generated/classes/scanpy.pl.MatrixPlot.DEFAULT_COLORMAP.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.MatrixPlot.DEFAULT_COLORMAP.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.MatrixPlot.DEFAULT_COLOR_LEGEND_TITLE — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFA,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.MatrixPlot.DEFAULT_COLOR_LEGEND_TITLE.html:223,Integrat,Integrating,223,en/stable/api/generated/classes/scanpy.pl.MatrixPlot.DEFAULT_COLOR_LEGEND_TITLE.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.MatrixPlot.DEFAULT_COLOR_LEGEND_TITLE.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.MatrixPlot.DEFAULT_EDGE_COLOR — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLO,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.MatrixPlot.DEFAULT_EDGE_COLOR.html:215,Integrat,Integrating,215,en/stable/api/generated/classes/scanpy.pl.MatrixPlot.DEFAULT_EDGE_COLOR.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.MatrixPlot.DEFAULT_EDGE_COLOR.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.MatrixPlot.DEFAULT_EDGE_LW — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_O,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.MatrixPlot.DEFAULT_EDGE_LW.html:212,Integrat,Integrating,212,en/stable/api/generated/classes/scanpy.pl.MatrixPlot.DEFAULT_EDGE_LW.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.MatrixPlot.DEFAULT_EDGE_LW.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.MatrixPlot.DEFAULT_LEGENDS_WIDTH — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_C,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.MatrixPlot.DEFAULT_LEGENDS_WIDTH.html:218,Integrat,Integrating,218,en/stable/api/generated/classes/scanpy.pl.MatrixPlot.DEFAULT_LEGENDS_WIDTH.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.MatrixPlot.DEFAULT_LEGENDS_WIDTH.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.MatrixPlot.DEFAULT_SAVE_PREFIX — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COL,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.MatrixPlot.DEFAULT_SAVE_PREFIX.html:216,Integrat,Integrating,216,en/stable/api/generated/classes/scanpy.pl.MatrixPlot.DEFAULT_SAVE_PREFIX.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.MatrixPlot.DEFAULT_SAVE_PREFIX.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.MatrixPlot.DEFAULT_WSPACE — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.MatrixPlot.DEFAULT_WSPACE.html:211,Integrat,Integrating,211,en/stable/api/generated/classes/scanpy.pl.MatrixPlot.DEFAULT_WSPACE.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.MatrixPlot.DEFAULT_WSPACE.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.MatrixPlot.MAX_NUM_CATEGORIES — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLO,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.MatrixPlot.MAX_NUM_CATEGORIES.html:215,Integrat,Integrating,215,en/stable/api/generated/classes/scanpy.pl.MatrixPlot.MAX_NUM_CATEGORIES.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.MatrixPlot.MAX_NUM_CATEGORIES.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.MatrixPlot.MIN_FIGURE_HEIGHT — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.MatrixPlot.MIN_FIGURE_HEIGHT.html:214,Integrat,Integrating,214,en/stable/api/generated/classes/scanpy.pl.MatrixPlot.MIN_FIGURE_HEIGHT.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.MatrixPlot.MIN_FIGURE_HEIGHT.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.MatrixPlot.add_dendrogram — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.MatrixPlot.add_dendrogram.html:211,Integrat,Integrating,211,en/stable/api/generated/classes/scanpy.pl.MatrixPlot.add_dendrogram.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.MatrixPlot.add_dendrogram.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.MatrixPlot.add_totals — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON; sc,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.MatrixPlot.add_totals.html:207,Integrat,Integrating,207,en/stable/api/generated/classes/scanpy.pl.MatrixPlot.add_totals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.MatrixPlot.add_totals.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.MatrixPlot.get_axes — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON; scan,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.MatrixPlot.get_axes.html:205,Integrat,Integrating,205,en/stable/api/generated/classes/scanpy.pl.MatrixPlot.get_axes.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.MatrixPlot.get_axes.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.MatrixPlot.getdoc — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON; scanpy,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.MatrixPlot.getdoc.html:203,Integrat,Integrating,203,en/stable/api/generated/classes/scanpy.pl.MatrixPlot.getdoc.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.MatrixPlot.getdoc.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.MatrixPlot.legend — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON; scanpy,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.MatrixPlot.legend.html:203,Integrat,Integrating,203,en/stable/api/generated/classes/scanpy.pl.MatrixPlot.legend.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.MatrixPlot.legend.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.MatrixPlot.make_figure — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON; s,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.MatrixPlot.make_figure.html:208,Integrat,Integrating,208,en/stable/api/generated/classes/scanpy.pl.MatrixPlot.make_figure.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.MatrixPlot.make_figure.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.MatrixPlot.savefig — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON; scanp,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.MatrixPlot.savefig.html:204,Integrat,Integrating,204,en/stable/api/generated/classes/scanpy.pl.MatrixPlot.savefig.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.MatrixPlot.savefig.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.MatrixPlot.show — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON; scanpy.p,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.MatrixPlot.show.html:201,Integrat,Integrating,201,en/stable/api/generated/classes/scanpy.pl.MatrixPlot.show.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.MatrixPlot.show.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.MatrixPlot.style — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON; scanpy.,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.MatrixPlot.style.html:202,Integrat,Integrating,202,en/stable/api/generated/classes/scanpy.pl.MatrixPlot.style.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.MatrixPlot.style.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.MatrixPlot.swap_axes — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON; sca,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.MatrixPlot.swap_axes.html:206,Integrat,Integrating,206,en/stable/api/generated/classes/scanpy.pl.MatrixPlot.swap_axes.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.MatrixPlot.swap_axes.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.StackedViolin — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON; scanpy.pl.,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.html:199,Integrat,Integrating,199,en/stable/api/generated/classes/scanpy.pl.StackedViolin.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.StackedViolin.DEFAULT_CATEGORY_HEIGHT — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFA,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_CATEGORY_HEIGHT.html:223,Integrat,Integrating,223,en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_CATEGORY_HEIGHT.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_CATEGORY_HEIGHT.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.StackedViolin.DEFAULT_CATEGORY_WIDTH — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAU,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_CATEGORY_WIDTH.html:222,Integrat,Integrating,222,en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_CATEGORY_WIDTH.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_CATEGORY_WIDTH.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.StackedViolin.DEFAULT_COLORMAP — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COL,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_COLORMAP.html:216,Integrat,Integrating,216,en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_COLORMAP.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_COLORMAP.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.StackedViolin.DEFAULT_COLOR_LEGEND_TITLE — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.D,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_COLOR_LEGEND_TITLE.html:226,Integrat,Integrating,226,en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_COLOR_LEGEND_TITLE.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_COLOR_LEGEND_TITLE.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.StackedViolin.DEFAULT_CUT — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_CUT.html:211,Integrat,Integrating,211,en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_CUT.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_CUT.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.StackedViolin.DEFAULT_DENSITY_NORM — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_DENSITY_NORM.html:220,Integrat,Integrating,220,en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_DENSITY_NORM.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_DENSITY_NORM.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.StackedViolin.DEFAULT_INNER — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_INNER.html:213,Integrat,Integrating,213,en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_INNER.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_INNER.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.StackedViolin.DEFAULT_JITTER — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_JITTER.html:214,Integrat,Integrating,214,en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_JITTER.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_JITTER.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.StackedViolin.DEFAULT_JITTER_SIZE — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_JITTER_SIZE.html:219,Integrat,Integrating,219,en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_JITTER_SIZE.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_JITTER_SIZE.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.StackedViolin.DEFAULT_LEGENDS_WIDTH — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAUL,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_LEGENDS_WIDTH.html:221,Integrat,Integrating,221,en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_LEGENDS_WIDTH.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_LEGENDS_WIDTH.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.StackedViolin.DEFAULT_LINE_WIDTH — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_C,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_LINE_WIDTH.html:218,Integrat,Integrating,218,en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_LINE_WIDTH.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_LINE_WIDTH.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.StackedViolin.DEFAULT_PLOT_X_PADDING — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAU,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_PLOT_X_PADDING.html:222,Integrat,Integrating,222,en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_PLOT_X_PADDING.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_PLOT_X_PADDING.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.StackedViolin.DEFAULT_PLOT_YTICKLABELS — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEF,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_PLOT_YTICKLABELS.html:224,Integrat,Integrating,224,en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_PLOT_YTICKLABELS.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_PLOT_YTICKLABELS.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.StackedViolin.DEFAULT_PLOT_Y_PADDING — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAU,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_PLOT_Y_PADDING.html:222,Integrat,Integrating,222,en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_PLOT_Y_PADDING.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_PLOT_Y_PADDING.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.StackedViolin.DEFAULT_ROW_PALETTE — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_ROW_PALETTE.html:219,Integrat,Integrating,219,en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_ROW_PALETTE.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_ROW_PALETTE.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.StackedViolin.DEFAULT_SAVE_PREFIX — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_SAVE_PREFIX.html:219,Integrat,Integrating,219,en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_SAVE_PREFIX.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_SAVE_PREFIX.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.StackedViolin.DEFAULT_STRIPPLOT — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_CO,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_STRIPPLOT.html:217,Integrat,Integrating,217,en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_STRIPPLOT.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_STRIPPLOT.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.StackedViolin.DEFAULT_WSPACE — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_WSPACE.html:214,Integrat,Integrating,214,en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_WSPACE.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_WSPACE.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.StackedViolin.DEFAULT_YLIM — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_O,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_YLIM.html:212,Integrat,Integrating,212,en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_YLIM.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.DEFAULT_YLIM.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.StackedViolin.MAX_NUM_CATEGORIES — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_C,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.MAX_NUM_CATEGORIES.html:218,Integrat,Integrating,218,en/stable/api/generated/classes/scanpy.pl.StackedViolin.MAX_NUM_CATEGORIES.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.MAX_NUM_CATEGORIES.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.StackedViolin.MIN_FIGURE_HEIGHT — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_CO,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.MIN_FIGURE_HEIGHT.html:217,Integrat,Integrating,217,en/stable/api/generated/classes/scanpy.pl.StackedViolin.MIN_FIGURE_HEIGHT.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.MIN_FIGURE_HEIGHT.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.StackedViolin.add_dendrogram — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.add_dendrogram.html:214,Integrat,Integrating,214,en/stable/api/generated/classes/scanpy.pl.StackedViolin.add_dendrogram.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.add_dendrogram.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.StackedViolin.add_totals — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON;,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.add_totals.html:210,Integrat,Integrating,210,en/stable/api/generated/classes/scanpy.pl.StackedViolin.add_totals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.add_totals.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.StackedViolin.get_axes — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON; s,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.get_axes.html:208,Integrat,Integrating,208,en/stable/api/generated/classes/scanpy.pl.StackedViolin.get_axes.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.get_axes.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.StackedViolin.getdoc — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON; sca,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.getdoc.html:206,Integrat,Integrating,206,en/stable/api/generated/classes/scanpy.pl.StackedViolin.getdoc.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.getdoc.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.StackedViolin.legend — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON; sca,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.legend.html:206,Integrat,Integrating,206,en/stable/api/generated/classes/scanpy.pl.StackedViolin.legend.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.legend.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.StackedViolin.make_figure — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.make_figure.html:211,Integrat,Integrating,211,en/stable/api/generated/classes/scanpy.pl.StackedViolin.make_figure.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.make_figure.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.StackedViolin.savefig — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON; sc,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.savefig.html:207,Integrat,Integrating,207,en/stable/api/generated/classes/scanpy.pl.StackedViolin.savefig.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.savefig.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.StackedViolin.show — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON; scanp,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.show.html:204,Integrat,Integrating,204,en/stable/api/generated/classes/scanpy.pl.StackedViolin.show.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.show.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.StackedViolin.style — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON; scan,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.style.html:205,Integrat,Integrating,205,en/stable/api/generated/classes/scanpy.pl.StackedViolin.style.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.style.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pl.StackedViolin.swap_axes — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON; ,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.swap_axes.html:209,Integrat,Integrating,209,en/stable/api/generated/classes/scanpy.pl.StackedViolin.swap_axes.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.swap_axes.html,2,['Integrat'],['Integrating']
Integrability,. scanpy.pp.scrublet_simulate_doublets — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_O,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pp.scrublet_simulate_doublets.html:212,Integrat,Integrating,212,en/stable/api/generated/scanpy.pp.scrublet_simulate_doublets.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pp.scrublet_simulate_doublets.html,2,['Integrat'],['Integrating']
Integrability,".external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.tl.ingest. Contents . ingest(). scanpy.tl.ingest#. scanpy.tl.ingest(adata, adata_ref, *, obs=None, embedding_method=('umap', 'pca'), labeling_method='knn', neighbors_key=None, inplace=True, **kwargs)[source]#; Map labels and embeddings from reference data to new data.; Integrating data using ingest and BBKNN; Integrates embeddings and annotations of an adata with a reference dataset; adata_ref through projecting on a PCA (or alternate; model) that has been fitted on the reference data. The function uses a knn; classifier for mapping labels and the UMAP package [McInnes et al., 2018] for mapping; the embeddings. Note; We refer to this asymmetric dataset integration as ingesting; annotations from reference data to new data. This is different from; learning a joint representation that integrates both datasets in an; unbiased way, as CCA (e.g. in Seurat) or a conditional VAE (e.g. in; scVI) would do. You need to run neighbors() on adata_ref before; passing it. Parameters:. adata AnnDataThe annotated data matrix of shape n_obs × n_vars. Rows correspond; to cells and columns to genes. This is the dataset without labels and; embeddings. adata_ref AnnDataThe annotated data matrix of shape n_obs × n_vars. Rows correspond; to cells and columns to genes.; Variables (n_vars and var_names) of adata_ref should be the same; as in adata.; This is the dataset with labels and embeddings; which need to be mapped to adata. obs str | Iterable[str] | None (default: None)Labels’ keys in adata_ref.obs which need to be mapped to adata.obs; (inferred for observation of adata). embedding_method str | Iterable[str] (default: ('umap', 'pca'))Embeddings in adata_ref which need",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.ingest.html:9893,integrat,integration,9893,en/stable/generated/scanpy.tl.ingest.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.ingest.html,1,['integrat'],['integration']
Integrability,".external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.external.tl.palantir_results. Contents . palantir_results(). scanpy.external.tl.palantir_results#. scanpy.external.tl.palantir_results(adata, early_cell, *, ms_data='X_palantir_multiscale', terminal_states=None, knn=30, num_waypoints=1200, n_jobs=-1, scale_components=True, use_early_cell_as_start=False, max_iterations=25)[source]#; Running Palantir; A convenience function that wraps palantir.core.run_palantir to compute branch; probabilities and waypoints. Parameters:. adata AnnDataAn AnnData object. early_cell strStart cell for pseudotime construction. ms_data str (default: 'X_palantir_multiscale')Palantir multi scale data matrix,. terminal_states list | None (default: None)List of user defined terminal states. knn int (default: 30)Number of nearest neighbors for graph construction. num_waypoints int (default: 1200)Number of waypoints to sample. n_jobs int (default: -1)Number of jobs for parallel processing. scale_components bool (default: True)Transform features by scaling each feature to a given range. Consult the; documentation for sklearn.preprocessing.minmax_scale. use_early_cell_as_start bool (default: False)Use early_cell as start_cell, instead of determining it from the boundary; cells closest to the defined early_cell. max_iter",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.palantir_results.html:9631,wrap,wraps,9631,en/stable/external/generated/scanpy.external.tl.palantir_results.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.palantir_results.html,2,['wrap'],['wraps']
Integrability,.gene_coordinates.rst; scanpy.queries.mitochondrial_genes.rst; scanpy.read.rst; scanpy.read_10x_h5.rst; scanpy.read_10x_mtx.rst; scanpy.read_csv.rst; scanpy.read_excel.rst; scanpy.read_h5ad.rst; scanpy.read_hdf.rst; scanpy.read_loom.rst; scanpy.read_mtx.rst; scanpy.read_text.rst; scanpy.read_umi_tools.rst; scanpy.read_visium.rst; scanpy.set_figure_params.rst; scanpy.tl.dendrogram.rst; scanpy.tl.diffmap.rst; scanpy.tl.dpt.rst; scanpy.tl.draw_graph.rst; scanpy.tl.embedding_density.rst; scanpy.tl.filter_rank_genes_groups.rst; scanpy.tl.ingest.rst; scanpy.tl.leiden.rst; scanpy.tl.louvain.rst; scanpy.tl.marker_gene_overlap.rst; scanpy.tl.paga.rst; scanpy.tl.rank_genes_groups.rst; scanpy.tl.score_genes.rst; scanpy.tl.score_genes_cell_cycle.rst; scanpy.tl.sim.rst; scanpy.tl.tsne.rst; scanpy.tl.umap.rst. /how-to; ; index.md; knn-transformers.ipynb; plotting-with-marsilea.ipynb. /release-notes; ; index.md. /tutorials; . /basics; ; clustering.ipynb; clustering-2017.ipynb; index.md; integrating-data-using-ingest.ipynb. /experimental; ; dask.ipynb; index.md; pearson_residuals.ipynb. /plotting; ; advanced.ipynb; core.ipynb; index.md. /spatial; ; index.md; integration-scanorama.ipynb. /trajectories; ; index.md; paga-paul15.ipynb. index.md. community.md; contributors.md; ecosystem.md; index.md; installation.md; news.md; references.rst; usage-principles.md. /_static; . /css; ; rtd_sphinx_search.min.css. /js; ; rtd_search_config.js; rtd_sphinx_search.min.js. /scripts; ; bootstrap.js; pydata-sphinx-theme.js; rtd-sphinx-search.js; sphinx-book-theme.js. /styles; ; bootstrap.css; pydata-sphinx-theme.css; scanpy.css; sphinx-book-theme.css; theme.css. /vendor; . /fontawesome; . /6.5.2; . /css; ; all.min.css. /js; ; all.min.js. /webfonts; ; fa-brands-400.ttf; fa-brands-400.woff2; fa-regular-400.ttf; fa-regular-400.woff2; fa-solid-900.ttf; fa-solid-900.woff2; fa-v4compatibility.ttf; fa-v4compatibility.woff2. basic.css; clipboard.min.js; copybutton.css; copybutton.js; design-tabs.js; doctool,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/index-wcopy.html:9732,integrat,integrating-data-using-ingest,9732,index-wcopy.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/index-wcopy.html,1,['integrat'],['integrating-data-using-ingest']
Integrability,".pp.mnn_correct; scanpy.external.pp.scanorama_integrate; scanpy.external.pp.hashsolo; scanpy.external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .md. .pdf. Preprocessing: PP. Contents . Data integration; Sample demultiplexing; Imputation. Preprocessing: PP#. Data integration#. pp.bbknn(adata, *[, batch_key, use_rep, ...]); Batch balanced kNN [Polański et al., 2019]. pp.harmony_integrate(adata, key, *[, basis, ...]); Use harmonypy [Korsunsky et al., 2019] to integrate different experiments. pp.mnn_correct(*datas[, var_index, ...]); Correct batch effects by matching mutual nearest neighbors [Haghverdi et al., 2018] [Kang, 2018]. pp.scanorama_integrate(adata, key, *[, ...]); Use Scanorama [Hie et al., 2019] to integrate different experiments. Sample demultiplexing#. pp.hashsolo(adata, cell_hashing_columns, *); Probabilistic demultiplexing of cell hashing data using HashSolo [Bernstein et al., 2020]. Imputation#; Note that the fundamental limitations of imputation are still under debate. pp.dca(adata[, mode, ae_type, ...]); Deep count autoencoder [Eraslan et al., 2019]. pp.magic(adata[, name_list, knn, decay, ...]); Markov Affinity-based Graph Imputation of Cells (MAGIC) API [van Dijk et al., 2018]. previous; External API. next; scanpy.external.pp.bbkn",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/preprocessing.html:9333,integrat,integration,9333,en/stable/external/preprocessing.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/preprocessing.html,1,['integrat'],['integration']
Integrability,"; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.pp.scrublet. Contents . scrublet(). scanpy.pp.scrublet#. scanpy.pp.scrublet(adata, adata_sim=None, *, batch_key=None, sim_doublet_ratio=2.0, expected_doublet_rate=0.05, stdev_doublet_rate=0.02, synthetic_doublet_umi_subsampling=1.0, knn_dist_metric='euclidean', normalize_variance=True, log_transform=False, mean_center=True, n_prin_comps=30, use_approx_neighbors=None, get_doublet_neighbor_parents=False, n_neighbors=None, threshold=None, verbose=True, copy=False, random_state=0)[source]#; Predict doublets using Scrublet [Wolock et al., 2019].; Predict cell doublets using a nearest-neighbor classifier of observed; transcriptomes and simulated doublets. Works best if the input is a raw; (unnormalized) counts matrix from a single sample or a collection of; similar samples from the same experiment.; This function is a wrapper around functions that pre-process using Scanpy; and directly call functions of Scrublet(). You may also undertake your own; preprocessing, simulate doublets with; scrublet_simulate_doublets(), and run the core scrublet; function scrublet() with adata_sim set. Parameters:. adata AnnDataThe annotated data matrix of shape n_obs × n_vars. Rows; correspond to cells and columns to genes. Expected to be un-normalised; where adata_sim is not supplied, in which case doublets will be; simulated and pre-processing applied to both objects. If adata_sim is; supplied, this should be the observed transcriptomes processed; consistently (filtering, transform, normalisaton, hvg) with adata_sim. adata_sim AnnData | None (default: None)(Advanced use case) Optional annData object generated by; scrublet_simulate_doublets(), with same number of vars; as adata. This should have been built from adata_obs after; filtering genes and cells and selcting highly-variable genes. batch_key str | None (default: None)Optional obs column name discrimi",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pp.scrublet.html:10058,wrap,wrapper,10058,en/stable/api/generated/scanpy.pp.scrublet.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pp.scrublet.html,1,['wrap'],['wrapper']
Integrability,"; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.pl.MatrixPlot. Contents . MatrixPlot. scanpy.pl.MatrixPlot#. class scanpy.pl.MatrixPlot(adata, var_names, groupby, *, use_raw=None, log=False, num_categories=7, categories_order=None, title=None, figsize=None, gene_symbols=None, var_group_positions=None, var_group_labels=None, var_group_rotation=None, layer=None, standard_scale=None, ax=None, values_df=None, vmin=None, vmax=None, vcenter=None, norm=None, **kwds)[source]#; Allows the visualization of values using a color map. Parameters:. adata AnnDataAnnotated data matrix. var_names Union[str, Sequence[str], Mapping[str, Union[str, Sequence[str]]]]var_names should be a valid subset of adata.var_names.; If var_names is a mapping, then the key is used as label; to group the values (see var_group_labels). The mapping values; should be sequences of valid adata.var_names. In this; case either coloring or ‘brackets’ are used for the grouping; of var names depending on the plot. When var_names is a mapping,; then the var_group_labels and var_group_positions are set. groupby str | Sequence[str]The key of the observation grouping to consider. use_raw bool | None (default: None)Use raw attribute of adata if present. log bool (default: False)Plot on logarithmic axis. num_categories int (default: 7)Only used if groupby observation is not categorical. This value; determines the number of groups into which the groupby observation; should be subdivided. categories_order Sequence[str] | None (default: None)Order in which to show the categories. Note: add_dendrogram or add_totals; can change the categories order. figsize tuple[float, float] | None (default: None)Figure size when multi_panel=True.; Otherwise the rcParam['figure.figsize] value is used.; Format is (width, height). dendrogramIf True or a valid dendrogram key, a dendrogram based on the hierarchical; clustering between the groupby categories is added.; The",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.MatrixPlot.html:10149,depend,depending,10149,en/stable/api/generated/classes/scanpy.pl.MatrixPlot.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.MatrixPlot.html,2,['depend'],['depending']
Integrability,"; adata_spatial_posterior.var.set_index(""gene_ids"", inplace=True). Subset the spatial anndata to (approximately) selects only spots belonging to the cortex. adata_anterior_subset = adata_spatial_anterior[; adata_spatial_anterior.obsm[""spatial""][:, 1] < 6000, :; ]; adata_posterior_subset = adata_spatial_posterior[; (adata_spatial_posterior.obsm[""spatial""][:, 1] < 4000); & (adata_spatial_posterior.obsm[""spatial""][:, 0] < 6000),; :,; ]. Run integration with Scanorama. adatas_anterior = [adata_cortex, adata_anterior_subset]; adatas_posterior = [adata_cortex, adata_posterior_subset]. # Integration.; adatas_cor_anterior = scanorama.correct_scanpy(adatas_anterior, return_dimred=True); adatas_cor_posterior = scanorama.correct_scanpy(adatas_posterior, return_dimred=True). Found 22689 genes among all datasets; [[0. 0.22877847]; [0. 0. ]]; Processing datasets (0, 1); Found 22689 genes among all datasets; [[0. 0.35810811]; [0. 0. ]]; Processing datasets (0, 1). Concatenate datasets and assign integrated embeddings to anndata objects.; Notice that we are concatenating datasets with the join=""outer"" and uns_merge=""first"" strategies. This is because we want to keep the obsm['coords'] as well as the images of the visium datasets. adata_cortex_anterior = sc.concat(; adatas_cor_anterior,; label=""dataset"",; keys=[""smart-seq"", ""visium""],; join=""outer"",; uns_merge=""first"",; ); adata_cortex_posterior = sc.concat(; adatas_cor_posterior,; label=""dataset"",; keys=[""smart-seq"", ""visium""],; join=""outer"",; uns_merge=""first"",; ). At this step, we have integrated each visium dataset in a common embedding with the scRNA-seq dataset. In such embedding space, we can compute distances between samples and use such distances as weights to be used for for propagating labels from the scRNA-seq dataset to the Visium dataset.; Such approach is very similar to the TransferData function in Seurat (see paper). Here, we re-implement the label transfer function with a simple python function, see below.; Frist, ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html:22768,integrat,integrated,22768,en/stable/tutorials/spatial/integration-scanorama.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html,2,['integrat'],['integrated']
Integrability,"; few non-zero fitted coefficients). Return type:; AnnData | None. Returns:; Returns None if copy=False, else returns an AnnData object. Sets the following fields:. adata.uns['rank_genes_groups' | key_added]['names']structured numpy.ndarray (dtype object)Structured array to be indexed by group id storing the gene; names. Ordered according to scores. adata.uns['rank_genes_groups' | key_added]['scores']structured numpy.ndarray (dtype object)Structured array to be indexed by group id storing the z-score; underlying the computation of a p-value for each gene for each; group. Ordered according to scores. adata.uns['rank_genes_groups' | key_added]['logfoldchanges']structured numpy.ndarray (dtype object)Structured array to be indexed by group id storing the log2; fold change for each gene for each group. Ordered according to; scores. Only provided if method is ‘t-test’ like.; Note: this is an approximation calculated from mean-log values. adata.uns['rank_genes_groups' | key_added]['pvals']structured numpy.ndarray (dtype float)p-values. adata.uns['rank_genes_groups' | key_added]['pvals_adj']structured numpy.ndarray (dtype float)Corrected p-values. adata.uns['rank_genes_groups' | key_added]['pts']pandas.DataFrame (dtype float)Fraction of cells expressing the genes for each group. adata.uns['rank_genes_groups' | key_added]['pts_rest']pandas.DataFrame (dtype float)Only if reference is set to 'rest'.; Fraction of cells from the union of the rest of each group; expressing the genes. Notes; There are slight inconsistencies depending on whether sparse; or dense data are passed. See here.; Examples; >>> import scanpy as sc; >>> adata = sc.datasets.pbmc68k_reduced(); >>> sc.tl.rank_genes_groups(adata, 'bulk_labels', method='wilcoxon'); >>> # to visualize the results; >>> sc.pl.rank_genes_groups(adata). previous; scanpy.tl.ingest. next; scanpy.tl.filter_rank_genes_groups. Contents; . rank_genes_groups(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.rank_genes_groups.html:13436,depend,depending,13436,en/stable/generated/scanpy.tl.rank_genes_groups.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.rank_genes_groups.html,1,['depend'],['depending']
Integrability,"; scanpy.external.pp.bbknn; scanpy.external.pp.harmony_integrate; scanpy.external.pp.mnn_correct; scanpy.external.pp.scanorama_integrate; scanpy.external.pp.hashsolo; scanpy.external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .ipynb. .pdf. Integrating spatial data with scRNA-seq using scanorama. Contents . Loading libraries; Reading the data; Data integration; Data integration and label transfer from scRNA-seq dataset. Integrating spatial data with scRNA-seq using scanorama#; Author: Giovanni Palla. Note; For up-to-date analysis tutorials, kindly check out SquidPy tutorials. This tutorial shows how to work with multiple Visium datasets and perform integration of scRNA-seq dataset with Scanpy. It follows the previous tutorial on analysis and visualization of spatial transcriptomics data.; We will use Scanorama paper - code to perform integration and label transfer. It has a convenient interface with scanpy and anndata.; To install the required libraries, type the following:; pip install git+https://github.com/theislab/scanpy.git; pip install git+https://github.com/theislab/anndata.git; pip install scanorama. Loading libraries#. import scanpy as sc; import anndata as an; import pandas as pd; import numpy as np; import matplotlib.pyplot as plt; import",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html:9267,Integrat,Integrating,9267,en/stable/tutorials/spatial/integration-scanorama.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html,1,['Integrat'],['Integrating']
Integrability,"=7, figsize=None, dendrogram=False, title=None, cmap='viridis', colorbar_title='Mean expression\\nin group', gene_symbols=None, var_group_positions=None, var_group_labels=None, var_group_rotation=None, layer=None, standard_scale=None, values_df=None, swap_axes=False, show=None, save=None, ax=None, return_fig=False, vmin=None, vmax=None, vcenter=None, norm=None, **kwds)[source]#; Creates a heatmap of the mean expression values per group of each var_names.; This function provides a convenient interface to the MatrixPlot; class. If you need more flexibility, you should use MatrixPlot; directly. Parameters:. adata AnnDataAnnotated data matrix. var_names Union[str, Sequence[str], Mapping[str, Union[str, Sequence[str]]]]var_names should be a valid subset of adata.var_names.; If var_names is a mapping, then the key is used as label; to group the values (see var_group_labels). The mapping values; should be sequences of valid adata.var_names. In this; case either coloring or ‘brackets’ are used for the grouping; of var names depending on the plot. When var_names is a mapping,; then the var_group_labels and var_group_positions are set. groupby str | Sequence[str]The key of the observation grouping to consider. use_raw bool | None (default: None)Use raw attribute of adata if present. log bool (default: False)Plot on logarithmic axis. num_categories int (default: 7)Only used if groupby observation is not categorical. This value; determines the number of groups into which the groupby observation; should be subdivided. categories_orderOrder in which to show the categories. Note: add_dendrogram or add_totals; can change the categories order. figsize tuple[float, float] | None (default: None)Figure size when multi_panel=True.; Otherwise the rcParam['figure.figsize] value is used.; Format is (width, height). dendrogram bool | str (default: False)If True or a valid dendrogram key, a dendrogram based on the hierarchical; clustering between the groupby categories is added.; The dendrogr",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pl.matrixplot.html:10421,depend,depending,10421,en/stable/generated/scanpy.pl.matrixplot.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pl.matrixplot.html,1,['depend'],['depending']
Integrability,"=None, var_group_labels=None, var_group_rotation=None, layer=None, standard_scale=None, swap_axes=False, show_gene_labels=None, show=None, save=None, figsize=None, vmin=None, vmax=None, vcenter=None, norm=None, **kwds)[source]#; Heatmap of the expression values of genes.; If groupby is given, the heatmap is ordered by the respective group. For; example, a list of marker genes can be plotted, ordered by clustering. If; the groupby observation annotation is not categorical the observation; annotation is turned into a categorical by binning the data into the number; specified in num_categories. Parameters:. adata AnnDataAnnotated data matrix. var_names Union[str, Sequence[str], Mapping[str, Union[str, Sequence[str]]]]var_names should be a valid subset of adata.var_names.; If var_names is a mapping, then the key is used as label; to group the values (see var_group_labels). The mapping values; should be sequences of valid adata.var_names. In this; case either coloring or ‘brackets’ are used for the grouping; of var names depending on the plot. When var_names is a mapping,; then the var_group_labels and var_group_positions are set. groupby str | Sequence[str]The key of the observation grouping to consider. use_raw bool | None (default: None)Use raw attribute of adata if present. log bool (default: False)Plot on logarithmic axis. num_categories int (default: 7)Only used if groupby observation is not categorical. This value; determines the number of groups into which the groupby observation; should be subdivided. categories_orderOrder in which to show the categories. Note: add_dendrogram or add_totals; can change the categories order. figsize tuple[float, float] | None (default: None)Figure size when multi_panel=True.; Otherwise the rcParam['figure.figsize] value is used.; Format is (width, height). dendrogram bool | str (default: False)If True or a valid dendrogram key, a dendrogram based on the hierarchical; clustering between the groupby categories is added.; The dendrogr",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pl.heatmap.html:10466,depend,depending,10466,en/stable/generated/scanpy.pl.heatmap.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pl.heatmap.html,1,['depend'],['depending']
Integrability,"C metrics) driving signifigant variation in this dataset. In this case, there isn’t anything too alarming, but it’s a good idea to explore this. sc.pl.pca(; adata,; color=[""sample"", ""sample"", ""pct_counts_mt"", ""pct_counts_mt""],; dimensions=[(0, 1), (2, 3), (0, 1), (2, 3)],; ncols=2,; size=2,; ). Nearest neighbor graph constuction and visualization#; Let us compute the neighborhood graph of cells using the PCA representation of the data matrix. sc.pp.neighbors(adata). This graph can then be embedded in two dimensions for visualiztion with UMAP (McInnes et al., 2018):. sc.tl.umap(adata). We can now visualize the UMAP according to the sample. sc.pl.umap(; adata,; color=""sample"",; # Setting a smaller point size to get prevent overlap; size=2,; ). Even though the data considered in this tutorial includes two different samples, we only observe a minor batch effect and we can continue with clustering and annotation of our data.; If you inspect batch effects in your UMAP it can be beneficial to integrate across samples and perform batch correction/integration. We recommend checking out scanorama and scvi-tools for batch integration. Clustering#; As with Seurat and many other frameworks, we recommend the Leiden graph-clustering method (community detection based on optimizing modularity) [Traag et al., 2019]. Note that Leiden clustering directly clusters the neighborhood graph of cells, which we already computed in the previous section. # Using the igraph implementation and a fixed number of iterations can be significantly faster, especially for larger datasets; sc.tl.leiden(adata, flavor=""igraph"", n_iterations=2). sc.pl.umap(adata, color=[""leiden""]). Re-assess quality control and cell filtering#; As indicated before, we will now re-assess our filtering strategy by visualizing different QC metrics using UMAP. sc.pl.umap(; adata,; color=[""leiden"", ""predicted_doublet"", ""doublet_score""],; # increase horizontal space between panels; wspace=0.5,; size=3,; ). sc.pl.umap(; adata,; co",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering.html:17211,integrat,integrate,17211,en/stable/tutorials/basics/clustering.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering.html,4,['integrat'],"['integrate', 'integration']"
Integrability,"Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .md. .pdf. Installation. Contents . Development Version; Docker; Troubleshooting. Installation#; To use scanpy from another project, install it using your favourite environment manager:. Hatch (recommended)Pip/PyPICondaAdding scanpy[leiden] to your dependencies is enough.; See below for how to use Scanpy’s Development Version.; If you prefer to exclusively use PyPI run:; $ pip install 'scanpy[leiden]'. After installing installing e.g. Miniconda, run:; $ conda install -c conda-forge scanpy python-igraph leidenalg. Pull Scanpy from PyPI (consider using pip3 to access Python 3):; $ pip install scanpy. If you use Hatch or pip, the extra [leiden] installs two packages that are needed for popular; parts of scanpy but aren’t requirements: igraph [Csárdi and Nepusz, 2006] and leiden [Traag et al., 2019].; If you use conda, you should to add these dependencies to your environment individually. Development Version#; To work with the latest version on GitHub: clone the repository and cd into its root directory.; $ gh repo clone scverse/scanpy; $ cd scanpy. Hatch (recommended)Pip/PyPICondaTo use one of the predefined Hatch environments in hatch.toml,; run either hatch test [args] or hatch run [env:]command [...args], e.g.:; $ hatch test -p # run tests in parallel; $ hatch run docs:build # build docs; $ hatch run towncrier:create # create changelog entry. If you are using pip>=21.3, an editable install can be made:; $ python -m venv .venv; $ source .venv/bin/activate; $ pip install -e '.[dev,test]'. If you want to let conda handle the installations of dependencies, do:; $ pipx install beni; $ beni pyproject.toml > environment.yml; $ conda env create -f environment.yml; $ conda activate scanpy; $ pip install -e '.[dev,doc,test]'. For instructions on how to work with the code, see the contribution guide. Docker#; If you’re using Docker",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/installation.html:10060,depend,dependencies,10060,en/stable/installation.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/installation.html,1,['depend'],['dependencies']
Integrability,"Data integration and label transfer from scRNA-seq dataset#; We can also perform data integration between one scRNA-seq dataset and one spatial transcriptomics dataset. Such task is particularly useful because it allows us to transfer cell type labels to the Visium dataset, which were dentified from the scRNA-seq dataset.; For this task, we will be using a dataset from Tasic et al., where the mouse cortex was profiled with smart-seq technology.; The dataset can be downloaded from GEO count - metadata.; Conveniently, you can also download the pre-processed dataset in h5ad format from here.; Since the dataset was generated from the mouse cortex, we will subset the visium dataset in order to select only the spots part of the cortex. Note that the integration can also be performed on the whole brain slice, but it would give rise to false positive cell type assignments and and therefore it should be interpreted with more care.; The integration task will be performed with Scanorama: each Visium dataset will be integrated with the smart-seq cortex dataset.; The following cell should be uncommented out and run if this is the first time running this notebook. if not Path(""./data/adata_processed.h5ad"").exists():; !wget https://ftp.ncbi.nlm.nih.gov/geo/series/GSE115nnn/GSE115746/suppl/GSE115746_cells_exon_counts.csv.gz -O data/GSE115746_cells_exon_counts.csv.gz; !gunzip data/GSE115746_cells_exon_counts.csv.gz; !wget https://ftp.ncbi.nlm.nih.gov/geo/series/GSE115nnn/GSE115746/suppl/GSE115746_complete_metadata_28706-cells.csv.gz -O data/GSE115746_complete_metadata_28706-cells.csv.gz; !gunzip data/GSE115746_complete_metadata_28706-cells.csv.gz; %pip install pybiomart; counts = pd.read_csv(""data/GSE115746_cells_exon_counts.csv"", index_col=0).T; meta = pd.read_csv(; ""data/GSE115746_complete_metadata_28706-cells.csv"", index_col=""sample_name""; ); meta = meta.loc[counts.index]; annot = sc.queries.biomart_annotations(; ""mmusculus"",; [""mgi_symbol"", ""ensembl_gene_id""],; ).set_index(""mgi_",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html:20278,integrat,integration,20278,en/stable/tutorials/spatial/integration-scanorama.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html,4,['integrat'],"['integrated', 'integration']"
Integrability,"ML no longer returns a squared Euclidean distance matrix, so we should not square-root the kNN distance matrix. pr1828 M Zaslavsky; Removed pytables dependency by implementing read_10x_h5 with h5py due to installation errors on Windows pr2064; Fixed bug in scanpy.external.pp.hashsolo() where default value was set improperly pr2190 B Reiz; Fixed bug in scanpy.pl.embedding() functions where an error could be raised when there were missing values and large numbers of categories pr2187 I Virshup. Version 1.8#. 1.8.2 2021-11-3#. Documentation#. Update conda installation instructions pr1974 L Heumos. Bug fixes#. Fix plotting after scanpy.tl.filter_rank_genes_groups() pr1942 S Rybakov; Fix use_raw=None using anndata.AnnData.var_names if anndata.AnnData.raw; is present in scanpy.tl.score_genes() pr1999 M Klein; Fix compatibility with UMAP 0.5.2 pr2028 L Mcinnes; Fixed non-determinism in scanpy.pl.paga() node positions pr1922 I Virshup. Ecosystem#. Added PASTE (a tool to align and integrate spatial transcriptomics data) to scanpy ecosystem. 1.8.1 2021-07-07#. Bug fixes#. Fixed reproducibility of scanpy.tl.score_genes(). Calculation and output is now float64 type. pr1890 I Kucinski; Workarounds for some changes/ bugs in pandas 1.3 pr1918 I Virshup; Fixed bug where sc.pl.paga_compare could mislabel nodes on the paga graph pr1898 I Virshup; Fixed handling of use_raw with scanpy.tl.rank_genes_groups() pr1934 I Virshup. 1.8.0 2021-06-28#. Metrics module#. Added scanpy.metrics module!. Added scanpy.metrics.gearys_c() for spatial autocorrelation pr915 I Virshup; Added scanpy.metrics.morans_i() for global spatial autocorrelation pr1740 I Virshup, G Palla; Added scanpy.metrics.confusion_matrix() for comparing labellings pr915 I Virshup. Features#. Added layer and copy kwargs to normalize_total() pr1667 I Virshup; Added vcenter and norm arguments to the plotting functions pr1551 G Eraslan; Standardized and expanded available arguments to the sc.pl.rank_genes_groups* family of function",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:25602,integrat,integrate,25602,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,1,['integrat'],['integrate']
Integrability,"Python library designed for the analysis and visualization of transcriptomes, especially with long-read transcriptomes in mind.; Users can add transcriptomes from different datasets and explore distinct splicing and expression patterns across datasets. Analysis methods#. scvi-tools#. scvi-tools Berkeley. scvi-tools hosts deep generative models (DGM) for end-to-end analysis of single-cell; omics data (e.g., scVI, scANVI, totalVI). It also contains several primitives to build novel DGMs. Fate mapping#. CellRank Helmholtz Munich. CellRank is a framework to uncover cellular dynamics based on single-cell data.; It incorporates modalities such as RNA velocity, pseudotime, developmental potential, real-time information, etc. Differential expression#. diffxpy Helmholtz Munich. Data integration#. scanaroma MIT. Modeling perturbations#. scGen / trVAE Helmholtz Munich. Feature selection#. triku 🦔 Biodonostia Health Research Institute; CIARA Helmholtz Munich. CIARA is an algorithm for feature selection, that aims for the identification of rare cell types via scRNA-Seq data in scanpy. Annotation/ Enrichment Analysis#; Analyses using curated prior knowledge. decoupler is a collection of footprint enrichment methods that allows to infer transcription factor or pathway activities. Institute for Computational Biomedicine, Heidelberg University; Cubé Harvard University. Intuitive Nonparametric Gene Network Search Algorithm that learns from existing biological pathways & multiplicative gene interference patterns. previous; scanpy.external.exporting.cellbrowser. next; Release notes. Contents; . Viewers; Portals; Modalities; RNA velocity; Spatial Transcriptomics Tools; Multimodal integration; Adaptive immune receptor repertoire (AIRR); Long reads. Analysis methods; scvi-tools; Fate mapping; Differential expression; Data integration; Modeling perturbations; Feature selection; Annotation/ Enrichment Analysis. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/ecosystem.html:13109,integrat,integration,13109,en/stable/ecosystem.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/ecosystem.html,2,['integrat'],['integration']
Integrability,"R) repertoires. dandelion University of Cambridge. dandelion is a single-cell BCR-seq network analysis package that integrates with transcriptomic data analyzed via scanpy. Long reads#. Swan UC Irvine. Swan is a Python library designed for the analysis and visualization of transcriptomes, especially with long-read transcriptomes in mind.; Users can add transcriptomes from different datasets and explore distinct splicing and expression patterns across datasets. Analysis methods#. scvi-tools#. scvi-tools Berkeley. scvi-tools hosts deep generative models (DGM) for end-to-end analysis of single-cell; omics data (e.g., scVI, scANVI, totalVI). It also contains several primitives to build novel DGMs. Fate mapping#. CellRank Helmholtz Munich. CellRank is a framework to uncover cellular dynamics based on single-cell data.; It incorporates modalities such as RNA velocity, pseudotime, developmental potential, real-time information, etc. Differential expression#. diffxpy Helmholtz Munich. Data integration#. scanaroma MIT. Modeling perturbations#. scGen / trVAE Helmholtz Munich. Feature selection#. triku 🦔 Biodonostia Health Research Institute; CIARA Helmholtz Munich. CIARA is an algorithm for feature selection, that aims for the identification of rare cell types via scRNA-Seq data in scanpy. Annotation/ Enrichment Analysis#; Analyses using curated prior knowledge. decoupler is a collection of footprint enrichment methods that allows to infer transcription factor or pathway activities. Institute for Computational Biomedicine, Heidelberg University; Cubé Harvard University. Intuitive Nonparametric Gene Network Search Algorithm that learns from existing biological pathways & multiplicative gene interference patterns. previous; scanpy.external.exporting.cellbrowser. next; Release notes. Contents; . Viewers; Portals; Modalities; RNA velocity; Spatial Transcriptomics Tools; Multimodal integration; Adaptive immune receptor repertoire (AIRR); Long reads. Analysis methods; scvi-tools; Fa",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/ecosystem.html:12206,integrat,integration,12206,en/stable/ecosystem.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/ecosystem.html,1,['integrat'],['integration']
Integrability,"The triplets are sampled from the high-dimensional representation of the; points and a weighting scheme is used to reflect the importance of each; triplet.; TriMap provides a significantly better global view of the data than the; other dimensionality reduction methods such t-SNE, LargeVis, and UMAP.; The global structure includes relative distances of the clusters, multiple; scales in the data, and the existence of possible outliers. We define a; global score to quantify the quality of an embedding in reflecting the; global structure of the data. Parameters:. adata AnnDataAnnotated data matrix. n_components int (default: 2)Number of dimensions of the embedding. n_inliers int (default: 10)Number of inlier points for triplet constraints. n_outliers int (default: 5)Number of outlier points for triplet constraints. n_random int (default: 5)Number of random triplet constraints per point. metric Literal['angular', 'euclidean', 'hamming', 'manhattan'] (default: 'euclidean')Distance measure: ‘angular’, ‘euclidean’, ‘hamming’, ‘manhattan’. weight_adj float (default: 500.0)Adjusting the weights using a non-linear transformation. lr float (default: 1000.0)Learning rate. n_iters int (default: 400)Number of iterations. verbose bool | int | None (default: None)If True, print the progress report.; If None, sc.settings.verbosity is used. copy bool (default: False)Return a copy instead of writing to adata. Return type:; AnnData | None. Returns:; Depending on copy, returns or updates adata with the following fields. X_trimapndarray, (obsm, shape=(n_samples, n_components), dtype float)TriMap coordinates of data. Example; >>> import scanpy as sc; >>> import scanpy.external as sce; >>> pbmc = sc.datasets.pbmc68k_reduced(); >>> pbmc = sce.tl.trimap(pbmc, copy=True); >>> sce.pl.trimap(pbmc, color=['bulk_labels'], s=10). previous; scanpy.external.tl.palantir. next; scanpy.external.tl.sam. Contents; . trimap(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.trimap.html:11258,Depend,Depending,11258,en/stable/external/generated/scanpy.external.tl.trimap.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.trimap.html,1,['Depend'],['Depending']
Integrability,"_subset]. # Integration.; adatas_cor_anterior = scanorama.correct_scanpy(adatas_anterior, return_dimred=True); adatas_cor_posterior = scanorama.correct_scanpy(adatas_posterior, return_dimred=True). Found 22689 genes among all datasets; [[0. 0.22877847]; [0. 0. ]]; Processing datasets (0, 1); Found 22689 genes among all datasets; [[0. 0.35810811]; [0. 0. ]]; Processing datasets (0, 1). Concatenate datasets and assign integrated embeddings to anndata objects.; Notice that we are concatenating datasets with the join=""outer"" and uns_merge=""first"" strategies. This is because we want to keep the obsm['coords'] as well as the images of the visium datasets. adata_cortex_anterior = sc.concat(; adatas_cor_anterior,; label=""dataset"",; keys=[""smart-seq"", ""visium""],; join=""outer"",; uns_merge=""first"",; ); adata_cortex_posterior = sc.concat(; adatas_cor_posterior,; label=""dataset"",; keys=[""smart-seq"", ""visium""],; join=""outer"",; uns_merge=""first"",; ). At this step, we have integrated each visium dataset in a common embedding with the scRNA-seq dataset. In such embedding space, we can compute distances between samples and use such distances as weights to be used for for propagating labels from the scRNA-seq dataset to the Visium dataset.; Such approach is very similar to the TransferData function in Seurat (see paper). Here, we re-implement the label transfer function with a simple python function, see below.; Frist, let’s compute cosine distances between the visium dataset and the scRNA-seq dataset, in the common embedding space. from sklearn.metrics.pairwise import cosine_distances. distances_anterior = 1 - cosine_distances(; adata_cortex_anterior[adata_cortex_anterior.obs.dataset == ""smart-seq""].obsm[; ""X_scanorama""; ],; adata_cortex_anterior[adata_cortex_anterior.obs.dataset == ""visium""].obsm[; ""X_scanorama""; ],; ); distances_posterior = 1 - cosine_distances(; adata_cortex_posterior[adata_cortex_posterior.obs.dataset == ""smart-seq""].obsm[; ""X_scanorama""; ],; adata_cortex_posterio",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html:23320,integrat,integrated,23320,en/stable/tutorials/spatial/integration-scanorama.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html,2,['integrat'],['integrated']
Integrability,"a; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .md. .pdf. Installation. Contents . Development Version; Docker; Troubleshooting. Installation#; To use scanpy from another project, install it using your favourite environment manager:. Hatch (recommended)Pip/PyPICondaAdding scanpy[leiden] to your dependencies is enough.; See below for how to use Scanpy’s Development Version.; If you prefer to exclusively use PyPI run:; $ pip install 'scanpy[leiden]'. After installing installing e.g. Miniconda, run:; $ conda install -c conda-forge scanpy python-igraph leidenalg. Pull Scanpy from PyPI (consider using pip3 to access Python 3):; $ pip install scanpy. If you use Hatch or pip, the extra [leiden] installs two packages that are needed for popular; parts of scanpy but aren’t requirements: igraph [Csárdi and Nepusz, 2006] and leiden [Traag et al., 2019].; If you use conda, you should to add these dependencies to your environment individually. Development Version#; To work with the latest version on GitHub: clone the repository and cd into its root directory.; $ gh repo clone scverse/scanpy; $ cd scanpy. Hatch (recommended)Pip/PyPICondaTo use one of the predefined Hatch environments in hatch.toml,; run either hatch test [args] or hatch run [env:]command [...args], e.g.",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/installation.html:9458,depend,dependencies,9458,en/stable/installation.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/installation.html,1,['depend'],['dependencies']
Integrability,"anpy.external.pp.mnn_correct; scanpy.external.pp.scanorama_integrate; scanpy.external.pp.hashsolo; scanpy.external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .md. .pdf. Ecosystem. Contents . Viewers; Portals; Modalities; RNA velocity; Spatial Transcriptomics Tools; Multimodal integration; Adaptive immune receptor repertoire (AIRR); Long reads. Analysis methods; scvi-tools; Fate mapping; Differential expression; Data integration; Modeling perturbations; Feature selection; Annotation/ Enrichment Analysis. Ecosystem#. Warning; We are no longer accepting new tools on this page.; Instead, please submit your tool to the scverse ecosystem package listing. Viewers#; Interactive manifold viewers. cellxgene via direct reading of .h5ad CZI; cirrocumulus via direct reading of .h5ad Broad Inst.; cell browser via exporing through cellbrowser() UCSC; SPRING via exporting through spring_project() Harvard Med; vitessce for purely browser based viewing of zarr formatted AnnData files Harvard Med. Portals#. the Gene Expression Analysis Resource U Maryland; the Galaxy Project for the Human Cell Atlas [tweet] U Freiburg; the Expression Atlas EMBL-EBI. Modalities#. RNA velocity#. scVelo Helmholtz Munich. Spatial Transcriptomics Tools#. squidpy Helmholtz Munich. Squidpy ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/ecosystem.html:9325,integrat,integration,9325,en/stable/ecosystem.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/ecosystem.html,1,['integrat'],['integration']
Integrability,"anpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .md. .pdf. Preprocessing: PP. Contents . Data integration; Sample demultiplexing; Imputation. Preprocessing: PP#. Data integration#. pp.bbknn(adata, *[, batch_key, use_rep, ...]); Batch balanced kNN [Polański et al., 2019]. pp.harmony_integrate(adata, key, *[, basis, ...]); Use harmonypy [Korsunsky et al., 2019] to integrate different experiments. pp.mnn_correct(*datas[, var_index, ...]); Correct batch effects by matching mutual nearest neighbors [Haghverdi et al., 2018] [Kang, 2018]. pp.scanorama_integrate(adata, key, *[, ...]); Use Scanorama [Hie et al., 2019] to integrate different experiments. Sample demultiplexing#. pp.hashsolo(adata, cell_hashing_columns, *); Probabilistic demultiplexing of cell hashing data using HashSolo [Bernstein et al., 2020]. Imputation#; Note that the fundamental limitations of imputation are still under debate. pp.dca(adata[, mode, ae_type, ...]); Deep count autoencoder [Eraslan et al., 2019]. pp.magic(adata[, name_list, knn, decay, ...]); Markov Affinity-based Graph Imputation of Cells (MAGIC) API [van Dijk et al., 2018]. previous; External API. next; scanpy.external.pp.bbknn. Contents; . Data integration; Sample demultiplexing; Imputation. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/preprocessing.html:9531,integrat,integrate,9531,en/stable/external/preprocessing.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/preprocessing.html,3,['integrat'],"['integrate', 'integration']"
Integrability,"anpy.pl.StackedViolin#. class scanpy.pl.StackedViolin(adata, var_names, groupby, *, use_raw=None, log=False, num_categories=7, categories_order=None, title=None, figsize=None, gene_symbols=None, var_group_positions=None, var_group_labels=None, var_group_rotation=None, layer=None, standard_scale=None, ax=None, vmin=None, vmax=None, vcenter=None, norm=None, **kwds)[source]#; Stacked violin plots.; Makes a compact image composed of individual violin plots; (from violinplot()) stacked on top of each other.; Useful to visualize gene expression per cluster.; Wraps seaborn.violinplot() for AnnData. Parameters:. adata AnnDataAnnotated data matrix. var_names Union[str, Sequence[str], Mapping[str, Union[str, Sequence[str]]]]var_names should be a valid subset of adata.var_names.; If var_names is a mapping, then the key is used as label; to group the values (see var_group_labels). The mapping values; should be sequences of valid adata.var_names. In this; case either coloring or ‘brackets’ are used for the grouping; of var names depending on the plot. When var_names is a mapping,; then the var_group_labels and var_group_positions are set. groupby str | Sequence[str]The key of the observation grouping to consider. use_raw bool | None (default: None)Use raw attribute of adata if present. log bool (default: False)Plot on logarithmic axis. num_categories int (default: 7)Only used if groupby observation is not categorical. This value; determines the number of groups into which the groupby observation; should be subdivided. categories_order Sequence[str] | None (default: None)Order in which to show the categories. Note: add_dendrogram or add_totals; can change the categories order. figsize tuple[float, float] | None (default: None)Figure size when multi_panel=True.; Otherwise the rcParam['figure.figsize] value is used.; Format is (width, height). dendrogramIf True or a valid dendrogram key, a dendrogram based on the hierarchical; clustering between the groupby categories is added.; The",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.html:10317,depend,depending,10317,en/stable/api/generated/classes/scanpy.pl.StackedViolin.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.html,2,['depend'],['depending']
Integrability,"ansform or GLM-PCA). for adata in [; adata_spatial_anterior,; adata_spatial_posterior,; ]:; sc.pp.normalize_total(adata, inplace=True); sc.pp.log1p(adata); sc.pp.highly_variable_genes(adata, flavor=""seurat"", n_top_genes=2000, inplace=True). normalizing counts per cell; finished (0:00:00); extracting highly variable genes; finished (0:00:00); --> added; 'highly_variable', boolean vector (adata.var); 'means', float vector (adata.var); 'dispersions', float vector (adata.var); 'dispersions_norm', float vector (adata.var); normalizing counts per cell; finished (0:00:00); extracting highly variable genes; finished (0:00:00); --> added; 'highly_variable', boolean vector (adata.var); 'means', float vector (adata.var); 'dispersions', float vector (adata.var); 'dispersions_norm', float vector (adata.var). Data integration#; We are now ready to perform integration of the two dataset. As mentioned before, we will be using Scanorama for that. Scanorama returns two lists, one for the integrated embeddings and one for the corrected counts, for each dataset.; We would like to note that in this context using BBKNN or Ingest is also possible. adatas = [adata_spatial_anterior, adata_spatial_posterior]; adatas_cor = scanorama.correct_scanpy(adatas, return_dimred=True). Found 32285 genes among all datasets; [[0. 0.48882265]; [0. 0. ]]; Processing datasets (0, 1). We will concatenate the two datasets and save the integrated embeddings in adata_spatial.obsm['scanorama_embedding']. Furthermore we will compute UMAP to visualize the results and qualitatively assess the data integration task.; Notice that we are concatenating the two dataset with uns_merge=""unique"" strategy, in order to keep both images from the visium datasets in the concatenated anndata object. adata_spatial = sc.concat(; adatas_cor,; label=""library_id"",; uns_merge=""unique"",; keys=[; k; for d in [; adatas_cor[0].uns[""spatial""],; adatas_cor[1].uns[""spatial""],; ]; for k, v in d.items(); ],; index_unique=""-"",; ). sc.pp.neighbor",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html:16062,integrat,integrated,16062,en/stable/tutorials/spatial/integration-scanorama.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html,2,['integrat'],['integrated']
Integrability,"ase notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.pp.highly_variable_genes. Contents . highly_variable_genes(). scanpy.pp.highly_variable_genes#. scanpy.pp.highly_variable_genes(adata, *, layer=None, n_top_genes=None, min_disp=0.5, max_disp=inf, min_mean=0.0125, max_mean=3, span=0.3, n_bins=20, flavor='seurat', subset=False, inplace=True, batch_key=None, check_values=True)[source]#; Annotate highly variable genes [Satija et al., 2015, Stuart et al., 2019, Zheng et al., 2017].; Expects logarithmized data, except when flavor='seurat_v3'/'seurat_v3_paper', in which count; data is expected.; Depending on flavor, this reproduces the R-implementations of Seurat; [Satija et al., 2015], Cell Ranger [Zheng et al., 2017], and Seurat v3 [Stuart et al., 2019].; 'seurat_v3'/'seurat_v3_paper' requires scikit-misc package. If you plan to use this flavor, consider; installing scanpy with this optional dependency: scanpy[skmisc].; For the dispersion-based methods (flavor='seurat' Satija et al. [2015] and; flavor='cell_ranger' Zheng et al. [2017]), the normalized dispersion is obtained; by scaling with the mean and standard deviation of the dispersions for genes; falling into a given bin for mean expression of genes. This means that for each; bin of mean expression, highly variable genes are selected.; For flavor='seurat_v3'/'seurat_v3_paper' [Stuart et al., 2019], a normalized variance for each gene; is computed. First, the data are standardized (i.e., z-score normalization; per feature) with a regularized standard deviation. Next, the normalized variance; is computed as the variance of each gene after the transformation. Genes are ranked; by the normalized variance.; Only if batch_key is not None, the two flavors differ: For flavor='seurat_v3', genes are first sorted by the median (across batches) rank, with ties broken by the number of batches a gene is a ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.highly_variable_genes.html:10096,depend,dependency,10096,en/stable/generated/scanpy.pp.highly_variable_genes.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.highly_variable_genes.html,1,['depend'],['dependency']
Integrability,"bplots(1, 2, figsize=(15, 10)). for i, library in enumerate(; [""V1_Mouse_Brain_Sagittal_Anterior"", ""V1_Mouse_Brain_Sagittal_Posterior""]; ):; ad = adata_spatial[adata_spatial.obs.library_id == library, :].copy(); sc.pl.spatial(; ad,; img_key=""hires"",; library_id=library,; color=""clusters"",; size=1.5,; palette=[; v; for k, v in clusters_colors.items(); if k in ad.obs.clusters.unique().tolist(); ],; legend_loc=None,; show=False,; ax=axs[i],; ). plt.tight_layout(). WARNING: Length of palette colors is smaller than the number of categories (palette length: 16, categories length: 18. Some categories will have the same color.; WARNING: Length of palette colors is smaller than the number of categories (palette length: 14, categories length: 18. Some categories will have the same color. From the clusters, we can clearly see the stratification of the cortical layer in both of the tissues (see the Allen brain atlas for reference). Furthermore, it seems that the dataset integration worked well, since there is a clear continuity between clusters in the two tissues. Data integration and label transfer from scRNA-seq dataset#; We can also perform data integration between one scRNA-seq dataset and one spatial transcriptomics dataset. Such task is particularly useful because it allows us to transfer cell type labels to the Visium dataset, which were dentified from the scRNA-seq dataset.; For this task, we will be using a dataset from Tasic et al., where the mouse cortex was profiled with smart-seq technology.; The dataset can be downloaded from GEO count - metadata.; Conveniently, you can also download the pre-processed dataset in h5ad format from here.; Since the dataset was generated from the mouse cortex, we will subset the visium dataset in order to select only the spots part of the cortex. Note that the integration can also be performed on the whole brain slice, but it would give rise to false positive cell type assignments and and therefore it should be interpreted with more ca",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html:19241,integrat,integration,19241,en/stable/tutorials/spatial/integration-scanorama.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html,2,['integrat'],['integration']
Integrability,"brain atlas for reference). Furthermore, it seems that the dataset integration worked well, since there is a clear continuity between clusters in the two tissues. Data integration and label transfer from scRNA-seq dataset#; We can also perform data integration between one scRNA-seq dataset and one spatial transcriptomics dataset. Such task is particularly useful because it allows us to transfer cell type labels to the Visium dataset, which were dentified from the scRNA-seq dataset.; For this task, we will be using a dataset from Tasic et al., where the mouse cortex was profiled with smart-seq technology.; The dataset can be downloaded from GEO count - metadata.; Conveniently, you can also download the pre-processed dataset in h5ad format from here.; Since the dataset was generated from the mouse cortex, we will subset the visium dataset in order to select only the spots part of the cortex. Note that the integration can also be performed on the whole brain slice, but it would give rise to false positive cell type assignments and and therefore it should be interpreted with more care.; The integration task will be performed with Scanorama: each Visium dataset will be integrated with the smart-seq cortex dataset.; The following cell should be uncommented out and run if this is the first time running this notebook. if not Path(""./data/adata_processed.h5ad"").exists():; !wget https://ftp.ncbi.nlm.nih.gov/geo/series/GSE115nnn/GSE115746/suppl/GSE115746_cells_exon_counts.csv.gz -O data/GSE115746_cells_exon_counts.csv.gz; !gunzip data/GSE115746_cells_exon_counts.csv.gz; !wget https://ftp.ncbi.nlm.nih.gov/geo/series/GSE115nnn/GSE115746/suppl/GSE115746_complete_metadata_28706-cells.csv.gz -O data/GSE115746_complete_metadata_28706-cells.csv.gz; !gunzip data/GSE115746_complete_metadata_28706-cells.csv.gz; %pip install pybiomart; counts = pd.read_csv(""data/GSE115746_cells_exon_counts.csv"", index_col=0).T; meta = pd.read_csv(; ""data/GSE115746_complete_metadata_28706-cells.csv"", inde",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html:20091,integrat,integration,20091,en/stable/tutorials/spatial/integration-scanorama.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html,2,['integrat'],['integration']
Integrability,"bs; scanpy._settings.ScanpyConfig.plot_suffix; scanpy._settings.ScanpyConfig.verbosity; scanpy._settings.ScanpyConfig.writedir; scanpy._settings.ScanpyConfig.N_PCS; scanpy._settings.ScanpyConfig.set_figure_params. scanpy.logging.print_header; scanpy.logging.print_versions. Datasets; scanpy.datasets.blobs; scanpy.datasets.ebi_expression_atlas; scanpy.datasets.krumsiek11; scanpy.datasets.moignard15; scanpy.datasets.pbmc3k; scanpy.datasets.pbmc3k_processed; scanpy.datasets.pbmc68k_reduced; scanpy.datasets.paul15; scanpy.datasets.toggleswitch; scanpy.datasets.visium_sge. Deprecated functions; scanpy.pp.filter_genes_dispersion; scanpy.pp.normalize_per_cell. External API; Preprocessing: PP; scanpy.external.pp.bbknn; scanpy.external.pp.harmony_integrate; scanpy.external.pp.mnn_correct; scanpy.external.pp.scanorama_integrate; scanpy.external.pp.hashsolo; scanpy.external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .md. .pdf. Experimental. Experimental#. How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. previous; Integrating spatial data with scRNA-seq using scanorama. next; How to preprocess UMI count data with analytic Pearson residuals. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/index.html:9349,Integrat,Integrating,9349,en/stable/tutorials/experimental/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/index.html,1,['Integrat'],['Integrating']
Integrability,"but perform a basic transformation on the data matrix. Basic Preprocessing#; For visual quality control, see highest_expr_genes() and; filter_genes_dispersion() in scanpy.pl. pp.calculate_qc_metrics; Calculate quality control metrics. pp.filter_cells; Filter cell outliers based on counts and numbers of genes expressed. pp.filter_genes; Filter genes based on number of cells or counts. pp.highly_variable_genes; Annotate highly variable genes [Satija et al., 2015, Stuart et al., 2019, Zheng et al., 2017]. pp.log1p; Logarithmize the data matrix. pp.pca; Principal component analysis [Pedregosa et al., 2011]. pp.normalize_total; Normalize counts per cell. pp.regress_out; Regress out (mostly) unwanted sources of variation. pp.scale; Scale data to unit variance and zero mean. pp.subsample; Subsample to a fraction of the number of observations. pp.downsample_counts; Downsample counts from count matrix. Recipes#. pp.recipe_zheng17; Normalization and filtering as of Zheng et al. [2017]. pp.recipe_weinreb17; Normalization and filtering as of [Weinreb et al., 2017]. pp.recipe_seurat; Normalization and filtering as of Seurat [Satija et al., 2015]. Batch effect correction#; Also see [Data integration]. Note that a simple batch correction method is available via pp.regress_out(). Checkout scanpy.external for more. pp.combat; ComBat function for batch effect correction [Johnson et al., 2006, Leek et al., 2017, Pedersen, 2012]. Doublet detection#. pp.scrublet; Predict doublets using Scrublet [Wolock et al., 2019]. pp.scrublet_simulate_doublets; Simulate doublets by adding the counts of random observed transcriptome pairs. Neighbors#. pp.neighbors; Computes the nearest neighbors distance matrix and a neighborhood graph of observations [McInnes et al., 2018]. previous; API. next; scanpy.pp.calculate_qc_metrics. Contents; . Basic Preprocessing; Recipes; Batch effect correction; Doublet detection; Neighbors. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/preprocessing.html:10815,integrat,integration,10815,en/stable/api/preprocessing.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/preprocessing.html,1,['integrat'],['integration']
Integrability,"buting; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.external.pp.bbknn. Contents . bbknn(). scanpy.external.pp.bbknn#. scanpy.external.pp.bbknn(adata, *, batch_key='batch', use_rep='X_pca', approx=True, use_annoy=True, metric='euclidean', copy=False, neighbors_within_batch=3, n_pcs=50, trim=None, annoy_n_trees=10, pynndescent_n_neighbors=30, pynndescent_random_state=0, use_faiss=True, set_op_mix_ratio=1.0, local_connectivity=1, **kwargs)[source]#; Batch balanced kNN [Polański et al., 2019].; Batch balanced kNN alters the kNN procedure to identify each cell’s top neighbours in; each batch separately instead of the entire cell pool with no accounting for batch.; The nearest neighbours for each batch are then merged to create a final list of; neighbours for the cell. Aligns batches in a quick and lightweight manner.; For use in the scanpy workflow as an alternative to neighbors(). Note; This is just a wrapper of bbknn.bbknn(): up to date docstring,; more information and bug reports there. Parameters:. adata AnnDataNeeds the PCA computed and stored in adata.obsm[""X_pca""]. batch_key str (default: 'batch')adata.obs column name discriminating between your batches. use_rep str (default: 'X_pca')The dimensionality reduction in .obsm to use for neighbour detection. Defaults to PCA. approx bool (default: True)If True, use approximate neighbour finding - annoy or PyNNDescent. This results; in a quicker run time for large datasets while also potentially increasing the degree of; batch correction. use_annoy bool (default: True)Only used when approx=True. If True, will use annoy for neighbour finding. If; False, will use pyNNDescent instead. metric Union[str, Callable, DistanceMetric] (default: 'euclidean')What distance metric to use. The options depend on the choice of neighbour algorithm.; ”euclidean”, the default, is always available.; Annoy supports “angular”, “manhattan” and “hamming”.; ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.bbknn.html:10099,wrap,wrapper,10099,en/stable/generated/scanpy.external.pp.bbknn.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.bbknn.html,1,['wrap'],['wrapper']
Integrability,"cipal component analysis [Pedregosa et al., 2011]. tl.tsne; t-SNE [Amir et al., 2013, Pedregosa et al., 2011, van der Maaten and Hinton, 2008]. tl.umap; Embed the neighborhood graph using UMAP [McInnes et al., 2018]. tl.draw_graph; Force-directed graph drawing [Chippada, 2018, Islam et al., 2011, Jacomy et al., 2014]. tl.diffmap; Diffusion Maps [Coifman et al., 2005, Haghverdi et al., 2015, Wolf et al., 2018]. Compute densities on embeddings. tl.embedding_density; Calculate the density of cells in an embedding (per condition). Clustering and trajectory inference#. tl.leiden; Cluster cells into subgroups [Traag et al., 2019]. tl.louvain; Cluster cells into subgroups [Blondel et al., 2008, Levine et al., 2015, Traag, 2015]. tl.dendrogram; Computes a hierarchical clustering for the given groupby categories. tl.dpt; Infer progression of cells through geodesic distance along the graph [Haghverdi et al., 2016, Wolf et al., 2019]. tl.paga; Mapping out the coarse-grained connectivity structures of complex manifolds [Wolf et al., 2019]. Data integration#. tl.ingest; Map labels and embeddings from reference data to new data. Marker genes#. tl.rank_genes_groups; Rank genes for characterizing groups. tl.filter_rank_genes_groups; Filters out genes based on log fold change and fraction of genes expressing the gene within and outside the groupby categories. tl.marker_gene_overlap; Calculate an overlap score between data-deriven marker genes and provided markers. Gene scores, Cell cycle#. tl.score_genes; Score a set of genes [Satija et al., 2015]. tl.score_genes_cell_cycle; Score cell cycle genes [Satija et al., 2015]. Simulations#. tl.sim; Simulate dynamic gene expression data [Wittmann et al., 2009] [Wolf et al., 2018]. previous; scanpy.pp.neighbors. next; scanpy.tl.tsne. Contents; . Embeddings. Clustering and trajectory inference; Data integration; Marker genes; Gene scores, Cell cycle; Simulations. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/tools.html:10694,integrat,integration,10694,en/stable/api/tools.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/tools.html,2,['integrat'],['integration']
Integrability,"dict).; Always specify what these contain, e.g. {'a': (1, 2)} → Mapping[str, Tuple[int, int]].; If you can’t use one of those, use a concrete class like AnnData.; If your parameter only accepts an enumeration of strings, specify them like so: Literal['elem-1', 'elem-2']. Returns section#; There are three types of return sections – prose, tuple, and a mix of both. Prose is for simple cases.; Tuple return sections are formatted like parameters. Other than in numpydoc, each tuple is first characterized by the identifier and not by its type. Provide type annotation in the function header.; Mix of prose and tuple is relevant in complicated cases, e.g. when you want to describe that you added something as annotation to an `AnnData` object. Examples#; For simple cases, use prose as in normalize_total():; Returns; -------; Returns dictionary with normalized copies of `adata.X` and `adata.layers`; or updates `adata` with normalized versions of the original; `adata.X` and `adata.layers`, depending on `inplace`. For tuple return values, you can use the standard numpydoc way of populating it,; e.g. as in calculate_qc_metrics().; Do not add types in the docstring, but specify them in the function signature:; def myfunc(...) -> tuple[int, str]:; """"""; ...; Returns; -------; one_identifier; Description.; second_identifier; Description 2.; """"""; ... Many functions also just modify parts of the passed AnnData object, like e.g. dpt().; You can then combine prose and lists to best describe what happens:; Returns; -------; Depending on `copy`, returns or updates `adata` with the following fields. If `n_branchings==0`, no field `dpt_groups` will be written. dpt_pseudotime : :class:`~pandas.Series` (`adata.obs`, dtype `float`); Array of dim (number of samples) that stores the pseudotime of each; cell, that is, the DPT distance with respect to the root cell.; dpt_groups : :class:`pandas.Series` (`adata.obs`, dtype `category`); Array of dim (number of samples) that stores the subgroup id ('0",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/dev/documentation.html:13915,depend,depending,13915,en/stable/dev/documentation.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/dev/documentation.html,1,['depend'],['depending']
Integrability,"e iteratively starting from one reference dataset, one can use ingest. Mapping onto a reference batch using ingest#; Choose one reference batch for training the model and setting up the neighborhood graph (here, a PCA) and separate out all other batches.; As before, the model trained on the reference batch will explain the biological variation observed within it. adata_ref = adata_all[adata_all.obs.batch == ""0""]. Compute the PCA, neighbors and UMAP on the reference data. sc.pp.pca(adata_ref); sc.pp.neighbors(adata_ref); sc.tl.umap(adata_ref). The reference batch contains 12 of the 19 cell types across all batches. sc.pl.umap(adata_ref, color=""celltype""). Iteratively map labels (such as ‘celltype’) and embeddings (such as ‘X_pca’ and ‘X_umap’) from the reference data onto the query batches. adatas = [adata_all[adata_all.obs.batch == i].copy() for i in [""1"", ""2"", ""3""]]. sc.settings.verbosity = 2 # a bit more logging; for iadata, adata in enumerate(adatas):; print(f""... integrating batch {iadata+1}""); adata.obs[""celltype_orig""] = adata.obs.celltype # save the original cell type; sc.tl.ingest(adata, adata_ref, obs=""celltype""). ... integrating batch 1; running ingest; finished (0:00:06); ... integrating batch 2; running ingest; finished (0:00:07); ... integrating batch 3; running ingest; finished (0:00:03). Each of the query batches now carries annotation that has been contextualized with adata_ref. By concatenating, we can view it together. adata_concat = adata_ref.concatenate(adatas). adata_concat.obs.celltype = adata_concat.obs.celltype.astype(""category""); # fix category ordering; adata_concat.obs.celltype.cat.reorder_categories(; adata_ref.obs.celltype.cat.categories, inplace=True; ); # fix category coloring; adata_concat.uns[""celltype_colors""] = adata_ref.uns[""celltype_colors""]. sc.pl.umap(adata_concat, color=[""batch"", ""celltype""]). Compared to the BBKNN result, this is maintained clusters in a much more pronounced fashion. If one already observed a desired continuou",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/integrating-data-using-ingest.html:17326,integrat,integrating,17326,en/stable/tutorials/basics/integrating-data-using-ingest.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/integrating-data-using-ingest.html,2,['integrat'],['integrating']
Integrability,"e. Deprecated functions; scanpy.pp.filter_genes_dispersion; scanpy.pp.normalize_per_cell. External API; Preprocessing: PP; scanpy.external.pp.bbknn; scanpy.external.pp.harmony_integrate; scanpy.external.pp.mnn_correct; scanpy.external.pp.scanorama_integrate; scanpy.external.pp.hashsolo; scanpy.external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .md. .pdf. External API. External API#. Warning; We are no longer accepting new tools into scanpy.external.; Instead, please submit your tool to the scverse ecosystem package listing. Note; For tools that integrate well with scanpy and anndata, see:. The scverse ecosystem; Scanpy’s ecosystem ecosystem page. Import Scanpy’s wrappers to external tools as:; import scanpy.external as sce. Preprocessing: PP; Data integration; Sample demultiplexing; Imputation. Tools: TL; Embeddings; Clustering and trajectory inference; Gene scores, Cell cycle. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. previous; scanpy.pp.normalize_per_cell. next; Preprocessing: PP. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/index.html:9414,integrat,integrate,9414,en/stable/external/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/index.html,3,"['integrat', 'wrap']","['integrate', 'integration', 'wrappers']"
Integrability,"e; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.pp.recipe_zheng17. Contents . recipe_zheng17(). scanpy.pp.recipe_zheng17#. scanpy.pp.recipe_zheng17(adata, *, n_top_genes=1000, log=True, plot=False, copy=False)[source]#; Normalization and filtering as of Zheng et al. [2017].; Reproduces the preprocessing of Zheng et al. [2017] – the Cell Ranger R Kit of 10x; Genomics.; Expects non-logarithmized data.; If using logarithmized data, pass log=False.; The recipe runs the following steps; sc.pp.filter_genes(adata, min_counts=1) # only consider genes with more than 1 count; sc.pp.normalize_per_cell( # normalize with total UMI count per cell; adata, key_n_counts='n_counts_all'; ); filter_result = sc.pp.filter_genes_dispersion( # select highly-variable genes; adata.X, flavor='cell_ranger', n_top_genes=n_top_genes, log=False; ); adata = adata[:, filter_result.gene_subset] # subset the genes; sc.pp.normalize_per_cell(adata) # renormalize after filtering; if log: sc.pp.log1p(adata) # log transform: adata.X = log(adata.X + 1); sc.pp.scale(adata) # scale to unit variance and shift to zero mean. Parameters:. adata AnnDataAnnotated data matrix. n_top_genes int (default: 1000)Number of genes to keep. log bool (default: True)Take logarithm. plot bool (default: False)Show a plot of the gene dispersion vs. mean relation. copy bool (default: False)Return a copy of adata instead of updating it. Return type:; AnnData | None. Returns:; Returns or updates adata depending on copy. previous; scanpy.pp.downsample_counts. next; scanpy.pp.recipe_weinreb17. Contents; . recipe_zheng17(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pp.recipe_zheng17.html:10652,depend,depending,10652,en/stable/api/generated/scanpy.pp.recipe_zheng17.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pp.recipe_zheng17.html,1,['depend'],['depending']
Integrability,"e; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.external.pp.harmony_integrate. Contents . harmony_integrate(). scanpy.external.pp.harmony_integrate#. scanpy.external.pp.harmony_integrate(adata, key, *, basis='X_pca', adjusted_basis='X_pca_harmony', **kwargs)[source]#; Use harmonypy [Korsunsky et al., 2019] to integrate different experiments.; Harmony [Korsunsky et al., 2019] is an algorithm for integrating single-cell; data from multiple experiments. This function uses the python; port of Harmony, harmonypy, to integrate single-cell data; stored in an AnnData object. As Harmony works by adjusting the; principal components, this function should be run after performing; PCA but before computing the neighbor graph, as illustrated in the; example below. Parameters:. adata AnnDataThe annotated data matrix. key strThe name of the column in adata.obs that differentiates; among experiments/batches. basis str (default: 'X_pca')The name of the field in adata.obsm where the PCA table is; stored. Defaults to 'X_pca', which is the default for; sc.pp.pca(). adjusted_basis str (default: 'X_pca_harmony')The name of the field in adata.obsm where the adjusted PCA; table will be stored after running this function. Defaults to; X_pca_harmony. kwargsAny additional arguments will be passed to; harmonypy.run_harmony(). Retu",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.harmony_integrate.html:9515,integrat,integrate,9515,en/stable/generated/scanpy.external.pp.harmony_integrate.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.harmony_integrate.html,1,['integrat'],['integrate']
Integrability,"e_symbols=None, var_group_positions=None, var_group_labels=None, var_group_rotation=None, layer=None, swap_axes=False, dot_color_df=None, show=None, save=None, ax=None, return_fig=False, vmin=None, vmax=None, vcenter=None, norm=None, **kwds)[source]#; Makes a dot plot of the expression values of var_names.; For each var_name and each groupby category a dot is plotted.; Each dot represents two values: mean expression within each category; (visualized by color) and fraction of cells expressing the var_name in the; category (visualized by the size of the dot). If groupby is not given,; the dotplot assumes that all data belongs to a single category. Note; A gene is considered expressed if the expression value in the adata (or; adata.raw) is above the specified threshold which is zero by default. An example of dotplot usage is to visualize, for multiple marker genes,; the mean value and the percentage of cells expressing the gene; across multiple clusters.; This function provides a convenient interface to the DotPlot; class. If you need more flexibility, you should use DotPlot; directly. Parameters:. adata AnnDataAnnotated data matrix. var_names Union[str, Sequence[str], Mapping[str, Union[str, Sequence[str]]]]var_names should be a valid subset of adata.var_names.; If var_names is a mapping, then the key is used as label; to group the values (see var_group_labels). The mapping values; should be sequences of valid adata.var_names. In this; case either coloring or ‘brackets’ are used for the grouping; of var names depending on the plot. When var_names is a mapping,; then the var_group_labels and var_group_positions are set. groupby str | Sequence[str]The key of the observation grouping to consider. use_raw bool | None (default: None)Use raw attribute of adata if present. log bool (default: False)Plot on logarithmic axis. num_categories int (default: 7)Only used if groupby observation is not categorical. This value; determines the number of groups into which the groupby obs",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pl.dotplot.html:10650,interface,interface,10650,en/stable/generated/scanpy.pl.dotplot.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pl.dotplot.html,1,['interface'],['interface']
Integrability,"eature selection; Annotation/ Enrichment Analysis. Ecosystem#. Warning; We are no longer accepting new tools on this page.; Instead, please submit your tool to the scverse ecosystem package listing. Viewers#; Interactive manifold viewers. cellxgene via direct reading of .h5ad CZI; cirrocumulus via direct reading of .h5ad Broad Inst.; cell browser via exporing through cellbrowser() UCSC; SPRING via exporting through spring_project() Harvard Med; vitessce for purely browser based viewing of zarr formatted AnnData files Harvard Med. Portals#. the Gene Expression Analysis Resource U Maryland; the Galaxy Project for the Human Cell Atlas [tweet] U Freiburg; the Expression Atlas EMBL-EBI. Modalities#. RNA velocity#. scVelo Helmholtz Munich. Spatial Transcriptomics Tools#. squidpy Helmholtz Munich. Squidpy is a comprehensive toolkit for working with spatial single cell omics data. PASTE Princeton. PASTE is a computational method to align and integrate spatial transcriptomics data across adjacent tissue slices by leveraging both gene expression similarity and spatial distances between spots. bento 🍱 UC San Diego. Bento is an accessible Python toolkit for performing subcellular analysis of spatial transcriptomics data. Multimodal integration#. MUON and MuData EMBL/ DKFZ. MUON, and it’s associated data structure MuData are designed to organise, analyse, visualise, and exchange multimodal data.; MUON enables a range of analyses for ATAC and CITE-seq, from data preprocessing to flexible multi-omics alignment. Adaptive immune receptor repertoire (AIRR)#. scirpy Medical University of Innsbruck. scirpy is a scanpy extension to expore single-cell T-cell receptor (TCR) and B-cell receptor (BCR) repertoires. dandelion University of Cambridge. dandelion is a single-cell BCR-seq network analysis package that integrates with transcriptomic data analyzed via scanpy. Long reads#. Swan UC Irvine. Swan is a Python library designed for the analysis and visualization of transcriptomes, especial",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/ecosystem.html:10454,integrat,integrate,10454,en/stable/ecosystem.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/ecosystem.html,1,['integrat'],['integrate']
Integrability,"ed.; Each dot represents two values: mean expression within each category; (visualized by color) and fraction of cells expressing the var_name in the; category (visualized by the size of the dot). If groupby is not given,; the dotplot assumes that all data belongs to a single category. Note; A gene is considered expressed if the expression value in the adata (or; adata.raw) is above the specified threshold which is zero by default. An example of dotplot usage is to visualize, for multiple marker genes,; the mean value and the percentage of cells expressing the gene; across multiple clusters. Parameters:. adata AnnDataAnnotated data matrix. var_names Union[str, Sequence[str], Mapping[str, Union[str, Sequence[str]]]]var_names should be a valid subset of adata.var_names.; If var_names is a mapping, then the key is used as label; to group the values (see var_group_labels). The mapping values; should be sequences of valid adata.var_names. In this; case either coloring or ‘brackets’ are used for the grouping; of var names depending on the plot. When var_names is a mapping,; then the var_group_labels and var_group_positions are set. groupby str | Sequence[str]The key of the observation grouping to consider. use_raw bool | None (default: None)Use raw attribute of adata if present. log bool (default: False)Plot on logarithmic axis. num_categories int (default: 7)Only used if groupby observation is not categorical. This value; determines the number of groups into which the groupby observation; should be subdivided. categories_order Sequence[str] | None (default: None)Order in which to show the categories. Note: add_dendrogram or add_totals; can change the categories order. figsize tuple[float, float] | None (default: None)Figure size when multi_panel=True.; Otherwise the rcParam['figure.figsize] value is used.; Format is (width, height). dendrogramIf True or a valid dendrogram key, a dendrogram based on the hierarchical; clustering between the groupby categories is added.; The",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.html:10990,depend,depending,10990,en/stable/api/generated/classes/scanpy.pl.DotPlot.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.html,2,['depend'],['depending']
Integrability,"efault: 10)Number of diffusion components. knn int (default: 30)Number of nearest neighbors for graph construction. alpha float (default: 0)Normalization parameter for the diffusion operator. use_adjacency_matrix bool (default: False)Use adaptive anisotropic adjacency matrix, instead of PCA projections; (default) to compute diffusion components. distances_key str | None (default: None)With use_adjacency_matrix=True, use the indicated distances key for .obsp.; If None, 'distances'. n_eigs int | None (default: None)Number of eigen vectors to use. If None specified, the number of eigen; vectors will be determined using eigen gap. Passed to; palantir.utils.determine_multiscale_space. impute_data bool (default: True)Impute data using MAGIC. n_steps int (default: 3)Number of steps in the diffusion operator. Passed to; palantir.utils.run_magic_imputation. copy bool (default: False)Return a copy instead of writing to adata. Return type:; AnnData | None. Returns:; Depending on copy, returns or updates adata with the following fields:. Diffusion maps,used for magic imputation, and to generate multi-scale data matrix,. X_palantir_diff_comp - ndarray (obsm, dtype float)Array of Diffusion components. palantir_EigenValues - ndarray (uns, dtype float)Array of corresponding eigen values. palantir_diff_op - spmatrix (obsp, dtype float)The diffusion operator matrix. Multi scale space results,used to build tsne on diffusion components, and to compute branch probabilities; and waypoints,. X_palantir_multiscale - ndarray (obsm, dtype float)Multi scale data matrix. MAGIC imputation,used for plotting gene expression on tsne, and gene expression trends,. palantir_imp - ndarray (layers, dtype float)Imputed data matrix (MAGIC imputation). Example; >>> import scanpy.external as sce; >>> import scanpy as sc. A sample data is available here.; Load sample data; >>> adata = sc.read_csv(filename=""Palantir/data/marrow_sample_scseq_counts.csv.gz""). Cleanup and normalize; >>> sc.pp.filter_cells(adata",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.palantir.html:11191,Depend,Depending,11191,en/stable/external/generated/scanpy.external.tl.palantir.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.palantir.html,1,['Depend'],['Depending']
Integrability,"electing genes that vary strongly across batches pr622 G Eraslan. Bug fixes#. rank_genes_groups() t-test implementation doesn’t return NaN when variance is 0, also changed to scipy’s implementation pr621 I Virshup; umap() with init_pos='paga' detects correct dtype A Wolf; louvain() and leiden() auto-generate key_added=louvain_R upon passing restrict_to, which was temporarily changed in 1.4.1 A Wolf. Code design#. neighbors() and umap() got rid of UMAP legacy code and introduced UMAP as a dependency pr576 S Rybakov. 1.4.1 2019-04-26#. New functionality#. Scanpy has a command line interface again. Invoking it with scanpy somecommand [args] calls scanpy-somecommand [args], except for builtin commands (currently scanpy settings) pr604 P Angerer; ebi_expression_atlas() allows convenient download of EBI expression atlas I Virshup; marker_gene_overlap() computes overlaps of marker genes M Luecken; filter_rank_genes_groups() filters out genes based on fold change and fraction of cells expressing genes F Ramirez; normalize_total() replaces normalize_per_cell(), is more efficient and provides a parameter to only normalize using a fraction of expressed genes S Rybakov; downsample_counts() has been sped up, changed default value of replace parameter to False pr474 I Virshup; embedding_density() computes densities on embeddings pr543 M Luecken; palantir() interfaces Palantir [Setty et al., 2019] pr493 A Mousa. Code design#. .layers support of scatter plots F Ramirez; fix double-logarithmization in compute of log fold change in rank_genes_groups() A Muñoz-Rojas; fix return sections of docs P Angerer. Version 1.3#. 1.3.8 2019-02-05#. various documentation and dev process improvements; Added combat() function for batch effect correction [Johnson et al., 2006, Leek et al., 2017, Pedersen, 2012] pr398 M Lange. 1.3.7 2019-01-02#. API changed from import scanpy as sc to import scanpy.api as sc.; phenograph() wraps the graph clustering package Phenograph [Levine et al., 2015] thanks to ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:43839,interface,interfaces,43839,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,1,['interface'],['interfaces']
Integrability,"ellxgene via direct reading of .h5ad CZI; cirrocumulus via direct reading of .h5ad Broad Inst.; cell browser via exporing through cellbrowser() UCSC; SPRING via exporting through spring_project() Harvard Med; vitessce for purely browser based viewing of zarr formatted AnnData files Harvard Med. Portals#. the Gene Expression Analysis Resource U Maryland; the Galaxy Project for the Human Cell Atlas [tweet] U Freiburg; the Expression Atlas EMBL-EBI. Modalities#. RNA velocity#. scVelo Helmholtz Munich. Spatial Transcriptomics Tools#. squidpy Helmholtz Munich. Squidpy is a comprehensive toolkit for working with spatial single cell omics data. PASTE Princeton. PASTE is a computational method to align and integrate spatial transcriptomics data across adjacent tissue slices by leveraging both gene expression similarity and spatial distances between spots. bento 🍱 UC San Diego. Bento is an accessible Python toolkit for performing subcellular analysis of spatial transcriptomics data. Multimodal integration#. MUON and MuData EMBL/ DKFZ. MUON, and it’s associated data structure MuData are designed to organise, analyse, visualise, and exchange multimodal data.; MUON enables a range of analyses for ATAC and CITE-seq, from data preprocessing to flexible multi-omics alignment. Adaptive immune receptor repertoire (AIRR)#. scirpy Medical University of Innsbruck. scirpy is a scanpy extension to expore single-cell T-cell receptor (TCR) and B-cell receptor (BCR) repertoires. dandelion University of Cambridge. dandelion is a single-cell BCR-seq network analysis package that integrates with transcriptomic data analyzed via scanpy. Long reads#. Swan UC Irvine. Swan is a Python library designed for the analysis and visualization of transcriptomes, especially with long-read transcriptomes in mind.; Users can add transcriptomes from different datasets and explore distinct splicing and expression patterns across datasets. Analysis methods#. scvi-tools#. scvi-tools Berkeley. scvi-tools hosts dee",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/ecosystem.html:10746,integrat,integration,10746,en/stable/ecosystem.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/ecosystem.html,1,['integrat'],['integration']
Integrability,"ene_data:; # Calculate the color to display; palette = sm.to_rgba(pdata.median()).tolist(); sv.add_bottom(; mp.Violin(; pdata,; inner=None,; linecolor="".7"",; linewidth=0.5,; density_norm=""width"",; palette=palette,; ),; size=0.5,; pad=0.1,; legend=False,; ); sv_anno.add_bottom(mp.Title(gene_name, align=""left""), size=0.5, pad=0.1). sv.add_bottom(mp.Labels(cdata.columns)); sv.add_dendrogram(""top""). # To fake a legend; sv.add_bottom(; mp.ColorMesh(; cdata,; cmap=""Blues"",; cbar_kws={""title"": ""Median expression\nin group"", ""orientation"": ""horizontal""},; ),; size=0,; ); comp = sv + 0.1 + sv_anno; comp.add_legends(); comp.render(). More information#; Other plots are possible with Marsilea by creating new plotter. See Marsilea’s documention to learn how. import session_info. session_info.show(dependencies=True). Click to view session information. -----; anndata 0.10.6; marsilea 0.3.5; matplotlib 3.8.3; numpy 1.26.4; pandas 2.2.0; scanpy 1.10.1; session_info 1.0.0; -----. Click to view modules imported as dependencies. PIL 10.2.0; anyio NA; appnope 0.1.3; arrow 1.3.0; asttokens NA; attr 23.2.0; attrs 23.2.0; babel 2.14.0; certifi 2024.02.02; cffi 1.16.0; charset_normalizer 3.3.2; colorama 0.4.6; comm 0.2.1; cycler 0.12.1; cython_runtime NA; dateutil 2.8.2; debugpy 1.8.0; decorator 5.1.1; defusedxml 0.7.1; exceptiongroup 1.2.0; executing 2.0.1; fastjsonschema NA; fqdn NA; h5py 3.10.0; idna 3.6; ipykernel 6.29.0; isoduration NA; jedi 0.19.1; jinja2 3.1.3; joblib 1.3.2; json5 NA; jsonpointer 2.4; jsonschema 4.21.1; jsonschema_specifications NA; jupyter_events 0.9.0; jupyter_server 2.12.5; jupyterlab_server 2.25.2; kiwisolver 1.4.5; legacy_api_wrap NA; legendkit 0.3.4; llvmlite 0.42.0; markupsafe 2.1.5; matplotlib_inline 0.1.6; mpl_toolkits NA; natsort 8.4.0; nbformat 5.9.2; numba 0.59.1; overrides NA; packaging 23.2; parso 0.8.3; patsy 0.5.6; pexpect 4.9.0; platformdirs 4.1.0; prometheus_client NA; prompt_toolkit 3.0.43; psutil 5.9.8; ptyprocess 0.7.0; pure_eval 0.2.2; pyarrow 1",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/how-to/plotting-with-marsilea.html:17389,depend,dependencies,17389,en/stable/how-to/plotting-with-marsilea.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/how-to/plotting-with-marsilea.html,1,['depend'],['dependencies']
Integrability,"enes based on fold change and fraction of cells expressing genes F Ramirez; normalize_total() replaces normalize_per_cell(), is more efficient and provides a parameter to only normalize using a fraction of expressed genes S Rybakov; downsample_counts() has been sped up, changed default value of replace parameter to False pr474 I Virshup; embedding_density() computes densities on embeddings pr543 M Luecken; palantir() interfaces Palantir [Setty et al., 2019] pr493 A Mousa. Code design#. .layers support of scatter plots F Ramirez; fix double-logarithmization in compute of log fold change in rank_genes_groups() A Muñoz-Rojas; fix return sections of docs P Angerer. Version 1.3#. 1.3.8 2019-02-05#. various documentation and dev process improvements; Added combat() function for batch effect correction [Johnson et al., 2006, Leek et al., 2017, Pedersen, 2012] pr398 M Lange. 1.3.7 2019-01-02#. API changed from import scanpy as sc to import scanpy.api as sc.; phenograph() wraps the graph clustering package Phenograph [Levine et al., 2015] thanks to A Mousa. 1.3.6 2018-12-11#. Major updates#. a new plotting gallery for visualizing-marker-genes F Ramirez; tutorials are integrated on ReadTheDocs, pbmc3k and paga-paul15 A Wolf. Interactive exploration of analysis results through manifold viewers#. CZI’s cellxgene directly reads .h5ad files the cellxgene developers; the UCSC Single Cell Browser requires exporting via cellbrowser() M Haeussler. Code design#. highly_variable_genes() supersedes filter_genes_dispersion(), it gives the same results but, by default, expects logarithmized data and doesn’t subset A Wolf. 1.3.5 2018-12-09#. uncountable figure improvements pr369 F Ramirez. 1.3.4 2018-11-24#. leiden() wraps the recent graph clustering package by Traag et al. [2019] K Polanski; bbknn() wraps the recent batch correction package [Polański et al., 2019] K Polanski; calculate_qc_metrics() caculates a number of quality control metrics, similar to calculateQCMetrics from Scater [Mc",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:44396,wrap,wraps,44396,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,1,['wrap'],['wraps']
Integrability,"ernal.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.queries.enrich. Contents . enrich(). scanpy.queries.enrich#. scanpy.queries.enrich(container, *, org='hsapiens', gprofiler_kwargs=mappingproxy({}))[source]#; Get enrichment for DE results.; This is a thin convenience wrapper around the very useful gprofiler.; This method dispatches on the first argument, leading to the following two; signatures:; enrich(container, ...); enrich(adata: AnnData, group, key: str, ...). Where:; enrich(adata, group, key, ...) = enrich(adata.uns[key][""names""][group], ...). Parameters:. container Iterable[str] | Mapping[str, Iterable[str]]Contains list of genes you’d like to search. If container is a dict all; enrichment queries are made at once. adataAnnData object whose group will be looked for. groupThe group whose genes should be used for enrichment. keyKey in uns to find group under. org str (default: 'hsapiens')Organism to query. Must be an organism in ensembl biomart. “hsapiens”,; “mmusculus”, “drerio”, etc. gprofiler_kwargs Mapping[str, Any] (default: mappingproxy({}))Keyword arguments to pass to GProfiler.profile, see gprofiler. Some; useful options are no_evidences=False which reports gene intersections,; sources=['GO:BP'] which limits gene sets to only GO biological p",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.queries.enrich.html:9454,wrap,wrapper,9454,en/stable/generated/scanpy.queries.enrich.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.queries.enrich.html,1,['wrap'],['wrapper']
Integrability,"ernal.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.external.pp.harmony_integrate. Contents . harmony_integrate(). scanpy.external.pp.harmony_integrate#. scanpy.external.pp.harmony_integrate(adata, key, *, basis='X_pca', adjusted_basis='X_pca_harmony', **kwargs)[source]#; Use harmonypy [Korsunsky et al., 2019] to integrate different experiments.; Harmony [Korsunsky et al., 2019] is an algorithm for integrating single-cell; data from multiple experiments. This function uses the python; port of Harmony, harmonypy, to integrate single-cell data; stored in an AnnData object. As Harmony works by adjusting the; principal components, this function should be run after performing; PCA but before computing the neighbor graph, as illustrated in the; example below. Parameters:. adata AnnDataThe annotated data matrix. key strThe name of the column in adata.obs that differentiates; among experiments/batches. basis str (default: 'X_pca')The name of the field in adata.obsm where the PCA table is; stored. Defaults to 'X_pca', which is the default for; sc.pp.pca(). adjusted_basis str (default: 'X_pca_harmony')The name of the field in adata.obsm where the adjusted PCA; table will be stored after running this function. Defaults to; X_pca_harmony. kwargsAny additional arguments will be passed to; harmonypy.run_harmony(). Returns:; Updates adata with the field adata.obsm[obsm_out_field],; containing principal components adjusted by Harmony such that; different experiments are integrated. Example; First, load librar",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.harmony_integrate.html:9721,integrat,integrate,9721,en/stable/generated/scanpy.external.pp.harmony_integrate.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.harmony_integrate.html,1,['integrat'],['integrate']
Integrability,"ernal.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .md. .pdf. API. API#; Import Scanpy as:; import scanpy as sc. Note; Additional functionality is available in the broader ecosystem, with some tools being wrapped in the scanpy.external module. Preprocessing: pp; Basic Preprocessing; Recipes; Batch effect correction; Doublet detection; Neighbors. Tools: tl; Embeddings; Clustering and trajectory inference; Data integration; Marker genes; Gene scores, Cell cycle; Simulations. Plotting: pl; Generic; Classes; Preprocessing; Tools. Reading; scanpy.read; scanpy.read_10x_h5; scanpy.read_10x_mtx; scanpy.read_visium; scanpy.read_h5ad; scanpy.read_csv; scanpy.read_excel; scanpy.read_hdf; scanpy.read_loom; scanpy.read_mtx; scanpy.read_text; scanpy.read_umi_tools. Get object from AnnData: get; scanpy.get.obs_df; scanpy.get.var_df; scanpy.get.rank_genes_groups_df; scanpy.get.aggregate. Queries; scanpy.queries.biomart_annotations; scanpy.queries.gene_coordinates; scanpy.queries.mitochondrial_genes; scanpy.queries.enrich. Metrics; scanpy.metrics.confusion_matrix; scanpy.metrics.gearys_c; scanpy.metrics.morans_i. Experimental; scanpy.experimental.pp.normalize_pearson_residuals; scanpy.experimental.pp.normalize_pearson_residuals_pca; scanpy.experimental.pp.highly_variable_genes; scanpy.experimental.pp.recipe_pearson_residuals. Classes; scanpy.Neighbors. Settings; scanpy.set_figure_params; scanpy._settings.S",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/index.html:9562,integrat,integration,9562,en/stable/api/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/index.html,1,['integrat'],['integration']
Integrability,"es#. neighbors() correctly infers n_neighbors again from params, which was temporarily broken in v1.4.2 I Virshup. Code design#. calculate_qc_metrics() is single threaded by default for datasets under 300,000 cells – allowing cached compilation pr615 I Virshup. 1.4.2 2019-05-06#. New functionality#. combat() supports additional covariates which may include adjustment variables or biological condition pr618 G Eraslan; highly_variable_genes() has a batch_key option which performs HVG selection in each batch separately to avoid selecting genes that vary strongly across batches pr622 G Eraslan. Bug fixes#. rank_genes_groups() t-test implementation doesn’t return NaN when variance is 0, also changed to scipy’s implementation pr621 I Virshup; umap() with init_pos='paga' detects correct dtype A Wolf; louvain() and leiden() auto-generate key_added=louvain_R upon passing restrict_to, which was temporarily changed in 1.4.1 A Wolf. Code design#. neighbors() and umap() got rid of UMAP legacy code and introduced UMAP as a dependency pr576 S Rybakov. 1.4.1 2019-04-26#. New functionality#. Scanpy has a command line interface again. Invoking it with scanpy somecommand [args] calls scanpy-somecommand [args], except for builtin commands (currently scanpy settings) pr604 P Angerer; ebi_expression_atlas() allows convenient download of EBI expression atlas I Virshup; marker_gene_overlap() computes overlaps of marker genes M Luecken; filter_rank_genes_groups() filters out genes based on fold change and fraction of cells expressing genes F Ramirez; normalize_total() replaces normalize_per_cell(), is more efficient and provides a parameter to only normalize using a fraction of expressed genes S Rybakov; downsample_counts() has been sped up, changed default value of replace parameter to False pr474 I Virshup; embedding_density() computes densities on embeddings pr543 M Luecken; palantir() interfaces Palantir [Setty et al., 2019] pr493 A Mousa. Code design#. .layers support of scatter plots ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:42967,depend,dependency,42967,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,1,['depend'],['dependency']
Integrability,"et al., 2019]. Parameters:. adata AnnDataThe annotated data matrix. key strThe name of the column in adata.obs that differentiates; among experiments/batches. Cells from the same batch must be; contiguously stored in adata. basis str (default: 'X_pca')The name of the field in adata.obsm where the PCA table is; stored. Defaults to 'X_pca', which is the default for; sc.pp.pca(). adjusted_basis str (default: 'X_scanorama')The name of the field in adata.obsm where the integrated; embeddings will be stored after running this function. Defaults; to X_scanorama. knn int (default: 20)Number of nearest neighbors to use for matching. sigma float (default: 15)Correction smoothing parameter on Gaussian kernel. approx bool (default: True)Use approximate nearest neighbors with Python annoy;; greatly speeds up matching runtime. alpha float (default: 0.1)Alignment score minimum cutoff. batch_size int (default: 5000)The batch size used in the alignment vector computation. Useful; when integrating very large (>100k samples) datasets. Set to; large value that runs within available memory. kwargsAny additional arguments will be passed to; scanorama.assemble(). Return type:; None. Returns:; Updates adata with the field adata.obsm[adjusted_basis],; containing Scanorama embeddings such that different experiments; are integrated. Example; First, load libraries and example dataset, and preprocess.; >>> import scanpy as sc; >>> import scanpy.external as sce; >>> adata = sc.datasets.pbmc3k(); >>> sc.pp.recipe_zheng17(adata); >>> sc.pp.pca(adata). We now arbitrarily assign a batch metadata variable to each cell; for the sake of example, but during real usage there would already; be a column in adata.obs giving the experiment each cell came; from.; >>> adata.obs['batch'] = 1350*['a'] + 1350*['b']. Finally, run Scanorama. Afterwards, there will be a new table in; adata.obsm containing the Scanorama embeddings.; >>> sce.pp.scanorama_integrate(adata, 'batch', verbose=1); Processing datasets a <=> ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.scanorama_integrate.html:10904,integrat,integrating,10904,en/stable/generated/scanpy.external.pp.scanorama_integrate.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.scanorama_integrate.html,1,['integrat'],['integrating']
Integrability,"ettings.ScanpyConfig.set_figure_params. scanpy.logging.print_header; scanpy.logging.print_versions. Datasets; scanpy.datasets.blobs; scanpy.datasets.ebi_expression_atlas; scanpy.datasets.krumsiek11; scanpy.datasets.moignard15; scanpy.datasets.pbmc3k; scanpy.datasets.pbmc3k_processed; scanpy.datasets.pbmc68k_reduced; scanpy.datasets.paul15; scanpy.datasets.toggleswitch; scanpy.datasets.visium_sge. Deprecated functions; scanpy.pp.filter_genes_dispersion; scanpy.pp.normalize_per_cell. External API; Preprocessing: PP; scanpy.external.pp.bbknn; scanpy.external.pp.harmony_integrate; scanpy.external.pp.mnn_correct; scanpy.external.pp.scanorama_integrate; scanpy.external.pp.hashsolo; scanpy.external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.logging.print_header. Contents . print_header(). scanpy.logging.print_header#. scanpy.logging.print_header(*, file=None)[source]#; Versions that might influence the numerical results.; Matplotlib and Seaborn are excluded from this. Parameters:. file default: NoneOptional path for dependency output. previous; scanpy._settings.ScanpyConfig.set_figure_params. next; scanpy.logging.print_versions. Contents; . print_header(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.logging.print_header.html:9524,depend,dependency,9524,en/stable/generated/scanpy.logging.print_header.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.logging.print_header.html,1,['depend'],['dependency']
Integrability,"external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.external.pp.scanorama_integrate. Contents . scanorama_integrate(). scanpy.external.pp.scanorama_integrate#. scanpy.external.pp.scanorama_integrate(adata, key, *, basis='X_pca', adjusted_basis='X_scanorama', knn=20, sigma=15, approx=True, alpha=0.1, batch_size=5000, **kwargs)[source]#; Use Scanorama [Hie et al., 2019] to integrate different experiments.; Scanorama [Hie et al., 2019] is an algorithm for integrating single-cell; data from multiple experiments stored in an AnnData object. This; function should be run after performing PCA but before computing; the neighbor graph, as illustrated in the example below.; This uses the implementation of scanorama [Hie et al., 2019]. Parameters:. adata AnnDataThe annotated data matrix. key strThe name of the column in adata.obs that differentiates; among experiments/batches. Cells from the same batch must be; contiguously stored in adata. basis str (default: 'X_pca')The name of the field in adata.obsm where the PCA table is; stored. Defaults to 'X_pca', which is the default for; sc.pp.pca(). adjusted_basis str (default: 'X_scanorama')The name of the field in adata.obsm where the integrated; embeddings will be stored after running this function. Defaults; to X_scanorama. knn int (default: 20)Number of nearest neighbors to use for matching. sigma float (default: 15)Correction smoothing parameter on Gaussian kernel. approx bool (default: True)Use approximate nearest neighbo",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.scanorama_integrate.html:9659,integrat,integrating,9659,en/stable/generated/scanpy.external.pp.scanorama_integrate.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.scanorama_integrate.html,1,['integrat'],['integrating']
Integrability,"ference batch will explain the biological variation observed within it. adata_ref = adata_all[adata_all.obs.batch == ""0""]. Compute the PCA, neighbors and UMAP on the reference data. sc.pp.pca(adata_ref); sc.pp.neighbors(adata_ref); sc.tl.umap(adata_ref). The reference batch contains 12 of the 19 cell types across all batches. sc.pl.umap(adata_ref, color=""celltype""). Iteratively map labels (such as ‘celltype’) and embeddings (such as ‘X_pca’ and ‘X_umap’) from the reference data onto the query batches. adatas = [adata_all[adata_all.obs.batch == i].copy() for i in [""1"", ""2"", ""3""]]. sc.settings.verbosity = 2 # a bit more logging; for iadata, adata in enumerate(adatas):; print(f""... integrating batch {iadata+1}""); adata.obs[""celltype_orig""] = adata.obs.celltype # save the original cell type; sc.tl.ingest(adata, adata_ref, obs=""celltype""). ... integrating batch 1; running ingest; finished (0:00:06); ... integrating batch 2; running ingest; finished (0:00:07); ... integrating batch 3; running ingest; finished (0:00:03). Each of the query batches now carries annotation that has been contextualized with adata_ref. By concatenating, we can view it together. adata_concat = adata_ref.concatenate(adatas). adata_concat.obs.celltype = adata_concat.obs.celltype.astype(""category""); # fix category ordering; adata_concat.obs.celltype.cat.reorder_categories(; adata_ref.obs.celltype.cat.categories, inplace=True; ); # fix category coloring; adata_concat.uns[""celltype_colors""] = adata_ref.uns[""celltype_colors""]. sc.pl.umap(adata_concat, color=[""batch"", ""celltype""]). Compared to the BBKNN result, this is maintained clusters in a much more pronounced fashion. If one already observed a desired continuous structure (as in the hematopoietic datasets, for instance), ingest allows to easily maintain this structure. Evaluating consistency#; Let us subset the data to the query batches. adata_query = adata_concat[adata_concat.obs.batch.isin([""1"", ""2"", ""3""])]. The following plot is a bit hard to rea",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/integrating-data-using-ingest.html:17611,integrat,integrating,17611,en/stable/tutorials/basics/integrating-data-using-ingest.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/integrating-data-using-ingest.html,2,['integrat'],['integrating']
Integrability,"finished (0:00:00): normalized adata.X and added 'n_counts', counts per cell before normalization (adata.obs); computing PCA; with n_comps=15; finished (0:00:08); computing neighbors; using 'X_pca' with n_pcs = 15; finished: added to `.uns['neighbors']`; `.obsp['distances']`, distances for each pair of neighbors; `.obsp['connectivities']`, weighted adjacency matrix (0:00:00); computing UMAP; finished: added; 'X_umap', UMAP coordinates (adata.obsm) (0:00:01); running Leiden clustering; finished: found 6 clusters and added; 'clusters', the cluster labels (adata.obs, categorical) (0:00:00). The experiment consisted in measuring gene expression counts from a single cell type (cultured U2-OS cells). Clusters consist of cell states at different stages of the cell cycle. We don’t expect to see specific structure in spatial dimensions given the experimental setup.; We can visualize the clusters obtained from running Leiden in UMAP space and spatial coordinates like this. adata_merfish. AnnData object with n_obs × n_vars = 645 × 12903; obs: 'n_counts', 'clusters'; uns: 'log1p', 'pca', 'neighbors', 'umap', 'leiden'; obsm: 'spatial', 'X_pca', 'X_umap'; varm: 'PCs'; obsp: 'distances', 'connectivities'. sc.pl.umap(adata_merfish, color=""clusters""); sc.pl.embedding(adata_merfish, basis=""spatial"", color=""clusters""). We hope you found the tutorial useful!; Report back to us which features/external tools you would like to see in Scanpy.; We are extending Scanpy and AnnData to support other spatial data types, such as Imaging Mass Cytometry and extend data structure to support spatial graphs and additional features. Stay tuned!. previous; Spatial. next; Integrating spatial data with scRNA-seq using scanorama. Contents; . Reading the data; QC and preprocessing; Manifold embedding and clustering based on transcriptional similarity; Visualization in spatial coordinates; Cluster marker genes; MERFISH example. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/basic-analysis.html:22438,Integrat,Integrating,22438,en/stable/tutorials/spatial/basic-analysis.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/basic-analysis.html,1,['Integrat'],['Integrating']
Integrability,"g, but it’s a good idea to explore this. sc.pl.pca(; adata,; color=[""sample"", ""sample"", ""pct_counts_mt"", ""pct_counts_mt""],; dimensions=[(0, 1), (2, 3), (0, 1), (2, 3)],; ncols=2,; size=2,; ). Nearest neighbor graph constuction and visualization#; Let us compute the neighborhood graph of cells using the PCA representation of the data matrix. sc.pp.neighbors(adata). This graph can then be embedded in two dimensions for visualiztion with UMAP (McInnes et al., 2018):. sc.tl.umap(adata). We can now visualize the UMAP according to the sample. sc.pl.umap(; adata,; color=""sample"",; # Setting a smaller point size to get prevent overlap; size=2,; ). Even though the data considered in this tutorial includes two different samples, we only observe a minor batch effect and we can continue with clustering and annotation of our data.; If you inspect batch effects in your UMAP it can be beneficial to integrate across samples and perform batch correction/integration. We recommend checking out scanorama and scvi-tools for batch integration. Clustering#; As with Seurat and many other frameworks, we recommend the Leiden graph-clustering method (community detection based on optimizing modularity) [Traag et al., 2019]. Note that Leiden clustering directly clusters the neighborhood graph of cells, which we already computed in the previous section. # Using the igraph implementation and a fixed number of iterations can be significantly faster, especially for larger datasets; sc.tl.leiden(adata, flavor=""igraph"", n_iterations=2). sc.pl.umap(adata, color=[""leiden""]). Re-assess quality control and cell filtering#; As indicated before, we will now re-assess our filtering strategy by visualizing different QC metrics using UMAP. sc.pl.umap(; adata,; color=[""leiden"", ""predicted_doublet"", ""doublet_score""],; # increase horizontal space between panels; wspace=0.5,; size=3,; ). sc.pl.umap(; adata,; color=[""leiden"", ""log1p_total_counts"", ""pct_counts_mt"", ""log1p_n_genes_by_counts""],; wspace=0.5,; ncols=2,",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering.html:17339,integrat,integration,17339,en/stable/tutorials/basics/clustering.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering.html,2,['integrat'],['integration']
Integrability,"gakaryocytes do not appear as a separate cluster anymore. This is an extreme case as the reference data is very small; but one should always question if the reference data contain enough biological variation to meaningfully accomodate query data. Using BBKNN#. sc.tl.pca(adata_concat). %%time; sc.external.pp.bbknn(adata_concat, batch_key=""batch"") # running bbknn 1.3.6. CPU times: user 1.67 s, sys: 749 ms, total: 2.42 s; Wall time: 324 ms. sc.tl.umap(adata_concat). sc.pl.umap(adata_concat, color=[""batch"", ""louvain""]). Also BBKNN doesn’t maintain the Megakaryocytes cluster. However, it seems to mix cells more homogeneously. Pancreas#; The following data has been used in the scGen paper [Lotfollahi et al., 2019], has been used here,; was curated here and can be downloaded from here (the BBKNN paper).; It contains data for human pancreas from 4 different studies [Baron et al., 2016, Muraro et al., 2016, Segerstolpe et al., 2016, Wang et al., 2016],; which have been used in the seminal papers on single-cell dataset integration [Butler et al., 2018, Haghverdi et al., 2018] and many times ever since. # note that this collection of batches is already intersected on the genes; adata_all = sc.read(; ""data/pancreas.h5ad"",; backup_url=""https://www.dropbox.com/s/qj1jlm9w10wmt0u/pancreas.h5ad?dl=1"",; ). adata_all.shape. (14693, 2448). Inspect the cell types observed in these studies. counts = adata_all.obs.celltype.value_counts(); counts. alpha 4214; beta 3354; ductal 1804; acinar 1368; not applicable 1154; delta 917; gamma 571; endothelial 289; activated_stellate 284; dropped 178; quiescent_stellate 173; mesenchymal 80; macrophage 55; PSC 54; unclassified endocrine 41; co-expression 39; mast 32; epsilon 28; mesenchyme 27; schwann 13; t_cell 7; MHC class II 5; unclear 4; unclassified 2; Name: celltype, dtype: int64. To simplify visualization, let’s remove the 5 minority classes. minority_classes = counts.index[-5:].tolist() # get the minority classes; adata_all = adata_all[~adata_",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/integrating-data-using-ingest.html:14673,integrat,integration,14673,en/stable/tutorials/basics/integrating-data-using-ingest.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/integrating-data-using-ingest.html,2,['integrat'],['integration']
Integrability,"gend_loc=""on data"", title="""", frameon=False, save="".pdf""; ). WARNING: saving figure to file figures/umap.pdf. Now that we annotated the cell types, let us visualize the marker genes. sc.pl.dotplot(adata, marker_genes, groupby=""leiden"");. There is also a very compact violin plot. sc.pl.stacked_violin(adata, marker_genes, groupby=""leiden"");. During the course of this analysis, the AnnData accumlated the following annotations. adata. AnnData object with n_obs × n_vars = 2638 × 1838; obs: 'n_genes', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'leiden'; var: 'gene_ids', 'n_cells', 'mt', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'highly_variable', 'means', 'dispersions', 'dispersions_norm', 'mean', 'std'; uns: 'hvg', 'leiden', 'leiden_colors', 'log1p', 'neighbors', 'pca', 'rank_genes_groups', 'umap'; obsm: 'X_pca', 'X_umap'; varm: 'PCs'; obsp: 'connectivities', 'distances'. # `compression='gzip'` saves disk space, and slightly slows down writing and subsequent reading; adata.write(results_file, compression=""gzip""). Get a rough overview of the file using h5ls, which has many options - for more details see here. The file format might still be subject to further optimization in the future. All reading functions will remain backwards-compatible, though.; If you want to share this file with people who merely want to use it for visualization, a simple way to reduce the file size is by removing the dense scaled and corrected data matrix. The file still contains the raw data used in the visualizations in adata.raw. adata.raw.to_adata().write(""./write/pbmc3k_withoutX.h5ad""). previous; Preprocessing and clustering. next; Integrating data using ingest and BBKNN. Contents; . Preprocessing; Principal component analysis; Computing the neighborhood graph; Embedding the neighborhood graph; Clustering the neighborhood graph; Finding marker genes. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering-2017.html:26106,Integrat,Integrating,26106,en/stable/tutorials/basics/clustering-2017.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering-2017.html,1,['Integrat'],['Integrating']
Integrability,"gest and BBKNN. Contents . PBMCs; Mapping PBMCs using ingest; Using BBKNN. Pancreas; Seeing the batch effect; BBKNN; Mapping onto a reference batch using ingest; Evaluating consistency; Cell types conserved across batches; All cell types. Visualizing distributions across batches; Density plot; Partial visualizaton of a subset of groups in embedding. Integrating data using ingest and BBKNN#; The following tutorial describes a simple PCA-based method for integrating data we call ingest and compares it with BBKNN [Polanski19]. BBKNN integrates well with the Scanpy workflow and is accessible through the bbknn function.; The ingest function assumes an annotated reference dataset that captures the biological variability of interest. The rational is to fit a model on the reference data and use it to project new data. For the time being, this model is a PCA combined with a neighbor lookup search tree, for which we use UMAP’s implementation [McInnes18]. Similar PCA-based integrations have been used before, for instance, in [Weinreb18]. As ingest is simple and the procedure clear, the workflow is transparent and fast.; Like BBKNN, ingest leaves the data matrix itself invariant.; Unlike BBKNN, ingest solves the label mapping problem (like scmap) and maintains an embedding that might have desired properties like specific clusters or trajectories. We refer to this asymmetric dataset integration as ingesting annotations from an annotated reference adata_ref into an adata that still lacks this annotation. It is different from learning a joint representation that integrates datasets in a symmetric way as BBKNN, Scanorma, Conos, CCA (e.g. in Seurat) or a conditional VAE (e.g. in scVI, trVAE) would do, but comparable to the initiall MNN implementation in scran. Take a look at tools in the external API or at the ecoystem page to get a start with other tools. import scanpy as sc; import pandas as pd. sc.settings.verbosity = 1 # verbosity: errors (0), warnings (1), info (2), hints (3); ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/integrating-data-using-ingest.html:10252,integrat,integrations,10252,en/stable/tutorials/basics/integrating-data-using-ingest.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/integrating-data-using-ingest.html,2,['integrat'],['integrations']
Integrability,"hate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.pl.StackedViolin. Contents . StackedViolin. scanpy.pl.StackedViolin#. class scanpy.pl.StackedViolin(adata, var_names, groupby, *, use_raw=None, log=False, num_categories=7, categories_order=None, title=None, figsize=None, gene_symbols=None, var_group_positions=None, var_group_labels=None, var_group_rotation=None, layer=None, standard_scale=None, ax=None, vmin=None, vmax=None, vcenter=None, norm=None, **kwds)[source]#; Stacked violin plots.; Makes a compact image composed of individual violin plots; (from violinplot()) stacked on top of each other.; Useful to visualize gene expression per cluster.; Wraps seaborn.violinplot() for AnnData. Parameters:. adata AnnDataAnnotated data matrix. var_names Union[str, Sequence[str], Mapping[str, Union[str, Sequence[str]]]]var_names should be a valid subset of adata.var_names.; If var_names is a mapping, then the key is used as label; to group the values (see var_group_labels). The mapping values; should be sequences of valid adata.var_names. In this; case either coloring or ‘brackets’ are used for the grouping; of var names depending on the plot. When var_names is a mapping,; then the var_group_labels and var_group_positions are set. groupby str | Sequence[str]The key of the observation grouping to consider. use_raw bool | None (default: None)Use raw attribute of adata if present. log bool (default: False)Plot on logarithmic axis. num_categories int (default: 7)Only used if groupby observation is not categorical. This value; determines the number of groups into which the groupby observation; should be subdivided. categories_order Sequence[str] | N",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.html:9844,Wrap,Wraps,9844,en/stable/api/generated/classes/scanpy.pl.StackedViolin.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.html,1,['Wrap'],['Wraps']
Integrability,"ial(). Better support for plotting without an image, as well as directly providing images pr1512 G Palla; Dict input for scanpy.queries.enrich() pr1488 G Eraslan; rank_genes_groups_df() can now return fraction of cells in a group expressing a gene, and allows retrieving values for multiple groups at once pr1388 G Eraslan; Color annotations for gene sets in heatmap() are now matched to color for cluster pr1511 L Sikkema; PCA plots can now annotate axes with variance explained pr1470 bfurtwa; Plots with groupby arguments can now group by values in the index by passing the index’s name (like pd.DataFrame.groupby). pr1583 F Ramirez; Added na_color and na_in_legend keyword arguments to embedding() plots. Allows specifying color for missing or filtered values in plots like umap() or spatial() pr1356 I Virshup; embedding() plots now support passing dict of {cluster_name: cluster_color, ...} for palette argument pr1392 I Virshup. External tools (new)#. Add Scanorama integration to scanpy external API (scanorama_integrate(), Hie et al. [2019]) pr1332 B Hie; Scrublet [Wolock et al., 2019] integration: scrublet(), scrublet_simulate_doublets(), and plotting method scrublet_score_distribution() pr1476 J Manning; hashsolo() for HTO demultiplexing [Bernstein et al., 2020] pr1432 NJ Bernstein; Added scirpy (sc-AIRR analysis) to ecosystem page pr1453 G Sturm; Added scvi-tools to ecosystem page pr1421 A Gayoso. External tools (changes)#. Updates for palantir() and palantir_results() pr1245 A Mousa; Fixes to harmony_timeseries() docs pr1248 A Mousa; Support for leiden clustering by scanpy.external.tl.phenograph() pr1080 A Mousa; Deprecate scanpy.external.pp.scvi pr1554 G Xing; Updated default params of sam() to work with larger data pr1540 A Tarashansky. Documentation#. New contribution guide pr1544 I Virshup; zsh installation instructions pr1444 P Angerer. Performance#. Speed up read_10x_h5() pr1402 P Weiler; Speed ups for obs_df() pr1499 F Ramirez. Bugfixes#. Consistent fold-change,",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:31537,integrat,integration,31537,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,1,['integrat'],['integration']
Integrability,"ide of your main plot. In Marsilea, a plot instance is called plotter.; When you add a plotter, you can easily adjust its size and the padding between adjcent plot using size and pad. # Create plotters; chunk = mp.Chunk(uni_cells, rotation=0, align=""center""); colors = mp.Colors(list(pbmc.obs[""louvain""]), palette=cmapper); label_markers = mp.Labels(markers). # Add to the heatmap; m.add_left(colors, size=0.1, pad=0.1); m.add_left(chunk); m.add_top(label_markers, pad=0.1); m.render(). You may want to add dendrogram to display the similarity among cell types.; You can use add_dendrogram, we will add it to the right side, but you can also add it to the left side if you want. m.add_dendrogram(""right"", add_base=False); m.render(). The legend is still mising, you can use add_legends to add all legends at once. Marsilea will automatically layout all the legends.; In the end, you can you add_title to add a title. m.add_legends(); m.add_title(""Expression Profile""); m.render(). OK, let’s wrap up all the code in below. There are few things you should notice in Marsilea:. Always call render() in the end to actually render the plot.; The order of add_* operation decides the order of plotters. But group_rows and group_cols can be called anytime. m = ma.Heatmap(exp, cmap=""viridis"", height=4, width=3); m.group_rows(pbmc.obs[""louvain""], order=uni_cells). m.add_left(; mp.Colors(list(pbmc.obs[""louvain""]), palette=cmapper),; size=0.1,; pad=0.1,; ); m.add_left(mp.Chunk(uni_cells, rotation=0, align=""center"")); m.add_top(mp.Labels(markers), pad=0.1); m.add_dendrogram(""right"", add_base=False). m.add_legends(); m.add_title(""Expression Profile""); m.render(). Now that we’ve covered some basics of Marsilea, we’ll see how it can be used to create custom plots similar to scanpy’s existing methods:. agg = sc.get.aggregate(pbmc[:, markers], by=""louvain"", func=[""mean"", ""count_nonzero""]); agg.obs[""cell_counts""] = pbmc.obs[""louvain""].value_counts(); agg. AnnData object with n_obs × n_vars = 8 × 12; obs:",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/how-to/plotting-with-marsilea.html:12504,wrap,wrap,12504,en/stable/how-to/plotting-with-marsilea.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/how-to/plotting-with-marsilea.html,1,['wrap'],['wrap']
Integrability,"igns batches in a quick and lightweight manner.; For use in the scanpy workflow as an alternative to neighbors(). Note; This is just a wrapper of bbknn.bbknn(): up to date docstring,; more information and bug reports there. Parameters:. adata AnnDataNeeds the PCA computed and stored in adata.obsm[""X_pca""]. batch_key str (default: 'batch')adata.obs column name discriminating between your batches. use_rep str (default: 'X_pca')The dimensionality reduction in .obsm to use for neighbour detection. Defaults to PCA. approx bool (default: True)If True, use approximate neighbour finding - annoy or PyNNDescent. This results; in a quicker run time for large datasets while also potentially increasing the degree of; batch correction. use_annoy bool (default: True)Only used when approx=True. If True, will use annoy for neighbour finding. If; False, will use pyNNDescent instead. metric Union[str, Callable, DistanceMetric] (default: 'euclidean')What distance metric to use. The options depend on the choice of neighbour algorithm.; ”euclidean”, the default, is always available.; Annoy supports “angular”, “manhattan” and “hamming”.; PyNNDescent supports metrics listed in pynndescent.distances.named_distances; and custom functions, including compiled Numba code.; >>> import pynndescent; >>> pynndescent.distances.named_distances.keys() ; dict_keys(['euclidean', 'l2', 'sqeuclidean', 'manhattan', 'taxicab', 'l1', 'chebyshev', 'linfinity',; 'linfty', 'linf', 'minkowski', 'seuclidean', 'standardised_euclidean', 'wminkowski', ...]). KDTree supports members of sklearn.neighbors.KDTree’s valid_metrics list, or parameterised; DistanceMetric objects:; >>> import sklearn.neighbors; >>> sklearn.neighbors.KDTree.valid_metrics; ['euclidean', 'l2', 'minkowski', 'p', 'manhattan', 'cityblock', 'l1', 'chebyshev', 'infinity']. Note; check the relevant documentation for up-to-date lists. copy bool (default: False)If True, return a copy instead of writing to the supplied adata. neighbors_within_batch int (",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.bbknn.html:10949,depend,depend,10949,en/stable/generated/scanpy.external.pp.bbknn.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.bbknn.html,1,['depend'],['depend']
Integrability,"ing.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.tl.ingest. Contents . ingest(). scanpy.tl.ingest#. scanpy.tl.ingest(adata, adata_ref, *, obs=None, embedding_method=('umap', 'pca'), labeling_method='knn', neighbors_key=None, inplace=True, **kwargs)[source]#; Map labels and embeddings from reference data to new data.; Integrating data using ingest and BBKNN; Integrates embeddings and annotations of an adata with a reference dataset; adata_ref through projecting on a PCA (or alternate; model) that has been fitted on the reference data. The function uses a knn; classifier for mapping labels and the UMAP package [McInnes et al., 2018] for mapping; the embeddings. Note; We refer to this asymmetric dataset integration as ingesting; annotations from reference data to new data. This is different from; learning a joint representation that integrates both datasets in an; unbiased way, as CCA (e.g. in Seurat) or a conditional VAE (e.g. in; scVI) would do. You need to run neighbors() on adata_ref before; passing it. Parameters:. adata AnnDataThe annotated data matrix of shape n_obs × n_vars. Rows correspond; to cells and columns to genes. This is the dataset without labels and; embeddings. adata_ref AnnDataThe annotated data matrix of shape n_obs × n_vars. Rows correspond; to cells and columns to genes.; Variables (n_vars and var_names) of adata_ref should be the same; as in adata.; This is the dataset with labels and embeddings; which need to be mapped to adata. obs str | Iterable[str] | None (default: None)Labels’ keys in adata_ref.obs which need to be mapped to adata.obs; (inferred for observation of adata). embedding_method str | Iterable[str] (default: ('umap', 'pca'))Embeddings in adata_ref which need to be mapped to adata.; The only supported values are ‘umap’ and ‘pca’. labeling_method str (default: 'knn')The me",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.ingest.html:10025,integrat,integrates,10025,en/stable/generated/scanpy.tl.ingest.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.ingest.html,1,['integrat'],['integrates']
Integrability,"is accessible through the bbknn function.; The ingest function assumes an annotated reference dataset that captures the biological variability of interest. The rational is to fit a model on the reference data and use it to project new data. For the time being, this model is a PCA combined with a neighbor lookup search tree, for which we use UMAP’s implementation [McInnes18]. Similar PCA-based integrations have been used before, for instance, in [Weinreb18]. As ingest is simple and the procedure clear, the workflow is transparent and fast.; Like BBKNN, ingest leaves the data matrix itself invariant.; Unlike BBKNN, ingest solves the label mapping problem (like scmap) and maintains an embedding that might have desired properties like specific clusters or trajectories. We refer to this asymmetric dataset integration as ingesting annotations from an annotated reference adata_ref into an adata that still lacks this annotation. It is different from learning a joint representation that integrates datasets in a symmetric way as BBKNN, Scanorma, Conos, CCA (e.g. in Seurat) or a conditional VAE (e.g. in scVI, trVAE) would do, but comparable to the initiall MNN implementation in scran. Take a look at tools in the external API or at the ecoystem page to get a start with other tools. import scanpy as sc; import pandas as pd. sc.settings.verbosity = 1 # verbosity: errors (0), warnings (1), info (2), hints (3); sc.logging.print_versions(); sc.settings.set_figure_params(dpi=80, frameon=False, figsize=(3, 3), facecolor=""white""). scanpy==1.5.0 anndata==0.7.1 umap==0.4.2 numpy==1.18.1 scipy==1.4.1 pandas==1.0.3 scikit-learn==0.22.1 statsmodels==0.11.0. PBMCs#; We consider an annotated reference dataset adata_ref and a dataset for which you want to query labels and embeddings adata. # this is an earlier version of the dataset from the pbmc3k tutorial; adata_ref = sc.datasets.pbmc3k_processed(); adata = sc.datasets.pbmc68k_reduced(). To use sc.tl.ingest, the datasets need to be defined o",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/integrating-data-using-ingest.html:10849,integrat,integrates,10849,en/stable/tutorials/basics/integrating-data-using-ingest.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/integrating-data-using-ingest.html,2,['integrat'],['integrates']
Integrability,"itter=False, size=1, scale='width', yticklabels=False, order=None, swap_axes=False, show=None, save=None, return_fig=False, row_palette=None, cmap='Blues', ax=None, vmin=None, vmax=None, vcenter=None, norm=None, **kwds)[source]#; Stacked violin plots.; Makes a compact image composed of individual violin plots; (from violinplot()) stacked on top of each other.; Useful to visualize gene expression per cluster.; Wraps seaborn.violinplot() for AnnData.; This function provides a convenient interface to the; StackedViolin class. If you need more flexibility,; you should use StackedViolin directly. Parameters:. adata AnnDataAnnotated data matrix. var_names Union[str, Sequence[str], Mapping[str, Union[str, Sequence[str]]]]var_names should be a valid subset of adata.var_names.; If var_names is a mapping, then the key is used as label; to group the values (see var_group_labels). The mapping values; should be sequences of valid adata.var_names. In this; case either coloring or ‘brackets’ are used for the grouping; of var names depending on the plot. When var_names is a mapping,; then the var_group_labels and var_group_positions are set. groupby str | Sequence[str]The key of the observation grouping to consider. use_raw bool | None (default: None)Use raw attribute of adata if present. log bool (default: False)Plot on logarithmic axis. num_categories int (default: 7)Only used if groupby observation is not categorical. This value; determines the number of groups into which the groupby observation; should be subdivided. categories_orderOrder in which to show the categories. Note: add_dendrogram or add_totals; can change the categories order. figsize tuple[float, float] | None (default: None)Figure size when multi_panel=True.; Otherwise the rcParam['figure.figsize] value is used.; Format is (width, height). dendrogram bool | str (default: False)If True or a valid dendrogram key, a dendrogram based on the hierarchical; clustering between the groupby categories is added.; The dendrogr",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pl.stacked_violin.html:10680,depend,depending,10680,en/stable/generated/scanpy.pl.stacked_violin.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pl.stacked_violin.html,1,['depend'],['depending']
Integrability,"k_reduced; scanpy.datasets.paul15; scanpy.datasets.toggleswitch; scanpy.datasets.visium_sge. Deprecated functions; scanpy.pp.filter_genes_dispersion; scanpy.pp.normalize_per_cell. External API; Preprocessing: PP; scanpy.external.pp.bbknn; scanpy.external.pp.harmony_integrate; scanpy.external.pp.mnn_correct; scanpy.external.pp.scanorama_integrate; scanpy.external.pp.hashsolo; scanpy.external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .md. .pdf. Experimental. Experimental#; New methods that are in early development which are not (yet); integrated in Scanpy core. experimental.pp.normalize_pearson_residuals; Applies analytic Pearson residual normalization, based on Lause et al. [2021]. experimental.pp.normalize_pearson_residuals_pca; Applies analytic Pearson residual normalization and PCA, based on Lause et al. [2021]. experimental.pp.highly_variable_genes; Select highly variable genes using analytic Pearson residuals [Lause et al., 2021]. experimental.pp.recipe_pearson_residuals; Full pipeline for HVG selection and normalization by analytic Pearson residuals [Lause et al., 2021]. previous; scanpy.metrics.morans_i. next; scanpy.experimental.pp.normalize_pearson_residuals. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/experimental.html:9312,integrat,integrated,9312,en/stable/api/experimental.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/experimental.html,1,['integrat'],['integrated']
Integrability,"l.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .ipynb. .pdf. Integrating spatial data with scRNA-seq using scanorama. Contents . Loading libraries; Reading the data; Data integration; Data integration and label transfer from scRNA-seq dataset. Integrating spatial data with scRNA-seq using scanorama#; Author: Giovanni Palla. Note; For up-to-date analysis tutorials, kindly check out SquidPy tutorials. This tutorial shows how to work with multiple Visium datasets and perform integration of scRNA-seq dataset with Scanpy. It follows the previous tutorial on analysis and visualization of spatial transcriptomics data.; We will use Scanorama paper - code to perform integration and label transfer. It has a convenient interface with scanpy and anndata.; To install the required libraries, type the following:; pip install git+https://github.com/theislab/scanpy.git; pip install git+https://github.com/theislab/anndata.git; pip install scanorama. Loading libraries#. import scanpy as sc; import anndata as an; import pandas as pd; import numpy as np; import matplotlib.pyplot as plt; import seaborn as sns; import scanorama. from pathlib import Path. sc.logging.print_versions(); sc.set_figure_params(facecolor=""white"", figsize=(8, 8)); sc.settings.verbosity = 3. -----; anndata 0.11.0.dev78+g64ab900; scanpy 1.10.0rc2.dev6+g14555ba4; -----; PIL 10.2.0; annoy NA; anyio NA; appnope 0.1.3; arrow 1.3.0; asciitree NA; asttokens NA; attr 23.2.0; attrs 23.2.0; babel 2.14.0; certifi 2023.11.17; cffi 1.16.0; charset_normalizer 3.3.2; cloudpickle 3.0.0; comm 0.2.1; cycler 0.12.1; cython_runtime NA; dask 2024.1.0; dateutil 2.8.2; debugpy 1.8.0; decorator 5.1.1; defusedxml 0.7.1; executing 2.0.1; fasteners 0.19; fastjsonschema NA",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html:9924,interface,interface,9924,en/stable/tutorials/spatial/integration-scanorama.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html,2,['interface'],['interface']
Integrability,"le_genes() (seurat and cell-ranger tested) pr2856 ilan-gold. Documentation#. Doc style overhaul pr2220 A Gayoso; Re-add search-as-you-type, this time via readthedocs-sphinx-search pr2805 P Angerer; Fixed a lot of broken usage examples pr2605 P Angerer; Improved harmonization of return field of sc.pp and sc.tl functions pr2742 E Roellin; Improved docs for percent_top argument of calculate_qc_metrics() pr2849 I Virshup; New basic clustering tutorial (Preprocessing and clustering), based on one from scverse-tutorials pr2901 I Virshup; Overhauled Tutorials page, and added new How to section to docs pr2901 I Virshup; Added a new tutorial on working with dask (Using dask with Scanpy) pr2901 I Gold I Virshup. Bug fixes#. Updated read_visium() such that it can read spaceranger 2.0 files L Lehner; Fix normalize_total() for dask pr2466 P Angerer; Fix setting sc.settings.verbosity in some cases pr2605 P Angerer; Fix all remaining pandas warnings pr2789 P Angerer; Fix some annoying plotting warnings around violin plots pr2844 P Angerer; Scanpy now has a test job which tests against the minumum versions of the dependencies. In the process of implementing this, many bugs associated with using older versions of pandas, anndata, numpy, and matplotlib were fixed. pr2816 I Virshup; Fix warnings caused by internal usage of pandas.DataFrame.stack with pandas>=2.1 pr2864I Virshup; scanpy.get.aggregate() now always returns numpy.ndarray pr2893 S Dicks; Removes self from array of neighbors for use_approx_neighbors = True in scrublet() pr2896S Dicks; Compatibility with scipy 1.13 pr2943 I Virshup; Fix use of dendrogram() on highly correlated low precision data pr2928 P Angerer; Fix pytest deprecation warning pr2879 P Angerer. Development Process#. Scanpy is now tested against python 3.12 pr2863 ivirshup; Fix testing package build pr2468 P Angerer. Deprecations#. Dropped support for Python 3.8. More details here. pr2695 P Angerer; Deprecated specifying large numbers of function parameters by",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:18216,depend,dependencies,18216,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,1,['depend'],['dependencies']
Integrability,"ll, 162(1):184–197, jul 2015. URL: https://doi.org/10.1016/j.cell.2015.05.047, doi:10.1016/j.cell.2015.05.047. [LWT19]; Mohammad Lotfollahi, F. Alexander Wolf, and Fabian J. Theis. Scgen predicts single-cell perturbation responses. Nature Methods, 16(8):715–721, jul 2019. URL: https://doi.org/10.1038/s41592-019-0494-8, doi:10.1038/s41592-019-0494-8. [LBC+21]; Malte Luecken, Daniel Burkhardt, Robrecht Cannoodt, Christopher Lance, Aditi Agrawal, Hananeh Aliee, Ann Chen, Louise Deconinck, Angela Detweiler, Alejandro Granados, Shelly Huynh, Laura Isacco, Yang Kim, Dominik Klein, Bony De Kumar, Sunil Kuppasani, Heiko Lickert, Aaron McGeever, Joaquin Melgarejo, Honey Mekonen, Maurizio Morri, Michaela Müller, Norma Neff, Sheryl Paul, Bastian Rieck, Kaylie Schneider, Scott Steelman, Michael Sterr, Daniel Treacy, Alexander Tong, Alexandra-Chloe Villani, Guilin Wang, Jia Yan, Ce Zhang, Angela Pisco, Smita Krishnaswamy, Fabian Theis, and Jonathan M Bloom. A sandbox for prediction and integration of dna, rna, and proteins in single cells. In J. Vanschoren and S. Yeung, editors, Proceedings of the Neural Information Processing Systems Track on Datasets and Benchmarks, volume 1. Curran, 2021. URL: https://datasets-benchmarks-proceedings.neurips.cc/paper_files/paper/2021/file/158f3069a435b314a80bdcb024f8e422-Paper-round2.pdf. [MCLW17]; Davis J McCarthy, Kieran R Campbell, Aaron T L Lun, and Quin F Wills. Scater: pre-processing, quality control, normalization and visualization of single-cell RNA-seq data in r. Bioinformatics, 33(8):1179–1186, jan 2017. URL: https://doi.org/10.1093/bioinformatics/btw777, doi:10.1093/bioinformatics/btw777. [MHM18]; Leland McInnes, John Healy, and James Melville. Umap: uniform manifold approximation and projection for dimension reduction. 2018. URL: https://arxiv.org/abs/1802.03426, doi:10.48550/ARXIV.1802.03426. [MWH+15]; Victoria Moignard, Steven Woodhouse, Laleh Haghverdi, Andrew J Lilly, Yosuke Tanaka, Adam C Wilkinson, Florian Buettner, Iain C Ma",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/references.html:18844,integrat,integration,18844,en/stable/references.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/references.html,1,['integrat'],['integration']
Integrability,"ll. The not-excluded genes will sum up to; target_sum. Providing this argument when adata.X is a Array; will incur blocking .compute() calls on the array. max_fraction float (default: 0.05)If exclude_highly_expressed=True, consider cells as highly expressed; that have more counts than max_fraction of the original total counts; in at least one cell. key_added str | None (default: None)Name of the field in adata.obs where the normalization factor is; stored. layer str | None (default: None)Layer to normalize instead of X. If None, X is normalized. inplace bool (default: True)Whether to update adata or return dictionary with normalized copies of; adata.X and adata.layers. copy bool (default: False)Whether to modify copied input object. Not compatible with inplace=False. Return type:; AnnData | dict[str, ndarray] | None. Returns:; Returns dictionary with normalized copies of adata.X and adata.layers; or updates adata with normalized version of the original; adata.X and adata.layers, depending on inplace. Example; >>> import sys; >>> from anndata import AnnData; >>> import scanpy as sc; >>> sc.settings.verbosity = 'info'; >>> sc.settings.logfile = sys.stdout # for doctests; >>> np.set_printoptions(precision=2); >>> adata = AnnData(np.array([; ... [3, 3, 3, 6, 6],; ... [1, 1, 1, 2, 2],; ... [1, 22, 1, 2, 2],; ... ], dtype='float32')); >>> adata.X; array([[ 3., 3., 3., 6., 6.],; [ 1., 1., 1., 2., 2.],; [ 1., 22., 1., 2., 2.]], dtype=float32); >>> X_norm = sc.pp.normalize_total(adata, target_sum=1, inplace=False)['X']; normalizing counts per cell; finished (0:00:00); >>> X_norm; array([[0.14, 0.14, 0.14, 0.29, 0.29],; [0.14, 0.14, 0.14, 0.29, 0.29],; [0.04, 0.79, 0.04, 0.07, 0.07]], dtype=float32); >>> X_norm = sc.pp.normalize_total(; ... adata, target_sum=1, exclude_highly_expressed=True,; ... max_fraction=0.2, inplace=False; ... )['X']; normalizing counts per cell. The following highly-expressed genes are not considered during normalization factor computation:; ['1', '3', ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.normalize_total.html:11947,depend,depending,11947,en/stable/generated/scanpy.pp.normalize_total.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.normalize_total.html,1,['depend'],['depending']
Integrability,"lly sparse, and can thus be stored efficiently for large datasets. However, when the count matrix is transformed to Pearson residuals, the data becomes dense. To avoid memory problems, we recommend that you reduce the size of your count matrix by gene selection, before running normalize_pearson_residuals(adata) on the reduced data. To perform RAM-efficient gene selection, use highly_variable_genes(adata,flavor='pearson_residuals') with the chunksize argument: This will still use Pearson residual variance to identify variable genes, but won’t compute all residuals at once. Reduce the chunksize as needed if you run into RAM issues during gene selection. Note that a very small chunksize will slow down the computation, so try to set it as large as possible with your resources.; As an example, we used chunksize=1000 when processing a dataset with 2 million cells in a machine with 500 GB RAM. For smaller machines, we would recommend to reduce this below 100. Wrapper functions for Pearson residuals preprocessing#; The scanpy.experimental.pp module also ships two wrappers that run multiple pre-processing steps at once:. sc.experimental.pp.normalize_pearson_residuals_pca() performs normalization by Pearson residuals and PCA in one go. This function is helpful to quickly obtain a Pearson residual-based data representation when highly variable genes are already defined, as only those are used by default.; sc.experimental.pp.recipe_pearson_residuals() performs gene selection and normalization by Pearson residuals, and PCA on top. This is intended to make the full Pearson residual preprocessing available in one step. All hyperparameters of the individual steps can still be controlled using the wrapper functions’ arguments. See the documentation for details. References / See also#; Hafemeister & Satija (2019), Normalization and variance stabilization of single-cell RNA-seq data using regularized negative binomial regression, Genome Biology; Lause et al. (2021), Analytic Pearson r",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:29797,Wrap,Wrapper,29797,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,1,['Wrap'],['Wrapper']
Integrability,"lts with them hidden via the --disable-pytest-warnings argument. Writing tests#; You can refer to the existing test suite for examples.; If you haven’t written tests before, Software Carpentry has an in-depth testing guide.; We highly recommend using Test-Driven Development when contributing code.; This not only ensures you have tests written, it often makes implementation easier since you start out with a specification for your function.; Consider parameterizing your tests using the pytest.mark.parameterize and pytest.fixture decorators.; You can read more about fixtures in pytest’s documentation, but we’d also recommend searching our test suite for existing usage. What to test#; If you’re not sure what to tests about your function, some ideas include:. Are there arguments which conflict with each other? Check that if they are both passed, the function throws an error (see pytest.raises docs).; Are there input values which should cause your function to error?; Did you add a helpful error message that recommends better outputs? Check that that error message is actually thrown.; Can you place bounds on the values returned by your function?; Are there different input values which should generate equivalent output (e.g. if an array is sparse or dense)?; Do you have arguments which should have orthogonal effects on the output? Check that they are independent. For example, if there is a flag for extended output, the base output should remain the same either way.; Are you optimizing a method? Check that it’s results are the same as a gold standard implementation. Performance#; It’s more important that you’re accurately testing the code works than it is that test suite runs quickly.; That said, it’s nice when the test suite runs fast.; You can check how long tests take to run by passing --durations=0 argument to pytest.; Hopefully your new tests won’t show up on top!; Some approaches to this include:. Is there a common setup/ computation happening in each test? Consider ca",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/dev/testing.html:11138,message,message,11138,en/stable/dev/testing.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/dev/testing.html,2,['message'],['message']
Integrability,"n by Pearson residuals and PCA in one go. This function is helpful to quickly obtain a Pearson residual-based data representation when highly variable genes are already defined, as only those are used by default.; sc.experimental.pp.recipe_pearson_residuals() performs gene selection and normalization by Pearson residuals, and PCA on top. This is intended to make the full Pearson residual preprocessing available in one step. All hyperparameters of the individual steps can still be controlled using the wrapper functions’ arguments. See the documentation for details. References / See also#; Hafemeister & Satija (2019), Normalization and variance stabilization of single-cell RNA-seq data using regularized negative binomial regression, Genome Biology; Lause et al. (2021), Analytic Pearson residuals for normalization of single-cell RNA-seq UMI data, Genome Biology; Wagner (2021), Normalization methods for single-cell RNA-Seq data, Youtube; Choudhary & Satija (2022), Comparison and evaluation of statistical error models for scRNA-seq, Genome Biology. previous; Experimental. next; Using dask with Scanpy. Contents; . Background; Preparations; Download data; Load data. Perform Quality control; Basic filtering; Compute quality control metrics; Plot quality control metrics. Use Pearson residuals for selection of highly variable genes; Compute 2000 variable genes with Pearson residuals; Plot gene selection; Apply gene selection; Print resulting adata objects. Transforming raw counts to Pearson residuals; Preparations; Compute Pearson residuals; Compute PCA and t-SNE; Compute Neighborhood graph and Leiden clustering; Plot Leiden clusters on tSNE and PBMC marker genes. Optional input arguments; Overdispersion parameter theta; Clipping threshold clip; chunksize and best practice to obtain Pearson residuals for large datasets. Wrapper functions for Pearson residuals preprocessing; References / See also. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:31876,Wrap,Wrapper,31876,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,1,['Wrap'],['Wrapper']
Integrability,"n; scanpy.external.pp.harmony_integrate; scanpy.external.pp.mnn_correct; scanpy.external.pp.scanorama_integrate; scanpy.external.pp.hashsolo; scanpy.external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .md. .pdf. Preprocessing: PP. Contents . Data integration; Sample demultiplexing; Imputation. Preprocessing: PP#. Data integration#. pp.bbknn(adata, *[, batch_key, use_rep, ...]); Batch balanced kNN [Polański et al., 2019]. pp.harmony_integrate(adata, key, *[, basis, ...]); Use harmonypy [Korsunsky et al., 2019] to integrate different experiments. pp.mnn_correct(*datas[, var_index, ...]); Correct batch effects by matching mutual nearest neighbors [Haghverdi et al., 2018] [Kang, 2018]. pp.scanorama_integrate(adata, key, *[, ...]); Use Scanorama [Hie et al., 2019] to integrate different experiments. Sample demultiplexing#. pp.hashsolo(adata, cell_hashing_columns, *); Probabilistic demultiplexing of cell hashing data using HashSolo [Bernstein et al., 2020]. Imputation#; Note that the fundamental limitations of imputation are still under debate. pp.dca(adata[, mode, ae_type, ...]); Deep count autoencoder [Eraslan et al., 2019]. pp.magic(adata[, name_list, knn, decay, ...]); Markov Affinity-based Graph Imputation of Cells (MAGIC) API [van Dijk et al., 2018",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/preprocessing.html:9260,integrat,integration,9260,en/stable/external/preprocessing.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/preprocessing.html,1,['integrat'],['integration']
Integrability,"nal.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.pp.log1p. Contents . log1p(). scanpy.pp.log1p#. scanpy.pp.log1p(data, *, base=None, copy=False, chunked=None, chunk_size=None, layer=None, obsm=None)[source]#; Logarithmize the data matrix.; Computes \(X = \log(X + 1)\),; where \(log\) denotes the natural logarithm unless a different base is given. Parameters:. data AnnData | ndarray | spmatrixThe (annotated) data matrix of shape n_obs × n_vars.; Rows correspond to cells and columns to genes. base Number | None (default: None)Base of the logarithm. Natural logarithm is used by default. copy bool (default: False)If an AnnData is passed, determines whether a copy; is returned. chunked bool | None (default: None)Process the data matrix in chunks, which will save memory.; Applies only to AnnData. chunk_size int | None (default: None)n_obs of the chunks to process the data in. layer str | None (default: None)Entry of layers to transform. obsm str | None (default: None)Entry of obsm to transform. Return type:; AnnData | ndarray | spmatrix | None. Returns:; Returns or updates data, depending on copy. previous; scanpy.pp.highly_variable_genes. next; scanpy.pp.pca. Contents; . log1p(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.log1p.html:10272,depend,depending,10272,en/stable/generated/scanpy.pp.log1p.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.log1p.html,1,['depend'],['depending']
Integrability,"nal.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .md. .pdf. Getting set up. Contents . Working with git; Forking and cloning; pre-commit; Creating a branch for your feature; Open a pull request. Development environments. Getting set up#. Working with git#; This section of the docs covers our practices for working with git on our codebase. For more in-depth guides, we can recommend a few sources:; For a more complete git tutorials we recommend checking out:. Atlassian’s git tutorialBeginner friendly introductions to the git command line interface. Setting up git for GitHubConfiguring git to work with your GitHub user account. Forking and cloning#; To get the code, and be able to push changes back to the main project, you’ll need to (1) fork the repository on github and (2) clone the repository to your local machine.; This is very straight forward if you’re using GitHub’s CLI:; $ gh repo fork scverse/scanpy --clone --remote. This will fork the repo to your github account, create a clone of the repo on your current machine, add our repository as a remote, and set the main development branch to track our repository.; To do this manually, first make a fork of the repository by clicking the “fork” button on our main github package. Then, on your machine, run:; $ # Clone your fork of the repository (substitute in your username); $ git clone https://github.com/{your-username}/scanpy.git; $ # Enter the cloned repository; $ cd scanpy; $ # Add our repository as a remote; $ git remote add upstr",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/dev/getting-set-up.html:9705,interface,interface,9705,en/stable/dev/getting-set-up.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/dev/getting-set-up.html,1,['interface'],['interface']
Integrability,"ng: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.external.tl.phate. Contents . phate(). scanpy.external.tl.phate#. scanpy.external.tl.phate(adata, n_components=2, *, k=5, a=15, n_landmark=2000, t='auto', gamma=1.0, n_pca=100, knn_dist='euclidean', mds_dist='euclidean', mds='metric', n_jobs=None, random_state=None, verbose=None, copy=False, **kwargs)[source]#; PHATE [Moon et al., 2019].; Potential of Heat-diffusion for Affinity-based Trajectory Embedding (PHATE); embeds high dimensional single-cell data into two or three dimensions for; visualization of biological progressions.; For more information and access to the object-oriented interface, read the; PHATE documentation. For; tutorials, bug reports, and R/MATLAB implementations, visit the PHATE; GitHub page. For help; using PHATE, go here. Parameters:. adata AnnDataAnnotated data matrix. n_components int (default: 2)number of dimensions in which the data will be embedded. k int (default: 5)number of nearest neighbors on which to build kernel. a int (default: 15)sets decay rate of kernel tails.; If None, alpha decaying kernel is not used. n_landmark int (default: 2000)number of landmarks to use in fast PHATE. t int | str (default: 'auto')power to which the diffusion operator is powered; sets the level of diffusion. If ‘auto’, t is selected; according to the knee point in the Von Neumann Entropy of; the diffusion operator. gamma float (default: 1.0)Informational distance constant between -1 and 1.; gamma=1 gives the PHATE log potential, gamma=0 gives; a square root potential. n_pca int (default: 100)Number of principal components to use for calculating; n",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.phate.html:9831,interface,interface,9831,en/stable/external/generated/scanpy.external.tl.phate.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.phate.html,2,['interface'],['interface']
Integrability,"nishing from things like .uns['log1p'] pr2546 SP Shen; Depend on igraph instead of python-igraph pr2566 P Angerer; rank_genes_groups() now handles unsorted groups as intended pr2589 S Dicks; rank_genes_groups_df() now works for rank_genes_groups() with method=""logreg"" pr2601 S Dicks; scanpy.tl._utils._choose_representation now works with n_pcs if bigger than settings.N_PCS pr2610 S Dicks. 1.9.3 2023-03-02#. Bug fixes#. Variety of fixes against pandas 2.0.0rc0 pr2434 I Virshup. 1.9.2 2023-02-16#. Bug fixes#. highly_variable_genes() layer argument now works in tandem with batches pr2302 D Schaumont; highly_variable_genes() with flavor='cell_ranger' now handles the case in issue2230 where the number of calculated dispersions is less than n_top_genes pr2231 L Zappia; Fix compatibility with matplotlib 3.7 pr2414 I Virshup P Fisher; Fix scrublet numpy matrix compatibility issue pr2395 A Gayoso. 1.9.1 2022-04-05#. Bug fixes#. normalize_total() works when Dask is not installed pr2209 R Cannoodt; Fix embedding plots by bumping matplotlib dependency to version 3.4 pr2212 I Virshup. 1.9.0 2022-04-01#. Tutorials#. New tutorial on the usage of Pearson Residuals: How to preprocess UMI count data with analytic Pearson residuals J Lause, G Palla; Materials and recordings for Scanpy workshops by Maren Büttner. Experimental module#. Added scanpy.experimental module! Currently contains functionality related to pearson residuals in scanpy.experimental.pp pr1715 J Lause, G Palla, I Virshup. This includes:. normalize_pearson_residuals() for Pearson Residuals normalization; highly_variable_genes() for HVG selection with Pearson Residuals; normalize_pearson_residuals_pca() for Pearson Residuals normalization and dimensionality reduction with PCA; recipe_pearson_residuals() for Pearson Residuals normalization, HVG selection and dimensionality reduction with PCA. Features#. filter_rank_genes_groups() now allows to filter with absolute values of log fold change pr1649 S Rybakov; _choose_repres",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:21934,depend,dependency,21934,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,1,['depend'],['dependency']
Integrability,"notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .ipynb. .pdf. How to preprocess UMI count data with analytic Pearson residuals. Contents . Background; Preparations; Download data; Load data. Perform Quality control; Basic filtering; Compute quality control metrics; Plot quality control metrics. Use Pearson residuals for selection of highly variable genes; Compute 2000 variable genes with Pearson residuals; Plot gene selection; Apply gene selection; Print resulting adata objects. Transforming raw counts to Pearson residuals; Preparations; Compute Pearson residuals; Compute PCA and t-SNE; Compute Neighborhood graph and Leiden clustering; Plot Leiden clusters on tSNE and PBMC marker genes. Optional input arguments; Overdispersion parameter theta; Clipping threshold clip; chunksize and best practice to obtain Pearson residuals for large datasets. Wrapper functions for Pearson residuals preprocessing; References / See also. How to preprocess UMI count data with analytic Pearson residuals#; With version 1.9, scanpy introduces new preprocessing functions based on Pearson residuals into the experimental.pp module. These functions implement the core steps of the preprocessing described and benchmarked in Lause et al. (2021).; In the first part, this tutorial introduces the new core functions by demonstrating their usage on two example datasets. In the second part, we briefly explain the optional arguments and their default settings. Finally, two wrapper functions that run the whole Pearson residual workflow at once are briefly discussed. Background#; In brief, Pearson residuals transform raw UMI counts into a representation where three aims are achieved:. remove the technical variation that comes from differences in total counts between cells; stabilize the mean-variance relationship across genes, i.e. ensure that biological signal from both low and high expression gene",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:10069,Wrap,Wrapper,10069,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,1,['Wrap'],['Wrapper']
Integrability,"npy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.pl.matrixplot. Contents . matrixplot(). scanpy.pl.matrixplot#. scanpy.pl.matrixplot(adata, var_names, groupby, *, use_raw=None, log=False, num_categories=7, figsize=None, dendrogram=False, title=None, cmap='viridis', colorbar_title='Mean expression\\nin group', gene_symbols=None, var_group_positions=None, var_group_labels=None, var_group_rotation=None, layer=None, standard_scale=None, values_df=None, swap_axes=False, show=None, save=None, ax=None, return_fig=False, vmin=None, vmax=None, vcenter=None, norm=None, **kwds)[source]#; Creates a heatmap of the mean expression values per group of each var_names.; This function provides a convenient interface to the MatrixPlot; class. If you need more flexibility, you should use MatrixPlot; directly. Parameters:. adata AnnDataAnnotated data matrix. var_names Union[str, Sequence[str], Mapping[str, Union[str, Sequence[str]]]]var_names should be a valid subset of adata.var_names.; If var_names is a mapping, then the key is used as label; to group the values (see var_group_labels). The mapping values; should be sequences of valid adata.var_names. In this; case either coloring or ‘brackets’ are used for the grouping; of var names depending on the plot. When var_names is a mapping,; then the var_group_labels and var_group_positions are set. groupby str | Sequence[str]The key of the observation grouping to consider. use_raw bool | None (default: None)Use raw attribute of adata if present. log bool (default: False)Plot on logarithmic axis. num_categories int (default: 7)Only used if groupby observation is not categorical. This value; determines the number of groups into which the groupby",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pl.matrixplot.html:9885,interface,interface,9885,en/stable/generated/scanpy.pl.matrixplot.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pl.matrixplot.html,1,['interface'],['interface']
Integrability,"npyConfig.max_memory; scanpy._settings.ScanpyConfig.n_jobs; scanpy._settings.ScanpyConfig.plot_suffix; scanpy._settings.ScanpyConfig.verbosity; scanpy._settings.ScanpyConfig.writedir; scanpy._settings.ScanpyConfig.N_PCS; scanpy._settings.ScanpyConfig.set_figure_params. scanpy.logging.print_header; scanpy.logging.print_versions. Datasets; scanpy.datasets.blobs; scanpy.datasets.ebi_expression_atlas; scanpy.datasets.krumsiek11; scanpy.datasets.moignard15; scanpy.datasets.pbmc3k; scanpy.datasets.pbmc3k_processed; scanpy.datasets.pbmc68k_reduced; scanpy.datasets.paul15; scanpy.datasets.toggleswitch; scanpy.datasets.visium_sge. Deprecated functions; scanpy.pp.filter_genes_dispersion; scanpy.pp.normalize_per_cell. External API; Preprocessing: PP; scanpy.external.pp.bbknn; scanpy.external.pp.harmony_integrate; scanpy.external.pp.mnn_correct; scanpy.external.pp.scanorama_integrate; scanpy.external.pp.hashsolo; scanpy.external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .md. .pdf. Basics. Basics#. Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. previous; Tutorials. next; Preprocessing and clustering. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/index.html:9318,Integrat,Integrating,9318,en/stable/tutorials/basics/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/index.html,1,['Integrat'],['Integrating']
Integrability,"nt matrix is transformed to Pearson residuals, the data becomes dense. To avoid memory problems, we recommend that you reduce the size of your count matrix by gene selection, before running normalize_pearson_residuals(adata) on the reduced data. To perform RAM-efficient gene selection, use highly_variable_genes(adata,flavor='pearson_residuals') with the chunksize argument: This will still use Pearson residual variance to identify variable genes, but won’t compute all residuals at once. Reduce the chunksize as needed if you run into RAM issues during gene selection. Note that a very small chunksize will slow down the computation, so try to set it as large as possible with your resources.; As an example, we used chunksize=1000 when processing a dataset with 2 million cells in a machine with 500 GB RAM. For smaller machines, we would recommend to reduce this below 100. Wrapper functions for Pearson residuals preprocessing#; The scanpy.experimental.pp module also ships two wrappers that run multiple pre-processing steps at once:. sc.experimental.pp.normalize_pearson_residuals_pca() performs normalization by Pearson residuals and PCA in one go. This function is helpful to quickly obtain a Pearson residual-based data representation when highly variable genes are already defined, as only those are used by default.; sc.experimental.pp.recipe_pearson_residuals() performs gene selection and normalization by Pearson residuals, and PCA on top. This is intended to make the full Pearson residual preprocessing available in one step. All hyperparameters of the individual steps can still be controlled using the wrapper functions’ arguments. See the documentation for details. References / See also#; Hafemeister & Satija (2019), Normalization and variance stabilization of single-cell RNA-seq data using regularized negative binomial regression, Genome Biology; Lause et al. (2021), Analytic Pearson residuals for normalization of single-cell RNA-seq UMI data, Genome Biology; Wagner (2021",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:29902,wrap,wrappers,29902,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,2,['wrap'],['wrappers']
Integrability,"ntegrate; scanpy.external.pp.mnn_correct; scanpy.external.pp.scanorama_integrate; scanpy.external.pp.hashsolo; scanpy.external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .md. .pdf. Tools: tl. Contents . Embeddings. Clustering and trajectory inference; Data integration; Marker genes; Gene scores, Cell cycle; Simulations. Tools: tl#; Any transformation of the data matrix that is not preprocessing. In contrast to a preprocessing function, a tool usually adds an easily interpretable annotation to the data matrix, which can then be visualized with a corresponding plotting function. Embeddings#. pp.pca; Principal component analysis [Pedregosa et al., 2011]. tl.tsne; t-SNE [Amir et al., 2013, Pedregosa et al., 2011, van der Maaten and Hinton, 2008]. tl.umap; Embed the neighborhood graph using UMAP [McInnes et al., 2018]. tl.draw_graph; Force-directed graph drawing [Chippada, 2018, Islam et al., 2011, Jacomy et al., 2014]. tl.diffmap; Diffusion Maps [Coifman et al., 2005, Haghverdi et al., 2015, Wolf et al., 2018]. Compute densities on embeddings. tl.embedding_density; Calculate the density of cells in an embedding (per condition). Clustering and trajectory inference#. tl.leiden; Cluster cells into subgroups [Traag et al., 2019]. tl.louvain; Cluster cells ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/tools.html:9293,integrat,integration,9293,en/stable/api/tools.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/tools.html,1,['integrat'],['integration']
Integrability,"nts.; Harmony [Korsunsky et al., 2019] is an algorithm for integrating single-cell; data from multiple experiments. This function uses the python; port of Harmony, harmonypy, to integrate single-cell data; stored in an AnnData object. As Harmony works by adjusting the; principal components, this function should be run after performing; PCA but before computing the neighbor graph, as illustrated in the; example below. Parameters:. adata AnnDataThe annotated data matrix. key strThe name of the column in adata.obs that differentiates; among experiments/batches. basis str (default: 'X_pca')The name of the field in adata.obsm where the PCA table is; stored. Defaults to 'X_pca', which is the default for; sc.pp.pca(). adjusted_basis str (default: 'X_pca_harmony')The name of the field in adata.obsm where the adjusted PCA; table will be stored after running this function. Defaults to; X_pca_harmony. kwargsAny additional arguments will be passed to; harmonypy.run_harmony(). Returns:; Updates adata with the field adata.obsm[obsm_out_field],; containing principal components adjusted by Harmony such that; different experiments are integrated. Example; First, load libraries and example dataset, and preprocess.; >>> import scanpy as sc; >>> import scanpy.external as sce; >>> adata = sc.datasets.pbmc3k(); >>> sc.pp.recipe_zheng17(adata); >>> sc.pp.pca(adata). We now arbitrarily assign a batch metadata variable to each cell; for the sake of example, but during real usage there would already; be a column in adata.obs giving the experiment each cell came; from.; >>> adata.obs['batch'] = 1350*['a'] + 1350*['b']. Finally, run harmony. Afterwards, there will be a new table in; adata.obsm containing the adjusted PC’s.; >>> sce.pp.harmony_integrate(adata, 'batch'); >>> 'X_pca_harmony' in adata.obsm; True. previous; scanpy.external.pp.bbknn. next; scanpy.external.pp.mnn_correct. Contents; . harmony_integrate(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.harmony_integrate.html:10679,integrat,integrated,10679,en/stable/generated/scanpy.external.pp.harmony_integrate.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.harmony_integrate.html,1,['integrat'],['integrated']
Integrability,"of principal components to compute. Defaults to 50, or 1 - minimum; dimension size of selected representation. layer str | None (default: None)If provided, which element of layers to use for PCA. zero_center bool | None (default: True)If True, compute standard PCA from covariance matrix.; If False, omit zero-centering variables; (uses scikit-learn TruncatedSVD or; dask-ml TruncatedSVD),; which allows to handle sparse input efficiently.; Passing None decides automatically based on sparseness of the data. svd_solver str | None (default: None)SVD solver to use:. NoneSee chunked and zero_center descriptions to determine which class will be used.; Depending on the class and the type of X different values for default will be set.; If scikit-learn PCA is used, will give 'arpack',; if scikit-learn TruncatedSVD is used, will give 'randomized',; if dask-ml PCA or IncrementalPCA is used, will give 'auto',; if dask-ml TruncatedSVD is used, will give 'tsqr'. 'arpack'for the ARPACK wrapper in SciPy (svds()); Not available with dask arrays. 'randomized'for the randomized algorithm due to Halko (2009). For dask arrays,; this will use svd_compressed(). 'auto'chooses automatically depending on the size of the problem. 'lobpcg'An alternative SciPy solver. Not available with dask arrays. 'tsqr'Only available with dask arrays. “tsqr”; algorithm from Benson et. al. (2013). Changed in version 1.9.3: Default value changed from 'arpack' to None. Changed in version 1.4.5: Default value changed from 'auto' to 'arpack'. Efficient computation of the principal components of a sparse matrix; currently only works with the 'arpack’ or 'lobpcg' solvers.; If X is a dask array, dask-ml classes PCA,; IncrementalPCA, or; TruncatedSVD will be used.; Otherwise their scikit-learn counterparts PCA,; IncrementalPCA, or; TruncatedSVD will be used. random_state Union[int, RandomState, None] (default: 0)Change to use different initial states for the optimization. return_info bool (default: False)Only relevant w",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.pca.html:11189,wrap,wrapper,11189,en/stable/generated/scanpy.pp.pca.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.pca.html,1,['wrap'],['wrapper']
Integrability,"one, the representation is chosen automatically:; For .n_vars < N_PCS (default: 50), .X is used, otherwise ‘X_pca’ is used.; If ‘X_pca’ is not present, it’s computed with default parameters or n_pcs if present. knn bool (default: True)If True, use a hard threshold to restrict the number of neighbors to; n_neighbors, that is, consider a knn graph. Otherwise, use a Gaussian; Kernel to assign low weights to neighbors more distant than the; n_neighbors nearest neighbor. method Literal['umap', 'gauss'] (default: 'umap')Use ‘umap’ [McInnes et al., 2018] or ‘gauss’ (Gauss kernel following Coifman et al. [2005]; with adaptive width Haghverdi et al. [2016]) for computing connectivities. transformer Union[KnnTransformerLike, Literal['pynndescent', 'sklearn', 'rapids'], None] (default: None)Approximate kNN search implementation following the API of; KNeighborsTransformer.; See Using other kNN libraries in Scanpy for more details.; Also accepts the following known options:. None (the default)Behavior depends on data size.; For small data, we will calculate exact kNN, otherwise we use; PyNNDescentTransformer. 'pynndescent'PyNNDescentTransformer. 'rapids'A transformer based on cuml.neighbors.NearestNeighbors. Deprecated since version 1.10.0: Use rapids_singlecell.pp.neighbors() instead. metric Union[Literal['cityblock', 'cosine', 'euclidean', 'l1', 'l2', 'manhattan'], Literal['braycurtis', 'canberra', 'chebyshev', 'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski', 'mahalanobis', 'minkowski', 'rogerstanimoto', 'russellrao', 'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean', 'yule'], Callable[[ndarray, ndarray], float]] (default: 'euclidean')A known metric’s name or a callable that returns a distance.; ignored if ``transformer`` is an instance. metric_kwds Mapping[str, Any] (default: mappingproxy({}))Options for the metric.; ignored if ``transformer`` is an instance. random_state Union[int, RandomState, None] (default: 0)A numpy random seed.; ignored if ``transforme",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pp.neighbors.html:11741,depend,depends,11741,en/stable/api/generated/scanpy.pp.neighbors.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pp.neighbors.html,1,['depend'],['depends']
Integrability,"ot.index.isin(counts.columns)]; counts = counts.rename(columns=dict(zip(annot.index, annot[""ensembl_gene_id""]))); adata_cortex = an.AnnData(counts, obs=meta); sc.pp.normalize_total(adata_cortex, inplace=True); sc.pp.log1p(adata_cortex); adata_cortex.write_h5ad(""data/adata_processed.h5ad""). adata_cortex = sc.read(""./data/adata_processed.h5ad""). adata_spatial_anterior.var.set_index(""gene_ids"", inplace=True); adata_spatial_posterior.var.set_index(""gene_ids"", inplace=True). Subset the spatial anndata to (approximately) selects only spots belonging to the cortex. adata_anterior_subset = adata_spatial_anterior[; adata_spatial_anterior.obsm[""spatial""][:, 1] < 6000, :; ]; adata_posterior_subset = adata_spatial_posterior[; (adata_spatial_posterior.obsm[""spatial""][:, 1] < 4000); & (adata_spatial_posterior.obsm[""spatial""][:, 0] < 6000),; :,; ]. Run integration with Scanorama. adatas_anterior = [adata_cortex, adata_anterior_subset]; adatas_posterior = [adata_cortex, adata_posterior_subset]. # Integration.; adatas_cor_anterior = scanorama.correct_scanpy(adatas_anterior, return_dimred=True); adatas_cor_posterior = scanorama.correct_scanpy(adatas_posterior, return_dimred=True). Found 22689 genes among all datasets; [[0. 0.22877847]; [0. 0. ]]; Processing datasets (0, 1); Found 22689 genes among all datasets; [[0. 0.35810811]; [0. 0. ]]; Processing datasets (0, 1). Concatenate datasets and assign integrated embeddings to anndata objects.; Notice that we are concatenating datasets with the join=""outer"" and uns_merge=""first"" strategies. This is because we want to keep the obsm['coords'] as well as the images of the visium datasets. adata_cortex_anterior = sc.concat(; adatas_cor_anterior,; label=""dataset"",; keys=[""smart-seq"", ""visium""],; join=""outer"",; uns_merge=""first"",; ); adata_cortex_posterior = sc.concat(; adatas_cor_posterior,; label=""dataset"",; keys=[""smart-seq"", ""visium""],; join=""outer"",; uns_merge=""first"",; ). At this step, we have integrated each visium dataset in a common em",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html:22360,Integrat,Integration,22360,en/stable/tutorials/spatial/integration-scanorama.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html,1,['Integrat'],['Integration']
Integrability,"ote; More information and bug reports here. Parameters:. adata AnnDataAnnotated data matrix of shape n_obs × n_vars. Rows correspond to; cells and columns to genes. Rows represent two or more time points,; where replicates of the same time point are consecutive in order. tp strkey name of observation annotation .obs representing time points. Time; points should be categorical of dtype=category. The unique categories for; the categorical will be used as the time points to construct the timepoint; connections. n_neighbors int (default: 30)Number of nearest neighbors for graph construction. n_components int | None (default: 1000)Minimum number of principal components to use. Specify None to use; pre-computed components. The higher the value the better to capture 85% of the; variance. n_jobs int (default: -2)Nearest Neighbors will be computed in parallel using n_jobs. copy bool (default: False)Return a copy instead of writing to adata. Return type:; AnnData | None. Returns:; Depending on copy, returns or updates .obsm, .obsp and .uns with the following:. X_harmony - ndarray (obsm, dtype float)force directed layout. harmony_aff - spmatrix (obsp, dtype float)affinity matrix. harmony_aff_aug - spmatrix (obsp, dtype float)augmented affinity matrix. harmony_timepoint_var - str (uns)The name of the variable passed as tp. harmony_timepoint_connections - ndarray (uns, dtype str)The links between time points. Example; >>> from itertools import product; >>> import pandas as pd; >>> from anndata import AnnData; >>> import scanpy as sc; >>> import scanpy.external as sce. Load AnnData; A sample with real data is available here.; Random data sets of three time points with two replicates each:; >>> adata_ref = sc.datasets.pbmc3k(); >>> start = [596, 615, 1682, 1663, 1409, 1432]; >>> adata = AnnData.concatenate(; ... *(adata_ref[i : i + 1000] for i in start),; ... join=""outer"",; ... batch_key=""sample"",; ... batch_categories=[f""sa{i}_Rep{j}"" for i, j in product((1, 2, 3), (1, 2))],; ...",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.harmony_timeseries.html:11131,Depend,Depending,11131,en/stable/external/generated/scanpy.external.tl.harmony_timeseries.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.harmony_timeseries.html,1,['Depend'],['Depending']
Integrability,"ounts per cell; finished (0:00:00); extracting highly variable genes; finished (0:00:00); --> added; 'highly_variable', boolean vector (adata.var); 'means', float vector (adata.var); 'dispersions', float vector (adata.var); 'dispersions_norm', float vector (adata.var). Data integration#; We are now ready to perform integration of the two dataset. As mentioned before, we will be using Scanorama for that. Scanorama returns two lists, one for the integrated embeddings and one for the corrected counts, for each dataset.; We would like to note that in this context using BBKNN or Ingest is also possible. adatas = [adata_spatial_anterior, adata_spatial_posterior]; adatas_cor = scanorama.correct_scanpy(adatas, return_dimred=True). Found 32285 genes among all datasets; [[0. 0.48882265]; [0. 0. ]]; Processing datasets (0, 1). We will concatenate the two datasets and save the integrated embeddings in adata_spatial.obsm['scanorama_embedding']. Furthermore we will compute UMAP to visualize the results and qualitatively assess the data integration task.; Notice that we are concatenating the two dataset with uns_merge=""unique"" strategy, in order to keep both images from the visium datasets in the concatenated anndata object. adata_spatial = sc.concat(; adatas_cor,; label=""library_id"",; uns_merge=""unique"",; keys=[; k; for d in [; adatas_cor[0].uns[""spatial""],; adatas_cor[1].uns[""spatial""],; ]; for k, v in d.items(); ],; index_unique=""-"",; ). sc.pp.neighbors(adata_spatial, use_rep=""X_scanorama""); sc.tl.umap(adata_spatial); sc.tl.leiden(; adata_spatial, key_added=""clusters"", n_iterations=2, flavor=""igraph"", directed=False; ). computing neighbors; finished: added to `.uns['neighbors']`; `.obsp['distances']`, distances for each pair of neighbors; `.obsp['connectivities']`, weighted adjacency matrix (0:00:02); computing UMAP; finished: added; 'X_umap', UMAP coordinates (adata.obsm) (0:00:06); running Leiden clustering; finished: found 22 clusters and added; 'clusters', the cluster label",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html:16652,integrat,integration,16652,en/stable/tutorials/spatial/integration-scanorama.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html,2,['integrat'],['integration']
Integrability,"p. Code design#. calculate_qc_metrics() is single threaded by default for datasets under 300,000 cells – allowing cached compilation pr615 I Virshup. 1.4.2 2019-05-06#. New functionality#. combat() supports additional covariates which may include adjustment variables or biological condition pr618 G Eraslan; highly_variable_genes() has a batch_key option which performs HVG selection in each batch separately to avoid selecting genes that vary strongly across batches pr622 G Eraslan. Bug fixes#. rank_genes_groups() t-test implementation doesn’t return NaN when variance is 0, also changed to scipy’s implementation pr621 I Virshup; umap() with init_pos='paga' detects correct dtype A Wolf; louvain() and leiden() auto-generate key_added=louvain_R upon passing restrict_to, which was temporarily changed in 1.4.1 A Wolf. Code design#. neighbors() and umap() got rid of UMAP legacy code and introduced UMAP as a dependency pr576 S Rybakov. 1.4.1 2019-04-26#. New functionality#. Scanpy has a command line interface again. Invoking it with scanpy somecommand [args] calls scanpy-somecommand [args], except for builtin commands (currently scanpy settings) pr604 P Angerer; ebi_expression_atlas() allows convenient download of EBI expression atlas I Virshup; marker_gene_overlap() computes overlaps of marker genes M Luecken; filter_rank_genes_groups() filters out genes based on fold change and fraction of cells expressing genes F Ramirez; normalize_total() replaces normalize_per_cell(), is more efficient and provides a parameter to only normalize using a fraction of expressed genes S Rybakov; downsample_counts() has been sped up, changed default value of replace parameter to False pr474 I Virshup; embedding_density() computes densities on embeddings pr543 M Luecken; palantir() interfaces Palantir [Setty et al., 2019] pr493 A Mousa. Code design#. .layers support of scatter plots F Ramirez; fix double-logarithmization in compute of log fold change in rank_genes_groups() A Muñoz-Rojas; fix re",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:43060,interface,interface,43060,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,1,['interface'],['interface']
Integrability,"pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .ipynb. .pdf. Using dask with Scanpy. Using dask with Scanpy#. Warning; 🔪 Beware sharp edges! 🔪; dask support in scanpy is new and highly experimental!; Many functions in scanpy do not support dask and may exhibit unexpected behaviour if dask arrays are passed to them. Stick to what’s outlined in this tutorial and you should be fine!; Please report any issues you run into over on the issue tracker. dask is a popular out-of-core, distributed array processing library that scanpy is beginning to support. Here we walk through a quick tutorial of using dask in a simple analysis task.; This notebook relies on optional dependencies in dask and sklearn_ann and annoy. Install them with:; pip install -U ""dask[array,distributed,diagnostics]"" sklearn_ann annoy. from pathlib import Path. import numpy as np; import dask.distributed as dd; import scanpy as sc; import anndata as ad; import h5py. sc.logging.print_header(). scanpy==1.10.0rc2.dev103+gc6766d75 anndata==0.11.0.dev157+ge0b81f1.d20240812 umap==0.5.6 numpy==2.0.1 scipy==1.14.0 pandas==2.2.2 scikit-learn==1.5.1 statsmodels==0.14.2 igraph==0.11.6 pynndescent==0.5.13. Here, we’ll be working with a moderately large dataset of 1.4 million cells taken from: COVID-19 immune features revealed by a large-scale single-cell transcriptome atlas. if not Path(""cell_atlas.h5ad"").exists():; !wget https://datasets.cellxgene.cziscience.com/82eac9c1-485f-4e21-ab21-8510823d4f6e.h5ad -O ""cell_atlas.h5ad"". For more information on using distributed computing via dask, please see their documentation. In short, one needs to define both a cluster and a client to have some degree of",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/dask.html:9839,depend,dependencies,9839,en/stable/tutorials/experimental/dask.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/dask.html,2,['depend'],['dependencies']
Integrability,"previously, note that there are more sensible alternatives for normalization (see discussion in sc-tutorial paper and more recent alternatives such as SCTransform or GLM-PCA). for adata in [; adata_spatial_anterior,; adata_spatial_posterior,; ]:; sc.pp.normalize_total(adata, inplace=True); sc.pp.log1p(adata); sc.pp.highly_variable_genes(adata, flavor=""seurat"", n_top_genes=2000, inplace=True). normalizing counts per cell; finished (0:00:00); extracting highly variable genes; finished (0:00:00); --> added; 'highly_variable', boolean vector (adata.var); 'means', float vector (adata.var); 'dispersions', float vector (adata.var); 'dispersions_norm', float vector (adata.var); normalizing counts per cell; finished (0:00:00); extracting highly variable genes; finished (0:00:00); --> added; 'highly_variable', boolean vector (adata.var); 'means', float vector (adata.var); 'dispersions', float vector (adata.var); 'dispersions_norm', float vector (adata.var). Data integration#; We are now ready to perform integration of the two dataset. As mentioned before, we will be using Scanorama for that. Scanorama returns two lists, one for the integrated embeddings and one for the corrected counts, for each dataset.; We would like to note that in this context using BBKNN or Ingest is also possible. adatas = [adata_spatial_anterior, adata_spatial_posterior]; adatas_cor = scanorama.correct_scanpy(adatas, return_dimred=True). Found 32285 genes among all datasets; [[0. 0.48882265]; [0. 0. ]]; Processing datasets (0, 1). We will concatenate the two datasets and save the integrated embeddings in adata_spatial.obsm['scanorama_embedding']. Furthermore we will compute UMAP to visualize the results and qualitatively assess the data integration task.; Notice that we are concatenating the two dataset with uns_merge=""unique"" strategy, in order to keep both images from the visium datasets in the concatenated anndata object. adata_spatial = sc.concat(; adatas_cor,; label=""library_id"",; uns_merge=""unique",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html:15889,integrat,integration,15889,en/stable/tutorials/spatial/integration-scanorama.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html,4,['integrat'],['integration']
Integrability,"py.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .ipynb. .pdf. Integrating data using ingest and BBKNN. Contents . PBMCs; Mapping PBMCs using ingest; Using BBKNN. Pancreas; Seeing the batch effect; BBKNN; Mapping onto a reference batch using ingest; Evaluating consistency; Cell types conserved across batches; All cell types. Visualizing distributions across batches; Density plot; Partial visualizaton of a subset of groups in embedding. Integrating data using ingest and BBKNN#; The following tutorial describes a simple PCA-based method for integrating data we call ingest and compares it with BBKNN [Polanski19]. BBKNN integrates well with the Scanpy workflow and is accessible through the bbknn function.; The ingest function assumes an annotated reference dataset that captures the biological variability of interest. The rational is to fit a model on the reference data and use it to project new data. For the time being, this model is a PCA combined with a neighbor lookup search tree, for which we use UMAP’s implementation [McInnes18]. Similar PCA-based integrations have been used before, for instance, in [Weinreb18]. As ingest is simple and the procedure clear, the workflow is transparent and fast.; Like BBKNN, ingest leaves the data matrix itself invariant.; Unlike BBKNN, ingest solves the label mapping problem (like scmap) and maintains an embedding that might have desired properties like specific clusters or trajectories. We refer to this asymmetric dataset integration as ingesting annotations from an annotated reference adata_ref into an adata that still lacks this annotation. It is different from learning a joint representation that in",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/integrating-data-using-ingest.html:9811,integrat,integrates,9811,en/stable/tutorials/basics/integrating-data-using-ingest.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/integrating-data-using-ingest.html,2,['integrat'],['integrates']
Integrability,"r to only normalize using a fraction of expressed genes S Rybakov; downsample_counts() has been sped up, changed default value of replace parameter to False pr474 I Virshup; embedding_density() computes densities on embeddings pr543 M Luecken; palantir() interfaces Palantir [Setty et al., 2019] pr493 A Mousa. Code design#. .layers support of scatter plots F Ramirez; fix double-logarithmization in compute of log fold change in rank_genes_groups() A Muñoz-Rojas; fix return sections of docs P Angerer. Version 1.3#. 1.3.8 2019-02-05#. various documentation and dev process improvements; Added combat() function for batch effect correction [Johnson et al., 2006, Leek et al., 2017, Pedersen, 2012] pr398 M Lange. 1.3.7 2019-01-02#. API changed from import scanpy as sc to import scanpy.api as sc.; phenograph() wraps the graph clustering package Phenograph [Levine et al., 2015] thanks to A Mousa. 1.3.6 2018-12-11#. Major updates#. a new plotting gallery for visualizing-marker-genes F Ramirez; tutorials are integrated on ReadTheDocs, pbmc3k and paga-paul15 A Wolf. Interactive exploration of analysis results through manifold viewers#. CZI’s cellxgene directly reads .h5ad files the cellxgene developers; the UCSC Single Cell Browser requires exporting via cellbrowser() M Haeussler. Code design#. highly_variable_genes() supersedes filter_genes_dispersion(), it gives the same results but, by default, expects logarithmized data and doesn’t subset A Wolf. 1.3.5 2018-12-09#. uncountable figure improvements pr369 F Ramirez. 1.3.4 2018-11-24#. leiden() wraps the recent graph clustering package by Traag et al. [2019] K Polanski; bbknn() wraps the recent batch correction package [Polański et al., 2019] K Polanski; calculate_qc_metrics() caculates a number of quality control metrics, similar to calculateQCMetrics from Scater [McCarthy et al., 2017] I Virshup. 1.3.3 2018-11-05#. Major updates#. a fully distributed preprocessing backend T White and the Laserson Lab. Code design#. read_10x_h5()",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:44595,integrat,integrated,44595,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,1,['integrat'],['integrated']
Integrability,"ression plotting. pr1529 F Ramirez. See rank_genes_groups_dotplot() or rank_genes_groups_matrixplot() for examples. Bug fixes#. Fix scanpy.pl.paga_path() TypeError with recent versions of anndata pr1047 P Angerer; Fix detection of whether IPython is running pr1844 I Virshup; Fixed reproducibility of scanpy.tl.diffmap() (added random_state) pr1858 I Kucinski; Fixed errors and warnings from embedding plots with small numbers of categories after sns.set_palette was called pr1886 I Virshup; Fixed handling of gene_symbols argument in a number of sc.pl.rank_genes_groups* functions pr1529 F Ramirez I Virshup; Fixed handling of use_raw for sc.tl.rank_genes_groups when no .raw is present pr1895 I Virshup; scanpy.pl.rank_genes_groups_violin() now works for raw=False pr1669 M van den Beek; scanpy.pl.dotplot() now uses smallest_dot argument correctly pr1771 S Flemming. Development Process#. Switched to flit for building and deploying the package, a simple tool with an easy to understand command line interface and metadata pr1527 P Angerer; Use pre-commit for style checks pr1684 pr1848 L Heumos I Virshup. Deprecations#. Dropped support for Python 3.6. More details here. pr1897 I Virshup; Deprecated layers and layers_norm kwargs to normalize_total() pr1667 I Virshup; Deprecated MulticoreTSNE backend for scanpy.tl.tsne() pr1854 I Virshup. Version 1.7#. 1.7.2 2021-04-07#. Bug fixes#. scanpy.logging.print_versions() now works when python<3.8 pr1691 I Virshup; scanpy.pp.regress_out() now uses joblib as the parallel backend, and should stop oversubscribing threads pr1694 I Virshup; scanpy.pp.highly_variable_genes() with flavor=""seurat_v3"" now returns correct gene means and -variances when used with batch_key pr1732 J Lause; scanpy.pp.highly_variable_genes() now throws a warning instead of an error when non-integer values are passed for method ""seurat_v3"". The check can be skipped by passing check_values=False. pr1679 G Palla. Ecosystem#. Added triku a feature selection method to the e",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:28743,interface,interface,28743,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,1,['interface'],['interface']
Integrability,"rformance#; It’s more important that you’re accurately testing the code works than it is that test suite runs quickly.; That said, it’s nice when the test suite runs fast.; You can check how long tests take to run by passing --durations=0 argument to pytest.; Hopefully your new tests won’t show up on top!; Some approaches to this include:. Is there a common setup/ computation happening in each test? Consider caching these in a scoped test fixture.; Is the behaviour you’re testing for dependent on the size of the data? If not, consider reducing it. Plotting tests#; While computational functions will return arrays and values, it can be harder to work with the output of plotting functions.; To make this easier, we use the image_comparer fixture for comparing plotting results (search the test suite for example usage).; This is used to check that generated plots look the same as they did previously.; Reference images (the expected output) are stored as expected.png to relevant tests directory under scanpy/tests/_images.; When run, the test suite will generate actual.png files for each check.; These files are compared, and if the actual plot differs from the reference plot, a diff of the images is also generated.; Paths for all these files will be reported when a test fails, and images for failed plots can be viewed via the :doc:CI interface <ci>.; A common gotcha here is that plots often change slightly on different machines/ OSs.; scanpy’s test suite sets a number of environment variables to ensure as similar of plots as possible.; When adding new reference plots, the recommended workflow is to write the test as though an expected result already exists, run it once to generate the output, then move that output to the reference directory. previous; Getting set up. next; Documentation. Contents; . Running the tests; Miscellaneous tips. Writing tests; What to test; Performance; Plotting tests. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/dev/testing.html:13068,interface,interface,13068,en/stable/dev/testing.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/dev/testing.html,1,['interface'],['interface']
Integrability,"rnal.pp.mnn_correct; scanpy.external.pp.scanorama_integrate; scanpy.external.pp.hashsolo; scanpy.external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .md. .pdf. API. API#; Import Scanpy as:; import scanpy as sc. Note; Additional functionality is available in the broader ecosystem, with some tools being wrapped in the scanpy.external module. Preprocessing: pp; Basic Preprocessing; Recipes; Batch effect correction; Doublet detection; Neighbors. Tools: tl; Embeddings; Clustering and trajectory inference; Data integration; Marker genes; Gene scores, Cell cycle; Simulations. Plotting: pl; Generic; Classes; Preprocessing; Tools. Reading; scanpy.read; scanpy.read_10x_h5; scanpy.read_10x_mtx; scanpy.read_visium; scanpy.read_h5ad; scanpy.read_csv; scanpy.read_excel; scanpy.read_hdf; scanpy.read_loom; scanpy.read_mtx; scanpy.read_text; scanpy.read_umi_tools. Get object from AnnData: get; scanpy.get.obs_df; scanpy.get.var_df; scanpy.get.rank_genes_groups_df; scanpy.get.aggregate. Queries; scanpy.queries.biomart_annotations; scanpy.queries.gene_coordinates; scanpy.queries.mitochondrial_genes; scanpy.queries.enrich. Metrics; scanpy.metrics.confusion_matrix; scanpy.metrics.gearys_c; scanpy.metrics.morans_i. Experimental; scanpy.experimental.pp.normalize_pearson_r",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/index.html:9354,wrap,wrapped,9354,en/stable/api/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/index.html,1,['wrap'],['wrapped']
Integrability,"rown.; Can you place bounds on the values returned by your function?; Are there different input values which should generate equivalent output (e.g. if an array is sparse or dense)?; Do you have arguments which should have orthogonal effects on the output? Check that they are independent. For example, if there is a flag for extended output, the base output should remain the same either way.; Are you optimizing a method? Check that it’s results are the same as a gold standard implementation. Performance#; It’s more important that you’re accurately testing the code works than it is that test suite runs quickly.; That said, it’s nice when the test suite runs fast.; You can check how long tests take to run by passing --durations=0 argument to pytest.; Hopefully your new tests won’t show up on top!; Some approaches to this include:. Is there a common setup/ computation happening in each test? Consider caching these in a scoped test fixture.; Is the behaviour you’re testing for dependent on the size of the data? If not, consider reducing it. Plotting tests#; While computational functions will return arrays and values, it can be harder to work with the output of plotting functions.; To make this easier, we use the image_comparer fixture for comparing plotting results (search the test suite for example usage).; This is used to check that generated plots look the same as they did previously.; Reference images (the expected output) are stored as expected.png to relevant tests directory under scanpy/tests/_images.; When run, the test suite will generate actual.png files for each check.; These files are compared, and if the actual plot differs from the reference plot, a diff of the images is also generated.; Paths for all these files will be reported when a test fails, and images for failed plots can be viewed via the :doc:CI interface <ci>.; A common gotcha here is that plots often change slightly on different machines/ OSs.; scanpy’s test suite sets a number of environment va",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/dev/testing.html:12209,depend,dependent,12209,en/stable/dev/testing.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/dev/testing.html,1,['depend'],['dependent']
Integrability,"rray(cdata).max(); sm = ScalarMappable(norm=Normalize(vmin=vmin, vmax=vmax), cmap=""Blues""). sv = ma.ZeroHeightCluster(agg_exp.T, width=3); sv_anno = ma.ZeroHeight(width=1). for gene_name, pdata in gene_data:; # Calculate the color to display; palette = sm.to_rgba(pdata.median()).tolist(); sv.add_bottom(; mp.Violin(; pdata,; inner=None,; linecolor="".7"",; linewidth=0.5,; density_norm=""width"",; palette=palette,; ),; size=0.5,; pad=0.1,; legend=False,; ); sv_anno.add_bottom(mp.Title(gene_name, align=""left""), size=0.5, pad=0.1). sv.add_bottom(mp.Labels(cdata.columns)); sv.add_dendrogram(""top""). # To fake a legend; sv.add_bottom(; mp.ColorMesh(; cdata,; cmap=""Blues"",; cbar_kws={""title"": ""Median expression\nin group"", ""orientation"": ""horizontal""},; ),; size=0,; ); comp = sv + 0.1 + sv_anno; comp.add_legends(); comp.render(). More information#; Other plots are possible with Marsilea by creating new plotter. See Marsilea’s documention to learn how. import session_info. session_info.show(dependencies=True). Click to view session information. -----; anndata 0.10.6; marsilea 0.3.5; matplotlib 3.8.3; numpy 1.26.4; pandas 2.2.0; scanpy 1.10.1; session_info 1.0.0; -----. Click to view modules imported as dependencies. PIL 10.2.0; anyio NA; appnope 0.1.3; arrow 1.3.0; asttokens NA; attr 23.2.0; attrs 23.2.0; babel 2.14.0; certifi 2024.02.02; cffi 1.16.0; charset_normalizer 3.3.2; colorama 0.4.6; comm 0.2.1; cycler 0.12.1; cython_runtime NA; dateutil 2.8.2; debugpy 1.8.0; decorator 5.1.1; defusedxml 0.7.1; exceptiongroup 1.2.0; executing 2.0.1; fastjsonschema NA; fqdn NA; h5py 3.10.0; idna 3.6; ipykernel 6.29.0; isoduration NA; jedi 0.19.1; jinja2 3.1.3; joblib 1.3.2; json5 NA; jsonpointer 2.4; jsonschema 4.21.1; jsonschema_specifications NA; jupyter_events 0.9.0; jupyter_server 2.12.5; jupyterlab_server 2.25.2; kiwisolver 1.4.5; legacy_api_wrap NA; legendkit 0.3.4; llvmlite 0.42.0; markupsafe 2.1.5; matplotlib_inline 0.1.6; mpl_toolkits NA; natsort 8.4.0; nbformat 5.9.2; numba 0.59",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/how-to/plotting-with-marsilea.html:17173,depend,dependencies,17173,en/stable/how-to/plotting-with-marsilea.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/how-to/plotting-with-marsilea.html,1,['depend'],['dependencies']
Integrability,"rsion requirement of scipy to scipy>1.4 to support rmatmat argument of LinearOperator issue1246 I Virshup; Fix asymmetry of scores for the 'wilcoxon' method in rank_genes_groups() issue754 S Rybakov; Avoid trimming of gene names in rank_genes_groups() issue753 S Rybakov. Version 1.5#. 1.5.1 2020-05-21#. Bug fixes#. Fixed a bug in pca(), where random_state did not have an effect for sparse input pr1240 I Virshup; Fixed docstring in pca() which included an unused argument pr1240 I Virshup. 1.5.0 2020-05-15#; The 1.5.0 release adds a lot of new functionality, much of which takes advantage of anndata updates 0.7.0 - 0.7.2. Highlights of this release include support for spatial data, dedicated handling of graphs in AnnData, sparse PCA, an interface with scvi, and others. Spatial data support#. Basic analysis Analysis and visualization of spatial transcriptomics data and integration with single cell data Integrating spatial data with scRNA-seq using scanorama G Palla; read_visium() read 10x Visium data pr1034 G Palla, P Angerer, I Virshup; visium_sge() load Visium data directly from 10x Genomics pr1013 M Mirkazemi, G Palla, P Angerer; spatial() plot spatial data pr1012 G Palla, P Angerer. New functionality#. Many functions, like neighbors() and umap(), now store cell-by-cell graphs in obsp pr1118 S Rybakov; scale() and log1p() can be used on any element in layers or obsm pr1173 I Virshup. External tools#. scanpy.external.pp.scvi for preprocessing with scVI pr1085 G Xing; Guide for using Scanpy in R pr1186 L Zappia. Performance#. pca() now uses efficient implicit centering for sparse matrices. This can lead to signifigantly improved performance for large datasets pr1066 A Tarashansky; score_genes() now has an efficient implementation for sparse matrices with missing values pr1196 redst4r. Warning; The new pca() implementation can result in slightly different results for sparse matrices. See the pr (pr1066) and documentation for more info. Code design#. stacked_violin() can",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:37861,integrat,integration,37861,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,1,['integrat'],['integration']
Integrability,"s . tracksplot(). scanpy.pl.tracksplot#. scanpy.pl.tracksplot(adata, var_names, groupby, *, use_raw=None, log=False, dendrogram=False, gene_symbols=None, var_group_positions=None, var_group_labels=None, layer=None, show=None, save=None, figsize=None, **kwds)[source]#; In this type of plot each var_name is plotted as a filled line plot where the; y values correspond to the var_name values and x is each of the cells. Best results; are obtained when using raw counts that are not log.; groupby is required to sort and order the values using the respective group; and should be a categorical value. Parameters:. adata AnnDataAnnotated data matrix. var_names Union[str, Sequence[str], Mapping[str, Union[str, Sequence[str]]]]var_names should be a valid subset of adata.var_names.; If var_names is a mapping, then the key is used as label; to group the values (see var_group_labels). The mapping values; should be sequences of valid adata.var_names. In this; case either coloring or ‘brackets’ are used for the grouping; of var names depending on the plot. When var_names is a mapping,; then the var_group_labels and var_group_positions are set. groupby str | Sequence[str]The key of the observation grouping to consider. use_raw bool | None (default: None)Use raw attribute of adata if present. log bool (default: False)Plot on logarithmic axis. num_categoriesOnly used if groupby observation is not categorical. This value; determines the number of groups into which the groupby observation; should be subdivided. categories_orderOrder in which to show the categories. Note: add_dendrogram or add_totals; can change the categories order. figsize tuple[float, float] | None (default: None)Figure size when multi_panel=True.; Otherwise the rcParam['figure.figsize] value is used.; Format is (width, height). dendrogram bool | str (default: False)If True or a valid dendrogram key, a dendrogram based on the hierarchical; clustering between the groupby categories is added.; The dendrogram information is",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pl.tracksplot.html:10290,depend,depending,10290,en/stable/generated/scanpy.pl.tracksplot.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pl.tracksplot.html,1,['depend'],['depending']
Integrability,"s enough.; See below for how to use Scanpy’s Development Version.; If you prefer to exclusively use PyPI run:; $ pip install 'scanpy[leiden]'. After installing installing e.g. Miniconda, run:; $ conda install -c conda-forge scanpy python-igraph leidenalg. Pull Scanpy from PyPI (consider using pip3 to access Python 3):; $ pip install scanpy. If you use Hatch or pip, the extra [leiden] installs two packages that are needed for popular; parts of scanpy but aren’t requirements: igraph [Csárdi and Nepusz, 2006] and leiden [Traag et al., 2019].; If you use conda, you should to add these dependencies to your environment individually. Development Version#; To work with the latest version on GitHub: clone the repository and cd into its root directory.; $ gh repo clone scverse/scanpy; $ cd scanpy. Hatch (recommended)Pip/PyPICondaTo use one of the predefined Hatch environments in hatch.toml,; run either hatch test [args] or hatch run [env:]command [...args], e.g.:; $ hatch test -p # run tests in parallel; $ hatch run docs:build # build docs; $ hatch run towncrier:create # create changelog entry. If you are using pip>=21.3, an editable install can be made:; $ python -m venv .venv; $ source .venv/bin/activate; $ pip install -e '.[dev,test]'. If you want to let conda handle the installations of dependencies, do:; $ pipx install beni; $ beni pyproject.toml > environment.yml; $ conda env create -f environment.yml; $ conda activate scanpy; $ pip install -e '.[dev,doc,test]'. For instructions on how to work with the code, see the contribution guide. Docker#; If you’re using Docker, you can use e.g. the image gcfntnu/scanpy from Docker Hub. Troubleshooting#; If you get a Permission denied error, never use sudo pip. Instead, use virtual environments or:; $ pip install --user scanpy. previous; Scanpy – Single-Cell Analysis in Python. next; Tutorials. Contents; . Development Version; Docker; Troubleshooting. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/installation.html:10774,depend,dependencies,10774,en/stable/installation.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/installation.html,1,['depend'],['dependencies']
Integrability,"s neighborhoods to be calculated in; log(n_samples) time. knn_dist str (default: 'euclidean')recommended values: ‘euclidean’ and ‘cosine’; Any metric from scipy.spatial.distance can be used; distance metric for building kNN graph. mds_dist str (default: 'euclidean')recommended values: ‘euclidean’ and ‘cosine’; Any metric from scipy.spatial.distance can be used; distance metric for MDS. mds Literal['classic', 'metric', 'nonmetric'] (default: 'metric')Selects which MDS algorithm is used for dimensionality reduction. n_jobs int | None (default: None)The number of jobs to use for the computation.; If None, sc.settings.n_jobs is used.; If -1 all CPUs are used. If 1 is given, no parallel computing code is; used at all, which is useful for debugging.; For n_jobs below -1, (n_cpus + 1 + n_jobs) are used. Thus for; n_jobs = -2, all CPUs but one are used. random_state Union[int, RandomState, None] (default: None)Random seed. Defaults to the global numpy random number generator. verbose bool | int | None (default: None)If True or an int/Verbosity ≥ 2/hint, print status messages.; If None, sc.settings.verbosity is used. copy bool (default: False)Return a copy instead of writing to adata. kwargsAdditional arguments to phate.PHATE. Return type:; AnnData | None. Returns:; Depending on copy, returns or updates adata with the following fields. X_phatenp.ndarray, (adata.obs, shape=[n_samples, n_components], dtype float)PHATE coordinates of data. Examples; >>> from anndata import AnnData; >>> import scanpy.external as sce; >>> import phate; >>> tree_data, tree_clusters = phate.tree.gen_dla(; ... n_dim=100,; ... n_branch=20,; ... branch_length=100,; ... ); >>> tree_data.shape; (2000, 100); >>> adata = AnnData(tree_data); >>> sce.tl.phate(adata, k=5, a=20, t=150); >>> adata.obsm['X_phate'].shape; (2000, 2); >>> sce.pl.phate(adata). previous; Tools: TL. next; scanpy.external.tl.palantir. Contents; . phate(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.phate.html:11965,message,messages,11965,en/stable/external/generated/scanpy.external.tl.phate.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.phate.html,3,"['Depend', 'message']","['Depending', 'messages']"
Integrability,"s_df() can now return fraction of cells in a group expressing a gene, and allows retrieving values for multiple groups at once pr1388 G Eraslan; Color annotations for gene sets in heatmap() are now matched to color for cluster pr1511 L Sikkema; PCA plots can now annotate axes with variance explained pr1470 bfurtwa; Plots with groupby arguments can now group by values in the index by passing the index’s name (like pd.DataFrame.groupby). pr1583 F Ramirez; Added na_color and na_in_legend keyword arguments to embedding() plots. Allows specifying color for missing or filtered values in plots like umap() or spatial() pr1356 I Virshup; embedding() plots now support passing dict of {cluster_name: cluster_color, ...} for palette argument pr1392 I Virshup. External tools (new)#. Add Scanorama integration to scanpy external API (scanorama_integrate(), Hie et al. [2019]) pr1332 B Hie; Scrublet [Wolock et al., 2019] integration: scrublet(), scrublet_simulate_doublets(), and plotting method scrublet_score_distribution() pr1476 J Manning; hashsolo() for HTO demultiplexing [Bernstein et al., 2020] pr1432 NJ Bernstein; Added scirpy (sc-AIRR analysis) to ecosystem page pr1453 G Sturm; Added scvi-tools to ecosystem page pr1421 A Gayoso. External tools (changes)#. Updates for palantir() and palantir_results() pr1245 A Mousa; Fixes to harmony_timeseries() docs pr1248 A Mousa; Support for leiden clustering by scanpy.external.tl.phenograph() pr1080 A Mousa; Deprecate scanpy.external.pp.scvi pr1554 G Xing; Updated default params of sam() to work with larger data pr1540 A Tarashansky. Documentation#. New contribution guide pr1544 I Virshup; zsh installation instructions pr1444 P Angerer. Performance#. Speed up read_10x_h5() pr1402 P Weiler; Speed ups for obs_df() pr1499 F Ramirez. Bugfixes#. Consistent fold-change, fractions calculation for filter_rank_genes_groups pr1391 S Rybakov; Fixed bug where score_genes would error if one gene was passed pr1398 I Virshup; Fixed log1p inplace on integ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:31660,integrat,integration,31660,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,1,['integrat'],['integration']
Integrability,"scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .ipynb. .pdf. Integrating spatial data with scRNA-seq using scanorama. Contents . Loading libraries; Reading the data; Data integration; Data integration and label transfer from scRNA-seq dataset. Integrating spatial data with scRNA-seq using scanorama#; Author: Giovanni Palla. Note; For up-to-date analysis tutorials, kindly check out SquidPy tutorials. This tutorial shows how to work with multiple Visium datasets and perform integration of scRNA-seq dataset with Scanpy. It follows the previous tutorial on analysis and visualization of spatial transcriptomics data.; We will use Scanorama paper - code to perform integration and label transfer. It has a convenient interface with scanpy and anndata.; To install the required libraries, type the following:; pip install git+https://github.com/theislab/scanpy.git; pip install git+https://github.com/theislab/anndata.git; pip install scanorama. Loading libraries#. import scanpy as sc; import anndata as an; import pandas as pd; import numpy as np; import matplotlib.pyplot as plt; import seaborn as sns; import scanorama. from pathlib import Path. sc.logging.print_versions(); sc.set_figure_params(facecolor=""white"", figsize=(8, 8)); sc.settings.verbosity = 3. -----; anndata 0.11.0.dev78+g64ab900; scanpy 1.10.0rc2.dev6+g14555ba4; -----; PIL 10.2.0; annoy NA; anyio NA; appnope 0.1.3; arrow 1.3.0; asciitree NA; asttokens NA; attr 23.2.0; attrs 23.2.0; babel 2.14.0; certifi 2023.11.17; cffi 1.16.0; charset_normalizer 3.3.2; cloudpickle 3.0.0; comm 0.2.1; cycler 0.12.1; cython_runtime NA; dask 2024.1.0; dateutil 2.8.2; debugpy 1.8.0; decorator 5.1.1; d",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html:9872,integrat,integration,9872,en/stable/tutorials/spatial/integration-scanorama.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html,2,['integrat'],['integration']
Integrability,"scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.external.pp.scanorama_integrate. Contents . scanorama_integrate(). scanpy.external.pp.scanorama_integrate#. scanpy.external.pp.scanorama_integrate(adata, key, *, basis='X_pca', adjusted_basis='X_scanorama', knn=20, sigma=15, approx=True, alpha=0.1, batch_size=5000, **kwargs)[source]#; Use Scanorama [Hie et al., 2019] to integrate different experiments.; Scanorama [Hie et al., 2019] is an algorithm for integrating single-cell; data from multiple experiments stored in an AnnData object. This; function should be run after performing PCA but before computing; the neighbor graph, as illustrated in the example below.; This uses the implementation of scanorama [Hie et al., 2019]. Parameters:. adata AnnDataThe annotated data matrix. key strThe name of the column in adata.obs that differentiates; among experiments/batches. Cells from the same batch must be; contiguously stored in adata. basis str (default: 'X_pca')The name of the field in adata.obsm where the PCA table is; stored. Defaults to 'X_pca', which is the default for; sc.pp.pca(). adjusted_basis str (default: 'X_scanorama')The name of the field in adata.obsm where the integrated; embeddings will be stored after running this function. Defaults; to X_scanorama. knn int (default: 20)Number of nearest neighbors to use for matching. sigma float (default: 15)Correctio",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.scanorama_integrate.html:9576,integrat,integrate,9576,en/stable/generated/scanpy.external.pp.scanorama_integrate.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.scanorama_integrate.html,1,['integrat'],['integrate']
Integrability,"se_approx_neighbors = True in scrublet() pr2896S Dicks; Compatibility with scipy 1.13 pr2943 I Virshup; Fix use of dendrogram() on highly correlated low precision data pr2928 P Angerer; Fix pytest deprecation warning pr2879 P Angerer. Development Process#. Scanpy is now tested against python 3.12 pr2863 ivirshup; Fix testing package build pr2468 P Angerer. Deprecations#. Dropped support for Python 3.8. More details here. pr2695 P Angerer; Deprecated specifying large numbers of function parameters by position as opposed to by name/keyword in all public APIs.; e.g. prefer sc.tl.umap(adata, min_dist=0.1, spread=0.8) over sc.tl.umap(adata, 0.1, 0.8) pr2702 P Angerer; Dropped support for umap<0.5 for performance reasons. pr2870 P Angerer. Version 1.9#. 1.9.8 2024-01-26#. Bug fixes#. Fix handling of numpy array palettes for old numpy versions pr2832 P Angerer. 1.9.7 2024-01-25#. Bug fixes#. Fix handling of numpy array palettes (e.g. after write-read cycle) pr2734 P Angerer; Specify correct version of matplotlib dependency pr2733 P Fisher; Fix scanpy.pl.violin() usage of seaborn.catplot pr2739 E Roellin; Fix scanpy.pp.highly_variable_genes() to handle the combinations of inplace and subset consistently pr2757 E Roellin; Replace usage of various deprecated functionality from anndata and pandas pr2678 pr2779 P Angerer; Allow to use default n_top_genes when using scanpy.pp.highly_variable_genes() flavor 'seurat_v3' pr2782 P Angerer; Fix scanpy.read_10x_mtx()’s gex_only=True mode pr2801 P Angerer. 1.9.6 2023-10-31#. Bug fixes#. Allow scanpy.pl.scatter() to accept a str palette name pr2571 P Angerer; Make scanpy.external.tl.palantir() compatible with palantir >=1.3 pr2672 DJ Otto; Fix scanpy.pl.pca() when return_fig=True and annotate_var_explained=True pr2682 J Wagner; Temp fix for issue2680 by skipping seaborn version 0.13.0 pr2661 P Angerer; Fix scanpy.pp.highly_variable_genes() to not modify the used layer when flavor=seurat pr2698 E Roellin; Prevent pandas from causing infi",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:19619,depend,dependency,19619,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,1,['depend'],['dependency']
Integrability,"seq. Genome Research, 21(7):1160–1167, may 2011. URL: https://doi.org/10.1101/gr.110882.110, doi:10.1101/gr.110882.110. [JVHB14]; Mathieu Jacomy, Tommaso Venturini, Sebastien Heymann, and Mathieu Bastian. Forceatlas2, a continuous graph layout algorithm for handy network visualization designed for the gephi software. PLoS ONE, 9(6):e98679, jun 2014. URL: https://doi.org/10.1371/journal.pone.0098679, doi:10.1371/journal.pone.0098679. [JLR06]; W. Evan Johnson, Cheng Li, and Ariel Rabinovic. Adjusting batch effects in microarray expression data using empirical bayes methods. Biostatistics, 8(1):118–127, apr 2006. URL: https://doi.org/10.1093/biostatistics/kxj037, doi:10.1093/biostatistics/kxj037. [Kan18]; Chris Kang. Mnnpy - mnn-correct in python. chriscainx/mnnpy, 2018. URL: chriscainx/mnnpy. [KMF+19]; Ilya Korsunsky, Nghia Millard, Jean Fan, Kamil Slowikowski, Fan Zhang, Kevin Wei, Yuriy Baglaenko, Michael Brenner, Po-ru Loh, and Soumya Raychaudhuri. Fast, sensitive and accurate integration of single-cell data with harmony. Nature Methods, 16(12):1289–1296, nov 2019. URL: https://doi.org/10.1038/s41592-019-0619-0, doi:10.1038/s41592-019-0619-0. [KMST11]; Jan Krumsiek, Carsten Marr, Timm Schroeder, and Fabian J. Theis. Hierarchical differentiation of myeloid progenitors is encoded in the transcription factor network. PLoS ONE, 6(8):e22649, aug 2011. URL: https://doi.org/10.1371/journal.pone.0022649, doi:10.1371/journal.pone.0022649. [LMSZ+18]; Gioele La Manno, Ruslan Soldatov, Amit Zeisel, Emelie Braun, Hannah Hochgerner, Viktor Petukhov, Katja Lidschreiber, Maria E. Kastriti, Peter Lönnerberg, Alessandro Furlan, Jean Fan, Lars E. Borm, Zehua Liu, David van Bruggen, Jimin Guo, Xiaoling He, Roger Barker, Erik Sundström, Gonçalo Castelo-Branco, Patrick Cramer, Igor Adameyko, Sten Linnarsson, and Peter V. Kharchenko. Rna velocity of single cells. Nature, 560(7719):494–498, aug 2018. URL: https://doi.org/10.1038/s41586-018-0414-6, doi:10.1038/s41586-018-0414-6. [LDB14]; Re",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/references.html:15693,integrat,integration,15693,en/stable/references.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/references.html,1,['integrat'],['integration']
Integrability,"sets.blobs; scanpy.datasets.ebi_expression_atlas; scanpy.datasets.krumsiek11; scanpy.datasets.moignard15; scanpy.datasets.pbmc3k; scanpy.datasets.pbmc3k_processed; scanpy.datasets.pbmc68k_reduced; scanpy.datasets.paul15; scanpy.datasets.toggleswitch; scanpy.datasets.visium_sge. Deprecated functions; scanpy.pp.filter_genes_dispersion; scanpy.pp.normalize_per_cell. External API; Preprocessing: PP; scanpy.external.pp.bbknn; scanpy.external.pp.harmony_integrate; scanpy.external.pp.mnn_correct; scanpy.external.pp.scanorama_integrate; scanpy.external.pp.hashsolo; scanpy.external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy._settings.ScanpyConfig.verbosity. Contents . ScanpyConfig.verbosity. scanpy._settings.ScanpyConfig.verbosity#. property ScanpyConfig.verbosity: Verbosity[source]#; Verbosity level (default warning); Level 0: only show ‘error’ messages.; Level 1: also show ‘warning’ messages.; Level 2: also show ‘info’ messages.; Level 3: also show ‘hint’ messages.; Level 4: also show very detailed progress for ‘debug’ging. previous; scanpy._settings.ScanpyConfig.plot_suffix. next; scanpy._settings.ScanpyConfig.writedir. Contents; . ScanpyConfig.verbosity. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy._settings.ScanpyConfig.verbosity.html:9481,message,messages,9481,en/stable/generated/scanpy._settings.ScanpyConfig.verbosity.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy._settings.ScanpyConfig.verbosity.html,4,['message'],['messages']
Integrability,"shup; Clean up _ranks and fix dendrogram for scipy 1.5 pr1290 S Rybakov; Use .raw to translate gene symbols if applicable pr1278 E Rice; Fix diffmap (issue1262) G Eraslan; Fix neighbors in spring_project issue1260 S Rybakov; Fix default size of dot in spatial plots pr1255 issue1253 giovp; Bumped version requirement of scipy to scipy>1.4 to support rmatmat argument of LinearOperator issue1246 I Virshup; Fix asymmetry of scores for the 'wilcoxon' method in rank_genes_groups() issue754 S Rybakov; Avoid trimming of gene names in rank_genes_groups() issue753 S Rybakov. Version 1.5#. 1.5.1 2020-05-21#. Bug fixes#. Fixed a bug in pca(), where random_state did not have an effect for sparse input pr1240 I Virshup; Fixed docstring in pca() which included an unused argument pr1240 I Virshup. 1.5.0 2020-05-15#; The 1.5.0 release adds a lot of new functionality, much of which takes advantage of anndata updates 0.7.0 - 0.7.2. Highlights of this release include support for spatial data, dedicated handling of graphs in AnnData, sparse PCA, an interface with scvi, and others. Spatial data support#. Basic analysis Analysis and visualization of spatial transcriptomics data and integration with single cell data Integrating spatial data with scRNA-seq using scanorama G Palla; read_visium() read 10x Visium data pr1034 G Palla, P Angerer, I Virshup; visium_sge() load Visium data directly from 10x Genomics pr1013 M Mirkazemi, G Palla, P Angerer; spatial() plot spatial data pr1012 G Palla, P Angerer. New functionality#. Many functions, like neighbors() and umap(), now store cell-by-cell graphs in obsp pr1118 S Rybakov; scale() and log1p() can be used on any element in layers or obsm pr1173 I Virshup. External tools#. scanpy.external.pp.scvi for preprocessing with scVI pr1085 G Xing; Guide for using Scanpy in R pr1186 L Zappia. Performance#. pca() now uses efficient implicit centering for sparse matrices. This can lead to signifigantly improved performance for large datasets pr1066 A Tarasha",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:37727,interface,interface,37727,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,1,['interface'],['interface']
Integrability,"sing: PP; scanpy.external.pp.bbknn; scanpy.external.pp.harmony_integrate; scanpy.external.pp.mnn_correct; scanpy.external.pp.scanorama_integrate; scanpy.external.pp.hashsolo; scanpy.external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .ipynb. .pdf. Integrating data using ingest and BBKNN. Contents . PBMCs; Mapping PBMCs using ingest; Using BBKNN. Pancreas; Seeing the batch effect; BBKNN; Mapping onto a reference batch using ingest; Evaluating consistency; Cell types conserved across batches; All cell types. Visualizing distributions across batches; Density plot; Partial visualizaton of a subset of groups in embedding. Integrating data using ingest and BBKNN#; The following tutorial describes a simple PCA-based method for integrating data we call ingest and compares it with BBKNN [Polanski19]. BBKNN integrates well with the Scanpy workflow and is accessible through the bbknn function.; The ingest function assumes an annotated reference dataset that captures the biological variability of interest. The rational is to fit a model on the reference data and use it to project new data. For the time being, this model is a PCA combined with a neighbor lookup search tree, for which we use UMAP’s implementation [McInnes18]. Similar PCA-based integrations have ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/integrating-data-using-ingest.html:9250,Integrat,Integrating,9250,en/stable/tutorials/basics/integrating-data-using-ingest.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/integrating-data-using-ingest.html,1,['Integrat'],['Integrating']
Integrability,"spatial[adata_spatial.obs.library_id == library, :].copy(); sc.pl.spatial(; ad,; img_key=""hires"",; library_id=library,; color=""clusters"",; size=1.5,; palette=[; v; for k, v in clusters_colors.items(); if k in ad.obs.clusters.unique().tolist(); ],; legend_loc=None,; show=False,; ax=axs[i],; ). plt.tight_layout(). WARNING: Length of palette colors is smaller than the number of categories (palette length: 16, categories length: 18. Some categories will have the same color.; WARNING: Length of palette colors is smaller than the number of categories (palette length: 14, categories length: 18. Some categories will have the same color. From the clusters, we can clearly see the stratification of the cortical layer in both of the tissues (see the Allen brain atlas for reference). Furthermore, it seems that the dataset integration worked well, since there is a clear continuity between clusters in the two tissues. Data integration and label transfer from scRNA-seq dataset#; We can also perform data integration between one scRNA-seq dataset and one spatial transcriptomics dataset. Such task is particularly useful because it allows us to transfer cell type labels to the Visium dataset, which were dentified from the scRNA-seq dataset.; For this task, we will be using a dataset from Tasic et al., where the mouse cortex was profiled with smart-seq technology.; The dataset can be downloaded from GEO count - metadata.; Conveniently, you can also download the pre-processed dataset in h5ad format from here.; Since the dataset was generated from the mouse cortex, we will subset the visium dataset in order to select only the spots part of the cortex. Note that the integration can also be performed on the whole brain slice, but it would give rise to false positive cell type assignments and and therefore it should be interpreted with more care.; The integration task will be performed with Scanorama: each Visium dataset will be integrated with the smart-seq cortex dataset.; The following cel",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html:19342,integrat,integration,19342,en/stable/tutorials/spatial/integration-scanorama.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html,4,['integrat'],['integration']
Integrability,"subset.copy(); adata_posterior_subset_transfer.obs = pd.concat(; [adata_posterior_subset.obs, cp_posterior_df], axis=1; ). We are then able to explore how cell types are propagated from the scRNA-seq dataset to the visium dataset. Let’s first visualize the neurons cortical layers. sc.pl.spatial(; adata_anterior_subset_transfer,; img_key=""hires"",; color=[""L2/3 IT"", ""L4"", ""L5 PT"", ""L6 CT""],; size=1.5,; ); sc.pl.spatial(; adata_posterior_subset_transfer,; img_key=""hires"",; color=[""L2/3 IT"", ""L4"", ""L5 PT"", ""L6 CT""],; size=1.5,; ). Interestingly, it seems that this approach worked, since sequential layers of cortical neurons could be correctly identified, both in the anterior and posterior sagittal slide.; We can go ahead an visualize astrocytes and oligodendrocytes as well. sc.pl.spatial(; adata_anterior_subset_transfer, img_key=""hires"", color=[""Oligo"", ""Astro""], size=1.5; ); sc.pl.spatial(; adata_posterior_subset_transfer, img_key=""hires"", color=[""Oligo"", ""Astro""], size=1.5; ). In this tutorial, we showed how to work with multiple slices in Scanpy, and perform label transfers between an annotated scRNA-seq dataset and an unannotated Visium dataset. We showed that such approach, that leverages the data integration performances of Scanorama, is useful and provide a straightforward tool for exploratory analysis.; However, for the label transfer task, we advise analysts to explore more principled approaches, based on cell-type deconvolution, that are likely to provide more accurate and interpretable results. See recent approaches such as:. Stereoscope paper - code; AutogeneS paper - code; MuSiC paper - code; CIBERSORT-X paper - webtool; Deconv-seq code; cell2location paper - code. previous; Analysis and visualization of spatial transcriptomics data. next; Experimental. Contents; . Loading libraries; Reading the data; Data integration; Data integration and label transfer from scRNA-seq dataset. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html:27206,integrat,integration,27206,en/stable/tutorials/spatial/integration-scanorama.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html,6,['integrat'],['integration']
Integrability,"t all other batches.; As before, the model trained on the reference batch will explain the biological variation observed within it. adata_ref = adata_all[adata_all.obs.batch == ""0""]. Compute the PCA, neighbors and UMAP on the reference data. sc.pp.pca(adata_ref); sc.pp.neighbors(adata_ref); sc.tl.umap(adata_ref). The reference batch contains 12 of the 19 cell types across all batches. sc.pl.umap(adata_ref, color=""celltype""). Iteratively map labels (such as ‘celltype’) and embeddings (such as ‘X_pca’ and ‘X_umap’) from the reference data onto the query batches. adatas = [adata_all[adata_all.obs.batch == i].copy() for i in [""1"", ""2"", ""3""]]. sc.settings.verbosity = 2 # a bit more logging; for iadata, adata in enumerate(adatas):; print(f""... integrating batch {iadata+1}""); adata.obs[""celltype_orig""] = adata.obs.celltype # save the original cell type; sc.tl.ingest(adata, adata_ref, obs=""celltype""). ... integrating batch 1; running ingest; finished (0:00:06); ... integrating batch 2; running ingest; finished (0:00:07); ... integrating batch 3; running ingest; finished (0:00:03). Each of the query batches now carries annotation that has been contextualized with adata_ref. By concatenating, we can view it together. adata_concat = adata_ref.concatenate(adatas). adata_concat.obs.celltype = adata_concat.obs.celltype.astype(""category""); # fix category ordering; adata_concat.obs.celltype.cat.reorder_categories(; adata_ref.obs.celltype.cat.categories, inplace=True; ); # fix category coloring; adata_concat.uns[""celltype_colors""] = adata_ref.uns[""celltype_colors""]. sc.pl.umap(adata_concat, color=[""batch"", ""celltype""]). Compared to the BBKNN result, this is maintained clusters in a much more pronounced fashion. If one already observed a desired continuous structure (as in the hematopoietic datasets, for instance), ingest allows to easily maintain this structure. Evaluating consistency#; Let us subset the data to the query batches. adata_query = adata_concat[adata_concat.obs.batch.isi",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/integrating-data-using-ingest.html:17550,integrat,integrating,17550,en/stable/tutorials/basics/integrating-data-using-ingest.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/integrating-data-using-ingest.html,2,['integrat'],['integrating']
Integrability,t; scanpy.read_h5ad.rst; scanpy.read_hdf.rst; scanpy.read_loom.rst; scanpy.read_mtx.rst; scanpy.read_text.rst; scanpy.read_umi_tools.rst; scanpy.read_visium.rst; scanpy.set_figure_params.rst; scanpy.tl.dendrogram.rst; scanpy.tl.diffmap.rst; scanpy.tl.dpt.rst; scanpy.tl.draw_graph.rst; scanpy.tl.embedding_density.rst; scanpy.tl.filter_rank_genes_groups.rst; scanpy.tl.ingest.rst; scanpy.tl.leiden.rst; scanpy.tl.louvain.rst; scanpy.tl.marker_gene_overlap.rst; scanpy.tl.paga.rst; scanpy.tl.rank_genes_groups.rst; scanpy.tl.score_genes.rst; scanpy.tl.score_genes_cell_cycle.rst; scanpy.tl.sim.rst; scanpy.tl.tsne.rst; scanpy.tl.umap.rst. /how-to; ; index.md; knn-transformers.ipynb; plotting-with-marsilea.ipynb. /release-notes; ; index.md. /tutorials; . /basics; ; clustering.ipynb; clustering-2017.ipynb; index.md; integrating-data-using-ingest.ipynb. /experimental; ; dask.ipynb; index.md; pearson_residuals.ipynb. /plotting; ; advanced.ipynb; core.ipynb; index.md. /spatial; ; index.md; integration-scanorama.ipynb. /trajectories; ; index.md; paga-paul15.ipynb. index.md. community.md; contributors.md; ecosystem.md; index.md; installation.md; news.md; references.rst; usage-principles.md. /_static; . /css; ; rtd_sphinx_search.min.css. /js; ; rtd_search_config.js; rtd_sphinx_search.min.js. /scripts; ; bootstrap.js; pydata-sphinx-theme.js; rtd-sphinx-search.js; sphinx-book-theme.js. /styles; ; bootstrap.css; pydata-sphinx-theme.css; scanpy.css; sphinx-book-theme.css; theme.css. /vendor; . /fontawesome; . /6.5.2; . /css; ; all.min.css. /js; ; all.min.js. /webfonts; ; fa-brands-400.ttf; fa-brands-400.woff2; fa-regular-400.ttf; fa-regular-400.woff2; fa-solid-900.ttf; fa-solid-900.woff2; fa-v4compatibility.ttf; fa-v4compatibility.woff2. basic.css; clipboard.min.js; copybutton.css; copybutton.js; design-tabs.js; doctools.js; documentation_options.js; language_data.js; mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css; plot_directive.css; pygments.css; Scanpy_Lo,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/index-wcopy.html:9906,integrat,integration-scanorama,9906,index-wcopy.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/index-wcopy.html,1,['integrat'],['integration-scanorama']
Integrability,"tall -qU ""pip""; %pip install -q ""scanpy"" ""sklearn-ann[annoy]"". Note: you may need to restart the kernel to use updated packages.; Note: you may need to restart the kernel to use updated packages. import scanpy as sc; from sklearn_ann.kneighbors.annoy import AnnoyTransformer # noqa: F401. sc.logging.print_header(). scanpy==1.10.0rc2.dev0+g48b495d9.d20240222 anndata==0.10.5.post1 umap==0.5.5 numpy==1.26.4 scipy==1.12.0 pandas==2.2.0 scikit-learn==1.4.1.post1 statsmodels==0.14.1 igraph==0.11.4 pynndescent==0.5.11. Our nearest neighbors implementation uses the PCA embedding by default, so let’s pre-compute that:. adata_default = sc.datasets.paul15(); sc.pp.pca(adata_default); adata_annoy, adata_pynnd = adata_default.copy(), adata_default.copy(). WARNING: In Scanpy 0.*, this returned logarithmized data. Now it returns non-logarithmized data. The best way to use a third-party approximate nearest neighbors implementation is to use sklearn-ann. It provides kNN Transformer classes wrapping several popular approximate nearest neighbor libraries.; Explicitly setting the transformer parameter allows customizing how this function behaves.; By default, for small datasets, Scanpy just calculates all distances.; Setting the transformer parameter to ""pynndescent"" makes Scanpy always use its default for large datasets. %timeit sc.pp.neighbors(adata_default, n_neighbors=15); %timeit sc.pp.neighbors(adata_pynnd, transformer=""pynndescent"", n_neighbors=15); %timeit sc.pp.neighbors(adata_annoy, transformer=AnnoyTransformer(15)). 29.3 ms ± 1.53 ms per loop (mean ± std. dev. of 7 runs, 1 loop each); 683 ms ± 28.9 ms per loop (mean ± std. dev. of 7 runs, 1 loop each); 50.1 ms ± 350 µs per loop (mean ± std. dev. of 7 runs, 10 loops each). Looks like Annoy is quite a bit faster than PyNNDescent (but of course not as fast as Scanpy’s brute-force shortcut on a small dataset like this).; Let’s see if Leidenalg and UMAP get reasonable results when using each of the kNN graphs. for adata in [adata_d",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/how-to/knn-transformers.html:10481,wrap,wrapping,10481,en/stable/how-to/knn-transformers.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/how-to/knn-transformers.html,1,['wrap'],['wrapping']
Integrability,"ternal.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .ipynb. .pdf. Integrating spatial data with scRNA-seq using scanorama. Contents . Loading libraries; Reading the data; Data integration; Data integration and label transfer from scRNA-seq dataset. Integrating spatial data with scRNA-seq using scanorama#; Author: Giovanni Palla. Note; For up-to-date analysis tutorials, kindly check out SquidPy tutorials. This tutorial shows how to work with multiple Visium datasets and perform integration of scRNA-seq dataset with Scanpy. It follows the previous tutorial on analysis and visualization of spatial transcriptomics data.; We will use Scanorama paper - code to perform integration and label transfer. It has a convenient interface with scanpy and anndata.; To install the required libraries, type the following:; pip install git+https://github.com/theislab/scanpy.git; pip install git+https://github.com/theislab/anndata.git; pip install scanorama. Loading libraries#. import scanpy as sc; import anndata as an; import pandas as pd; import numpy as np; import matplotlib.pyplot as plt; import seaborn as sns; import scanorama. from pathlib import Path. sc.logging.print_versions(); sc.set_figure_params(facecolor=""white"", figsize=(8, 8)); sc.settings.verbosity = 3. -----; anndata 0.11.0.dev78+g64ab900; scanpy 1.10.0rc2.dev6+g14555ba4; -----; PIL 10.2.0; annoy NA; anyio NA; appnope 0.1.3; arrow 1.3.0; asciitree NA; asttokens NA; attr 23.2.0; attrs 23.2.0; babel ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html:9683,integrat,integration,9683,en/stable/tutorials/spatial/integration-scanorama.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html,2,['integrat'],['integration']
Integrability,"tings.ScanpyConfig.logpath; scanpy._settings.ScanpyConfig.max_memory; scanpy._settings.ScanpyConfig.n_jobs; scanpy._settings.ScanpyConfig.plot_suffix; scanpy._settings.ScanpyConfig.verbosity; scanpy._settings.ScanpyConfig.writedir; scanpy._settings.ScanpyConfig.N_PCS; scanpy._settings.ScanpyConfig.set_figure_params. scanpy.logging.print_header; scanpy.logging.print_versions. Datasets; scanpy.datasets.blobs; scanpy.datasets.ebi_expression_atlas; scanpy.datasets.krumsiek11; scanpy.datasets.moignard15; scanpy.datasets.pbmc3k; scanpy.datasets.pbmc3k_processed; scanpy.datasets.pbmc68k_reduced; scanpy.datasets.paul15; scanpy.datasets.toggleswitch; scanpy.datasets.visium_sge. Deprecated functions; scanpy.pp.filter_genes_dispersion; scanpy.pp.normalize_per_cell. External API; Preprocessing: PP; scanpy.external.pp.bbknn; scanpy.external.pp.harmony_integrate; scanpy.external.pp.mnn_correct; scanpy.external.pp.scanorama_integrate; scanpy.external.pp.hashsolo; scanpy.external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .md. .pdf. Plotting. Plotting#. Core plotting functions; Customizing Scanpy plots. previous; Integrating data using ingest and BBKNN. next; Core plotting functions. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/index.html:9298,Integrat,Integrating,9298,en/stable/tutorials/plotting/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/index.html,1,['Integrat'],['Integrating']
Integrability,"ts, using; n_pca < 20 allows neighborhoods to be calculated in; roughly log(n_samples) time. If None, no PCA is performed. solver Literal['exact', 'approximate'] (default: 'exact')Which solver to use. “exact” uses the implementation described; in van Dijk et al. [2018]. “approximate” uses a faster; implementation that performs imputation in the PCA space and then; projects back to the gene space. Note, the “approximate” solver may; return negative values. knn_dist str (default: 'euclidean')recommended values: ‘euclidean’, ‘cosine’, ‘precomputed’; Any metric from scipy.spatial.distance can be used; distance metric for building kNN graph. If ‘precomputed’,; data should be an n_samples x n_samples distance or; affinity matrix. random_state Union[int, RandomState, None] (default: None)Random seed. Defaults to the global numpy random number generator. n_jobs int | None (default: None)Number of threads to use in training. All cores are used by default. verbose bool (default: False)If True or an integer >= 2, print status messages.; If None, sc.settings.verbosity is used. copy bool | None (default: None)If true, a copy of anndata is returned. If None, copy is True if; genes is not 'all_genes' or 'pca_only'. copy may only be False; if genes is 'all_genes' or 'pca_only', as the resultant data; will otherwise have different column names from the input data. kwargsAdditional arguments to magic.MAGIC. Return type:; AnnData | None. Returns:; If copy is True, AnnData object is returned.; If subset_genes is not all_genes, PCA on MAGIC values of cells are; stored in adata.obsm['X_magic'] and adata.X is not modified.; The raw counts are stored in .raw attribute of AnnData object. Examples; >>> import scanpy as sc; >>> import scanpy.external as sce; >>> adata = sc.datasets.paul15(); >>> sc.pp.normalize_per_cell(adata); >>> sc.pp.sqrt(adata) # or sc.pp.log1p(adata); >>> adata_magic = sce.pp.magic(adata, name_list=['Mpo', 'Klf1', 'Ifitm1'], knn=5); >>> adata_magic.shape; (2730, 3); >>>",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.magic.html:12282,message,messages,12282,en/stable/generated/scanpy.external.pp.magic.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.magic.html,1,['message'],['messages']
Integrability,"tting up the neighborhood graph (here, a PCA) and separate out all other batches.; As before, the model trained on the reference batch will explain the biological variation observed within it. adata_ref = adata_all[adata_all.obs.batch == ""0""]. Compute the PCA, neighbors and UMAP on the reference data. sc.pp.pca(adata_ref); sc.pp.neighbors(adata_ref); sc.tl.umap(adata_ref). The reference batch contains 12 of the 19 cell types across all batches. sc.pl.umap(adata_ref, color=""celltype""). Iteratively map labels (such as ‘celltype’) and embeddings (such as ‘X_pca’ and ‘X_umap’) from the reference data onto the query batches. adatas = [adata_all[adata_all.obs.batch == i].copy() for i in [""1"", ""2"", ""3""]]. sc.settings.verbosity = 2 # a bit more logging; for iadata, adata in enumerate(adatas):; print(f""... integrating batch {iadata+1}""); adata.obs[""celltype_orig""] = adata.obs.celltype # save the original cell type; sc.tl.ingest(adata, adata_ref, obs=""celltype""). ... integrating batch 1; running ingest; finished (0:00:06); ... integrating batch 2; running ingest; finished (0:00:07); ... integrating batch 3; running ingest; finished (0:00:03). Each of the query batches now carries annotation that has been contextualized with adata_ref. By concatenating, we can view it together. adata_concat = adata_ref.concatenate(adatas). adata_concat.obs.celltype = adata_concat.obs.celltype.astype(""category""); # fix category ordering; adata_concat.obs.celltype.cat.reorder_categories(; adata_ref.obs.celltype.cat.categories, inplace=True; ); # fix category coloring; adata_concat.uns[""celltype_colors""] = adata_ref.uns[""celltype_colors""]. sc.pl.umap(adata_concat, color=[""batch"", ""celltype""]). Compared to the BBKNN result, this is maintained clusters in a much more pronounced fashion. If one already observed a desired continuous structure (as in the hematopoietic datasets, for instance), ingest allows to easily maintain this structure. Evaluating consistency#; Let us subset the data to the query b",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/integrating-data-using-ingest.html:17489,integrat,integrating,17489,en/stable/tutorials/basics/integrating-data-using-ingest.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/integrating-data-using-ingest.html,2,['integrat'],['integrating']
Integrability,"unksize will slow down the computation, so try to set it as large as possible with your resources.; As an example, we used chunksize=1000 when processing a dataset with 2 million cells in a machine with 500 GB RAM. For smaller machines, we would recommend to reduce this below 100. Wrapper functions for Pearson residuals preprocessing#; The scanpy.experimental.pp module also ships two wrappers that run multiple pre-processing steps at once:. sc.experimental.pp.normalize_pearson_residuals_pca() performs normalization by Pearson residuals and PCA in one go. This function is helpful to quickly obtain a Pearson residual-based data representation when highly variable genes are already defined, as only those are used by default.; sc.experimental.pp.recipe_pearson_residuals() performs gene selection and normalization by Pearson residuals, and PCA on top. This is intended to make the full Pearson residual preprocessing available in one step. All hyperparameters of the individual steps can still be controlled using the wrapper functions’ arguments. See the documentation for details. References / See also#; Hafemeister & Satija (2019), Normalization and variance stabilization of single-cell RNA-seq data using regularized negative binomial regression, Genome Biology; Lause et al. (2021), Analytic Pearson residuals for normalization of single-cell RNA-seq UMI data, Genome Biology; Wagner (2021), Normalization methods for single-cell RNA-Seq data, Youtube; Choudhary & Satija (2022), Comparison and evaluation of statistical error models for scRNA-seq, Genome Biology. previous; Experimental. next; Using dask with Scanpy. Contents; . Background; Preparations; Download data; Load data. Perform Quality control; Basic filtering; Compute quality control metrics; Plot quality control metrics. Use Pearson residuals for selection of highly variable genes; Compute 2000 variable genes with Pearson residuals; Plot gene selection; Apply gene selection; Print resulting adata objects. Transformi",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:30540,wrap,wrapper,30540,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,2,['wrap'],['wrapper']
Integrability,"var_name in the; category (visualized by the size of the dot). If groupby is not given,; the dotplot assumes that all data belongs to a single category. Note; A gene is considered expressed if the expression value in the adata (or; adata.raw) is above the specified threshold which is zero by default. An example of dotplot usage is to visualize, for multiple marker genes,; the mean value and the percentage of cells expressing the gene; across multiple clusters.; This function provides a convenient interface to the DotPlot; class. If you need more flexibility, you should use DotPlot; directly. Parameters:. adata AnnDataAnnotated data matrix. var_names Union[str, Sequence[str], Mapping[str, Union[str, Sequence[str]]]]var_names should be a valid subset of adata.var_names.; If var_names is a mapping, then the key is used as label; to group the values (see var_group_labels). The mapping values; should be sequences of valid adata.var_names. In this; case either coloring or ‘brackets’ are used for the grouping; of var names depending on the plot. When var_names is a mapping,; then the var_group_labels and var_group_positions are set. groupby str | Sequence[str]The key of the observation grouping to consider. use_raw bool | None (default: None)Use raw attribute of adata if present. log bool (default: False)Plot on logarithmic axis. num_categories int (default: 7)Only used if groupby observation is not categorical. This value; determines the number of groups into which the groupby observation; should be subdivided. categories_orderOrder in which to show the categories. Note: add_dendrogram or add_totals; can change the categories order. figsize tuple[float, float] | None (default: None)Figure size when multi_panel=True.; Otherwise the rcParam['figure.figsize] value is used.; Format is (width, height). dendrogram bool | str (default: False)If True or a valid dendrogram key, a dendrogram based on the hierarchical; clustering between the groupby categories is added.; The dendrogr",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pl.dotplot.html:11180,depend,depending,11180,en/stable/generated/scanpy.pl.dotplot.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pl.dotplot.html,1,['depend'],['depending']
Integrability,"vements; Added combat() function for batch effect correction [Johnson et al., 2006, Leek et al., 2017, Pedersen, 2012] pr398 M Lange. 1.3.7 2019-01-02#. API changed from import scanpy as sc to import scanpy.api as sc.; phenograph() wraps the graph clustering package Phenograph [Levine et al., 2015] thanks to A Mousa. 1.3.6 2018-12-11#. Major updates#. a new plotting gallery for visualizing-marker-genes F Ramirez; tutorials are integrated on ReadTheDocs, pbmc3k and paga-paul15 A Wolf. Interactive exploration of analysis results through manifold viewers#. CZI’s cellxgene directly reads .h5ad files the cellxgene developers; the UCSC Single Cell Browser requires exporting via cellbrowser() M Haeussler. Code design#. highly_variable_genes() supersedes filter_genes_dispersion(), it gives the same results but, by default, expects logarithmized data and doesn’t subset A Wolf. 1.3.5 2018-12-09#. uncountable figure improvements pr369 F Ramirez. 1.3.4 2018-11-24#. leiden() wraps the recent graph clustering package by Traag et al. [2019] K Polanski; bbknn() wraps the recent batch correction package [Polański et al., 2019] K Polanski; calculate_qc_metrics() caculates a number of quality control metrics, similar to calculateQCMetrics from Scater [McCarthy et al., 2017] I Virshup. 1.3.3 2018-11-05#. Major updates#. a fully distributed preprocessing backend T White and the Laserson Lab. Code design#. read_10x_h5() and read_10x_mtx() read Cell Ranger 3.0 outputs pr334 Q Gong. Note; Also see changes in anndata 0.6. changed default compression to None in write_h5ad() to speed up read and write, disk space use is usually less critical; performance gains in write_h5ad() due to better handling of strings and categories S Rybakov. 1.3.1 2018-09-03#. RNA velocity in single cells [La Manno et al., 2018]#. Scanpy and AnnData support loom’s layers so that computations for single-cell RNA velocity [La Manno et al., 2018] become feasible S Rybakov and V Bergen; scvelo harmonizes with Scanpy and ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:45141,wrap,wraps,45141,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,1,['wrap'],['wraps']
Integrability,"x = axs[row_idx, col_idx]; sc.pl.umap(adata, color=marker, ax=ax, show=False, frameon=False, s=20); # Add cell type as row label - here we simply add it as ylabel of; # the first Axes object in the row; if col_idx == 0:; # We disabled axis drawing in UMAP to have plots without background and border; # so we need to re-enable axis to plot the ylabel; ax.axis(""on""); ax.tick_params(; top=""off"",; bottom=""off"",; left=""off"",; right=""off"",; labelleft=""on"",; labelbottom=""off"",; ); ax.set_ylabel(cell_type + ""\n"", rotation=90, fontsize=14); ax.set(frame_on=False); col_idx += 1; # Remove unused column Axes in the current row; while col_idx < ncol:; axs[row_idx, col_idx].remove(); col_idx += 1; # Alignment within the Figure; fig.tight_layout(). Plot size#; There are multiple options for adjusting plot size, as shown below.; We can adjust plot size by setting rcParams['figure.figsize'], which will also change settings for future plots.; These are either available through scanpy’s set_figure_params which wraps Matplotlib’s rcParams or by modifying them directly. rcParams[""figure.figsize""] = (2, 2); sc.pl.umap(adata, color=""bulk_labels""); # Set back to value selected above; rcParams[""figure.figsize""] = FIGSIZE. We can set rcParams for a single plot with a context manager which won’t change the setting for future plots. with plt.rc_context({""figure.figsize"": (5, 5)}):; sc.pl.umap(adata, color=""bulk_labels""). We can also create an Axes object with a predefined size and pass it to a scanpy plotting function. fig, ax = plt.subplots(figsize=(4, 4)); sc.pl.umap(adata, color=""bulk_labels"", ax=ax). The figsize is divided between all Axes and spaces between them. Thus, if we have multiple Axes (columns or rows) we must accordingly increase figsize.; However, if we do not pass Axes objects to the scanpy embedding function it will automatically create individual Axes with the size of the current global figsize (as specified by e.g. matplotlib figure.figsize). ncol = 2; nrow = 1; figsize = 3;",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/advanced.html:17501,wrap,wraps,17501,en/stable/tutorials/plotting/advanced.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/advanced.html,2,['wrap'],['wraps']
Integrability,"x]; annot = sc.queries.biomart_annotations(; ""mmusculus"",; [""mgi_symbol"", ""ensembl_gene_id""],; ).set_index(""mgi_symbol""); annot = annot[annot.index.isin(counts.columns)]; counts = counts.rename(columns=dict(zip(annot.index, annot[""ensembl_gene_id""]))); adata_cortex = an.AnnData(counts, obs=meta); sc.pp.normalize_total(adata_cortex, inplace=True); sc.pp.log1p(adata_cortex); adata_cortex.write_h5ad(""data/adata_processed.h5ad""). adata_cortex = sc.read(""./data/adata_processed.h5ad""). adata_spatial_anterior.var.set_index(""gene_ids"", inplace=True); adata_spatial_posterior.var.set_index(""gene_ids"", inplace=True). Subset the spatial anndata to (approximately) selects only spots belonging to the cortex. adata_anterior_subset = adata_spatial_anterior[; adata_spatial_anterior.obsm[""spatial""][:, 1] < 6000, :; ]; adata_posterior_subset = adata_spatial_posterior[; (adata_spatial_posterior.obsm[""spatial""][:, 1] < 4000); & (adata_spatial_posterior.obsm[""spatial""][:, 0] < 6000),; :,; ]. Run integration with Scanorama. adatas_anterior = [adata_cortex, adata_anterior_subset]; adatas_posterior = [adata_cortex, adata_posterior_subset]. # Integration.; adatas_cor_anterior = scanorama.correct_scanpy(adatas_anterior, return_dimred=True); adatas_cor_posterior = scanorama.correct_scanpy(adatas_posterior, return_dimred=True). Found 22689 genes among all datasets; [[0. 0.22877847]; [0. 0. ]]; Processing datasets (0, 1); Found 22689 genes among all datasets; [[0. 0.35810811]; [0. 0. ]]; Processing datasets (0, 1). Concatenate datasets and assign integrated embeddings to anndata objects.; Notice that we are concatenating datasets with the join=""outer"" and uns_merge=""first"" strategies. This is because we want to keep the obsm['coords'] as well as the images of the visium datasets. adata_cortex_anterior = sc.concat(; adatas_cor_anterior,; label=""dataset"",; keys=[""smart-seq"", ""visium""],; join=""outer"",; uns_merge=""first"",; ); adata_cortex_posterior = sc.concat(; adatas_cor_posterior,; label=""dataset",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html:22214,integrat,integration,22214,en/stable/tutorials/spatial/integration-scanorama.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html,2,['integrat'],['integration']
Integrability,"xternal.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.external.pp.harmony_integrate. Contents . harmony_integrate(). scanpy.external.pp.harmony_integrate#. scanpy.external.pp.harmony_integrate(adata, key, *, basis='X_pca', adjusted_basis='X_pca_harmony', **kwargs)[source]#; Use harmonypy [Korsunsky et al., 2019] to integrate different experiments.; Harmony [Korsunsky et al., 2019] is an algorithm for integrating single-cell; data from multiple experiments. This function uses the python; port of Harmony, harmonypy, to integrate single-cell data; stored in an AnnData object. As Harmony works by adjusting the; principal components, this function should be run after performing; PCA but before computing the neighbor graph, as illustrated in the; example below. Parameters:. adata AnnDataThe annotated data matrix. key strThe name of the column in adata.obs that differentiates; among experiments/batches. basis str (default: 'X_pca')The name of the field in adata.obsm where the PCA table is; stored. Defaults to 'X_pca', which is the default for; sc.pp.pca(). adjusted_basis str (default: 'X_pca_harmony')The name of the field in adata.obsm where the adjusted PCA; table will be stored after running this function. Defaults to; X_pca_harmony. kwargsAny additional arguments will be passed to; harmonypy.run_harmony(). Returns:; Updates adata with the field adata.obsm[obsm_out_field],; containing principal compo",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.harmony_integrate.html:9602,integrat,integrating,9602,en/stable/generated/scanpy.external.pp.harmony_integrate.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.harmony_integrate.html,1,['integrat'],['integrating']
Integrability,"y({}), return_model=False, return_info=False, copy=False)[source]#; Deep count autoencoder [Eraslan et al., 2019].; Fits a count autoencoder to the raw count data given in the anndata object; in order to denoise the data and to capture hidden representation of; cells in low dimensions. Type of the autoencoder and return values are; determined by the parameters. Note; More information and bug reports here. Parameters:. adata AnnDataAn anndata file with .raw attribute representing raw counts. mode Literal['denoise', 'latent'] (default: 'denoise')denoise overwrites adata.X with denoised expression values.; In latent mode DCA adds adata.obsm['X_dca'] to given adata; object. This matrix represent latent representation of cells via DCA. ae_type Literal['zinb-conddisp', 'zinb', 'nb-conddisp', 'nb'] (default: 'nb-conddisp')Type of the autoencoder. Return values and the architecture is; determined by the type e.g. nb does not provide dropout; probabilities. Types that end with “-conddisp”, assumes that dispersion is mean dependant. normalize_per_cell bool (default: True)If true, library size normalization is performed using; the sc.pp.normalize_per_cell function in Scanpy and saved into adata; object. Mean layer is re-introduces library size differences by; scaling the mean value of each cell in the output layer. See the; manuscript for more details. scale bool (default: True)If true, the input of the autoencoder is centered using; sc.pp.scale function of Scanpy. Note that the output is kept as raw; counts as loss functions are designed for the count data. log1p bool (default: True)If true, the input of the autoencoder is log transformed with a; pseudocount of one using sc.pp.log1p function of Scanpy. hidden_size Sequence[int] (default: (64, 32, 64))Width of hidden layers. hidden_dropout float | Sequence[float] (default: 0.0)Probability of weight dropout in the autoencoder (per layer if list; or tuple). batchnorm bool (default: True)If true, batch normalization is performed.",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.dca.html:10749,depend,dependant,10749,en/stable/generated/scanpy.external.pp.dca.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.dca.html,1,['depend'],['dependant']
Integrability,"y.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .ipynb. .pdf. Integrating spatial data with scRNA-seq using scanorama. Contents . Loading libraries; Reading the data; Data integration; Data integration and label transfer from scRNA-seq dataset. Integrating spatial data with scRNA-seq using scanorama#; Author: Giovanni Palla. Note; For up-to-date analysis tutorials, kindly check out SquidPy tutorials. This tutorial shows how to work with multiple Visium datasets and perform integration of scRNA-seq dataset with Scanpy. It follows the previous tutorial on analysis and visualization of spatial transcriptomics data.; We will use Scanorama paper - code to perform integration and label transfer. It has a convenient interface with scanpy and anndata.; To install the required libraries, type the following:; pip install git+https://github.com/theislab/scanpy.git; pip install git+https://github.com/theislab/anndata.git; pip install scanorama. Loading libraries#. import scanpy as sc; import anndata as an; import pandas as pd; import numpy as np; import matplotlib.pyplot as plt; import seaborn as sns; import scanorama. from pathlib import Path. sc.logging.print_versions(); sc.set_figure_params(facecolor=""white"", figsize=(8, 8)); sc.settings.verbosity = 3. -----; anndata 0.11.0",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html:9450,Integrat,Integrating,9450,en/stable/tutorials/spatial/integration-scanorama.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html,1,['Integrat'],['Integrating']
Integrability,"y.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .ipynb. .pdf. Integrating data using ingest and BBKNN. Contents . PBMCs; Mapping PBMCs using ingest; Using BBKNN. Pancreas; Seeing the batch effect; BBKNN; Mapping onto a reference batch using ingest; Evaluating consistency; Cell types conserved across batches; All cell types. Visualizing distributions across batches; Density plot; Partial visualizaton of a subset of groups in embedding. Integrating data using ingest and BBKNN#; The following tutorial describes a simple PCA-based method for integrating data we call ingest and compares it with BBKNN [Polanski19]. BBKNN integrates well with the Scanpy workflow and is accessible through the bbknn function.; The ingest function assumes an annotated reference dataset that captures the biological variability of interest. The rational is to fit a model on the reference data and use it to project new data. For the time being, this model is a PCA combined with a neighbor lookup search tree, for which we use UMAP’s implementation [McInnes18]. Similar PCA-based integrations have been used before, for instance, in [Weinreb18]. As ingest is simple and the procedure clear, the workflow is transparent and fast.; Like BBKNN, ingest leaves the data matrix itself invariant.; Unlike BBKNN, ingest solves the label mapping problem (like scmap) and maintains an embedding that might have desired properties like specific clusters or trajectories. We refer to this asymmetric dataset integration as ingesting annotations from an an",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/integrating-data-using-ingest.html:9732,integrat,integrating,9732,en/stable/tutorials/basics/integrating-data-using-ingest.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/integrating-data-using-ingest.html,3,"['Integrat', 'integrat']","['Integrating', 'integrating']"
Integrability,"zed data – the logarithm of mean; and dispersion is taken internally when log is at its default value; True. For ‘cell_ranger’, this is usually called for logarithmized data; – in this case you should set log to False. In their default; workflows, Seurat passes the cutoffs whereas Cell Ranger passes; n_top_genes. min_mean float | None (default: None). max_mean float | None (default: None). min_disp float | None (default: None). max_disp float | None (default: None)If n_top_genes unequals None, these cutoffs for the means and the; normalized dispersions are ignored. n_bins int (default: 20)Number of bins for binning the mean gene expression. Normalization is; done with respect to each bin. If just a single gene falls into a bin,; the normalized dispersion is artificially set to 1. You’ll be informed; about this if you set settings.verbosity = 4. n_top_genes int | None (default: None)Number of highly-variable genes to keep. log bool (default: True)Use the logarithm of the mean to variance ratio. subset bool (default: True)Keep highly-variable genes only (if True) else write a bool array for h; ighly-variable genes while keeping all genes. copy bool (default: False)If an AnnData is passed, determines whether a copy; is returned. Return type:; AnnData | recarray | None. Returns:; If an AnnData adata is passed, returns or updates adata depending on; copy. It filters the adata and adds the annotations. meansadata.varMeans per gene. Logarithmized when log is True. dispersionsadata.varDispersions per gene. Logarithmized when log is True. dispersions_normadata.varNormalized dispersions per gene. Logarithmized when log is True. If a data matrix X is passed, the annotation is returned as np.recarray; with the same information stored in fields: gene_subset, means, dispersions, dispersion_norm. previous; Deprecated functions. next; scanpy.pp.normalize_per_cell. Contents; . filter_genes_dispersion(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.filter_genes_dispersion.html:12228,depend,depending,12228,en/stable/generated/scanpy.pp.filter_genes_dispersion.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.filter_genes_dispersion.html,1,['depend'],['depending']
Integrability,﻿. Analysis and visualization of spatial transcriptomics data — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/basic-analysis.html:235,Integrat,Integrating,235,en/stable/tutorials/spatial/basic-analysis.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/basic-analysis.html,2,['Integrat'],['Integrating']
Integrability,﻿. Customizing Scanpy plots — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON; scanpy.p,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/advanced.html:201,Integrat,Integrating,201,en/stable/tutorials/plotting/advanced.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/advanced.html,2,['Integrat'],['Integrating']
Integrability,﻿. How to preprocess UMI count data with analytic Pearson residuals — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scan,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:241,Integrat,Integrating,241,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,2,['Integrat'],['Integrating']
Integrability,﻿. Integrating spatial data with scRNA-seq using scanorama — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.Dot,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html:3,Integrat,Integrating,3,en/stable/tutorials/spatial/integration-scanorama.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html,3,['Integrat'],['Integrating']
Integrability,﻿. Preprocessing and clustering — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON; scan,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering.html:205,Integrat,Integrating,205,en/stable/tutorials/basics/clustering.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering.html,2,['Integrat'],['Integrating']
Modifiability," 'on data', 'on data export', 'best', 'upper right', 'upper left', 'lower left', 'lower right', 'right', 'center left', 'center right', 'lower center', 'upper center', 'center']] (default: 'right margin')Location of legend, either 'on data', 'right margin', None,; or a valid keyword for the loc parameter of Legend. legend_fontsize Union[int, float, Literal['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'], None] (default: None)Numeric size in pt or string describing the size.; See set_fontsize(). legend_fontweight Union[int, Literal['light', 'normal', 'medium', 'semibold', 'bold', 'heavy', 'black']] (default: 'bold')Legend font weight. A numeric value in range 0-1000 or a string.; Defaults to 'bold' if legend_loc == 'on data', otherwise to 'normal'.; See set_fontweight(). legend_fontoutline int | None (default: None)Line width of the legend font outline in pt. Draws a white outline using; the path effect withStroke. colorbar_loc str | None (default: 'right')Where to place the colorbar for continous variables. If None, no colorbar; is added. size float (default: 1.0)Point size. If None, is automatically computed as 120000 / n_cells.; Can be a sequence containing the size for each cell. The order should be; the same as in adata.obs. color_map Colormap | str | None (default: None)Color map to use for continous variables. Can be a name or a; Colormap instance (e.g. ""magma”, ""viridis""; or mpl.cm.cividis), see get_cmap().; If None, the value of mpl.rcParams[""image.cmap""] is used.; The default color_map can be set using set_figure_params(). palette str | Sequence[str] | Cycler | None (default: None)Colors to use for plotting categorical annotation groups.; The palette can be a valid ListedColormap name; ('Set2', 'tab20', …), a Cycler object, a dict mapping; categories to colors, or a sequence of colors. Colors must be valid to; matplotlib. (see is_color_like()).; If None, mpl.rcParams[""axes.prop_cycle""] is used unless the categorical; variable alread",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pl.spatial.html:15180,variab,variables,15180,en/stable/api/generated/scanpy.pl.spatial.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pl.spatial.html,1,['variab'],['variables']
Modifiability," 'on data', 'on data export', 'best', 'upper right', 'upper left', 'lower left', 'lower right', 'right', 'center left', 'center right', 'lower center', 'upper center', 'center']] (default: 'right margin')Location of legend, either 'on data', 'right margin', None,; or a valid keyword for the loc parameter of Legend. legend_fontsize Union[int, float, Literal['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'], None] (default: None)Numeric size in pt or string describing the size.; See set_fontsize(). legend_fontweight Union[int, Literal['light', 'normal', 'medium', 'semibold', 'bold', 'heavy', 'black']] (default: 'bold')Legend font weight. A numeric value in range 0-1000 or a string.; Defaults to 'bold' if legend_loc == 'on data', otherwise to 'normal'.; See set_fontweight(). legend_fontoutline int | None (default: None)Line width of the legend font outline in pt. Draws a white outline using; the path effect withStroke. colorbar_loc str | None (default: 'right')Where to place the colorbar for continous variables. If None, no colorbar; is added. size float | Sequence[float] | None (default: None)Point size. If None, is automatically computed as 120000 / n_cells.; Can be a sequence containing the size for each cell. The order should be; the same as in adata.obs. color_map Colormap | str | None (default: None)Color map to use for continous variables. Can be a name or a; Colormap instance (e.g. ""magma”, ""viridis""; or mpl.cm.cividis), see get_cmap().; If None, the value of mpl.rcParams[""image.cmap""] is used.; The default color_map can be set using set_figure_params(). palette str | Sequence[str] | Cycler | None (default: None)Colors to use for plotting categorical annotation groups.; The palette can be a valid ListedColormap name; ('Set2', 'tab20', …), a Cycler object, a dict mapping; categories to colors, or a sequence of colors. Colors must be valid to; matplotlib. (see is_color_like()).; If None, mpl.rcParams[""axes.prop_cycle""] is used unless the ca",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pl.phate.html:13604,variab,variables,13604,en/stable/generated/scanpy.external.pl.phate.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pl.phate.html,8,['variab'],['variables']
Modifiability," 2018-12-01. News#. rapids-singlecell brings scanpy to the GPU! 2024-03-18#; rapids-singlecell by Severin Dicks provides a scanpy-like API with accelerated operations implemented on GPU. Scanpy hits 100 contributors! 2022-03-31#; 100 people have contributed to Scanpy’s source code!; Of course, contributions to the project are not limited to direct modification of the source code.; Many others have improved the project by building on top of it, participating in development discussions, helping others with usage, or by showing off what it’s helped them accomplish.; Thanks to all our contributors for making this project possible!. New community channels 2022-03-31#; We’ve moved our forums and have a new publicly available chat!. Our discourse forum has migrated to a joint scverse forum (discourse.scverse.org).; Our private developer Slack has been replaced by a public Zulip chat (scverse.zulipchat.com). Toolkit for spatial (squidpy) and multimodal (muon) published 2022-02-01#; Two large toolkits extending our ecosystem to new modalities have had their manuscripts published!. Muon, a framework for multimodal has been published in Genome Biology.; Squidpy a toolkit for working with spatial single cell data has been published in Nature Methods. scVelo on the cover of Nature Biotechnology 2020-12-01#; Scanpy’s counterpart for RNA velocity, scVelo, made it on the cover of Nature Biotechnology [tweet]. Scanpy selected among 20 papers for 20 years of Genome Biology 2020-08-01#; Genome Biology: Celebrating 20 Years of Genome Biology selected the initial Scanpy paper for the year 2018 among 20 papers for 20 years [tweet]. COVID-19 datasets distributed as h5ad 2020-04-01#; In a joint initiative, the Wellcome Sanger Institute, the Human Cell Atlas, and the CZI distribute datasets related to COVID-19 via anndata’s h5ad files: covid19cellatlas.org. It wasn’t anticipated that the initial idea of sharing and backing an on-disk representation of AnnData would become so widely adopted. ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/news.html:10900,extend,extending,10900,en/stable/news.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/news.html,1,['extend'],['extending']
Modifiability," Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.pl.scatter. Contents . scatter(). scanpy.pl.scatter#. scanpy.pl.scatter(adata, x=None, y=None, *, color=None, use_raw=None, layers=None, sort_order=True, alpha=None, basis=None, groups=None, components=None, projection='2d', legend_loc='right margin', legend_fontsize=None, legend_fontweight=None, legend_fontoutline=None, color_map=None, palette=None, frameon=None, right_margin=None, left_margin=None, size=None, marker='.', title=None, show=None, save=None, ax=None)[source]#; Scatter plot along observations or variables axes.; Color the plot using annotations of observations (.obs), variables; (.var) or expression of genes (.var_names). Parameters:. adata AnnDataAnnotated data matrix. x str | None (default: None)x coordinate. y str | None (default: None)y coordinate. color str | Collection[str] | None (default: None)Keys for annotations of observations/cells or variables/genes,; or a hex color specification, e.g.,; 'ann1', '#fe57a1', or ['ann1', 'ann2']. use_raw bool | None (default: None)Whether to use raw attribute of adata. Defaults to True if .raw is present. layers str | Collection[str] | None (default: None)Use the layers attribute of adata if present: specify the layer for; x, y and color. If layers is a string, then it is expanded to; (layers, layers, layers). basis Optional[Literal['pca', 'tsne', 'umap', 'diffmap', 'draw_graph_fr']] (default: None)String that denotes a plotting tool that computed coordinates. sort_order bool (default: True)For continuous annotations used as color parameter, plot data points; with higher values on top of others. groups str | Iterable[str] | None (default: None)Restrict to a few categories in categorical observation annotation.; The default is not to restrict to any groups. dimensions0-indexed dimensions of the embedding to plot as integers. E.g. [(0, 1), (1, 2)].; Unlike compone",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pl.scatter.html:10106,variab,variables,10106,en/stable/generated/scanpy.pl.scatter.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pl.scatter.html,1,['variab'],['variables']
Modifiability," Legend. legend_fontsize Union[int, float, Literal['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'], None] (default: None)Numeric size in pt or string describing the size.; See set_fontsize(). legend_fontweight Union[int, Literal['light', 'normal', 'medium', 'semibold', 'bold', 'heavy', 'black'], None] (default: None)Legend font weight. A numeric value in range 0-1000 or a string.; Defaults to 'bold' if legend_loc == 'on data', otherwise to 'normal'.; See set_fontweight(). legend_fontoutline float | None (default: None)Line width of the legend font outline in pt. Draws a white outline using; the path effect withStroke. colorbar_locWhere to place the colorbar for continous variables. If None, no colorbar; is added. size int | float | None (default: None)Point size. If None, is automatically computed as 120000 / n_cells.; Can be a sequence containing the size for each cell. The order should be; the same as in adata.obs. color_map str | Colormap | None (default: None)Color map to use for continous variables. Can be a name or a; Colormap instance (e.g. ""magma”, ""viridis""; or mpl.cm.cividis), see get_cmap().; If None, the value of mpl.rcParams[""image.cmap""] is used.; The default color_map can be set using set_figure_params(). palette Union[Cycler, ListedColormap, str, tuple[float, ...], Sequence[Union[str, tuple[float, ...]]], None] (default: None)Colors to use for plotting categorical annotation groups.; The palette can be a valid ListedColormap name; ('Set2', 'tab20', …), a Cycler object, a dict mapping; categories to colors, or a sequence of colors. Colors must be valid to; matplotlib. (see is_color_like()).; If None, mpl.rcParams[""axes.prop_cycle""] is used unless the categorical; variable already has colors stored in adata.uns[""{var}_colors""].; If provided, values of adata.uns[""{var}_colors""] will be set. na_colorColor to use for null or masked values. Can be anything matplotlib accepts as a; color. Used for all points if color=None. na_in_leg",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pl.scatter.html:12854,variab,variables,12854,en/stable/generated/scanpy.pl.scatter.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pl.scatter.html,1,['variab'],['variables']
Modifiability," True, gene expression is averaged only over the cells; expressing the given genes. standard_scale Optional[Literal['var', 'group']] (default: None)Whether or not to standardize that dimension between 0 and 1,; meaning for each variable or group,; subtract the minimum and divide each by its maximum. kwdsAre passed to matplotlib.pyplot.scatter(). See also. dotplot()Simpler way to call DotPlot but with less options. rank_genes_groups_dotplot()to plot marker genes identified using the rank_genes_groups() function. Examples; >>> import scanpy as sc; >>> adata = sc.datasets.pbmc68k_reduced(); >>> markers = ['C1QA', 'PSAP', 'CD79A', 'CD79B', 'CST3', 'LYZ']; >>> sc.pl.DotPlot(adata, markers, groupby='bulk_labels').show(). Using var_names as dict:; >>> markers = {'T-cell': 'CD3D', 'B-cell': 'CD79A', 'myeloid': 'CST3'}; >>> sc.pl.DotPlot(adata, markers, groupby='bulk_labels').show(). Attributes. DEFAULT_CATEGORY_HEIGHT. DEFAULT_CATEGORY_WIDTH. DEFAULT_COLORMAP. DEFAULT_COLOR_LEGEND_TITLE. DEFAULT_COLOR_ON. DEFAULT_DOT_EDGECOLOR. DEFAULT_DOT_EDGELW. DEFAULT_DOT_MAX. DEFAULT_DOT_MIN. DEFAULT_LARGEST_DOT. DEFAULT_LEGENDS_WIDTH. DEFAULT_PLOT_X_PADDING. DEFAULT_PLOT_Y_PADDING. DEFAULT_SAVE_PREFIX. DEFAULT_SIZE_EXPONENT. DEFAULT_SIZE_LEGEND_TITLE. DEFAULT_SMALLEST_DOT. DEFAULT_WSPACE. MAX_NUM_CATEGORIES. MIN_FIGURE_HEIGHT. Methods. add_dendrogram(*[, show, dendrogram_key, size]). add_totals(*[, show, sort, size, color]). get_axes(). getdoc(). legend(*[, show, show_size_legend, ...]); Configures dot size and the colorbar legends. make_figure(); Renders the image but does not call matplotlib.pyplot.show(). savefig(filename[, bbox_inches]); Save the current figure. show([return_axes]); Show the figure. style(*[, cmap, color_on, dot_max, dot_min, ...]). swap_axes(*[, swap_axes]); Plots a transposed image. previous; scanpy.pl.dendrogram. next; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT. Contents; . DotPlot. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.html:15205,Config,Configures,15205,en/stable/api/generated/classes/scanpy.pl.DotPlot.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.html,1,['Config'],['Configures']
Modifiability," a time. Will eventually replace the components; argument. componentsFor instance, ['1,2', '2,3']. To plot all available components use; components='all'. projectionProjection of plot (default: '2d'). legend_locLocation of legend, either 'on data', 'right margin', None,; or a valid keyword for the loc parameter of Legend. legend_fontsizeNumeric size in pt or string describing the size.; See set_fontsize(). legend_fontweightLegend font weight. A numeric value in range 0-1000 or a string.; Defaults to 'bold' if legend_loc == 'on data', otherwise to 'normal'.; See set_fontweight(). legend_fontoutlineLine width of the legend font outline in pt. Draws a white outline using; the path effect withStroke. colorbar_locWhere to place the colorbar for continous variables. If None, no colorbar; is added. sizePoint size. If None, is automatically computed as 120000 / n_cells.; Can be a sequence containing the size for each cell. The order should be; the same as in adata.obs. color_mapColor map to use for continous variables. Can be a name or a; Colormap instance (e.g. ""magma”, ""viridis""; or mpl.cm.cividis), see get_cmap().; If None, the value of mpl.rcParams[""image.cmap""] is used.; The default color_map can be set using set_figure_params(). paletteColors to use for plotting categorical annotation groups.; The palette can be a valid ListedColormap name; ('Set2', 'tab20', …), a Cycler object, a dict mapping; categories to colors, or a sequence of colors. Colors must be valid to; matplotlib. (see is_color_like()).; If None, mpl.rcParams[""axes.prop_cycle""] is used unless the categorical; variable already has colors stored in adata.uns[""{var}_colors""].; If provided, values of adata.uns[""{var}_colors""] will be set. na_colorColor to use for null or masked values. Can be anything matplotlib accepts as a; color. Used for all points if color=None. na_in_legendIf there are missing values, whether they get an entry in the legend. Currently; only implemented for categorical legends. frameonDra",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pl.pca_overview.html:11151,variab,variables,11151,en/stable/api/generated/scanpy.pl.pca_overview.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pl.pca_overview.html,1,['variab'],['variables']
Modifiability," also align at the bottom of the image and do not shrink if the dotplot image is smaller.; Allow plotting genes in rows and categories in columns (swap_axes).; Using DotPlot, the dot_edge_color and line width can be modified, a grid can be added, and other modifications are enabled.; A new style was added in which the dots are replaced by an empty circle and the square behind the circle is colored (like in matrixplots). stacked_violin() changes:. Violin colors can be colored based on average gene expression as in dotplots.; The linewidth of the violin plots is thinner.; Removed the tics for the y-axis as they tend to overlap with each other. Using the style method they can be displayed if needed. Additions#. concat() is now exported from scanpy, see Concatenation for more info. pr1338 I Virshup; Added highly variable gene selection strategy from Seurat v3 pr1204 A Gayoso; Added CellRank to scanpy ecosystem pr1304 giovp; Added backup_url param to read_10x_h5() pr1296 A Gayoso; Allow prefix for read_10x_mtx() pr1250 G Sturm; Optional tie correction for the 'wilcoxon' method in rank_genes_groups() pr1330 S Rybakov; Use sinfo for print_versions() and add print_header() to do what it previously did. pr1338 I Virshup pr1373. Bug fixes#. Avoid warning in rank_genes_groups() if ‘t-test’ is passed pr1303 A Wolf; Restrict sphinx version to <3.1, >3.0 pr1297 I Virshup; Clean up _ranks and fix dendrogram for scipy 1.5 pr1290 S Rybakov; Use .raw to translate gene symbols if applicable pr1278 E Rice; Fix diffmap (issue1262) G Eraslan; Fix neighbors in spring_project issue1260 S Rybakov; Fix default size of dot in spatial plots pr1255 issue1253 giovp; Bumped version requirement of scipy to scipy>1.4 to support rmatmat argument of LinearOperator issue1246 I Virshup; Fix asymmetry of scores for the 'wilcoxon' method in rank_genes_groups() issue754 S Rybakov; Avoid trimming of gene names in rank_genes_groups() issue753 S Rybakov. Version 1.5#. 1.5.1 2020-05-21#. Bug fixes#. Fixed a bu",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:36129,variab,variable,36129,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,1,['variab'],['variable']
Modifiability," and residuals are clipped to sqrt(n_obs). Finally, genes; are ranked by residual variance.; Expects raw count input. Parameters:. adata AnnDataThe annotated data matrix of shape n_obs × n_vars.; Rows correspond to cells and columns to genes. theta float (default: 100)The negative binomial overdispersion parameter theta for Pearson residuals.; Higher values correspond to less overdispersion (var = mean + mean^2/theta), and theta=np.inf corresponds to a Poisson model. clip float | None (default: None)Determines if and how residuals are clipped:. If None, residuals are clipped to the interval [-sqrt(n_obs), sqrt(n_obs)], where n_obs is the number of cells in the dataset (default behavior).; If any scalar c, residuals are clipped to the interval [-c, c]. Set clip=np.inf for no clipping. n_top_genes int | None (default: None)Number of highly-variable genes to keep. Mandatory if flavor='seurat_v3' or; flavor='pearson_residuals'. batch_key str | None (default: None)If specified, highly-variable genes are selected within each batch separately; and merged. This simple process avoids the selection of batch-specific genes; and acts as a lightweight batch correction method. Genes are first sorted by; how many batches they are a HVG. If flavor='pearson_residuals', ties are; broken by the median rank (across batches) based on within-batch residual; variance. chunksize int (default: 1000)If flavor='pearson_residuals', this dertermines how many genes are processed at; once while computing the residual variance. Choosing a smaller value will reduce; the required memory. flavor Literal['pearson_residuals'] (default: 'pearson_residuals')Choose the flavor for identifying highly variable genes. In this experimental; version, only ‘pearson_residuals’ is functional. check_values bool (default: True)If True, checks if counts in selected layer are integers as expected by this; function, and return a warning if non-integers are found. Otherwise, proceed; without checking. Setting this to Fal",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.highly_variable_genes.html:10872,variab,variable,10872,en/stable/generated/scanpy.experimental.pp.highly_variable_genes.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.highly_variable_genes.html,1,['variab'],['variable']
Modifiability," bool (default: True)Impute data using MAGIC. n_steps int (default: 3)Number of steps in the diffusion operator. Passed to; palantir.utils.run_magic_imputation. copy bool (default: False)Return a copy instead of writing to adata. Return type:; AnnData | None. Returns:; Depending on copy, returns or updates adata with the following fields:. Diffusion maps,used for magic imputation, and to generate multi-scale data matrix,. X_palantir_diff_comp - ndarray (obsm, dtype float)Array of Diffusion components. palantir_EigenValues - ndarray (uns, dtype float)Array of corresponding eigen values. palantir_diff_op - spmatrix (obsp, dtype float)The diffusion operator matrix. Multi scale space results,used to build tsne on diffusion components, and to compute branch probabilities; and waypoints,. X_palantir_multiscale - ndarray (obsm, dtype float)Multi scale data matrix. MAGIC imputation,used for plotting gene expression on tsne, and gene expression trends,. palantir_imp - ndarray (layers, dtype float)Imputed data matrix (MAGIC imputation). Example; >>> import scanpy.external as sce; >>> import scanpy as sc. A sample data is available here.; Load sample data; >>> adata = sc.read_csv(filename=""Palantir/data/marrow_sample_scseq_counts.csv.gz""). Cleanup and normalize; >>> sc.pp.filter_cells(adata, min_counts=1000); >>> sc.pp.filter_genes(adata, min_counts=10); >>> sc.pp.normalize_per_cell(adata); >>> sc.pp.log1p(adata). Data preprocessing; Palantir builds diffusion maps using one of two optional inputs:; Principal component analysis; >>> sc.pp.pca(adata, n_comps=300). or,; Nearist neighbors graph; >>> sc.pp.neighbors(adata, knn=30). Diffusion maps; Palantir determines the diffusion maps of the data as an estimate of the low; dimensional phenotypic manifold of the data.; >>> sce.tl.palantir(adata, n_components=5, knn=30). if pre-computed distances are to be used,; >>> sce.tl.palantir(; ... adata,; ... n_components=5,; ... knn=30,; ... use_adjacency_matrix=True,; ... distances_key=""di",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.palantir.html:11904,layers,layers,11904,en/stable/external/generated/scanpy.external.tl.palantir.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.palantir.html,2,['layers'],['layers']
Modifiability," can take a while to run the whole test suite. There are a few ways to cut down on this while working on a PR:. Only run a subset of the tests.; This can be done by specifying paths or test name patterns using the -k argument (e.g. hatch test test_plotting.py or hatch test -k ""test_umap*""); Run the tests in parallel using the -n argument (e.g. hatch test -n 8). Miscellaneous tips#. A lot of warnings can be thrown while running the test suite.; It’s often easier to read the test results with them hidden via the --disable-pytest-warnings argument. Writing tests#; You can refer to the existing test suite for examples.; If you haven’t written tests before, Software Carpentry has an in-depth testing guide.; We highly recommend using Test-Driven Development when contributing code.; This not only ensures you have tests written, it often makes implementation easier since you start out with a specification for your function.; Consider parameterizing your tests using the pytest.mark.parameterize and pytest.fixture decorators.; You can read more about fixtures in pytest’s documentation, but we’d also recommend searching our test suite for existing usage. What to test#; If you’re not sure what to tests about your function, some ideas include:. Are there arguments which conflict with each other? Check that if they are both passed, the function throws an error (see pytest.raises docs).; Are there input values which should cause your function to error?; Did you add a helpful error message that recommends better outputs? Check that that error message is actually thrown.; Can you place bounds on the values returned by your function?; Are there different input values which should generate equivalent output (e.g. if an array is sparse or dense)?; Do you have arguments which should have orthogonal effects on the output? Check that they are independent. For example, if there is a flag for extended output, the base output should remain the same either way.; Are you optimizing a method? C",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/dev/testing.html:10635,parameteriz,parameterize,10635,en/stable/dev/testing.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/dev/testing.html,1,['parameteriz'],['parameterize']
Modifiability," certain set of genes given by a boolean array; or a string referring to an array in var.; By default, uses .var['highly_variable'] if available, else everything. use_highly_variable bool | None (default: None)Whether to use highly variable genes only, stored in; .var['highly_variable'].; By default uses them if they have been determined beforehand. Deprecated since version 1.10.0: Use mask_var instead. check_values bool (default: True)If True, checks if counts in selected layer are integers as expected by this; function, and return a warning if non-integers are found. Otherwise, proceed; without checking. Setting this to False can speed up code for large datasets. inplace bool (default: True)If True, update adata with results. Otherwise, return results. See below for; details of what is returned. Return type:; AnnData | None. Returns:; If inplace=False, returns the Pearson residual-based PCA results (as AnnData; object). If inplace=True, updates adata with the following fields:. .uns['pearson_residuals_normalization']['pearson_residuals_df']The subset of highly variable genes, normalized by Pearson residuals. .uns['pearson_residuals_normalization']['theta']The used value of the overdisperion parameter theta. .uns['pearson_residuals_normalization']['clip']The used value of the clipping parameter. .obsm['X_pca']PCA representation of data after gene selection (if applicable) and Pearson; residual normalization. .varm['PCs']The principal components containing the loadings. When inplace=True and; use_highly_variable=True, this will contain empty rows for the genes not; selected. .uns['pca']['variance_ratio']Ratio of explained variance. .uns['pca']['variance']Explained variance, equivalent to the eigenvalues of the covariance matrix. previous; scanpy.experimental.pp.normalize_pearson_residuals. next; scanpy.experimental.pp.highly_variable_genes. Contents; . normalize_pearson_residuals_pca(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.normalize_pearson_residuals_pca.html:12243,variab,variable,12243,en/stable/generated/scanpy.experimental.pp.normalize_pearson_residuals_pca.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.normalize_pearson_residuals_pca.html,1,['variab'],['variable']
Modifiability," f:; adata = ad.AnnData(; obs=ad.experimental.read_elem(f[""obs""]),; var=ad.experimental.read_elem(f[""var""]),; ); adata.X = ad.experimental.read_elem_as_dask(; f[""raw/X""], chunks=(SPARSE_CHUNK_SIZE, adata.shape[1]); ). CPU times: user 2.4 s, sys: 673 ms, total: 3.08 s; Wall time: 3.22 s. We’ve optimized a number of scanpy functions to be completely lazy. That means it will look like nothing is computed when you call an operation on a dask array, but only later when you hit compute.; In some cases it’s currently unavoidable to skip all computation, and these cases will kick off compute for all the delayed operations immediately. %%time; adata.layers[""counts""] = adata.X.copy() # Making sure we keep access to the raw counts; sc.pp.normalize_total(adata, target_sum=1e4). CPU times: user 7.1 ms, sys: 31 μs, total: 7.13 ms; Wall time: 7.49 ms. %%time; sc.pp.log1p(adata). CPU times: user 3.14 ms, sys: 2.03 ms, total: 5.17 ms; Wall time: 4.88 ms. Highly variable genes needs to add entries into obs, which currently does not support lazy column. So computation will occur immediately on call. %%time; sc.pp.highly_variable_genes(adata). CPU times: user 3.46 s, sys: 509 ms, total: 3.97 s; Wall time: 50 s. PCA currently does not support sparse data. So we will need to densify the expression matrix before passing it in. However, as we are working with only a subset of the data at a time, we are able to perform this operation with a lower memory overhead.; As this is a still a significant increase in memory usage per chunk, we will need to reduce the number of observations present in each chunk. adata.layers[""dense""] = adata.X.rechunk((DENSE_CHUNK_SIZE, -1)).map_blocks(; lambda x: x.toarray(), dtype=adata.X.dtype, meta=np.array([]); ). %%time; sc.pp.pca(adata, layer=""dense""). CPU times: user 9.31 s, sys: 1.19 s, total: 10.5 s; Wall time: 1min 27s. While most of the PCA computation runs immediately, the last step (computing the observation loadings) is lazy, so must be triggered manua",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/dask.html:14843,variab,variable,14843,en/stable/tutorials/experimental/dask.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/dask.html,2,['variab'],['variable']
Modifiability," high doublet scores. sc.pp.scrublet(adata, batch_key=""sample""). We can remove doublets by either filtering out the cells called as doublets, or waiting until we’ve done a clustering pass and filtering out any clusters with high doublet scores. See also; Alternative methods for doublet detection within the scverse ecosystem are DoubletDetection and SOLO. You can read more about these in the Doublet Detection chapter of Single Cell Best Practices. Normalization#; The next preprocessing step is normalization. A common approach is count depth scaling with subsequent log plus one (log1p) transformation. Count depth scaling normalizes the data to a “size factor” such as the median count depth in the dataset, ten thousand (CP10k) or one million (CPM, counts per million). The size factor for count depth scaling can be controlled via target_sum in pp.normalize_total. We are applying median count depth normalization with log1p transformation (AKA log1PF). # Saving count data; adata.layers[""counts""] = adata.X.copy(). # Normalizing to median total counts; sc.pp.normalize_total(adata); # Logarithmize the data; sc.pp.log1p(adata). Feature selection#; As a next step, we want to reduce the dimensionality of the dataset and only include the most informative genes. This step is commonly known as feature selection. The scanpy function pp.highly_variable_genes annotates highly variable genes by reproducing the implementations of Seurat [Satija et al., 2015], Cell Ranger [Zheng et al., 2017], and Seurat v3 [Stuart et al., 2019] depending on the chosen flavor. sc.pp.highly_variable_genes(adata, n_top_genes=2000, batch_key=""sample""). sc.pl.highly_variable_genes(adata). Dimensionality Reduction#; Reduce the dimensionality of the data by running principal component analysis (PCA), which reveals the main axes of variation and denoises the data. sc.tl.pca(adata). Let us inspect the contribution of single PCs to the total variance in the data. This gives us information about how many PCs we sh",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering.html:14785,layers,layers,14785,en/stable/tutorials/basics/clustering.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering.html,2,['layers'],['layers']
Modifiability," in adata.obsm can be used with the generic function sc.pl.embedding. import scanpy as sc; from matplotlib.pyplot import rc_context. sc.set_figure_params(dpi=100, color_map=""viridis_r""); sc.settings.verbosity = 0; sc.logging.print_header(). scanpy==1.10.0rc2.dev6+g14555ba4.d20240226 anndata==0.11.0.dev78+g64ab900 umap==0.5.5 numpy==1.26.3 scipy==1.11.4 pandas==2.2.0 scikit-learn==1.3.2 statsmodels==0.14.1 igraph==0.10.8 pynndescent==0.5.11. Load pbmc dataset#. pbmc = sc.datasets.pbmc68k_reduced(). # inspect pbmc contents; pbmc. AnnData object with n_obs × n_vars = 700 × 765; obs: 'bulk_labels', 'n_genes', 'percent_mito', 'n_counts', 'S_score', 'G2M_score', 'phase', 'louvain'; var: 'n_counts', 'means', 'dispersions', 'dispersions_norm', 'highly_variable'; uns: 'bulk_labels_colors', 'louvain', 'louvain_colors', 'neighbors', 'pca', 'rank_genes_groups'; obsm: 'X_pca', 'X_umap'; varm: 'PCs'; obsp: 'distances', 'connectivities'. Visualization of gene expression and other variables#; For the scatter plots, the value to plot is given as the color argument. This can be any gene or any column in .obs, where .obs is a DataFrame containing the annotations per observation/cell, see AnnData for more information. # rc_context is used for the figure size, in this case 4x4; with rc_context({""figure.figsize"": (4, 4)}):; sc.pl.umap(pbmc, color=""CD79A""). Multiple values can be given to color. In the following example we will plot 6 genes: ‘CD79A’, ‘MS4A1’, ‘IGJ’, CD3D’, ‘FCER1A’, and ‘FCGR3A’ to get an idea on where those marker genes are being expressed.; Also, we will plot two other values: n_counts which is the number of UMI counts per cell (stored in .obs), and bulk_labels which is a categorical value containing the original labelling of the cells from 10X.; The number of plots per row is controlled using the ncols parameter. The maximum value plotted can be adjusted using vmax (similarly vmin can be used for the minimum value). In this case we use p99, which means to use as max va",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/core.html:12024,variab,variables,12024,en/stable/tutorials/plotting/core.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/core.html,2,['variab'],['variables']
Modifiability," is running pr1844 I Virshup; Fixed reproducibility of scanpy.tl.diffmap() (added random_state) pr1858 I Kucinski; Fixed errors and warnings from embedding plots with small numbers of categories after sns.set_palette was called pr1886 I Virshup; Fixed handling of gene_symbols argument in a number of sc.pl.rank_genes_groups* functions pr1529 F Ramirez I Virshup; Fixed handling of use_raw for sc.tl.rank_genes_groups when no .raw is present pr1895 I Virshup; scanpy.pl.rank_genes_groups_violin() now works for raw=False pr1669 M van den Beek; scanpy.pl.dotplot() now uses smallest_dot argument correctly pr1771 S Flemming. Development Process#. Switched to flit for building and deploying the package, a simple tool with an easy to understand command line interface and metadata pr1527 P Angerer; Use pre-commit for style checks pr1684 pr1848 L Heumos I Virshup. Deprecations#. Dropped support for Python 3.6. More details here. pr1897 I Virshup; Deprecated layers and layers_norm kwargs to normalize_total() pr1667 I Virshup; Deprecated MulticoreTSNE backend for scanpy.tl.tsne() pr1854 I Virshup. Version 1.7#. 1.7.2 2021-04-07#. Bug fixes#. scanpy.logging.print_versions() now works when python<3.8 pr1691 I Virshup; scanpy.pp.regress_out() now uses joblib as the parallel backend, and should stop oversubscribing threads pr1694 I Virshup; scanpy.pp.highly_variable_genes() with flavor=""seurat_v3"" now returns correct gene means and -variances when used with batch_key pr1732 J Lause; scanpy.pp.highly_variable_genes() now throws a warning instead of an error when non-integer values are passed for method ""seurat_v3"". The check can be skipped by passing check_values=False. pr1679 G Palla. Ecosystem#. Added triku a feature selection method to the ecosystem page pr1722 AM Ascensión; Added dorothea and progeny to the ecosystem page pr1767 P Badia-i-Mompel. 1.7.1 2021-02-24#. Documentation#. More twitter handles for core devs pr1676 G Eraslan. Bug fixes#. dendrogram() use 1 - correlation as di",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:28945,layers,layers,28945,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,1,['layers'],['layers']
Modifiability," margin', 'on data', 'on data export', 'best', 'upper right', 'upper left', 'lower left', 'lower right', 'right', 'center left', 'center right', 'lower center', 'upper center', 'center']] (default: 'right margin')Location of legend, either 'on data', 'right margin', None,; or a valid keyword for the loc parameter of Legend. legend_fontsize Union[int, float, Literal['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'], None] (default: None)Numeric size in pt or string describing the size.; See set_fontsize(). legend_fontweight Union[int, Literal['light', 'normal', 'medium', 'semibold', 'bold', 'heavy', 'black'], None] (default: None)Legend font weight. A numeric value in range 0-1000 or a string.; Defaults to 'bold' if legend_loc == 'on data', otherwise to 'normal'.; See set_fontweight(). legend_fontoutline float | None (default: None)Line width of the legend font outline in pt. Draws a white outline using; the path effect withStroke. colorbar_locWhere to place the colorbar for continous variables. If None, no colorbar; is added. size int | float | None (default: None)Point size. If None, is automatically computed as 120000 / n_cells.; Can be a sequence containing the size for each cell. The order should be; the same as in adata.obs. color_map str | Colormap | None (default: None)Color map to use for continous variables. Can be a name or a; Colormap instance (e.g. ""magma”, ""viridis""; or mpl.cm.cividis), see get_cmap().; If None, the value of mpl.rcParams[""image.cmap""] is used.; The default color_map can be set using set_figure_params(). palette Union[Cycler, ListedColormap, str, tuple[float, ...], Sequence[Union[str, tuple[float, ...]]], None] (default: None)Colors to use for plotting categorical annotation groups.; The palette can be a valid ListedColormap name; ('Set2', 'tab20', …), a Cycler object, a dict mapping; categories to colors, or a sequence of colors. Colors must be valid to; matplotlib. (see is_color_like()).; If None, mpl.rcParams[""a",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pl.scatter.html:12525,variab,variables,12525,en/stable/generated/scanpy.pl.scatter.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pl.scatter.html,1,['variab'],['variables']
Modifiability," now transform our raw counts to residuals by calling normalize_pearson_residuals(adata). In our example pipeline, we then apply PCA to reduce the dataset to the most relevant dimensions. We visualize this reduced representation with t-SNE and perform Leiden clustering, which is again taken from the PBMC3k tutorial.; This is just one of many possible pipelines: After PCA, you could also use UMAP or other embeddings to inspect the data, and cluster the data with a different algorithm than Leiden. Preparations#; Because we will transform the raw data in adata.X to residuals in the next step, we first save a copy of the raw counts to adata.layers['raw']. Also, we save a depth-normalized and square-root transformed version of the data to adata.layers['sqrt_norm'], so we can use them for plotting normalized counts later. Further background on why to use the square-root transform here can be found in Wagner (2020). # keep raw and depth-normalized counts for later; adata_pbmc3k.layers[""raw""] = adata_pbmc3k.X.copy(); adata_pbmc3k.layers[""sqrt_norm""] = np.sqrt(; sc.pp.normalize_total(adata_pbmc3k, inplace=False)[""X""]; ). adata_pbmc10k.layers[""raw""] = adata_pbmc10k.X.copy(); adata_pbmc10k.layers[""sqrt_norm""] = np.sqrt(; sc.pp.normalize_total(adata_pbmc10k, inplace=False)[""X""]; ). normalizing counts per cell; finished (0:00:00); normalizing counts per cell; finished (0:00:00). Compute Pearson residuals#; This will transform the sparse raw counts in adata.X to a dense matrix of Pearson residuals. for adata in [adata_pbmc3k, adata_pbmc10k]:; sc.experimental.pp.normalize_pearson_residuals(adata). computing analytic Pearson residuals on adata.X; finished (0:00:00); computing analytic Pearson residuals on adata.X; finished (0:00:00). Compute PCA and t-SNE#; We now reduce the dimensionality of the data by running PCA on the Pearson residuals. On top, we run t-SNE for vizualisation. for adata in [adata_pbmc3k, adata_pbmc10k]:; sc.pp.pca(adata, n_comps=50); n_cells = len(adata); sc.tl.",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:24385,layers,layers,24385,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,2,['layers'],['layers']
Modifiability," of add_* operation decides the order of plotters. But group_rows and group_cols can be called anytime. m = ma.Heatmap(exp, cmap=""viridis"", height=4, width=3); m.group_rows(pbmc.obs[""louvain""], order=uni_cells). m.add_left(; mp.Colors(list(pbmc.obs[""louvain""]), palette=cmapper),; size=0.1,; pad=0.1,; ); m.add_left(mp.Chunk(uni_cells, rotation=0, align=""center"")); m.add_top(mp.Labels(markers), pad=0.1); m.add_dendrogram(""right"", add_base=False). m.add_legends(); m.add_title(""Expression Profile""); m.render(). Now that we’ve covered some basics of Marsilea, we’ll see how it can be used to create custom plots similar to scanpy’s existing methods:. agg = sc.get.aggregate(pbmc[:, markers], by=""louvain"", func=[""mean"", ""count_nonzero""]); agg.obs[""cell_counts""] = pbmc.obs[""louvain""].value_counts(); agg. AnnData object with n_obs × n_vars = 8 × 12; obs: 'louvain', 'cell_counts'; var: 'n_cells'; layers: 'mean', 'count_nonzero'. agg_exp = agg.layers[""mean""]; agg_count = agg.layers[""count_nonzero""]; agg_cell_counts = agg.obs[""cell_counts""].to_numpy(). Matrixplot#. h, w = agg_exp.shape. m = ma.Heatmap(; agg_exp,; height=h / 3,; width=w / 3,; cmap=""Blues"",; linewidth=0.5,; linecolor=""lightgray"",; label=""Expression"",; ); m.add_right(mp.Labels(agg.obs[""louvain""], align=""center""), pad=0.1); m.add_top(mp.Labels(markers), pad=0.1); m.group_cols(cells, order=uni_cells); m.add_top(mp.Chunk(uni_cells, fill_colors=cell_colors, rotation=90)); m.add_left(mp.Numbers(agg_cell_counts, color=""#EEB76B"", label=""Count"")); m.add_dendrogram(""right"", pad=0.1); m.add_legends(); m.render(). Dot plot#. size = agg_count / agg_cell_counts[:, np.newaxis]; m = ma.SizedHeatmap(; size=size,; color=agg_exp,; cluster_data=size,; height=h / 3,; width=w / 3,; edgecolor=""lightgray"",; cmap=""Blues"",; size_legend_kws=dict(; colors=""#538bbf"",; title=""Fraction of cells\nin groups (%)"",; labels=[""20%"", ""40%"", ""60%"", ""80%"", ""100%""],; show_at=[0.2, 0.4, 0.6, 0.8, 1.0],; ),; color_legend_kws=dict(title=""Mean expression\nin g",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/how-to/plotting-with-marsilea.html:13636,layers,layers,13636,en/stable/how-to/plotting-with-marsilea.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/how-to/plotting-with-marsilea.html,1,['layers'],['layers']
Modifiability," of nearest neighbors to be searched. If knn; is False, a Gaussian kernel width is set to the distance of the; n_neighbors neighbor.; ignored if ``transformer`` is an instance. n_pcs int | None (default: None)Use this many PCs. If n_pcs==0 use .X if use_rep is None. use_rep str | None (default: None)Use the indicated representation. 'X' or any key for .obsm is valid.; If None, the representation is chosen automatically:; For .n_vars < N_PCS (default: 50), .X is used, otherwise ‘X_pca’ is used.; If ‘X_pca’ is not present, it’s computed with default parameters or n_pcs if present. knn bool (default: True)If True, use a hard threshold to restrict the number of neighbors to; n_neighbors, that is, consider a knn graph. Otherwise, use a Gaussian; Kernel to assign low weights to neighbors more distant than the; n_neighbors nearest neighbor. method Literal['umap', 'gauss'] (default: 'umap')Use ‘umap’ [McInnes et al., 2018] or ‘gauss’ (Gauss kernel following Coifman et al. [2005]; with adaptive width Haghverdi et al. [2016]) for computing connectivities. transformer Union[KnnTransformerLike, Literal['pynndescent', 'sklearn', 'rapids'], None] (default: None)Approximate kNN search implementation following the API of; KNeighborsTransformer.; See Using other kNN libraries in Scanpy for more details.; Also accepts the following known options:. None (the default)Behavior depends on data size.; For small data, we will calculate exact kNN, otherwise we use; PyNNDescentTransformer. 'pynndescent'PyNNDescentTransformer. 'rapids'A transformer based on cuml.neighbors.NearestNeighbors. Deprecated since version 1.10.0: Use rapids_singlecell.pp.neighbors() instead. metric Union[Literal['cityblock', 'cosine', 'euclidean', 'l1', 'l2', 'manhattan'], Literal['braycurtis', 'canberra', 'chebyshev', 'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski', 'mahalanobis', 'minkowski', 'rogerstanimoto', 'russellrao', 'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean', 'yule'], Callable[[ndar",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pp.neighbors.html:11354,adapt,adaptive,11354,en/stable/api/generated/scanpy.pp.neighbors.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pp.neighbors.html,1,['adapt'],['adaptive']
Modifiability," scanpy.external.pl.phate. Contents . phate(). scanpy.external.pl.phate#. scanpy.external.pl.phate(adata, *, color=None, mask_obs=None, gene_symbols=None, use_raw=None, sort_order=True, edges=False, edges_width=0.1, edges_color='grey', neighbors_key=None, arrows=False, arrows_kwds=None, groups=None, components=None, dimensions=None, layer=None, projection='2d', scale_factor=None, color_map=None, cmap=None, palette=None, na_color='lightgray', na_in_legend=True, size=None, frameon=None, legend_fontsize=None, legend_fontweight='bold', legend_loc='right margin', legend_fontoutline=None, colorbar_loc='right', vmax=None, vmin=None, vcenter=None, norm=None, add_outline=False, outline_width=(0.3, 0.05), outline_color=('black', 'white'), ncols=4, hspace=0.25, wspace=None, title=None, show=None, save=None, ax=None, return_fig=None, marker='.', **kwargs)[source]#; Scatter plot in PHATE basis. Parameters:. adata AnnDataAnnotated data matrix. color str | Sequence[str] | None (default: None)Keys for annotations of observations/cells or variables/genes, e.g.,; 'ann1' or ['ann1', 'ann2']. gene_symbols str | None (default: None)Column name in .var DataFrame that stores gene symbols. By default var_names; refer to the index column of the .var DataFrame. Setting this option allows; alternative names to be used. use_raw bool | None (default: None)Use .raw attribute of adata for coloring with gene expression. If None,; defaults to True if layer isn’t provided and adata.raw is present. layer str | None (default: None)Name of the AnnData object layer that wants to be plotted. By default; adata.raw.X is plotted. If use_raw=False is set, then adata.X is plotted.; If layer is set to a valid layer name, then the layer is plotted. layer; takes precedence over use_raw. edges bool (default: False)Show edges. edges_width float (default: 0.1)Width of edges. edges_color str | Sequence[float] | Sequence[str] (default: 'grey')Color of edges. See draw_networkx_edges(). neighbors_key str | None (defaul",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pl.phate.html:10270,variab,variables,10270,en/stable/generated/scanpy.external.pl.phate.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pl.phate.html,1,['variab'],['variables']
Modifiability," scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.datasets.pbmc68k_reduced. Contents . pbmc68k_reduced(). scanpy.datasets.pbmc68k_reduced#. scanpy.datasets.pbmc68k_reduced()[source]#; Subsampled and processed 68k PBMCs.; PBMC 68k dataset from 10x Genomics.; The original PBMC 68k dataset was preprocessed with steps including; normalize_total()[1] and scale().; It was saved keeping only 724 cells and 221 highly variable genes.; The saved file contains the annotation of cell types (key: 'bulk_labels'),; UMAP coordinates, louvain clustering and gene rankings based on the; bulk_labels. [1]; Back when the dataset was created, normalize_per_cell() was used instead. Return type:; AnnData. Returns:; Annotated data matrix. Examples; >>> import scanpy as sc; >>> sc.datasets.pbmc68k_reduced(); AnnData object with n_obs × n_vars = 700 × 765; obs: 'bulk_labels', 'n_genes', 'percent_mito', 'n_counts', 'S_score', 'G2M_score', 'phase', 'louvain'; var: 'n_counts', 'means', 'dispersions', 'dispersions_norm', 'highly_variable'; uns: 'bulk_labels_colors', 'louvain', 'louvain_colors', 'neighbors', 'pca', 'rank_genes_groups'; obsm: 'X_pca', 'X_umap'; varm: 'PCs'; obsp: 'distances', 'connectivities'. previous; scanpy.datasets.pbmc3k_processed. next; scanpy.datasets.paul15. Contents; . pbmc68k_reduced(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.datasets.pbmc68k_reduced.html:9610,variab,variable,9610,en/stable/generated/scanpy.datasets.pbmc68k_reduced.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.datasets.pbmc68k_reduced.html,1,['variab'],['variable']
Modifiability," subset A Wolf. 1.3.5 2018-12-09#. uncountable figure improvements pr369 F Ramirez. 1.3.4 2018-11-24#. leiden() wraps the recent graph clustering package by Traag et al. [2019] K Polanski; bbknn() wraps the recent batch correction package [Polański et al., 2019] K Polanski; calculate_qc_metrics() caculates a number of quality control metrics, similar to calculateQCMetrics from Scater [McCarthy et al., 2017] I Virshup. 1.3.3 2018-11-05#. Major updates#. a fully distributed preprocessing backend T White and the Laserson Lab. Code design#. read_10x_h5() and read_10x_mtx() read Cell Ranger 3.0 outputs pr334 Q Gong. Note; Also see changes in anndata 0.6. changed default compression to None in write_h5ad() to speed up read and write, disk space use is usually less critical; performance gains in write_h5ad() due to better handling of strings and categories S Rybakov. 1.3.1 2018-09-03#. RNA velocity in single cells [La Manno et al., 2018]#. Scanpy and AnnData support loom’s layers so that computations for single-cell RNA velocity [La Manno et al., 2018] become feasible S Rybakov and V Bergen; scvelo harmonizes with Scanpy and is able to process loom files with splicing information produced by Velocyto [La Manno et al., 2018], it runs a lot faster than the count matrix analysis of Velocyto and provides several conceptual developments. Plotting (Generic)#. dotplot() for visualizing genes across conditions and clusters, see here pr199 F Ramirez; heatmap() for pretty heatmaps pr175 F Ramirez; violin() produces very compact overview figures with many panels pr175 F Ramirez. There now is a section on imputation in external:#. magic() for imputation using data diffusion [van Dijk et al., 2018] pr187 S Gigante; dca() for imputation and latent space construction using an autoencoder [Eraslan et al., 2019] pr186 G Eraslan. Version 1.2#. 1.2.1 2018-06-08#. Plotting of Generic marker genes and quality control.#. highest_expr_genes() for quality control; plot genes with highest mean fra",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:46010,layers,layers,46010,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,1,['layers'],['layers']
Modifiability," the number of cells in the dataset (default behavior).; If any scalar c, residuals are clipped to the interval [-c, c]. Set clip=np.inf for no clipping. n_top_genes int | None (default: None)Number of highly-variable genes to keep. Mandatory if flavor='seurat_v3' or; flavor='pearson_residuals'. batch_key str | None (default: None)If specified, highly-variable genes are selected within each batch separately; and merged. This simple process avoids the selection of batch-specific genes; and acts as a lightweight batch correction method. Genes are first sorted by; how many batches they are a HVG. If flavor='pearson_residuals', ties are; broken by the median rank (across batches) based on within-batch residual; variance. chunksize int (default: 1000)If flavor='pearson_residuals', this dertermines how many genes are processed at; once while computing the residual variance. Choosing a smaller value will reduce; the required memory. flavor Literal['pearson_residuals'] (default: 'pearson_residuals')Choose the flavor for identifying highly variable genes. In this experimental; version, only ‘pearson_residuals’ is functional. check_values bool (default: True)If True, checks if counts in selected layer are integers as expected by this; function, and return a warning if non-integers are found. Otherwise, proceed; without checking. Setting this to False can speed up code for large datasets. layer str | None (default: None)Layer to use as input instead of X. If None, X is used. subset bool (default: False)If True, subset the data to highly-variable genes after finding them.; Otherwise merely indicate highly variable genes in adata.var (see below). inplace bool (default: True)If True, update adata with results. Otherwise, return results. See below for; details of what is returned. Return type:; DataFrame | None. Returns:; If inplace=True, adata.var is updated with the following fields. Otherwise,; returns the same fields as DataFrame. highly_variableboolboolean indicator of highly-",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.highly_variable_genes.html:11565,variab,variable,11565,en/stable/generated/scanpy.experimental.pp.highly_variable_genes.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.highly_variable_genes.html,1,['variab'],['variable']
Modifiability,"'zinb-conddisp', 'zinb', 'nb-conddisp', 'nb'] (default: 'nb-conddisp')Type of the autoencoder. Return values and the architecture is; determined by the type e.g. nb does not provide dropout; probabilities. Types that end with “-conddisp”, assumes that dispersion is mean dependant. normalize_per_cell bool (default: True)If true, library size normalization is performed using; the sc.pp.normalize_per_cell function in Scanpy and saved into adata; object. Mean layer is re-introduces library size differences by; scaling the mean value of each cell in the output layer. See the; manuscript for more details. scale bool (default: True)If true, the input of the autoencoder is centered using; sc.pp.scale function of Scanpy. Note that the output is kept as raw; counts as loss functions are designed for the count data. log1p bool (default: True)If true, the input of the autoencoder is log transformed with a; pseudocount of one using sc.pp.log1p function of Scanpy. hidden_size Sequence[int] (default: (64, 32, 64))Width of hidden layers. hidden_dropout float | Sequence[float] (default: 0.0)Probability of weight dropout in the autoencoder (per layer if list; or tuple). batchnorm bool (default: True)If true, batch normalization is performed. activation str (default: 'relu')Activation function of hidden layers. init str (default: 'glorot_uniform')Initialization method used to initialize weights. network_kwds Mapping[str, Any] (default: mappingproxy({}))Additional keyword arguments for the autoencoder. epochs int (default: 300)Number of total epochs in training. reduce_lr int (default: 10)Reduces learning rate if validation loss does not improve in given number of epochs. early_stop int (default: 15)Stops training if validation loss does not improve in given number of epochs. batch_size int (default: 32)Number of samples in the batch used for SGD. optimizer str (default: 'RMSprop')Type of optimization method used for training. random_state Union[int, RandomState, None] (default: 0)Seed ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.dca.html:11508,layers,layers,11508,en/stable/generated/scanpy.external.pp.dca.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.dca.html,1,['layers'],['layers']
Modifiability,"(default: 'X_pca')The name of the field in adata.obsm where the PCA table is; stored. Defaults to 'X_pca', which is the default for; sc.pp.pca(). adjusted_basis str (default: 'X_scanorama')The name of the field in adata.obsm where the integrated; embeddings will be stored after running this function. Defaults; to X_scanorama. knn int (default: 20)Number of nearest neighbors to use for matching. sigma float (default: 15)Correction smoothing parameter on Gaussian kernel. approx bool (default: True)Use approximate nearest neighbors with Python annoy;; greatly speeds up matching runtime. alpha float (default: 0.1)Alignment score minimum cutoff. batch_size int (default: 5000)The batch size used in the alignment vector computation. Useful; when integrating very large (>100k samples) datasets. Set to; large value that runs within available memory. kwargsAny additional arguments will be passed to; scanorama.assemble(). Return type:; None. Returns:; Updates adata with the field adata.obsm[adjusted_basis],; containing Scanorama embeddings such that different experiments; are integrated. Example; First, load libraries and example dataset, and preprocess.; >>> import scanpy as sc; >>> import scanpy.external as sce; >>> adata = sc.datasets.pbmc3k(); >>> sc.pp.recipe_zheng17(adata); >>> sc.pp.pca(adata). We now arbitrarily assign a batch metadata variable to each cell; for the sake of example, but during real usage there would already; be a column in adata.obs giving the experiment each cell came; from.; >>> adata.obs['batch'] = 1350*['a'] + 1350*['b']. Finally, run Scanorama. Afterwards, there will be a new table in; adata.obsm containing the Scanorama embeddings.; >>> sce.pp.scanorama_integrate(adata, 'batch', verbose=1); Processing datasets a <=> b; >>> 'X_scanorama' in adata.obsm; True. previous; scanpy.external.pp.mnn_correct. next; scanpy.external.pp.hashsolo. Contents; . scanorama_integrate(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.scanorama_integrate.html:11510,variab,variable,11510,en/stable/generated/scanpy.external.pp.scanorama_integrate.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.scanorama_integrate.html,1,['variab'],['variable']
Modifiability,") rank, with ties broken by the number of batches a gene is a HVG.; For flavor='seurat_v3_paper', genes are first sorted by the number of batches a gene is a HVG, with ties broken by the median (across batches) rank.; The following may help when comparing to Seurat’s naming:; If batch_key=None and flavor='seurat', this mimics Seurat’s FindVariableFeatures(…, method='mean.var.plot').; If batch_key=None and flavor='seurat_v3'/flavor='seurat_v3_paper', this mimics Seurat’s FindVariableFeatures(..., method='vst').; If batch_key is not None and flavor='seurat_v3_paper', this mimics Seurat’s SelectIntegrationFeatures.; See also scanpy.experimental.pp._highly_variable_genes for additional flavors; (e.g. Pearson residuals). Parameters:. adata AnnDataThe annotated data matrix of shape n_obs × n_vars. Rows correspond; to cells and columns to genes. layer str | None (default: None)If provided, use adata.layers[layer] for expression values instead of adata.X. n_top_genes int | None (default: None)Number of highly-variable genes to keep. Mandatory if flavor='seurat_v3'. min_mean float (default: 0.0125)If n_top_genes unequals None, this and all other cutoffs for the means and the; normalized dispersions are ignored. Ignored if flavor='seurat_v3'. max_mean float (default: 3)If n_top_genes unequals None, this and all other cutoffs for the means and the; normalized dispersions are ignored. Ignored if flavor='seurat_v3'. min_disp float (default: 0.5)If n_top_genes unequals None, this and all other cutoffs for the means and the; normalized dispersions are ignored. Ignored if flavor='seurat_v3'. max_disp float (default: inf)If n_top_genes unequals None, this and all other cutoffs for the means and the; normalized dispersions are ignored. Ignored if flavor='seurat_v3'. span float (default: 0.3)The fraction of the data (cells) used when estimating the variance in the loess; model fit if flavor='seurat_v3'. n_bins int (default: 20)Number of bins for binning the mean gene expression. Normal",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.highly_variable_genes.html:12025,variab,variable,12025,en/stable/generated/scanpy.pp.highly_variable_genes.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.highly_variable_genes.html,1,['variab'],['variable']
Modifiability,")[source]#; Run Diffusion maps using the adaptive anisotropic kernel [Setty et al., 2019].; Palantir is an algorithm to align cells along differentiation trajectories.; Palantir models differentiation as a stochastic process where stem cells; differentiate to terminally differentiated cells by a series of steps through; a low dimensional phenotypic manifold. Palantir effectively captures the; continuity in cell states and the stochasticity in cell fate determination.; Palantir has been designed to work with multidimensional single cell data; from diverse technologies such as Mass cytometry and single cell RNA-seq. Note; More information and bug reports here. Parameters:. adata AnnDataAn AnnData object. n_components int (default: 10)Number of diffusion components. knn int (default: 30)Number of nearest neighbors for graph construction. alpha float (default: 0)Normalization parameter for the diffusion operator. use_adjacency_matrix bool (default: False)Use adaptive anisotropic adjacency matrix, instead of PCA projections; (default) to compute diffusion components. distances_key str | None (default: None)With use_adjacency_matrix=True, use the indicated distances key for .obsp.; If None, 'distances'. n_eigs int | None (default: None)Number of eigen vectors to use. If None specified, the number of eigen; vectors will be determined using eigen gap. Passed to; palantir.utils.determine_multiscale_space. impute_data bool (default: True)Impute data using MAGIC. n_steps int (default: 3)Number of steps in the diffusion operator. Passed to; palantir.utils.run_magic_imputation. copy bool (default: False)Return a copy instead of writing to adata. Return type:; AnnData | None. Returns:; Depending on copy, returns or updates adata with the following fields:. Diffusion maps,used for magic imputation, and to generate multi-scale data matrix,. X_palantir_diff_comp - ndarray (obsm, dtype float)Array of Diffusion components. palantir_EigenValues - ndarray (uns, dtype float)Array of corr",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.palantir.html:10459,adapt,adaptive,10459,en/stable/external/generated/scanpy.external.tl.palantir.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.palantir.html,2,['adapt'],['adaptive']
Modifiability,", axes = plt.subplots(1, 2, figsize=(12, 6)); for ax, adata in zip(axes, [adata_pbmc3k, adata_pbmc10k]):; hvgs = adata.var[""highly_variable""]. ax.scatter(; adata.var[""mean_counts""], adata.var[""residual_variances""], s=3, edgecolor=""none""; ); ax.scatter(; adata.var[""mean_counts""][hvgs],; adata.var[""residual_variances""][hvgs],; c=""tab:red"",; label=""selected genes"",; s=3,; edgecolor=""none"",; ); ax.scatter(; adata.var[""mean_counts""][np.isin(adata.var_names, markers)],; adata.var[""residual_variances""][np.isin(adata.var_names, markers)],; c=""k"",; label=""known marker genes"",; s=10,; edgecolor=""none"",; ); ax.set_xscale(""log""); ax.set_xlabel(""mean expression""); ax.set_yscale(""log""); ax.set_ylabel(""residual variance""); ax.set_title(adata.uns[""name""]). ax.spines[""right""].set_visible(False); ax.spines[""top""].set_visible(False); ax.yaxis.set_ticks_position(""left""); ax.xaxis.set_ticks_position(""bottom""); plt.legend(). <matplotlib.legend.Legend at 0x15859b150>. Apply gene selection#; We subset both datasets to retain just the variable genes. adata_pbmc3k = adata_pbmc3k[:, adata_pbmc3k.var[""highly_variable""]]; adata_pbmc10k = adata_pbmc10k[:, adata_pbmc10k.var[""highly_variable""]]. Print resulting adata objects#. adata_pbmc3k. View of AnnData object with n_obs × n_vars = 2574 × 2000; obs: 'n_genes', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'outlier_mt', 'outlier_total', 'outlier_ngenes'; var: 'gene_ids', 'n_cells', 'mt', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'means', 'variances', 'residual_variances', 'highly_variable_rank', 'highly_variable'; uns: 'name', 'hvg'. adata_pbmc10k. View of AnnData object with n_obs × n_vars = 10968 × 2000; obs: 'n_genes', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'outlier_mt', 'outlier_total', 'outlier_ngenes'; var: 'gene_ids', 'feature_types', 'n_cells', 'mt', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'means', 'varianc",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:20899,variab,variable,20899,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,2,['variab'],['variable']
Modifiability,", legend_fontsize=None, legend_fontweight=None, legend_fontoutline=None, color_map=None, palette=None, frameon=None, right_margin=None, left_margin=None, size=None, marker='.', title=None, show=None, save=None, ax=None)[source]#; Scatter plot along observations or variables axes.; Color the plot using annotations of observations (.obs), variables; (.var) or expression of genes (.var_names). Parameters:. adata AnnDataAnnotated data matrix. x str | None (default: None)x coordinate. y str | None (default: None)y coordinate. color str | Collection[str] | None (default: None)Keys for annotations of observations/cells or variables/genes,; or a hex color specification, e.g.,; 'ann1', '#fe57a1', or ['ann1', 'ann2']. use_raw bool | None (default: None)Whether to use raw attribute of adata. Defaults to True if .raw is present. layers str | Collection[str] | None (default: None)Use the layers attribute of adata if present: specify the layer for; x, y and color. If layers is a string, then it is expanded to; (layers, layers, layers). basis Optional[Literal['pca', 'tsne', 'umap', 'diffmap', 'draw_graph_fr']] (default: None)String that denotes a plotting tool that computed coordinates. sort_order bool (default: True)For continuous annotations used as color parameter, plot data points; with higher values on top of others. groups str | Iterable[str] | None (default: None)Restrict to a few categories in categorical observation annotation.; The default is not to restrict to any groups. dimensions0-indexed dimensions of the embedding to plot as integers. E.g. [(0, 1), (1, 2)].; Unlike components, this argument is used in the same way as colors, e.g. is; used to specify a single plot at a time. Will eventually replace the components; argument. components str | Collection[str] | None (default: None)For instance, ['1,2', '2,3']. To plot all available components use; components='all'. projection Literal['2d', '3d'] (default: '2d')Projection of plot (default: '2d'). legend_loc Optional[Lite",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pl.scatter.html:10451,layers,layers,10451,en/stable/generated/scanpy.pl.scatter.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pl.scatter.html,4,['layers'],['layers']
Modifiability,", max_mean=3, span=0.3, n_bins=20, flavor='seurat', subset=False, inplace=True, batch_key=None, check_values=True)[source]#; Annotate highly variable genes [Satija et al., 2015, Stuart et al., 2019, Zheng et al., 2017].; Expects logarithmized data, except when flavor='seurat_v3'/'seurat_v3_paper', in which count; data is expected.; Depending on flavor, this reproduces the R-implementations of Seurat; [Satija et al., 2015], Cell Ranger [Zheng et al., 2017], and Seurat v3 [Stuart et al., 2019].; 'seurat_v3'/'seurat_v3_paper' requires scikit-misc package. If you plan to use this flavor, consider; installing scanpy with this optional dependency: scanpy[skmisc].; For the dispersion-based methods (flavor='seurat' Satija et al. [2015] and; flavor='cell_ranger' Zheng et al. [2017]), the normalized dispersion is obtained; by scaling with the mean and standard deviation of the dispersions for genes; falling into a given bin for mean expression of genes. This means that for each; bin of mean expression, highly variable genes are selected.; For flavor='seurat_v3'/'seurat_v3_paper' [Stuart et al., 2019], a normalized variance for each gene; is computed. First, the data are standardized (i.e., z-score normalization; per feature) with a regularized standard deviation. Next, the normalized variance; is computed as the variance of each gene after the transformation. Genes are ranked; by the normalized variance.; Only if batch_key is not None, the two flavors differ: For flavor='seurat_v3', genes are first sorted by the median (across batches) rank, with ties broken by the number of batches a gene is a HVG.; For flavor='seurat_v3_paper', genes are first sorted by the number of batches a gene is a HVG, with ties broken by the median (across batches) rank.; The following may help when comparing to Seurat’s naming:; If batch_key=None and flavor='seurat', this mimics Seurat’s FindVariableFeatures(…, method='mean.var.plot').; If batch_key=None and flavor='seurat_v3'/flavor='seurat_v3_pape",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.highly_variable_genes.html:10473,variab,variable,10473,en/stable/generated/scanpy.pp.highly_variable_genes.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.highly_variable_genes.html,1,['variab'],['variable']
Modifiability,", min_mean=None, max_mean=None, n_bins=20, n_top_genes=None, log=True, subset=True, copy=False)[source]#; Extract highly variable genes [Satija et al., 2015, Zheng et al., 2017]. Warning. Deprecated since version 1.3.6: Use highly_variable_genes(); instead. The new function is equivalent to the present; function, except that. the new function always expects logarithmized data; subset=False in the new function, it suffices to; merely annotate the genes, tools like pp.pca will; detect the annotation; you can now call: sc.pl.highly_variable_genes(adata); copy is replaced by inplace. If trying out parameters, pass the data matrix instead of AnnData.; Depending on flavor, this reproduces the R-implementations of Seurat; [Satija et al., 2015] and Cell Ranger [Zheng et al., 2017].; The normalized dispersion is obtained by scaling with the mean and standard; deviation of the dispersions for genes falling into a given bin for mean; expression of genes. This means that for each bin of mean expression, highly; variable genes are selected.; Use flavor='cell_ranger' with care and in the same way as in; recipe_zheng17(). Parameters:. data AnnData | spmatrix | ndarrayThe (annotated) data matrix of shape n_obs × n_vars. Rows correspond; to cells and columns to genes. flavor Literal['seurat', 'cell_ranger'] (default: 'seurat')Choose the flavor for computing normalized dispersion. If choosing; ‘seurat’, this expects non-logarithmized data – the logarithm of mean; and dispersion is taken internally when log is at its default value; True. For ‘cell_ranger’, this is usually called for logarithmized data; – in this case you should set log to False. In their default; workflows, Seurat passes the cutoffs whereas Cell Ranger passes; n_top_genes. min_mean float | None (default: None). max_mean float | None (default: None). min_disp float | None (default: None). max_disp float | None (default: None)If n_top_genes unequals None, these cutoffs for the means and the; normalized dispersions are i",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.filter_genes_dispersion.html:10454,variab,variable,10454,en/stable/generated/scanpy.pp.filter_genes_dispersion.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.filter_genes_dispersion.html,1,['variab'],['variable']
Modifiability,",; ). <Axes: xlabel='n_genes_by_counts', ylabel='Count'>. sc.pp.filter_cells(adata, min_counts=5000); sc.pp.filter_cells(adata, max_counts=35000); adata = adata[adata.obs[""pct_counts_mt""] < 20].copy(); print(f""#cells after MT filter: {adata.n_obs}""); sc.pp.filter_genes(adata, min_cells=10). filtered out 44 cells that have less than 5000 counts; filtered out 130 cells that have more than 35000 counts; #cells after MT filter: 3861; filtered out 16916 genes that are detected in less than 10 cells. We proceed to normalize Visium counts data with the built-in normalize_total method from Scanpy, and detect highly-variable genes (for later). Note that there are alternatives for normalization (see discussion in [Luecken19], and more recent alternatives such as SCTransform or GLM-PCA). sc.pp.normalize_total(adata, inplace=True); sc.pp.log1p(adata); sc.pp.highly_variable_genes(adata, flavor=""seurat"", n_top_genes=2000). normalizing counts per cell; finished (0:00:00); extracting highly variable genes; finished (0:00:00); --> added; 'highly_variable', boolean vector (adata.var); 'means', float vector (adata.var); 'dispersions', float vector (adata.var); 'dispersions_norm', float vector (adata.var). Manifold embedding and clustering based on transcriptional similarity#; To embed and cluster the manifold encoded by transcriptional similarity, we proceed as in the standard clustering tutorial. sc.pp.pca(adata); sc.pp.neighbors(adata); sc.tl.umap(adata); sc.tl.leiden(; adata, key_added=""clusters"", flavor=""igraph"", directed=False, n_iterations=2; ). computing PCA; with n_comps=50; finished (0:00:30); computing neighbors; using 'X_pca' with n_pcs = 50; finished: added to `.uns['neighbors']`; `.obsp['distances']`, distances for each pair of neighbors; `.obsp['connectivities']`, weighted adjacency matrix (0:00:05); computing UMAP; finished: added; 'X_umap', UMAP coordinates (adata.obsm) (0:00:12); running Leiden clustering; finished: found 10 clusters and added; 'clusters', the cluster",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/basic-analysis.html:15286,variab,variable,15286,en/stable/tutorials/spatial/basic-analysis.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/basic-analysis.html,2,['variab'],['variable']
Modifiability,".1 2019-04-26#. New functionality#. Scanpy has a command line interface again. Invoking it with scanpy somecommand [args] calls scanpy-somecommand [args], except for builtin commands (currently scanpy settings) pr604 P Angerer; ebi_expression_atlas() allows convenient download of EBI expression atlas I Virshup; marker_gene_overlap() computes overlaps of marker genes M Luecken; filter_rank_genes_groups() filters out genes based on fold change and fraction of cells expressing genes F Ramirez; normalize_total() replaces normalize_per_cell(), is more efficient and provides a parameter to only normalize using a fraction of expressed genes S Rybakov; downsample_counts() has been sped up, changed default value of replace parameter to False pr474 I Virshup; embedding_density() computes densities on embeddings pr543 M Luecken; palantir() interfaces Palantir [Setty et al., 2019] pr493 A Mousa. Code design#. .layers support of scatter plots F Ramirez; fix double-logarithmization in compute of log fold change in rank_genes_groups() A Muñoz-Rojas; fix return sections of docs P Angerer. Version 1.3#. 1.3.8 2019-02-05#. various documentation and dev process improvements; Added combat() function for batch effect correction [Johnson et al., 2006, Leek et al., 2017, Pedersen, 2012] pr398 M Lange. 1.3.7 2019-01-02#. API changed from import scanpy as sc to import scanpy.api as sc.; phenograph() wraps the graph clustering package Phenograph [Levine et al., 2015] thanks to A Mousa. 1.3.6 2018-12-11#. Major updates#. a new plotting gallery for visualizing-marker-genes F Ramirez; tutorials are integrated on ReadTheDocs, pbmc3k and paga-paul15 A Wolf. Interactive exploration of analysis results through manifold viewers#. CZI’s cellxgene directly reads .h5ad files the cellxgene developers; the UCSC Single Cell Browser requires exporting via cellbrowser() M Haeussler. Code design#. highly_variable_genes() supersedes filter_genes_dispersion(), it gives the same results but, by default, expects ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:43910,layers,layers,43910,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,1,['layers'],['layers']
Modifiability,".; Sequences (like list),; Iterables (like set), and; Mappings (like dict).; Always specify what these contain, e.g. {'a': (1, 2)} → Mapping[str, Tuple[int, int]].; If you can’t use one of those, use a concrete class like AnnData.; If your parameter only accepts an enumeration of strings, specify them like so: Literal['elem-1', 'elem-2']. Returns section#; There are three types of return sections – prose, tuple, and a mix of both. Prose is for simple cases.; Tuple return sections are formatted like parameters. Other than in numpydoc, each tuple is first characterized by the identifier and not by its type. Provide type annotation in the function header.; Mix of prose and tuple is relevant in complicated cases, e.g. when you want to describe that you added something as annotation to an `AnnData` object. Examples#; For simple cases, use prose as in normalize_total():; Returns; -------; Returns dictionary with normalized copies of `adata.X` and `adata.layers`; or updates `adata` with normalized versions of the original; `adata.X` and `adata.layers`, depending on `inplace`. For tuple return values, you can use the standard numpydoc way of populating it,; e.g. as in calculate_qc_metrics().; Do not add types in the docstring, but specify them in the function signature:; def myfunc(...) -> tuple[int, str]:; """"""; ...; Returns; -------; one_identifier; Description.; second_identifier; Description 2.; """"""; ... Many functions also just modify parts of the passed AnnData object, like e.g. dpt().; You can then combine prose and lists to best describe what happens:; Returns; -------; Depending on `copy`, returns or updates `adata` with the following fields. If `n_branchings==0`, no field `dpt_groups` will be written. dpt_pseudotime : :class:`~pandas.Series` (`adata.obs`, dtype `float`); Array of dim (number of samples) that stores the pseudotime of each; cell, that is, the DPT distance with respect to the root cell.; dpt_groups : :class:`pandas.Series` (`adata.obs`, dtype `category",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/dev/documentation.html:13815,layers,layers,13815,en/stable/dev/documentation.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/dev/documentation.html,1,['layers'],['layers']
Modifiability,".external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.pp.normalize_per_cell. Contents . normalize_per_cell(). scanpy.pp.normalize_per_cell#. scanpy.pp.normalize_per_cell(data, *, counts_per_cell_after=None, counts_per_cell=None, key_n_counts='n_counts', copy=False, layers=(), use_rep=None, min_counts=1)[source]#; Normalize total counts per cell. Warning. Deprecated since version 1.3.7: Use normalize_total() instead.; The new function is equivalent to the present; function, except that. the new function doesn’t filter cells based on min_counts,; use filter_cells() if filtering is needed.; some arguments were renamed; copy is replaced by inplace. Normalize each cell by total counts over all genes, so that every cell has; the same total count after normalization.; Similar functions are used, for example, by Seurat [Satija et al., 2015], Cell Ranger; [Zheng et al., 2017] or SPRING [Weinreb et al., 2017]. Parameters:. data AnnData | ndarray | spmatrixThe (annotated) data matrix of shape n_obs × n_vars. Rows correspond; to cells and columns to genes. counts_per_cell_after float | None (default: None)If None, after normalization, each cell has a total count equal; to the median of the counts_per_cell before normalization. counts_per_cel",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.normalize_per_cell.html:9456,layers,layers,9456,en/stable/generated/scanpy.pp.normalize_per_cell.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.normalize_per_cell.html,1,['layers'],['layers']
Modifiability,".external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .md. .pdf. Plotting: pl. Contents . Generic; Classes; Preprocessing; Tools; PCA; Embeddings. Branching trajectories and pseudotime, clustering; Marker genes; Simulations. Plotting: pl#; The plotting module scanpy.pl largely parallels the tl.* and a few of the pp.* functions.; For most tools and for some preprocessing functions, you’ll find a plotting function with the same name.; See Core plotting functions for an overview of how to use these functions. Note; See the Settings section for all important plotting configurations. Generic#. pl.scatter; Scatter plot along observations or variables axes. pl.heatmap; Heatmap of the expression values of genes. pl.dotplot; Makes a dot plot of the expression values of var_names. pl.tracksplot; In this type of plot each var_name is plotted as a filled line plot where the y values correspond to the var_name values and x is each of the cells. pl.violin; Violin plot. pl.stacked_violin; Stacked violin plots. pl.matrixplot; Creates a heatmap of the mean expression values per group of each var_names. pl.clustermap; Hierarchically-clustered heatmap. pl.ranking; Plot rankings. pl.dendrogram; Plots a dendrogram of the categories defined in groupby. Classes#; These classes allow fine tuning of visual parameters. pl.DotPlot; Allows the visualization of two values that are encoded as dot size and color. pl.MatrixPlot; Allows the visualization of values using a color map. pl.StackedViolin; Stacked violin plots. Preprocessing#; Methods for visualizing quality control and results of preprocessing functions. pl.highest_expr_ge",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/plotting.html:9798,variab,variables,9798,en/stable/api/plotting.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/plotting.html,1,['variab'],['variables']
Modifiability,".external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.pp.scrublet_simulate_doublets. Contents . scrublet_simulate_doublets(). scanpy.pp.scrublet_simulate_doublets#. scanpy.pp.scrublet_simulate_doublets(adata, *, layer=None, sim_doublet_ratio=2.0, synthetic_doublet_umi_subsampling=1.0, random_seed=0)[source]#; Simulate doublets by adding the counts of random observed transcriptome pairs. Parameters:. adata AnnDataThe annotated data matrix of shape n_obs × n_vars. Rows; correspond to cells and columns to genes. Genes should have been; filtered for expression and variability, and the object should contain; raw expression of the same dimensions. layer str | None (default: None)Layer of adata where raw values are stored, or ‘X’ if values are in .X. sim_doublet_ratio float (default: 2.0)Number of doublets to simulate relative to the number of observed; transcriptomes. If None, self.sim_doublet_ratio is used. synthetic_doublet_umi_subsampling float (default: 1.0)Rate for sampling UMIs when creating synthetic doublets. If 1.0,; each doublet is created by simply adding the UMIs from two randomly; sampled observed transcriptomes. For values less than 1, the; UMI counts are added and then randomly sampled at the specified; rate. Return type:; AnnData. Returns:; adata : anndata.AnnData with simulated doublets in .X; Adds fields to adata:. .obsm['scrublet']['doublet_parents']Pairs of .obs_names used to generate each simulated doublet transcriptome. .uns['scrublet']['parameters']Dictionary of Scrublet parameters. See also. scrublet()Main way of running Scrublet, runs pr",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pp.scrublet_simulate_doublets.html:9765,variab,variability,9765,en/stable/api/generated/scanpy.pp.scrublet_simulate_doublets.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pp.scrublet_simulate_doublets.html,2,['variab'],['variability']
Modifiability,".palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.external.tl.sam. Contents . sam(). scanpy.external.tl.sam#. scanpy.external.tl.sam(adata, *, max_iter=10, num_norm_avg=50, k=20, distance='correlation', standardization='StandardScaler', weight_pcs=False, sparse_pca=False, n_pcs=150, n_genes=3000, projection='umap', inplace=True, verbose=True)[source]#; Self-Assembling Manifolds single-cell RNA sequencing analysis tool [Tarashansky et al., 2019].; SAM iteratively rescales the input gene expression matrix to emphasize; genes that are spatially variable along the intrinsic manifold of the data.; It outputs the gene weights, nearest neighbor matrix, and a 2D projection.; The AnnData input should contain unstandardized, non-negative values.; Preferably, the data should be log-normalized and no genes should be filtered out. Parameters:. k int (default: 20)The number of nearest neighbors to identify for each cell. distance str (default: 'correlation')The distance metric to use when identifying nearest neighbors.; Can be any of the distance metrics supported by; pdist(). max_iter int (default: 10)The maximum number of iterations SAM will run. projection Literal['umap', 'tsne', 'None'] (default: 'umap')If ‘tsne’, generates a t-SNE embedding. If ‘umap’, generates a UMAP; embedding. If ‘None’, no embedding will be generated. standardization Literal['Normalizer', 'StandardScaler', 'None'] (default: 'StandardScaler')If ‘Normalizer’, use sklearn.preprocessing.Normalizer, which; normalizes expression data prior to",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.sam.html:9736,variab,variable,9736,en/stable/external/generated/scanpy.external.tl.sam.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.sam.html,2,['variab'],['variable']
Modifiability,".pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .md. .pdf. Usage Principles. Contents . Workflow; AnnData. Usage Principles#; Import Scanpy as:; import scanpy as sc. Workflow#; The typical workflow consists of subsequent calls of data analysis tools; in sc.tl, e.g.:; sc.tl.umap(adata, **tool_params) # embed a neighborhood graph of the data using UMAP. where adata is an AnnData object.; Each of these calls adds annotation to an expression matrix X,; which stores n_obs observations (cells) of n_vars variables (genes).; For each tool, there typically is an associated plotting function in sc.pl:; sc.pl.umap(adata, **plotting_params). If you pass show=False, a Axes instance is returned; and you have all of matplotlib’s detailed configuration possibilities.; To facilitate writing memory-efficient pipelines, by default,; Scanpy tools operate inplace on adata and return None –; this also allows to easily transition to out-of-memory pipelines.; If you want to return a copy of the AnnData object; and leave the passed adata unchanged, pass copy=True or inplace=False. AnnData#; Scanpy is based on anndata, which provides the AnnData class. At the most basic level, an AnnData object adata stores; a data matrix adata.X, annotation of observations; adata.obs and variables adata.var as pd.DataFrame and unstructured; annotation adata.uns as dict. Names of observations and; variables can be accessed via adata.obs_names and adata.var_names,; respectively. AnnData objects can be sliced like; dataframes, for example, adata_subset = adata[:, list_of_gene_names].; For more, see this blog post.; To read a data file to an AnnData object, call:; adata = sc.read(filename). to initialize an AnnData ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/usage-principles.html:9898,config,configuration,9898,en/stable/usage-principles.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/usage-principles.html,1,['config'],['configuration']
Modifiability,".pp.scale. Contents . scale(). scanpy.pp.scale#. scanpy.pp.scale(data, *, zero_center=True, max_value=None, copy=False, layer=None, obsm=None, mask_obs=None)[source]#; Scale data to unit variance and zero mean. Note; Variables (genes) that do not display any variation (are constant across; all observations) are retained and (for zero_center==True) set to 0; during this operation. In the future, they might be set to NaNs. Parameters:. data AnnData | spmatrix | ndarray | ArrayThe (annotated) data matrix of shape n_obs × n_vars.; Rows correspond to cells and columns to genes. zero_center bool (default: True)If False, omit zero-centering variables, which allows to handle sparse; input efficiently. max_value float | None (default: None)Clip (truncate) to this value after scaling. If None, do not clip. copy bool (default: False)Whether this function should be performed inplace. If an AnnData object; is passed, this also determines if a copy is returned. layer str | None (default: None)If provided, which element of layers to scale. obsm str | None (default: None)If provided, which element of obsm to scale. mask_obs ndarray[Any, dtype[bool]] | str | None (default: None)Restrict both the derivation of scaling parameters and the scaling itself; to a certain set of observations. The mask is specified as a boolean array; or a string referring to an array in obs.; This will transform data from csc to csr format if issparse(data). Return type:; AnnData | spmatrix | ndarray | Array | None. Returns:; Returns None if copy=False, else returns an updated AnnData object. Sets the following fields:. adata.X | adata.layers[layer]numpy.ndarray | scipy.sparse._csr.csr_matrix (dtype float)Scaled count data matrix. adata.var['mean']pandas.Series (dtype float)Means per gene before scaling. adata.var['std']pandas.Series (dtype float)Standard deviations per gene before scaling. adata.var['var']pandas.Series (dtype float)Variances per gene before scaling. previous; scanpy.pp.regress_out. next; sc",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.scale.html:10254,layers,layers,10254,en/stable/generated/scanpy.pp.scale.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.scale.html,1,['layers'],['layers']
Modifiability,".rst. .pdf. scanpy.pl.diffmap. Contents . diffmap(). scanpy.pl.diffmap#. scanpy.pl.diffmap(adata, *, color=None, mask_obs=None, gene_symbols=None, use_raw=None, sort_order=True, edges=False, edges_width=0.1, edges_color='grey', neighbors_key=None, arrows=False, arrows_kwds=None, groups=None, components=None, dimensions=None, layer=None, projection='2d', scale_factor=None, color_map=None, cmap=None, palette=None, na_color='lightgray', na_in_legend=True, size=None, frameon=None, legend_fontsize=None, legend_fontweight='bold', legend_loc='right margin', legend_fontoutline=None, colorbar_loc='right', vmax=None, vmin=None, vcenter=None, norm=None, add_outline=False, outline_width=(0.3, 0.05), outline_color=('black', 'white'), ncols=4, hspace=0.25, wspace=None, title=None, show=None, save=None, ax=None, return_fig=None, marker='.', **kwargs)[source]#; Scatter plot in Diffusion Map basis. Parameters:. adata AnnDataAnnotated data matrix. color str | Sequence[str] | None (default: None)Keys for annotations of observations/cells or variables/genes, e.g.,; 'ann1' or ['ann1', 'ann2']. gene_symbols str | None (default: None)Column name in .var DataFrame that stores gene symbols. By default var_names; refer to the index column of the .var DataFrame. Setting this option allows; alternative names to be used. use_raw bool | None (default: None)Use .raw attribute of adata for coloring with gene expression. If None,; defaults to True if layer isn’t provided and adata.raw is present. layer str | None (default: None)Name of the AnnData object layer that wants to be plotted. By default; adata.raw.X is plotted. If use_raw=False is set, then adata.X is plotted.; If layer is set to a valid layer name, then the layer is plotted. layer; takes precedence over use_raw. sort_order bool (default: True)For continuous annotations used as color parameter, plot data points; with higher values on top of others. groups str | Sequence[str] | None (default: None)Restrict to a few categories in categorica",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pl.diffmap.html:10252,variab,variables,10252,en/stable/api/generated/scanpy.pl.diffmap.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pl.diffmap.html,1,['variab'],['variables']
Modifiability,".scverse.org. GitHub ; Find a bug? Interested in improving scanpy? Checkout our GitHub for the latest developments. https://github.com/scverse/scanpy. Other resources. Follow changes in the release notes.; Find tools that harmonize well with anndata & Scanpy at scverse.org/packages/; Check out our contribution guide for development practices.; Consider citing Genome Biology (2018) along with original references. News#. rapids-singlecell brings scanpy to the GPU! 2024-03-18#; rapids-singlecell by Severin Dicks provides a scanpy-like API with accelerated operations implemented on GPU. Scanpy hits 100 contributors! 2022-03-31#; 100 people have contributed to Scanpy’s source code!; Of course, contributions to the project are not limited to direct modification of the source code.; Many others have improved the project by building on top of it, participating in development discussions, helping others with usage, or by showing off what it’s helped them accomplish.; Thanks to all our contributors for making this project possible!. New community channels 2022-03-31#; We’ve moved our forums and have a new publicly available chat!. Our discourse forum has migrated to a joint scverse forum (discourse.scverse.org).; Our private developer Slack has been replaced by a public Zulip chat (scverse.zulipchat.com). Toolkit for spatial (squidpy) and multimodal (muon) published 2022-02-01#; Two large toolkits extending our ecosystem to new modalities have had their manuscripts published!. Muon, a framework for multimodal has been published in Genome Biology.; Squidpy a toolkit for working with spatial single cell data has been published in Nature Methods. (past news). next; Installation. Contents; . News; rapids-singlecell brings scanpy to the GPU! 2024-03-18; Scanpy hits 100 contributors! 2022-03-31; New community channels 2022-03-31; Toolkit for spatial (squidpy) and multimodal (muon) published 2022-02-01. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/index.html:12037,extend,extending,12037,en/stable/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/index.html,1,['extend'],['extending']
Modifiability,"1.10.0a1, tick the “Set as a pre-release” checkbox. After making a release#; After any release has been made:. Create a milestone for the next release (in case you made a bugfix release) or releases (in case of a major/minor release).; For bugfix releases, this should have on-merge: backport to 0.<minor>.x,; so the meeseeksdev bot will create a backport PR. See Versioning for more info.; Clear out and close the milestone you just made a release for. After a major or minor release has been made:. Tweet about it! Announce it on Zulip! Announce it on Discourse! Think about making a bot for this! Maybe actually do that?; Create a new release notes file for the next minor release. This should only be added to the dev branch.; Tag the development branch. If you just released 1.7.0, this would be 1.8.0.dev0.; Create a new branch for this release series, like 1.7.x. This should get a new release notes file. Debugging the build process#; If you changed something about the build process (e.g. Hatchling’s build configuration),; or something about the package’s structure,; you might want to manually check if the build and upload process behaves as expected:; $ # Clear out old distributions; $ rm -r dist; $ # Build source distribution and wheel both; $ python -m build; $ # Now check those build artifacts; $ twine check dist/*; $ # List the wheel archive’s contents; $ bsdtar -tf dist/*.whl. You can also upload the package to <test.pypi.org> (tutorial); $ twine upload --repository testpypi dist/*. The above approximates what the publish workflow does automatically for us.; If you want to replicate the process more exactly, make sure you are careful,; and create a version tag before building (make sure you delete it after uploading to TestPyPI!). previous; Versioning. next; Contributors. Contents; . Preparing the release; Actually making the release; After making a release; Debugging the build process. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/dev/release.html:11419,config,configuration,11419,en/stable/dev/release.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/dev/release.html,1,['config'],['configuration']
Modifiability,"21], Pearson residuals of a negative binomial offset model are computed; (with overdispersion theta shared across genes). By default, overdispersion; theta=100 is used and residuals are clipped to sqrt(n_obs). Finally, genes; are ranked by residual variance.; Expects raw count input. Parameters:. adata AnnDataThe annotated data matrix of shape n_obs × n_vars.; Rows correspond to cells and columns to genes. theta float (default: 100)The negative binomial overdispersion parameter theta for Pearson residuals.; Higher values correspond to less overdispersion (var = mean + mean^2/theta), and theta=np.inf corresponds to a Poisson model. clip float | None (default: None)Determines if and how residuals are clipped:. If None, residuals are clipped to the interval [-sqrt(n_obs), sqrt(n_obs)], where n_obs is the number of cells in the dataset (default behavior).; If any scalar c, residuals are clipped to the interval [-c, c]. Set clip=np.inf for no clipping. n_top_genes int | None (default: None)Number of highly-variable genes to keep. Mandatory if flavor='seurat_v3' or; flavor='pearson_residuals'. batch_key str | None (default: None)If specified, highly-variable genes are selected within each batch separately; and merged. This simple process avoids the selection of batch-specific genes; and acts as a lightweight batch correction method. Genes are first sorted by; how many batches they are a HVG. If flavor='pearson_residuals', ties are; broken by the median rank (across batches) based on within-batch residual; variance. chunksize int (default: 1000)If flavor='pearson_residuals', this dertermines how many genes are processed at; once while computing the residual variance. Choosing a smaller value will reduce; the required memory. flavor Literal['pearson_residuals'] (default: 'pearson_residuals')Choose the flavor for identifying highly variable genes. In this experimental; version, only ‘pearson_residuals’ is functional. check_values bool (default: True)If True, checks if counts ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.highly_variable_genes.html:10727,variab,variable,10727,en/stable/generated/scanpy.experimental.pp.highly_variable_genes.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.highly_variable_genes.html,1,['variab'],['variable']
Modifiability,"5 J Lause, G Palla, I Virshup. This includes:. normalize_pearson_residuals() for Pearson Residuals normalization; highly_variable_genes() for HVG selection with Pearson Residuals; normalize_pearson_residuals_pca() for Pearson Residuals normalization and dimensionality reduction with PCA; recipe_pearson_residuals() for Pearson Residuals normalization, HVG selection and dimensionality reduction with PCA. Features#. filter_rank_genes_groups() now allows to filter with absolute values of log fold change pr1649 S Rybakov; _choose_representation now subsets the provided representation to n_pcs, regardless of the name of the provided representation (should affect mostly neighbors()) pr2179 I Virshup PG Majev; scanpy.pp.scrublet() (and related functions) can now be used on AnnData objects containing multiple batches pr1965 J Manning; Number of variables plotted with pca_loadings() can now be controlled with n_points argument. Additionally, variables are no longer repeated if the anndata has less than 30 variables pr2075 Yves33; Dask arrays now work with scanpy.pp.normalize_total() pr1663 G Buckley, I Virshup; embedding_density() now allows more than 10 groups pr1936 A Wolf; Embedding plots can now pass colorbar_loc to specify the location of colorbar legend, or pass None to not show a colorbar pr1821 A Schaar I Virshup; Embedding plots now have a dimensions argument, which lets users select which dimensions of their embedding to plot and uses the same broadcasting rules as other arguments pr1538 I Virshup; print_versions() now uses session_info pr2089 P Angerer I Virshup. Ecosystem#; Multiple packages have been added to our ecosystem page, including:. decoupler a for footprint analysis and pathway enrichement pr2186 PB Mompel; dandelion for B-cell receptor analysis pr1953 Z Tuong; CIARA a feature selection tools for identifying rare cell types pr2175 M Stock. Bug fixes#. Fixed finding variables with use_raw=True and basis=None in scanpy.pl.scatter() pr2027 E Rice; Fixed sca",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:23299,variab,variables,23299,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,2,['variab'],['variables']
Modifiability,"71xvg; . We’ll convert the X representation to dask using anndata.experimental.read_elem_as_dask.; The file we’ve retrieved from cellxgene has already been processed. Since this tutorial is demonstrating processing from counts, we’re just going to access the counts matrix and annotations. %%time; with h5py.File(""cell_atlas.h5ad"", ""r"") as f:; adata = ad.AnnData(; obs=ad.experimental.read_elem(f[""obs""]),; var=ad.experimental.read_elem(f[""var""]),; ); adata.X = ad.experimental.read_elem_as_dask(; f[""raw/X""], chunks=(SPARSE_CHUNK_SIZE, adata.shape[1]); ). CPU times: user 2.4 s, sys: 673 ms, total: 3.08 s; Wall time: 3.22 s. We’ve optimized a number of scanpy functions to be completely lazy. That means it will look like nothing is computed when you call an operation on a dask array, but only later when you hit compute.; In some cases it’s currently unavoidable to skip all computation, and these cases will kick off compute for all the delayed operations immediately. %%time; adata.layers[""counts""] = adata.X.copy() # Making sure we keep access to the raw counts; sc.pp.normalize_total(adata, target_sum=1e4). CPU times: user 7.1 ms, sys: 31 μs, total: 7.13 ms; Wall time: 7.49 ms. %%time; sc.pp.log1p(adata). CPU times: user 3.14 ms, sys: 2.03 ms, total: 5.17 ms; Wall time: 4.88 ms. Highly variable genes needs to add entries into obs, which currently does not support lazy column. So computation will occur immediately on call. %%time; sc.pp.highly_variable_genes(adata). CPU times: user 3.46 s, sys: 509 ms, total: 3.97 s; Wall time: 50 s. PCA currently does not support sparse data. So we will need to densify the expression matrix before passing it in. However, as we are working with only a subset of the data at a time, we are able to perform this operation with a lower memory overhead.; As this is a still a significant increase in memory usage per chunk, we will need to reduce the number of observations present in each chunk. adata.layers[""dense""] = adata.X.rechunk((DENSE_CHUNK_SIZ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/dask.html:14533,layers,layers,14533,en/stable/tutorials/experimental/dask.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/dask.html,2,['layers'],['layers']
Modifiability,": 3)If n_top_genes unequals None, this and all other cutoffs for the means and the; normalized dispersions are ignored. Ignored if flavor='seurat_v3'. min_disp float (default: 0.5)If n_top_genes unequals None, this and all other cutoffs for the means and the; normalized dispersions are ignored. Ignored if flavor='seurat_v3'. max_disp float (default: inf)If n_top_genes unequals None, this and all other cutoffs for the means and the; normalized dispersions are ignored. Ignored if flavor='seurat_v3'. span float (default: 0.3)The fraction of the data (cells) used when estimating the variance in the loess; model fit if flavor='seurat_v3'. n_bins int (default: 20)Number of bins for binning the mean gene expression. Normalization is; done with respect to each bin. If just a single gene falls into a bin,; the normalized dispersion is artificially set to 1. You’ll be informed; about this if you set settings.verbosity = 4. flavor Literal['seurat', 'cell_ranger', 'seurat_v3', 'seurat_v3_paper'] (default: 'seurat')Choose the flavor for identifying highly variable genes. For the dispersion; based methods in their default workflows, Seurat passes the cutoffs whereas; Cell Ranger passes n_top_genes. subset bool (default: False)Inplace subset to highly-variable genes if True otherwise merely indicate; highly variable genes. inplace bool (default: True)Whether to place calculated metrics in .var or return them. batch_key str | None (default: None)If specified, highly-variable genes are selected within each batch separately and merged.; This simple process avoids the selection of batch-specific genes and acts as a; lightweight batch correction method. For all flavors, except seurat_v3, genes are first sorted; by how many batches they are a HVG. For dispersion-based flavors ties are broken; by normalized dispersion. For flavor = 'seurat_v3_paper', ties are broken by the median; (across batches) rank based on within-batch normalized variance. check_values bool (default: True)Check if c",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.highly_variable_genes.html:13343,variab,variable,13343,en/stable/generated/scanpy.pp.highly_variable_genes.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.highly_variable_genes.html,1,['variab'],['variable']
Modifiability,": TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.pl.scatter. Contents . scatter(). scanpy.pl.scatter#. scanpy.pl.scatter(adata, x=None, y=None, *, color=None, use_raw=None, layers=None, sort_order=True, alpha=None, basis=None, groups=None, components=None, projection='2d', legend_loc='right margin', legend_fontsize=None, legend_fontweight=None, legend_fontoutline=None, color_map=None, palette=None, frameon=None, right_margin=None, left_margin=None, size=None, marker='.', title=None, show=None, save=None, ax=None)[source]#; Scatter plot along observations or variables axes.; Color the plot using annotations of observations (.obs), variables; (.var) or expression of genes (.var_names). Parameters:. adata AnnDataAnnotated data matrix. x str | None (default: None)x coordinate. y str | None (default: None)y coordinate. color str | Collection[str] | None (default: None)Keys for annotations of observations/cells or variables/genes,; or a hex color specification, e.g.,; 'ann1', '#fe57a1', or ['ann1', 'ann2']. use_raw bool | None (default: None)Whether to use raw attribute of adata. Defaults to True if .raw is present. layers str | Collection[str] | None (default: None)Use the layers attribute of adata if present: specify the layer for; x, y and color. If layers is a string, then i",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pl.scatter.html:9357,layers,layers,9357,en/stable/generated/scanpy.pl.scatter.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pl.scatter.html,1,['layers'],['layers']
Modifiability,"; sc.logging.print_versions(); results_file = ""./write/paul15.h5ad""; # low dpi (dots per inch) yields small inline figures; sc.settings.set_figure_params(dpi=80, frameon=False, figsize=(3, 3), facecolor=""white""). scanpy==1.5.0 anndata==0.7.1 umap==0.4.2 numpy==1.18.1 scipy==1.4.1 pandas==1.0.3 scikit-learn==0.22.1 statsmodels==0.11.0. adata = sc.datasets.paul15(). WARNING: In Scanpy 0.*, this returned logarithmized data. Now it returns non-logarithmized data. adata. AnnData object with n_obs × n_vars = 2730 × 3451 ; obs: 'paul15_clusters'; uns: 'iroot'. Let us work with a higher precision than the default ‘float32’ to ensure exactly the same results across different computational platforms. # this is not required and results will be comparable without it; adata.X = adata.X.astype(""float64""). Preprocessing and Visualization#; Apply a simple preprocessing recipe. sc.pp.recipe_zheng17(adata). running recipe zheng17; normalizing counts per cell; finished (0:00:00); extracting highly variable genes; finished (0:00:00); normalizing counts per cell; finished (0:00:00); finished (0:00:00). sc.tl.pca(adata, svd_solver=""arpack""). computing PCA; with n_comps=50; finished (0:00:00). sc.pp.neighbors(adata, n_neighbors=4, n_pcs=20); sc.tl.draw_graph(adata). computing neighbors; using 'X_pca' with n_pcs = 20; finished: added to `.uns['neighbors']`; `.obsp['distances']`, distances for each pair of neighbors; `.obsp['connectivities']`, weighted adjacency matrix (0:00:02); drawing single-cell graph using layout 'fa'; finished: added; 'X_draw_graph_fa', graph_drawing coordinates (adata.obsm) (0:00:14). sc.pl.draw_graph(adata, color=""paul15_clusters"", legend_loc=""on data""). This looks pretty messy. Optional: Denoising the graph#; To denoise the graph, we represent it in diffusion map space (and not in PCA space). Computing distances within a few diffusion components amounts to denoising the graph - we just take a few of the first spectral components. It’s very similar to denoising a da",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/trajectories/paga-paul15.html:11053,variab,variable,11053,en/stable/tutorials/trajectories/paga-paul15.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/trajectories/paga-paul15.html,2,['variab'],['variable']
Modifiability,"; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.external.tl.palantir. Contents . palantir(). scanpy.external.tl.palantir#. scanpy.external.tl.palantir(adata, *, n_components=10, knn=30, alpha=0, use_adjacency_matrix=False, distances_key=None, n_eigs=None, impute_data=True, n_steps=3, copy=False)[source]#; Run Diffusion maps using the adaptive anisotropic kernel [Setty et al., 2019].; Palantir is an algorithm to align cells along differentiation trajectories.; Palantir models differentiation as a stochastic process where stem cells; differentiate to terminally differentiated cells by a series of steps through; a low dimensional phenotypic manifold. Palantir effectively captures the; continuity in cell states and the stochasticity in cell fate determination.; Palantir has been designed to work with multidimensional single cell data; from diverse technologies such as Mass cytometry and single cell RNA-seq. Note; More information and bug reports here. Parameters:. adata AnnDataAn AnnData object. n_components int (default: 10)Number of diffusion components. knn int (default: 30)Number of nearest neighbors for graph construction. alpha float (default: 0)Normalization parameter for the diffusion operator. use_adjacency_matrix bool (default: False)",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.palantir.html:9531,adapt,adaptive,9531,en/stable/external/generated/scanpy.external.tl.palantir.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.palantir.html,2,['adapt'],['adaptive']
Modifiability,"Choose the flavor for computing normalized dispersion. If choosing; ‘seurat’, this expects non-logarithmized data – the logarithm of mean; and dispersion is taken internally when log is at its default value; True. For ‘cell_ranger’, this is usually called for logarithmized data; – in this case you should set log to False. In their default; workflows, Seurat passes the cutoffs whereas Cell Ranger passes; n_top_genes. min_mean float | None (default: None). max_mean float | None (default: None). min_disp float | None (default: None). max_disp float | None (default: None)If n_top_genes unequals None, these cutoffs for the means and the; normalized dispersions are ignored. n_bins int (default: 20)Number of bins for binning the mean gene expression. Normalization is; done with respect to each bin. If just a single gene falls into a bin,; the normalized dispersion is artificially set to 1. You’ll be informed; about this if you set settings.verbosity = 4. n_top_genes int | None (default: None)Number of highly-variable genes to keep. log bool (default: True)Use the logarithm of the mean to variance ratio. subset bool (default: True)Keep highly-variable genes only (if True) else write a bool array for h; ighly-variable genes while keeping all genes. copy bool (default: False)If an AnnData is passed, determines whether a copy; is returned. Return type:; AnnData | recarray | None. Returns:; If an AnnData adata is passed, returns or updates adata depending on; copy. It filters the adata and adds the annotations. meansadata.varMeans per gene. Logarithmized when log is True. dispersionsadata.varDispersions per gene. Logarithmized when log is True. dispersions_normadata.varNormalized dispersions per gene. Logarithmized when log is True. If a data matrix X is passed, the annotation is returned as np.recarray; with the same information stored in fields: gene_subset, means, dispersions, dispersion_norm. previous; Deprecated functions. next; scanpy.pp.normalize_per_cell. Contents; . fil",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.filter_genes_dispersion.html:11787,variab,variable,11787,en/stable/generated/scanpy.pp.filter_genes_dispersion.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.filter_genes_dispersion.html,1,['variab'],['variable']
Modifiability,"PCA coordinates, loadings and variance decomposition.; Uses the implementation of scikit-learn [Pedregosa et al., 2011]. Changed in version 1.5.0: In previous versions, computing a PCA on a sparse matrix would make; a dense copy of the array for mean centering.; As of scanpy 1.5.0, mean centering is implicit.; While results are extremely similar, they are not exactly the same.; If you would like to reproduce the old results, pass a dense array. Parameters:. data AnnData | ndarray | spmatrixThe (annotated) data matrix of shape n_obs × n_vars.; Rows correspond to cells and columns to genes. n_comps int | None (default: None)Number of principal components to compute. Defaults to 50, or 1 - minimum; dimension size of selected representation. layer str | None (default: None)If provided, which element of layers to use for PCA. zero_center bool | None (default: True)If True, compute standard PCA from covariance matrix.; If False, omit zero-centering variables; (uses scikit-learn TruncatedSVD or; dask-ml TruncatedSVD),; which allows to handle sparse input efficiently.; Passing None decides automatically based on sparseness of the data. svd_solver str | None (default: None)SVD solver to use:. NoneSee chunked and zero_center descriptions to determine which class will be used.; Depending on the class and the type of X different values for default will be set.; If scikit-learn PCA is used, will give 'arpack',; if scikit-learn TruncatedSVD is used, will give 'randomized',; if dask-ml PCA or IncrementalPCA is used, will give 'auto',; if dask-ml TruncatedSVD is used, will give 'tsqr'. 'arpack'for the ARPACK wrapper in SciPy (svds()); Not available with dask arrays. 'randomized'for the randomized algorithm due to Halko (2009). For dask arrays,; this will use svd_compressed(). 'auto'chooses automatically depending on the size of the problem. 'lobpcg'An alternative SciPy solver. Not available with dask arrays. 'tsqr'Only available with dask arrays. “tsqr”; algorithm from Benson et. al",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.pca.html:10526,variab,variables,10526,en/stable/generated/scanpy.pp.pca.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.pca.html,1,['variab'],['variables']
Modifiability,"Pearson residuals. On the resulting subset,; Pearson residual normalization and PCA are performed.; Expects raw count input. Parameters:. adata AnnDataThe annotated data matrix of shape n_obs × n_vars.; Rows correspond to cells and columns to genes. theta float (default: 100)The negative binomial overdispersion parameter theta for Pearson residuals.; Higher values correspond to less overdispersion (var = mean + mean^2/theta), and theta=np.inf corresponds to a Poisson model. clip float | None (default: None)Determines if and how residuals are clipped:. If None, residuals are clipped to the interval [-sqrt(n_obs), sqrt(n_obs)], where n_obs is the number of cells in the dataset (default behavior).; If any scalar c, residuals are clipped to the interval [-c, c]. Set clip=np.inf for no clipping. n_top_genes int (default: 1000)Number of highly-variable genes to keep. Mandatory if flavor='seurat_v3' or; flavor='pearson_residuals'. batch_key str | None (default: None)If specified, highly-variable genes are selected within each batch separately; and merged. This simple process avoids the selection of batch-specific genes; and acts as a lightweight batch correction method. Genes are first sorted by; how many batches they are a HVG. If flavor='pearson_residuals', ties are; broken by the median rank (across batches) based on within-batch residual; variance. chunksize int (default: 1000)If flavor='pearson_residuals', this dertermines how many genes are processed at; once while computing the residual variance. Choosing a smaller value will reduce; the required memory. n_comps int | None (default: 50)Number of principal components to compute in the PCA step. random_state float | None (default: 0)Random seed for setting the initial states for the optimization in the PCA step. kwargs_pca dict (default: {})Dictionary of further keyword arguments passed on to scanpy.pp.pca(). check_values bool (default: True)If True, checks if counts in selected layer are integers as expected by this; ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.recipe_pearson_residuals.html:10740,variab,variable,10740,en/stable/generated/scanpy.experimental.pp.recipe_pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.recipe_pearson_residuals.html,1,['variab'],['variable']
Modifiability,"To run the tests, simply run hatch test.; It can take a while to run the whole test suite. There are a few ways to cut down on this while working on a PR:. Only run a subset of the tests.; This can be done by specifying paths or test name patterns using the -k argument (e.g. hatch test test_plotting.py or hatch test -k ""test_umap*""); Run the tests in parallel using the -n argument (e.g. hatch test -n 8). Miscellaneous tips#. A lot of warnings can be thrown while running the test suite.; It’s often easier to read the test results with them hidden via the --disable-pytest-warnings argument. Writing tests#; You can refer to the existing test suite for examples.; If you haven’t written tests before, Software Carpentry has an in-depth testing guide.; We highly recommend using Test-Driven Development when contributing code.; This not only ensures you have tests written, it often makes implementation easier since you start out with a specification for your function.; Consider parameterizing your tests using the pytest.mark.parameterize and pytest.fixture decorators.; You can read more about fixtures in pytest’s documentation, but we’d also recommend searching our test suite for existing usage. What to test#; If you’re not sure what to tests about your function, some ideas include:. Are there arguments which conflict with each other? Check that if they are both passed, the function throws an error (see pytest.raises docs).; Are there input values which should cause your function to error?; Did you add a helpful error message that recommends better outputs? Check that that error message is actually thrown.; Can you place bounds on the values returned by your function?; Are there different input values which should generate equivalent output (e.g. if an array is sparse or dense)?; Do you have arguments which should have orthogonal effects on the output? Check that they are independent. For example, if there is a flag for extended output, the base output should remain the same",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/dev/testing.html:10587,parameteriz,parameterizing,10587,en/stable/dev/testing.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/dev/testing.html,1,['parameteriz'],['parameterizing']
Modifiability,"_integrate; scanpy.external.pp.hashsolo; scanpy.external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .md. .pdf. Contributing. Contributing#; Contributions to scanpy are welcome!; This section of the docs provides some guidelines and tips to follow when contributing. Contributing code; Development workflow; Code style. Getting set up; Working with git; Forking and cloning; pre-commit; Creating a branch for your feature; Open a pull request. Development environments. Tests; Running the tests; Miscellaneous tips. Writing tests; What to test; Performance; Plotting tests. Documentation; Building the docs; Adding to the docs; docstrings format; Plots in docstrings; Params section; Returns section; Examples. CI; Plotting tests; Viewing plots from failed tests on Azure pipelines; Misc. Versioning; Semantic versioning; Version numbers. Tooling; Technical details. Making a release; Preparing the release; Actually making the release; After making a release; Debugging the build process. Parts of the guidelines have been adapted from the pandas and MDAnalysis guides.; These are both excellent guides and we highly recommend checking them out. previous; News. next; Contributing code. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/dev/index.html:10132,adapt,adapted,10132,en/stable/dev/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/dev/index.html,1,['adapt'],['adapted']
Modifiability,"ace bool (default: True)Set fields in adata if True. Otherwise, returns a copy. verbose bool (default: True)If True, displays SAM log statements. Return type:; SAM | tuple[SAM, AnnData]. Returns:; sam_obj if inplace is True or (sam_obj,AnnData) otherwise. adata - AnnData; .var['weights']SAM weights for each gene. .var['spatial_dispersions']Spatial dispersions for each gene (these are used to compute the; SAM weights). .uns['sam']Dictionary of SAM-specific outputs, such as the parameters; used for preprocessing (‘preprocess_args’) and running; (‘run_args’) SAM. .uns['neighbors']A dictionary with key ‘connectivities’ containing the kNN adjacency; matrix output by SAM. If built-in scanpy dimensionality reduction; methods are to be used using the SAM-output AnnData, users; should recompute the neighbors using .obs['X_pca'] with; scanpy.pp.neighbors. .obsm['X_pca']The principal components output by SAM. .obsm['X_umap']The UMAP projection output by SAM. .layers['X_disp']The expression matrix used for nearest-neighbor averaging. .layers['X_knn_avg']The nearest-neighbor-averaged expression data used for computing the; spatial dispersions of genes. Example; >>> import scanpy.external as sce; >>> import scanpy as sc. * Running SAM *; Assuming we are given an AnnData object called adata, we can run the SAM; algorithm as follows:; >>> sam_obj = sce.tl.sam(adata,inplace=True). The input AnnData object should contain unstandardized, non-negative; expression values. Preferably, the data should be log-normalized and no; genes should be filtered out.; Please see the documentation for a description of all available parameters.; For more detailed tutorials, please visit the original Github repository:; atarashansky/self-assembling-manifold; * Plotting *; To visualize the output, we can use:; >>> sce.pl.sam(adata,projection='X_umap'). sce.pl.sam accepts all keyword arguments used in the; matplotlib.pyplot.scatter function.; * SAMGUI *; SAM comes with the SAMGUI module, a graphical-user",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.sam.html:13625,layers,layers,13625,en/stable/external/generated/scanpy.external.tl.sam.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.sam.html,2,['layers'],['layers']
Modifiability,"ace calculated metrics in .var or return them. batch_key str | None (default: None)If specified, highly-variable genes are selected within each batch separately and merged.; This simple process avoids the selection of batch-specific genes and acts as a; lightweight batch correction method. For all flavors, except seurat_v3, genes are first sorted; by how many batches they are a HVG. For dispersion-based flavors ties are broken; by normalized dispersion. For flavor = 'seurat_v3_paper', ties are broken by the median; (across batches) rank based on within-batch normalized variance. check_values bool (default: True)Check if counts in selected layer are integers. A Warning is returned if set to True.; Only used if flavor='seurat_v3'/'seurat_v3_paper'. Return type:; DataFrame | None. Returns:; Returns a pandas.DataFrame with calculated metrics if inplace=True, else returns an AnnData object where it sets the following field:. adata.var['highly_variable']pandas.Series (dtype bool)boolean indicator of highly-variable genes. adata.var['means']pandas.Series (dtype float)means per gene. adata.var['dispersions']pandas.Series (dtype float)For dispersion-based flavors, dispersions per gene. adata.var['dispersions_norm']pandas.Series (dtype float)For dispersion-based flavors, normalized dispersions per gene. adata.var['variances']pandas.Series (dtype float)For flavor='seurat_v3'/'seurat_v3_paper', variance per gene. adata.var['variances_norm']/'seurat_v3_paper'pandas.Series (dtype float)For flavor='seurat_v3'/'seurat_v3_paper', normalized variance per gene, averaged in; the case of multiple batches. adata.var['highly_variable_rank']pandas.Series (dtype float)For flavor='seurat_v3'/'seurat_v3_paper', rank of the gene according to normalized; variance, in case of multiple batches description above. adata.var['highly_variable_nbatches']pandas.Series (dtype int)If batch_key is given, this denotes in how many batches genes are detected as HVG. adata.var['highly_variable_intersection']p",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.highly_variable_genes.html:14671,variab,variable,14671,en/stable/generated/scanpy.pp.highly_variable_genes.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.highly_variable_genes.html,1,['variab'],['variable']
Modifiability,"ajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.pp.neighbors. Contents . neighbors(). scanpy.pp.neighbors#. scanpy.pp.neighbors(adata, n_neighbors=15, n_pcs=None, *, use_rep=None, knn=True, method='umap', transformer=None, metric='euclidean', metric_kwds=mappingproxy({}), random_state=0, key_added=None, copy=False)[source]#; Computes the nearest neighbors distance matrix and a neighborhood graph of observations [McInnes et al., 2018].; The neighbor search efficiency of this heavily relies on UMAP [McInnes et al., 2018],; which also provides a method for estimating connectivities of data points -; the connectivity of the manifold (method=='umap'). If method=='gauss',; connectivities are computed according to Coifman et al. [2005], in the adaption of; Haghverdi et al. [2016]. Parameters:. adata AnnDataAnnotated data matrix. n_neighbors int (default: 15)The size of local neighborhood (in terms of number of neighboring data; points) used for manifold approximation. Larger values result in more; global views of the manifold, while smaller values result in more local; data being preserved. In general values should be in the range 2 to 100.; If knn is True, number of nearest neighbors to be searched. If knn; is False, a Gaussian kernel width is set to the distance of the; n_neighbors neighbor.; ignored if ``transformer`` is an instance. n_pcs int | None (default: None)Use this many PCs. If n_pcs==0 use .X if use_rep is None. use_rep str | None (default: None)Use the indicated representation. 'X' or any key for .obsm is valid.; If None, the representation is chosen automatically:; For .n_vars < N_PCS (default: 50), .X is used, otherwise ‘X_pca’ is used.; If ‘X_pca’ is not present, it’s computed with default parameters or n_pcs if pr",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pp.neighbors.html:9934,adapt,adaption,9934,en/stable/api/generated/scanpy.pp.neighbors.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pp.neighbors.html,1,['adapt'],['adaption']
Modifiability,"al variance. Choosing a smaller value will reduce; the required memory. flavor Literal['pearson_residuals'] (default: 'pearson_residuals')Choose the flavor for identifying highly variable genes. In this experimental; version, only ‘pearson_residuals’ is functional. check_values bool (default: True)If True, checks if counts in selected layer are integers as expected by this; function, and return a warning if non-integers are found. Otherwise, proceed; without checking. Setting this to False can speed up code for large datasets. layer str | None (default: None)Layer to use as input instead of X. If None, X is used. subset bool (default: False)If True, subset the data to highly-variable genes after finding them.; Otherwise merely indicate highly variable genes in adata.var (see below). inplace bool (default: True)If True, update adata with results. Otherwise, return results. See below for; details of what is returned. Return type:; DataFrame | None. Returns:; If inplace=True, adata.var is updated with the following fields. Otherwise,; returns the same fields as DataFrame. highly_variableboolboolean indicator of highly-variable genes. meansfloatmeans per gene. variancesfloatvariance per gene. residual_variancesfloatFor flavor='pearson_residuals', residual variance per gene. Averaged in the; case of multiple batches. highly_variable_rankfloatFor flavor='pearson_residuals', rank of the gene according to residual.; variance, median rank in the case of multiple batches. highly_variable_nbatchesintIf batch_key given, denotes in how many batches genes are detected as HVG. highly_variable_intersectionboolIf batch_key given, denotes the genes that are highly variable in all batches. Notes; Experimental version of sc.pp.highly_variable_genes(). previous; scanpy.experimental.pp.normalize_pearson_residuals_pca. next; scanpy.experimental.pp.recipe_pearson_residuals. Contents; . highly_variable_genes(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.highly_variable_genes.html:12519,variab,variable,12519,en/stable/generated/scanpy.experimental.pp.highly_variable_genes.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.highly_variable_genes.html,2,['variab'],['variable']
Modifiability,"al.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.pp.filter_genes_dispersion. Contents . filter_genes_dispersion(). scanpy.pp.filter_genes_dispersion#. scanpy.pp.filter_genes_dispersion(data, *, flavor='seurat', min_disp=None, max_disp=None, min_mean=None, max_mean=None, n_bins=20, n_top_genes=None, log=True, subset=True, copy=False)[source]#; Extract highly variable genes [Satija et al., 2015, Zheng et al., 2017]. Warning. Deprecated since version 1.3.6: Use highly_variable_genes(); instead. The new function is equivalent to the present; function, except that. the new function always expects logarithmized data; subset=False in the new function, it suffices to; merely annotate the genes, tools like pp.pca will; detect the annotation; you can now call: sc.pl.highly_variable_genes(adata); copy is replaced by inplace. If trying out parameters, pass the data matrix instead of AnnData.; Depending on flavor, this reproduces the R-implementations of Seurat; [Satija et al., 2015] and Cell Ranger [Zheng et al., 2017].; The normalized dispersion is obtained by scaling with the mean and standard; deviation of the dispersions for genes falling into a given bin for mean; expression of genes. This means that for each bin of mean expression, highly; variable genes are se",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.filter_genes_dispersion.html:9560,variab,variable,9560,en/stable/generated/scanpy.pp.filter_genes_dispersion.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.filter_genes_dispersion.html,1,['variab'],['variable']
Modifiability,"alantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .md. .pdf. Plotting: pl. Contents . Generic; Classes; Preprocessing; Tools; PCA; Embeddings. Branching trajectories and pseudotime, clustering; Marker genes; Simulations. Plotting: pl#; The plotting module scanpy.pl largely parallels the tl.* and a few of the pp.* functions.; For most tools and for some preprocessing functions, you’ll find a plotting function with the same name.; See Core plotting functions for an overview of how to use these functions. Note; See the Settings section for all important plotting configurations. Generic#. pl.scatter; Scatter plot along observations or variables axes. pl.heatmap; Heatmap of the expression values of genes. pl.dotplot; Makes a dot plot of the expression values of var_names. pl.tracksplot; In this type of plot each var_name is plotted as a filled line plot where the y values correspond to the var_name values and x is each of the cells. pl.violin; Violin plot. pl.stacked_violin; Stacked violin plots. pl.matrixplot; Creates a heatmap of the mean expression values per group of each var_names. pl.clustermap; Hierarchically-clustered heatmap. pl.ranking; Plot rankings. pl.dendrogram; Plots a dendrogram of the categories defined in groupby. Classes#; These classes allow fine tuning of visual parameters. pl.DotPlot; Allows the visualization of two values that are encoded as dot size and color. pl.MatrixPlot; Allows the visualization of values using a color map. pl.StackedViolin; Stacked violin plots. Preprocessing#; Methods for visua",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/plotting.html:9725,config,configurations,9725,en/stable/api/plotting.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/plotting.html,1,['config'],['configurations']
Modifiability,"alse, inplace=True; ). A violin plot of some of the computed quality measures:. the number of genes expressed in the count matrix; the total counts per cell; the percentage of counts in mitochondrial genes. sc.pl.violin(; adata,; [""n_genes_by_counts"", ""total_counts"", ""pct_counts_mt""],; jitter=0.4,; multi_panel=True,; ). Remove cells that have too many mitochondrial genes expressed or too many total counts:. sc.pl.scatter(adata, x=""total_counts"", y=""pct_counts_mt""); sc.pl.scatter(adata, x=""total_counts"", y=""n_genes_by_counts""). Actually do the filtering by slicing the AnnData object. adata = adata[adata.obs.n_genes_by_counts < 2500, :]; adata = adata[adata.obs.pct_counts_mt < 5, :].copy(). Total-count normalize (library-size correct) the data matrix \(\mathbf{X}\) to 10,000 reads per cell, so that counts become comparable among cells. sc.pp.normalize_total(adata, target_sum=1e4). normalizing counts per cell; finished (0:00:00). Logarithmize the data:. sc.pp.log1p(adata). Identify highly-variable genes. sc.pp.highly_variable_genes(adata, min_mean=0.0125, max_mean=3, min_disp=0.5). extracting highly variable genes; finished (0:00:00); --> added; 'highly_variable', boolean vector (adata.var); 'means', float vector (adata.var); 'dispersions', float vector (adata.var); 'dispersions_norm', float vector (adata.var). sc.pl.highly_variable_genes(adata). Set the .raw attribute of the AnnData object to the normalized and logarithmized raw gene expression for later use in differential testing and visualizations of gene expression. This simply freezes the state of the AnnData object. Note; You can get back an AnnData of the object in .raw by calling .raw.to_adata(). adata.raw = adata. Note; If you don’t proceed below with correcting the data with sc.pp.regress_out and scaling it via sc.pp.scale, you can also get away without using .raw at all.; The result of the previous highly-variable-genes detection is stored as an annotation in .var.highly_variable and auto-detected by PCA an",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering-2017.html:14145,variab,variable,14145,en/stable/tutorials/basics/clustering-2017.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering-2017.html,2,['variab'],['variable']
Modifiability,"anpyConfig.plot_suffix; scanpy._settings.ScanpyConfig.verbosity; scanpy._settings.ScanpyConfig.writedir; scanpy._settings.ScanpyConfig.N_PCS; scanpy._settings.ScanpyConfig.set_figure_params. scanpy.logging.print_header; scanpy.logging.print_versions. Datasets; scanpy.datasets.blobs; scanpy.datasets.ebi_expression_atlas; scanpy.datasets.krumsiek11; scanpy.datasets.moignard15; scanpy.datasets.pbmc3k; scanpy.datasets.pbmc3k_processed; scanpy.datasets.pbmc68k_reduced; scanpy.datasets.paul15; scanpy.datasets.toggleswitch; scanpy.datasets.visium_sge. Deprecated functions; scanpy.pp.filter_genes_dispersion; scanpy.pp.normalize_per_cell. External API; Preprocessing: PP; scanpy.external.pp.bbknn; scanpy.external.pp.harmony_integrate; scanpy.external.pp.mnn_correct; scanpy.external.pp.scanorama_integrate; scanpy.external.pp.hashsolo; scanpy.external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .md. .pdf. Deprecated functions. Deprecated functions#. pp.filter_genes_dispersion; Extract highly variable genes [Satija et al., 2015, Zheng et al., 2017]. pp.normalize_per_cell; Normalize total counts per cell. previous; scanpy.datasets.visium_sge. next; scanpy.pp.filter_genes_dispersion. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/deprecated.html:9316,variab,variable,9316,en/stable/api/deprecated.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/deprecated.html,1,['variab'],['variable']
Modifiability,"antir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.pl.scatter. Contents . scatter(). scanpy.pl.scatter#. scanpy.pl.scatter(adata, x=None, y=None, *, color=None, use_raw=None, layers=None, sort_order=True, alpha=None, basis=None, groups=None, components=None, projection='2d', legend_loc='right margin', legend_fontsize=None, legend_fontweight=None, legend_fontoutline=None, color_map=None, palette=None, frameon=None, right_margin=None, left_margin=None, size=None, marker='.', title=None, show=None, save=None, ax=None)[source]#; Scatter plot along observations or variables axes.; Color the plot using annotations of observations (.obs), variables; (.var) or expression of genes (.var_names). Parameters:. adata AnnDataAnnotated data matrix. x str | None (default: None)x coordinate. y str | None (default: None)y coordinate. color str | Collection[str] | None (default: None)Keys for annotations of observations/cells or variables/genes,; or a hex color specification, e.g.,; 'ann1', '#fe57a1', or ['ann1', 'ann2']. use_raw bool | None (default: None)Whether to use raw attribute of adata. Defaults to True if .raw is present. layers str | Collection[str] | None (default: None)Use the layers attribute of adata if present: specify the layer for; x, y and color. If layers is a string, then it is expanded to; (layers, layers, layers). basis Optional[Literal['pca', 'tsne', 'umap', 'diffmap', 'draw_graph_fr']] (default: None)String that denotes a plotting tool that computed coordinates. sort_order bool (default: True)For c",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pl.scatter.html:9748,variab,variables,9748,en/stable/generated/scanpy.pl.scatter.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pl.scatter.html,1,['variab'],['variables']
Modifiability,"at integrates datasets in a symmetric way as BBKNN, Scanorma, Conos, CCA (e.g. in Seurat) or a conditional VAE (e.g. in scVI, trVAE) would do, but comparable to the initiall MNN implementation in scran. Take a look at tools in the external API or at the ecoystem page to get a start with other tools. import scanpy as sc; import pandas as pd. sc.settings.verbosity = 1 # verbosity: errors (0), warnings (1), info (2), hints (3); sc.logging.print_versions(); sc.settings.set_figure_params(dpi=80, frameon=False, figsize=(3, 3), facecolor=""white""). scanpy==1.5.0 anndata==0.7.1 umap==0.4.2 numpy==1.18.1 scipy==1.4.1 pandas==1.0.3 scikit-learn==0.22.1 statsmodels==0.11.0. PBMCs#; We consider an annotated reference dataset adata_ref and a dataset for which you want to query labels and embeddings adata. # this is an earlier version of the dataset from the pbmc3k tutorial; adata_ref = sc.datasets.pbmc3k_processed(); adata = sc.datasets.pbmc68k_reduced(). To use sc.tl.ingest, the datasets need to be defined on the same variables. var_names = adata_ref.var_names.intersection(adata.var_names); adata_ref = adata_ref[:, var_names]; adata = adata[:, var_names]. The model and graph (here PCA, neighbors, UMAP) trained on the reference data will explain the biological variation observed within it. sc.pp.pca(adata_ref); sc.pp.neighbors(adata_ref); sc.tl.umap(adata_ref). The manifold still looks essentially the same as in the clustering tutorial. sc.pl.umap(adata_ref, color=""louvain""). Mapping PBMCs using ingest#; Let’s map labels and embeddings from adata_ref to adata based on a chosen representation. Here, we use adata_ref.obsm['X_pca'] to map cluster labels and the UMAP coordinates. sc.tl.ingest(adata, adata_ref, obs=""louvain""). adata.uns[""louvain_colors""] = adata_ref.uns[""louvain_colors""] # fix colors. sc.pl.umap(adata, color=[""louvain"", ""bulk_labels""], wspace=0.5). By comparing the ‘bulk_labels’ annotation with ‘louvain’, we see that the data has been reasonably mapped, only the annot",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/integrating-data-using-ingest.html:11867,variab,variables,11867,en/stable/tutorials/basics/integrating-data-using-ingest.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/integrating-data-using-ingest.html,2,['variab'],['variables']
Modifiability,"ation annotation .obs representing time points. Time; points should be categorical of dtype=category. The unique categories for; the categorical will be used as the time points to construct the timepoint; connections. n_neighbors int (default: 30)Number of nearest neighbors for graph construction. n_components int | None (default: 1000)Minimum number of principal components to use. Specify None to use; pre-computed components. The higher the value the better to capture 85% of the; variance. n_jobs int (default: -2)Nearest Neighbors will be computed in parallel using n_jobs. copy bool (default: False)Return a copy instead of writing to adata. Return type:; AnnData | None. Returns:; Depending on copy, returns or updates .obsm, .obsp and .uns with the following:. X_harmony - ndarray (obsm, dtype float)force directed layout. harmony_aff - spmatrix (obsp, dtype float)affinity matrix. harmony_aff_aug - spmatrix (obsp, dtype float)augmented affinity matrix. harmony_timepoint_var - str (uns)The name of the variable passed as tp. harmony_timepoint_connections - ndarray (uns, dtype str)The links between time points. Example; >>> from itertools import product; >>> import pandas as pd; >>> from anndata import AnnData; >>> import scanpy as sc; >>> import scanpy.external as sce. Load AnnData; A sample with real data is available here.; Random data sets of three time points with two replicates each:; >>> adata_ref = sc.datasets.pbmc3k(); >>> start = [596, 615, 1682, 1663, 1409, 1432]; >>> adata = AnnData.concatenate(; ... *(adata_ref[i : i + 1000] for i in start),; ... join=""outer"",; ... batch_key=""sample"",; ... batch_categories=[f""sa{i}_Rep{j}"" for i, j in product((1, 2, 3), (1, 2))],; ... ); >>> time_points = adata.obs[""sample""].str.split(""_"", expand=True)[0]; >>> adata.obs[""time_points""] = pd.Categorical(; ... time_points, categories=['sa1', 'sa2', 'sa3']; ... ). Normalize and filter for highly expressed genes; >>> sc.pp.normalize_total(adata, target_sum=10000); >>> sc.pp.log1p",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.harmony_timeseries.html:11455,variab,variable,11455,en/stable/external/generated/scanpy.external.tl.harmony_timeseries.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.harmony_timeseries.html,2,['variab'],['variable']
Modifiability,"axs[2]); sns.histplot(; adata.obs[""n_genes_by_counts""][adata.obs[""n_genes_by_counts""] < 4000],; kde=False,; bins=60,; ax=axs[3],; ). sc.datasets.visium_sge downloads the filtered visium dataset, the output of spaceranger that contains only spots within the tissue slice. Indeed, looking at standard QC metrics we can observe that the samples do not contain empty spots.; We proceed to normalize Visium counts data with the built-in normalize_total method from Scanpy, and detect highly-variable genes (for later). As discussed previously, note that there are more sensible alternatives for normalization (see discussion in sc-tutorial paper and more recent alternatives such as SCTransform or GLM-PCA). for adata in [; adata_spatial_anterior,; adata_spatial_posterior,; ]:; sc.pp.normalize_total(adata, inplace=True); sc.pp.log1p(adata); sc.pp.highly_variable_genes(adata, flavor=""seurat"", n_top_genes=2000, inplace=True). normalizing counts per cell; finished (0:00:00); extracting highly variable genes; finished (0:00:00); --> added; 'highly_variable', boolean vector (adata.var); 'means', float vector (adata.var); 'dispersions', float vector (adata.var); 'dispersions_norm', float vector (adata.var); normalizing counts per cell; finished (0:00:00); extracting highly variable genes; finished (0:00:00); --> added; 'highly_variable', boolean vector (adata.var); 'means', float vector (adata.var); 'dispersions', float vector (adata.var); 'dispersions_norm', float vector (adata.var). Data integration#; We are now ready to perform integration of the two dataset. As mentioned before, we will be using Scanorama for that. Scanorama returns two lists, one for the integrated embeddings and one for the corrected counts, for each dataset.; We would like to note that in this context using BBKNN or Ingest is also possible. adatas = [adata_spatial_anterior, adata_spatial_posterior]; adatas_cor = scanorama.correct_scanpy(adatas, return_dimred=True). Found 32285 genes among all datasets; [[0. 0.488",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html:15385,variab,variable,15385,en/stable/tutorials/spatial/integration-scanorama.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html,2,['variab'],['variable']
Modifiability,"ayer=None, obsm=None, mask_obs=None)[source]#; Scale data to unit variance and zero mean. Note; Variables (genes) that do not display any variation (are constant across; all observations) are retained and (for zero_center==True) set to 0; during this operation. In the future, they might be set to NaNs. Parameters:. data AnnData | spmatrix | ndarray | ArrayThe (annotated) data matrix of shape n_obs × n_vars.; Rows correspond to cells and columns to genes. zero_center bool (default: True)If False, omit zero-centering variables, which allows to handle sparse; input efficiently. max_value float | None (default: None)Clip (truncate) to this value after scaling. If None, do not clip. copy bool (default: False)Whether this function should be performed inplace. If an AnnData object; is passed, this also determines if a copy is returned. layer str | None (default: None)If provided, which element of layers to scale. obsm str | None (default: None)If provided, which element of obsm to scale. mask_obs ndarray[Any, dtype[bool]] | str | None (default: None)Restrict both the derivation of scaling parameters and the scaling itself; to a certain set of observations. The mask is specified as a boolean array; or a string referring to an array in obs.; This will transform data from csc to csr format if issparse(data). Return type:; AnnData | spmatrix | ndarray | Array | None. Returns:; Returns None if copy=False, else returns an updated AnnData object. Sets the following fields:. adata.X | adata.layers[layer]numpy.ndarray | scipy.sparse._csr.csr_matrix (dtype float)Scaled count data matrix. adata.var['mean']pandas.Series (dtype float)Means per gene before scaling. adata.var['std']pandas.Series (dtype float)Standard deviations per gene before scaling. adata.var['var']pandas.Series (dtype float)Variances per gene before scaling. previous; scanpy.pp.regress_out. next; scanpy.pp.subsample. Contents; . scale(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.scale.html:10852,layers,layers,10852,en/stable/generated/scanpy.pp.scale.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.scale.html,1,['layers'],['layers']
Modifiability,"browser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.tl.rank_genes_groups. Contents . rank_genes_groups(). scanpy.tl.rank_genes_groups#. scanpy.tl.rank_genes_groups(adata, groupby, *, mask_var=None, use_raw=None, groups='all', reference='rest', n_genes=None, rankby_abs=False, pts=False, key_added=None, copy=False, method=None, corr_method='benjamini-hochberg', tie_correct=False, layer=None, **kwds)[source]#; Rank genes for characterizing groups.; Expects logarithmized data. Parameters:. adata AnnDataAnnotated data matrix. groupby strThe key of the observations grouping to consider. mask_var ndarray[Any, dtype[bool]] | str | None (default: None)Select subset of genes to use in statistical tests. use_raw bool | None (default: None)Use raw attribute of adata if present. layer str | None (default: None)Key from adata.layers whose value will be used to perform tests on. groups Union[Literal['all'], Iterable[str]] (default: 'all')Subset of groups, e.g. ['g1', 'g2', 'g3'], to which comparison; shall be restricted, or 'all' (default), for all groups. Note that if; reference='rest' all groups will still be used as the reference, not; just those specified in groups. reference str (default: 'rest')If 'rest', compare each group to the union of the rest of the group.; If a group identifier, compare with respect to this group. n_genes int | None (default: None)The number of genes that appear in the returned tables.; Defaults to all genes. method Optional[Literal['logreg', 't-test', 'wilcoxon', 't-test_overestim_var']] (default: None)The default method is 't-test',; 't-test_overestim_var' overestimates variance of each group,; 'wilcoxon' uses Wilcoxon rank-sum,; 'logreg' uses logistic regression. See Ntranos et al. [2019],; here and here,; for why this is meaningful. corr_method Literal['benjamini-hochberg', 'bonferroni'] (default: 'b",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.rank_genes_groups.html:10015,layers,layers,10015,en/stable/generated/scanpy.tl.rank_genes_groups.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.rank_genes_groups.html,1,['layers'],['layers']
Modifiability,"canpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.pl.scatter. Contents . scatter(). scanpy.pl.scatter#. scanpy.pl.scatter(adata, x=None, y=None, *, color=None, use_raw=None, layers=None, sort_order=True, alpha=None, basis=None, groups=None, components=None, projection='2d', legend_loc='right margin', legend_fontsize=None, legend_fontweight=None, legend_fontoutline=None, color_map=None, palette=None, frameon=None, right_margin=None, left_margin=None, size=None, marker='.', title=None, show=None, save=None, ax=None)[source]#; Scatter plot along observations or variables axes.; Color the plot using annotations of observations (.obs), variables; (.var) or expression of genes (.var_names). Parameters:. adata AnnDataAnnotated data matrix. x str | None (default: None)x coordinate. y str | None (default: None)y coordinate. color str | Collection[str] | None (default: None)Keys for annotations of observations/cells or variables/genes,; or a hex color specification, e.g.,; 'ann1', '#fe57a1', or ['ann1', 'ann2']. use_raw bool | None (default: None)Whether to use raw attribute of adata. Defaults to True if .raw is present. layers str | Collection[str] | None (default: None)Use the layers attribute of adata if present: specify the layer for; x, y and color. If layers is a string, then it is expanded to; (layers, layers, layers). basis Optional[Literal['pca', 'tsne', 'umap', 'diffmap', 'draw_graph_fr']] (default: None)String that denotes a plotting tool that computed coordinates. sort_order bool (default: True)For continuous annotations used as color parameter, plot data points; with higher values on top of others. groups str | I",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pl.scatter.html:9822,variab,variables,9822,en/stable/generated/scanpy.pl.scatter.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pl.scatter.html,1,['variab'],['variables']
Modifiability,"canpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.tl.diffmap. Contents . diffmap(). scanpy.tl.diffmap#. scanpy.tl.diffmap(adata, n_comps=15, *, neighbors_key=None, random_state=0, copy=False)[source]#; Diffusion Maps [Coifman et al., 2005, Haghverdi et al., 2015, Wolf et al., 2018].; Diffusion maps [Coifman et al., 2005] has been proposed for visualizing single-cell; data by Haghverdi et al. [2015]. The tool uses the adapted Gaussian kernel suggested; by Haghverdi et al. [2016] in the implementation of Wolf et al. [2018].; The width (“sigma”) of the connectivity kernel is implicitly determined by; the number of neighbors used to compute the single-cell graph in; neighbors(). To reproduce the original implementation; using a Gaussian kernel, use method=='gauss' in; neighbors(). To use an exponential kernel, use the default; method=='umap'. Differences between these options shouldn’t usually be; dramatic. Parameters:. adata AnnDataAnnotated data matrix. n_comps int (default: 15)The number of dimensions of the representation. neighbors_key str | None (default: None)If not specified, diffmap looks .uns[‘neighbors’] for neighbors settings; and .obsp[‘connectivities’], .obsp[‘distances’] for connectivities and; distances respectively (default storage places for pp.neighbors).; If specified, diffmap looks .uns[neighbors_key] for neighbors settings and; .obsp[.uns[neighbors_key][‘connectivities_key’]],; .obsp[.uns[neighbors",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.diffmap.html:9604,adapt,adapted,9604,en/stable/generated/scanpy.tl.diffmap.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.diffmap.html,1,['adapt'],['adapted']
Modifiability,"canpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.datasets.pbmc3k. Contents . pbmc3k(). scanpy.datasets.pbmc3k#. scanpy.datasets.pbmc3k()[source]#; 3k PBMCs from 10x Genomics.; The data consists in 3k PBMCs from a Healthy Donor and is freely available; from 10x Genomics (file from this webpage).; The exact same data is also used in Seurat’s basic clustering tutorial. Note; This downloads 5.9 MB of data upon the first call of the function and stores it in; datasetdir/pbmc3k_raw.h5ad. The following code was run to produce the file.; adata = sc.read_10x_mtx(; # the directory with the `.mtx` file; './data/filtered_gene_bc_matrices/hg19/',; # use gene symbols for the variable names (variables-axis index); var_names='gene_symbols',; # write a cache file for faster subsequent reading; cache=True,; ). adata.var_names_make_unique() # this is unnecessary if using 'gene_ids'; adata.write('write/pbmc3k_raw.h5ad', compression='gzip'). Return type:; AnnData. Returns:; Annotated data matrix. Examples; >>> import scanpy as sc; >>> sc.datasets.pbmc3k(); AnnData object with n_obs × n_vars = 2700 × 32738; var: 'gene_ids'. previous; scanpy.datasets.moignard15. next; scanpy.datasets.pbmc3k_processed. Contents; . pbmc3k(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.datasets.pbmc3k.html:9859,variab,variable,9859,en/stable/generated/scanpy.datasets.pbmc3k.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.datasets.pbmc3k.html,2,['variab'],"['variable', 'variables-axis']"
Modifiability,"canpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.pp.highly_variable_genes. Contents . highly_variable_genes(). scanpy.pp.highly_variable_genes#. scanpy.pp.highly_variable_genes(adata, *, layer=None, n_top_genes=None, min_disp=0.5, max_disp=inf, min_mean=0.0125, max_mean=3, span=0.3, n_bins=20, flavor='seurat', subset=False, inplace=True, batch_key=None, check_values=True)[source]#; Annotate highly variable genes [Satija et al., 2015, Stuart et al., 2019, Zheng et al., 2017].; Expects logarithmized data, except when flavor='seurat_v3'/'seurat_v3_paper', in which count; data is expected.; Depending on flavor, this reproduces the R-implementations of Seurat; [Satija et al., 2015], Cell Ranger [Zheng et al., 2017], and Seurat v3 [Stuart et al., 2019].; 'seurat_v3'/'seurat_v3_paper' requires scikit-misc package. If you plan to use this flavor, consider; installing scanpy with this optional dependency: scanpy[skmisc].; For the dispersion-based methods (flavor='seurat' Satija et al. [2015] and; flavor='cell_ranger' Zheng et al. [2017]), the normalized dispersion is obtained; by scaling with the mean and standard deviation of the dispersions for genes; falling into a given bin for mean expression of genes. This means that for each; bin of mean expression, highly variable genes are selected.; For flavor='seurat_v3'/'seurat_v3_paper' [Stuart et",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.highly_variable_genes.html:9599,variab,variable,9599,en/stable/generated/scanpy.pp.highly_variable_genes.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.highly_variable_genes.html,1,['variab'],['variable']
Modifiability,"ced representation with t-SNE and perform Leiden clustering, which is again taken from the PBMC3k tutorial.; This is just one of many possible pipelines: After PCA, you could also use UMAP or other embeddings to inspect the data, and cluster the data with a different algorithm than Leiden. Preparations#; Because we will transform the raw data in adata.X to residuals in the next step, we first save a copy of the raw counts to adata.layers['raw']. Also, we save a depth-normalized and square-root transformed version of the data to adata.layers['sqrt_norm'], so we can use them for plotting normalized counts later. Further background on why to use the square-root transform here can be found in Wagner (2020). # keep raw and depth-normalized counts for later; adata_pbmc3k.layers[""raw""] = adata_pbmc3k.X.copy(); adata_pbmc3k.layers[""sqrt_norm""] = np.sqrt(; sc.pp.normalize_total(adata_pbmc3k, inplace=False)[""X""]; ). adata_pbmc10k.layers[""raw""] = adata_pbmc10k.X.copy(); adata_pbmc10k.layers[""sqrt_norm""] = np.sqrt(; sc.pp.normalize_total(adata_pbmc10k, inplace=False)[""X""]; ). normalizing counts per cell; finished (0:00:00); normalizing counts per cell; finished (0:00:00). Compute Pearson residuals#; This will transform the sparse raw counts in adata.X to a dense matrix of Pearson residuals. for adata in [adata_pbmc3k, adata_pbmc10k]:; sc.experimental.pp.normalize_pearson_residuals(adata). computing analytic Pearson residuals on adata.X; finished (0:00:00); computing analytic Pearson residuals on adata.X; finished (0:00:00). Compute PCA and t-SNE#; We now reduce the dimensionality of the data by running PCA on the Pearson residuals. On top, we run t-SNE for vizualisation. for adata in [adata_pbmc3k, adata_pbmc10k]:; sc.pp.pca(adata, n_comps=50); n_cells = len(adata); sc.tl.tsne(adata, use_rep=""X_pca""). computing PCA; with n_comps=50; finished (0:00:27); computing tSNE; using sklearn.manifold.TSNE; finished: added; 'X_tsne', tSNE coordinates (adata.obsm) (0:00:12); computing PCA; ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:24597,layers,layers,24597,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,2,['layers'],['layers']
Modifiability,"clipping of array in scale() pr3100 P Ashish & S Dicks. 1.10.1 2024-04-09#. Documentation#. Added how-to example on plotting with Marsilea pr2974 Y Zheng. Bug fixes#. Fix aggregate when aggregating by more than two groups pr2965 I Virshup. Performance#. scale() now uses numba kernels for sparse.csr_matrix and sparse.csc_matrix when zero_center==False and mask_obs is provided. This greatly speed up execution pr2942 S Dicks. 1.10.0 2024-03-26#; scanpy 1.10 brings a large amount of new features, performance improvements, and improved documentation.; Some highlights:. Improved support for out-of-core workflows via dask. See new tutorial: Using dask with Scanpy demonstrating counts-to-clusters for 1.4 million cells in <10 min.; A new basic clustering tutorial demonstrating an updated workflow.; Opt-in increased performance for neighbor search and clustering (how to guide).; Ability to mask observations or variables from a number of methods (see Customizing Scanpy plots for an example with plotting embeddings); A new function aggregate() for computing aggregations of your data, very useful for pseudo bulking!. Features#. scrublet() and scrublet_simulate_doublets() were moved from scanpy.external.pp to scanpy.pp. The scrublet implementation is now maintained as part of scanpy pr2703 P Angerer; scanpy.pp.pca(), scanpy.pp.scale(), scanpy.pl.embedding(), and scanpy.experimental.pp.normalize_pearson_residuals_pca() now support a mask parameter pr2272 C Bright, T Marcella, & P Angerer; Enhanced dask support for some internal utilities, paving the way for more extensive dask support pr2696 P Angerer; scanpy.pp.highly_variable_genes() supports dask for the default seurat and cell_ranger flavors pr2809 P Angerer; New function scanpy.get.aggregate() which allows grouped aggregations over your data. Useful for pseudobulking! pr2590 Isaac Virshup Ilan Gold Jon Bloom; scanpy.pp.neighbors() now has a transformer argument allowing the use of different ANN/ KNN libraries pr2536 P Angerer;",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:14538,variab,variables,14538,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,1,['variab'],['variables']
Modifiability,"d 0 we set vmax to maximal absolut value and vmin to; # the negative value of maxabs; maxabs = max(abs(adata.obs[""B_cell_score""])); sc.pl.umap(; adata, color=""B_cell_score"", cmap=""coolwarm"", s=20, vmin=-maxabs, vmax=maxabs; ); adata.obs.drop(""B_cell_score"", axis=1, inplace=True). matplotlib also supports custom color palettes with scaling (e.g. log), value range normalisation, centering, and custom color combinations or dynamic ranges. # Log-scaled palette. # Make mock column with log-normally distirbuited values; adata.obs[""lognormal""] = np.random.lognormal(3, 1, adata.shape[0]). # Log scaling of the palette; norm = mcolors.LogNorm(); sc.pl.umap(adata, color=""lognormal"", s=20, norm=norm). adata.obs.drop(""lognormal"", axis=1, inplace=True). # Centered non-symmetric palette. # Make mock column for plotting, here we use B cell score; sc.tl.score_genes(adata, [""CD79A"", ""MS4A1""], score_name=""B_cell_score""). # Palette normalization with centering and adapted dynamic range to correspond to; # the distance of vmin and vmax from the cenetr; # Adapted from https://stackoverflow.com/a/50003503; class MidpointNormalize(mcolors.Normalize):; def __init__(self, vmin=None, vmax=None, midpoint=0, clip=False):; self.midpoint = midpoint; mcolors.Normalize.__init__(self, vmin, vmax, clip). def __call__(self, value, clip=None):; value = np.array(value).astype(float); normalized_min = max(; 0.0,; 0.5; * (1.0 - abs((self.midpoint - self.vmin) / (self.midpoint - self.vmax))),; ); normalized_max = min(; 1.0,; 0.5; * (1.0 + abs((self.vmax - self.midpoint) / (self.midpoint - self.vmin))),; ); normalized_mid = 0.5; x, y = (; [self.vmin, self.midpoint, self.vmax],; [normalized_min, normalized_mid, normalized_max],; ); return np.ma.masked_array(np.interp(value, x, y)). # Add padding arround vmin and vmax as Colorbar sets value limits to round numbers below and; # above the vmin and vmax, respectively, which means that they can not be assigned the correct; # color with our nomalisation function t",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/advanced.html:28171,adapt,adapted,28171,en/stable/tutorials/plotting/advanced.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/advanced.html,3,"['Adapt', 'adapt']","['Adapted', 'adapted']"
Modifiability,"d genes. fig, axs = plt.subplots(1, 4, figsize=(15, 4)); sns.histplot(adata.obs[""total_counts""], kde=False, ax=axs[0]); sns.histplot(; adata.obs[""total_counts""][adata.obs[""total_counts""] < 10000],; kde=False,; bins=40,; ax=axs[1],; ); sns.histplot(adata.obs[""n_genes_by_counts""], kde=False, bins=60, ax=axs[2]); sns.histplot(; adata.obs[""n_genes_by_counts""][adata.obs[""n_genes_by_counts""] < 4000],; kde=False,; bins=60,; ax=axs[3],; ). <Axes: xlabel='n_genes_by_counts', ylabel='Count'>. sc.pp.filter_cells(adata, min_counts=5000); sc.pp.filter_cells(adata, max_counts=35000); adata = adata[adata.obs[""pct_counts_mt""] < 20].copy(); print(f""#cells after MT filter: {adata.n_obs}""); sc.pp.filter_genes(adata, min_cells=10). filtered out 44 cells that have less than 5000 counts; filtered out 130 cells that have more than 35000 counts; #cells after MT filter: 3861; filtered out 16916 genes that are detected in less than 10 cells. We proceed to normalize Visium counts data with the built-in normalize_total method from Scanpy, and detect highly-variable genes (for later). Note that there are alternatives for normalization (see discussion in [Luecken19], and more recent alternatives such as SCTransform or GLM-PCA). sc.pp.normalize_total(adata, inplace=True); sc.pp.log1p(adata); sc.pp.highly_variable_genes(adata, flavor=""seurat"", n_top_genes=2000). normalizing counts per cell; finished (0:00:00); extracting highly variable genes; finished (0:00:00); --> added; 'highly_variable', boolean vector (adata.var); 'means', float vector (adata.var); 'dispersions', float vector (adata.var); 'dispersions_norm', float vector (adata.var). Manifold embedding and clustering based on transcriptional similarity#; To embed and cluster the manifold encoded by transcriptional similarity, we proceed as in the standard clustering tutorial. sc.pp.pca(adata); sc.pp.neighbors(adata); sc.tl.umap(adata); sc.tl.leiden(; adata, key_added=""clusters"", flavor=""igraph"", directed=False, n_iterations=2; ). computing PC",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/basic-analysis.html:14911,variab,variable,14911,en/stable/tutorials/spatial/basic-analysis.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/basic-analysis.html,2,['variab'],['variable']
Modifiability,"d in Lause et al. (2021).; The call to highly_variable_genes(flavor='pearson_residuals',n_top_genes=2000) computes the residual variances and selects 2000 genes based on this. As shown in the plots below, cell type marker genes known a priori are successfully selected. Compute 2000 variable genes with Pearson residuals#; This will create the field highly_variable, indicating the 2000 genes that have the most variable Pearson residuals. for adata in [adata_pbmc3k, adata_pbmc10k]:; sc.experimental.pp.highly_variable_genes(; adata, flavor=""pearson_residuals"", n_top_genes=2000; ). extracting highly variable genes; --> added; 'highly_variable', boolean vector (adata.var); 'highly_variable_rank', float vector (adata.var); 'highly_variable_nbatches', int vector (adata.var); 'highly_variable_intersection', boolean vector (adata.var); 'means', float vector (adata.var); 'variances', float vector (adata.var); 'residual_variances', float vector (adata.var); extracting highly variable genes; --> added; 'highly_variable', boolean vector (adata.var); 'highly_variable_rank', float vector (adata.var); 'highly_variable_nbatches', int vector (adata.var); 'highly_variable_intersection', boolean vector (adata.var); 'means', float vector (adata.var); 'variances', float vector (adata.var); 'residual_variances', float vector (adata.var). Plot gene selection#; To illustrate the selection procedure, we plot mean and residual variance of each gene, highlighting the selected genes (red). On top, we plot the known marker genes defined in the beginning (black). We can see that all of them are selected, as desired. fig, axes = plt.subplots(1, 2, figsize=(12, 6)); for ax, adata in zip(axes, [adata_pbmc3k, adata_pbmc10k]):; hvgs = adata.var[""highly_variable""]. ax.scatter(; adata.var[""mean_counts""], adata.var[""residual_variances""], s=3, edgecolor=""none""; ); ax.scatter(; adata.var[""mean_counts""][hvgs],; adata.var[""residual_variances""][hvgs],; c=""tab:red"",; label=""selected genes"",; s=3,; edgecolor=""no",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:19236,variab,variable,19236,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,2,['variab'],['variable']
Modifiability,"d indexing byg in ~scanpy.pp.highly_variable_genes pr1456 V Bergen; Fix default number of genes for marker_genes_overlap pr1464 MD Luecken; Fixed passing groupby and dendrogram_key to dendrogram() pr1465 M Varma; Fixed download path of pbmc3k_processed pr1472 D Strobl; Better error message when computing DE with a group of size 1 pr1490 J Manning; Update cugraph API usage for v0.16 pr1494 R Ilango; Fixed marker_gene_overlap default value for top_n_markers pr1464 MD Luecken; Pass random_state to RAPIDs UMAP pr1474 C Nolet; Fixed anndata version requirement for concat() (re-exported from scanpy as sc.concat) pr1491 I Virshup; Fixed the width of the progress bar when downloading data pr1507 M Klein; Updated link for moignard15 dataset pr1542 I Virshup; Fixed bug where calling set_figure_params could block if IPython was installed, but not used. pr1547 I Virshup; violin() no longer fails if .raw not present pr1548 I Virshup; spatial() refactoring and better handling of spatial data pr1512 G Palla; pca() works with chunked=True again pr1592 I Virshup; ingest() now works with umap-learn 0.5.0 pr1601 S Rybakov. Version 1.6#. 1.6.0 2020-08-15#; This release includes an overhaul of dotplot(), matrixplot(), and stacked_violin() (pr1210 F Ramirez), and of the internals of rank_genes_groups() (pr1156 S Rybakov). Overhaul of dotplot(), matrixplot(), and stacked_violin() pr1210 F Ramirez#. An overhauled tutorial Core plotting functions.; New plotting classes can be accessed directly (e.g., DotPlot) or using the return_fig param.; It is possible to plot log fold change and p-values in the rank_genes_groups_dotplot() family of functions.; Added ax parameter which allows embedding the plot in other images.; Added option to include a bar plot instead of the dendrogram containing the cell/observation totals per category.; Return a dictionary of axes for further manipulation. This includes the main plot, legend and dendrogram to totals; Legends can be removed.; The groupby param can tak",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:33868,refactor,refactoring,33868,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,1,['refactor'],['refactoring']
Modifiability,"data using UMAP. where adata is an AnnData object.; Each of these calls adds annotation to an expression matrix X,; which stores n_obs observations (cells) of n_vars variables (genes).; For each tool, there typically is an associated plotting function in sc.pl:; sc.pl.umap(adata, **plotting_params). If you pass show=False, a Axes instance is returned; and you have all of matplotlib’s detailed configuration possibilities.; To facilitate writing memory-efficient pipelines, by default,; Scanpy tools operate inplace on adata and return None –; this also allows to easily transition to out-of-memory pipelines.; If you want to return a copy of the AnnData object; and leave the passed adata unchanged, pass copy=True or inplace=False. AnnData#; Scanpy is based on anndata, which provides the AnnData class. At the most basic level, an AnnData object adata stores; a data matrix adata.X, annotation of observations; adata.obs and variables adata.var as pd.DataFrame and unstructured; annotation adata.uns as dict. Names of observations and; variables can be accessed via adata.obs_names and adata.var_names,; respectively. AnnData objects can be sliced like; dataframes, for example, adata_subset = adata[:, list_of_gene_names].; For more, see this blog post.; To read a data file to an AnnData object, call:; adata = sc.read(filename). to initialize an AnnData object. Possibly add further annotation using, e.g., pd.read_csv:; import pandas as pd; anno = pd.read_csv(filename_sample_annotation); adata.obs['cell_groups'] = anno['cell_groups'] # categorical annotation of type pandas.Categorical; adata.obs['time'] = anno['time'] # numerical annotation of type float; # alternatively, you could also set the whole dataframe; # adata.obs = anno. To write, use:; adata.write(filename); adata.write_csvs(filename); adata.write_loom(filename). previous; Using dask with Scanpy. next; How to. Contents; . Workflow; AnnData. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/usage-principles.html:10543,variab,variables,10543,en/stable/usage-principles.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/usage-principles.html,1,['variab'],['variables']
Modifiability,"dense arrays without centering pr1160 simonwm; regress_out() now works when some features are constant pr1194 simonwm; normalize_total() errored if the passed object was a view pr1200 I Virshup; neighbors() sometimes ignored the n_pcs param pr1124 V Bergen; ebi_expression_atlas() which contained some out-of-date URLs pr1102 I Virshup; ingest() for UMAP 0.4 pr1165 S Rybakov; louvain() for Louvain 0.6 pr1197 I Virshup; highly_variable_genes() which could lead to incorrect results when the batch_key argument was used pr1180 G Eraslan; ingest() where an inconsistent number of neighbors was used pr1111 S Rybakov. Version 1.4#. 1.4.6 2020-03-17#. Functionality in external#. sam() self-assembling manifolds [Tarashansky et al., 2019] pr903 A Tarashansky; harmony_timeseries() for trajectory inference on discrete time points pr994 A Mousa; wishbone() for trajectory inference (bifurcations) pr1063 A Mousa. Code design#. violin now reads .uns['colors_...'] pr1029 michalk8. Bug fixes#. adapt ingest() for UMAP 0.4 pr1038 pr1106 S Rybakov; compat with matplotlib 3.1 and 3.2 pr1090 I Virshup, P Angerer; fix PAGA for new igraph pr1037 P Angerer; fix rapids compat of louvain pr1079 LouisFaure. 1.4.5 2019-12-30#; Please install scanpy==1.4.5.post3 instead of scanpy==1.4.5. New functionality#. ingest() maps labels and embeddings of reference data to new data Integrating data using ingest and BBKNN pr651 S Rybakov, A Wolf; queries recieved many updates including enrichment through gprofiler and more advanced biomart queries pr467 I Virshup; set_figure_params() allows setting figsize and accepts facecolor='white', useful for working in dark mode A Wolf. Code design#. downsample_counts now always preserves the dtype of it’s input, instead of converting floats to ints pr865 I Virshup; allow specifying a base for log1p() pr931 G Eraslan; run neighbors on a GPU using rapids pr830 T White; param docs from typed params P Angerer; embedding_density() now only takes one positional argument; simil",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:40283,adapt,adapt,40283,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,1,['adapt'],['adapt']
Modifiability,"dict).; Always specify what these contain, e.g. {'a': (1, 2)} → Mapping[str, Tuple[int, int]].; If you can’t use one of those, use a concrete class like AnnData.; If your parameter only accepts an enumeration of strings, specify them like so: Literal['elem-1', 'elem-2']. Returns section#; There are three types of return sections – prose, tuple, and a mix of both. Prose is for simple cases.; Tuple return sections are formatted like parameters. Other than in numpydoc, each tuple is first characterized by the identifier and not by its type. Provide type annotation in the function header.; Mix of prose and tuple is relevant in complicated cases, e.g. when you want to describe that you added something as annotation to an `AnnData` object. Examples#; For simple cases, use prose as in normalize_total():; Returns; -------; Returns dictionary with normalized copies of `adata.X` and `adata.layers`; or updates `adata` with normalized versions of the original; `adata.X` and `adata.layers`, depending on `inplace`. For tuple return values, you can use the standard numpydoc way of populating it,; e.g. as in calculate_qc_metrics().; Do not add types in the docstring, but specify them in the function signature:; def myfunc(...) -> tuple[int, str]:; """"""; ...; Returns; -------; one_identifier; Description.; second_identifier; Description 2.; """"""; ... Many functions also just modify parts of the passed AnnData object, like e.g. dpt().; You can then combine prose and lists to best describe what happens:; Returns; -------; Depending on `copy`, returns or updates `adata` with the following fields. If `n_branchings==0`, no field `dpt_groups` will be written. dpt_pseudotime : :class:`~pandas.Series` (`adata.obs`, dtype `float`); Array of dim (number of samples) that stores the pseudotime of each; cell, that is, the DPT distance with respect to the root cell.; dpt_groups : :class:`pandas.Series` (`adata.obs`, dtype `category`); Array of dim (number of samples) that stores the subgroup id ('0",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/dev/documentation.html:13906,layers,layers,13906,en/stable/dev/documentation.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/dev/documentation.html,1,['layers'],['layers']
Modifiability,"dom_state=0, return_info=False, mask_var=_empty, use_highly_variable=None, dtype='float32', chunked=False, chunk_size=None, copy=False)[source]#; Principal component analysis [Pedregosa et al., 2011].; Computes PCA coordinates, loadings and variance decomposition.; Uses the implementation of scikit-learn [Pedregosa et al., 2011]. Changed in version 1.5.0: In previous versions, computing a PCA on a sparse matrix would make; a dense copy of the array for mean centering.; As of scanpy 1.5.0, mean centering is implicit.; While results are extremely similar, they are not exactly the same.; If you would like to reproduce the old results, pass a dense array. Parameters:. data AnnData | ndarray | spmatrixThe (annotated) data matrix of shape n_obs × n_vars.; Rows correspond to cells and columns to genes. n_comps int | None (default: None)Number of principal components to compute. Defaults to 50, or 1 - minimum; dimension size of selected representation. layer str | None (default: None)If provided, which element of layers to use for PCA. zero_center bool | None (default: True)If True, compute standard PCA from covariance matrix.; If False, omit zero-centering variables; (uses scikit-learn TruncatedSVD or; dask-ml TruncatedSVD),; which allows to handle sparse input efficiently.; Passing None decides automatically based on sparseness of the data. svd_solver str | None (default: None)SVD solver to use:. NoneSee chunked and zero_center descriptions to determine which class will be used.; Depending on the class and the type of X different values for default will be set.; If scikit-learn PCA is used, will give 'arpack',; if scikit-learn TruncatedSVD is used, will give 'randomized',; if dask-ml PCA or IncrementalPCA is used, will give 'auto',; if dask-ml TruncatedSVD is used, will give 'tsqr'. 'arpack'for the ARPACK wrapper in SciPy (svds()); Not available with dask arrays. 'randomized'for the randomized algorithm due to Halko (2009). For dask arrays,; this will use svd_compressed().",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.pca.html:10379,layers,layers,10379,en/stable/generated/scanpy.pp.pca.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.pca.html,1,['layers'],['layers']
Modifiability,"e and the tenth var_name.; By giving more positions, more brackets/color blocks are drawn. var_group_labels Sequence[str] | None (default: None)Labels for each of the var_group_positions that want to be highlighted. var_group_rotation float | None (default: None)Label rotation degrees.; By default, labels larger than 4 characters are rotated 90 degrees. layer str | None (default: None)Name of the AnnData object layer that wants to be plotted. By default adata.raw.X is plotted.; If use_raw=False is set, then adata.X is plotted. If layer is set to a valid layer name,; then the layer is plotted. layer takes precedence over use_raw. title str | None (default: None)Title for the figure. colorbar_title str | None (default: 'Mean expression\\nin group')Title for the color bar. New line character (n) can be used. cmap str | None (default: 'viridis')String denoting matplotlib color map. standard_scale Optional[Literal['var', 'group']] (default: None)Whether or not to standardize the given dimension between 0 and 1, meaning for; each variable or group, subtract the minimum and divide each by its maximum. swap_axes bool (default: False)By default, the x axis contains var_names (e.g. genes) and the y axis; the groupby categories. By setting swap_axes then x are the; groupby categories and y the var_names. return_fig bool | None (default: False)Returns DotPlot object. Useful for fine-tuning; the plot. Takes precedence over show=False. show bool | None (default: None)Show the plot, do not return axis. save str | bool | None (default: None)If True or a str, save the figure.; A string is appended to the default filename.; Infer the filetype if ending on {'.pdf', '.png', '.svg'}. ax _AxesSubplot | None (default: None)A matplotlib axes object. Only works if plotting a single component. vmin float | None (default: None)The value representing the lower limit of the color scale. Values smaller than vmin are plotted; with the same color as vmin. vmax float | None (default: None)The value ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pl.matrixplot.html:13190,variab,variable,13190,en/stable/generated/scanpy.pl.matrixplot.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pl.matrixplot.html,1,['variab'],['variable']
Modifiability,"e). ncol = 2; nrow = 1; figsize = 3; wspace = 1; # Adapt figure size based on number of rows and columns and added space between them; # (e.g. wspace between columns); fig, axs = plt.subplots(; nrow, ncol, figsize=(ncol * figsize + (ncol - 1) * wspace * figsize, nrow * figsize); ); plt.subplots_adjust(wspace=wspace); sc.pl.umap(adata, color=""louvain"", ax=axs[0], show=False); sc.pl.umap(adata, color=""phase"", ax=axs[1]). Adjust space between subplots#; When plotting multiple plots (e.g. with embedding) in the same row or column it may happen that the legend overlaps with the neighbouring plot. This can be overcomed by setting wspace (width) or hspace (height). These parameters can be likewise used when creating Axes for plotting (see the above section on using matplotlib Axes). # Default, legend is overlapping; sc.pl.umap(adata, color=[""bulk_labels"", ""phase""]). # Increase gap size between plots; sc.pl.umap(adata, color=[""bulk_labels"", ""phase""], wspace=1). Adapt axes appearance#; We can further modify the plot object (e.g. Axes) to change axis text, title size, font type (e.g. italic), font color, etc. For further details on customizing Axes and Figure objects see matplotlib documentation.; Some scanpy plotting functions already have predefined parameters for adjusting plot appearance. For example, embedding enables setting of titles with the title parameter and transparent plotting with the frameon parameter. # Set title with the title parameter; # Return Axes to further modify the plot; ax = sc.pl.umap(adata, color=""bulk_labels"", title=""Cell type"", show=False); # Modify xlabel; _ = ax.set_xlabel(""umap1"", fontsize=20). # Make title italic; ax = sc.pl.umap(adata, color=""IGJ"", show=False); _ = ax.set_title(""IGJ"", style=""italic""). # Transparent background and no borders/axis labels with frameon=False; sc.pl.umap(adata, color=""bulk_labels"", frameon=False). We can also change appearance (e.g color) of individual axis labels. This may be of special interest for plots like d",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/advanced.html:19427,Adapt,Adapt,19427,en/stable/tutorials/plotting/advanced.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/advanced.html,1,['Adapt'],['Adapt']
Modifiability,"e; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.pp.recipe_zheng17. Contents . recipe_zheng17(). scanpy.pp.recipe_zheng17#. scanpy.pp.recipe_zheng17(adata, *, n_top_genes=1000, log=True, plot=False, copy=False)[source]#; Normalization and filtering as of Zheng et al. [2017].; Reproduces the preprocessing of Zheng et al. [2017] – the Cell Ranger R Kit of 10x; Genomics.; Expects non-logarithmized data.; If using logarithmized data, pass log=False.; The recipe runs the following steps; sc.pp.filter_genes(adata, min_counts=1) # only consider genes with more than 1 count; sc.pp.normalize_per_cell( # normalize with total UMI count per cell; adata, key_n_counts='n_counts_all'; ); filter_result = sc.pp.filter_genes_dispersion( # select highly-variable genes; adata.X, flavor='cell_ranger', n_top_genes=n_top_genes, log=False; ); adata = adata[:, filter_result.gene_subset] # subset the genes; sc.pp.normalize_per_cell(adata) # renormalize after filtering; if log: sc.pp.log1p(adata) # log transform: adata.X = log(adata.X + 1); sc.pp.scale(adata) # scale to unit variance and shift to zero mean. Parameters:. adata AnnDataAnnotated data matrix. n_top_genes int (default: 1000)Number of genes to keep. log bool (default: True)Take logarithm. plot bool (default: False)Show a plot of the gene dispersion vs. mean relation. copy bool (default: False)Return a copy of adata instead of updating it. Return type:; AnnData | None. Returns:; Returns or updates adata depending on copy. previous; scanpy.pp.downsample_counts. next; scanpy.pp.recipe_weinreb17. Contents; . recipe_zheng17(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pp.recipe_zheng17.html:9936,variab,variable,9936,en/stable/api/generated/scanpy.pp.recipe_zheng17.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pp.recipe_zheng17.html,1,['variab'],['variable']
Modifiability,"efine is largely arbitrary, and so is the resolution parameter that we use to control for it. As such, the number of clusters is ultimately bound to the stable and biologically-meaningful groups that we can ultimately distringuish, typically done by experts in the corresponding field or by using expert-curated prior knowledge in the form of markers. sc.pl.umap(; adata,; color=[""leiden_res_0.02"", ""leiden_res_0.50"", ""leiden_res_2.00""],; legend_loc=""on data"",; ). sc.pl.umap(; adata,; color=[""leiden_res_0.02"", ""leiden_res_0.50"", ""leiden_res_2.00""],; legend_loc=""on data"",; ). Though UMAPs should not be over-interpreted, here we can already see that in the highest resolution our data is over-clustered, while the lowest resolution is likely grouping cells which belong to distinct cell identities. Marker gene set#; Let’s define a set of marker genes for the main cell types that we expect to see in this dataset. These were adapted from Single Cell Best Practices annotation chapter, for a more detailed overview and best practices in cell type annotation, we refer the user to it. marker_genes = {; ""CD14+ Mono"": [""FCN1"", ""CD14""],; ""CD16+ Mono"": [""TCF7L2"", ""FCGR3A"", ""LYN""],; # Note: DMXL2 should be negative; ""cDC2"": [""CST3"", ""COTL1"", ""LYZ"", ""DMXL2"", ""CLEC10A"", ""FCER1A""],; ""Erythroblast"": [""MKI67"", ""HBA1"", ""HBB""],; # Note HBM and GYPA are negative markers; ""Proerythroblast"": [""CDK6"", ""SYNGR1"", ""HBM"", ""GYPA""],; ""NK"": [""GNLY"", ""NKG7"", ""CD247"", ""FCER1G"", ""TYROBP"", ""KLRG1"", ""FCGR3A""],; ""ILC"": [""ID2"", ""PLCG2"", ""GNLY"", ""SYNE1""],; ""Naive CD20+ B"": [""MS4A1"", ""IL4R"", ""IGHD"", ""FCRL1"", ""IGHM""],; # Note IGHD and IGHM are negative markers; ""B cells"": [; ""MS4A1"",; ""ITGB1"",; ""COL4A4"",; ""PRDM1"",; ""IRF4"",; ""PAX5"",; ""BCL11A"",; ""BLK"",; ""IGHD"",; ""IGHM"",; ],; ""Plasma cells"": [""MZB1"", ""HSP90B1"", ""FNDC3B"", ""PRDM1"", ""IGKC"", ""JCHAIN""],; # Note PAX5 is a negative marker; ""Plasmablast"": [""XBP1"", ""PRDM1"", ""PAX5""],; ""CD4+ T"": [""CD4"", ""IL7R"", ""TRBC2""],; ""CD8+ T"": [""CD8A"", ""CD8B"", ""GZMK"", ""GZMA"", ""CCL5"", ""GZMB""",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering.html:20894,adapt,adapted,20894,en/stable/tutorials/basics/clustering.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering.html,2,['adapt'],['adapted']
Modifiability,"egend_fontsize Union[int, float, Literal['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'], None] (default: None)Numeric size in pt or string describing the size.; See set_fontsize(). legend_fontweight Union[int, Literal['light', 'normal', 'medium', 'semibold', 'bold', 'heavy', 'black']] (default: 'bold')Legend font weight. A numeric value in range 0-1000 or a string.; Defaults to 'bold' if legend_loc == 'on data', otherwise to 'normal'.; See set_fontweight(). legend_fontoutline int | None (default: None)Line width of the legend font outline in pt. Draws a white outline using; the path effect withStroke. colorbar_loc str | None (default: 'right')Where to place the colorbar for continous variables. If None, no colorbar; is added. size float (default: 1.0)Point size. If None, is automatically computed as 120000 / n_cells.; Can be a sequence containing the size for each cell. The order should be; the same as in adata.obs. color_map Colormap | str | None (default: None)Color map to use for continous variables. Can be a name or a; Colormap instance (e.g. ""magma”, ""viridis""; or mpl.cm.cividis), see get_cmap().; If None, the value of mpl.rcParams[""image.cmap""] is used.; The default color_map can be set using set_figure_params(). palette str | Sequence[str] | Cycler | None (default: None)Colors to use for plotting categorical annotation groups.; The palette can be a valid ListedColormap name; ('Set2', 'tab20', …), a Cycler object, a dict mapping; categories to colors, or a sequence of colors. Colors must be valid to; matplotlib. (see is_color_like()).; If None, mpl.rcParams[""axes.prop_cycle""] is used unless the categorical; variable already has colors stored in adata.uns[""{var}_colors""].; If provided, values of adata.uns[""{var}_colors""] will be set. na_color Union[str, tuple[float, ...], None] (default: None)Color to use for null or masked values. Can be anything matplotlib accepts as a; color. Used for all points if color=None. na_in_legend bool (def",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pl.spatial.html:15495,variab,variables,15495,en/stable/api/generated/scanpy.pl.spatial.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pl.spatial.html,1,['variab'],['variables']
Modifiability,"embedding(adata, basis, *, color=None, mask_obs=None, gene_symbols=None, use_raw=None, sort_order=True, edges=False, edges_width=0.1, edges_color='grey', neighbors_key=None, arrows=False, arrows_kwds=None, groups=None, components=None, dimensions=None, layer=None, projection='2d', scale_factor=None, color_map=None, cmap=None, palette=None, na_color='lightgray', na_in_legend=True, size=None, frameon=None, legend_fontsize=None, legend_fontweight='bold', legend_loc='right margin', legend_fontoutline=None, colorbar_loc='right', vmax=None, vmin=None, vcenter=None, norm=None, add_outline=False, outline_width=(0.3, 0.05), outline_color=('black', 'white'), ncols=4, hspace=0.25, wspace=None, title=None, show=None, save=None, ax=None, return_fig=None, marker='.', **kwargs)[source]#; Scatter plot for user specified embedding basis (e.g. umap, pca, etc). Parameters:. basis strName of the obsm basis to use. adata AnnDataAnnotated data matrix. color str | Sequence[str] | None (default: None)Keys for annotations of observations/cells or variables/genes, e.g.,; 'ann1' or ['ann1', 'ann2']. gene_symbols str | None (default: None)Column name in .var DataFrame that stores gene symbols. By default var_names; refer to the index column of the .var DataFrame. Setting this option allows; alternative names to be used. use_raw bool | None (default: None)Use .raw attribute of adata for coloring with gene expression. If None,; defaults to True if layer isn’t provided and adata.raw is present. layer str | None (default: None)Name of the AnnData object layer that wants to be plotted. By default; adata.raw.X is plotted. If use_raw=False is set, then adata.X is plotted.; If layer is set to a valid layer name, then the layer is plotted. layer; takes precedence over use_raw. edges bool (default: False)Show edges. edges_width float (default: 0.1)Width of edges. edges_color str | Sequence[float] | Sequence[str] (default: 'grey')Color of edges. See draw_networkx_edges(). neighbors_key str | None (defaul",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pl.embedding.html:10343,variab,variables,10343,en/stable/api/generated/scanpy.pl.embedding.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pl.embedding.html,1,['variab'],['variables']
Modifiability,"er annotated cell types from the scRNA-seq dataset.; We convert the class_prob_[anterior-posterior] object to a dataframe and assign it to the respective anndata. cp_anterior_df = pd.DataFrame(; class_prob_anterior,; columns=sorted(adata_cortex.obs[""cell_subclass""].cat.categories),; ); cp_posterior_df = pd.DataFrame(; class_prob_posterior,; columns=sorted(adata_cortex.obs[""cell_subclass""].cat.categories),; ). cp_anterior_df.index = adata_anterior_subset.obs.index; cp_posterior_df.index = adata_posterior_subset.obs.index. adata_anterior_subset_transfer = adata_anterior_subset.copy(); adata_anterior_subset_transfer.obs = pd.concat(; [adata_anterior_subset.obs, cp_anterior_df], axis=1; ). adata_posterior_subset_transfer = adata_posterior_subset.copy(); adata_posterior_subset_transfer.obs = pd.concat(; [adata_posterior_subset.obs, cp_posterior_df], axis=1; ). We are then able to explore how cell types are propagated from the scRNA-seq dataset to the visium dataset. Let’s first visualize the neurons cortical layers. sc.pl.spatial(; adata_anterior_subset_transfer,; img_key=""hires"",; color=[""L2/3 IT"", ""L4"", ""L5 PT"", ""L6 CT""],; size=1.5,; ); sc.pl.spatial(; adata_posterior_subset_transfer,; img_key=""hires"",; color=[""L2/3 IT"", ""L4"", ""L5 PT"", ""L6 CT""],; size=1.5,; ). Interestingly, it seems that this approach worked, since sequential layers of cortical neurons could be correctly identified, both in the anterior and posterior sagittal slide.; We can go ahead an visualize astrocytes and oligodendrocytes as well. sc.pl.spatial(; adata_anterior_subset_transfer, img_key=""hires"", color=[""Oligo"", ""Astro""], size=1.5; ); sc.pl.spatial(; adata_posterior_subset_transfer, img_key=""hires"", color=[""Oligo"", ""Astro""], size=1.5; ). In this tutorial, we showed how to work with multiple slices in Scanpy, and perform label transfers between an annotated scRNA-seq dataset and an unannotated Visium dataset. We showed that such approach, that leverages the data integration performances of Scanorama,",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html:26262,layers,layers,26262,en/stable/tutorials/spatial/integration-scanorama.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html,2,['layers'],['layers']
Modifiability,"er category, turning the gene labels off and swapping the axes. Notice that when the image is swapped, a color code for the categories appear instead of the ‘brackets’. sc.pl.rank_genes_groups_heatmap(; pbmc,; n_genes=10,; use_raw=False,; swap_axes=True,; show_gene_labels=False,; vmin=-3,; vmax=3,; cmap=""bwr"",; ). Visualize marker genes using tracksplot#. sc.pl.rank_genes_groups_tracksplot(pbmc, n_genes=3). Comparison of marker genes using split violin plots#; In scanpy, is very easy to compare marker genes using split violin plots for all groups at once. with rc_context({""figure.figsize"": (9, 1.5)}):; sc.pl.rank_genes_groups_violin(pbmc, n_genes=20, jitter=False). Dendrogram options#; Most of the visualizations can arrange the categories using a dendrogram. However, the dendrogram can also be plotted independently as follows:. # compute hierarchical clustering using PCs (several distance metrics and linkage methods are available).; sc.tl.dendrogram(pbmc, ""bulk_labels""). ax = sc.pl.dendrogram(pbmc, ""bulk_labels""). Plot correlation#; Together with the dendrogram it is possible to plot the correlation (by default ‘pearson’) of the categories. ax = sc.pl.correlation_matrix(pbmc, ""bulk_labels"", figsize=(5, 3.5)). previous; Plotting. next; Customizing Scanpy plots. Contents; . Scatter plots for embeddings; Load pbmc dataset; Visualization of gene expression and other variables. Identification of clusters based on known marker genes; dotplot; violin plot; stacked-violin plot; matrixplot. Combining plots in subplots; Heatmaps; Tracksplot; Visualization of marker genes; Visualize marker genes using dotplot; Focusing on particular groups. Visualize marker genes using matrixplot; Visualize marker genes using stacked violin plots; Visualize marker genes using heatmap; Visualize marker genes using tracksplot. Comparison of marker genes using split violin plots; Dendrogram options; Plot correlation. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/core.html:24155,variab,variables,24155,en/stable/tutorials/plotting/core.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/core.html,2,['variab'],['variables']
Modifiability,"er the group and results in a new layer; in the output AnnData object.; If none of layer, obsm, or varm are passed in, X will be used for aggregation data. Parameters:. adata AnnDataAnnData to be aggregated. by str | Collection[str]Key of the column to be grouped-by. func Union[Literal['count_nonzero', 'mean', 'sum', 'var'], Iterable[Literal['count_nonzero', 'mean', 'sum', 'var']]]How to aggregate. axis Optional[Literal['obs', 0, 'var', 1]] (default: None)Axis on which to find group by column. mask ndarray[Any, dtype[bool]] | str | None (default: None)Boolean mask (or key to column containing mask) to apply along the axis. dof int (default: 1)Degrees of freedom for variance. Defaults to 1. layer str | None (default: None)If not None, key for aggregation data. obsm str | None (default: None)If not None, key for aggregation data. varm str | None (default: None)If not None, key for aggregation data. Return type:; AnnData. Returns:; Aggregated AnnData. Examples; Calculating mean expression and number of nonzero entries per cluster:; >>> import scanpy as sc, pandas as pd; >>> pbmc = sc.datasets.pbmc3k_processed().raw.to_adata(); >>> pbmc.shape; (2638, 13714); >>> aggregated = sc.get.aggregate(pbmc, by=""louvain"", func=[""mean"", ""count_nonzero""]); >>> aggregated; AnnData object with n_obs × n_vars = 8 × 13714; obs: 'louvain'; var: 'n_cells'; layers: 'mean', 'count_nonzero'. We can group over multiple columns:; >>> pbmc.obs[""percent_mito_binned""] = pd.cut(pbmc.obs[""percent_mito""], bins=5); >>> sc.get.aggregate(pbmc, by=[""louvain"", ""percent_mito_binned""], func=[""mean"", ""count_nonzero""]); AnnData object with n_obs × n_vars = 40 × 13714; obs: 'louvain', 'percent_mito_binned'; var: 'n_cells'; layers: 'mean', 'count_nonzero'. Note that this filters out any combination of groups that wasn’t present in the original data. previous; scanpy.get.rank_genes_groups_df. next; Queries. Contents; . aggregate(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.get.aggregate.html:11014,layers,layers,11014,en/stable/generated/scanpy.get.aggregate.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.get.aggregate.html,2,['layers'],['layers']
Modifiability,"erate very large residuals for these few cells. In turn, these cells might dominate in downstream processing. To avoid such unbalanced behavior, Hafemeister & Satija (2019) introduced a heuristic that clips all residuals to +-sqrt(n_cells). This is the default behavior of all functions for Pearson residuals discussed here. If desired, a different threshold can be set using the clip argument. If no clipping is desired, use clip=np.Inf. chunksize and best practice to obtain Pearson residuals for large datasets#; Raw scRNA UMI counts are usually sparse, and can thus be stored efficiently for large datasets. However, when the count matrix is transformed to Pearson residuals, the data becomes dense. To avoid memory problems, we recommend that you reduce the size of your count matrix by gene selection, before running normalize_pearson_residuals(adata) on the reduced data. To perform RAM-efficient gene selection, use highly_variable_genes(adata,flavor='pearson_residuals') with the chunksize argument: This will still use Pearson residual variance to identify variable genes, but won’t compute all residuals at once. Reduce the chunksize as needed if you run into RAM issues during gene selection. Note that a very small chunksize will slow down the computation, so try to set it as large as possible with your resources.; As an example, we used chunksize=1000 when processing a dataset with 2 million cells in a machine with 500 GB RAM. For smaller machines, we would recommend to reduce this below 100. Wrapper functions for Pearson residuals preprocessing#; The scanpy.experimental.pp module also ships two wrappers that run multiple pre-processing steps at once:. sc.experimental.pp.normalize_pearson_residuals_pca() performs normalization by Pearson residuals and PCA in one go. This function is helpful to quickly obtain a Pearson residual-based data representation when highly variable genes are already defined, as only those are used by default.; sc.experimental.pp.recipe_pearson_resi",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:29352,variab,variable,29352,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,2,['variab'],['variable']
Modifiability,"ernal.pp.hashsolo; scanpy.external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .md. .pdf. Preprocessing: pp. Contents . Basic Preprocessing; Recipes; Batch effect correction; Doublet detection; Neighbors. Preprocessing: pp#; Filtering of highly-variable genes, batch-effect correction, per-cell normalization, preprocessing recipes.; Any transformation of the data matrix that is not a tool. Other than tools, preprocessing steps usually don’t return an easily interpretable annotation, but perform a basic transformation on the data matrix. Basic Preprocessing#; For visual quality control, see highest_expr_genes() and; filter_genes_dispersion() in scanpy.pl. pp.calculate_qc_metrics; Calculate quality control metrics. pp.filter_cells; Filter cell outliers based on counts and numbers of genes expressed. pp.filter_genes; Filter genes based on number of cells or counts. pp.highly_variable_genes; Annotate highly variable genes [Satija et al., 2015, Stuart et al., 2019, Zheng et al., 2017]. pp.log1p; Logarithmize the data matrix. pp.pca; Principal component analysis [Pedregosa et al., 2011]. pp.normalize_total; Normalize counts per cell. pp.regress_out; Regress out (mostly) unwanted sources of variation. pp.scale; Scale data to unit variance and zero mean. pp",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/preprocessing.html:9380,variab,variable,9380,en/stable/api/preprocessing.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/preprocessing.html,1,['variab'],['variable']
Modifiability,"ernal.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.pl.violin. Contents . violin(). scanpy.pl.violin#. scanpy.pl.violin(adata, keys, groupby=None, *, log=False, use_raw=None, stripplot=True, jitter=True, size=1, layer=None, scale='width', order=None, multi_panel=None, xlabel='', ylabel=None, rotation=None, show=None, save=None, ax=None, **kwds)[source]#; Violin plot.; Wraps seaborn.violinplot() for AnnData. Parameters:. adata AnnDataAnnotated data matrix. keys str | Sequence[str]Keys for accessing variables of .var_names or fields of .obs. groupby str | None (default: None)The key of the observation grouping to consider. log bool (default: False)Plot on logarithmic axis. use_raw bool | None (default: None)Whether to use raw attribute of adata. Defaults to True if .raw is present. stripplot bool (default: True)Add a stripplot on top of the violin plot.; See stripplot(). jitter float | bool (default: True)Add jitter to the stripplot (only when stripplot is True); See stripplot(). size int (default: 1)Size of the jitter points. layer str | None (default: None)Name of the AnnData object layer that wants to be plotted. By; default adata.raw.X is plotted. If use_raw=False is set,; then adata.X is plotted. If layer is set to a valid layer name,; then the layer is plotted. layer takes precedence over use_raw. scale Literal['area', 'count', 'width'] (default: 'width')The method used to scale the width of each violin.; If ‘width’ (the default), each violin will have the sam",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pl.violin.html:9683,variab,variables,9683,en/stable/generated/scanpy.pl.violin.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pl.violin.html,1,['variab'],['variables']
Modifiability,"et to True, this will add a thin border around groups of dots. In some situations; this can enhance the aesthetics of the resulting image. outline_color tuple[str, str] (default: ('black', 'white'))Tuple with two valid color names used to adjust the add_outline. The first color is the; border color (default: black), while the second color is a gap color between the; border color and the scatter dot (default: white). outline_width tuple[float, float] (default: (0.3, 0.05))Tuple with two width numbers used to adjust the outline. The first value is the width; of the border color as a fraction of the scatter dot size (default: 0.3). The second value is; width of the gap color (default: 0.05). ncols int (default: 4)Number of panels per row. wspace float | None (default: None)Adjust the width of the space between multiple panels. hspace float (default: 0.25)Adjust the height of the space between multiple panels. return_fig bool | None (default: None)Return the matplotlib figure. kwargsArguments to pass to matplotlib.pyplot.scatter(),; for instance: the maximum and minimum values (e.g. vmin=-2, vmax=5). show bool | None (default: None)Show the plot, do not return axis. save bool | str | None (default: None)If True or a str, save the figure.; A string is appended to the default filename.; Infer the filetype if ending on {'.pdf', '.png', '.svg'}. ax Axes | None (default: None)A matplotlib axes object. Only works if plotting a single component. Return type:; Figure | Axes | list[Axes] | None. Returns:; If show==False a Axes or a list of it. Examples; import scanpy as sc; adata = sc.datasets.pbmc3k_processed(); sc.pl.pca(adata). Colour points by discrete variable (Louvain clusters).; sc.pl.pca(adata, color=""louvain""). Colour points by gene expression.; sc.pl.pca(adata, color=""CST3""). See also; pp.pca. previous; scanpy.pl.scrublet_score_distribution. next; scanpy.pl.pca_loadings. Contents; . pca(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pl.pca.html:18030,variab,variable,18030,en/stable/api/generated/scanpy.pl.pca.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pl.pca.html,1,['variab'],['variable']
Modifiability,"external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.experimental.pp.highly_variable_genes. Contents . highly_variable_genes(). scanpy.experimental.pp.highly_variable_genes#. scanpy.experimental.pp.highly_variable_genes(adata, *, theta=100, clip=None, n_top_genes=None, batch_key=None, chunksize=1000, flavor='pearson_residuals', check_values=True, layer=None, subset=False, inplace=True)[source]#; Select highly variable genes using analytic Pearson residuals [Lause et al., 2021].; In Lause et al. [2021], Pearson residuals of a negative binomial offset model are computed; (with overdispersion theta shared across genes). By default, overdispersion; theta=100 is used and residuals are clipped to sqrt(n_obs). Finally, genes; are ranked by residual variance.; Expects raw count input. Parameters:. adata AnnDataThe annotated data matrix of shape n_obs × n_vars.; Rows correspond to cells and columns to genes. theta float (default: 100)The negative binomial overdispersion parameter theta for Pearson residuals.; Higher values correspond to less overdispersion (var = mean + mean^2/theta), and theta=np.inf corresponds to a Poisson model. clip float | None (default: None)Determines if and how residuals are clipped:. If None, residuals are clipped to the interval [-sqrt(n_obs), sqrt(n_obs)], where n_obs is the number of cells in t",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.highly_variable_genes.html:9620,variab,variable,9620,en/stable/generated/scanpy.experimental.pp.highly_variable_genes.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.highly_variable_genes.html,1,['variab'],['variable']
Modifiability,"external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.read_10x_mtx. Contents . read_10x_mtx(). scanpy.read_10x_mtx#. scanpy.read_10x_mtx(path, *, var_names='gene_symbols', make_unique=True, cache=False, cache_compression=_empty, gex_only=True, prefix=None)[source]#; Read 10x-Genomics-formatted mtx directory. Parameters:. path Path | strPath to directory for .mtx and .tsv files,; e.g. ‘./filtered_gene_bc_matrices/hg19/’. var_names Literal['gene_symbols', 'gene_ids'] (default: 'gene_symbols')The variables index. make_unique bool (default: True)Whether to make the variables index unique by appending ‘-1’,; ‘-2’ etc. or not. cache bool (default: False)If False, read from source, if True, read from fast ‘h5ad’ cache. cache_compression Union[Literal['gzip', 'lzf'], None, Empty] (default: _empty)See the h5py Filter pipeline.; (Default: settings.cache_compression). gex_only bool (default: True)Only keep ‘Gene Expression’ data and ignore other feature types,; e.g. ‘Antibody Capture’, ‘CRISPR Guide Capture’, or ‘Custom’. prefix str | None (default: None)Any prefix before matrix.mtx, genes.tsv and barcodes.tsv. For instance,; if the files are named patientA_matrix.mtx, patientA_genes.tsv and; patientA_barcodes.tsv the prefix is patientA_.; (Default: no prefix). Return type:; AnnData. Returns:; An AnnData object. previous; scanpy.read_10x_h5. next; scanpy.read_visium. Contents; . read_10x_mtx(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.read_10x_mtx.html:9749,variab,variables,9749,en/stable/generated/scanpy.read_10x_mtx.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.read_10x_mtx.html,1,['variab'],['variables']
Modifiability,"finished (0:00:00): normalized adata.X and added 'n_counts', counts per cell before normalization (adata.obs); computing PCA; with n_comps=15; finished (0:00:08); computing neighbors; using 'X_pca' with n_pcs = 15; finished: added to `.uns['neighbors']`; `.obsp['distances']`, distances for each pair of neighbors; `.obsp['connectivities']`, weighted adjacency matrix (0:00:00); computing UMAP; finished: added; 'X_umap', UMAP coordinates (adata.obsm) (0:00:01); running Leiden clustering; finished: found 6 clusters and added; 'clusters', the cluster labels (adata.obs, categorical) (0:00:00). The experiment consisted in measuring gene expression counts from a single cell type (cultured U2-OS cells). Clusters consist of cell states at different stages of the cell cycle. We don’t expect to see specific structure in spatial dimensions given the experimental setup.; We can visualize the clusters obtained from running Leiden in UMAP space and spatial coordinates like this. adata_merfish. AnnData object with n_obs × n_vars = 645 × 12903; obs: 'n_counts', 'clusters'; uns: 'log1p', 'pca', 'neighbors', 'umap', 'leiden'; obsm: 'spatial', 'X_pca', 'X_umap'; varm: 'PCs'; obsp: 'distances', 'connectivities'. sc.pl.umap(adata_merfish, color=""clusters""); sc.pl.embedding(adata_merfish, basis=""spatial"", color=""clusters""). We hope you found the tutorial useful!; Report back to us which features/external tools you would like to see in Scanpy.; We are extending Scanpy and AnnData to support other spatial data types, such as Imaging Mass Cytometry and extend data structure to support spatial graphs and additional features. Stay tuned!. previous; Spatial. next; Integrating spatial data with scRNA-seq using scanorama. Contents; . Reading the data; QC and preprocessing; Manifold embedding and clustering based on transcriptional similarity; Visualization in spatial coordinates; Cluster marker genes; MERFISH example. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/basic-analysis.html:22226,extend,extending,22226,en/stable/tutorials/spatial/basic-analysis.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/basic-analysis.html,4,['extend'],"['extend', 'extending']"
Modifiability,"float, Literal['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'], None] (default: None)Numeric size in pt or string describing the size.; See set_fontsize(). legend_fontweight Union[int, Literal['light', 'normal', 'medium', 'semibold', 'bold', 'heavy', 'black']] (default: 'bold')Legend font weight. A numeric value in range 0-1000 or a string.; Defaults to 'bold' if legend_loc == 'on data', otherwise to 'normal'.; See set_fontweight(). legend_fontoutline int | None (default: None)Line width of the legend font outline in pt. Draws a white outline using; the path effect withStroke. colorbar_loc str | None (default: 'right')Where to place the colorbar for continous variables. If None, no colorbar; is added. size float | Sequence[float] | None (default: None)Point size. If None, is automatically computed as 120000 / n_cells.; Can be a sequence containing the size for each cell. The order should be; the same as in adata.obs. color_map Colormap | str | None (default: None)Color map to use for continous variables. Can be a name or a; Colormap instance (e.g. ""magma”, ""viridis""; or mpl.cm.cividis), see get_cmap().; If None, the value of mpl.rcParams[""image.cmap""] is used.; The default color_map can be set using set_figure_params(). palette str | Sequence[str] | Cycler | None (default: None)Colors to use for plotting categorical annotation groups.; The palette can be a valid ListedColormap name; ('Set2', 'tab20', …), a Cycler object, a dict mapping; categories to colors, or a sequence of colors. Colors must be valid to; matplotlib. (see is_color_like()).; If None, mpl.rcParams[""axes.prop_cycle""] is used unless the categorical; variable already has colors stored in adata.uns[""{var}_colors""].; If provided, values of adata.uns[""{var}_colors""] will be set. na_color Union[str, tuple[float, ...]] (default: 'lightgray')Color to use for null or masked values. Can be anything matplotlib accepts as a; color. Used for all points if color=None. na_in_legend bool (de",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pl.phate.html:13945,variab,variables,13945,en/stable/generated/scanpy.external.pl.phate.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pl.phate.html,8,['variab'],['variables']
Modifiability,"for Pearson residuals.; Higher values correspond to less overdispersion (var = mean + mean^2/theta), and theta=np.inf corresponds to a Poisson model. clip float | None (default: None)Determines if and how residuals are clipped:. If None, residuals are clipped to the interval [-sqrt(n_obs), sqrt(n_obs)], where n_obs is the number of cells in the dataset (default behavior).; If any scalar c, residuals are clipped to the interval [-c, c]. Set clip=np.inf for no clipping. check_values bool (default: True)If True, checks if counts in selected layer are integers as expected by this; function, and return a warning if non-integers are found. Otherwise, proceed; without checking. Setting this to False can speed up code for large datasets. layer str | None (default: None)Layer to use as input instead of X. If None, X is used. inplace bool (default: True)If True, update adata with results. Otherwise, return results. See below for; details of what is returned. copy bool (default: False)If True, the function runs on a copy of the input object and returns the; modified copy. Otherwise, the input object is modified direcly. Not compatible; with inplace=False. Return type:; AnnData | dict[str, ndarray] | None. Returns:; If inplace=True, adata.X or the selected layer in adata.layers is updated; with the normalized values. adata.uns is updated with the following fields.; If inplace=False, the same fields are returned as dictionary with the; normalized values in results_dict['X']. .uns['pearson_residuals_normalization']['theta']The used value of the overdisperion parameter theta. .uns['pearson_residuals_normalization']['clip']The used value of the clipping parameter. .uns['pearson_residuals_normalization']['computed_on']The name of the layer on which the residuals were computed. previous; Experimental. next; scanpy.experimental.pp.normalize_pearson_residuals_pca. Contents; . normalize_pearson_residuals(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.normalize_pearson_residuals.html:11342,layers,layers,11342,en/stable/generated/scanpy.experimental.pp.normalize_pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.normalize_pearson_residuals.html,1,['layers'],['layers']
Modifiability,"from Benson et. al. (2013). Changed in version 1.9.3: Default value changed from 'arpack' to None. Changed in version 1.4.5: Default value changed from 'auto' to 'arpack'. Efficient computation of the principal components of a sparse matrix; currently only works with the 'arpack’ or 'lobpcg' solvers.; If X is a dask array, dask-ml classes PCA,; IncrementalPCA, or; TruncatedSVD will be used.; Otherwise their scikit-learn counterparts PCA,; IncrementalPCA, or; TruncatedSVD will be used. random_state Union[int, RandomState, None] (default: 0)Change to use different initial states for the optimization. return_info bool (default: False)Only relevant when not passing an AnnData:; see “Returns”. mask_var ndarray[Any, dtype[bool]] | str | None | Empty (default: _empty)To run only on a certain set of genes given by a boolean array; or a string referring to an array in var.; By default, uses .var['highly_variable'] if available, else everything. use_highly_variable bool | None (default: None)Whether to use highly variable genes only, stored in; .var['highly_variable'].; By default uses them if they have been determined beforehand. Deprecated since version 1.10.0: Use mask_var instead. layerLayer of adata to use as expression values. dtype Union[dtype[Any], None, type[Any], _SupportsDType[dtype[Any]], str, tuple[Any, int], tuple[Any, Union[SupportsIndex, Sequence[SupportsIndex]]], list[Any], _DTypeDict, tuple[Any, Any]] (default: 'float32')Numpy data type string to which to convert the result. chunked bool (default: False)If True, perform an incremental PCA on segments of chunk_size.; The incremental PCA automatically zero centers and ignores settings of; random_seed and svd_solver. Uses sklearn IncrementalPCA or; dask-ml IncrementalPCA. If False, perform a full PCA and; use sklearn PCA or; dask-ml PCA. chunk_size int | None (default: None)Number of observations to include in each chunk.; Required if chunked=True was passed. copy bool (default: False)If an AnnData is passed, de",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.pca.html:12571,variab,variable,12571,en/stable/generated/scanpy.pp.pca.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.pca.html,1,['variab'],['variable']
Modifiability,"from adata are skipped.; By default (or when specifying 'all' or None), these keys are tried:; [""tsne"", ""umap"", ""pagaFa"", ""pagaFr"", ""pagaUmap"", ""phate"",; ""fa"", ""fr"", ""kk"", ""drl"", ""rt"", ""trimap""].; For these, default display labels are automatically used.; For other values, you can specify a mapping from coordinate name to; display label, e.g. {""tsne"": ""t-SNE by Scanpy""}. annot_keys Iterable[str] | Mapping[str, str] | None (default: ('louvain', 'percent_mito', 'n_genes', 'n_counts'))Annotations in adata.obsm to export.; Can be a mapping from annotation column name to display label.; Specify None for all available columns in .obs. skip_matrix bool (default: False)Do not export the matrix.; If you had previously exported this adata into the same data_dir,; then there is no need to export the whole matrix again.; This option will make the export a lot faster,; e.g. when only coordinates or meta data were changed. html_dir Path | str | None (default: None)If this variable is set, the export will build html; files from data_dir to html_dir, creating html/js/json files.; Usually there is one global html output directory for all datasets.; Often, html_dir is located under a webserver’s (like Apache); htdocs directory or is copied to one.; A directory html_dir/project_name will be created and; an index.html will be created under html_dir for all subdirectories.; Existing files will be overwritten.; If do not to use html_dir,; you can use the command line tool cbBuild to build the html directory. port int | None (default: None)If this variable and html_dir are set,; Python’s built-in web server will be spawned as a daemon in the; background and serve the files under html_dir.; To kill the process, call cellbrowser.cellbrowser.stop(). do_debug bool (default: False)Activate debugging output. Examples; See this; tutorial. previous; scanpy.external.exporting.spring_project. next; Ecosystem. Contents; . cellbrowser(). By Scanpy development team. ; © Copyright 2024, the Scanpy devel",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.exporting.cellbrowser.html:11903,variab,variable,11903,en/stable/generated/scanpy.external.exporting.cellbrowser.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.exporting.cellbrowser.html,1,['variab'],['variable']
Modifiability,"g_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .md. .pdf. Tools: TL. Contents . Embeddings; Clustering and trajectory inference; Gene scores, Cell cycle. Tools: TL#. Embeddings#. tl.phate(adata[, n_components, k, a, ...]); PHATE [Moon et al., 2019]. tl.palantir(adata, *[, n_components, knn, ...]); Run Diffusion maps using the adaptive anisotropic kernel [Setty et al., 2019]. tl.trimap(adata[, n_components, n_inliers, ...]); TriMap: Large-scale Dimensionality Reduction Using Triplets [Amid and Warmuth, 2019]. tl.sam(adata, *[, max_iter, num_norm_avg, ...]); Self-Assembling Manifolds single-cell RNA sequencing analysis tool [Tarashansky et al., 2019]. Clustering and trajectory inference#. tl.phenograph(data[, clustering_algo, k, ...]); PhenoGraph clustering [Levine et al., 2015]. tl.harmony_timeseries(adata, tp, *[, ...]); Harmony time series for data visualization with augmented affinity matrix at discrete time points [Nowotschin et al., 2019]. tl.wishbone(adata, start_cell, *[, branch, ...]); Wishbone identifies bifurcating developmental trajectories from single-cell data [Setty et al., 2016]. tl.palantir(adata, *[, n_components, knn, ...]); Run Diffusion maps using the adaptive anisotropic kernel [Setty et al., 2019]. tl.palantir_results(adata, early_cell, *[, ...]); Running Palantir. Gene scores, Cell cycle#. tl.sandbag(adata[, annotation, fraction, ...]); Calculate marker pairs of genes [Fechtner, 2018, Scialdone et al., 2015]. tl.cyclone(adata[, marker_pairs, ...]); Assigns scores and predicted class to observations [Scialdone et al., 2015] [Fechtner, 2018]. previous; scanpy.external.pp.magic. next; scanpy.external.tl.phate. Contents; . Embeddings; Clustering and trajectory inference; Gene scores, Cell cycle. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/tools.html:10348,adapt,adaptive,10348,en/stable/external/tools.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/tools.html,1,['adapt'],['adaptive']
Modifiability,"genes_by_counts > 6000. print(; ""%u cells with high %% of mitochondrial genes""; % (sum(adata_pbmc10k.obs[""outlier_mt""])); ); print(""%u cells with large total counts"" % (sum(adata_pbmc10k.obs[""outlier_total""]))); print(; ""%u cells with large number of genes"" % (sum(adata_pbmc10k.obs[""outlier_ngenes""])); ). adata_pbmc10k = adata_pbmc10k[~adata_pbmc10k.obs[""outlier_mt""], :]; adata_pbmc10k = adata_pbmc10k[~adata_pbmc10k.obs[""outlier_total""], :]; adata_pbmc10k = adata_pbmc10k[~adata_pbmc10k.obs[""outlier_ngenes""], :]; sc.pp.filter_genes(adata_pbmc10k, min_cells=1). 494 cells with high % of mitochondrial genes; 75 cells with large total counts; 6 cells with large number of genes; filtered out 1 genes that are detected in less than 1 cells. Use Pearson residuals for selection of highly variable genes#; Analytic Pearson residuals can be used to identify biologically variable genes. For that, the observed counts are compared to the expected counts of a “null model”. This model includes no biological variability between cells. Pearson residuals are defined such that genes that are not differentially expressed will have variance close to 1. In contrast, if a gene is differentially expressed, it will deviate from the null model, causing larger residuals and residual variance >1 for this gene. More details and comparisons to other gene selection methods can be found in Lause et al. (2021).; The call to highly_variable_genes(flavor='pearson_residuals',n_top_genes=2000) computes the residual variances and selects 2000 genes based on this. As shown in the plots below, cell type marker genes known a priori are successfully selected. Compute 2000 variable genes with Pearson residuals#; This will create the field highly_variable, indicating the 2000 genes that have the most variable Pearson residuals. for adata in [adata_pbmc3k, adata_pbmc10k]:; sc.experimental.pp.highly_variable_genes(; adata, flavor=""pearson_residuals"", n_top_genes=2000; ). extracting highly variable genes; --> added;",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:17890,variab,variability,17890,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,2,['variab'],['variability']
Modifiability,"gical rather then technical variances. This is why it makes sense to use Pearson residuals as basis for downstream processing.; After reducing the dataset to the most variable genes in the previous steps, we will now transform our raw counts to residuals by calling normalize_pearson_residuals(adata). In our example pipeline, we then apply PCA to reduce the dataset to the most relevant dimensions. We visualize this reduced representation with t-SNE and perform Leiden clustering, which is again taken from the PBMC3k tutorial.; This is just one of many possible pipelines: After PCA, you could also use UMAP or other embeddings to inspect the data, and cluster the data with a different algorithm than Leiden. Preparations#; Because we will transform the raw data in adata.X to residuals in the next step, we first save a copy of the raw counts to adata.layers['raw']. Also, we save a depth-normalized and square-root transformed version of the data to adata.layers['sqrt_norm'], so we can use them for plotting normalized counts later. Further background on why to use the square-root transform here can be found in Wagner (2020). # keep raw and depth-normalized counts for later; adata_pbmc3k.layers[""raw""] = adata_pbmc3k.X.copy(); adata_pbmc3k.layers[""sqrt_norm""] = np.sqrt(; sc.pp.normalize_total(adata_pbmc3k, inplace=False)[""X""]; ). adata_pbmc10k.layers[""raw""] = adata_pbmc10k.X.copy(); adata_pbmc10k.layers[""sqrt_norm""] = np.sqrt(; sc.pp.normalize_total(adata_pbmc10k, inplace=False)[""X""]; ). normalizing counts per cell; finished (0:00:00); normalizing counts per cell; finished (0:00:00). Compute Pearson residuals#; This will transform the sparse raw counts in adata.X to a dense matrix of Pearson residuals. for adata in [adata_pbmc3k, adata_pbmc10k]:; sc.experimental.pp.normalize_pearson_residuals(adata). computing analytic Pearson residuals on adata.X; finished (0:00:00); computing analytic Pearson residuals on adata.X; finished (0:00:00). Compute PCA and t-SNE#; We now reduce the",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:24149,layers,layers,24149,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,2,['layers'],['layers']
Modifiability,"gical variability between cells. Pearson residuals are defined such that genes that are not differentially expressed will have variance close to 1. In contrast, if a gene is differentially expressed, it will deviate from the null model, causing larger residuals and residual variance >1 for this gene. More details and comparisons to other gene selection methods can be found in Lause et al. (2021).; The call to highly_variable_genes(flavor='pearson_residuals',n_top_genes=2000) computes the residual variances and selects 2000 genes based on this. As shown in the plots below, cell type marker genes known a priori are successfully selected. Compute 2000 variable genes with Pearson residuals#; This will create the field highly_variable, indicating the 2000 genes that have the most variable Pearson residuals. for adata in [adata_pbmc3k, adata_pbmc10k]:; sc.experimental.pp.highly_variable_genes(; adata, flavor=""pearson_residuals"", n_top_genes=2000; ). extracting highly variable genes; --> added; 'highly_variable', boolean vector (adata.var); 'highly_variable_rank', float vector (adata.var); 'highly_variable_nbatches', int vector (adata.var); 'highly_variable_intersection', boolean vector (adata.var); 'means', float vector (adata.var); 'variances', float vector (adata.var); 'residual_variances', float vector (adata.var); extracting highly variable genes; --> added; 'highly_variable', boolean vector (adata.var); 'highly_variable_rank', float vector (adata.var); 'highly_variable_nbatches', int vector (adata.var); 'highly_variable_intersection', boolean vector (adata.var); 'means', float vector (adata.var); 'variances', float vector (adata.var); 'residual_variances', float vector (adata.var). Plot gene selection#; To illustrate the selection procedure, we plot mean and residual variance of each gene, highlighting the selected genes (red). On top, we plot the known marker genes defined in the beginning (black). We can see that all of them are selected, as desired. fig, axes = plt",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:18860,variab,variable,18860,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,2,['variab'],['variable']
Modifiability,"grate; scanpy.external.pp.mnn_correct; scanpy.external.pp.scanorama_integrate; scanpy.external.pp.hashsolo; scanpy.external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .ipynb. .pdf. Core plotting functions. Contents . Scatter plots for embeddings; Load pbmc dataset; Visualization of gene expression and other variables. Identification of clusters based on known marker genes; dotplot; violin plot; stacked-violin plot; matrixplot. Combining plots in subplots; Heatmaps; Tracksplot; Visualization of marker genes; Visualize marker genes using dotplot; Focusing on particular groups. Visualize marker genes using matrixplot; Visualize marker genes using stacked violin plots; Visualize marker genes using heatmap; Visualize marker genes using tracksplot. Comparison of marker genes using split violin plots; Dendrogram options; Plot correlation. Core plotting functions#; Author: Fidel Ramírez; This tutorial explores the visualization possibilities of scanpy and is divided into three sections:. Scatter plots for embeddings (eg. UMAP, t-SNE); Identification of clusters using known marker genes; Visualization of differentially expressed genes. In this tutorial, we will use a dataset from 10x containing 68k cells from PBMC. Scanpy, includes in its distribution a red",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/core.html:9362,variab,variables,9362,en/stable/tutorials/plotting/core.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/core.html,2,['variab'],['variables']
Modifiability,"he most relevant dimensions. We visualize this reduced representation with t-SNE and perform Leiden clustering, which is again taken from the PBMC3k tutorial.; This is just one of many possible pipelines: After PCA, you could also use UMAP or other embeddings to inspect the data, and cluster the data with a different algorithm than Leiden. Preparations#; Because we will transform the raw data in adata.X to residuals in the next step, we first save a copy of the raw counts to adata.layers['raw']. Also, we save a depth-normalized and square-root transformed version of the data to adata.layers['sqrt_norm'], so we can use them for plotting normalized counts later. Further background on why to use the square-root transform here can be found in Wagner (2020). # keep raw and depth-normalized counts for later; adata_pbmc3k.layers[""raw""] = adata_pbmc3k.X.copy(); adata_pbmc3k.layers[""sqrt_norm""] = np.sqrt(; sc.pp.normalize_total(adata_pbmc3k, inplace=False)[""X""]; ). adata_pbmc10k.layers[""raw""] = adata_pbmc10k.X.copy(); adata_pbmc10k.layers[""sqrt_norm""] = np.sqrt(; sc.pp.normalize_total(adata_pbmc10k, inplace=False)[""X""]; ). normalizing counts per cell; finished (0:00:00); normalizing counts per cell; finished (0:00:00). Compute Pearson residuals#; This will transform the sparse raw counts in adata.X to a dense matrix of Pearson residuals. for adata in [adata_pbmc3k, adata_pbmc10k]:; sc.experimental.pp.normalize_pearson_residuals(adata). computing analytic Pearson residuals on adata.X; finished (0:00:00); computing analytic Pearson residuals on adata.X; finished (0:00:00). Compute PCA and t-SNE#; We now reduce the dimensionality of the data by running PCA on the Pearson residuals. On top, we run t-SNE for vizualisation. for adata in [adata_pbmc3k, adata_pbmc10k]:; sc.pp.pca(adata, n_comps=50); n_cells = len(adata); sc.tl.tsne(adata, use_rep=""X_pca""). computing PCA; with n_comps=50; finished (0:00:27); computing tSNE; using sklearn.manifold.TSNE; finished: added; 'X_tsne', tSNE",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:24543,layers,layers,24543,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,2,['layers'],['layers']
Modifiability,"he null model expects the technical sources of variance, they are removed from the data. In contrast, biological variance is preserved: The null model is designed not to predict biological differences between cells. As a result, it will deviate from the observed counts starkly whenever genes differ in their expression between subpopulations – and produce large residuals in return. This will even work for genes that mark only small subpopulations. An example of detecting a rare subpopulation consisting of just 50 cells with Pearson residuals is presented in Lause et al. (2021).; As a result, the transformed data will show less technical variability, and biological signals from variable genes will be amplified. Therefore, downstream processing like PCA will be dominated by biological rather then technical variances. This is why it makes sense to use Pearson residuals as basis for downstream processing.; After reducing the dataset to the most variable genes in the previous steps, we will now transform our raw counts to residuals by calling normalize_pearson_residuals(adata). In our example pipeline, we then apply PCA to reduce the dataset to the most relevant dimensions. We visualize this reduced representation with t-SNE and perform Leiden clustering, which is again taken from the PBMC3k tutorial.; This is just one of many possible pipelines: After PCA, you could also use UMAP or other embeddings to inspect the data, and cluster the data with a different algorithm than Leiden. Preparations#; Because we will transform the raw data in adata.X to residuals in the next step, we first save a copy of the raw counts to adata.layers['raw']. Also, we save a depth-normalized and square-root transformed version of the data to adata.layers['sqrt_norm'], so we can use them for plotting normalized counts later. Further background on why to use the square-root transform here can be found in Wagner (2020). # keep raw and depth-normalized counts for later; adata_pbmc3k.layers[""raw""] = ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:23354,variab,variable,23354,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,2,['variab'],['variable']
Modifiability,"hr = 0.5; _ = axs[1].axhline(thr, c=""r""); _ = axs[0].axvline(thr, c=""r""). # Compare PAGA with and without prunning; fig, axs = plt.subplots(1, 2, figsize=(6, 3)); sc.pl.paga(adata, ax=axs[0], title=""PAGA"", show=False); sc.pl.paga(adata, ax=axs[1], title=""PAGA - prunned"", threshold=thr). PAGA layout#; The layout used in PAGA is optimised to correspond to the PAGA connectivties (edge weighs). However, sometimes we would wish to have a different layout. For this we can use the pos argument. PAGA layout corresponding to UMAP#; Set PAGA dot centers to the mean of the UMAP embedding values of cells from the corresponding groups. # Compare UMAP and PAGA layouts; fig, axs = plt.subplots(1, 2, figsize=(6, 3)); sc.pl.umap(; adata, color=""louvain"", ax=axs[0], show=False, title=""UMAP"", legend_loc=""on data""; ); sc.pl.paga(adata, ax=axs[1], title=""PAGA""). # Define PAGA positions based on the UMAP layout -; # for each cluster we use the mean of the UMAP positions from the cells in that cluster; pos = pd.DataFrame(adata.obsm[""X_umap""], index=adata.obs_names); pos[""group""] = adata.obs[adata.uns[""paga""][""groups""]]; pos = pos.groupby(""group"", observed=True).mean(). # Plot UMAP in the background; ax = sc.pl.umap(adata, show=False); # Plot PAGA ontop of the UMAP; sc.pl.paga(; adata,; color=""louvain"",; threshold=thr,; node_size_scale=1,; edge_width_scale=0.7,; pos=pos.values,; random_state=0,; ax=ax,; ). previous; Core plotting functions. next; Trajectories. Contents; . Talking to matplotlib; Figure and Axes objects; Using matplotlib Axes to customize plot alignment; Plot size; Adjust space between subplots; Adapt axes appearance. Labels and legends; Customizing legends; Annotating scatter plots. Colors; Discrete palettes; Continous palettes; Colorblind friendly palettes. UMAP; Coloring cell subset; Cell ordering; Optimising UMAP layout. PAGA; Prune PAGA edges; PAGA layout; PAGA layout corresponding to UMAP. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/advanced.html:36251,Adapt,Adapt,36251,en/stable/tutorials/plotting/advanced.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/advanced.html,1,['Adapt'],['Adapt']
Modifiability,"ibutors; References. .rst. .pdf. scanpy.pl.tsne. Contents . tsne(). scanpy.pl.tsne#. scanpy.pl.tsne(adata, *, color=None, mask_obs=None, gene_symbols=None, use_raw=None, sort_order=True, edges=False, edges_width=0.1, edges_color='grey', neighbors_key=None, arrows=False, arrows_kwds=None, groups=None, components=None, dimensions=None, layer=None, projection='2d', scale_factor=None, color_map=None, cmap=None, palette=None, na_color='lightgray', na_in_legend=True, size=None, frameon=None, legend_fontsize=None, legend_fontweight='bold', legend_loc='right margin', legend_fontoutline=None, colorbar_loc='right', vmax=None, vmin=None, vcenter=None, norm=None, add_outline=False, outline_width=(0.3, 0.05), outline_color=('black', 'white'), ncols=4, hspace=0.25, wspace=None, title=None, show=None, save=None, ax=None, return_fig=None, marker='.', **kwargs)[source]#; Scatter plot in tSNE basis. Parameters:. adata AnnDataAnnotated data matrix. color str | Sequence[str] | None (default: None)Keys for annotations of observations/cells or variables/genes, e.g.,; 'ann1' or ['ann1', 'ann2']. gene_symbols str | None (default: None)Column name in .var DataFrame that stores gene symbols. By default var_names; refer to the index column of the .var DataFrame. Setting this option allows; alternative names to be used. use_raw bool | None (default: None)Use .raw attribute of adata for coloring with gene expression. If None,; defaults to True if layer isn’t provided and adata.raw is present. layer str | None (default: None)Name of the AnnData object layer that wants to be plotted. By default; adata.raw.X is plotted. If use_raw=False is set, then adata.X is plotted.; If layer is set to a valid layer name, then the layer is plotted. layer; takes precedence over use_raw. edges bool (default: False)Show edges. edges_width float (default: 0.1)Width of edges. edges_color str | Sequence[float] | Sequence[str] (default: 'grey')Color of edges. See draw_networkx_edges(). neighbors_key str | None (defaul",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pl.tsne.html:10228,variab,variables,10228,en/stable/api/generated/scanpy.pl.tsne.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pl.tsne.html,1,['variab'],['variables']
Modifiability,"ibutors; References. .rst. .pdf. scanpy.pl.umap. Contents . umap(). scanpy.pl.umap#. scanpy.pl.umap(adata, *, color=None, mask_obs=None, gene_symbols=None, use_raw=None, sort_order=True, edges=False, edges_width=0.1, edges_color='grey', neighbors_key=None, arrows=False, arrows_kwds=None, groups=None, components=None, dimensions=None, layer=None, projection='2d', scale_factor=None, color_map=None, cmap=None, palette=None, na_color='lightgray', na_in_legend=True, size=None, frameon=None, legend_fontsize=None, legend_fontweight='bold', legend_loc='right margin', legend_fontoutline=None, colorbar_loc='right', vmax=None, vmin=None, vcenter=None, norm=None, add_outline=False, outline_width=(0.3, 0.05), outline_color=('black', 'white'), ncols=4, hspace=0.25, wspace=None, title=None, show=None, save=None, ax=None, return_fig=None, marker='.', **kwargs)[source]#; Scatter plot in UMAP basis. Parameters:. adata AnnDataAnnotated data matrix. color str | Sequence[str] | None (default: None)Keys for annotations of observations/cells or variables/genes, e.g.,; 'ann1' or ['ann1', 'ann2']. gene_symbols str | None (default: None)Column name in .var DataFrame that stores gene symbols. By default var_names; refer to the index column of the .var DataFrame. Setting this option allows; alternative names to be used. use_raw bool | None (default: None)Use .raw attribute of adata for coloring with gene expression. If None,; defaults to True if layer isn’t provided and adata.raw is present. layer str | None (default: None)Name of the AnnData object layer that wants to be plotted. By default; adata.raw.X is plotted. If use_raw=False is set, then adata.X is plotted.; If layer is set to a valid layer name, then the layer is plotted. layer; takes precedence over use_raw. edges bool (default: False)Show edges. edges_width float (default: 0.1)Width of edges. edges_color str | Sequence[float] | Sequence[str] (default: 'grey')Color of edges. See draw_networkx_edges(). neighbors_key str | None (defaul",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pl.umap.html:10228,variab,variables,10228,en/stable/api/generated/scanpy.pl.umap.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pl.umap.html,1,['variab'],['variables']
Modifiability,"if flavor='seurat_v3'. span float (default: 0.3)The fraction of the data (cells) used when estimating the variance in the loess; model fit if flavor='seurat_v3'. n_bins int (default: 20)Number of bins for binning the mean gene expression. Normalization is; done with respect to each bin. If just a single gene falls into a bin,; the normalized dispersion is artificially set to 1. You’ll be informed; about this if you set settings.verbosity = 4. flavor Literal['seurat', 'cell_ranger', 'seurat_v3', 'seurat_v3_paper'] (default: 'seurat')Choose the flavor for identifying highly variable genes. For the dispersion; based methods in their default workflows, Seurat passes the cutoffs whereas; Cell Ranger passes n_top_genes. subset bool (default: False)Inplace subset to highly-variable genes if True otherwise merely indicate; highly variable genes. inplace bool (default: True)Whether to place calculated metrics in .var or return them. batch_key str | None (default: None)If specified, highly-variable genes are selected within each batch separately and merged.; This simple process avoids the selection of batch-specific genes and acts as a; lightweight batch correction method. For all flavors, except seurat_v3, genes are first sorted; by how many batches they are a HVG. For dispersion-based flavors ties are broken; by normalized dispersion. For flavor = 'seurat_v3_paper', ties are broken by the median; (across batches) rank based on within-batch normalized variance. check_values bool (default: True)Check if counts in selected layer are integers. A Warning is returned if set to True.; Only used if flavor='seurat_v3'/'seurat_v3_paper'. Return type:; DataFrame | None. Returns:; Returns a pandas.DataFrame with calculated metrics if inplace=True, else returns an AnnData object where it sets the following field:. adata.var['highly_variable']pandas.Series (dtype bool)boolean indicator of highly-variable genes. adata.var['means']pandas.Series (dtype float)means per gene. adata.var['dispe",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.highly_variable_genes.html:13759,variab,variable,13759,en/stable/generated/scanpy.pp.highly_variable_genes.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.highly_variable_genes.html,1,['variab'],['variable']
Modifiability,"imeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.read_10x_mtx. Contents . read_10x_mtx(). scanpy.read_10x_mtx#. scanpy.read_10x_mtx(path, *, var_names='gene_symbols', make_unique=True, cache=False, cache_compression=_empty, gex_only=True, prefix=None)[source]#; Read 10x-Genomics-formatted mtx directory. Parameters:. path Path | strPath to directory for .mtx and .tsv files,; e.g. ‘./filtered_gene_bc_matrices/hg19/’. var_names Literal['gene_symbols', 'gene_ids'] (default: 'gene_symbols')The variables index. make_unique bool (default: True)Whether to make the variables index unique by appending ‘-1’,; ‘-2’ etc. or not. cache bool (default: False)If False, read from source, if True, read from fast ‘h5ad’ cache. cache_compression Union[Literal['gzip', 'lzf'], None, Empty] (default: _empty)See the h5py Filter pipeline.; (Default: settings.cache_compression). gex_only bool (default: True)Only keep ‘Gene Expression’ data and ignore other feature types,; e.g. ‘Antibody Capture’, ‘CRISPR Guide Capture’, or ‘Custom’. prefix str | None (default: None)Any prefix before matrix.mtx, genes.tsv and barcodes.tsv. For instance,; if the files are named patientA_matrix.mtx, patientA_genes.tsv and; patientA_barcodes.tsv the prefix is patientA_.; (Default: no prefix). Return type:; AnnData. Returns:; An AnnData object. previous; scanpy.read_10x_h5. next; scanpy.read_visium. Contents; . read_10x_mtx(). By Scanpy development team. ; © Copyright 2024, the Scanpy dev",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.read_10x_mtx.html:9680,variab,variables,9680,en/stable/generated/scanpy.read_10x_mtx.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.read_10x_mtx.html,1,['variab'],['variables']
Modifiability,"implementation of mnnpy [Kang, 2018].; Depending on do_concatenate, returns matrices or AnnData objects in the; original order containing corrected expression values or a concatenated; matrix or AnnData object.; Be reminded that it is not advised to use the corrected data matrices for; differential expression testing.; More information and bug reports here. Parameters:. datas AnnData | ndarrayExpression matrices or AnnData objects. Matrices should be shaped like; n_obs × n_vars (n_cell × n_gene) and have consistent number of columns.; AnnData objects should have same number of variables. var_index Collection[str] | None (default: None)The index (list of str) of vars (genes). Necessary when using only a; subset of vars to perform MNN correction, and should be supplied with; var_subset. When datas are AnnData objects, var_index is ignored. var_subset Collection[str] | None (default: None)The subset of vars (list of str) to be used when performing MNN; correction. Typically, a list of highly variable genes (HVGs).; When set to None, uses all vars. batch_key str (default: 'batch')The batch_key for concatenate().; Only valid when do_concatenate and supplying AnnData objects. index_unique str (default: '-')The index_unique for concatenate().; Only valid when do_concatenate and supplying AnnData objects. batch_categories Collection[Any] | None (default: None)The batch_categories for concatenate().; Only valid when do_concatenate and supplying AnnData objects. k int (default: 20)Number of mutual nearest neighbors. sigma float (default: 1.0)The bandwidth of the Gaussian smoothing kernel used to compute the; correction vectors. Default is 1. cos_norm_in bool (default: True)Whether cosine normalization should be performed on the input data prior; to calculating distances between cells. cos_norm_out bool (default: True)Whether cosine normalization should be performed prior to computing corrected expression values. svd_dim int | None (default: None)The number of dimensions to use",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.mnn_correct.html:10785,variab,variable,10785,en/stable/generated/scanpy.external.pp.mnn_correct.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.mnn_correct.html,1,['variab'],['variable']
Modifiability,"ing normalize_pearson_residuals(adata). In our example pipeline, we then apply PCA to reduce the dataset to the most relevant dimensions. We visualize this reduced representation with t-SNE and perform Leiden clustering, which is again taken from the PBMC3k tutorial.; This is just one of many possible pipelines: After PCA, you could also use UMAP or other embeddings to inspect the data, and cluster the data with a different algorithm than Leiden. Preparations#; Because we will transform the raw data in adata.X to residuals in the next step, we first save a copy of the raw counts to adata.layers['raw']. Also, we save a depth-normalized and square-root transformed version of the data to adata.layers['sqrt_norm'], so we can use them for plotting normalized counts later. Further background on why to use the square-root transform here can be found in Wagner (2020). # keep raw and depth-normalized counts for later; adata_pbmc3k.layers[""raw""] = adata_pbmc3k.X.copy(); adata_pbmc3k.layers[""sqrt_norm""] = np.sqrt(; sc.pp.normalize_total(adata_pbmc3k, inplace=False)[""X""]; ). adata_pbmc10k.layers[""raw""] = adata_pbmc10k.X.copy(); adata_pbmc10k.layers[""sqrt_norm""] = np.sqrt(; sc.pp.normalize_total(adata_pbmc10k, inplace=False)[""X""]; ). normalizing counts per cell; finished (0:00:00); normalizing counts per cell; finished (0:00:00). Compute Pearson residuals#; This will transform the sparse raw counts in adata.X to a dense matrix of Pearson residuals. for adata in [adata_pbmc3k, adata_pbmc10k]:; sc.experimental.pp.normalize_pearson_residuals(adata). computing analytic Pearson residuals on adata.X; finished (0:00:00); computing analytic Pearson residuals on adata.X; finished (0:00:00). Compute PCA and t-SNE#; We now reduce the dimensionality of the data by running PCA on the Pearson residuals. On top, we run t-SNE for vizualisation. for adata in [adata_pbmc3k, adata_pbmc10k]:; sc.pp.pca(adata, n_comps=50); n_cells = len(adata); sc.tl.tsne(adata, use_rep=""X_pca""). computing PCA; with ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:24437,layers,layers,24437,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,2,['layers'],['layers']
Modifiability,"iolin. As previously, a dendrogram was added to group similar clusters. ax = sc.pl.stacked_violin(; pbmc, marker_genes_dict, groupby=""clusters"", swap_axes=False, dendrogram=True; ). matrixplot#; A simple way to visualize the expression of genes is with a matrix plot. This is a heatmap of the mean expression values per gene grouped by categories. This type plot basically shows the same information as the color in the dotplots.; Here, scale the expression of the genes from 0 to 1, being the maximum mean expression and 0 the minimum. sc.pl.matrixplot(; pbmc,; marker_genes_dict,; ""clusters"",; dendrogram=True,; cmap=""Blues"",; standard_scale=""var"",; colorbar_title=""column scaled\nexpression"",; ). Other useful option is to normalize the gene expression using sc.pp.scale. Here we store this information under the scale layer. Afterwards we adjust the plot min and max and use a diverging color map (in this case RdBu_r where _r means reversed). # scale and store results in layer; pbmc.layers[""scaled""] = sc.pp.scale(pbmc, copy=True).X. sc.pl.matrixplot(; pbmc,; marker_genes_dict,; ""clusters"",; dendrogram=True,; colorbar_title=""mean z-score"",; layer=""scaled"",; vmin=-2,; vmax=2,; cmap=""RdBu_r"",; ). Combining plots in subplots#; An axis can be passed to a plot to combine multiple outputs as in the following example. import matplotlib.pyplot as plt. fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(20, 4), gridspec_kw={""wspace"": 0.9}). ax1_dict = sc.pl.dotplot(; pbmc, marker_genes_dict, groupby=""bulk_labels"", ax=ax1, show=False; ); ax2_dict = sc.pl.stacked_violin(; pbmc, marker_genes_dict, groupby=""bulk_labels"", ax=ax2, show=False; ); ax3_dict = sc.pl.matrixplot(; pbmc, marker_genes_dict, groupby=""bulk_labels"", ax=ax3, show=False, cmap=""viridis""; ). Heatmaps#; Heatmaps do not collapse cells as in previous plots. Instead, each cells is shown in a row (or column if swap_axes=True). The groupby information can be added and is shown using the same color code found for sc.pl.umap or an",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/core.html:18435,layers,layers,18435,en/stable/tutorials/plotting/core.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/core.html,2,['layers'],['layers']
Modifiability,"ipped.; By default (or when specifying 'all' or None), these keys are tried:; [""tsne"", ""umap"", ""pagaFa"", ""pagaFr"", ""pagaUmap"", ""phate"",; ""fa"", ""fr"", ""kk"", ""drl"", ""rt"", ""trimap""].; For these, default display labels are automatically used.; For other values, you can specify a mapping from coordinate name to; display label, e.g. {""tsne"": ""t-SNE by Scanpy""}. annot_keys Iterable[str] | Mapping[str, str] | None (default: ('louvain', 'percent_mito', 'n_genes', 'n_counts'))Annotations in adata.obsm to export.; Can be a mapping from annotation column name to display label.; Specify None for all available columns in .obs. skip_matrix bool (default: False)Do not export the matrix.; If you had previously exported this adata into the same data_dir,; then there is no need to export the whole matrix again.; This option will make the export a lot faster,; e.g. when only coordinates or meta data were changed. html_dir Path | str | None (default: None)If this variable is set, the export will build html; files from data_dir to html_dir, creating html/js/json files.; Usually there is one global html output directory for all datasets.; Often, html_dir is located under a webserver’s (like Apache); htdocs directory or is copied to one.; A directory html_dir/project_name will be created and; an index.html will be created under html_dir for all subdirectories.; Existing files will be overwritten.; If do not to use html_dir,; you can use the command line tool cbBuild to build the html directory. port int | None (default: None)If this variable and html_dir are set,; Python’s built-in web server will be spawned as a daemon in the; background and serve the files under html_dir.; To kill the process, call cellbrowser.cellbrowser.stop(). do_debug bool (default: False)Activate debugging output. Examples; See this; tutorial. previous; scanpy.external.exporting.spring_project. next; Ecosystem. Contents; . cellbrowser(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.exporting.cellbrowser.html:12481,variab,variable,12481,en/stable/generated/scanpy.external.exporting.cellbrowser.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.exporting.cellbrowser.html,1,['variab'],['variable']
Modifiability,"is is interpreted as a vmin=percentile(N).; For example vmin=’p1.5’ is interpreted as the 1.5 percentile. If vmin is function, then; vmin is interpreted as the return value of the function over the list of values to plot.; For example to set vmin tp the mean of the values to plot, def my_vmin(values): return; np.mean(values) and then set vmin=my_vmin. If vmin is None (default) an automatic; minimum value is used as defined by matplotlib scatter function. When making multiple; plots, vmin can be a list of values, one for each plot. For example vmin=[0.1, 'p1', None, my_vmin]. vmaxThe value representing the upper limit of the color scale. The format is the same as for vmin. vcenterThe value representing the center of the color scale. Useful for diverging colormaps.; The format is the same as for vmin.; Example: sc.pl.umap(adata, color=’TREM2’, vcenter=’p50’, cmap=’RdBu_r’). add_outlineIf set to True, this will add a thin border around groups of dots. In some situations; this can enhance the aesthetics of the resulting image. outline_colorTuple with two valid color names used to adjust the add_outline. The first color is the; border color (default: black), while the second color is a gap color between the; border color and the scatter dot (default: white). outline_widthTuple with two width numbers used to adjust the outline. The first value is the width; of the border color as a fraction of the scatter dot size (default: 0.3). The second value is; width of the gap color (default: 0.05). ncolsNumber of panels per row. wspaceAdjust the width of the space between multiple panels. hspaceAdjust the height of the space between multiple panels. return_figReturn the matplotlib figure. kwargsArguments to pass to matplotlib.pyplot.scatter(),; for instance: the maximum and minimum values (e.g. vmin=-2, vmax=5). showShow the plot, do not return axis. saveIf True or a str, save the figure.; A string is appended to the default filename.; Infer the filetype if ending on {'.pdf', '.pn",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pl.pca_overview.html:13556,enhance,enhance,13556,en/stable/api/generated/scanpy.pl.pca_overview.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pl.pca_overview.html,1,['enhance'],['enhance']
Modifiability,"ized dispersions are ignored. Ignored if flavor='seurat_v3'. max_disp float (default: inf)If n_top_genes unequals None, this and all other cutoffs for the means and the; normalized dispersions are ignored. Ignored if flavor='seurat_v3'. span float (default: 0.3)The fraction of the data (cells) used when estimating the variance in the loess; model fit if flavor='seurat_v3'. n_bins int (default: 20)Number of bins for binning the mean gene expression. Normalization is; done with respect to each bin. If just a single gene falls into a bin,; the normalized dispersion is artificially set to 1. You’ll be informed; about this if you set settings.verbosity = 4. flavor Literal['seurat', 'cell_ranger', 'seurat_v3', 'seurat_v3_paper'] (default: 'seurat')Choose the flavor for identifying highly variable genes. For the dispersion; based methods in their default workflows, Seurat passes the cutoffs whereas; Cell Ranger passes n_top_genes. subset bool (default: False)Inplace subset to highly-variable genes if True otherwise merely indicate; highly variable genes. inplace bool (default: True)Whether to place calculated metrics in .var or return them. batch_key str | None (default: None)If specified, highly-variable genes are selected within each batch separately and merged.; This simple process avoids the selection of batch-specific genes and acts as a; lightweight batch correction method. For all flavors, except seurat_v3, genes are first sorted; by how many batches they are a HVG. For dispersion-based flavors ties are broken; by normalized dispersion. For flavor = 'seurat_v3_paper', ties are broken by the median; (across batches) rank based on within-batch normalized variance. check_values bool (default: True)Check if counts in selected layer are integers. A Warning is returned if set to True.; Only used if flavor='seurat_v3'/'seurat_v3_paper'. Return type:; DataFrame | None. Returns:; Returns a pandas.DataFrame with calculated metrics if inplace=True, else returns an AnnData obje",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.highly_variable_genes.html:13541,variab,variable,13541,en/stable/generated/scanpy.pp.highly_variable_genes.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.highly_variable_genes.html,2,['variab'],['variable']
Modifiability,"k_reduced; scanpy.datasets.paul15; scanpy.datasets.toggleswitch; scanpy.datasets.visium_sge. Deprecated functions; scanpy.pp.filter_genes_dispersion; scanpy.pp.normalize_per_cell. External API; Preprocessing: PP; scanpy.external.pp.bbknn; scanpy.external.pp.harmony_integrate; scanpy.external.pp.mnn_correct; scanpy.external.pp.scanorama_integrate; scanpy.external.pp.hashsolo; scanpy.external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .md. .pdf. Experimental. Experimental#; New methods that are in early development which are not (yet); integrated in Scanpy core. experimental.pp.normalize_pearson_residuals; Applies analytic Pearson residual normalization, based on Lause et al. [2021]. experimental.pp.normalize_pearson_residuals_pca; Applies analytic Pearson residual normalization and PCA, based on Lause et al. [2021]. experimental.pp.highly_variable_genes; Select highly variable genes using analytic Pearson residuals [Lause et al., 2021]. experimental.pp.recipe_pearson_residuals; Full pipeline for HVG selection and normalization by analytic Pearson residuals [Lause et al., 2021]. previous; scanpy.metrics.morans_i. next; scanpy.experimental.pp.normalize_pearson_residuals. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/experimental.html:9652,variab,variable,9652,en/stable/api/experimental.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/experimental.html,1,['variab'],['variable']
Modifiability,"ker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .ipynb. .pdf. Integrating data using ingest and BBKNN. Contents . PBMCs; Mapping PBMCs using ingest; Using BBKNN. Pancreas; Seeing the batch effect; BBKNN; Mapping onto a reference batch using ingest; Evaluating consistency; Cell types conserved across batches; All cell types. Visualizing distributions across batches; Density plot; Partial visualizaton of a subset of groups in embedding. Integrating data using ingest and BBKNN#; The following tutorial describes a simple PCA-based method for integrating data we call ingest and compares it with BBKNN [Polanski19]. BBKNN integrates well with the Scanpy workflow and is accessible through the bbknn function.; The ingest function assumes an annotated reference dataset that captures the biological variability of interest. The rational is to fit a model on the reference data and use it to project new data. For the time being, this model is a PCA combined with a neighbor lookup search tree, for which we use UMAP’s implementation [McInnes18]. Similar PCA-based integrations have been used before, for instance, in [Weinreb18]. As ingest is simple and the procedure clear, the workflow is transparent and fast.; Like BBKNN, ingest leaves the data matrix itself invariant.; Unlike BBKNN, ingest solves the label mapping problem (like scmap) and maintains an embedding that might have desired properties like specific clusters or trajectories. We refer to this asymmetric dataset integration as ingesting annotations from an annotated reference adata_ref into an adata that still lacks this annotation. It is different from learning a joint representation that integrates datasets in a symmetric way as BBKNN, Scanorma, Conos, CCA (e.g. in Seurat) or a conditional V",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/integrating-data-using-ingest.html:9987,variab,variability,9987,en/stable/tutorials/basics/integrating-data-using-ingest.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/integrating-data-using-ingest.html,2,['variab'],['variability']
Modifiability,"kshops by Maren Büttner. Experimental module#. Added scanpy.experimental module! Currently contains functionality related to pearson residuals in scanpy.experimental.pp pr1715 J Lause, G Palla, I Virshup. This includes:. normalize_pearson_residuals() for Pearson Residuals normalization; highly_variable_genes() for HVG selection with Pearson Residuals; normalize_pearson_residuals_pca() for Pearson Residuals normalization and dimensionality reduction with PCA; recipe_pearson_residuals() for Pearson Residuals normalization, HVG selection and dimensionality reduction with PCA. Features#. filter_rank_genes_groups() now allows to filter with absolute values of log fold change pr1649 S Rybakov; _choose_representation now subsets the provided representation to n_pcs, regardless of the name of the provided representation (should affect mostly neighbors()) pr2179 I Virshup PG Majev; scanpy.pp.scrublet() (and related functions) can now be used on AnnData objects containing multiple batches pr1965 J Manning; Number of variables plotted with pca_loadings() can now be controlled with n_points argument. Additionally, variables are no longer repeated if the anndata has less than 30 variables pr2075 Yves33; Dask arrays now work with scanpy.pp.normalize_total() pr1663 G Buckley, I Virshup; embedding_density() now allows more than 10 groups pr1936 A Wolf; Embedding plots can now pass colorbar_loc to specify the location of colorbar legend, or pass None to not show a colorbar pr1821 A Schaar I Virshup; Embedding plots now have a dimensions argument, which lets users select which dimensions of their embedding to plot and uses the same broadcasting rules as other arguments pr1538 I Virshup; print_versions() now uses session_info pr2089 P Angerer I Virshup. Ecosystem#; Multiple packages have been added to our ecosystem page, including:. decoupler a for footprint analysis and pathway enrichement pr2186 PB Mompel; dandelion for B-cell receptor analysis pr1953 Z Tuong; CIARA a feature selecti",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:23201,variab,variables,23201,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,1,['variab'],['variables']
Modifiability,"l.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .ipynb. .pdf. How to preprocess UMI count data with analytic Pearson residuals. Contents . Background; Preparations; Download data; Load data. Perform Quality control; Basic filtering; Compute quality control metrics; Plot quality control metrics. Use Pearson residuals for selection of highly variable genes; Compute 2000 variable genes with Pearson residuals; Plot gene selection; Apply gene selection; Print resulting adata objects. Transforming raw counts to Pearson residuals; Preparations; Compute Pearson residuals; Compute PCA and t-SNE; Compute Neighborhood graph and Leiden clustering; Plot Leiden clusters on tSNE and PBMC marker genes. Optional input arguments; Overdispersion parameter theta; Clipping threshold clip; chunksize and best practice to obtain Pearson residuals for large datasets. Wrapper functions for Pearson residuals preprocessing; References / See also. How to preprocess UMI count data with analytic Pearson residuals#; With version 1.9, scanpy introduces new preprocessing functions based on Pearson residuals into the experimental.pp module. These functions implement the core steps of the preprocessing described and benchmarked in Lause et al. (2021).; In the first part, this tutorial introduces the new core functions by demonstrating their usage on two example datasets. In the second part, we briefly ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:9556,variab,variable,9556,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,4,['variab'],['variable']
Modifiability,"let Detection chapter of Single Cell Best Practices. Normalization#; The next preprocessing step is normalization. A common approach is count depth scaling with subsequent log plus one (log1p) transformation. Count depth scaling normalizes the data to a “size factor” such as the median count depth in the dataset, ten thousand (CP10k) or one million (CPM, counts per million). The size factor for count depth scaling can be controlled via target_sum in pp.normalize_total. We are applying median count depth normalization with log1p transformation (AKA log1PF). # Saving count data; adata.layers[""counts""] = adata.X.copy(). # Normalizing to median total counts; sc.pp.normalize_total(adata); # Logarithmize the data; sc.pp.log1p(adata). Feature selection#; As a next step, we want to reduce the dimensionality of the dataset and only include the most informative genes. This step is commonly known as feature selection. The scanpy function pp.highly_variable_genes annotates highly variable genes by reproducing the implementations of Seurat [Satija et al., 2015], Cell Ranger [Zheng et al., 2017], and Seurat v3 [Stuart et al., 2019] depending on the chosen flavor. sc.pp.highly_variable_genes(adata, n_top_genes=2000, batch_key=""sample""). sc.pl.highly_variable_genes(adata). Dimensionality Reduction#; Reduce the dimensionality of the data by running principal component analysis (PCA), which reveals the main axes of variation and denoises the data. sc.tl.pca(adata). Let us inspect the contribution of single PCs to the total variance in the data. This gives us information about how many PCs we should consider in order to compute the neighborhood relations of cells, e.g. used in the clustering function leiden() or tsne(). In our experience, there does not seem to be signifigant downside to overestimating the numer of principal components. sc.pl.pca_variance_ratio(adata, n_pcs=50, log=True). You can also plot the principal components to see if there are any potentially undesired features ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering.html:15178,variab,variable,15178,en/stable/tutorials/basics/clustering.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering.html,2,['variab'],['variable']
Modifiability,"lity, and biological signals from variable genes will be amplified. Therefore, downstream processing like PCA will be dominated by biological rather then technical variances. This is why it makes sense to use Pearson residuals as basis for downstream processing.; After reducing the dataset to the most variable genes in the previous steps, we will now transform our raw counts to residuals by calling normalize_pearson_residuals(adata). In our example pipeline, we then apply PCA to reduce the dataset to the most relevant dimensions. We visualize this reduced representation with t-SNE and perform Leiden clustering, which is again taken from the PBMC3k tutorial.; This is just one of many possible pipelines: After PCA, you could also use UMAP or other embeddings to inspect the data, and cluster the data with a different algorithm than Leiden. Preparations#; Because we will transform the raw data in adata.X to residuals in the next step, we first save a copy of the raw counts to adata.layers['raw']. Also, we save a depth-normalized and square-root transformed version of the data to adata.layers['sqrt_norm'], so we can use them for plotting normalized counts later. Further background on why to use the square-root transform here can be found in Wagner (2020). # keep raw and depth-normalized counts for later; adata_pbmc3k.layers[""raw""] = adata_pbmc3k.X.copy(); adata_pbmc3k.layers[""sqrt_norm""] = np.sqrt(; sc.pp.normalize_total(adata_pbmc3k, inplace=False)[""X""]; ). adata_pbmc10k.layers[""raw""] = adata_pbmc10k.X.copy(); adata_pbmc10k.layers[""sqrt_norm""] = np.sqrt(; sc.pp.normalize_total(adata_pbmc10k, inplace=False)[""X""]; ). normalizing counts per cell; finished (0:00:00); normalizing counts per cell; finished (0:00:00). Compute Pearson residuals#; This will transform the sparse raw counts in adata.X to a dense matrix of Pearson residuals. for adata in [adata_pbmc3k, adata_pbmc10k]:; sc.experimental.pp.normalize_pearson_residuals(adata). computing analytic Pearson residuals on ad",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:24044,layers,layers,24044,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,2,['layers'],['layers']
Modifiability,"ll, 162(1):184–197, jul 2015. URL: https://doi.org/10.1016/j.cell.2015.05.047, doi:10.1016/j.cell.2015.05.047. [LWT19]; Mohammad Lotfollahi, F. Alexander Wolf, and Fabian J. Theis. Scgen predicts single-cell perturbation responses. Nature Methods, 16(8):715–721, jul 2019. URL: https://doi.org/10.1038/s41592-019-0494-8, doi:10.1038/s41592-019-0494-8. [LBC+21]; Malte Luecken, Daniel Burkhardt, Robrecht Cannoodt, Christopher Lance, Aditi Agrawal, Hananeh Aliee, Ann Chen, Louise Deconinck, Angela Detweiler, Alejandro Granados, Shelly Huynh, Laura Isacco, Yang Kim, Dominik Klein, Bony De Kumar, Sunil Kuppasani, Heiko Lickert, Aaron McGeever, Joaquin Melgarejo, Honey Mekonen, Maurizio Morri, Michaela Müller, Norma Neff, Sheryl Paul, Bastian Rieck, Kaylie Schneider, Scott Steelman, Michael Sterr, Daniel Treacy, Alexander Tong, Alexandra-Chloe Villani, Guilin Wang, Jia Yan, Ce Zhang, Angela Pisco, Smita Krishnaswamy, Fabian Theis, and Jonathan M Bloom. A sandbox for prediction and integration of dna, rna, and proteins in single cells. In J. Vanschoren and S. Yeung, editors, Proceedings of the Neural Information Processing Systems Track on Datasets and Benchmarks, volume 1. Curran, 2021. URL: https://datasets-benchmarks-proceedings.neurips.cc/paper_files/paper/2021/file/158f3069a435b314a80bdcb024f8e422-Paper-round2.pdf. [MCLW17]; Davis J McCarthy, Kieran R Campbell, Aaron T L Lun, and Quin F Wills. Scater: pre-processing, quality control, normalization and visualization of single-cell RNA-seq data in r. Bioinformatics, 33(8):1179–1186, jan 2017. URL: https://doi.org/10.1093/bioinformatics/btw777, doi:10.1093/bioinformatics/btw777. [MHM18]; Leland McInnes, John Healy, and James Melville. Umap: uniform manifold approximation and projection for dimension reduction. 2018. URL: https://arxiv.org/abs/1802.03426, doi:10.48550/ARXIV.1802.03426. [MWH+15]; Victoria Moignard, Steven Woodhouse, Laleh Haghverdi, Andrew J Lilly, Yosuke Tanaka, Adam C Wilkinson, Florian Buettner, Iain C Ma",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/references.html:18817,sandbox,sandbox,18817,en/stable/references.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/references.html,1,['sandbox'],['sandbox']
Modifiability,"ll. The not-excluded genes will sum up to; target_sum. Providing this argument when adata.X is a Array; will incur blocking .compute() calls on the array. max_fraction float (default: 0.05)If exclude_highly_expressed=True, consider cells as highly expressed; that have more counts than max_fraction of the original total counts; in at least one cell. key_added str | None (default: None)Name of the field in adata.obs where the normalization factor is; stored. layer str | None (default: None)Layer to normalize instead of X. If None, X is normalized. inplace bool (default: True)Whether to update adata or return dictionary with normalized copies of; adata.X and adata.layers. copy bool (default: False)Whether to modify copied input object. Not compatible with inplace=False. Return type:; AnnData | dict[str, ndarray] | None. Returns:; Returns dictionary with normalized copies of adata.X and adata.layers; or updates adata with normalized version of the original; adata.X and adata.layers, depending on inplace. Example; >>> import sys; >>> from anndata import AnnData; >>> import scanpy as sc; >>> sc.settings.verbosity = 'info'; >>> sc.settings.logfile = sys.stdout # for doctests; >>> np.set_printoptions(precision=2); >>> adata = AnnData(np.array([; ... [3, 3, 3, 6, 6],; ... [1, 1, 1, 2, 2],; ... [1, 22, 1, 2, 2],; ... ], dtype='float32')); >>> adata.X; array([[ 3., 3., 3., 6., 6.],; [ 1., 1., 1., 2., 2.],; [ 1., 22., 1., 2., 2.]], dtype=float32); >>> X_norm = sc.pp.normalize_total(adata, target_sum=1, inplace=False)['X']; normalizing counts per cell; finished (0:00:00); >>> X_norm; array([[0.14, 0.14, 0.14, 0.29, 0.29],; [0.14, 0.14, 0.14, 0.29, 0.29],; [0.04, 0.79, 0.04, 0.07, 0.07]], dtype=float32); >>> X_norm = sc.pp.normalize_total(; ... adata, target_sum=1, exclude_highly_expressed=True,; ... max_fraction=0.2, inplace=False; ... )['X']; normalizing counts per cell. The following highly-expressed genes are not considered during normalization factor computation:; ['1', '3', ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.normalize_total.html:11939,layers,layers,11939,en/stable/generated/scanpy.pp.normalize_total.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.normalize_total.html,1,['layers'],['layers']
Modifiability,"lt: 50)Number of principal components to compute in the PCA step. random_state float | None (default: 0)Random seed for setting the initial states for the optimization in the PCA step. kwargs_pca dict (default: {})Dictionary of further keyword arguments passed on to scanpy.pp.pca(). check_values bool (default: True)If True, checks if counts in selected layer are integers as expected by this; function, and return a warning if non-integers are found. Otherwise, proceed; without checking. Setting this to False can speed up code for large datasets. inplace bool (default: True)If True, update adata with results. Otherwise, return results. See below for; details of what is returned. Return type:; tuple[AnnData, DataFrame] | None. Returns:; If inplace=False, separately returns the gene selection results (as; DataFrame) and Pearson residual-based PCA results (as; AnnData). If inplace=True, updates adata with the; following fields for gene selection results:. .var['highly_variable']boolboolean indicator of highly-variable genes. .var['means']floatmeans per gene. .var['variances']floatvariances per gene. .var['residual_variances']floatPearson residual variance per gene. Averaged in the case of multiple; batches. .var['highly_variable_rank']floatRank of the gene according to residual variance, median rank in the; case of multiple batches. .var['highly_variable_nbatches']intIf batch_key is given, this denotes in how many batches genes are; detected as HVG. .var['highly_variable_intersection']boolIf batch_key is given, this denotes the genes that are highly variable; in all batches. The following fields contain Pearson residual-based PCA results and; normalization settings:. .uns['pearson_residuals_normalization']['pearson_residuals_df']The subset of highly variable genes, normalized by Pearson residuals. .uns['pearson_residuals_normalization']['theta']The used value of the overdisperion parameter theta. .uns['pearson_residuals_normalization']['clip']The used value of the clippin",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.recipe_pearson_residuals.html:12371,variab,variable,12371,en/stable/generated/scanpy.experimental.pp.recipe_pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.recipe_pearson_residuals.html,1,['variab'],['variable']
Modifiability,"map; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.pp.scale. Contents . scale(). scanpy.pp.scale#. scanpy.pp.scale(data, *, zero_center=True, max_value=None, copy=False, layer=None, obsm=None, mask_obs=None)[source]#; Scale data to unit variance and zero mean. Note; Variables (genes) that do not display any variation (are constant across; all observations) are retained and (for zero_center==True) set to 0; during this operation. In the future, they might be set to NaNs. Parameters:. data AnnData | spmatrix | ndarray | ArrayThe (annotated) data matrix of shape n_obs × n_vars.; Rows correspond to cells and columns to genes. zero_center bool (default: True)If False, omit zero-centering variables, which allows to handle sparse; input efficiently. max_value float | None (default: None)Clip (truncate) to this value after scaling. If None, do not clip. copy bool (default: False)Whether this function should be performed inplace. If an AnnData object; is passed, this also determines if a copy is returned. layer str | None (default: None)If provided, which element of layers to scale. obsm str | None (default: None)If provided, which element of obsm to scale. mask_obs ndarray[Any, dtype[bool]] | str | None (default: None)Restrict both the derivation of scaling parameters and the scaling itself; to a certain set of observations. The mask is specified as a boolean array; or a string referring to an array in obs.; This will transform data from csc to csr format if issparse(data). Return type:; AnnData | spmatrix | ndarray | Array | None. Returns:; Returns None if copy=False, else returns an updated AnnData object. Sets the following fields:. adata.X | adata.layers[layer]numpy.",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.scale.html:9872,variab,variables,9872,en/stable/generated/scanpy.pp.scale.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.scale.html,1,['variab'],['variables']
Modifiability,"me and the tenth var_name.; By giving more positions, more brackets/color blocks are drawn. var_group_labels Sequence[str] | None (default: None)Labels for each of the var_group_positions that want to be highlighted. var_group_rotation float | None (default: None)Label rotation degrees.; By default, labels larger than 4 characters are rotated 90 degrees. layer str | None (default: None)Name of the AnnData object layer that wants to be plotted. By default adata.raw.X is plotted.; If use_raw=False is set, then adata.X is plotted. If layer is set to a valid layer name,; then the layer is plotted. layer takes precedence over use_raw. title str | None (default: None)Title for the figure. colorbar_title str | None (default: 'Median expression\\nin group')Title for the color bar. New line character (n) can be used. cmap str | None (default: 'Blues')String denoting matplotlib color map. standard_scale Optional[Literal['var', 'obs']] (default: None)Whether or not to standardize the given dimension between 0 and 1, meaning for; each variable or group, subtract the minimum and divide each by its maximum. swap_axes bool (default: False)By default, the x axis contains var_names (e.g. genes) and the y axis; the groupby categories. By setting swap_axes then x are the; groupby categories and y the var_names. return_fig bool | None (default: False)Returns DotPlot object. Useful for fine-tuning; the plot. Takes precedence over show=False. stripplot bool (default: False)Add a stripplot on top of the violin plot.; See stripplot(). jitter float | bool (default: False)Add jitter to the stripplot (only when stripplot is True); See stripplot(). size int (default: 1)Size of the jitter points. order Sequence[str] | None (default: None)Order in which to show the categories. Note: if dendrogram=True; the categories order will be given by the dendrogram and order; will be ignored. scale Literal['area', 'count', 'width'] (default: 'width')The method used to scale the width of each violin.; If ‘wi",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pl.stacked_violin.html:13447,variab,variable,13447,en/stable/generated/scanpy.pl.stacked_violin.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pl.stacked_violin.html,1,['variab'],['variable']
Modifiability,"mean^2/theta), and theta=np.inf corresponds to a Poisson model. clip float | None (default: None)Determines if and how residuals are clipped:. If None, residuals are clipped to the interval [-sqrt(n_obs), sqrt(n_obs)], where n_obs is the number of cells in the dataset (default behavior).; If any scalar c, residuals are clipped to the interval [-c, c]. Set clip=np.inf for no clipping. n_comps int | None (default: 50)Number of principal components to compute in the PCA step. random_state float (default: 0)Random seed for setting the initial states for the optimization in the PCA step. kwargs_pca Mapping[str, Any] (default: mappingproxy({}))Dictionary of further keyword arguments passed on to scanpy.pp.pca(). mask_var ndarray | str | None | Empty (default: _empty)To run only on a certain set of genes given by a boolean array; or a string referring to an array in var.; By default, uses .var['highly_variable'] if available, else everything. use_highly_variable bool | None (default: None)Whether to use highly variable genes only, stored in; .var['highly_variable'].; By default uses them if they have been determined beforehand. Deprecated since version 1.10.0: Use mask_var instead. check_values bool (default: True)If True, checks if counts in selected layer are integers as expected by this; function, and return a warning if non-integers are found. Otherwise, proceed; without checking. Setting this to False can speed up code for large datasets. inplace bool (default: True)If True, update adata with results. Otherwise, return results. See below for; details of what is returned. Return type:; AnnData | None. Returns:; If inplace=False, returns the Pearson residual-based PCA results (as AnnData; object). If inplace=True, updates adata with the following fields:. .uns['pearson_residuals_normalization']['pearson_residuals_df']The subset of highly variable genes, normalized by Pearson residuals. .uns['pearson_residuals_normalization']['theta']The used value of the overdisperion pa",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.normalize_pearson_residuals_pca.html:11396,variab,variable,11396,en/stable/generated/scanpy.experimental.pp.normalize_pearson_residuals_pca.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.normalize_pearson_residuals_pca.html,1,['variab'],['variable']
Modifiability,"mediately. %%time; adata.layers[""counts""] = adata.X.copy() # Making sure we keep access to the raw counts; sc.pp.normalize_total(adata, target_sum=1e4). CPU times: user 7.1 ms, sys: 31 μs, total: 7.13 ms; Wall time: 7.49 ms. %%time; sc.pp.log1p(adata). CPU times: user 3.14 ms, sys: 2.03 ms, total: 5.17 ms; Wall time: 4.88 ms. Highly variable genes needs to add entries into obs, which currently does not support lazy column. So computation will occur immediately on call. %%time; sc.pp.highly_variable_genes(adata). CPU times: user 3.46 s, sys: 509 ms, total: 3.97 s; Wall time: 50 s. PCA currently does not support sparse data. So we will need to densify the expression matrix before passing it in. However, as we are working with only a subset of the data at a time, we are able to perform this operation with a lower memory overhead.; As this is a still a significant increase in memory usage per chunk, we will need to reduce the number of observations present in each chunk. adata.layers[""dense""] = adata.X.rechunk((DENSE_CHUNK_SIZE, -1)).map_blocks(; lambda x: x.toarray(), dtype=adata.X.dtype, meta=np.array([]); ). %%time; sc.pp.pca(adata, layer=""dense""). CPU times: user 9.31 s, sys: 1.19 s, total: 10.5 s; Wall time: 1min 27s. While most of the PCA computation runs immediately, the last step (computing the observation loadings) is lazy, so must be triggered manually to avoid recomputation. %%time; adata.obsm[""X_pca""] = adata.obsm[""X_pca""].compute(). CPU times: user 6.72 s, sys: 1.36 s, total: 8.08 s; Wall time: 1min 15s. adata. AnnData object with n_obs × n_vars = 1462702 × 27714; obs: 'celltype', 'majorType', 'City', 'sampleID', 'donor_id', 'Sample type', 'CoVID-19 severity', 'Sample time', 'Sampling day (Days after symptom onset)', 'BCR single cell sequencing', 'TCR single cell sequencing', 'Outcome', 'Comorbidities', 'COVID-19-related medication and anti-microbials', 'Leukocytes [G over L]', 'Neutrophils [G over L]', 'Lymphocytes [G over L]', 'Unpublished', 'disease_onto",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/dask.html:15496,layers,layers,15496,en/stable/tutorials/experimental/dask.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/dask.html,2,['layers'],['layers']
Modifiability,"more than max_fraction of the total counts; in at least one cell. The not-excluded genes will sum up to; target_sum. Providing this argument when adata.X is a Array; will incur blocking .compute() calls on the array. max_fraction float (default: 0.05)If exclude_highly_expressed=True, consider cells as highly expressed; that have more counts than max_fraction of the original total counts; in at least one cell. key_added str | None (default: None)Name of the field in adata.obs where the normalization factor is; stored. layer str | None (default: None)Layer to normalize instead of X. If None, X is normalized. inplace bool (default: True)Whether to update adata or return dictionary with normalized copies of; adata.X and adata.layers. copy bool (default: False)Whether to modify copied input object. Not compatible with inplace=False. Return type:; AnnData | dict[str, ndarray] | None. Returns:; Returns dictionary with normalized copies of adata.X and adata.layers; or updates adata with normalized version of the original; adata.X and adata.layers, depending on inplace. Example; >>> import sys; >>> from anndata import AnnData; >>> import scanpy as sc; >>> sc.settings.verbosity = 'info'; >>> sc.settings.logfile = sys.stdout # for doctests; >>> np.set_printoptions(precision=2); >>> adata = AnnData(np.array([; ... [3, 3, 3, 6, 6],; ... [1, 1, 1, 2, 2],; ... [1, 22, 1, 2, 2],; ... ], dtype='float32')); >>> adata.X; array([[ 3., 3., 3., 6., 6.],; [ 1., 1., 1., 2., 2.],; [ 1., 22., 1., 2., 2.]], dtype=float32); >>> X_norm = sc.pp.normalize_total(adata, target_sum=1, inplace=False)['X']; normalizing counts per cell; finished (0:00:00); >>> X_norm; array([[0.14, 0.14, 0.14, 0.29, 0.29],; [0.14, 0.14, 0.14, 0.29, 0.29],; [0.04, 0.79, 0.04, 0.07, 0.07]], dtype=float32); >>> X_norm = sc.pp.normalize_total(; ... adata, target_sum=1, exclude_highly_expressed=True,; ... max_fraction=0.2, inplace=False; ... )['X']; normalizing counts per cell. The following highly-expressed genes are not c",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.normalize_total.html:11855,layers,layers,11855,en/stable/generated/scanpy.pp.normalize_total.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.normalize_total.html,1,['layers'],['layers']
Modifiability,"mple or a collection of; similar samples from the same experiment.; This function is a wrapper around functions that pre-process using Scanpy; and directly call functions of Scrublet(). You may also undertake your own; preprocessing, simulate doublets with; scrublet_simulate_doublets(), and run the core scrublet; function scrublet() with adata_sim set. Parameters:. adata AnnDataThe annotated data matrix of shape n_obs × n_vars. Rows; correspond to cells and columns to genes. Expected to be un-normalised; where adata_sim is not supplied, in which case doublets will be; simulated and pre-processing applied to both objects. If adata_sim is; supplied, this should be the observed transcriptomes processed; consistently (filtering, transform, normalisaton, hvg) with adata_sim. adata_sim AnnData | None (default: None)(Advanced use case) Optional annData object generated by; scrublet_simulate_doublets(), with same number of vars; as adata. This should have been built from adata_obs after; filtering genes and cells and selcting highly-variable genes. batch_key str | None (default: None)Optional obs column name discriminating between batches. sim_doublet_ratio float (default: 2.0)Number of doublets to simulate relative to the number of observed; transcriptomes. expected_doublet_rate float (default: 0.05)Where adata_sim not suplied, the estimated doublet rate for the; experiment. stdev_doublet_rate float (default: 0.02)Where adata_sim not suplied, uncertainty in the expected doublet rate. synthetic_doublet_umi_subsampling float (default: 1.0)Where adata_sim not suplied, rate for sampling UMIs when creating; synthetic doublets. If 1.0, each doublet is created by simply adding; the UMI counts from two randomly sampled observed transcriptomes. For; values less than 1, the UMI counts are added and then randomly sampled; at the specified rate. knn_dist_metric Union[Literal['cityblock', 'cosine', 'euclidean', 'l1', 'l2', 'manhattan'], Literal['braycurtis', 'canberra', 'chebyshev', 'c",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pp.scrublet.html:11012,variab,variable,11012,en/stable/api/generated/scanpy.pp.scrublet.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pp.scrublet.html,1,['variab'],['variable']
Modifiability,"n annotation.; The default is not to restrict to any groups. dimensions0-indexed dimensions of the embedding to plot as integers. E.g. [(0, 1), (1, 2)].; Unlike components, this argument is used in the same way as colors, e.g. is; used to specify a single plot at a time. Will eventually replace the components; argument. componentsFor instance, ['1,2', '2,3']. To plot all available components use; components='all'. projectionProjection of plot (default: '2d'). legend_locLocation of legend, either 'on data', 'right margin', None,; or a valid keyword for the loc parameter of Legend. legend_fontsizeNumeric size in pt or string describing the size.; See set_fontsize(). legend_fontweightLegend font weight. A numeric value in range 0-1000 or a string.; Defaults to 'bold' if legend_loc == 'on data', otherwise to 'normal'.; See set_fontweight(). legend_fontoutlineLine width of the legend font outline in pt. Draws a white outline using; the path effect withStroke. colorbar_locWhere to place the colorbar for continous variables. If None, no colorbar; is added. sizePoint size. If None, is automatically computed as 120000 / n_cells.; Can be a sequence containing the size for each cell. The order should be; the same as in adata.obs. color_mapColor map to use for continous variables. Can be a name or a; Colormap instance (e.g. ""magma”, ""viridis""; or mpl.cm.cividis), see get_cmap().; If None, the value of mpl.rcParams[""image.cmap""] is used.; The default color_map can be set using set_figure_params(). paletteColors to use for plotting categorical annotation groups.; The palette can be a valid ListedColormap name; ('Set2', 'tab20', …), a Cycler object, a dict mapping; categories to colors, or a sequence of colors. Colors must be valid to; matplotlib. (see is_color_like()).; If None, mpl.rcParams[""axes.prop_cycle""] is used unless the categorical; variable already has colors stored in adata.uns[""{var}_colors""].; If provided, values of adata.uns[""{var}_colors""] will be set. na_colorColor",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pl.pca_overview.html:10895,variab,variables,10895,en/stable/api/generated/scanpy.pl.pca_overview.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pl.pca_overview.html,1,['variab'],['variables']
Modifiability,"n below. There are few things you should notice in Marsilea:. Always call render() in the end to actually render the plot.; The order of add_* operation decides the order of plotters. But group_rows and group_cols can be called anytime. m = ma.Heatmap(exp, cmap=""viridis"", height=4, width=3); m.group_rows(pbmc.obs[""louvain""], order=uni_cells). m.add_left(; mp.Colors(list(pbmc.obs[""louvain""]), palette=cmapper),; size=0.1,; pad=0.1,; ); m.add_left(mp.Chunk(uni_cells, rotation=0, align=""center"")); m.add_top(mp.Labels(markers), pad=0.1); m.add_dendrogram(""right"", add_base=False). m.add_legends(); m.add_title(""Expression Profile""); m.render(). Now that we’ve covered some basics of Marsilea, we’ll see how it can be used to create custom plots similar to scanpy’s existing methods:. agg = sc.get.aggregate(pbmc[:, markers], by=""louvain"", func=[""mean"", ""count_nonzero""]); agg.obs[""cell_counts""] = pbmc.obs[""louvain""].value_counts(); agg. AnnData object with n_obs × n_vars = 8 × 12; obs: 'louvain', 'cell_counts'; var: 'n_cells'; layers: 'mean', 'count_nonzero'. agg_exp = agg.layers[""mean""]; agg_count = agg.layers[""count_nonzero""]; agg_cell_counts = agg.obs[""cell_counts""].to_numpy(). Matrixplot#. h, w = agg_exp.shape. m = ma.Heatmap(; agg_exp,; height=h / 3,; width=w / 3,; cmap=""Blues"",; linewidth=0.5,; linecolor=""lightgray"",; label=""Expression"",; ); m.add_right(mp.Labels(agg.obs[""louvain""], align=""center""), pad=0.1); m.add_top(mp.Labels(markers), pad=0.1); m.group_cols(cells, order=uni_cells); m.add_top(mp.Chunk(uni_cells, fill_colors=cell_colors, rotation=90)); m.add_left(mp.Numbers(agg_cell_counts, color=""#EEB76B"", label=""Count"")); m.add_dendrogram(""right"", pad=0.1); m.add_legends(); m.render(). Dot plot#. size = agg_count / agg_cell_counts[:, np.newaxis]; m = ma.SizedHeatmap(; size=size,; color=agg_exp,; cluster_data=size,; height=h / 3,; width=w / 3,; edgecolor=""lightgray"",; cmap=""Blues"",; size_legend_kws=dict(; colors=""#538bbf"",; title=""Fraction of cells\nin groups (%)"",; lab",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/how-to/plotting-with-marsilea.html:13557,layers,layers,13557,en/stable/how-to/plotting-with-marsilea.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/how-to/plotting-with-marsilea.html,1,['layers'],['layers']
Modifiability,"n by Pearson residuals and PCA in one go. This function is helpful to quickly obtain a Pearson residual-based data representation when highly variable genes are already defined, as only those are used by default.; sc.experimental.pp.recipe_pearson_residuals() performs gene selection and normalization by Pearson residuals, and PCA on top. This is intended to make the full Pearson residual preprocessing available in one step. All hyperparameters of the individual steps can still be controlled using the wrapper functions’ arguments. See the documentation for details. References / See also#; Hafemeister & Satija (2019), Normalization and variance stabilization of single-cell RNA-seq data using regularized negative binomial regression, Genome Biology; Lause et al. (2021), Analytic Pearson residuals for normalization of single-cell RNA-seq UMI data, Genome Biology; Wagner (2021), Normalization methods for single-cell RNA-Seq data, Youtube; Choudhary & Satija (2022), Comparison and evaluation of statistical error models for scRNA-seq, Genome Biology. previous; Experimental. next; Using dask with Scanpy. Contents; . Background; Preparations; Download data; Load data. Perform Quality control; Basic filtering; Compute quality control metrics; Plot quality control metrics. Use Pearson residuals for selection of highly variable genes; Compute 2000 variable genes with Pearson residuals; Plot gene selection; Apply gene selection; Print resulting adata objects. Transforming raw counts to Pearson residuals; Preparations; Compute Pearson residuals; Compute PCA and t-SNE; Compute Neighborhood graph and Leiden clustering; Plot Leiden clusters on tSNE and PBMC marker genes. Optional input arguments; Overdispersion parameter theta; Clipping threshold clip; chunksize and best practice to obtain Pearson residuals for large datasets. Wrapper functions for Pearson residuals preprocessing; References / See also. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:31363,variab,variable,31363,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,4,['variab'],['variable']
Modifiability,"nal.pp.hashsolo; scanpy.external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.pl.pca_loadings. Contents . pca_loadings(). scanpy.pl.pca_loadings#. scanpy.pl.pca_loadings(adata, components=None, *, include_lowest=True, n_points=None, show=None, save=None)[source]#; Rank genes according to contributions to PCs. Parameters:. adata AnnDataAnnotated data matrix. components str | Sequence[int] | None (default: None)For example, '1,2,3' means [1, 2, 3], first, second, third; principal component. include_lowest bool (default: True)Whether to show the variables with both highest and lowest loadings. show bool | None (default: None)Show the plot, do not return axis. n_points int | None (default: None)Number of variables to plot for each component. save str | bool | None (default: None)If True or a str, save the figure.; A string is appended to the default filename.; Infer the filetype if ending on {'.pdf', '.png', '.svg'}. Examples; import scanpy as sc; adata = sc.datasets.pbmc3k_processed(). Show first 3 components loadings; sc.pl.pca_loadings(adata, components = '1,2,3'). previous; scanpy.pl.pca. next; scanpy.pl.pca_variance_ratio. Contents; . pca_loadings(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pl.pca_loadings.html:9709,variab,variables,9709,en/stable/api/generated/scanpy.pl.pca_loadings.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pl.pca_loadings.html,2,['variab'],['variables']
Modifiability,"nal.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.pp.log1p. Contents . log1p(). scanpy.pp.log1p#. scanpy.pp.log1p(data, *, base=None, copy=False, chunked=None, chunk_size=None, layer=None, obsm=None)[source]#; Logarithmize the data matrix.; Computes \(X = \log(X + 1)\),; where \(log\) denotes the natural logarithm unless a different base is given. Parameters:. data AnnData | ndarray | spmatrixThe (annotated) data matrix of shape n_obs × n_vars.; Rows correspond to cells and columns to genes. base Number | None (default: None)Base of the logarithm. Natural logarithm is used by default. copy bool (default: False)If an AnnData is passed, determines whether a copy; is returned. chunked bool | None (default: None)Process the data matrix in chunks, which will save memory.; Applies only to AnnData. chunk_size int | None (default: None)n_obs of the chunks to process the data in. layer str | None (default: None)Entry of layers to transform. obsm str | None (default: None)Entry of obsm to transform. Return type:; AnnData | ndarray | spmatrix | None. Returns:; Returns or updates data, depending on copy. previous; scanpy.pp.highly_variable_genes. next; scanpy.pp.pca. Contents; . log1p(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.log1p.html:10106,layers,layers,10106,en/stable/generated/scanpy.pp.log1p.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.log1p.html,1,['layers'],['layers']
Modifiability,"ne (default: None)Labels for each of the var_group_positions that want to be highlighted. var_group_rotation float | None (default: None)Label rotation degrees.; By default, labels larger than 4 characters are rotated 90 degrees. layer str | None (default: None)Name of the AnnData object layer that wants to be plotted. By default adata.raw.X is plotted.; If use_raw=False is set, then adata.X is plotted. If layer is set to a valid layer name,; then the layer is plotted. layer takes precedence over use_raw. title str | None (default: None)Title for the figure. expression_cutoffExpression cutoff that is used for binarizing the gene expression and; determining the fraction of cells expressing given genes. A gene is; expressed only if the expression value is greater than this threshold. mean_only_expressedIf True, gene expression is averaged only over the cells; expressing the given genes. standard_scale Literal['var', 'group'] (default: None)Whether or not to standardize that dimension between 0 and 1,; meaning for each variable or group,; subtract the minimum and divide each by its maximum. values_df DataFrame | None (default: None)Optionally, a dataframe with the values to plot can be given. The; index should be the grouby categories and the columns the genes names. kwdsAre passed to matplotlib.pyplot.scatter(). See also. matrixplot()Simpler way to call MatrixPlot but with less options. rank_genes_groups_matrixplot()to plot marker genes identified using the rank_genes_groups() function. Examples; Simple visualization of the average expression of a few genes grouped by; the category ‘bulk_labels’.; import scanpy as sc; adata = sc.datasets.pbmc68k_reduced(); markers = ['C1QA', 'PSAP', 'CD79A', 'CD79B', 'CST3', 'LYZ']; sc.pl.MatrixPlot(adata, markers, groupby='bulk_labels').show(). Same visualization but passing var_names as dict, which adds a grouping of; the genes on top of the image:; markers = {'T-cell': 'CD3D', 'B-cell': 'CD79A', 'myeloid': 'CST3'}; sc.pl.MatrixPlot(",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.MatrixPlot.html:13045,variab,variable,13045,en/stable/api/generated/classes/scanpy.pl.MatrixPlot.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.MatrixPlot.html,2,['variab'],['variable']
Modifiability,"ne)If provided, use adata.layers[layer] for expression values instead; of adata.X. use_raw bool (default: False)If True, use adata.raw.X for expression values instead of adata.X. inplace bool (default: False)Whether to place calculated metrics in adata’s .obs and .var. log1p bool (default: True)Set to False to skip computing log1p transformed annotations. Return type:; tuple[DataFrame, DataFrame] | None. Returns:; Depending on inplace returns calculated metrics; (as DataFrame) or updates adata’s obs and var.; Observation level metrics include:. total_{var_type}_by_{expr_type}E.g. “total_genes_by_counts”. Number of genes with positive counts in a cell. total_{expr_type}E.g. “total_counts”. Total number of counts for a cell. pct_{expr_type}_in_top_{n}_{var_type} – for n in percent_topE.g. “pct_counts_in_top_50_genes”. Cumulative percentage of counts; for 50 most expressed genes in a cell. total_{expr_type}_{qc_var} – for qc_var in qc_varsE.g. “total_counts_mito”. Total number of counts for variables in; qc_vars. pct_{expr_type}_{qc_var} – for qc_var in qc_varsE.g. “pct_counts_mito”. Proportion of total counts for a cell which; are mitochondrial. Variable level metrics include:. total_{expr_type}E.g. “total_counts”. Sum of counts for a gene. n_genes_by_{expr_type}E.g. “n_genes_by_counts”. The number of genes with at least 1 count in a cell. Calculated for all cells. mean_{expr_type}E.g. “mean_counts”. Mean expression over all cells. n_cells_by_{expr_type}E.g. “n_cells_by_counts”. Number of cells this expression is; measured in. pct_dropout_by_{expr_type}E.g. “pct_dropout_by_counts”. Percentage of cells this feature does; not appear in. Example; Calculate qc metrics for visualization.; import scanpy as sc; import seaborn as sns. pbmc = sc.datasets.pbmc3k(); pbmc.var[""mito""] = pbmc.var_names.str.startswith(""MT-""); sc.pp.calculate_qc_metrics(pbmc, qc_vars=[""mito""], inplace=True); sns.jointplot(; data=pbmc.obs,; x=""log1p_total_counts"",; y=""log1p_n_genes_by_counts"",; kind=""",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.calculate_qc_metrics.html:11703,variab,variables,11703,en/stable/generated/scanpy.pp.calculate_qc_metrics.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.calculate_qc_metrics.html,1,['variab'],['variables']
Modifiability,"nomics-formatted visum dataset.; In addition to reading regular 10x output,; this looks for the spatial folder and loads images,; coordinates and scale factors.; Based on the Space Ranger output docs.; See spatial() for a compatible plotting function. Parameters:. path Path | strPath to directory for visium datafiles. genome str | None (default: None)Filter expression to genes within this genome. count_file str (default: 'filtered_feature_bc_matrix.h5')Which file in the passed directory to use as the count file. Typically would be one of:; ‘filtered_feature_bc_matrix.h5’ or ‘raw_feature_bc_matrix.h5’. library_id str | None (default: None)Identifier for the visium library. Can be modified when concatenating multiple adata objects. source_image_path Path | str | None (default: None)Path to the high-resolution tissue image. Path will be included in; .uns[""spatial""][library_id][""metadata""][""source_image_path""]. Return type:; AnnData. Returns:; Annotated data matrix, where observations/cells are named by their; barcode and variables/genes by gene name. Stores the following information:. XThe data matrix is stored. obs_namesCell names. var_namesGene names for a feature barcode matrix, probe names for a probe bc matrix. var['gene_ids']Gene IDs. var['feature_types']Feature types. obs[filtered_barcodes]filtered barcodes if present in the matrix. varAny additional metadata present in /matrix/features is read in. uns['spatial']Dict of spaceranger output files with ‘library_id’ as key. uns['spatial'][library_id]['images']Dict of images ('hires' and 'lowres'). uns['spatial'][library_id]['scalefactors']Scale factors for the spots. uns['spatial'][library_id]['metadata']Files metadata: ‘chemistry_description’, ‘software_version’, ‘source_image_path’. obsm['spatial']Spatial spot coordinates, usable as basis by embedding(). previous; scanpy.read_10x_mtx. next; scanpy.read_h5ad. Contents; . read_visium(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.read_visium.html:10493,variab,variables,10493,en/stable/generated/scanpy.read_visium.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.read_visium.html,1,['variab'],['variables']
Modifiability,"np.mean(values) and then set vmin=my_vmin. If vmin is None (default) an automatic; minimum value is used as defined by matplotlib scatter function. When making multiple; plots, vmin can be a list of values, one for each plot. For example vmin=[0.1, 'p1', None, my_vmin]. vmax Union[str, float, Callable[[Sequence[float]], float], Sequence[Union[str, float, Callable[[Sequence[float]], float]]], None] (default: None)The value representing the upper limit of the color scale. The format is the same as for vmin. vcenter Union[str, float, Callable[[Sequence[float]], float], Sequence[Union[str, float, Callable[[Sequence[float]], float]]], None] (default: None)The value representing the center of the color scale. Useful for diverging colormaps.; The format is the same as for vmin.; Example: sc.pl.umap(adata, color=’TREM2’, vcenter=’p50’, cmap=’RdBu_r’). add_outline bool | None (default: False)If set to True, this will add a thin border around groups of dots. In some situations; this can enhance the aesthetics of the resulting image. outline_color tuple[str, str] (default: ('black', 'white'))Tuple with two valid color names used to adjust the add_outline. The first color is the; border color (default: black), while the second color is a gap color between the; border color and the scatter dot (default: white). outline_width tuple[float, float] (default: (0.3, 0.05))Tuple with two width numbers used to adjust the outline. The first value is the width; of the border color as a fraction of the scatter dot size (default: 0.3). The second value is; width of the gap color (default: 0.05). ncols int (default: 4)Number of panels per row. wspace float | None (default: None)Adjust the width of the space between multiple panels. hspace float (default: 0.25)Adjust the height of the space between multiple panels. return_fig bool | None (default: None)Return the matplotlib figure. kwargsArguments to pass to matplotlib.pyplot.scatter(),; for instance: the maximum and minimum values (e.g. vmin",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pl.phate.html:16999,enhance,enhance,16999,en/stable/generated/scanpy.external.pl.phate.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pl.phate.html,9,['enhance'],['enhance']
Modifiability,"nt. normalize_per_cell bool (default: True)If true, library size normalization is performed using; the sc.pp.normalize_per_cell function in Scanpy and saved into adata; object. Mean layer is re-introduces library size differences by; scaling the mean value of each cell in the output layer. See the; manuscript for more details. scale bool (default: True)If true, the input of the autoencoder is centered using; sc.pp.scale function of Scanpy. Note that the output is kept as raw; counts as loss functions are designed for the count data. log1p bool (default: True)If true, the input of the autoencoder is log transformed with a; pseudocount of one using sc.pp.log1p function of Scanpy. hidden_size Sequence[int] (default: (64, 32, 64))Width of hidden layers. hidden_dropout float | Sequence[float] (default: 0.0)Probability of weight dropout in the autoencoder (per layer if list; or tuple). batchnorm bool (default: True)If true, batch normalization is performed. activation str (default: 'relu')Activation function of hidden layers. init str (default: 'glorot_uniform')Initialization method used to initialize weights. network_kwds Mapping[str, Any] (default: mappingproxy({}))Additional keyword arguments for the autoencoder. epochs int (default: 300)Number of total epochs in training. reduce_lr int (default: 10)Reduces learning rate if validation loss does not improve in given number of epochs. early_stop int (default: 15)Stops training if validation loss does not improve in given number of epochs. batch_size int (default: 32)Number of samples in the batch used for SGD. optimizer str (default: 'RMSprop')Type of optimization method used for training. random_state Union[int, RandomState, None] (default: 0)Seed for python, numpy and tensorflow. threads int | None (default: None)Number of threads to use in training. All cores are used by default. learning_rate float | None (default: None)Learning rate to use in the training. verbose bool (default: False)If true, prints additional info",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.dca.html:11784,layers,layers,11784,en/stable/generated/scanpy.external.pp.dca.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.dca.html,1,['layers'],['layers']
Modifiability,"nts per cell; finished (0:00:00). Logarithmize the data:. sc.pp.log1p(adata). Identify highly-variable genes. sc.pp.highly_variable_genes(adata, min_mean=0.0125, max_mean=3, min_disp=0.5). extracting highly variable genes; finished (0:00:00); --> added; 'highly_variable', boolean vector (adata.var); 'means', float vector (adata.var); 'dispersions', float vector (adata.var); 'dispersions_norm', float vector (adata.var). sc.pl.highly_variable_genes(adata). Set the .raw attribute of the AnnData object to the normalized and logarithmized raw gene expression for later use in differential testing and visualizations of gene expression. This simply freezes the state of the AnnData object. Note; You can get back an AnnData of the object in .raw by calling .raw.to_adata(). adata.raw = adata. Note; If you don’t proceed below with correcting the data with sc.pp.regress_out and scaling it via sc.pp.scale, you can also get away without using .raw at all.; The result of the previous highly-variable-genes detection is stored as an annotation in .var.highly_variable and auto-detected by PCA and hence, sc.pp.neighbors and subsequent manifold/graph tools. In that case, the step actually do the filtering below is unnecessary, too. Actually do the filtering. adata = adata[:, adata.var.highly_variable]. Regress out effects of total counts per cell and the percentage of mitochondrial genes expressed. Scale the data to unit variance. sc.pp.regress_out(adata, [""total_counts"", ""pct_counts_mt""]). regressing out ['total_counts', 'pct_counts_mt']; sparse input is densified and may lead to high memory use; finished (0:00:02). Scale each gene to unit variance. Clip values exceeding standard deviation 10. sc.pp.scale(adata, max_value=10). Principal component analysis#; Reduce the dimensionality of the data by running principal component analysis (PCA), which reveals the main axes of variation and denoises the data. sc.tl.pca(adata, svd_solver=""arpack""). computing PCA; with n_comps=50; finished (0:",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering-2017.html:15041,variab,variable-genes,15041,en/stable/tutorials/basics/clustering-2017.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering-2017.html,2,['variab'],['variable-genes']
Modifiability,"nts.; Harmony [Korsunsky et al., 2019] is an algorithm for integrating single-cell; data from multiple experiments. This function uses the python; port of Harmony, harmonypy, to integrate single-cell data; stored in an AnnData object. As Harmony works by adjusting the; principal components, this function should be run after performing; PCA but before computing the neighbor graph, as illustrated in the; example below. Parameters:. adata AnnDataThe annotated data matrix. key strThe name of the column in adata.obs that differentiates; among experiments/batches. basis str (default: 'X_pca')The name of the field in adata.obsm where the PCA table is; stored. Defaults to 'X_pca', which is the default for; sc.pp.pca(). adjusted_basis str (default: 'X_pca_harmony')The name of the field in adata.obsm where the adjusted PCA; table will be stored after running this function. Defaults to; X_pca_harmony. kwargsAny additional arguments will be passed to; harmonypy.run_harmony(). Returns:; Updates adata with the field adata.obsm[obsm_out_field],; containing principal components adjusted by Harmony such that; different experiments are integrated. Example; First, load libraries and example dataset, and preprocess.; >>> import scanpy as sc; >>> import scanpy.external as sce; >>> adata = sc.datasets.pbmc3k(); >>> sc.pp.recipe_zheng17(adata); >>> sc.pp.pca(adata). We now arbitrarily assign a batch metadata variable to each cell; for the sake of example, but during real usage there would already; be a column in adata.obs giving the experiment each cell came; from.; >>> adata.obs['batch'] = 1350*['a'] + 1350*['b']. Finally, run harmony. Afterwards, there will be a new table in; adata.obsm containing the adjusted PC’s.; >>> sce.pp.harmony_integrate(adata, 'batch'); >>> 'X_pca_harmony' in adata.obsm; True. previous; scanpy.external.pp.bbknn. next; scanpy.external.pp.mnn_correct. Contents; . harmony_integrate(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.harmony_integrate.html:10952,variab,variable,10952,en/stable/generated/scanpy.external.pp.harmony_integrate.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.harmony_integrate.html,1,['variab'],['variable']
Modifiability,"od. Genes are first sorted by; how many batches they are a HVG. If flavor='pearson_residuals', ties are; broken by the median rank (across batches) based on within-batch residual; variance. chunksize int (default: 1000)If flavor='pearson_residuals', this dertermines how many genes are processed at; once while computing the residual variance. Choosing a smaller value will reduce; the required memory. flavor Literal['pearson_residuals'] (default: 'pearson_residuals')Choose the flavor for identifying highly variable genes. In this experimental; version, only ‘pearson_residuals’ is functional. check_values bool (default: True)If True, checks if counts in selected layer are integers as expected by this; function, and return a warning if non-integers are found. Otherwise, proceed; without checking. Setting this to False can speed up code for large datasets. layer str | None (default: None)Layer to use as input instead of X. If None, X is used. subset bool (default: False)If True, subset the data to highly-variable genes after finding them.; Otherwise merely indicate highly variable genes in adata.var (see below). inplace bool (default: True)If True, update adata with results. Otherwise, return results. See below for; details of what is returned. Return type:; DataFrame | None. Returns:; If inplace=True, adata.var is updated with the following fields. Otherwise,; returns the same fields as DataFrame. highly_variableboolboolean indicator of highly-variable genes. meansfloatmeans per gene. variancesfloatvariance per gene. residual_variancesfloatFor flavor='pearson_residuals', residual variance per gene. Averaged in the; case of multiple batches. highly_variable_rankfloatFor flavor='pearson_residuals', rank of the gene according to residual.; variance, median rank in the case of multiple batches. highly_variable_nbatchesintIf batch_key given, denotes in how many batches genes are detected as HVG. highly_variable_intersectionboolIf batch_key given, denotes the genes that are h",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.highly_variable_genes.html:12070,variab,variable,12070,en/stable/generated/scanpy.experimental.pp.highly_variable_genes.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.highly_variable_genes.html,1,['variab'],['variable']
Modifiability,"ooking at standard QC metrics we can observe that the samples do not contain empty spots.; We proceed to normalize Visium counts data with the built-in normalize_total method from Scanpy, and detect highly-variable genes (for later). As discussed previously, note that there are more sensible alternatives for normalization (see discussion in sc-tutorial paper and more recent alternatives such as SCTransform or GLM-PCA). for adata in [; adata_spatial_anterior,; adata_spatial_posterior,; ]:; sc.pp.normalize_total(adata, inplace=True); sc.pp.log1p(adata); sc.pp.highly_variable_genes(adata, flavor=""seurat"", n_top_genes=2000, inplace=True). normalizing counts per cell; finished (0:00:00); extracting highly variable genes; finished (0:00:00); --> added; 'highly_variable', boolean vector (adata.var); 'means', float vector (adata.var); 'dispersions', float vector (adata.var); 'dispersions_norm', float vector (adata.var); normalizing counts per cell; finished (0:00:00); extracting highly variable genes; finished (0:00:00); --> added; 'highly_variable', boolean vector (adata.var); 'means', float vector (adata.var); 'dispersions', float vector (adata.var); 'dispersions_norm', float vector (adata.var). Data integration#; We are now ready to perform integration of the two dataset. As mentioned before, we will be using Scanorama for that. Scanorama returns two lists, one for the integrated embeddings and one for the corrected counts, for each dataset.; We would like to note that in this context using BBKNN or Ingest is also possible. adatas = [adata_spatial_anterior, adata_spatial_posterior]; adatas_cor = scanorama.correct_scanpy(adatas, return_dimred=True). Found 32285 genes among all datasets; [[0. 0.48882265]; [0. 0. ]]; Processing datasets (0, 1). We will concatenate the two datasets and save the integrated embeddings in adata_spatial.obsm['scanorama_embedding']. Furthermore we will compute UMAP to visualize the results and qualitatively assess the data integration task.; Notic",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html:15668,variab,variable,15668,en/stable/tutorials/spatial/integration-scanorama.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html,2,['variab'],['variable']
Modifiability,"ools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.pp.normalize_total. Contents . normalize_total(). scanpy.pp.normalize_total#. scanpy.pp.normalize_total(adata, *, target_sum=None, exclude_highly_expressed=False, max_fraction=0.05, key_added=None, layer=None, layers=None, layer_norm=None, inplace=True, copy=False)[source]#; Normalize counts per cell.; Normalize each cell by total counts over all genes,; so that every cell has the same total count after normalization.; If choosing target_sum=1e6, this is CPM normalization.; If exclude_highly_expressed=True, very highly expressed genes are excluded; from the computation of the normalization factor (size factor) for each; cell. This is meaningful as these can strongly influence the resulting; normalized values for all other genes [Weinreb et al., 2017].; Similar functions are used, for example, by Seurat [Satija et al., 2015], Cell Ranger; [Zheng et al., 2017] or SPRING [Weinreb et al., 2017]. Note; When used with a Array in adata.X, this function will have to; call functions that trigger .compute() on the Array if exclude_highly_expressed; is True, layer_norm is not None, or if key_added is not None. Parameters:. adata AnnDataThe annotated data matrix of shape n_obs × n_vars.; Rows correspond to cells and columns to genes",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.normalize_total.html:9451,layers,layers,9451,en/stable/generated/scanpy.pp.normalize_total.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.normalize_total.html,1,['layers'],['layers']
Modifiability,"or='seurat_v3', genes are first sorted by the median (across batches) rank, with ties broken by the number of batches a gene is a HVG.; For flavor='seurat_v3_paper', genes are first sorted by the number of batches a gene is a HVG, with ties broken by the median (across batches) rank.; The following may help when comparing to Seurat’s naming:; If batch_key=None and flavor='seurat', this mimics Seurat’s FindVariableFeatures(…, method='mean.var.plot').; If batch_key=None and flavor='seurat_v3'/flavor='seurat_v3_paper', this mimics Seurat’s FindVariableFeatures(..., method='vst').; If batch_key is not None and flavor='seurat_v3_paper', this mimics Seurat’s SelectIntegrationFeatures.; See also scanpy.experimental.pp._highly_variable_genes for additional flavors; (e.g. Pearson residuals). Parameters:. adata AnnDataThe annotated data matrix of shape n_obs × n_vars. Rows correspond; to cells and columns to genes. layer str | None (default: None)If provided, use adata.layers[layer] for expression values instead of adata.X. n_top_genes int | None (default: None)Number of highly-variable genes to keep. Mandatory if flavor='seurat_v3'. min_mean float (default: 0.0125)If n_top_genes unequals None, this and all other cutoffs for the means and the; normalized dispersions are ignored. Ignored if flavor='seurat_v3'. max_mean float (default: 3)If n_top_genes unequals None, this and all other cutoffs for the means and the; normalized dispersions are ignored. Ignored if flavor='seurat_v3'. min_disp float (default: 0.5)If n_top_genes unequals None, this and all other cutoffs for the means and the; normalized dispersions are ignored. Ignored if flavor='seurat_v3'. max_disp float (default: inf)If n_top_genes unequals None, this and all other cutoffs for the means and the; normalized dispersions are ignored. Ignored if flavor='seurat_v3'. span float (default: 0.3)The fraction of the data (cells) used when estimating the variance in the loess; model fit if flavor='seurat_v3'. n_bins int (def",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.highly_variable_genes.html:11914,layers,layers,11914,en/stable/generated/scanpy.pp.highly_variable_genes.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.highly_variable_genes.html,1,['layers'],['layers']
Modifiability,"or=None, mask_obs=None, gene_symbols=None, use_raw=None, sort_order=True, edges=False, edges_width=0.1, edges_color='grey', neighbors_key=None, arrows=False, arrows_kwds=None, groups=None, components=None, dimensions=None, layer=None, projection='2d', scale_factor=None, color_map=None, cmap=None, palette=None, na_color='lightgray', na_in_legend=True, size=None, frameon=None, legend_fontsize=None, legend_fontweight='bold', legend_loc='right margin', legend_fontoutline=None, colorbar_loc='right', vmax=None, vmin=None, vcenter=None, norm=None, add_outline=False, outline_width=(0.3, 0.05), outline_color=('black', 'white'), ncols=4, hspace=0.25, wspace=None, title=None, show=None, save=None, ax=None, return_fig=None, marker='.', annotate_var_explained=False, **kwargs)[source]#; Scatter plot in PCA coordinates.; Use the parameter annotate_var_explained to annotate the explained variance. Parameters:. adata AnnDataAnnotated data matrix. color str | Sequence[str] | None (default: None)Keys for annotations of observations/cells or variables/genes, e.g.,; 'ann1' or ['ann1', 'ann2']. gene_symbols str | None (default: None)Column name in .var DataFrame that stores gene symbols. By default var_names; refer to the index column of the .var DataFrame. Setting this option allows; alternative names to be used. use_raw bool | None (default: None)Use .raw attribute of adata for coloring with gene expression. If None,; defaults to True if layer isn’t provided and adata.raw is present. layer str | None (default: None)Name of the AnnData object layer that wants to be plotted. By default; adata.raw.X is plotted. If use_raw=False is set, then adata.X is plotted.; If layer is set to a valid layer name, then the layer is plotted. layer; takes precedence over use_raw. annotate_var_explained bool (default: False). sort_order bool (default: True)For continuous annotations used as color parameter, plot data points; with higher values on top of others. groups str | Sequence[str] | None (default: N",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pl.pca.html:10336,variab,variables,10336,en/stable/api/generated/scanpy.pl.pca.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pl.pca.html,1,['variab'],['variables']
Modifiability,"orbar; is added. size int | float | None (default: None)Point size. If None, is automatically computed as 120000 / n_cells.; Can be a sequence containing the size for each cell. The order should be; the same as in adata.obs. color_map str | Colormap | None (default: None)Color map to use for continous variables. Can be a name or a; Colormap instance (e.g. ""magma”, ""viridis""; or mpl.cm.cividis), see get_cmap().; If None, the value of mpl.rcParams[""image.cmap""] is used.; The default color_map can be set using set_figure_params(). palette Union[Cycler, ListedColormap, str, tuple[float, ...], Sequence[Union[str, tuple[float, ...]]], None] (default: None)Colors to use for plotting categorical annotation groups.; The palette can be a valid ListedColormap name; ('Set2', 'tab20', …), a Cycler object, a dict mapping; categories to colors, or a sequence of colors. Colors must be valid to; matplotlib. (see is_color_like()).; If None, mpl.rcParams[""axes.prop_cycle""] is used unless the categorical; variable already has colors stored in adata.uns[""{var}_colors""].; If provided, values of adata.uns[""{var}_colors""] will be set. na_colorColor to use for null or masked values. Can be anything matplotlib accepts as a; color. Used for all points if color=None. na_in_legendIf there are missing values, whether they get an entry in the legend. Currently; only implemented for categorical legends. frameon bool | None (default: None)Draw a frame around the scatter plot. Defaults to value set in; set_figure_params(), defaults to True. title str | None (default: None)Provide title for panels either as string or list of strings,; e.g. ['title1', 'title2', ...]. show bool | None (default: None)Show the plot, do not return axis. save str | bool | None (default: None)If True or a str, save the figure.; A string is appended to the default filename.; Infer the filetype if ending on {'.pdf', '.png', '.svg'}. ax Axes | None (default: None)A matplotlib axes object. Only works if plotting a single compone",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pl.scatter.html:13552,variab,variable,13552,en/stable/generated/scanpy.pl.scatter.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pl.scatter.html,1,['variab'],['variable']
Modifiability,"orted; by how many batches they are a HVG. For dispersion-based flavors ties are broken; by normalized dispersion. For flavor = 'seurat_v3_paper', ties are broken by the median; (across batches) rank based on within-batch normalized variance. check_values bool (default: True)Check if counts in selected layer are integers. A Warning is returned if set to True.; Only used if flavor='seurat_v3'/'seurat_v3_paper'. Return type:; DataFrame | None. Returns:; Returns a pandas.DataFrame with calculated metrics if inplace=True, else returns an AnnData object where it sets the following field:. adata.var['highly_variable']pandas.Series (dtype bool)boolean indicator of highly-variable genes. adata.var['means']pandas.Series (dtype float)means per gene. adata.var['dispersions']pandas.Series (dtype float)For dispersion-based flavors, dispersions per gene. adata.var['dispersions_norm']pandas.Series (dtype float)For dispersion-based flavors, normalized dispersions per gene. adata.var['variances']pandas.Series (dtype float)For flavor='seurat_v3'/'seurat_v3_paper', variance per gene. adata.var['variances_norm']/'seurat_v3_paper'pandas.Series (dtype float)For flavor='seurat_v3'/'seurat_v3_paper', normalized variance per gene, averaged in; the case of multiple batches. adata.var['highly_variable_rank']pandas.Series (dtype float)For flavor='seurat_v3'/'seurat_v3_paper', rank of the gene according to normalized; variance, in case of multiple batches description above. adata.var['highly_variable_nbatches']pandas.Series (dtype int)If batch_key is given, this denotes in how many batches genes are detected as HVG. adata.var['highly_variable_intersection']pandas.Series (dtype bool)If batch_key is given, this denotes the genes that are highly variable in all batches. Notes; This function replaces filter_genes_dispersion(). previous; scanpy.pp.filter_genes. next; scanpy.pp.log1p. Contents; . highly_variable_genes(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.highly_variable_genes.html:15742,variab,variable,15742,en/stable/generated/scanpy.pp.highly_variable_genes.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.highly_variable_genes.html,1,['variab'],['variable']
Modifiability,"ortex.obs[""cell_subclass""].cat.categories),; ). cp_anterior_df.index = adata_anterior_subset.obs.index; cp_posterior_df.index = adata_posterior_subset.obs.index. adata_anterior_subset_transfer = adata_anterior_subset.copy(); adata_anterior_subset_transfer.obs = pd.concat(; [adata_anterior_subset.obs, cp_anterior_df], axis=1; ). adata_posterior_subset_transfer = adata_posterior_subset.copy(); adata_posterior_subset_transfer.obs = pd.concat(; [adata_posterior_subset.obs, cp_posterior_df], axis=1; ). We are then able to explore how cell types are propagated from the scRNA-seq dataset to the visium dataset. Let’s first visualize the neurons cortical layers. sc.pl.spatial(; adata_anterior_subset_transfer,; img_key=""hires"",; color=[""L2/3 IT"", ""L4"", ""L5 PT"", ""L6 CT""],; size=1.5,; ); sc.pl.spatial(; adata_posterior_subset_transfer,; img_key=""hires"",; color=[""L2/3 IT"", ""L4"", ""L5 PT"", ""L6 CT""],; size=1.5,; ). Interestingly, it seems that this approach worked, since sequential layers of cortical neurons could be correctly identified, both in the anterior and posterior sagittal slide.; We can go ahead an visualize astrocytes and oligodendrocytes as well. sc.pl.spatial(; adata_anterior_subset_transfer, img_key=""hires"", color=[""Oligo"", ""Astro""], size=1.5; ); sc.pl.spatial(; adata_posterior_subset_transfer, img_key=""hires"", color=[""Oligo"", ""Astro""], size=1.5; ). In this tutorial, we showed how to work with multiple slices in Scanpy, and perform label transfers between an annotated scRNA-seq dataset and an unannotated Visium dataset. We showed that such approach, that leverages the data integration performances of Scanorama, is useful and provide a straightforward tool for exploratory analysis.; However, for the label transfer task, we advise analysts to explore more principled approaches, based on cell-type deconvolution, that are likely to provide more accurate and interpretable results. See recent approaches such as:. Stereoscope paper - code; AutogeneS paper - code; MuSiC paper ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html:26589,layers,layers,26589,en/stable/tutorials/spatial/integration-scanorama.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html,2,['layers'],['layers']
Modifiability,"our function.; Consider parameterizing your tests using the pytest.mark.parameterize and pytest.fixture decorators.; You can read more about fixtures in pytest’s documentation, but we’d also recommend searching our test suite for existing usage. What to test#; If you’re not sure what to tests about your function, some ideas include:. Are there arguments which conflict with each other? Check that if they are both passed, the function throws an error (see pytest.raises docs).; Are there input values which should cause your function to error?; Did you add a helpful error message that recommends better outputs? Check that that error message is actually thrown.; Can you place bounds on the values returned by your function?; Are there different input values which should generate equivalent output (e.g. if an array is sparse or dense)?; Do you have arguments which should have orthogonal effects on the output? Check that they are independent. For example, if there is a flag for extended output, the base output should remain the same either way.; Are you optimizing a method? Check that it’s results are the same as a gold standard implementation. Performance#; It’s more important that you’re accurately testing the code works than it is that test suite runs quickly.; That said, it’s nice when the test suite runs fast.; You can check how long tests take to run by passing --durations=0 argument to pytest.; Hopefully your new tests won’t show up on top!; Some approaches to this include:. Is there a common setup/ computation happening in each test? Consider caching these in a scoped test fixture.; Is the behaviour you’re testing for dependent on the size of the data? If not, consider reducing it. Plotting tests#; While computational functions will return arrays and values, it can be harder to work with the output of plotting functions.; To make this easier, we use the image_comparer fixture for comparing plotting results (search the test suite for example usage).; This is used to ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/dev/testing.html:11548,extend,extended,11548,en/stable/dev/testing.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/dev/testing.html,1,['extend'],['extended']
Modifiability,"p.mnn_correct(*datas, var_index=None, var_subset=None, batch_key='batch', index_unique='-', batch_categories=None, k=20, sigma=1.0, cos_norm_in=True, cos_norm_out=True, svd_dim=None, var_adj=True, compute_angle=False, mnn_order=None, svd_mode='rsvd', do_concatenate=True, save_raw=False, n_jobs=None, **kwargs)[source]#; Correct batch effects by matching mutual nearest neighbors [Haghverdi et al., 2018] [Kang, 2018].; This uses the implementation of mnnpy [Kang, 2018].; Depending on do_concatenate, returns matrices or AnnData objects in the; original order containing corrected expression values or a concatenated; matrix or AnnData object.; Be reminded that it is not advised to use the corrected data matrices for; differential expression testing.; More information and bug reports here. Parameters:. datas AnnData | ndarrayExpression matrices or AnnData objects. Matrices should be shaped like; n_obs × n_vars (n_cell × n_gene) and have consistent number of columns.; AnnData objects should have same number of variables. var_index Collection[str] | None (default: None)The index (list of str) of vars (genes). Necessary when using only a; subset of vars to perform MNN correction, and should be supplied with; var_subset. When datas are AnnData objects, var_index is ignored. var_subset Collection[str] | None (default: None)The subset of vars (list of str) to be used when performing MNN; correction. Typically, a list of highly variable genes (HVGs).; When set to None, uses all vars. batch_key str (default: 'batch')The batch_key for concatenate().; Only valid when do_concatenate and supplying AnnData objects. index_unique str (default: '-')The index_unique for concatenate().; Only valid when do_concatenate and supplying AnnData objects. batch_categories Collection[Any] | None (default: None)The batch_categories for concatenate().; Only valid when do_concatenate and supplying AnnData objects. k int (default: 20)Number of mutual nearest neighbors. sigma float (default: 1.0)The bandw",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.mnn_correct.html:10365,variab,variables,10365,en/stable/generated/scanpy.external.pp.mnn_correct.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.mnn_correct.html,1,['variab'],['variables']
Modifiability,"per cell; the percentage of counts in mitochondrial genes. sc.pl.violin(; adata,; [""n_genes_by_counts"", ""total_counts"", ""pct_counts_mt""],; jitter=0.4,; multi_panel=True,; ). Remove cells that have too many mitochondrial genes expressed or too many total counts:. sc.pl.scatter(adata, x=""total_counts"", y=""pct_counts_mt""); sc.pl.scatter(adata, x=""total_counts"", y=""n_genes_by_counts""). Actually do the filtering by slicing the AnnData object. adata = adata[adata.obs.n_genes_by_counts < 2500, :]; adata = adata[adata.obs.pct_counts_mt < 5, :].copy(). Total-count normalize (library-size correct) the data matrix \(\mathbf{X}\) to 10,000 reads per cell, so that counts become comparable among cells. sc.pp.normalize_total(adata, target_sum=1e4). normalizing counts per cell; finished (0:00:00). Logarithmize the data:. sc.pp.log1p(adata). Identify highly-variable genes. sc.pp.highly_variable_genes(adata, min_mean=0.0125, max_mean=3, min_disp=0.5). extracting highly variable genes; finished (0:00:00); --> added; 'highly_variable', boolean vector (adata.var); 'means', float vector (adata.var); 'dispersions', float vector (adata.var); 'dispersions_norm', float vector (adata.var). sc.pl.highly_variable_genes(adata). Set the .raw attribute of the AnnData object to the normalized and logarithmized raw gene expression for later use in differential testing and visualizations of gene expression. This simply freezes the state of the AnnData object. Note; You can get back an AnnData of the object in .raw by calling .raw.to_adata(). adata.raw = adata. Note; If you don’t proceed below with correcting the data with sc.pp.regress_out and scaling it via sc.pp.scale, you can also get away without using .raw at all.; The result of the previous highly-variable-genes detection is stored as an annotation in .var.highly_variable and auto-detected by PCA and hence, sc.pp.neighbors and subsequent manifold/graph tools. In that case, the step actually do the filtering below is unnecessary, too. Actually do",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering-2017.html:14258,variab,variable,14258,en/stable/tutorials/basics/clustering-2017.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering-2017.html,2,['variab'],['variable']
Modifiability,"pression and other variables. Identification of clusters based on known marker genes; dotplot; violin plot; stacked-violin plot; matrixplot. Combining plots in subplots; Heatmaps; Tracksplot; Visualization of marker genes; Visualize marker genes using dotplot; Focusing on particular groups. Visualize marker genes using matrixplot; Visualize marker genes using stacked violin plots; Visualize marker genes using heatmap; Visualize marker genes using tracksplot. Comparison of marker genes using split violin plots; Dendrogram options; Plot correlation. Core plotting functions#; Author: Fidel Ramírez; This tutorial explores the visualization possibilities of scanpy and is divided into three sections:. Scatter plots for embeddings (eg. UMAP, t-SNE); Identification of clusters using known marker genes; Visualization of differentially expressed genes. In this tutorial, we will use a dataset from 10x containing 68k cells from PBMC. Scanpy, includes in its distribution a reduced sample of this dataset consisting of only 700 cells and 765 highly variable genes. This dataset has been already preprocessed and UMAP computed.; In this tutorial, we will also use the following literature markers:. B-cell: CD79A, MS4A1; Plasma: IGJ (JCHAIN); T-cell: CD3D; NK: GNLY, NKG7; Myeloid: CST3, LYZ; Monocytes: FCGR3A; Dendritic: FCER1A. Scatter plots for embeddings#; With scanpy, scatter plots for tSNE, UMAP and several other embeddings are readily available using the sc.pl.tsne, sc.pl.umap etc. functions. See here the list of options.; Those functions access the data stored in adata.obsm. For example sc.pl.umap uses the information stored in adata.obsm['X_umap']. For more flexibility, any key stored in adata.obsm can be used with the generic function sc.pl.embedding. import scanpy as sc; from matplotlib.pyplot import rc_context. sc.set_figure_params(dpi=100, color_map=""viridis_r""); sc.settings.verbosity = 0; sc.logging.print_header(). scanpy==1.10.0rc2.dev6+g14555ba4.d20240226 anndata==0.11.0",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/core.html:10393,variab,variable,10393,en/stable/tutorials/plotting/core.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/core.html,2,['variab'],['variable']
Modifiability,"py.external.pl.trimap. Contents . trimap(). scanpy.external.pl.trimap#. scanpy.external.pl.trimap(adata, *, color=None, mask_obs=None, gene_symbols=None, use_raw=None, sort_order=True, edges=False, edges_width=0.1, edges_color='grey', neighbors_key=None, arrows=False, arrows_kwds=None, groups=None, components=None, dimensions=None, layer=None, projection='2d', scale_factor=None, color_map=None, cmap=None, palette=None, na_color='lightgray', na_in_legend=True, size=None, frameon=None, legend_fontsize=None, legend_fontweight='bold', legend_loc='right margin', legend_fontoutline=None, colorbar_loc='right', vmax=None, vmin=None, vcenter=None, norm=None, add_outline=False, outline_width=(0.3, 0.05), outline_color=('black', 'white'), ncols=4, hspace=0.25, wspace=None, title=None, show=None, save=None, ax=None, return_fig=None, marker='.', **kwargs)[source]#; Scatter plot in TriMap basis. Parameters:. adata AnnDataAnnotated data matrix. color str | Sequence[str] | None (default: None)Keys for annotations of observations/cells or variables/genes, e.g.,; 'ann1' or ['ann1', 'ann2']. gene_symbols str | None (default: None)Column name in .var DataFrame that stores gene symbols. By default var_names; refer to the index column of the .var DataFrame. Setting this option allows; alternative names to be used. use_raw bool | None (default: None)Use .raw attribute of adata for coloring with gene expression. If None,; defaults to True if layer isn’t provided and adata.raw is present. layer str | None (default: None)Name of the AnnData object layer that wants to be plotted. By default; adata.raw.X is plotted. If use_raw=False is set, then adata.X is plotted.; If layer is set to a valid layer name, then the layer is plotted. layer; takes precedence over use_raw. edges bool (default: False)Show edges. edges_width float (default: 0.1)Width of edges. edges_color str | Sequence[float] | Sequence[str] (default: 'grey')Color of edges. See draw_networkx_edges(). neighbors_key str | None (defaul",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pl.trimap.html:10276,variab,variables,10276,en/stable/generated/scanpy.external.pl.trimap.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pl.trimap.html,1,['variab'],['variables']
Modifiability,"py.external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.pl.StackedViolin.legend. Contents . StackedViolin.legend(). scanpy.pl.StackedViolin.legend#. StackedViolin.legend(*, show=True, title='Expression\\nlevel in group', width=1.5)[source]#; Configure legend parameters. Parameters:. show bool | None (default: True)Set to ‘False’ to hide the default plot of the legend. This sets the; legend width to zero which will result in a wider main plot. title str | None (default: 'Expression\\nlevel in group')Legend title. Appears on top of the color bar. Use ‘\n’ to add line breaks. width float | None (default: 1.5)Width of the legend. The unit is the same as in matplotlib (inches). Return type:; Self. Returns:; Returns self for method chaining. Examples; Set legend title:; >>> import scanpy as sc; >>> adata = sc.datasets.pbmc68k_reduced(); >>> markers = {'T-cell': 'CD3D', 'B-cell': 'CD79A', 'myeloid': 'CST3'}; >>> dp = sc.pl._baseplot_class.BasePlot(adata, markers, groupby='bulk_labels') \; ... .legend(title='log(UMI counts + 1)'); >>> dp.color_legend_title; 'log(UMI counts + 1)'. previous; scanpy.pl.StackedViolin.getdoc. next; scanpy.pl.StackedViolin.make_figure. Contents; . StackedViolin.legend(). By Scanpy development team. ; © Copyrigh",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.legend.html:9432,Config,Configure,9432,en/stable/api/generated/classes/scanpy.pl.StackedViolin.legend.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.legend.html,1,['Config'],['Configure']
Modifiability,"r by modifying them directly. rcParams[""figure.figsize""] = (2, 2); sc.pl.umap(adata, color=""bulk_labels""); # Set back to value selected above; rcParams[""figure.figsize""] = FIGSIZE. We can set rcParams for a single plot with a context manager which won’t change the setting for future plots. with plt.rc_context({""figure.figsize"": (5, 5)}):; sc.pl.umap(adata, color=""bulk_labels""). We can also create an Axes object with a predefined size and pass it to a scanpy plotting function. fig, ax = plt.subplots(figsize=(4, 4)); sc.pl.umap(adata, color=""bulk_labels"", ax=ax). The figsize is divided between all Axes and spaces between them. Thus, if we have multiple Axes (columns or rows) we must accordingly increase figsize.; However, if we do not pass Axes objects to the scanpy embedding function it will automatically create individual Axes with the size of the current global figsize (as specified by e.g. matplotlib figure.figsize). ncol = 2; nrow = 1; figsize = 3; wspace = 1; # Adapt figure size based on number of rows and columns and added space between them; # (e.g. wspace between columns); fig, axs = plt.subplots(; nrow, ncol, figsize=(ncol * figsize + (ncol - 1) * wspace * figsize, nrow * figsize); ); plt.subplots_adjust(wspace=wspace); sc.pl.umap(adata, color=""louvain"", ax=axs[0], show=False); sc.pl.umap(adata, color=""phase"", ax=axs[1]). Adjust space between subplots#; When plotting multiple plots (e.g. with embedding) in the same row or column it may happen that the legend overlaps with the neighbouring plot. This can be overcomed by setting wspace (width) or hspace (height). These parameters can be likewise used when creating Axes for plotting (see the above section on using matplotlib Axes). # Default, legend is overlapping; sc.pl.umap(adata, color=[""bulk_labels"", ""phase""]). # Increase gap size between plots; sc.pl.umap(adata, color=[""bulk_labels"", ""phase""], wspace=1). Adapt axes appearance#; We can further modify the plot object (e.g. Axes) to change axis text, title siz",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/advanced.html:18510,Adapt,Adapt,18510,en/stable/tutorials/plotting/advanced.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/advanced.html,1,['Adapt'],['Adapt']
Modifiability,"r large datasets. inplace bool (default: True)If True, update adata with results. Otherwise, return results. See below for; details of what is returned. Return type:; tuple[AnnData, DataFrame] | None. Returns:; If inplace=False, separately returns the gene selection results (as; DataFrame) and Pearson residual-based PCA results (as; AnnData). If inplace=True, updates adata with the; following fields for gene selection results:. .var['highly_variable']boolboolean indicator of highly-variable genes. .var['means']floatmeans per gene. .var['variances']floatvariances per gene. .var['residual_variances']floatPearson residual variance per gene. Averaged in the case of multiple; batches. .var['highly_variable_rank']floatRank of the gene according to residual variance, median rank in the; case of multiple batches. .var['highly_variable_nbatches']intIf batch_key is given, this denotes in how many batches genes are; detected as HVG. .var['highly_variable_intersection']boolIf batch_key is given, this denotes the genes that are highly variable; in all batches. The following fields contain Pearson residual-based PCA results and; normalization settings:. .uns['pearson_residuals_normalization']['pearson_residuals_df']The subset of highly variable genes, normalized by Pearson residuals. .uns['pearson_residuals_normalization']['theta']The used value of the overdisperion parameter theta. .uns['pearson_residuals_normalization']['clip']The used value of the clipping parameter. .obsm['X_pca']PCA representation of data after gene selection and Pearson residual; normalization. .varm['PCs']The principal components containing the loadings. When inplace=True this; will contain empty rows for the genes not selected during HVG selection. .uns['pca']['variance_ratio']Ratio of explained variance. .uns['pca']['variance']Explained variance, equivalent to the eigenvalues of the covariance matrix. previous; scanpy.experimental.pp.highly_variable_genes. next; Classes. Contents; . recipe_pearson_residu",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.recipe_pearson_residuals.html:12922,variab,variable,12922,en/stable/generated/scanpy.experimental.pp.recipe_pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.recipe_pearson_residuals.html,1,['variab'],['variable']
Modifiability,"r; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .md. .pdf. Settings. Settings#; A convenience function for setting some default matplotlib.rcParams and a; high-resolution jupyter display backend useful for use in notebooks. set_figure_params; Set resolution/size, styling and format of figures. An instance of the ScanpyConfig is available as scanpy.settings and allows configuring Scanpy. _settings.ScanpyConfig; Config manager for scanpy. Some selected settings are discussed in the following.; Influence the global behavior of plotting functions. In non-interactive scripts,; you’d usually want to set settings.autoshow to False. autoshow; Automatically show figures if autosave == False (default True). autosave; Automatically save figures in figdir (default False). The default directories for saving figures, caching files and storing datasets. figdir; Directory for saving figures (default './figures/'). cachedir; Directory for cache files (default './cache/'). datasetdir; Directory for example datasets (default './data/'). The verbosity of logging output, where verbosity levels have the following; meaning: 0=’error’, 1=’warning’, 2=’info’, 3=’hint’, 4=more details, 5=even more; details, etc. verbosity; Verbosity level (default warning). Print versions of packages that might influence numerical results. logging.print_header; Versions that might influence",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/settings.html:9527,config,configuring,9527,en/stable/api/settings.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/settings.html,1,['config'],['configuring']
Modifiability,"r=True, alpha=None, basis=None, groups=None, components=None, projection='2d', legend_loc='right margin', legend_fontsize=None, legend_fontweight=None, legend_fontoutline=None, color_map=None, palette=None, frameon=None, right_margin=None, left_margin=None, size=None, marker='.', title=None, show=None, save=None, ax=None)[source]#; Scatter plot along observations or variables axes.; Color the plot using annotations of observations (.obs), variables; (.var) or expression of genes (.var_names). Parameters:. adata AnnDataAnnotated data matrix. x str | None (default: None)x coordinate. y str | None (default: None)y coordinate. color str | Collection[str] | None (default: None)Keys for annotations of observations/cells or variables/genes,; or a hex color specification, e.g.,; 'ann1', '#fe57a1', or ['ann1', 'ann2']. use_raw bool | None (default: None)Whether to use raw attribute of adata. Defaults to True if .raw is present. layers str | Collection[str] | None (default: None)Use the layers attribute of adata if present: specify the layer for; x, y and color. If layers is a string, then it is expanded to; (layers, layers, layers). basis Optional[Literal['pca', 'tsne', 'umap', 'diffmap', 'draw_graph_fr']] (default: None)String that denotes a plotting tool that computed coordinates. sort_order bool (default: True)For continuous annotations used as color parameter, plot data points; with higher values on top of others. groups str | Iterable[str] | None (default: None)Restrict to a few categories in categorical observation annotation.; The default is not to restrict to any groups. dimensions0-indexed dimensions of the embedding to plot as integers. E.g. [(0, 1), (1, 2)].; Unlike components, this argument is used in the same way as colors, e.g. is; used to specify a single plot at a time. Will eventually replace the components; argument. components str | Collection[str] | None (default: None)For instance, ['1,2', '2,3']. To plot all available components use; components='all'. p",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pl.scatter.html:10312,layers,layers,10312,en/stable/generated/scanpy.pl.scatter.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pl.scatter.html,2,['layers'],['layers']
Modifiability,"rformance#; It’s more important that you’re accurately testing the code works than it is that test suite runs quickly.; That said, it’s nice when the test suite runs fast.; You can check how long tests take to run by passing --durations=0 argument to pytest.; Hopefully your new tests won’t show up on top!; Some approaches to this include:. Is there a common setup/ computation happening in each test? Consider caching these in a scoped test fixture.; Is the behaviour you’re testing for dependent on the size of the data? If not, consider reducing it. Plotting tests#; While computational functions will return arrays and values, it can be harder to work with the output of plotting functions.; To make this easier, we use the image_comparer fixture for comparing plotting results (search the test suite for example usage).; This is used to check that generated plots look the same as they did previously.; Reference images (the expected output) are stored as expected.png to relevant tests directory under scanpy/tests/_images.; When run, the test suite will generate actual.png files for each check.; These files are compared, and if the actual plot differs from the reference plot, a diff of the images is also generated.; Paths for all these files will be reported when a test fails, and images for failed plots can be viewed via the :doc:CI interface <ci>.; A common gotcha here is that plots often change slightly on different machines/ OSs.; scanpy’s test suite sets a number of environment variables to ensure as similar of plots as possible.; When adding new reference plots, the recommended workflow is to write the test as though an expected result already exists, run it once to generate the output, then move that output to the reference directory. previous; Getting set up. next; Documentation. Contents; . Running the tests; Miscellaneous tips. Writing tests; What to test; Performance; Plotting tests. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/dev/testing.html:13220,variab,variables,13220,en/stable/dev/testing.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/dev/testing.html,1,['variab'],['variables']
Modifiability,"ries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.datasets.pbmc3k_processed. Contents . pbmc3k_processed(). scanpy.datasets.pbmc3k_processed#. scanpy.datasets.pbmc3k_processed()[source]#; Processed 3k PBMCs from 10x Genomics.; Processed using the basic tutorial Preprocessing and clustering 3k PBMCs (legacy workflow).; For preprocessing, cells are filtered out that have few gene counts or too high a percent_mito.; The counts are logarithmized and only genes marked by highly_variable_genes() are retained.; The obs variables n_counts and percent_mito are corrected for; using regress_out(), and values are scaled and clipped by scale().; Finally, pca() and neighbors() are calculated.; As analysis steps, the embeddings tsne() and umap() are performed.; Communities are identified using louvain() and marker genes using rank_genes_groups(). Return type:; AnnData. Returns:; Annotated data matrix. Examples; >>> import scanpy as sc; >>> sc.datasets.pbmc3k_processed(); AnnData object with n_obs × n_vars = 2638 × 1838; obs: 'n_genes', 'percent_mito', 'n_counts', 'louvain'; var: 'n_cells'; uns: 'draw_graph', 'louvain', 'louvain_colors', 'neighbors', 'pca', 'rank_genes_groups'; obsm: 'X_pca', 'X_tsne', 'X_umap', 'X_draw_graph_fr'; varm: 'PCs'; obsp: 'distances', 'connectivities'. previous; scanpy.datasets.pbmc3k. next; scanpy.datasets.pbmc68k_reduced. Contents; . pbmc3k_processed(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.datasets.pbmc3k_processed.html:9716,variab,variables,9716,en/stable/generated/scanpy.datasets.pbmc3k_processed.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.datasets.pbmc3k_processed.html,1,['variab'],['variables']
Modifiability,"rmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.tl.dendrogram. Contents . dendrogram(). scanpy.tl.dendrogram#. scanpy.tl.dendrogram(adata, groupby, *, n_pcs=None, use_rep=None, var_names=None, use_raw=None, cor_method='pearson', linkage_method='complete', optimal_ordering=False, key_added=None, inplace=True)[source]#; Computes a hierarchical clustering for the given groupby categories.; By default, the PCA representation is used unless .X; has less than 50 variables.; Alternatively, a list of var_names (e.g. genes) can be given.; Average values of either var_names or components are used; to compute a correlation matrix.; The hierarchical clustering can be visualized using; scanpy.pl.dendrogram() or multiple other visualizations that can; include a dendrogram: matrixplot(),; heatmap(), dotplot(),; and stacked_violin(). Note; The computation of the hierarchical clustering is based on predefined; groups and not per cell. The correlation matrix is computed using by; default pearson but other methods are available. Parameters:. adata AnnDataAnnotated data matrix. n_pcs int | None (default: None)Use this many PCs. If n_pcs==0 use .X if use_rep is None. use_rep str | None (default: None)Use the indicated representation. 'X' or any key for .obsm is valid.; If None, the representation is chosen automatically:; For .n_vars < N_PCS (default: 50), .X is used, otherwise ‘X_pca’ is used.; If ‘X_pca’ is not present, it’s computed with default para",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.dendrogram.html:9649,variab,variables,9649,en/stable/generated/scanpy.tl.dendrogram.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.dendrogram.html,1,['variab'],['variables']
Modifiability,"rnal.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.pp.combat. Contents . combat(). scanpy.pp.combat#. scanpy.pp.combat(adata, key='batch', *, covariates=None, inplace=True)[source]#; ComBat function for batch effect correction [Johnson et al., 2006, Leek et al., 2017, Pedersen, 2012].; Corrects for batch effects by fitting linear models, gains statistical power; via an EB framework where information is borrowed across genes.; This uses the implementation combat.py [Pedersen, 2012]. Parameters:. adata AnnDataAnnotated data matrix. key str (default: 'batch')Key to a categorical annotation from obs; that will be used for batch effect removal. covariates Collection[str] | None (default: None)Additional covariates besides the batch variable such as adjustment; variables or biological condition. This parameter refers to the design; matrix X in Equation 2.1 in Johnson et al. [2006] and to the mod argument in; the original combat function in the sva R package.; Note that not including covariates may introduce bias or lead to the; removal of biological signal in unbalanced designs. inplace bool (default: True)Whether to replace adata.X or to return the corrected data. Return type:; ndarray | None. Returns:; Returns numpy.ndarray if inplace=True, else returns None and sets the following field in the adata object:. adata.Xnumpy.ndarray (dtype float)Corrected data matrix. previous; scanpy.pp.recipe_seurat. next; scanpy.pp.scrublet. Contents; . combat(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pp.combat.html:9918,variab,variable,9918,en/stable/api/generated/scanpy.pp.combat.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pp.combat.html,2,['variab'],"['variable', 'variables']"
Modifiability,"rrect; scanpy.external.pp.scanorama_integrate; scanpy.external.pp.hashsolo; scanpy.external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .ipynb. .pdf. Customizing Scanpy plots. Contents . Talking to matplotlib; Figure and Axes objects; Using matplotlib Axes to customize plot alignment; Plot size; Adjust space between subplots; Adapt axes appearance. Labels and legends; Customizing legends; Annotating scatter plots. Colors; Discrete palettes; Continous palettes; Colorblind friendly palettes. UMAP; Coloring cell subset; Cell ordering; Optimising UMAP layout. PAGA; Prune PAGA edges; PAGA layout; PAGA layout corresponding to UMAP. Customizing Scanpy plots#; This is an advanced tutorial on customizing scanpy plots. For an introduction to scanpy plotting functions please see the introductory tutorial. import scanpy as sc; import pandas as pd; import numpy as np. import matplotlib.pyplot as plt; import seaborn as sns; import matplotlib.colors as mcolors. # Inital setting for plot size; from matplotlib import rcParams. FIGSIZE = (3, 3); rcParams[""figure.figsize""] = FIGSIZE. adata = sc.datasets.pbmc68k_reduced(). Talking to matplotlib#; This section provides general information on how to customize plots.; scanpy plots are based on matplotlib objects, which w",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/advanced.html:9414,Adapt,Adapt,9414,en/stable/tutorials/plotting/advanced.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/advanced.html,1,['Adapt'],['Adapt']
Modifiability,"rson_residuals', ties are; broken by the median rank (across batches) based on within-batch residual; variance. chunksize int (default: 1000)If flavor='pearson_residuals', this dertermines how many genes are processed at; once while computing the residual variance. Choosing a smaller value will reduce; the required memory. flavor Literal['pearson_residuals'] (default: 'pearson_residuals')Choose the flavor for identifying highly variable genes. In this experimental; version, only ‘pearson_residuals’ is functional. check_values bool (default: True)If True, checks if counts in selected layer are integers as expected by this; function, and return a warning if non-integers are found. Otherwise, proceed; without checking. Setting this to False can speed up code for large datasets. layer str | None (default: None)Layer to use as input instead of X. If None, X is used. subset bool (default: False)If True, subset the data to highly-variable genes after finding them.; Otherwise merely indicate highly variable genes in adata.var (see below). inplace bool (default: True)If True, update adata with results. Otherwise, return results. See below for; details of what is returned. Return type:; DataFrame | None. Returns:; If inplace=True, adata.var is updated with the following fields. Otherwise,; returns the same fields as DataFrame. highly_variableboolboolean indicator of highly-variable genes. meansfloatmeans per gene. variancesfloatvariance per gene. residual_variancesfloatFor flavor='pearson_residuals', residual variance per gene. Averaged in the; case of multiple batches. highly_variable_rankfloatFor flavor='pearson_residuals', rank of the gene according to residual.; variance, median rank in the case of multiple batches. highly_variable_nbatchesintIf batch_key given, denotes in how many batches genes are detected as HVG. highly_variable_intersectionboolIf batch_key given, denotes the genes that are highly variable in all batches. Notes; Experimental version of sc.pp.highly_vari",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.highly_variable_genes.html:12139,variab,variable,12139,en/stable/generated/scanpy.experimental.pp.highly_variable_genes.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.highly_variable_genes.html,1,['variab'],['variable']
Modifiability,"s than 1 cells. Use Pearson residuals for selection of highly variable genes#; Analytic Pearson residuals can be used to identify biologically variable genes. For that, the observed counts are compared to the expected counts of a “null model”. This model includes no biological variability between cells. Pearson residuals are defined such that genes that are not differentially expressed will have variance close to 1. In contrast, if a gene is differentially expressed, it will deviate from the null model, causing larger residuals and residual variance >1 for this gene. More details and comparisons to other gene selection methods can be found in Lause et al. (2021).; The call to highly_variable_genes(flavor='pearson_residuals',n_top_genes=2000) computes the residual variances and selects 2000 genes based on this. As shown in the plots below, cell type marker genes known a priori are successfully selected. Compute 2000 variable genes with Pearson residuals#; This will create the field highly_variable, indicating the 2000 genes that have the most variable Pearson residuals. for adata in [adata_pbmc3k, adata_pbmc10k]:; sc.experimental.pp.highly_variable_genes(; adata, flavor=""pearson_residuals"", n_top_genes=2000; ). extracting highly variable genes; --> added; 'highly_variable', boolean vector (adata.var); 'highly_variable_rank', float vector (adata.var); 'highly_variable_nbatches', int vector (adata.var); 'highly_variable_intersection', boolean vector (adata.var); 'means', float vector (adata.var); 'variances', float vector (adata.var); 'residual_variances', float vector (adata.var); extracting highly variable genes; --> added; 'highly_variable', boolean vector (adata.var); 'highly_variable_rank', float vector (adata.var); 'highly_variable_nbatches', int vector (adata.var); 'highly_variable_intersection', boolean vector (adata.var); 'means', float vector (adata.var); 'variances', float vector (adata.var); 'residual_variances', float vector (adata.var). Plot gene selectio",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:18541,variab,variable,18541,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,4,['variab'],['variable']
Modifiability,"s#. Fixed a bug in pca(), where random_state did not have an effect for sparse input pr1240 I Virshup; Fixed docstring in pca() which included an unused argument pr1240 I Virshup. 1.5.0 2020-05-15#; The 1.5.0 release adds a lot of new functionality, much of which takes advantage of anndata updates 0.7.0 - 0.7.2. Highlights of this release include support for spatial data, dedicated handling of graphs in AnnData, sparse PCA, an interface with scvi, and others. Spatial data support#. Basic analysis Analysis and visualization of spatial transcriptomics data and integration with single cell data Integrating spatial data with scRNA-seq using scanorama G Palla; read_visium() read 10x Visium data pr1034 G Palla, P Angerer, I Virshup; visium_sge() load Visium data directly from 10x Genomics pr1013 M Mirkazemi, G Palla, P Angerer; spatial() plot spatial data pr1012 G Palla, P Angerer. New functionality#. Many functions, like neighbors() and umap(), now store cell-by-cell graphs in obsp pr1118 S Rybakov; scale() and log1p() can be used on any element in layers or obsm pr1173 I Virshup. External tools#. scanpy.external.pp.scvi for preprocessing with scVI pr1085 G Xing; Guide for using Scanpy in R pr1186 L Zappia. Performance#. pca() now uses efficient implicit centering for sparse matrices. This can lead to signifigantly improved performance for large datasets pr1066 A Tarashansky; score_genes() now has an efficient implementation for sparse matrices with missing values pr1196 redst4r. Warning; The new pca() implementation can result in slightly different results for sparse matrices. See the pr (pr1066) and documentation for more info. Code design#. stacked_violin() can now be used as a subplot pr1084 P Angerer; score_genes() has improved logging pr1119 G Eraslan; scale() now saves mean and standard deviation in the var pr1173 A Wolf; harmony_timeseries() pr1091 A Mousa. Bug fixes#. combat() now works when obs_names aren’t unique. pr1215 I Virshup; scale() can now be used on d",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:38356,layers,layers,38356,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,1,['layers'],['layers']
Modifiability,"s(adata_spatial_anterior, inplace=True); sc.pp.calculate_qc_metrics(adata_spatial_posterior, inplace=True). for name, adata in [; (""anterior"", adata_spatial_anterior),; (""posterior"", adata_spatial_posterior),; ]:; fig, axs = plt.subplots(1, 4, figsize=(12, 3)); fig.suptitle(f""Covariates for filtering: {name}""). sns.histplot(adata.obs[""total_counts""], kde=False, ax=axs[0]); sns.histplot(; adata.obs[""total_counts""][adata.obs[""total_counts""] < 20000],; kde=False,; bins=40,; ax=axs[1],; ); sns.histplot(adata.obs[""n_genes_by_counts""], kde=False, bins=60, ax=axs[2]); sns.histplot(; adata.obs[""n_genes_by_counts""][adata.obs[""n_genes_by_counts""] < 4000],; kde=False,; bins=60,; ax=axs[3],; ). sc.datasets.visium_sge downloads the filtered visium dataset, the output of spaceranger that contains only spots within the tissue slice. Indeed, looking at standard QC metrics we can observe that the samples do not contain empty spots.; We proceed to normalize Visium counts data with the built-in normalize_total method from Scanpy, and detect highly-variable genes (for later). As discussed previously, note that there are more sensible alternatives for normalization (see discussion in sc-tutorial paper and more recent alternatives such as SCTransform or GLM-PCA). for adata in [; adata_spatial_anterior,; adata_spatial_posterior,; ]:; sc.pp.normalize_total(adata, inplace=True); sc.pp.log1p(adata); sc.pp.highly_variable_genes(adata, flavor=""seurat"", n_top_genes=2000, inplace=True). normalizing counts per cell; finished (0:00:00); extracting highly variable genes; finished (0:00:00); --> added; 'highly_variable', boolean vector (adata.var); 'means', float vector (adata.var); 'dispersions', float vector (adata.var); 'dispersions_norm', float vector (adata.var); normalizing counts per cell; finished (0:00:00); extracting highly variable genes; finished (0:00:00); --> added; 'highly_variable', boolean vector (adata.var); 'means', float vector (adata.var); 'dispersions', float vector (adata.var)",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html:14881,variab,variable,14881,en/stable/tutorials/spatial/integration-scanorama.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html,2,['variab'],['variable']
Modifiability,"s; References. .rst. .pdf. scanpy.pp.calculate_qc_metrics. Contents . calculate_qc_metrics(). scanpy.pp.calculate_qc_metrics#. scanpy.pp.calculate_qc_metrics(adata, *, expr_type='counts', var_type='genes', qc_vars=(), percent_top=(50, 100, 200, 500), layer=None, use_raw=False, inplace=False, log1p=True, parallel=None)[source]#; Calculate quality control metrics.; Calculates a number of qc metrics for an AnnData object, see section; Returns for specifics. Largely based on calculateQCMetrics from scater; [McCarthy et al., 2017]. Currently is most efficient on a sparse CSR or dense matrix.; Note that this method can take a while to compile on the first call. That; result is then cached to disk to be used later. Parameters:. adata AnnDataAnnotated data matrix. expr_type str (default: 'counts')Name of kind of values in X. var_type str (default: 'genes')The kind of thing the variables are. qc_vars Collection[str] | str (default: ())Keys for boolean columns of .var which identify variables you could; want to control for (e.g. “ERCC” or “mito”). percent_top Collection[int] | None (default: (50, 100, 200, 500))List of ranks (where genes are ranked by expression) at which the cumulative; proportion of expression will be reported as a percentage. This can be used to; assess library complexity. Ranks are considered 1-indexed, and if empty or None; don’t calculate.; E.g. percent_top=[50] finds cumulative proportion to the 50th most expressed gene. layer str | None (default: None)If provided, use adata.layers[layer] for expression values instead; of adata.X. use_raw bool (default: False)If True, use adata.raw.X for expression values instead of adata.X. inplace bool (default: False)Whether to place calculated metrics in adata’s .obs and .var. log1p bool (default: True)Set to False to skip computing log1p transformed annotations. Return type:; tuple[DataFrame, DataFrame] | None. Returns:; Depending on inplace returns calculated metrics; (as DataFrame) or updates adata’s obs and var.",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.calculate_qc_metrics.html:10200,variab,variables,10200,en/stable/generated/scanpy.pp.calculate_qc_metrics.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.calculate_qc_metrics.html,1,['variab'],['variables']
Modifiability,"scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.experimental.pp.normalize_pearson_residuals_pca. Contents . normalize_pearson_residuals_pca(). scanpy.experimental.pp.normalize_pearson_residuals_pca#. scanpy.experimental.pp.normalize_pearson_residuals_pca(adata, *, theta=100, clip=None, n_comps=50, random_state=0, kwargs_pca=mappingproxy({}), mask_var=_empty, use_highly_variable=None, check_values=True, inplace=True)[source]#; Applies analytic Pearson residual normalization and PCA, based on Lause et al. [2021].; The residuals are based on a negative binomial offset model with overdispersion; theta shared across genes. By default, residuals are clipped to sqrt(n_obs),; overdispersion theta=100 is used, and PCA is run with 50 components.; Operates on the subset of highly variable genes in adata.var['highly_variable']; by default. Expects raw count input. Parameters:. adata AnnDataThe annotated data matrix of shape n_obs × n_vars.; Rows correspond to cells and columns to genes. theta float (default: 100)The negative binomial overdispersion parameter theta for Pearson residuals.; Higher values correspond to less overdispersion (var = mean + mean^2/theta), and theta=np.inf corresponds to a Poisson model. clip float | None (default: None)Determines if and how residuals are clipped:. If None, residuals are clipped to the interval [-sqrt(n_obs), sqrt(n_obs)], where n_obs is the number of cells in the dataset (default behavior).; If any scalar c, residuals are clipped to the interval [-c, c]. Set clip=np.inf for no clipping. n_comps int | None (default: 50)Number of principal components to compute in the PCA step. random_state float (default: 0)Random seed for setting the initial states for the optimization in the PCA step. kwargs_pca Mapping[str, Any] (",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.normalize_pearson_residuals_pca.html:10002,variab,variable,10002,en/stable/generated/scanpy.experimental.pp.normalize_pearson_residuals_pca.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.normalize_pearson_residuals_pca.html,1,['variab'],['variable']
Modifiability,"scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .md. .pdf. Usage Principles. Contents . Workflow; AnnData. Usage Principles#; Import Scanpy as:; import scanpy as sc. Workflow#; The typical workflow consists of subsequent calls of data analysis tools; in sc.tl, e.g.:; sc.tl.umap(adata, **tool_params) # embed a neighborhood graph of the data using UMAP. where adata is an AnnData object.; Each of these calls adds annotation to an expression matrix X,; which stores n_obs observations (cells) of n_vars variables (genes).; For each tool, there typically is an associated plotting function in sc.pl:; sc.pl.umap(adata, **plotting_params). If you pass show=False, a Axes instance is returned; and you have all of matplotlib’s detailed configuration possibilities.; To facilitate writing memory-efficient pipelines, by default,; Scanpy tools operate inplace on adata and return None –; this also allows to easily transition to out-of-memory pipelines.; If you want to return a copy of the AnnData object; and leave the passed adata unchanged, pass copy=True or inplace=False. AnnData#; Scanpy is based on anndata, which provides the AnnData class. At the most basic level, an AnnData object adata stores; a data matrix adata.X, annotation of observations; adata.obs and variables adata.var as pd.DataFrame and unstructured; annotation adata.uns as dict. Names of observations and; variables can be accessed via adata.obs_names and adata.var_names,; respecti",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/usage-principles.html:9668,variab,variables,9668,en/stable/usage-principles.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/usage-principles.html,1,['variab'],['variables']
Modifiability,"scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.pl.DotPlot.legend. Contents . DotPlot.legend(). scanpy.pl.DotPlot.legend#. DotPlot.legend(*, show=True, show_size_legend=True, show_colorbar=True, size_title='Fraction of cells\\nin group (%)', colorbar_title='Mean expression\\nin group', width=1.5)[source]#; Configures dot size and the colorbar legends. Parameters:. show bool | None (default: True)Set to False to hide the default plot of the legends. This sets the; legend width to zero, which will result in a wider main plot. show_size_legend bool | None (default: True)Set to False to hide the dot size legend. show_colorbar bool | None (default: True)Set to False to hide the colorbar legend. size_title str | None (default: 'Fraction of cells\\nin group (%)')Title for the dot size legend. Use ‘n’ to add line breaks. Appears on top; of dot sizes. colorbar_title str | None (default: 'Mean expression\\nin group')Title for the color bar. Use ‘n’ to add line breaks. Appears on top of the; color bar. width float | None (default: 1.5)Width of the legends area. The unit is the same as in matplotlib (inches). Return type:; Self. Returns:; DotPlot. Examples; Set color bar title:; >>> import scanpy as sc; >>> adata = sc.datasets.pbmc68k_reduced(); >>> markers = {'T-cell': 'CD3D', 'B-cell': 'CD79A', 'myeloid': 'CST3'}",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.legend.html:9500,Config,Configures,9500,en/stable/api/generated/classes/scanpy.pl.DotPlot.legend.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.legend.html,1,['Config'],['Configures']
Modifiability,"scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.pp.regress_out. Contents . regress_out(). scanpy.pp.regress_out#. scanpy.pp.regress_out(adata, keys, *, layer=None, n_jobs=None, copy=False)[source]#; Regress out (mostly) unwanted sources of variation.; Uses simple linear regression. This is inspired by Seurat’s regressOut; function in R [Satija et al., 2015]. Note that this function tends to overcorrect; in certain circumstances as described in issue526. Parameters:. adata AnnDataThe annotated data matrix. keys str | Sequence[str]Keys for observation annotation on which to regress on. layer str | None (default: None)If provided, which element of layers to regress on. n_jobs int | None (default: None)Number of jobs for parallel computation.; None means using scanpy._settings.ScanpyConfig.n_jobs. copy bool (default: False)Determines whether a copy of adata is returned. Return type:; AnnData | None. Returns:; Returns None if copy=False, else returns an updated AnnData object. Sets the following fields:. adata.X | adata.layers[layer]numpy.ndarray | scipy.sparse._csr.csr_matrix (dtype float)Corrected count data matrix. previous; scanpy.pp.normalize_total. next; scanpy.pp.scale. Contents; . regress_out(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.regress_out.html:9842,layers,layers,9842,en/stable/generated/scanpy.pp.regress_out.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.regress_out.html,2,['layers'],['layers']
Modifiability,"scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.pl.dpt_groups_pseudotime. Contents . dpt_groups_pseudotime(). scanpy.pl.dpt_groups_pseudotime#. scanpy.pl.dpt_groups_pseudotime(adata, *, color_map=None, palette=None, show=None, save=None, marker='.')[source]#; Plot groups and pseudotime. Parameters:. adata AnnDataAnnotated data matrix. color_map str | Colormap | None (default: None)Color map to use for continous variables. Can be a name or a; Colormap instance (e.g. ""magma”, ""viridis""; or mpl.cm.cividis), see get_cmap().; If None, the value of mpl.rcParams[""image.cmap""] is used.; The default color_map can be set using set_figure_params(). palette Sequence[str] | Cycler | None (default: None)Colors to use for plotting categorical annotation groups.; The palette can be a valid ListedColormap name; ('Set2', 'tab20', …), a Cycler object, a dict mapping; categories to colors, or a sequence of colors. Colors must be valid to; matplotlib. (see is_color_like()).; If None, mpl.rcParams[""axes.prop_cycle""] is used unless the categorical; variable already has colors stored in adata.uns[""{var}_colors""].; If provided, values of adata.uns[""{var}_colors""] will be set. show bool | None (default: None)Show the plot, do not return axis. save bool | str | None (default: None)If True or a str, save the figure.; A string is appended to the default filename.; Infer the filetype if e",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pl.dpt_groups_pseudotime.html:9614,variab,variables,9614,en/stable/api/generated/scanpy.pl.dpt_groups_pseudotime.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pl.dpt_groups_pseudotime.html,1,['variab'],['variables']
Modifiability,"scanpy.metrics.gearys_c(adata, *, vals=None, use_graph=None, layer=None, obsm=None, obsp=None, use_raw=False)[source]#; Calculate Geary’s C, as used; by VISION.; Geary’s C is a measure of autocorrelation for some measure on a graph. This; can be to whether measures are correlated between neighboring cells. Lower; values indicate greater correlation. \[C =; \frac{; (N - 1)\sum_{i,j} w_{i,j} (x_i - x_j)^2; }{; 2W \sum_i (x_i - \bar{x})^2; }\]. Parameters:. adata AnnData. vals ndarray | spmatrix | None (default: None)Values to calculate Geary’s C for. If this is two dimensional, should; be of shape (n_features, n_cells). Otherwise should be of shape; (n_cells,). This matrix can be selected from elements of the anndata; object by using key word arguments: layer, obsm, obsp, or; use_raw. use_graph str | None (default: None)Key to use for graph in anndata object. If not provided, default; neighbors connectivities will be used instead. layer str | None (default: None)Key for adata.layers to choose vals. obsm str | None (default: None)Key for adata.obsm to choose vals. obsp str | None (default: None)Key for adata.obsp to choose vals. use_raw bool (default: False)Whether to use adata.raw.X for vals. This function can also be called on the graph and values directly. In this case; the signature looks like:. Parameters:. gThe graph. valsThe values. See the examples for more info. Return type:; ndarray | float. Returns:; If vals is two dimensional, returns a 1 dimensional ndarray array. Returns; a scalar if vals is 1d. Examples; Calculate Geary’s C for each components of a dimensionality reduction:; import scanpy as sc, numpy as np. pbmc = sc.datasets.pbmc68k_processed(); pc_c = sc.metrics.gearys_c(pbmc, obsm=""X_pca""). It’s equivalent to call the function directly on the underlying arrays:; alt = sc.metrics.gearys_c(pbmc.obsp[""connectivities""], pbmc.obsm[""X_pca""].T); np.testing.assert_array_equal(pc_c, alt). previous; scanpy.metrics.confusion_matrix. next; scanpy.metrics.morans_",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.metrics.gearys_c.html:10295,layers,layers,10295,en/stable/generated/scanpy.metrics.gearys_c.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.metrics.gearys_c.html,1,['layers'],['layers']
Modifiability,"served UMI counts are compared to the expected counts of a “null model”. This model includes only technical factors, but no biological differences between cells. We then only keep the deviations from this model, the residuals, as representation of the data.; This implicitly performs normalization by sequencing depth and variance stabilization: As the null model expects the technical sources of variance, they are removed from the data. In contrast, biological variance is preserved: The null model is designed not to predict biological differences between cells. As a result, it will deviate from the observed counts starkly whenever genes differ in their expression between subpopulations – and produce large residuals in return. This will even work for genes that mark only small subpopulations. An example of detecting a rare subpopulation consisting of just 50 cells with Pearson residuals is presented in Lause et al. (2021).; As a result, the transformed data will show less technical variability, and biological signals from variable genes will be amplified. Therefore, downstream processing like PCA will be dominated by biological rather then technical variances. This is why it makes sense to use Pearson residuals as basis for downstream processing.; After reducing the dataset to the most variable genes in the previous steps, we will now transform our raw counts to residuals by calling normalize_pearson_residuals(adata). In our example pipeline, we then apply PCA to reduce the dataset to the most relevant dimensions. We visualize this reduced representation with t-SNE and perform Leiden clustering, which is again taken from the PBMC3k tutorial.; This is just one of many possible pipelines: After PCA, you could also use UMAP or other embeddings to inspect the data, and cluster the data with a different algorithm than Leiden. Preparations#; Because we will transform the raw data in adata.X to residuals in the next step, we first save a copy of the raw counts to adata.layers[",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:23044,variab,variability,23044,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,4,['variab'],"['variability', 'variable']"
Modifiability,"sge. Deprecated functions; scanpy.pp.filter_genes_dispersion; scanpy.pp.normalize_per_cell. External API; Preprocessing: PP; scanpy.external.pp.bbknn; scanpy.external.pp.harmony_integrate; scanpy.external.pp.mnn_correct; scanpy.external.pp.scanorama_integrate; scanpy.external.pp.hashsolo; scanpy.external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .md. .pdf. Contributing code. Contents . Development workflow; Code style. Contributing code#. Development workflow#. Fork the Scanpy repository to your own GitHub account; Create a development environment; Create a new branch for your PR; Add your feature or bugfix to the codebase; Make sure all tests are passing; Build and visually check any changed documentation; Open a PR back to the main repository. Code style#; Code contributions will be formatted and style checked using Ruff.; Ignored checks are configured in the tool.ruff.lint section of pyproject.toml.; To learn how to ignore checks per line please read about ignoring errors.; Additionally, we use Scanpy’s EditorConfig,; so using an editor/IDE with support for both is helpful. previous; Contributing. next; Getting set up. Contents; . Development workflow; Code style. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/dev/code.html:9722,config,configured,9722,en/stable/dev/code.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/dev/code.html,1,['config'],['configured']
Modifiability,"shsolo; scanpy.external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.pl.MatrixPlot.legend. Contents . MatrixPlot.legend(). scanpy.pl.MatrixPlot.legend#. MatrixPlot.legend(*, show=True, title='Expression\\nlevel in group', width=1.5)[source]#; Configure legend parameters. Parameters:. show bool | None (default: True)Set to ‘False’ to hide the default plot of the legend. This sets the; legend width to zero which will result in a wider main plot. title str | None (default: 'Expression\\nlevel in group')Legend title. Appears on top of the color bar. Use ‘\n’ to add line breaks. width float | None (default: 1.5)Width of the legend. The unit is the same as in matplotlib (inches). Return type:; Self. Returns:; Returns self for method chaining. Examples; Set legend title:; >>> import scanpy as sc; >>> adata = sc.datasets.pbmc68k_reduced(); >>> markers = {'T-cell': 'CD3D', 'B-cell': 'CD79A', 'myeloid': 'CST3'}; >>> dp = sc.pl._baseplot_class.BasePlot(adata, markers, groupby='bulk_labels') \; ... .legend(title='log(UMI counts + 1)'); >>> dp.color_legend_title; 'log(UMI counts + 1)'. previous; scanpy.pl.MatrixPlot.getdoc. next; scanpy.pl.MatrixPlot.make_figure. Contents; . MatrixPlot.legend(). By Scanpy development team. ; © Copyright 2024, t",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.MatrixPlot.legend.html:9417,Config,Configure,9417,en/stable/api/generated/classes/scanpy.pl.MatrixPlot.legend.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.MatrixPlot.legend.html,1,['Config'],['Configure']
Modifiability,"ssion fractions with dot_min are plotted with this size. largest_dot float | None (default: 200.0)If none, the largest dot has size 200.; All expression fractions with dot_max are plotted with this size. dot_edge_color Union[str, tuple[float, ...], None] (default: 'black')Dot edge color. When color_on='dot' the default is no edge. When; color_on='square', edge color is white for darker colors and black; for lighter background square colors. dot_edge_lw float | None (default: 0.2)Dot edge line width. When color_on='dot' the default is no edge. When; color_on='square', line width = 1.5. size_exponent float | None (default: 1.5)Dot size is computed as:; fraction ** size exponent and afterwards scaled to match the; smallest_dot and largest_dot size parameters.; Using a different size exponent changes the relative sizes of the dots; to each other. grid float | None (default: False)Set to true to show grid lines. By default grid lines are not shown.; Further configuration of the grid lines can be achieved directly on the; returned ax. x_padding float | None (default: 0.8)Space between the plot left/right borders and the dots center. A unit; is the distance between the x ticks. Only applied when color_on = dot. y_padding float | None (default: 1.0)Space between the plot top/bottom borders and the dots center. A unit is; the distance between the y ticks. Only applied when color_on = dot. Return type:; Self. Returns:; DotPlot. Examples; >>> import scanpy as sc; >>> adata = sc.datasets.pbmc68k_reduced(); >>> markers = ['C1QA', 'PSAP', 'CD79A', 'CD79B', 'CST3', 'LYZ']. Change color map and apply it to the square behind the dot; >>> sc.pl.DotPlot(adata, markers, groupby='bulk_labels') \; ... .style(cmap='RdBu_r', color_on='square').show(). Add edge to dots and plot a grid; >>> sc.pl.DotPlot(adata, markers, groupby='bulk_labels') \; ... .style(dot_edge_color='black', dot_edge_lw=1, grid=True) \; ... .show(). previous; scanpy.pl.DotPlot.show. next; scanpy.pl.DotPlot.swap_axes. Con",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.style.html:11429,config,configuration,11429,en/stable/api/generated/classes/scanpy.pl.DotPlot.style.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.style.html,2,['config'],['configuration']
Modifiability,"str | None (default: None)Title for the figure. stripplotAdd a stripplot on top of the violin plot.; See stripplot(). jitterAdd jitter to the stripplot (only when stripplot is True); See stripplot(). sizeSize of the jitter points. orderOrder in which to show the categories. Note: if dendrogram=True; the categories order will be given by the dendrogram and order; will be ignored. density_normThe method used to scale the width of each violin.; If ‘width’ (the default), each violin will have the same width.; If ‘area’, each violin will have the same area.; If ‘count’, a violin’s width corresponds to the number of observations. row_paletteThe row palette determines the colors to use for the stacked violins.; The value should be a valid seaborn or matplotlib palette name; (see color_palette()).; Alternatively, a single color name or hex value can be passed,; e.g. 'red' or '#cc33ff'. standard_scale Optional[Literal['var', 'group']] (default: None)Whether or not to standardize a dimension between 0 and 1,; meaning for each variable or observation,; subtract the minimum and divide each by its maximum. swap_axesBy default, the x axis contains var_names (e.g. genes) and the y axis; the groupby categories. By setting swap_axes then x are the groupby; categories and y the var_names. When swapping; axes var_group_positions are no longer used. kwdsAre passed to violinplot(). See also. stacked_violin()simpler way to call StackedViolin but with less options. violin()to plot marker genes identified using rank_genes_groups(). Examples; >>> import scanpy as sc; >>> adata = sc.datasets.pbmc68k_reduced(); >>> markers = ['C1QA', 'PSAP', 'CD79A', 'CD79B', 'CST3', 'LYZ']; >>> sc.pl.StackedViolin(adata, markers, groupby='bulk_labels', dendrogram=True) ; <scanpy.plotting._stacked_violin.StackedViolin object at 0x...>. Using var_names as dict:; >>> markers = {'T-cell': 'CD3D', 'B-cell': 'CD79A', 'myeloid': 'CST3'}; >>> sc.pl.StackedViolin(adata, markers, groupby='bulk_labels', dendrogram=True",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.html:13730,variab,variable,13730,en/stable/api/generated/classes/scanpy.pl.StackedViolin.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.html,2,['variab'],['variable']
Modifiability,"t up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.pl.paga_path. Contents . paga_path(). scanpy.pl.paga_path#. scanpy.pl.paga_path(adata, nodes, keys, *, use_raw=True, annotations=('dpt_pseudotime',), color_map=None, color_maps_annotations=mappingproxy({'dpt_pseudotime': 'Greys'}), palette_groups=None, n_avg=1, groups_key=None, xlim=(None, None), title=None, left_margin=None, ytick_fontsize=None, title_fontsize=None, show_node_names=True, show_yticks=True, show_colorbar=True, legend_fontsize=None, legend_fontweight=None, normalize_to_zero_one=False, as_heatmap=True, return_data=False, show=None, save=None, ax=None)[source]#; Gene expression and annotation changes along paths in the abstracted graph. Parameters:. adata AnnDataAn annotated data matrix. nodes Sequence[str | int]A path through nodes of the abstracted graph, that is, names or indices; (within .categories) of groups that have been used to run PAGA. keys Sequence[str]Either variables in adata.var_names or annotations in; adata.obs. They are plotted using color_map. use_raw bool (default: True)Use adata.raw for retrieving gene expressions if it has been set. annotations Sequence[str] (default: ('dpt_pseudotime',))Plot these keys with color_maps_annotations. Need to be keys for; adata.obs. color_map str | Colormap | None (default: None)Matplotlib colormap. color_maps_annotations Mapping[str, str | Colormap] (default: mappingproxy({'dpt_pseudotime': 'Greys'}))Color maps for plotting the annotations. Keys of the dictionary must; appear in annotations. palette_groups Sequence[str] | None (default: None)Ususally, use the same sc.pl.palettes... as used for coloring the; abstracted graph. n_avg int (default: 1)Number of data points to include in computation of running average. groups_key str | None (default: None)Key of the grouping used to run PAGA. If None, defaults to; adata.uns['paga']['groups']. as_heatmap bool (default: True)Plot the timeseries as heatma",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pl.paga_path.html:10132,variab,variables,10132,en/stable/api/generated/scanpy.pl.paga_path.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pl.paga_path.html,1,['variab'],['variables']
Modifiability,"t. Additionally, variables are no longer repeated if the anndata has less than 30 variables pr2075 Yves33; Dask arrays now work with scanpy.pp.normalize_total() pr1663 G Buckley, I Virshup; embedding_density() now allows more than 10 groups pr1936 A Wolf; Embedding plots can now pass colorbar_loc to specify the location of colorbar legend, or pass None to not show a colorbar pr1821 A Schaar I Virshup; Embedding plots now have a dimensions argument, which lets users select which dimensions of their embedding to plot and uses the same broadcasting rules as other arguments pr1538 I Virshup; print_versions() now uses session_info pr2089 P Angerer I Virshup. Ecosystem#; Multiple packages have been added to our ecosystem page, including:. decoupler a for footprint analysis and pathway enrichement pr2186 PB Mompel; dandelion for B-cell receptor analysis pr1953 Z Tuong; CIARA a feature selection tools for identifying rare cell types pr2175 M Stock. Bug fixes#. Fixed finding variables with use_raw=True and basis=None in scanpy.pl.scatter() pr2027 E Rice; Fixed scanpy.pp.scrublet() to address issue1957 FlMai and ensure raw counts are used for simulation; Functions in scanpy.datasets no longer throw OldFormatWarnings when using anndata 0.8 pr2096 I Virshup; Fixed use of scanpy.pp.neighbors() with method='rapids': RAPIDS cuML no longer returns a squared Euclidean distance matrix, so we should not square-root the kNN distance matrix. pr1828 M Zaslavsky; Removed pytables dependency by implementing read_10x_h5 with h5py due to installation errors on Windows pr2064; Fixed bug in scanpy.external.pp.hashsolo() where default value was set improperly pr2190 B Reiz; Fixed bug in scanpy.pl.embedding() functions where an error could be raised when there were missing values and large numbers of categories pr2187 I Virshup. Version 1.8#. 1.8.2 2021-11-3#. Documentation#. Update conda installation instructions pr1974 L Heumos. Bug fixes#. Fix plotting after scanpy.tl.filter_rank_genes_groups",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:24263,variab,variables,24263,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,1,['variab'],['variables']
Modifiability,"t: 'right')Where to place the colorbar for continous variables. If None, no colorbar; is added. size float (default: 1.0)Point size. If None, is automatically computed as 120000 / n_cells.; Can be a sequence containing the size for each cell. The order should be; the same as in adata.obs. color_map Colormap | str | None (default: None)Color map to use for continous variables. Can be a name or a; Colormap instance (e.g. ""magma”, ""viridis""; or mpl.cm.cividis), see get_cmap().; If None, the value of mpl.rcParams[""image.cmap""] is used.; The default color_map can be set using set_figure_params(). palette str | Sequence[str] | Cycler | None (default: None)Colors to use for plotting categorical annotation groups.; The palette can be a valid ListedColormap name; ('Set2', 'tab20', …), a Cycler object, a dict mapping; categories to colors, or a sequence of colors. Colors must be valid to; matplotlib. (see is_color_like()).; If None, mpl.rcParams[""axes.prop_cycle""] is used unless the categorical; variable already has colors stored in adata.uns[""{var}_colors""].; If provided, values of adata.uns[""{var}_colors""] will be set. na_color Union[str, tuple[float, ...], None] (default: None)Color to use for null or masked values. Can be anything matplotlib accepts as a; color. Used for all points if color=None. na_in_legend bool (default: True)If there are missing values, whether they get an entry in the legend. Currently; only implemented for categorical legends. frameon bool | None (default: None)Draw a frame around the scatter plot. Defaults to value set in; set_figure_params(), defaults to True. title str | Sequence[str] | None (default: None)Provide title for panels either as string or list of strings,; e.g. ['title1', 'title2', ...]. vmin Union[str, float, Callable[[Sequence[float]], float], Sequence[Union[str, float, Callable[[Sequence[float]], float]]], None] (default: None)The value representing the lower limit of the color scale. Values smaller than vmin are plotted; with the s",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pl.spatial.html:16128,variab,variable,16128,en/stable/api/generated/scanpy.pl.spatial.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pl.spatial.html,1,['variab'],['variable']
Modifiability,"ta. To perform RAM-efficient gene selection, use highly_variable_genes(adata,flavor='pearson_residuals') with the chunksize argument: This will still use Pearson residual variance to identify variable genes, but won’t compute all residuals at once. Reduce the chunksize as needed if you run into RAM issues during gene selection. Note that a very small chunksize will slow down the computation, so try to set it as large as possible with your resources.; As an example, we used chunksize=1000 when processing a dataset with 2 million cells in a machine with 500 GB RAM. For smaller machines, we would recommend to reduce this below 100. Wrapper functions for Pearson residuals preprocessing#; The scanpy.experimental.pp module also ships two wrappers that run multiple pre-processing steps at once:. sc.experimental.pp.normalize_pearson_residuals_pca() performs normalization by Pearson residuals and PCA in one go. This function is helpful to quickly obtain a Pearson residual-based data representation when highly variable genes are already defined, as only those are used by default.; sc.experimental.pp.recipe_pearson_residuals() performs gene selection and normalization by Pearson residuals, and PCA on top. This is intended to make the full Pearson residual preprocessing available in one step. All hyperparameters of the individual steps can still be controlled using the wrapper functions’ arguments. See the documentation for details. References / See also#; Hafemeister & Satija (2019), Normalization and variance stabilization of single-cell RNA-seq data using regularized negative binomial regression, Genome Biology; Lause et al. (2021), Analytic Pearson residuals for normalization of single-cell RNA-seq UMI data, Genome Biology; Wagner (2021), Normalization methods for single-cell RNA-Seq data, Youtube; Choudhary & Satija (2022), Comparison and evaluation of statistical error models for scRNA-seq, Genome Biology. previous; Experimental. next; Using dask with Scanpy. Contents; . B",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:30176,variab,variable,30176,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,2,['variab'],['variable']
Modifiability,"ta=np.array([]); ). %%time; sc.pp.pca(adata, layer=""dense""). CPU times: user 9.31 s, sys: 1.19 s, total: 10.5 s; Wall time: 1min 27s. While most of the PCA computation runs immediately, the last step (computing the observation loadings) is lazy, so must be triggered manually to avoid recomputation. %%time; adata.obsm[""X_pca""] = adata.obsm[""X_pca""].compute(). CPU times: user 6.72 s, sys: 1.36 s, total: 8.08 s; Wall time: 1min 15s. adata. AnnData object with n_obs × n_vars = 1462702 × 27714; obs: 'celltype', 'majorType', 'City', 'sampleID', 'donor_id', 'Sample type', 'CoVID-19 severity', 'Sample time', 'Sampling day (Days after symptom onset)', 'BCR single cell sequencing', 'TCR single cell sequencing', 'Outcome', 'Comorbidities', 'COVID-19-related medication and anti-microbials', 'Leukocytes [G over L]', 'Neutrophils [G over L]', 'Lymphocytes [G over L]', 'Unpublished', 'disease_ontology_term_id', 'cell_type_ontology_term_id', 'tissue_ontology_term_id', 'development_stage_ontology_term_id', 'self_reported_ethnicity_ontology_term_id', 'assay_ontology_term_id', 'sex_ontology_term_id', 'is_primary_data', 'organism_ontology_term_id', 'suspension_type', 'tissue_type', 'cell_type', 'assay', 'disease', 'organism', 'sex', 'tissue', 'self_reported_ethnicity', 'development_stage', 'observation_joinid'; var: 'feature_is_filtered', 'feature_name', 'feature_reference', 'feature_biotype', 'feature_length', 'highly_variable', 'means', 'dispersions', 'dispersions_norm'; uns: 'log1p', 'hvg', 'pca'; obsm: 'X_pca'; varm: 'PCs'; layers: 'counts', 'dense'. Now that we’ve computed our PCA let’s take a look at it:. sc.pl.pca(adata, color=""majorType""). Further support for dask is a work in progress. However, many operations past this point can work with the dimensionality reduction directly in memory. With scanpy 1.10 many of these operations can be accelerated to make working with large datasets significantly easier. For example:. Using alternative KNN backends for faster neighbor calculat",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/dask.html:17147,layers,layers,17147,en/stable/tutorials/experimental/dask.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/dask.html,2,['layers'],['layers']
Modifiability,"tem page, release notes, tutorials overhaul pr960 pr966 A Wolf. Warning. changed default solver in pca() from auto to arpack; changed default use_raw in score_genes() from False to None. 1.4.4 2019-07-20#. New functionality#. scanpy.get adds helper functions for extracting data in convenient formats pr619 I Virshup. Bug fixes#. Stopped deprecations warnings from AnnData 0.6.22 I Virshup. Code design#. normalize_total() gains param exclude_highly_expressed, and fraction is renamed to max_fraction with better docs A Wolf. 1.4.3 2019-05-14#. Bug fixes#. neighbors() correctly infers n_neighbors again from params, which was temporarily broken in v1.4.2 I Virshup. Code design#. calculate_qc_metrics() is single threaded by default for datasets under 300,000 cells – allowing cached compilation pr615 I Virshup. 1.4.2 2019-05-06#. New functionality#. combat() supports additional covariates which may include adjustment variables or biological condition pr618 G Eraslan; highly_variable_genes() has a batch_key option which performs HVG selection in each batch separately to avoid selecting genes that vary strongly across batches pr622 G Eraslan. Bug fixes#. rank_genes_groups() t-test implementation doesn’t return NaN when variance is 0, also changed to scipy’s implementation pr621 I Virshup; umap() with init_pos='paga' detects correct dtype A Wolf; louvain() and leiden() auto-generate key_added=louvain_R upon passing restrict_to, which was temporarily changed in 1.4.1 A Wolf. Code design#. neighbors() and umap() got rid of UMAP legacy code and introduced UMAP as a dependency pr576 S Rybakov. 1.4.1 2019-04-26#. New functionality#. Scanpy has a command line interface again. Invoking it with scanpy somecommand [args] calls scanpy-somecommand [args], except for builtin commands (currently scanpy settings) pr604 P Angerer; ebi_expression_atlas() allows convenient download of EBI expression atlas I Virshup; marker_gene_overlap() computes overlaps of marker genes M Luecken; filter_rank_g",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:42312,variab,variables,42312,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,1,['variab'],['variables']
Modifiability,"tem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .md. .pdf. Preprocessing: pp. Contents . Basic Preprocessing; Recipes; Batch effect correction; Doublet detection; Neighbors. Preprocessing: pp#; Filtering of highly-variable genes, batch-effect correction, per-cell normalization, preprocessing recipes.; Any transformation of the data matrix that is not a tool. Other than tools, preprocessing steps usually don’t return an easily interpretable annotation, but perform a basic transformation on the data matrix. Basic Preprocessing#; For visual quality control, see highest_expr_genes() and; filter_genes_dispersion() in scanpy.pl. pp.calculate_qc_metrics; Calculate quality control metrics. pp.filter_cells; Filter cell outliers based on counts and numbers of genes expressed. pp.filter_genes; Filter genes based on number of cells or counts. pp.highly_variable_genes; Annotate highly variable genes [Satija et al., 2015, Stuart et al., 2019, Zheng et al., 2017]. pp.log1p; Logarithmize the data matrix. pp.pca; Principal component analysis [Pedregosa et al., 2011]. pp.normalize_total; Normalize counts per cell. pp.regress_out; Regress out (mostly) unwanted sources of variation. pp.scale; Scale data to unit variance and zero mean. pp.subsample; Subsample to a fraction of the number of observations. pp.downsample_counts; Downsample counts from count matrix. Recipes#. pp.recipe_zheng17; Normalization and filtering as of Zheng et al. [2017]. pp.recipe_weinreb17; Normalization and filtering as of [Weinreb et al., 2017]. pp.recipe_seurat; Normalization and filtering as of Seurat [Satija et al., 2015]. Batch effect correction#; Also see [Data integration]. Note that a simple batch correction method is available via pp.regress_out(). Checkout scanpy.external for more. pp.combat; ComBat function for batch effect correction [Johnson et al., 2006, Leek et al., 2017, Pederse",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/preprocessing.html:10051,variab,variable,10051,en/stable/api/preprocessing.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/preprocessing.html,1,['variab'],['variable']
Modifiability,"tes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.pp.calculate_qc_metrics. Contents . calculate_qc_metrics(). scanpy.pp.calculate_qc_metrics#. scanpy.pp.calculate_qc_metrics(adata, *, expr_type='counts', var_type='genes', qc_vars=(), percent_top=(50, 100, 200, 500), layer=None, use_raw=False, inplace=False, log1p=True, parallel=None)[source]#; Calculate quality control metrics.; Calculates a number of qc metrics for an AnnData object, see section; Returns for specifics. Largely based on calculateQCMetrics from scater; [McCarthy et al., 2017]. Currently is most efficient on a sparse CSR or dense matrix.; Note that this method can take a while to compile on the first call. That; result is then cached to disk to be used later. Parameters:. adata AnnDataAnnotated data matrix. expr_type str (default: 'counts')Name of kind of values in X. var_type str (default: 'genes')The kind of thing the variables are. qc_vars Collection[str] | str (default: ())Keys for boolean columns of .var which identify variables you could; want to control for (e.g. “ERCC” or “mito”). percent_top Collection[int] | None (default: (50, 100, 200, 500))List of ranks (where genes are ranked by expression) at which the cumulative; proportion of expression will be reported as a percentage. This can be used to; assess library complexity. Ranks are considered 1-indexed, and if empty or None; don’t calculate.; E.g. percent_top=[50] finds cumulative proportion to the 50th most expressed gene. layer str | None (default: None)If provided, use adata.layers[layer] for expression values instead; of adata.X. use_raw bool (default: False)If True, use adata.raw.X for expression values instead of adata.X. inplace bool (default: False)Whether to place calculated metrics in adata’s .obs and .var. log1p bool (default: True)Set to False to skip computing log1p transformed annotations. Return type:; tu",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.calculate_qc_metrics.html:10094,variab,variables,10094,en/stable/generated/scanpy.pp.calculate_qc_metrics.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.calculate_qc_metrics.html,1,['variab'],['variables']
Modifiability,"th var_name and the tenth var_name.; By giving more positions, more brackets/color blocks are drawn. var_group_labels Sequence[str] | None (default: None)Labels for each of the var_group_positions that want to be highlighted. var_group_rotation float | None (default: None)Label rotation degrees.; By default, labels larger than 4 characters are rotated 90 degrees. layer str | None (default: None)Name of the AnnData object layer that wants to be plotted. By default adata.raw.X is plotted.; If use_raw=False is set, then adata.X is plotted. If layer is set to a valid layer name,; then the layer is plotted. layer takes precedence over use_raw. title str | None (default: None)Title for the figure. colorbar_title str | None (default: 'Mean expression\\nin group')Title for the color bar. New line character (n) can be used. cmap str (default: 'Reds')String denoting matplotlib color map. standard_scale Optional[Literal['var', 'group']] (default: None)Whether or not to standardize the given dimension between 0 and 1, meaning for; each variable or group, subtract the minimum and divide each by its maximum. swap_axes bool | None (default: False)By default, the x axis contains var_names (e.g. genes) and the y axis; the groupby categories. By setting swap_axes then x are the; groupby categories and y the var_names. return_fig bool | None (default: False)Returns DotPlot object. Useful for fine-tuning; the plot. Takes precedence over show=False. size_title str | None (default: 'Fraction of cells\\nin group (%)')Title for the size legend. New line character (n) can be used. expression_cutoff float (default: 0.0)Expression cutoff that is used for binarizing the gene expression and; determining the fraction of cells expressing given genes. A gene is; expressed only if the expression value is greater than this threshold. mean_only_expressed bool (default: False)If True, gene expression is averaged only over the cells; expressing the given genes. dot_max float | None (default: None)If non",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pl.dotplot.html:13939,variab,variable,13939,en/stable/generated/scanpy.pl.dotplot.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pl.dotplot.html,1,['variab'],['variable']
Modifiability,"the colorbar for continous variables. If None, no colorbar; is added. size float | Sequence[float] | None (default: None)Point size. If None, is automatically computed as 120000 / n_cells.; Can be a sequence containing the size for each cell. The order should be; the same as in adata.obs. color_map Colormap | str | None (default: None)Color map to use for continous variables. Can be a name or a; Colormap instance (e.g. ""magma”, ""viridis""; or mpl.cm.cividis), see get_cmap().; If None, the value of mpl.rcParams[""image.cmap""] is used.; The default color_map can be set using set_figure_params(). palette str | Sequence[str] | Cycler | None (default: None)Colors to use for plotting categorical annotation groups.; The palette can be a valid ListedColormap name; ('Set2', 'tab20', …), a Cycler object, a dict mapping; categories to colors, or a sequence of colors. Colors must be valid to; matplotlib. (see is_color_like()).; If None, mpl.rcParams[""axes.prop_cycle""] is used unless the categorical; variable already has colors stored in adata.uns[""{var}_colors""].; If provided, values of adata.uns[""{var}_colors""] will be set. na_color Union[str, tuple[float, ...]] (default: 'lightgray')Color to use for null or masked values. Can be anything matplotlib accepts as a; color. Used for all points if color=None. na_in_legend bool (default: True)If there are missing values, whether they get an entry in the legend. Currently; only implemented for categorical legends. frameon bool | None (default: None)Draw a frame around the scatter plot. Defaults to value set in; set_figure_params(), defaults to True. title str | Sequence[str] | None (default: None)Provide title for panels either as string or list of strings,; e.g. ['title1', 'title2', ...]. vmin Union[str, float, Callable[[Sequence[float]], float], Sequence[Union[str, float, Callable[[Sequence[float]], float]]], None] (default: None)The value representing the lower limit of the color scale. Values smaller than vmin are plotted; with the ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pl.phate.html:14578,variab,variable,14578,en/stable/generated/scanpy.external.pl.phate.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pl.phate.html,8,['variab'],['variable']
Modifiability,"ting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.external.pp.magic. Contents . magic(). scanpy.external.pp.magic#. scanpy.external.pp.magic(adata, name_list=None, *, knn=5, decay=1, knn_max=None, t=3, n_pca=100, solver='exact', knn_dist='euclidean', random_state=None, n_jobs=None, verbose=False, copy=None, **kwargs)[source]#; Markov Affinity-based Graph Imputation of Cells (MAGIC) API [van Dijk et al., 2018].; MAGIC is an algorithm for denoising and transcript recover of single cells; applied to single-cell sequencing data. MAGIC builds a graph from the data; and uses diffusion to smooth out noise and recover the data manifold.; The algorithm implemented here has changed primarily in two ways; compared to the algorithm described in van Dijk et al. [2018]. Firstly, we use; the adaptive kernel described in Moon et al. [2019] for; improved stability. Secondly, data diffusion is applied; in the PCA space, rather than the data space, for speed and; memory improvements.; More information and bug reports; here. For help, visit; <https://krishnaswamylab.org/get-help>. Parameters:. adata AnnDataAn anndata file with .raw attribute representing raw counts. name_list Union[Literal['all_genes', 'pca_only'], Sequence[str], None] (default: None)Denoised genes to return. The default 'all_genes'/None; may require a large amount of memory if the input data is sparse.; Another possibility is 'pca_only'. knn int (default: 5)number of nearest neighbors on which to build kernel. decay float | None (default: 1)sets decay rate of kernel tails.; If None, alpha decaying kernel is not used. knn_max int | None (default: None)maximum number of nearest neighbors with nonzero connection.; If None, will be set to 3 * knn. t Union[Literal['auto'], int] (default: 3)power to which the diffusion opera",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.magic.html:9978,adapt,adaptive,9978,en/stable/generated/scanpy.external.pp.magic.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.magic.html,1,['adapt'],['adaptive']
Modifiability,"tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .md. .pdf. Tools: TL. Contents . Embeddings; Clustering and trajectory inference; Gene scores, Cell cycle. Tools: TL#. Embeddings#. tl.phate(adata[, n_components, k, a, ...]); PHATE [Moon et al., 2019]. tl.palantir(adata, *[, n_components, knn, ...]); Run Diffusion maps using the adaptive anisotropic kernel [Setty et al., 2019]. tl.trimap(adata[, n_components, n_inliers, ...]); TriMap: Large-scale Dimensionality Reduction Using Triplets [Amid and Warmuth, 2019]. tl.sam(adata, *[, max_iter, num_norm_avg, ...]); Self-Assembling Manifolds single-cell RNA sequencing analysis tool [Tarashansky et al., 2019]. Clustering and trajectory inference#. tl.phenograph(data[, clustering_algo, k, ...]); PhenoGraph clustering [Levine et al., 2015]. tl.harmony_timeseries(adata, tp, *[, ...]); Harmony time series for data visualization with augmented affinity matrix at discrete time points [Nowotschin et al., 2019]. tl.wishbone(adata, start_cell, *[, branch, ...]); Wishbone identifies bifurcating developmental trajectories from single-cell data [Setty et al., 2016]. tl.palantir(adata, *[, n_components, knn, ...]); Run Diffusion maps using the adaptive anisotropic kernel [Setty et al., 2019]. tl.palantir_results(adata, early_cell, *[, ...]); Running Palantir. Gene scores, Cell cycle#.",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/tools.html:9487,adapt,adaptive,9487,en/stable/external/tools.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/tools.html,1,['adapt'],['adaptive']
Modifiability,"tl.umap(adata, **tool_params) # embed a neighborhood graph of the data using UMAP. where adata is an AnnData object.; Each of these calls adds annotation to an expression matrix X,; which stores n_obs observations (cells) of n_vars variables (genes).; For each tool, there typically is an associated plotting function in sc.pl:; sc.pl.umap(adata, **plotting_params). If you pass show=False, a Axes instance is returned; and you have all of matplotlib’s detailed configuration possibilities.; To facilitate writing memory-efficient pipelines, by default,; Scanpy tools operate inplace on adata and return None –; this also allows to easily transition to out-of-memory pipelines.; If you want to return a copy of the AnnData object; and leave the passed adata unchanged, pass copy=True or inplace=False. AnnData#; Scanpy is based on anndata, which provides the AnnData class. At the most basic level, an AnnData object adata stores; a data matrix adata.X, annotation of observations; adata.obs and variables adata.var as pd.DataFrame and unstructured; annotation adata.uns as dict. Names of observations and; variables can be accessed via adata.obs_names and adata.var_names,; respectively. AnnData objects can be sliced like; dataframes, for example, adata_subset = adata[:, list_of_gene_names].; For more, see this blog post.; To read a data file to an AnnData object, call:; adata = sc.read(filename). to initialize an AnnData object. Possibly add further annotation using, e.g., pd.read_csv:; import pandas as pd; anno = pd.read_csv(filename_sample_annotation); adata.obs['cell_groups'] = anno['cell_groups'] # categorical annotation of type pandas.Categorical; adata.obs['time'] = anno['time'] # numerical annotation of type float; # alternatively, you could also set the whole dataframe; # adata.obs = anno. To write, use:; adata.write(filename); adata.write_csvs(filename); adata.write_loom(filename). previous; Using dask with Scanpy. next; How to. Contents; . Workflow; AnnData. By Scanpy deve",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/usage-principles.html:10432,variab,variables,10432,en/stable/usage-principles.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/usage-principles.html,1,['variab'],['variables']
Modifiability,"to actually render the plot.; The order of add_* operation decides the order of plotters. But group_rows and group_cols can be called anytime. m = ma.Heatmap(exp, cmap=""viridis"", height=4, width=3); m.group_rows(pbmc.obs[""louvain""], order=uni_cells). m.add_left(; mp.Colors(list(pbmc.obs[""louvain""]), palette=cmapper),; size=0.1,; pad=0.1,; ); m.add_left(mp.Chunk(uni_cells, rotation=0, align=""center"")); m.add_top(mp.Labels(markers), pad=0.1); m.add_dendrogram(""right"", add_base=False). m.add_legends(); m.add_title(""Expression Profile""); m.render(). Now that we’ve covered some basics of Marsilea, we’ll see how it can be used to create custom plots similar to scanpy’s existing methods:. agg = sc.get.aggregate(pbmc[:, markers], by=""louvain"", func=[""mean"", ""count_nonzero""]); agg.obs[""cell_counts""] = pbmc.obs[""louvain""].value_counts(); agg. AnnData object with n_obs × n_vars = 8 × 12; obs: 'louvain', 'cell_counts'; var: 'n_cells'; layers: 'mean', 'count_nonzero'. agg_exp = agg.layers[""mean""]; agg_count = agg.layers[""count_nonzero""]; agg_cell_counts = agg.obs[""cell_counts""].to_numpy(). Matrixplot#. h, w = agg_exp.shape. m = ma.Heatmap(; agg_exp,; height=h / 3,; width=w / 3,; cmap=""Blues"",; linewidth=0.5,; linecolor=""lightgray"",; label=""Expression"",; ); m.add_right(mp.Labels(agg.obs[""louvain""], align=""center""), pad=0.1); m.add_top(mp.Labels(markers), pad=0.1); m.group_cols(cells, order=uni_cells); m.add_top(mp.Chunk(uni_cells, fill_colors=cell_colors, rotation=90)); m.add_left(mp.Numbers(agg_cell_counts, color=""#EEB76B"", label=""Count"")); m.add_dendrogram(""right"", pad=0.1); m.add_legends(); m.render(). Dot plot#. size = agg_count / agg_cell_counts[:, np.newaxis]; m = ma.SizedHeatmap(; size=size,; color=agg_exp,; cluster_data=size,; height=h / 3,; width=w / 3,; edgecolor=""lightgray"",; cmap=""Blues"",; size_legend_kws=dict(; colors=""#538bbf"",; title=""Fraction of cells\nin groups (%)"",; labels=[""20%"", ""40%"", ""60%"", ""80%"", ""100%""],; show_at=[0.2, 0.4, 0.6, 0.8, 1.0],; ),; color_lege",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/how-to/plotting-with-marsilea.html:13604,layers,layers,13604,en/stable/how-to/plotting-with-marsilea.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/how-to/plotting-with-marsilea.html,1,['layers'],['layers']
Modifiability,"toutlineLine width of the legend font outline in pt. Draws a white outline using; the path effect withStroke. colorbar_locWhere to place the colorbar for continous variables. If None, no colorbar; is added. sizePoint size. If None, is automatically computed as 120000 / n_cells.; Can be a sequence containing the size for each cell. The order should be; the same as in adata.obs. color_mapColor map to use for continous variables. Can be a name or a; Colormap instance (e.g. ""magma”, ""viridis""; or mpl.cm.cividis), see get_cmap().; If None, the value of mpl.rcParams[""image.cmap""] is used.; The default color_map can be set using set_figure_params(). paletteColors to use for plotting categorical annotation groups.; The palette can be a valid ListedColormap name; ('Set2', 'tab20', …), a Cycler object, a dict mapping; categories to colors, or a sequence of colors. Colors must be valid to; matplotlib. (see is_color_like()).; If None, mpl.rcParams[""axes.prop_cycle""] is used unless the categorical; variable already has colors stored in adata.uns[""{var}_colors""].; If provided, values of adata.uns[""{var}_colors""] will be set. na_colorColor to use for null or masked values. Can be anything matplotlib accepts as a; color. Used for all points if color=None. na_in_legendIf there are missing values, whether they get an entry in the legend. Currently; only implemented for categorical legends. frameonDraw a frame around the scatter plot. Defaults to value set in; set_figure_params(), defaults to True. titleProvide title for panels either as string or list of strings,; e.g. ['title1', 'title2', ...]. vminThe value representing the lower limit of the color scale. Values smaller than vmin are plotted; with the same color as vmin. vmin can be a number, a string, a function or None. If; vmin is a string and has the format pN, this is interpreted as a vmin=percentile(N).; For example vmin=’p1.5’ is interpreted as the 1.5 percentile. If vmin is function, then; vmin is interpreted as the return v",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pl.pca_overview.html:11732,variab,variable,11732,en/stable/api/generated/scanpy.pl.pca_overview.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pl.pca_overview.html,1,['variab'],['variable']
Modifiability,"trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.pl.dpt_groups_pseudotime. Contents . dpt_groups_pseudotime(). scanpy.pl.dpt_groups_pseudotime#. scanpy.pl.dpt_groups_pseudotime(adata, *, color_map=None, palette=None, show=None, save=None, marker='.')[source]#; Plot groups and pseudotime. Parameters:. adata AnnDataAnnotated data matrix. color_map str | Colormap | None (default: None)Color map to use for continous variables. Can be a name or a; Colormap instance (e.g. ""magma”, ""viridis""; or mpl.cm.cividis), see get_cmap().; If None, the value of mpl.rcParams[""image.cmap""] is used.; The default color_map can be set using set_figure_params(). palette Sequence[str] | Cycler | None (default: None)Colors to use for plotting categorical annotation groups.; The palette can be a valid ListedColormap name; ('Set2', 'tab20', …), a Cycler object, a dict mapping; categories to colors, or a sequence of colors. Colors must be valid to; matplotlib. (see is_color_like()).; If None, mpl.rcParams[""axes.prop_cycle""] is used unless the categorical; variable already has colors stored in adata.uns[""{var}_colors""].; If provided, values of adata.uns[""{var}_colors""] will be set. show bool | None (default: None)Show the plot, do not return axis. save bool | str | None (default: None)If True or a str, save the figure.; A string is appended to the default filename.; Infer the filetype if ending on {'.pdf', '.png', '.svg'}. marker str | Sequence[str] (default: '.')Marker style. See markers for details. previous; scanpy.pl.embedding_density. next; scanpy.pl.dpt_timeseries. Contents; . dpt_groups_pseudotime(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pl.dpt_groups_pseudotime.html:10241,variab,variable,10241,en/stable/api/generated/scanpy.pl.dpt_groups_pseudotime.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pl.dpt_groups_pseudotime.html,1,['variab'],['variable']
Modifiability,"trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.read_10x_h5. Contents . read_10x_h5(). scanpy.read_10x_h5#. scanpy.read_10x_h5(filename, *, genome=None, gex_only=True, backup_url=None)[source]#; Read 10x-Genomics-formatted hdf5 file. Parameters:. filename Path | strPath to a 10x hdf5 file. genome str | None (default: None)Filter expression to genes within this genome. For legacy 10x h5; files, this must be provided if the data contains more than one genome. gex_only bool (default: True)Only keep ‘Gene Expression’ data and ignore other feature types,; e.g. ‘Antibody Capture’, ‘CRISPR Guide Capture’, or ‘Custom’. backup_url str | None (default: None)Retrieve the file from an URL if not present on disk. Return type:; AnnData. Returns:; Annotated data matrix, where observations/cells are named by their; barcode and variables/genes by gene name. Stores the following information:. XThe data matrix is stored. obs_namesCell names. var_namesGene names for a feature barcode matrix, probe names for a probe bc matrix. var['gene_ids']Gene IDs. var['feature_types']Feature types. obs[filtered_barcodes]filtered barcodes if present in the matrix. varAny additional metadata present in /matrix/features is read in. previous; scanpy.read. next; scanpy.read_10x_mtx. Contents; . read_10x_h5(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.read_10x_h5.html:10009,variab,variables,10009,en/stable/generated/scanpy.read_10x_h5.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.read_10x_h5.html,1,['variab'],['variables']
Modifiability,"tter plot in spatial coordinates.; This function allows overlaying data on top of images.; Use the parameter img_key to see the image in the background; And the parameter library_id to select the image.; By default, 'hires' and 'lowres' are attempted.; Use crop_coord, alpha_img, and bw to control how it is displayed.; Use size to scale the size of the Visium spots plotted on top.; As this function is designed to for imaging data, there are two key assumptions; about how coordinates are handled:; 1. The origin (e.g (0, 0)) is at the top left – as is common convention; with image data.; 2. Coordinates are in the pixel space of the source image, so an equal; aspect ratio is assumed.; If your anndata object has a ""spatial"" entry in .uns, the img_key; and library_id parameters to find values for img, scale_factor,; and spot_size arguments. Alternatively, these values be passed directly. Parameters:. adata AnnDataAnnotated data matrix. color str | Sequence[str] | None (default: None)Keys for annotations of observations/cells or variables/genes, e.g.,; 'ann1' or ['ann1', 'ann2']. gene_symbols str | None (default: None)Column name in .var DataFrame that stores gene symbols. By default var_names; refer to the index column of the .var DataFrame. Setting this option allows; alternative names to be used. use_raw bool | None (default: None)Use .raw attribute of adata for coloring with gene expression. If None,; defaults to True if layer isn’t provided and adata.raw is present. layer str | None (default: None)Name of the AnnData object layer that wants to be plotted. By default; adata.raw.X is plotted. If use_raw=False is set, then adata.X is plotted.; If layer is set to a valid layer name, then the layer is plotted. layer; takes precedence over use_raw. library_id str | None | Empty (default: _empty)library_id for Visium data, e.g. key in adata.uns[""spatial""]. img_key str | None | Empty (default: _empty)Key for image data, used to get img and scale_factor from ""images""; and ""sca",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pl.spatial.html:11225,variab,variables,11225,en/stable/api/generated/scanpy.pl.spatial.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pl.spatial.html,1,['variab'],['variables']
Modifiability,"uations; this can enhance the aesthetics of the resulting image. outline_color tuple[str, str] (default: ('black', 'white'))Tuple with two valid color names used to adjust the add_outline. The first color is the; border color (default: black), while the second color is a gap color between the; border color and the scatter dot (default: white). outline_width tuple[float, float] (default: (0.3, 0.05))Tuple with two width numbers used to adjust the outline. The first value is the width; of the border color as a fraction of the scatter dot size (default: 0.3). The second value is; width of the gap color (default: 0.05). ncols int (default: 4)Number of panels per row. wspace float | None (default: None)Adjust the width of the space between multiple panels. hspace float (default: 0.25)Adjust the height of the space between multiple panels. return_fig bool | None (default: None)Return the matplotlib figure. kwargsArguments to pass to matplotlib.pyplot.scatter(),; for instance: the maximum and minimum values (e.g. vmin=-2, vmax=5). show bool | None (default: None)Show the plot, do not return axis. save bool | str | None (default: None)If True or a str, save the figure.; A string is appended to the default filename.; Infer the filetype if ending on {'.pdf', '.png', '.svg'}. ax Axes | None (default: None)A matplotlib axes object. Only works if plotting a single component. Return type:; Figure | Axes | list[Axes] | None. Returns:; If show==False a Axes or a list of it. Examples; import scanpy as sc; adata = sc.datasets.pbmc68k_reduced(); sc.pl.umap(adata). Colour points by discrete variable (Louvain clusters).; sc.pl.umap(adata, color=""louvain""). Colour points by gene expression.; sc.pl.umap(adata, color=""HES4""). Plot muliple umaps for different gene expressions.; sc.pl.umap(adata, color=[""HES4"", ""TNFRSF4""]). See also; tl.umap. previous; scanpy.pl.tsne. next; scanpy.pl.diffmap. Contents; . umap(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pl.umap.html:18537,variab,variable,18537,en/stable/api/generated/scanpy.pl.umap.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pl.umap.html,1,['variab'],['variable']
Modifiability,"ue, inplace=True)[source]#; Full pipeline for HVG selection and normalization by analytic Pearson residuals [Lause et al., 2021].; Applies gene selection based on Pearson residuals. On the resulting subset,; Pearson residual normalization and PCA are performed.; Expects raw count input. Parameters:. adata AnnDataThe annotated data matrix of shape n_obs × n_vars.; Rows correspond to cells and columns to genes. theta float (default: 100)The negative binomial overdispersion parameter theta for Pearson residuals.; Higher values correspond to less overdispersion (var = mean + mean^2/theta), and theta=np.inf corresponds to a Poisson model. clip float | None (default: None)Determines if and how residuals are clipped:. If None, residuals are clipped to the interval [-sqrt(n_obs), sqrt(n_obs)], where n_obs is the number of cells in the dataset (default behavior).; If any scalar c, residuals are clipped to the interval [-c, c]. Set clip=np.inf for no clipping. n_top_genes int (default: 1000)Number of highly-variable genes to keep. Mandatory if flavor='seurat_v3' or; flavor='pearson_residuals'. batch_key str | None (default: None)If specified, highly-variable genes are selected within each batch separately; and merged. This simple process avoids the selection of batch-specific genes; and acts as a lightweight batch correction method. Genes are first sorted by; how many batches they are a HVG. If flavor='pearson_residuals', ties are; broken by the median rank (across batches) based on within-batch residual; variance. chunksize int (default: 1000)If flavor='pearson_residuals', this dertermines how many genes are processed at; once while computing the residual variance. Choosing a smaller value will reduce; the required memory. n_comps int | None (default: 50)Number of principal components to compute in the PCA step. random_state float | None (default: 0)Random seed for setting the initial states for the optimization in the PCA step. kwargs_pca dict (default: {})Dictionary of fur",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.recipe_pearson_residuals.html:10595,variab,variable,10595,en/stable/generated/scanpy.experimental.pp.recipe_pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.recipe_pearson_residuals.html,1,['variab'],['variable']
Modifiability,"ult: True)If True, displays SAM log statements. Return type:; SAM | tuple[SAM, AnnData]. Returns:; sam_obj if inplace is True or (sam_obj,AnnData) otherwise. adata - AnnData; .var['weights']SAM weights for each gene. .var['spatial_dispersions']Spatial dispersions for each gene (these are used to compute the; SAM weights). .uns['sam']Dictionary of SAM-specific outputs, such as the parameters; used for preprocessing (‘preprocess_args’) and running; (‘run_args’) SAM. .uns['neighbors']A dictionary with key ‘connectivities’ containing the kNN adjacency; matrix output by SAM. If built-in scanpy dimensionality reduction; methods are to be used using the SAM-output AnnData, users; should recompute the neighbors using .obs['X_pca'] with; scanpy.pp.neighbors. .obsm['X_pca']The principal components output by SAM. .obsm['X_umap']The UMAP projection output by SAM. .layers['X_disp']The expression matrix used for nearest-neighbor averaging. .layers['X_knn_avg']The nearest-neighbor-averaged expression data used for computing the; spatial dispersions of genes. Example; >>> import scanpy.external as sce; >>> import scanpy as sc. * Running SAM *; Assuming we are given an AnnData object called adata, we can run the SAM; algorithm as follows:; >>> sam_obj = sce.tl.sam(adata,inplace=True). The input AnnData object should contain unstandardized, non-negative; expression values. Preferably, the data should be log-normalized and no; genes should be filtered out.; Please see the documentation for a description of all available parameters.; For more detailed tutorials, please visit the original Github repository:; atarashansky/self-assembling-manifold; * Plotting *; To visualize the output, we can use:; >>> sce.pl.sam(adata,projection='X_umap'). sce.pl.sam accepts all keyword arguments used in the; matplotlib.pyplot.scatter function.; * SAMGUI *; SAM comes with the SAMGUI module, a graphical-user interface written with; Plotly and ipythonwidgets for interactively exploring and annotating; the",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.sam.html:13701,layers,layers,13701,en/stable/external/generated/scanpy.external.tl.sam.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.sam.html,2,['layers'],['layers']
Modifiability,"unts for observations (cells); before normalization. exclude_highly_expressed bool (default: False)Exclude (very) highly expressed genes for the computation of the; normalization factor (size factor) for each cell. A gene is considered; highly expressed, if it has more than max_fraction of the total counts; in at least one cell. The not-excluded genes will sum up to; target_sum. Providing this argument when adata.X is a Array; will incur blocking .compute() calls on the array. max_fraction float (default: 0.05)If exclude_highly_expressed=True, consider cells as highly expressed; that have more counts than max_fraction of the original total counts; in at least one cell. key_added str | None (default: None)Name of the field in adata.obs where the normalization factor is; stored. layer str | None (default: None)Layer to normalize instead of X. If None, X is normalized. inplace bool (default: True)Whether to update adata or return dictionary with normalized copies of; adata.X and adata.layers. copy bool (default: False)Whether to modify copied input object. Not compatible with inplace=False. Return type:; AnnData | dict[str, ndarray] | None. Returns:; Returns dictionary with normalized copies of adata.X and adata.layers; or updates adata with normalized version of the original; adata.X and adata.layers, depending on inplace. Example; >>> import sys; >>> from anndata import AnnData; >>> import scanpy as sc; >>> sc.settings.verbosity = 'info'; >>> sc.settings.logfile = sys.stdout # for doctests; >>> np.set_printoptions(precision=2); >>> adata = AnnData(np.array([; ... [3, 3, 3, 6, 6],; ... [1, 1, 1, 2, 2],; ... [1, 22, 1, 2, 2],; ... ], dtype='float32')); >>> adata.X; array([[ 3., 3., 3., 6., 6.],; [ 1., 1., 1., 2., 2.],; [ 1., 22., 1., 2., 2.]], dtype=float32); >>> X_norm = sc.pp.normalize_total(adata, target_sum=1, inplace=False)['X']; normalizing counts per cell; finished (0:00:00); >>> X_norm; array([[0.14, 0.14, 0.14, 0.29, 0.29],; [0.14, 0.14, 0.14, 0.29, 0.29],; [0.",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.normalize_total.html:11623,layers,layers,11623,en/stable/generated/scanpy.pp.normalize_total.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.normalize_total.html,1,['layers'],['layers']
Modifiability,"up_positions that want to be highlighted. var_group_rotation float | None (default: None)Label rotation degrees.; By default, labels larger than 4 characters are rotated 90 degrees. layer str | None (default: None)Name of the AnnData object layer that wants to be plotted. By default adata.raw.X is plotted.; If use_raw=False is set, then adata.X is plotted. If layer is set to a valid layer name,; then the layer is plotted. layer takes precedence over use_raw. title str | None (default: None)Title for the figure. expression_cutoff float (default: 0.0)Expression cutoff that is used for binarizing the gene expression and; determining the fraction of cells expressing given genes. A gene is; expressed only if the expression value is greater than this threshold. mean_only_expressed bool (default: False)If True, gene expression is averaged only over the cells; expressing the given genes. standard_scale Optional[Literal['var', 'group']] (default: None)Whether or not to standardize that dimension between 0 and 1,; meaning for each variable or group,; subtract the minimum and divide each by its maximum. kwdsAre passed to matplotlib.pyplot.scatter(). See also. dotplot()Simpler way to call DotPlot but with less options. rank_genes_groups_dotplot()to plot marker genes identified using the rank_genes_groups() function. Examples; >>> import scanpy as sc; >>> adata = sc.datasets.pbmc68k_reduced(); >>> markers = ['C1QA', 'PSAP', 'CD79A', 'CD79B', 'CST3', 'LYZ']; >>> sc.pl.DotPlot(adata, markers, groupby='bulk_labels').show(). Using var_names as dict:; >>> markers = {'T-cell': 'CD3D', 'B-cell': 'CD79A', 'myeloid': 'CST3'}; >>> sc.pl.DotPlot(adata, markers, groupby='bulk_labels').show(). Attributes. DEFAULT_CATEGORY_HEIGHT. DEFAULT_CATEGORY_WIDTH. DEFAULT_COLORMAP. DEFAULT_COLOR_LEGEND_TITLE. DEFAULT_COLOR_ON. DEFAULT_DOT_EDGECOLOR. DEFAULT_DOT_EDGELW. DEFAULT_DOT_MAX. DEFAULT_DOT_MIN. DEFAULT_LARGEST_DOT. DEFAULT_LEGENDS_WIDTH. DEFAULT_PLOT_X_PADDING. DEFAULT_PLOT_Y_PADDING. DEFAULT_SA",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.html:13939,variab,variable,13939,en/stable/api/generated/classes/scanpy.pl.DotPlot.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.html,2,['variab'],['variable']
Modifiability,"urely browser based viewing of zarr formatted AnnData files Harvard Med. Portals#. the Gene Expression Analysis Resource U Maryland; the Galaxy Project for the Human Cell Atlas [tweet] U Freiburg; the Expression Atlas EMBL-EBI. Modalities#. RNA velocity#. scVelo Helmholtz Munich. Spatial Transcriptomics Tools#. squidpy Helmholtz Munich. Squidpy is a comprehensive toolkit for working with spatial single cell omics data. PASTE Princeton. PASTE is a computational method to align and integrate spatial transcriptomics data across adjacent tissue slices by leveraging both gene expression similarity and spatial distances between spots. bento 🍱 UC San Diego. Bento is an accessible Python toolkit for performing subcellular analysis of spatial transcriptomics data. Multimodal integration#. MUON and MuData EMBL/ DKFZ. MUON, and it’s associated data structure MuData are designed to organise, analyse, visualise, and exchange multimodal data.; MUON enables a range of analyses for ATAC and CITE-seq, from data preprocessing to flexible multi-omics alignment. Adaptive immune receptor repertoire (AIRR)#. scirpy Medical University of Innsbruck. scirpy is a scanpy extension to expore single-cell T-cell receptor (TCR) and B-cell receptor (BCR) repertoires. dandelion University of Cambridge. dandelion is a single-cell BCR-seq network analysis package that integrates with transcriptomic data analyzed via scanpy. Long reads#. Swan UC Irvine. Swan is a Python library designed for the analysis and visualization of transcriptomes, especially with long-read transcriptomes in mind.; Users can add transcriptomes from different datasets and explore distinct splicing and expression patterns across datasets. Analysis methods#. scvi-tools#. scvi-tools Berkeley. scvi-tools hosts deep generative models (DGM) for end-to-end analysis of single-cell; omics data (e.g., scVI, scANVI, totalVI). It also contains several primitives to build novel DGMs. Fate mapping#. CellRank Helmholtz Munich. CellRank is a f",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/ecosystem.html:10996,flexible,flexible,10996,en/stable/ecosystem.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/ecosystem.html,1,['flexible'],['flexible']
Modifiability,"utlier_mt""] = adata_pbmc10k.obs.pct_counts_mt > 20; adata_pbmc10k.obs[""outlier_total""] = adata_pbmc10k.obs.total_counts > 25000; adata_pbmc10k.obs[""outlier_ngenes""] = adata_pbmc10k.obs.n_genes_by_counts > 6000. print(; ""%u cells with high %% of mitochondrial genes""; % (sum(adata_pbmc10k.obs[""outlier_mt""])); ); print(""%u cells with large total counts"" % (sum(adata_pbmc10k.obs[""outlier_total""]))); print(; ""%u cells with large number of genes"" % (sum(adata_pbmc10k.obs[""outlier_ngenes""])); ). adata_pbmc10k = adata_pbmc10k[~adata_pbmc10k.obs[""outlier_mt""], :]; adata_pbmc10k = adata_pbmc10k[~adata_pbmc10k.obs[""outlier_total""], :]; adata_pbmc10k = adata_pbmc10k[~adata_pbmc10k.obs[""outlier_ngenes""], :]; sc.pp.filter_genes(adata_pbmc10k, min_cells=1). 494 cells with high % of mitochondrial genes; 75 cells with large total counts; 6 cells with large number of genes; filtered out 1 genes that are detected in less than 1 cells. Use Pearson residuals for selection of highly variable genes#; Analytic Pearson residuals can be used to identify biologically variable genes. For that, the observed counts are compared to the expected counts of a “null model”. This model includes no biological variability between cells. Pearson residuals are defined such that genes that are not differentially expressed will have variance close to 1. In contrast, if a gene is differentially expressed, it will deviate from the null model, causing larger residuals and residual variance >1 for this gene. More details and comparisons to other gene selection methods can be found in Lause et al. (2021).; The call to highly_variable_genes(flavor='pearson_residuals',n_top_genes=2000) computes the residual variances and selects 2000 genes based on this. As shown in the plots below, cell type marker genes known a priori are successfully selected. Compute 2000 variable genes with Pearson residuals#; This will create the field highly_variable, indicating the 2000 genes that have the most variable Pearson residuals. f",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:17674,variab,variable,17674,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,4,['variab'],['variable']
Modifiability,"van Dijk et al., 2018] pr187 S Gigante; dca() for imputation and latent space construction using an autoencoder [Eraslan et al., 2019] pr186 G Eraslan. Version 1.2#. 1.2.1 2018-06-08#. Plotting of Generic marker genes and quality control.#. highest_expr_genes() for quality control; plot genes with highest mean fraction of cells, similar to plotQC of Scater [McCarthy et al., 2017] pr169 F Ramirez. 1.2.0 2018-06-08#. paga() improved, see PAGA; the default model changed, restore the previous default model by passing model='v1.0'. Version 1.1#. 1.1.0 2018-06-01#. set_figure_params() by default passes vector_friendly=True and allows you to produce reasonablly sized pdfs by rasterizing large scatter plots A Wolf; draw_graph() defaults to the ForceAtlas2 layout [Chippada, 2018, Jacomy et al., 2014], which is often more visually appealing and whose computation is much faster S Wollock; scatter() also plots along variables axis MD Luecken; pca() and log1p() support chunk processing S Rybakov; regress_out() is back to multiprocessing F Ramirez; read() reads compressed text files G Eraslan; mitochondrial_genes() for querying mito genes FG Brundu; mnn_correct() for batch correction [Haghverdi et al., 2018, Kang, 2018]; phate() for low-dimensional embedding [Moon et al., 2019] S Gigante; sandbag(), cyclone() for scoring genes [Fechtner, 2018, Scialdone et al., 2015]. Version 1.0#. 1.0.0 2018-03-30#. Major updates#. Scanpy is much faster and more memory efficient: preprocess, cluster and; visualize 1.3M cells in 6h, 130K cells in 14min, and 68K cells in 3min A Wolf; the API gained a preprocessing function neighbors() and a; class Neighbors() to which all basic graph computations are; delegated A Wolf. Warning; Upgrading to 1.0 isn’t fully backwards compatible in the following changes. the graph-based tools louvain(); dpt() draw_graph(); umap() diffmap(); paga() require prior computation of the graph:; sc.pp.neighbors(adata, n_neighbors=5); sc.tl.louvain(adata) instead of; previous",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:47632,variab,variables,47632,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,1,['variab'],['variables']
Modifiability,"w_graph. Contents . draw_graph(). scanpy.pl.draw_graph#. scanpy.pl.draw_graph(adata, *, color=None, mask_obs=None, gene_symbols=None, use_raw=None, sort_order=True, edges=False, edges_width=0.1, edges_color='grey', neighbors_key=None, arrows=False, arrows_kwds=None, groups=None, components=None, dimensions=None, layer=None, projection='2d', scale_factor=None, color_map=None, cmap=None, palette=None, na_color='lightgray', na_in_legend=True, size=None, frameon=None, legend_fontsize=None, legend_fontweight='bold', legend_loc='right margin', legend_fontoutline=None, colorbar_loc='right', vmax=None, vmin=None, vcenter=None, norm=None, add_outline=False, outline_width=(0.3, 0.05), outline_color=('black', 'white'), ncols=4, hspace=0.25, wspace=None, title=None, show=None, save=None, ax=None, return_fig=None, marker='.', layout=None, **kwargs)[source]#; Scatter plot in graph-drawing basis. Parameters:. adata AnnDataAnnotated data matrix. color str | Sequence[str] | None (default: None)Keys for annotations of observations/cells or variables/genes, e.g.,; 'ann1' or ['ann1', 'ann2']. gene_symbols str | None (default: None)Column name in .var DataFrame that stores gene symbols. By default var_names; refer to the index column of the .var DataFrame. Setting this option allows; alternative names to be used. use_raw bool | None (default: None)Use .raw attribute of adata for coloring with gene expression. If None,; defaults to True if layer isn’t provided and adata.raw is present. layer str | None (default: None)Name of the AnnData object layer that wants to be plotted. By default; adata.raw.X is plotted. If use_raw=False is set, then adata.X is plotted.; If layer is set to a valid layer name, then the layer is plotted. layer; takes precedence over use_raw. layout Optional[Literal['fr', 'drl', 'kk', 'grid_fr', 'lgl', 'rt', 'rt_circular', 'fa']] (default: None)One of the draw_graph() layouts.; By default, the last computed layout is used. edges bool (default: False)Show edges. edges_",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pl.draw_graph.html:10280,variab,variables,10280,en/stable/api/generated/scanpy.pl.draw_graph.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pl.draw_graph.html,1,['variab'],['variables']
Modifiability,"will draw a ‘bracket’ or a color block between the given start and end; positions. If the parameter var_group_labels is set, the corresponding; labels are added on top/left. E.g. var_group_positions=[(4,10)]; will add a bracket between the fourth var_name and the tenth var_name.; By giving more positions, more brackets/color blocks are drawn. var_group_labels Sequence[str] | None (default: None)Labels for each of the var_group_positions that want to be highlighted. var_group_rotation float | None (default: None)Label rotation degrees.; By default, labels larger than 4 characters are rotated 90 degrees. layer str | None (default: None)Name of the AnnData object layer that wants to be plotted. By default adata.raw.X is plotted.; If use_raw=False is set, then adata.X is plotted. If layer is set to a valid layer name,; then the layer is plotted. layer takes precedence over use_raw. standard_scale Optional[Literal['var', 'obs']] (default: None)Whether or not to standardize that dimension between 0 and 1, meaning for each variable or observation,; subtract the minimum and divide each by its maximum. swap_axes bool (default: False)By default, the x axis contains var_names (e.g. genes) and the y axis the groupby; categories (if any). By setting swap_axes then x are the groupby categories and y the var_names. show_gene_labels bool | None (default: None)By default gene labels are shown when there are 50 or less genes. Otherwise the labels are removed. show bool | None (default: None)Show the plot, do not return axis. save str | bool | None (default: None)If True or a str, save the figure.; A string is appended to the default filename.; Infer the filetype if ending on {'.pdf', '.png', '.svg'}. axA matplotlib axes object. Only works if plotting a single component. vmin float | None (default: None)The value representing the lower limit of the color scale. Values smaller than vmin are plotted; with the same color as vmin. vmax float | None (default: None)The value representing th",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pl.heatmap.html:12973,variab,variable,12973,en/stable/generated/scanpy.pl.heatmap.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pl.heatmap.html,1,['variab'],['variable']
Modifiability,"wise, return results. See below for; details of what is returned. Return type:; tuple[AnnData, DataFrame] | None. Returns:; If inplace=False, separately returns the gene selection results (as; DataFrame) and Pearson residual-based PCA results (as; AnnData). If inplace=True, updates adata with the; following fields for gene selection results:. .var['highly_variable']boolboolean indicator of highly-variable genes. .var['means']floatmeans per gene. .var['variances']floatvariances per gene. .var['residual_variances']floatPearson residual variance per gene. Averaged in the case of multiple; batches. .var['highly_variable_rank']floatRank of the gene according to residual variance, median rank in the; case of multiple batches. .var['highly_variable_nbatches']intIf batch_key is given, this denotes in how many batches genes are; detected as HVG. .var['highly_variable_intersection']boolIf batch_key is given, this denotes the genes that are highly variable; in all batches. The following fields contain Pearson residual-based PCA results and; normalization settings:. .uns['pearson_residuals_normalization']['pearson_residuals_df']The subset of highly variable genes, normalized by Pearson residuals. .uns['pearson_residuals_normalization']['theta']The used value of the overdisperion parameter theta. .uns['pearson_residuals_normalization']['clip']The used value of the clipping parameter. .obsm['X_pca']PCA representation of data after gene selection and Pearson residual; normalization. .varm['PCs']The principal components containing the loadings. When inplace=True this; will contain empty rows for the genes not selected during HVG selection. .uns['pca']['variance_ratio']Ratio of explained variance. .uns['pca']['variance']Explained variance, equivalent to the eigenvalues of the covariance matrix. previous; scanpy.experimental.pp.highly_variable_genes. next; Classes. Contents; . recipe_pearson_residuals(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.recipe_pearson_residuals.html:13126,variab,variable,13126,en/stable/generated/scanpy.experimental.pp.recipe_pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.recipe_pearson_residuals.html,1,['variab'],['variable']
Modifiability,"xternal.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.read_loom. Contents . read_loom(). scanpy.read_loom#. scanpy.read_loom(filename, *, sparse=True, cleanup=False, X_name='spliced', obs_names='CellID', obsm_names=None, var_names='Gene', varm_names=None, dtype='float32', obsm_mapping=mappingproxy({}), varm_mapping=mappingproxy({}), **kwargs)[source]#; Read .loom-formatted hdf5 file.; This reads the whole file into memory.; Beware that you have to explicitly state when you want to read the file as; sparse data. Parameters:. filename PathLikeThe filename. sparse bool (default: True)Whether to read the data matrix as sparse. cleanup bool (default: False)Whether to collapse all obs/var fields that only store; one unique value into .uns['loom-.']. X_name str (default: 'spliced')Loompy key with which the data matrix X is initialized. obs_names str (default: 'CellID')Loompy key where the observation/cell names are stored. obsm_mapping Mapping[str, Iterable[str]] (default: mappingproxy({}))Loompy keys which will be constructed into observation matrices. var_names str (default: 'Gene')Loompy key where the variable/gene names are stored. varm_mapping Mapping[str, Iterable[str]] (default: mappingproxy({}))Loompy keys which will be constructed into variable matrices. **kwargsArguments to loompy.connect. Return type:; AnnData. Example; pbmc = anndata.read_loom(; ""pbmc.loom"",; sparse=True,; X_name=""lognorm"",; obs_names=""cell_names"",; var_names=""gene_names"",; obsm_mapping={; ""X_umap"": [""umap_1"", ""umap_2""]; }; ). previous; scanpy.read_hdf. next; scanpy.read_mtx. Contents; . read_loom(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.read_loom.html:10293,variab,variable,10293,en/stable/generated/scanpy.read_loom.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.read_loom.html,2,['variab'],['variable']
Modifiability,"y is most efficient on a sparse CSR or dense matrix.; Note that this method can take a while to compile on the first call. That; result is then cached to disk to be used later. Parameters:. adata AnnDataAnnotated data matrix. expr_type str (default: 'counts')Name of kind of values in X. var_type str (default: 'genes')The kind of thing the variables are. qc_vars Collection[str] | str (default: ())Keys for boolean columns of .var which identify variables you could; want to control for (e.g. “ERCC” or “mito”). percent_top Collection[int] | None (default: (50, 100, 200, 500))List of ranks (where genes are ranked by expression) at which the cumulative; proportion of expression will be reported as a percentage. This can be used to; assess library complexity. Ranks are considered 1-indexed, and if empty or None; don’t calculate.; E.g. percent_top=[50] finds cumulative proportion to the 50th most expressed gene. layer str | None (default: None)If provided, use adata.layers[layer] for expression values instead; of adata.X. use_raw bool (default: False)If True, use adata.raw.X for expression values instead of adata.X. inplace bool (default: False)Whether to place calculated metrics in adata’s .obs and .var. log1p bool (default: True)Set to False to skip computing log1p transformed annotations. Return type:; tuple[DataFrame, DataFrame] | None. Returns:; Depending on inplace returns calculated metrics; (as DataFrame) or updates adata’s obs and var.; Observation level metrics include:. total_{var_type}_by_{expr_type}E.g. “total_genes_by_counts”. Number of genes with positive counts in a cell. total_{expr_type}E.g. “total_counts”. Total number of counts for a cell. pct_{expr_type}_in_top_{n}_{var_type} – for n in percent_topE.g. “pct_counts_in_top_50_genes”. Cumulative percentage of counts; for 50 most expressed genes in a cell. total_{expr_type}_{qc_var} – for qc_var in qc_varsE.g. “total_counts_mito”. Total number of counts for variables in; qc_vars. pct_{expr_type}_{qc_var} – ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.calculate_qc_metrics.html:10726,layers,layers,10726,en/stable/generated/scanpy.pp.calculate_qc_metrics.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.calculate_qc_metrics.html,1,['layers'],['layers']
Modifiability,"yer=None, obsm=None, obsp=None, use_raw=False)[source]#; Calculate Moran’s I Global Autocorrelation Statistic.; Moran’s I is a global autocorrelation statistic for some measure on a graph. It is commonly used in; spatial data analysis to assess autocorrelation on a 2D grid. It is closely related to Geary’s C,; but not identical. More info can be found here. \[I =; \frac{; N \sum_{i, j} w_{i, j} z_{i} z_{j}; }{; S_{0} \sum_{i} z_{i}^{2}; }\]. Parameters:. adata AnnData. vals ndarray | spmatrix | None (default: None)Values to calculate Moran’s I for. If this is two dimensional, should; be of shape (n_features, n_cells). Otherwise should be of shape; (n_cells,). This matrix can be selected from elements of the anndata; object by using key word arguments: layer, obsm, obsp, or; use_raw. use_graph str | None (default: None)Key to use for graph in anndata object. If not provided, default; neighbors connectivities will be used instead. layer str | None (default: None)Key for adata.layers to choose vals. obsm str | None (default: None)Key for adata.obsm to choose vals. obsp str | None (default: None)Key for adata.obsp to choose vals. use_raw bool (default: False)Whether to use adata.raw.X for vals. This function can also be called on the graph and values directly. In this case; the signature looks like:. Parameters:. gThe graph. valsThe values. See the examples for more info. Return type:; ndarray | float. Returns:; If vals is two dimensional, returns a 1 dimensional ndarray array. Returns; a scalar if vals is 1d. Examples; Calculate Moran’s I for each components of a dimensionality reduction:; import scanpy as sc, numpy as np. pbmc = sc.datasets.pbmc68k_processed(); pc_c = sc.metrics.morans_i(pbmc, obsm=""X_pca""). It’s equivalent to call the function directly on the underlying arrays:; alt = sc.metrics.morans_i(pbmc.obsp[""connectivities""], pbmc.obsm[""X_pca""].T); np.testing.assert_array_equal(pc_c, alt). previous; scanpy.metrics.gearys_c. next; Experimental. Contents; . mora",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.metrics.morans_i.html:10358,layers,layers,10358,en/stable/generated/scanpy.metrics.morans_i.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.metrics.morans_i.html,1,['layers'],['layers']
Modifiability,"yter notebooks and lab, you can see the documentation for a python function by hitting SHIFT + TAB. Hit it twice to expand the view. import pandas as pd; import scanpy as sc. sc.settings.verbosity = 3 # verbosity: errors (0), warnings (1), info (2), hints (3); sc.logging.print_header(); sc.settings.set_figure_params(dpi=80, facecolor=""white""). scanpy==1.10.0rc2.dev6+g14555ba4.d20240226 anndata==0.11.0.dev78+g64ab900 umap==0.5.5 numpy==1.26.3 scipy==1.11.4 pandas==2.2.0 scikit-learn==1.3.2 statsmodels==0.14.1 igraph==0.10.8 pynndescent==0.5.11. results_file = ""write/pbmc3k.h5ad"" # the file that will store the analysis results. Read in the count matrix into an AnnData object, which holds many slots for annotations and different representations of the data. It also comes with its own HDF5-based file format: .h5ad. adata = sc.read_10x_mtx(; ""data/filtered_gene_bc_matrices/hg19/"", # the directory with the `.mtx` file; var_names=""gene_symbols"", # use gene symbols for the variable names (variables-axis index); cache=True, # write a cache file for faster subsequent reading; ). ... reading from cache file cache/data-filtered_gene_bc_matrices-hg19-matrix.h5ad. Note; See anndata-tutorials/getting-started for a more comprehensive introduction to AnnData. adata.var_names_make_unique() # this is unnecessary if using `var_names='gene_ids'` in `sc.read_10x_mtx`. adata. AnnData object with n_obs × n_vars = 2700 × 32738; var: 'gene_ids'. Preprocessing#; Show those genes that yield the highest fraction of counts in each single cell, across all cells. sc.pl.highest_expr_genes(adata, n_top=20). normalizing counts per cell; finished (0:00:00). Basic filtering:. sc.pp.filter_cells(adata, min_genes=200); sc.pp.filter_genes(adata, min_cells=3). filtered out 19024 genes that are detected in less than 3 cells. Let’s assemble some information about mitochondrial genes, which are important for quality control.; Citing from “Simple Single Cell” workflows (Lun, McCarthy & Marioni, 2017):. High pro",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering-2017.html:11561,variab,variable,11561,en/stable/tutorials/basics/clustering-2017.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering-2017.html,4,['variab'],"['variable', 'variables-axis']"
Modifiability,"zed data – the logarithm of mean; and dispersion is taken internally when log is at its default value; True. For ‘cell_ranger’, this is usually called for logarithmized data; – in this case you should set log to False. In their default; workflows, Seurat passes the cutoffs whereas Cell Ranger passes; n_top_genes. min_mean float | None (default: None). max_mean float | None (default: None). min_disp float | None (default: None). max_disp float | None (default: None)If n_top_genes unequals None, these cutoffs for the means and the; normalized dispersions are ignored. n_bins int (default: 20)Number of bins for binning the mean gene expression. Normalization is; done with respect to each bin. If just a single gene falls into a bin,; the normalized dispersion is artificially set to 1. You’ll be informed; about this if you set settings.verbosity = 4. n_top_genes int | None (default: None)Number of highly-variable genes to keep. log bool (default: True)Use the logarithm of the mean to variance ratio. subset bool (default: True)Keep highly-variable genes only (if True) else write a bool array for h; ighly-variable genes while keeping all genes. copy bool (default: False)If an AnnData is passed, determines whether a copy; is returned. Return type:; AnnData | recarray | None. Returns:; If an AnnData adata is passed, returns or updates adata depending on; copy. It filters the adata and adds the annotations. meansadata.varMeans per gene. Logarithmized when log is True. dispersionsadata.varDispersions per gene. Logarithmized when log is True. dispersions_normadata.varNormalized dispersions per gene. Logarithmized when log is True. If a data matrix X is passed, the annotation is returned as np.recarray; with the same information stored in fields: gene_subset, means, dispersions, dispersion_norm. previous; Deprecated functions. next; scanpy.pp.normalize_per_cell. Contents; . filter_genes_dispersion(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.filter_genes_dispersion.html:11923,variab,variable,11923,en/stable/generated/scanpy.pp.filter_genes_dispersion.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.filter_genes_dispersion.html,2,['variab'],['variable']
Performance," Dicks; pp.highly_variable_genes with flavor=seurat_v3 now uses a numba kernel pr3017 S Dicks; Speed up scrublet() pr3044 S Dicks and pr3056 P Angerer; Speed up clipping of array in scale() pr3100 P Ashish & S Dicks. 1.10.1 2024-04-09#. Documentation#. Added how-to example on plotting with Marsilea pr2974 Y Zheng. Bug fixes#. Fix aggregate when aggregating by more than two groups pr2965 I Virshup. Performance#. scale() now uses numba kernels for sparse.csr_matrix and sparse.csc_matrix when zero_center==False and mask_obs is provided. This greatly speed up execution pr2942 S Dicks. 1.10.0 2024-03-26#; scanpy 1.10 brings a large amount of new features, performance improvements, and improved documentation.; Some highlights:. Improved support for out-of-core workflows via dask. See new tutorial: Using dask with Scanpy demonstrating counts-to-clusters for 1.4 million cells in <10 min.; A new basic clustering tutorial demonstrating an updated workflow.; Opt-in increased performance for neighbor search and clustering (how to guide).; Ability to mask observations or variables from a number of methods (see Customizing Scanpy plots for an example with plotting embeddings); A new function aggregate() for computing aggregations of your data, very useful for pseudo bulking!. Features#. scrublet() and scrublet_simulate_doublets() were moved from scanpy.external.pp to scanpy.pp. The scrublet implementation is now maintained as part of scanpy pr2703 P Angerer; scanpy.pp.pca(), scanpy.pp.scale(), scanpy.pl.embedding(), and scanpy.experimental.pp.normalize_pearson_residuals_pca() now support a mask parameter pr2272 C Bright, T Marcella, & P Angerer; Enhanced dask support for some internal utilities, paving the way for more extensive dask support pr2696 P Angerer; scanpy.pp.highly_variable_genes() supports dask for the default seurat and cell_ranger flavors pr2809 P Angerer; New function scanpy.get.aggregate() which allows grouped aggregations over your data. Useful for pseudobulking! ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:14442,perform,performance,14442,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,1,['perform'],['performance']
Performance," certain set of genes given by a boolean array; or a string referring to an array in var.; By default, uses .var['highly_variable'] if available, else everything. use_highly_variable bool | None (default: None)Whether to use highly variable genes only, stored in; .var['highly_variable'].; By default uses them if they have been determined beforehand. Deprecated since version 1.10.0: Use mask_var instead. check_values bool (default: True)If True, checks if counts in selected layer are integers as expected by this; function, and return a warning if non-integers are found. Otherwise, proceed; without checking. Setting this to False can speed up code for large datasets. inplace bool (default: True)If True, update adata with results. Otherwise, return results. See below for; details of what is returned. Return type:; AnnData | None. Returns:; If inplace=False, returns the Pearson residual-based PCA results (as AnnData; object). If inplace=True, updates adata with the following fields:. .uns['pearson_residuals_normalization']['pearson_residuals_df']The subset of highly variable genes, normalized by Pearson residuals. .uns['pearson_residuals_normalization']['theta']The used value of the overdisperion parameter theta. .uns['pearson_residuals_normalization']['clip']The used value of the clipping parameter. .obsm['X_pca']PCA representation of data after gene selection (if applicable) and Pearson; residual normalization. .varm['PCs']The principal components containing the loadings. When inplace=True and; use_highly_variable=True, this will contain empty rows for the genes not; selected. .uns['pca']['variance_ratio']Ratio of explained variance. .uns['pca']['variance']Explained variance, equivalent to the eigenvalues of the covariance matrix. previous; scanpy.experimental.pp.normalize_pearson_residuals. next; scanpy.experimental.pp.highly_variable_genes. Contents; . normalize_pearson_residuals_pca(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.normalize_pearson_residuals_pca.html:12649,load,loadings,12649,en/stable/generated/scanpy.experimental.pp.normalize_pearson_residuals_pca.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.normalize_pearson_residuals_pca.html,1,['load'],['loadings']
Performance," dataset. Uncomment this cell to create directories, download and unpack the data:. # !mkdir tutorial_data; # !mkdir tutorial_data/pbmc3k_v1; # !mkdir tutorial_data/pbmc10k_v3. # !wget http://cf.10xgenomics.com/samples/cell-exp/1.1.0/pbmc3k/pbmc3k_filtered_gene_bc_matrices.tar.gz -O tutorial_data/pbmc3k_v1.tar.gz; # !cd tutorial_data; tar -xzf pbmc3k_v1.tar.gz -C pbmc3k_v1 --strip-components 2. # !wget https://cf.10xgenomics.com/samples/cell-exp/3.0.0/pbmc_10k_v3/pbmc_10k_v3_filtered_feature_bc_matrix.tar.gz -O tutorial_data/pbmc10k_v3.tar.gz; # !cd tutorial_data; tar -xzf pbmc10k_v3.tar.gz -C pbmc10k_v3 --strip-components 1. Load data#; Here we load the two downloaded datasets from disk and create AnnData objects for them. adata_pbmc3k = sc.read_10x_mtx(""tutorial_data/pbmc3k_v1/"", cache=True); adata_pbmc10k = sc.read_10x_mtx(""tutorial_data/pbmc10k_v3/"", cache=True). adata_pbmc3k.uns[""name""] = ""PBMC 3k (v1)""; adata_pbmc10k.uns[""name""] = ""PBMC 10k (v3)"". ... writing an h5ad cache file to speedup reading next time; ... writing an h5ad cache file to speedup reading next time. To demonstrate that Pearson residuals select meaningful genes on these PBMC datasets, we will compare the gene selection to a set of marker genes that were identified in the PBMC3k tutorial. They map to PBMC cell types as follows:; ['IL7R', # CD4 T cells; 'LYZ', 'CD14', # CD14+ Monocytes; 'MS4A1', # B cells; 'CD8A', # CD8 T cells; 'GNLY', 'NKG7', # NK cells; 'FCGR3A', 'MS4A7', # FCGR3A+ Monocytes; 'FCER1A', 'CST3', # Dendritic Cells; 'PPBP'] # Megakaryocytes. A good gene selection should include these differentially expressed genes. # marker genes from table in pbmc3k tutorial; markers = [; ""IL7R"",; ""LYZ"",; ""CD14"",; ""MS4A1"",; ""CD8A"",; ""GNLY"",; ""NKG7"",; ""FCGR3A"",; ""MS4A7"",; ""FCER1A"",; ""CST3"",; ""PPBP"",; ]. Perform Quality control#; First, we remove cells and genes with few counts, then remove outlier cells. Parameters and thresholds are inspired from the PBMC3k tutorial. Basic filtering#. for adata i",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:13301,cache,cache,13301,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,2,['cache'],['cache']
Performance," decorators.; You can read more about fixtures in pytest’s documentation, but we’d also recommend searching our test suite for existing usage. What to test#; If you’re not sure what to tests about your function, some ideas include:. Are there arguments which conflict with each other? Check that if they are both passed, the function throws an error (see pytest.raises docs).; Are there input values which should cause your function to error?; Did you add a helpful error message that recommends better outputs? Check that that error message is actually thrown.; Can you place bounds on the values returned by your function?; Are there different input values which should generate equivalent output (e.g. if an array is sparse or dense)?; Do you have arguments which should have orthogonal effects on the output? Check that they are independent. For example, if there is a flag for extended output, the base output should remain the same either way.; Are you optimizing a method? Check that it’s results are the same as a gold standard implementation. Performance#; It’s more important that you’re accurately testing the code works than it is that test suite runs quickly.; That said, it’s nice when the test suite runs fast.; You can check how long tests take to run by passing --durations=0 argument to pytest.; Hopefully your new tests won’t show up on top!; Some approaches to this include:. Is there a common setup/ computation happening in each test? Consider caching these in a scoped test fixture.; Is the behaviour you’re testing for dependent on the size of the data? If not, consider reducing it. Plotting tests#; While computational functions will return arrays and values, it can be harder to work with the output of plotting functions.; To make this easier, we use the image_comparer fixture for comparing plotting results (search the test suite for example usage).; This is used to check that generated plots look the same as they did previously.; Reference images (the expected output",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/dev/testing.html:11625,optimiz,optimizing,11625,en/stable/dev/testing.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/dev/testing.html,1,['optimiz'],['optimizing']
Performance," genes. plt.rcParams[""figure.figsize""] = (4, 4); sc.pl.umap(adata, color=[""total_counts"", ""n_genes_by_counts"", ""clusters""], wspace=0.4). Visualization in spatial coordinates#; Let us now take a look at how total_counts and n_genes_by_counts behave in spatial coordinates. We will overlay the circular spots on top of the Hematoxylin and eosin stain (H&E) image provided, using the function sc.pl.spatial. plt.rcParams[""figure.figsize""] = (8, 8); sc.pl.spatial(adata, img_key=""hires"", color=[""total_counts"", ""n_genes_by_counts""]). The function sc.pl.spatial accepts 4 additional parameters:. img_key: key where the img is stored in the adata.uns element; crop_coord: coordinates to use for cropping (left, right, top, bottom); alpha_img: alpha value for the transcparency of the image; bw: flag to convert the image into gray scale. Furthermore, in sc.pl.spatial, the size parameter changes its behaviour: it becomes a scaling factor for the spot sizes.; Before, we performed clustering in gene expression space, and visualized the results with UMAP. By visualizing clustered samples in spatial dimensions, we can gain insights into tissue organization and, potentially, into inter-cellular communication. sc.pl.spatial(adata, img_key=""hires"", color=""clusters"", size=1.5). Spots belonging to the same cluster in gene expression space often co-occur in spatial dimensions. For instance, spots belonging to cluster 5 are often surrounded by spots belonging to cluster 0.; We can zoom in specific regions of interests to gain qualitative insights. Furthermore, by changing the alpha values of the spots, we can visualize better the underlying tissue morphology from the H&E image. sc.pl.spatial(; adata,; img_key=""hires"",; color=""clusters"",; groups=[""5"", ""9""],; crop_coord=[7000, 10000, 0, 6000],; alpha=0.5,; size=1.3,; ). Cluster marker genes#; Let us further inspect cluster 5, which occurs in small groups of spots across the image.; Compute marker genes and plot a heatmap with expression levels of i",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/basic-analysis.html:17428,perform,performed,17428,en/stable/tutorials/spatial/basic-analysis.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/basic-analysis.html,2,['perform'],['performed']
Performance," groups str | None (default: None)Key for categorical in adata.obs. You can pass your predefined groups; by choosing any categorical annotation of observations. Default:; The first present key of 'leiden' or 'louvain'. use_rna_velocity bool (default: False)Use RNA velocity to orient edges in the abstracted graph and estimate; transitions. Requires that adata.uns contains a directed single-cell; graph with key ['velocity_graph']. This feature might be subject; to change in the future. model Literal['v1.2', 'v1.0'] (default: 'v1.2')The PAGA connectivity model. neighbors_key str | None (default: None)If not specified, paga looks .uns['neighbors'] for neighbors settings; and .obsp['connectivities'], .obsp['distances'] for connectivities and; distances respectively (default storage places for pp.neighbors).; If specified, paga looks .uns[neighbors_key] for neighbors settings and; .obsp[.uns[neighbors_key]['connectivities_key']],; .obsp[.uns[neighbors_key]['distances_key']] for connectivities and distances; respectively. copy bool (default: False)Copy adata before computation and return a copy. Otherwise, perform; computation inplace and return None. Return type:; AnnData | None. Returns:; Returns None if copy=False, else returns an AnnData object. Sets the following fields:. adata.uns['connectivities']numpy.ndarray (dtype float)The full adjacency matrix of the abstracted graph, weights correspond to; confidence in the connectivities of partitions. adata.uns['connectivities_tree']scipy.sparse.csr_matrix (dtype float)The adjacency matrix of the tree-like subgraph that best explains; the topology. Notes; Together with a random walk-based distance measure; (e.g. scanpy.tl.dpt()) this generates a partial coordinatization of; data useful for exploring and explaining its variation. See also; pl.paga, pl.paga_path, pl.paga_compare. previous; scanpy.tl.dpt. next; scanpy.tl.ingest. Contents; . paga(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.paga.html:11700,perform,perform,11700,en/stable/generated/scanpy.tl.paga.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.paga.html,1,['perform'],['perform']
Performance," scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.tl.umap. Contents . umap(). scanpy.tl.umap#. scanpy.tl.umap(adata, *, min_dist=0.5, spread=1.0, n_components=2, maxiter=None, alpha=1.0, gamma=1.0, negative_sample_rate=5, init_pos='spectral', random_state=0, a=None, b=None, method='umap', neighbors_key='neighbors', copy=False)[source]#; Embed the neighborhood graph using UMAP [McInnes et al., 2018].; UMAP (Uniform Manifold Approximation and Projection) is a manifold learning; technique suitable for visualizing high-dimensional data. Besides tending to; be faster than tSNE, it optimizes the embedding such that it best reflects; the topology of the data, which we represent throughout Scanpy using a; neighborhood graph. tSNE, by contrast, optimizes the distribution of; nearest-neighbor distances in the embedding such that these best match the; distribution of distances in the high-dimensional space.; We use the implementation of umap-learn [McInnes et al., 2018].; For a few comparisons of UMAP with tSNE, see Becht et al. [2018]. Parameters:. adata AnnDataAnnotated data matrix. min_dist float (default: 0.5)The effective minimum distance between embedded points. Smaller values; will result in a more clustered/clumped embedding where nearby points on; the manifold are drawn closer together, while larger values will result; on a more even dispersal of points. The value should be set relative to; the spread value, which determines the scale at which embedded; points will be spread out. The default of in the umap-learn package is; 0.1. spread float (default: 1.0)The effective scale of embedded points. In combination with min_dist; this determines how clustered/clumped the embedded points are. n_components int (default: 2)The number of dimensions of the embedding. maxiter int | None (default: None",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.umap.html:9926,optimiz,optimizes,9926,en/stable/generated/scanpy.tl.umap.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.umap.html,1,['optimiz'],['optimizes']
Performance," scanpy.external.pp.scanorama_integrate; scanpy.external.pp.hashsolo; scanpy.external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .ipynb. .pdf. Integrating spatial data with scRNA-seq using scanorama. Contents . Loading libraries; Reading the data; Data integration; Data integration and label transfer from scRNA-seq dataset. Integrating spatial data with scRNA-seq using scanorama#; Author: Giovanni Palla. Note; For up-to-date analysis tutorials, kindly check out SquidPy tutorials. This tutorial shows how to work with multiple Visium datasets and perform integration of scRNA-seq dataset with Scanpy. It follows the previous tutorial on analysis and visualization of spatial transcriptomics data.; We will use Scanorama paper - code to perform integration and label transfer. It has a convenient interface with scanpy and anndata.; To install the required libraries, type the following:; pip install git+https://github.com/theislab/scanpy.git; pip install git+https://github.com/theislab/anndata.git; pip install scanorama. Loading libraries#. import scanpy as sc; import anndata as an; import pandas as pd; import numpy as np; import matplotlib.pyplot as plt; import seaborn as sns; import scanorama. from pathlib import Path. sc.logging.print_versions(); sc.set_",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html:9335,Load,Loading,9335,en/stable/tutorials/spatial/integration-scanorama.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html,1,['Load'],['Loading']
Performance," scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.read_h5ad. Contents . read_h5ad(). scanpy.read_h5ad#. scanpy.read_h5ad(filename, backed=None, *, as_sparse=(), as_sparse_fmt=<class 'scipy.sparse._csr.csr_matrix'>, chunk_size=6000)[source]#; Read .h5ad-formatted hdf5 file. Parameters:. filename str | PathFile name of data file. backed Union[Literal['r', 'r+'], bool, None] (default: None)If 'r', load AnnData in backed mode; instead of fully loading it into memory (memory mode).; If you want to modify backed attributes of the AnnData object,; you need to choose 'r+'.; Currently, backed only support updates to X. That means any; changes to other slots like obs will not be written to disk in; backed mode. If you would like save changes made to these slots; of a backed AnnData, write them to a new file; (see write()). For an example, see; [here] (https://anndata-tutorials.readthedocs.io/en/latest/getting-started.html#Partial-reading-of-large-data). as_sparse Sequence[str] (default: ())If an array was saved as dense, passing its name here will read it as; a sparse_matrix, by chunk of size chunk_size. as_sparse_fmt type[spmatrix] (default: <class 'scipy.sparse._csr.csr_matrix'>)Sparse format class to read elements from as_sparse in as. chunk_size int (default: 6000)Used only when loading sparse dataset that is stored as dense.; Loading iterates through chunks of the dataset of this row siz",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.read_h5ad.html:9580,load,load,9580,en/stable/generated/scanpy.read_h5ad.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.read_h5ad.html,2,['load'],"['load', 'loading']"
Performance," that you reduce the size of your count matrix by gene selection, before running normalize_pearson_residuals(adata) on the reduced data. To perform RAM-efficient gene selection, use highly_variable_genes(adata,flavor='pearson_residuals') with the chunksize argument: This will still use Pearson residual variance to identify variable genes, but won’t compute all residuals at once. Reduce the chunksize as needed if you run into RAM issues during gene selection. Note that a very small chunksize will slow down the computation, so try to set it as large as possible with your resources.; As an example, we used chunksize=1000 when processing a dataset with 2 million cells in a machine with 500 GB RAM. For smaller machines, we would recommend to reduce this below 100. Wrapper functions for Pearson residuals preprocessing#; The scanpy.experimental.pp module also ships two wrappers that run multiple pre-processing steps at once:. sc.experimental.pp.normalize_pearson_residuals_pca() performs normalization by Pearson residuals and PCA in one go. This function is helpful to quickly obtain a Pearson residual-based data representation when highly variable genes are already defined, as only those are used by default.; sc.experimental.pp.recipe_pearson_residuals() performs gene selection and normalization by Pearson residuals, and PCA on top. This is intended to make the full Pearson residual preprocessing available in one step. All hyperparameters of the individual steps can still be controlled using the wrapper functions’ arguments. See the documentation for details. References / See also#; Hafemeister & Satija (2019), Normalization and variance stabilization of single-cell RNA-seq data using regularized negative binomial regression, Genome Biology; Lause et al. (2021), Analytic Pearson residuals for normalization of single-cell RNA-seq UMI data, Genome Biology; Wagner (2021), Normalization methods for single-cell RNA-Seq data, Youtube; Choudhary & Satija (2022), Comparison and eva",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:30013,perform,performs,30013,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,2,['perform'],['performs']
Performance," view. import pandas as pd; import scanpy as sc. sc.settings.verbosity = 3 # verbosity: errors (0), warnings (1), info (2), hints (3); sc.logging.print_header(); sc.settings.set_figure_params(dpi=80, facecolor=""white""). scanpy==1.10.0rc2.dev6+g14555ba4.d20240226 anndata==0.11.0.dev78+g64ab900 umap==0.5.5 numpy==1.26.3 scipy==1.11.4 pandas==2.2.0 scikit-learn==1.3.2 statsmodels==0.14.1 igraph==0.10.8 pynndescent==0.5.11. results_file = ""write/pbmc3k.h5ad"" # the file that will store the analysis results. Read in the count matrix into an AnnData object, which holds many slots for annotations and different representations of the data. It also comes with its own HDF5-based file format: .h5ad. adata = sc.read_10x_mtx(; ""data/filtered_gene_bc_matrices/hg19/"", # the directory with the `.mtx` file; var_names=""gene_symbols"", # use gene symbols for the variable names (variables-axis index); cache=True, # write a cache file for faster subsequent reading; ). ... reading from cache file cache/data-filtered_gene_bc_matrices-hg19-matrix.h5ad. Note; See anndata-tutorials/getting-started for a more comprehensive introduction to AnnData. adata.var_names_make_unique() # this is unnecessary if using `var_names='gene_ids'` in `sc.read_10x_mtx`. adata. AnnData object with n_obs × n_vars = 2700 × 32738; var: 'gene_ids'. Preprocessing#; Show those genes that yield the highest fraction of counts in each single cell, across all cells. sc.pl.highest_expr_genes(adata, n_top=20). normalizing counts per cell; finished (0:00:00). Basic filtering:. sc.pp.filter_cells(adata, min_genes=200); sc.pp.filter_genes(adata, min_cells=3). filtered out 19024 genes that are detected in less than 3 cells. Let’s assemble some information about mitochondrial genes, which are important for quality control.; Citing from “Simple Single Cell” workflows (Lun, McCarthy & Marioni, 2017):. High proportions are indicative of poor-quality cells (Islam et al. 2014; Ilicic et al. 2016), possibly because of loss of cytoplasmi",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering-2017.html:11684,cache,cache,11684,en/stable/tutorials/basics/clustering-2017.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering-2017.html,4,['cache'],['cache']
Performance," with a; pseudocount of one using sc.pp.log1p function of Scanpy. hidden_size Sequence[int] (default: (64, 32, 64))Width of hidden layers. hidden_dropout float | Sequence[float] (default: 0.0)Probability of weight dropout in the autoencoder (per layer if list; or tuple). batchnorm bool (default: True)If true, batch normalization is performed. activation str (default: 'relu')Activation function of hidden layers. init str (default: 'glorot_uniform')Initialization method used to initialize weights. network_kwds Mapping[str, Any] (default: mappingproxy({}))Additional keyword arguments for the autoencoder. epochs int (default: 300)Number of total epochs in training. reduce_lr int (default: 10)Reduces learning rate if validation loss does not improve in given number of epochs. early_stop int (default: 15)Stops training if validation loss does not improve in given number of epochs. batch_size int (default: 32)Number of samples in the batch used for SGD. optimizer str (default: 'RMSprop')Type of optimization method used for training. random_state Union[int, RandomState, None] (default: 0)Seed for python, numpy and tensorflow. threads int | None (default: None)Number of threads to use in training. All cores are used by default. learning_rate float | None (default: None)Learning rate to use in the training. verbose bool (default: False)If true, prints additional information about training and architecture. training_kwds Mapping[str, Any] (default: mappingproxy({}))Additional keyword arguments for the training process. return_model bool (default: False)If true, trained autoencoder object is returned. See “Returns”. return_info bool (default: False)If true, all additional parameters of DCA are stored in adata.obsm such as dropout; probabilities (obsm[‘X_dca_dropout’]) and estimated dispersion values; (obsm[‘X_dca_dispersion’]), in case that autoencoder is of type; zinb or zinb-conddisp. copy bool (default: False)If true, a copy of anndata is returned. Return type:; AnnData | Non",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.dca.html:12338,optimiz,optimizer,12338,en/stable/generated/scanpy.external.pp.dca.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.dca.html,2,['optimiz'],"['optimization', 'optimizer']"
Performance,"(default: 'X_pca')The name of the field in adata.obsm where the PCA table is; stored. Defaults to 'X_pca', which is the default for; sc.pp.pca(). adjusted_basis str (default: 'X_scanorama')The name of the field in adata.obsm where the integrated; embeddings will be stored after running this function. Defaults; to X_scanorama. knn int (default: 20)Number of nearest neighbors to use for matching. sigma float (default: 15)Correction smoothing parameter on Gaussian kernel. approx bool (default: True)Use approximate nearest neighbors with Python annoy;; greatly speeds up matching runtime. alpha float (default: 0.1)Alignment score minimum cutoff. batch_size int (default: 5000)The batch size used in the alignment vector computation. Useful; when integrating very large (>100k samples) datasets. Set to; large value that runs within available memory. kwargsAny additional arguments will be passed to; scanorama.assemble(). Return type:; None. Returns:; Updates adata with the field adata.obsm[adjusted_basis],; containing Scanorama embeddings such that different experiments; are integrated. Example; First, load libraries and example dataset, and preprocess.; >>> import scanpy as sc; >>> import scanpy.external as sce; >>> adata = sc.datasets.pbmc3k(); >>> sc.pp.recipe_zheng17(adata); >>> sc.pp.pca(adata). We now arbitrarily assign a batch metadata variable to each cell; for the sake of example, but during real usage there would already; be a column in adata.obs giving the experiment each cell came; from.; >>> adata.obs['batch'] = 1350*['a'] + 1350*['b']. Finally, run Scanorama. Afterwards, there will be a new table in; adata.obsm containing the Scanorama embeddings.; >>> sce.pp.scanorama_integrate(adata, 'batch', verbose=1); Processing datasets a <=> b; >>> 'X_scanorama' in adata.obsm; True. previous; scanpy.external.pp.mnn_correct. next; scanpy.external.pp.hashsolo. Contents; . scanorama_integrate(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.scanorama_integrate.html:11265,load,load,11265,en/stable/generated/scanpy.external.pp.scanorama_integrate.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.scanorama_integrate.html,1,['load'],['load']
Performance,", 2018].; For a few comparisons of UMAP with tSNE, see Becht et al. [2018]. Parameters:. adata AnnDataAnnotated data matrix. min_dist float (default: 0.5)The effective minimum distance between embedded points. Smaller values; will result in a more clustered/clumped embedding where nearby points on; the manifold are drawn closer together, while larger values will result; on a more even dispersal of points. The value should be set relative to; the spread value, which determines the scale at which embedded; points will be spread out. The default of in the umap-learn package is; 0.1. spread float (default: 1.0)The effective scale of embedded points. In combination with min_dist; this determines how clustered/clumped the embedded points are. n_components int (default: 2)The number of dimensions of the embedding. maxiter int | None (default: None)The number of iterations (epochs) of the optimization. Called n_epochs; in the original UMAP. alpha float (default: 1.0)The initial learning rate for the embedding optimization. gamma float (default: 1.0)Weighting applied to negative samples in low dimensional embedding; optimization. Values higher than one will result in greater weight; being given to negative samples. negative_sample_rate int (default: 5)The number of negative edge/1-simplex samples to use per positive; edge/1-simplex sample in optimizing the low dimensional embedding. init_pos Union[Literal['paga', 'spectral', 'random'], ndarray, None] (default: 'spectral')How to initialize the low dimensional embedding. Called init in the; original UMAP. Options are:. Any key for adata.obsm.; ’paga’: positions from paga().; ’spectral’: use a spectral embedding of the graph.; ’random’: assign initial embedding positions at random.; A numpy array of initial embedding positions. random_state Union[int, RandomState, None] (default: 0)If int, random_state is the seed used by the random number generator;; If RandomState or Generator, random_state is the random number generator;; If ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.umap.html:11163,optimiz,optimization,11163,en/stable/generated/scanpy.tl.umap.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.umap.html,1,['optimiz'],['optimization']
Performance,. scanpy._settings.ScanpyConfig.cachedir — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy._settings.ScanpyConfig.cachedir.html:32,cache,cachedir,32,en/stable/generated/scanpy._settings.ScanpyConfig.cachedir.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy._settings.ScanpyConfig.cachedir.html,1,['cache'],['cachedir']
Performance,".1:43387/status. Memory: 42.67 GiB; . Nanny: tcp://127.0.0.1:42555; . Local directory: /tmp/dask-scratch-space/worker-a11nkkx1; . . Worker: 2. Comm: tcp://127.0.0.1:36599; . Total threads: 6; . Dashboard: http://127.0.0.1:39033/status. Memory: 42.67 GiB; . Nanny: tcp://127.0.0.1:45463; . Local directory: /tmp/dask-scratch-space/worker-mcr71xvg; . We’ll convert the X representation to dask using anndata.experimental.read_elem_as_dask.; The file we’ve retrieved from cellxgene has already been processed. Since this tutorial is demonstrating processing from counts, we’re just going to access the counts matrix and annotations. %%time; with h5py.File(""cell_atlas.h5ad"", ""r"") as f:; adata = ad.AnnData(; obs=ad.experimental.read_elem(f[""obs""]),; var=ad.experimental.read_elem(f[""var""]),; ); adata.X = ad.experimental.read_elem_as_dask(; f[""raw/X""], chunks=(SPARSE_CHUNK_SIZE, adata.shape[1]); ). CPU times: user 2.4 s, sys: 673 ms, total: 3.08 s; Wall time: 3.22 s. We’ve optimized a number of scanpy functions to be completely lazy. That means it will look like nothing is computed when you call an operation on a dask array, but only later when you hit compute.; In some cases it’s currently unavoidable to skip all computation, and these cases will kick off compute for all the delayed operations immediately. %%time; adata.layers[""counts""] = adata.X.copy() # Making sure we keep access to the raw counts; sc.pp.normalize_total(adata, target_sum=1e4). CPU times: user 7.1 ms, sys: 31 μs, total: 7.13 ms; Wall time: 7.49 ms. %%time; sc.pp.log1p(adata). CPU times: user 3.14 ms, sys: 2.03 ms, total: 5.17 ms; Wall time: 4.88 ms. Highly variable genes needs to add entries into obs, which currently does not support lazy column. So computation will occur immediately on call. %%time; sc.pp.highly_variable_genes(adata). CPU times: user 3.46 s, sys: 509 ms, total: 3.97 s; Wall time: 50 s. PCA currently does not support sparse data. So we will need to densify the expression matrix before passing it",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/dask.html:14178,optimiz,optimized,14178,en/stable/tutorials/experimental/dask.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/dask.html,2,['optimiz'],['optimized']
Performance,".cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .md. .pdf. Settings. Settings#; A convenience function for setting some default matplotlib.rcParams and a; high-resolution jupyter display backend useful for use in notebooks. set_figure_params; Set resolution/size, styling and format of figures. An instance of the ScanpyConfig is available as scanpy.settings and allows configuring Scanpy. _settings.ScanpyConfig; Config manager for scanpy. Some selected settings are discussed in the following.; Influence the global behavior of plotting functions. In non-interactive scripts,; you’d usually want to set settings.autoshow to False. autoshow; Automatically show figures if autosave == False (default True). autosave; Automatically save figures in figdir (default False). The default directories for saving figures, caching files and storing datasets. figdir; Directory for saving figures (default './figures/'). cachedir; Directory for cache files (default './cache/'). datasetdir; Directory for example datasets (default './data/'). The verbosity of logging output, where verbosity levels have the following; meaning: 0=’error’, 1=’warning’, 2=’info’, 3=’hint’, 4=more details, 5=even more; details, etc. verbosity; Verbosity level (default warning). Print versions of packages that might influence numerical results. logging.print_header; Versions that might influence the numerical results. logging.print_versions; Print versions of imported packages, OS, and jupyter environment. previous; scanpy.Neighbors.to_igraph. next; scanpy.set_figure_params. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/settings.html:10069,cache,cachedir,10069,en/stable/api/settings.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/settings.html,3,['cache'],"['cache', 'cachedir']"
Performance,".external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.tl.embedding_density. Contents . embedding_density(). scanpy.tl.embedding_density#. scanpy.tl.embedding_density(adata, basis='umap', *, groupby=None, key_added=None, components=None)[source]#; Calculate the density of cells in an embedding (per condition).; Gaussian kernel density estimation is used to calculate the density of; cells in an embedded space. This can be performed per category over a; categorical cell annotation. The cell density can be plotted using the; pl.embedding_density function.; Note that density values are scaled to be between 0 and 1. Thus, the; density value at each cell is only comparable to densities in; the same category.; Beware that the KDE estimate used (scipy.stats.gaussian_kde) becomes; unreliable if you don’t have enough cells in a category.; This function was written by Sophie Tritschler and implemented into; Scanpy by Malte Luecken. Parameters:. adata AnnDataThe annotated data matrix. basis str (default: 'umap')The embedding over which the density will be calculated. This embedded; representation should be found in adata.obsm['X_[basis]']`. groupby str | None (default: None)Key for categorical observation/cell annotation for which densities; are calculated per category. key_added str | None (default: None)Name of the .obs covariate that will be added with the density; estimates. components str | Sequence[str] | None (default: None)The e",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.embedding_density.html:9613,perform,performed,9613,en/stable/generated/scanpy.tl.embedding_density.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.embedding_density.html,1,['perform'],['performed']
Performance,".pp.hashsolo; scanpy.external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .ipynb. .pdf. How to preprocess UMI count data with analytic Pearson residuals. Contents . Background; Preparations; Download data; Load data. Perform Quality control; Basic filtering; Compute quality control metrics; Plot quality control metrics. Use Pearson residuals for selection of highly variable genes; Compute 2000 variable genes with Pearson residuals; Plot gene selection; Apply gene selection; Print resulting adata objects. Transforming raw counts to Pearson residuals; Preparations; Compute Pearson residuals; Compute PCA and t-SNE; Compute Neighborhood graph and Leiden clustering; Plot Leiden clusters on tSNE and PBMC marker genes. Optional input arguments; Overdispersion parameter theta; Clipping threshold clip; chunksize and best practice to obtain Pearson residuals for large datasets. Wrapper functions for Pearson residuals preprocessing; References / See also. How to preprocess UMI count data with analytic Pearson residuals#; With version 1.9, scanpy introduces new preprocessing functions based on Pearson residuals into the experimental.pp module. These functions implement the core steps of the preprocessing described and benchmarked in Lause et al. (2021).; In the",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:9405,Perform,Perform,9405,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,1,['Perform'],['Perform']
Performance,".read. Contents . read(). scanpy.read#. scanpy.read(filename, backed=None, *, sheet=None, ext=None, delimiter=None, first_column_names=False, backup_url=None, cache=False, cache_compression=_empty, **kwargs)[source]#; Read file and return AnnData object.; To speed up reading, consider passing cache=True, which creates an hdf5; cache file. Parameters:. filename Path | strIf the filename has no file extension, it is interpreted as a key for; generating a filename via sc.settings.writedir / (filename +; sc.settings.file_format_data). This is the same behavior as in; sc.read(filename, ...). backed Optional[Literal['r', 'r+']] (default: None)If 'r', load AnnData in backed mode instead; of fully loading it into memory (memory mode). If you want to modify; backed attributes of the AnnData object, you need to choose 'r+'. sheet str | None (default: None)Name of sheet/table in hdf5 or Excel file. ext str | None (default: None)Extension that indicates the file type. If None, uses extension of; filename. delimiter str | None (default: None)Delimiter that separates data within text file. If None, will split at; arbitrary number of white spaces, which is different from enforcing; splitting at any single white space ' '. first_column_names bool (default: False)Assume the first column stores row names. This is only necessary if; these are not strings: strings in the first column are automatically; assumed to be row names. backup_url str | None (default: None)Retrieve the file from an URL if not present on disk. cache bool (default: False)If False, read from source, if True, read from fast ‘h5ad’ cache. cache_compression Union[Literal['gzip', 'lzf'], None, Empty] (default: _empty)See the h5py Filter pipeline.; (Default: settings.cache_compression). kwargsParameters passed to read_loom(). Return type:; AnnData. Returns:; An AnnData object. previous; Reading. next; scanpy.read_10x_h5. Contents; . read(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.read.html:10748,cache,cache,10748,en/stable/generated/scanpy.read.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.read.html,2,['cache'],['cache']
Performance,".tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.read_visium. Contents . read_visium(). scanpy.read_visium#. scanpy.read_visium(path, genome=None, *, count_file='filtered_feature_bc_matrix.h5', library_id=None, load_images=True, source_image_path=None)[source]#; Read 10x-Genomics-formatted visum dataset.; In addition to reading regular 10x output,; this looks for the spatial folder and loads images,; coordinates and scale factors.; Based on the Space Ranger output docs.; See spatial() for a compatible plotting function. Parameters:. path Path | strPath to directory for visium datafiles. genome str | None (default: None)Filter expression to genes within this genome. count_file str (default: 'filtered_feature_bc_matrix.h5')Which file in the passed directory to use as the count file. Typically would be one of:; ‘filtered_feature_bc_matrix.h5’ or ‘raw_feature_bc_matrix.h5’. library_id str | None (default: None)Identifier for the visium library. Can be modified when concatenating multiple adata objects. source_image_path Path | str | None (default: None)Path to the high-resolution tissue image. Path will be included in; .uns[""spatial""][library_id][""metadata""][""source_image_path""]. Return type:; AnnData. Returns:; Annotated data matrix, where observations/cells are named by their; barcode and variables/genes by gene name. Stores the following information",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.read_visium.html:9574,load,loads,9574,en/stable/generated/scanpy.read_visium.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.read_visium.html,1,['load'],['loads']
Performance,"17-11-16. Version 0.2; 0.2.9 2017-10-25; Initial release of the new trajectory inference method PAGA. 0.2.1 2017-07-24. Version 0.1; 0.1.0 2017-05-17. Release notes#. Version 1.10#. 1.10.3 2024-09-17#. Bug fixes#. Prevent empty control gene set in score_genes() M Müller (pr2875); Fix subset=True of highly_variable_genes() when flavor is seurat or cell_ranger, and batch_key!=None E Roellin (pr3042); Add compatibility with numpy 2.0 P Angerer pr3065 and (pr3115); Fix legend_loc argument in scanpy.pl.embedding() not accepting matplotlib parameters P Angerer (pr3163); Fix dispersion cutoff in highly_variable_genes() in presence of NaNs P Angerer (pr3176); Fix axis labeling for swapped axes in rank_genes_groups_stacked_violin() Ilan Gold (pr3196); Upper bound dask on account of issuescverse/anndata#1579 Ilan Gold (pr3217); The fa2-modified package replaces forceatlas2 for the latter’s lack of maintenance A Alam (pr3220). 1.10.2 2024-06-25#. Development Process#. Add performance benchmarking pr2977 R Shrestha, P Angerer. Documentation#. Document several missing parameters in docstring pr2888 S Cheney; Fixed incorrect instructions in “testing” dev docs pr2994 I Virshup; Update marsilea tutorial to use group_ methods pr3001 I Virshup; Fixed citations pr3032 P Angerer; Improve dataset documentation pr3060 P Angerer. Bug fixes#. Compatibility with matplotlib 3.9 pr2999 I Virshup; Add clear errors where backed mode-like matrices (i.e., from sparse_dataset) are not supported pr3048 I gold; Write out full pca results when _choose_representation is called i.e., neighbors() without pca() pr3079 I gold; Fix deprecated use of .A with sparse matrices pr3084 P Angerer; Fix zappy support pr3089 P Angerer; Fix dotplot group order with pandas 1.x pr3101 P Angerer. Performance#. sparse_mean_variance_axis now uses all cores for the calculations pr3015 S Dicks; pp.highly_variable_genes with flavor=seurat_v3 now uses a numba kernel pr3017 S Dicks; Speed up scrublet() pr3044 S Dicks and pr3056",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:12578,perform,performance,12578,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,1,['perform'],['performance']
Performance,"18 to 0.19 changed the implementation of PCA,; some results might therefore look slightly different. Further updates#. UMAP [McInnes et al., 2018] can serve as a first visualization of the data just as tSNE,; in contrast to tSNE, UMAP directly embeds the single-cell graph and is faster;; UMAP is also used for measuring connectivities and computing neighbors,; see neighbors() A Wolf; graph abstraction: AGA is renamed to PAGA: paga(); now,; it only measures connectivities between partitions of the single-cell graph,; pseudotime and clustering need to be computed separately via; louvain() and dpt(), the; connectivity measure has been improved A Wolf; logistic regression for finding marker genes; rank_genes_groups() with parameter method='logreg' A Wolf; louvain() provides a better implementation for; reclustering via restrict_to A Wolf; scanpy no longer modifies rcParams upon import, call; settings.set_figure_params to set the ‘scanpy style’ A Wolf; default cache directory is ./cache/, set settings.cachedir to change; this; nested directories in this are avoided A Wolf; show edges in scatter plots based on graph visualization; draw_graph() and umap() by passing edges=True A Wolf; downsample_counts() for downsampling counts MD Luecken; default 'louvain_groups' are called 'louvain' A Wolf; 'X_diffmap' contains the zero component, plotting remains unchanged A Wolf. Version 0.4#. 0.4.4 2018-02-26#. embed cells using umap() [McInnes et al., 2018] pr92 G Eraslan; score sets of genes, e.g. for cell cycle, using score_genes() [Satija et al., 2015]:; notebook. 0.4.3 2018-02-09#. clustermap(): heatmap from hierarchical clustering,; based on seaborn.clustermap() [Waskom et al., 2016] A Wolf; only return matplotlib.axes.Axes in plotting functions of sc.pl; when show=False, otherwise None A Wolf. 0.4.2 2018-01-07#. amendments in PAGA and its plotting functions A Wolf. 0.4.0 2017-12-23#. export to SPRING [Weinreb et al., 2017] for interactive visualization of data:; spring tutorial ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:50429,cache,cache,50429,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,1,['cache'],['cache']
Performance,"4555ba4 anndata==0.11.0.dev78+g64ab900 umap==0.5.5 numpy==1.26.3 scipy==1.11.4 pandas==2.2.0 scikit-learn==1.3.2 statsmodels==0.14.1 igraph==0.10.8 pynndescent==0.5.11. Download data#; This tutorial uses two 10X datasets that are processed in parallel:. the 3k PBMC (v1 chemistry) dataset; the 10k PBMC (v3 chemistry) dataset. Uncomment this cell to create directories, download and unpack the data:. # !mkdir tutorial_data; # !mkdir tutorial_data/pbmc3k_v1; # !mkdir tutorial_data/pbmc10k_v3. # !wget http://cf.10xgenomics.com/samples/cell-exp/1.1.0/pbmc3k/pbmc3k_filtered_gene_bc_matrices.tar.gz -O tutorial_data/pbmc3k_v1.tar.gz; # !cd tutorial_data; tar -xzf pbmc3k_v1.tar.gz -C pbmc3k_v1 --strip-components 2. # !wget https://cf.10xgenomics.com/samples/cell-exp/3.0.0/pbmc_10k_v3/pbmc_10k_v3_filtered_feature_bc_matrix.tar.gz -O tutorial_data/pbmc10k_v3.tar.gz; # !cd tutorial_data; tar -xzf pbmc10k_v3.tar.gz -C pbmc10k_v3 --strip-components 1. Load data#; Here we load the two downloaded datasets from disk and create AnnData objects for them. adata_pbmc3k = sc.read_10x_mtx(""tutorial_data/pbmc3k_v1/"", cache=True); adata_pbmc10k = sc.read_10x_mtx(""tutorial_data/pbmc10k_v3/"", cache=True). adata_pbmc3k.uns[""name""] = ""PBMC 3k (v1)""; adata_pbmc10k.uns[""name""] = ""PBMC 10k (v3)"". ... writing an h5ad cache file to speedup reading next time; ... writing an h5ad cache file to speedup reading next time. To demonstrate that Pearson residuals select meaningful genes on these PBMC datasets, we will compare the gene selection to a set of marker genes that were identified in the PBMC3k tutorial. They map to PBMC cell types as follows:; ['IL7R', # CD4 T cells; 'LYZ', 'CD14', # CD14+ Monocytes; 'MS4A1', # B cells; 'CD8A', # CD8 T cells; 'GNLY', 'NKG7', # NK cells; 'FCGR3A', 'MS4A7', # FCGR3A+ Monocytes; 'FCER1A', 'CST3', # Dendritic Cells; 'PPBP'] # Megakaryocytes. A good gene selection should include these differentially expressed genes. # marker genes from table in pbmc3k tutorial; markers ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:12967,load,load,12967,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,3,"['Load', 'load']","['Load', 'load']"
Performance,"88 ms. Highly variable genes needs to add entries into obs, which currently does not support lazy column. So computation will occur immediately on call. %%time; sc.pp.highly_variable_genes(adata). CPU times: user 3.46 s, sys: 509 ms, total: 3.97 s; Wall time: 50 s. PCA currently does not support sparse data. So we will need to densify the expression matrix before passing it in. However, as we are working with only a subset of the data at a time, we are able to perform this operation with a lower memory overhead.; As this is a still a significant increase in memory usage per chunk, we will need to reduce the number of observations present in each chunk. adata.layers[""dense""] = adata.X.rechunk((DENSE_CHUNK_SIZE, -1)).map_blocks(; lambda x: x.toarray(), dtype=adata.X.dtype, meta=np.array([]); ). %%time; sc.pp.pca(adata, layer=""dense""). CPU times: user 9.31 s, sys: 1.19 s, total: 10.5 s; Wall time: 1min 27s. While most of the PCA computation runs immediately, the last step (computing the observation loadings) is lazy, so must be triggered manually to avoid recomputation. %%time; adata.obsm[""X_pca""] = adata.obsm[""X_pca""].compute(). CPU times: user 6.72 s, sys: 1.36 s, total: 8.08 s; Wall time: 1min 15s. adata. AnnData object with n_obs × n_vars = 1462702 × 27714; obs: 'celltype', 'majorType', 'City', 'sampleID', 'donor_id', 'Sample type', 'CoVID-19 severity', 'Sample time', 'Sampling day (Days after symptom onset)', 'BCR single cell sequencing', 'TCR single cell sequencing', 'Outcome', 'Comorbidities', 'COVID-19-related medication and anti-microbials', 'Leukocytes [G over L]', 'Neutrophils [G over L]', 'Lymphocytes [G over L]', 'Unpublished', 'disease_ontology_term_id', 'cell_type_ontology_term_id', 'tissue_ontology_term_id', 'development_stage_ontology_term_id', 'self_reported_ethnicity_ontology_term_id', 'assay_ontology_term_id', 'sex_ontology_term_id', 'is_primary_data', 'organism_ontology_term_id', 'suspension_type', 'tissue_type', 'cell_type', 'assay', 'disease', 'o",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/dask.html:15840,load,loadings,15840,en/stable/tutorials/experimental/dask.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/dask.html,2,['load'],['loadings']
Performance,": 30)The perplexity is related to the number of nearest neighbors that; is used in other manifold learning algorithms. Larger datasets; usually require a larger perplexity. Consider selecting a value; between 5 and 50. The choice is not extremely critical since t-SNE; is quite insensitive to this parameter. metric str (default: 'euclidean')Distance metric calculate neighbors on. early_exaggeration float | int (default: 12)Controls how tight natural clusters in the original space are in the; embedded space and how much space will be between them. For larger; values, the space between natural clusters will be larger in the; embedded space. Again, the choice of this parameter is not very; critical. If the cost function increases during initial optimization,; the early exaggeration factor or the learning rate might be too high. learning_rate float | int (default: 1000)Note that the R-package “Rtsne” uses a default of 200.; The learning rate can be a critical parameter. It should be; between 100 and 1000. If the cost function increases during initial; optimization, the early exaggeration factor or the learning rate; might be too high. If the cost function gets stuck in a bad local; minimum increasing the learning rate helps sometimes. random_state Union[int, RandomState, None] (default: 0)Change this to use different intial states for the optimization.; If None, the initial state is not reproducible. n_jobs int | None (default: None)Number of jobs for parallel computation.; None means using scanpy._settings.ScanpyConfig.n_jobs. copy bool (default: False)Return a copy instead of writing to adata. Return type:; AnnData | None. Returns:; Returns None if copy=False, else returns an AnnData object. Sets the following fields:. adata.obsm['X_tsne']numpy.ndarray (dtype float)tSNE coordinates of data. adata.uns['tsne']dicttSNE parameters. previous; Tools: tl. next; scanpy.tl.umap. Contents; . tsne(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.tsne.html:11519,optimiz,optimization,11519,en/stable/generated/scanpy.tl.tsne.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.tsne.html,2,['optimiz'],['optimization']
Performance,"; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy._settings.ScanpyConfig. Contents . ScanpyConfig. scanpy._settings.ScanpyConfig#. class scanpy._settings.ScanpyConfig(*, verbosity=Verbosity.warning, plot_suffix='', file_format_data='h5ad', file_format_figs='pdf', autosave=False, autoshow=True, writedir='./write/', cachedir='./cache/', datasetdir='./data/', figdir='./figures/', cache_compression='lzf', max_memory=15, n_jobs=1, logfile=None, categories_to_ignore=('N/A', 'dontknow', 'no_gate', '?'), _frameon=True, _vector_friendly=False, _low_resolution_warning=True, n_pcs=50)[source]#; Config manager for scanpy.; Attributes. autosave; Automatically save figures in figdir (default False). autoshow; Automatically show figures if autosave == False (default True). cache_compression; Compression for sc.read(..., cache=True) (default 'lzf'). cachedir; Directory for cache files (default './cache/'). categories_to_ignore; Categories that are omitted in plotting etc. datasetdir; Directory for example datasets (default './data/'). figdir; Directory for saving figures (default './figures/'). file_format_data; File format for saving AnnData objects. file_format_figs; File format for saving figures. logfile; The open file to write logs to. logpath; The file path logfile was set to. max_memory; Maximum memory usage in Gigabyte. n_jobs; Default number of jobs/ CPUs to use for parallel computing. plot_suffix; Global suffix that is appended to figure filenames. verbosity; Verbosity level (default warning). writedir; Directory where the function scanpy.write writes to by default. N_PCS; Default number of principal components to use. Methods. set_figure_params(*[, scanpy, dpi, ...]); Set resolution/size, styling and format of figures. previous; scanpy.set_figure_params. next; scanpy._settings.ScanpyConfig.autosave. Contents; . ScanpyConfig. By Scanpy development team. ; © Copyright 2024",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy._settings.ScanpyConfig.html:10089,cache,cache,10089,en/stable/generated/scanpy._settings.ScanpyConfig.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy._settings.ScanpyConfig.html,1,['cache'],['cache']
Performance,"; References. .rst. .pdf. scanpy.tl.leiden. Contents . leiden(). scanpy.tl.leiden#. scanpy.tl.leiden(adata, resolution=1, *, restrict_to=None, random_state=0, key_added='leiden', adjacency=None, directed=None, use_weights=True, n_iterations=-1, partition_type=None, neighbors_key=None, obsp=None, copy=False, flavor='leidenalg', **clustering_args)[source]#; Cluster cells into subgroups [Traag et al., 2019].; Cluster cells using the Leiden algorithm [Traag et al., 2019],; an improved version of the Louvain algorithm [Blondel et al., 2008].; It has been proposed for single-cell analysis by Levine et al. [2015].; This requires having ran neighbors() or; bbknn() first. Parameters:. adata AnnDataThe annotated data matrix. resolution float (default: 1)A parameter value controlling the coarseness of the clustering.; Higher values lead to more clusters.; Set to None if overriding partition_type; to one that doesn’t accept a resolution_parameter. random_state Union[int, RandomState, None] (default: 0)Change the initialization of the optimization. restrict_to tuple[str, Sequence[str]] | None (default: None)Restrict the clustering to the categories within the key for sample; annotation, tuple needs to contain (obs_key, list_of_categories). key_added str (default: 'leiden')adata.obs key under which to add the cluster labels. adjacency spmatrix | None (default: None)Sparse adjacency matrix of the graph, defaults to neighbors connectivities. directed bool | None (default: None)Whether to treat the graph as directed or undirected. use_weights bool (default: True)If True, edge weights from the graph are used in the computation; (placing more emphasis on stronger edges). n_iterations int (default: -1)How many iterations of the Leiden clustering algorithm to perform.; Positive values above 2 define the total number of iterations to perform,; -1 has the algorithm run until it reaches its optimal clustering.; 2 is faster and the default for underlying packages. partition_type type[Mutabl",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.leiden.html:10237,optimiz,optimization,10237,en/stable/generated/scanpy.tl.leiden.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.leiden.html,1,['optimiz'],['optimization']
Performance,"; dimensions=[(0, 1), (2, 3), (0, 1), (2, 3)],; ncols=2,; size=2,; ). Nearest neighbor graph constuction and visualization#; Let us compute the neighborhood graph of cells using the PCA representation of the data matrix. sc.pp.neighbors(adata). This graph can then be embedded in two dimensions for visualiztion with UMAP (McInnes et al., 2018):. sc.tl.umap(adata). We can now visualize the UMAP according to the sample. sc.pl.umap(; adata,; color=""sample"",; # Setting a smaller point size to get prevent overlap; size=2,; ). Even though the data considered in this tutorial includes two different samples, we only observe a minor batch effect and we can continue with clustering and annotation of our data.; If you inspect batch effects in your UMAP it can be beneficial to integrate across samples and perform batch correction/integration. We recommend checking out scanorama and scvi-tools for batch integration. Clustering#; As with Seurat and many other frameworks, we recommend the Leiden graph-clustering method (community detection based on optimizing modularity) [Traag et al., 2019]. Note that Leiden clustering directly clusters the neighborhood graph of cells, which we already computed in the previous section. # Using the igraph implementation and a fixed number of iterations can be significantly faster, especially for larger datasets; sc.tl.leiden(adata, flavor=""igraph"", n_iterations=2). sc.pl.umap(adata, color=[""leiden""]). Re-assess quality control and cell filtering#; As indicated before, we will now re-assess our filtering strategy by visualizing different QC metrics using UMAP. sc.pl.umap(; adata,; color=[""leiden"", ""predicted_doublet"", ""doublet_score""],; # increase horizontal space between panels; wspace=0.5,; size=3,; ). sc.pl.umap(; adata,; color=[""leiden"", ""log1p_total_counts"", ""pct_counts_mt"", ""log1p_n_genes_by_counts""],; wspace=0.5,; ncols=2,; ). Manual cell-type annotation#. Note; This section of the tutorial is expanded upon using prior knowledge resources lik",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering.html:17485,optimiz,optimizing,17485,en/stable/tutorials/basics/clustering.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering.html,2,['optimiz'],['optimizing']
Performance,; scanpy.queries.enrich. Metrics; scanpy.metrics.confusion_matrix; scanpy.metrics.gearys_c; scanpy.metrics.morans_i. Experimental; scanpy.experimental.pp.normalize_pearson_residuals; scanpy.experimental.pp.normalize_pearson_residuals_pca; scanpy.experimental.pp.highly_variable_genes; scanpy.experimental.pp.recipe_pearson_residuals. Classes; scanpy.Neighbors; scanpy.Neighbors.connectivities; scanpy.Neighbors.distances; scanpy.Neighbors.distances_dpt; scanpy.Neighbors.eigen_basis; scanpy.Neighbors.eigen_values; scanpy.Neighbors.rp_forest; scanpy.Neighbors.transitions; scanpy.Neighbors.transitions_sym; scanpy.Neighbors.compute_eigen; scanpy.Neighbors.compute_neighbors; scanpy.Neighbors.compute_transitions; scanpy.Neighbors.getdoc; scanpy.Neighbors.to_igraph. Settings; scanpy.set_figure_params; scanpy._settings.ScanpyConfig; scanpy._settings.ScanpyConfig.autosave; scanpy._settings.ScanpyConfig.autoshow; scanpy._settings.ScanpyConfig.cache_compression; scanpy._settings.ScanpyConfig.cachedir; scanpy._settings.ScanpyConfig.categories_to_ignore; scanpy._settings.ScanpyConfig.datasetdir; scanpy._settings.ScanpyConfig.figdir; scanpy._settings.ScanpyConfig.file_format_data; scanpy._settings.ScanpyConfig.file_format_figs; scanpy._settings.ScanpyConfig.logfile; scanpy._settings.ScanpyConfig.logpath; scanpy._settings.ScanpyConfig.max_memory; scanpy._settings.ScanpyConfig.n_jobs; scanpy._settings.ScanpyConfig.plot_suffix; scanpy._settings.ScanpyConfig.verbosity; scanpy._settings.ScanpyConfig.writedir; scanpy._settings.ScanpyConfig.N_PCS; scanpy._settings.ScanpyConfig.set_figure_params. scanpy.logging.print_header; scanpy.logging.print_versions. Datasets; scanpy.datasets.blobs; scanpy.datasets.ebi_expression_atlas; scanpy.datasets.krumsiek11; scanpy.datasets.moignard15; scanpy.datasets.pbmc3k; scanpy.datasets.pbmc3k_processed; scanpy.datasets.pbmc68k_reduced; scanpy.datasets.paul15; scanpy.datasets.toggleswitch; scanpy.datasets.visium_sge. Deprecated functions; scanpy.pp.filter_gene,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/community.html:7163,cache,cachedir,7163,en/stable/community.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/community.html,423,['cache'],['cachedir']
Performance,"==1.3.2 statsmodels==0.14.1 igraph==0.10.8 pynndescent==0.5.11. Download data#; This tutorial uses two 10X datasets that are processed in parallel:. the 3k PBMC (v1 chemistry) dataset; the 10k PBMC (v3 chemistry) dataset. Uncomment this cell to create directories, download and unpack the data:. # !mkdir tutorial_data; # !mkdir tutorial_data/pbmc3k_v1; # !mkdir tutorial_data/pbmc10k_v3. # !wget http://cf.10xgenomics.com/samples/cell-exp/1.1.0/pbmc3k/pbmc3k_filtered_gene_bc_matrices.tar.gz -O tutorial_data/pbmc3k_v1.tar.gz; # !cd tutorial_data; tar -xzf pbmc3k_v1.tar.gz -C pbmc3k_v1 --strip-components 2. # !wget https://cf.10xgenomics.com/samples/cell-exp/3.0.0/pbmc_10k_v3/pbmc_10k_v3_filtered_feature_bc_matrix.tar.gz -O tutorial_data/pbmc10k_v3.tar.gz; # !cd tutorial_data; tar -xzf pbmc10k_v3.tar.gz -C pbmc10k_v3 --strip-components 1. Load data#; Here we load the two downloaded datasets from disk and create AnnData objects for them. adata_pbmc3k = sc.read_10x_mtx(""tutorial_data/pbmc3k_v1/"", cache=True); adata_pbmc10k = sc.read_10x_mtx(""tutorial_data/pbmc10k_v3/"", cache=True). adata_pbmc3k.uns[""name""] = ""PBMC 3k (v1)""; adata_pbmc10k.uns[""name""] = ""PBMC 10k (v3)"". ... writing an h5ad cache file to speedup reading next time; ... writing an h5ad cache file to speedup reading next time. To demonstrate that Pearson residuals select meaningful genes on these PBMC datasets, we will compare the gene selection to a set of marker genes that were identified in the PBMC3k tutorial. They map to PBMC cell types as follows:; ['IL7R', # CD4 T cells; 'LYZ', 'CD14', # CD14+ Monocytes; 'MS4A1', # B cells; 'CD8A', # CD8 T cells; 'GNLY', 'NKG7', # NK cells; 'FCGR3A', 'MS4A7', # FCGR3A+ Monocytes; 'FCER1A', 'CST3', # Dendritic Cells; 'PPBP'] # Megakaryocytes. A good gene selection should include these differentially expressed genes. # marker genes from table in pbmc3k tutorial; markers = [; ""IL7R"",; ""LYZ"",; ""CD14"",; ""MS4A1"",; ""CD8A"",; ""GNLY"",; ""NKG7"",; ""FCGR3A"",; ""MS4A7"",; ""FCER1A"",; ""CST3""",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:13106,cache,cache,13106,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,2,['cache'],['cache']
Performance,"C metrics) driving signifigant variation in this dataset. In this case, there isn’t anything too alarming, but it’s a good idea to explore this. sc.pl.pca(; adata,; color=[""sample"", ""sample"", ""pct_counts_mt"", ""pct_counts_mt""],; dimensions=[(0, 1), (2, 3), (0, 1), (2, 3)],; ncols=2,; size=2,; ). Nearest neighbor graph constuction and visualization#; Let us compute the neighborhood graph of cells using the PCA representation of the data matrix. sc.pp.neighbors(adata). This graph can then be embedded in two dimensions for visualiztion with UMAP (McInnes et al., 2018):. sc.tl.umap(adata). We can now visualize the UMAP according to the sample. sc.pl.umap(; adata,; color=""sample"",; # Setting a smaller point size to get prevent overlap; size=2,; ). Even though the data considered in this tutorial includes two different samples, we only observe a minor batch effect and we can continue with clustering and annotation of our data.; If you inspect batch effects in your UMAP it can be beneficial to integrate across samples and perform batch correction/integration. We recommend checking out scanorama and scvi-tools for batch integration. Clustering#; As with Seurat and many other frameworks, we recommend the Leiden graph-clustering method (community detection based on optimizing modularity) [Traag et al., 2019]. Note that Leiden clustering directly clusters the neighborhood graph of cells, which we already computed in the previous section. # Using the igraph implementation and a fixed number of iterations can be significantly faster, especially for larger datasets; sc.tl.leiden(adata, flavor=""igraph"", n_iterations=2). sc.pl.umap(adata, color=[""leiden""]). Re-assess quality control and cell filtering#; As indicated before, we will now re-assess our filtering strategy by visualizing different QC metrics using UMAP. sc.pl.umap(; adata,; color=[""leiden"", ""predicted_doublet"", ""doublet_score""],; # increase horizontal space between panels; wspace=0.5,; size=3,; ). sc.pl.umap(; adata,; co",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering.html:17240,perform,perform,17240,en/stable/tutorials/basics/clustering.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering.html,2,['perform'],['perform']
Performance,"Data integration and label transfer from scRNA-seq dataset#; We can also perform data integration between one scRNA-seq dataset and one spatial transcriptomics dataset. Such task is particularly useful because it allows us to transfer cell type labels to the Visium dataset, which were dentified from the scRNA-seq dataset.; For this task, we will be using a dataset from Tasic et al., where the mouse cortex was profiled with smart-seq technology.; The dataset can be downloaded from GEO count - metadata.; Conveniently, you can also download the pre-processed dataset in h5ad format from here.; Since the dataset was generated from the mouse cortex, we will subset the visium dataset in order to select only the spots part of the cortex. Note that the integration can also be performed on the whole brain slice, but it would give rise to false positive cell type assignments and and therefore it should be interpreted with more care.; The integration task will be performed with Scanorama: each Visium dataset will be integrated with the smart-seq cortex dataset.; The following cell should be uncommented out and run if this is the first time running this notebook. if not Path(""./data/adata_processed.h5ad"").exists():; !wget https://ftp.ncbi.nlm.nih.gov/geo/series/GSE115nnn/GSE115746/suppl/GSE115746_cells_exon_counts.csv.gz -O data/GSE115746_cells_exon_counts.csv.gz; !gunzip data/GSE115746_cells_exon_counts.csv.gz; !wget https://ftp.ncbi.nlm.nih.gov/geo/series/GSE115nnn/GSE115746/suppl/GSE115746_complete_metadata_28706-cells.csv.gz -O data/GSE115746_complete_metadata_28706-cells.csv.gz; !gunzip data/GSE115746_complete_metadata_28706-cells.csv.gz; %pip install pybiomart; counts = pd.read_csv(""data/GSE115746_cells_exon_counts.csv"", index_col=0).T; meta = pd.read_csv(; ""data/GSE115746_complete_metadata_28706-cells.csv"", index_col=""sample_name""; ); meta = meta.loc[counts.index]; annot = sc.queries.biomart_annotations(; ""mmusculus"",; [""mgi_symbol"", ""ensembl_gene_id""],; ).set_index(""mgi_",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html:20303,perform,performed,20303,en/stable/tutorials/spatial/integration-scanorama.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html,2,['perform'],['performed']
Performance,"Download data#; This tutorial uses two 10X datasets that are processed in parallel:. the 3k PBMC (v1 chemistry) dataset; the 10k PBMC (v3 chemistry) dataset. Uncomment this cell to create directories, download and unpack the data:. # !mkdir tutorial_data; # !mkdir tutorial_data/pbmc3k_v1; # !mkdir tutorial_data/pbmc10k_v3. # !wget http://cf.10xgenomics.com/samples/cell-exp/1.1.0/pbmc3k/pbmc3k_filtered_gene_bc_matrices.tar.gz -O tutorial_data/pbmc3k_v1.tar.gz; # !cd tutorial_data; tar -xzf pbmc3k_v1.tar.gz -C pbmc3k_v1 --strip-components 2. # !wget https://cf.10xgenomics.com/samples/cell-exp/3.0.0/pbmc_10k_v3/pbmc_10k_v3_filtered_feature_bc_matrix.tar.gz -O tutorial_data/pbmc10k_v3.tar.gz; # !cd tutorial_data; tar -xzf pbmc10k_v3.tar.gz -C pbmc10k_v3 --strip-components 1. Load data#; Here we load the two downloaded datasets from disk and create AnnData objects for them. adata_pbmc3k = sc.read_10x_mtx(""tutorial_data/pbmc3k_v1/"", cache=True); adata_pbmc10k = sc.read_10x_mtx(""tutorial_data/pbmc10k_v3/"", cache=True). adata_pbmc3k.uns[""name""] = ""PBMC 3k (v1)""; adata_pbmc10k.uns[""name""] = ""PBMC 10k (v3)"". ... writing an h5ad cache file to speedup reading next time; ... writing an h5ad cache file to speedup reading next time. To demonstrate that Pearson residuals select meaningful genes on these PBMC datasets, we will compare the gene selection to a set of marker genes that were identified in the PBMC3k tutorial. They map to PBMC cell types as follows:; ['IL7R', # CD4 T cells; 'LYZ', 'CD14', # CD14+ Monocytes; 'MS4A1', # B cells; 'CD8A', # CD8 T cells; 'GNLY', 'NKG7', # NK cells; 'FCGR3A', 'MS4A7', # FCGR3A+ Monocytes; 'FCER1A', 'CST3', # Dendritic Cells; 'PPBP'] # Megakaryocytes. A good gene selection should include these differentially expressed genes. # marker genes from table in pbmc3k tutorial; markers = [; ""IL7R"",; ""LYZ"",; ""CD14"",; ""MS4A1"",; ""CD8A"",; ""GNLY"",; ""NKG7"",; ""FCGR3A"",; ""MS4A7"",; ""FCER1A"",; ""CST3"",; ""PPBP"",; ]. Perform Quality control#; First, we remove cells",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:13180,cache,cache,13180,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,2,['cache'],['cache']
Performance,"News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.pp.scale. Contents . scale(). scanpy.pp.scale#. scanpy.pp.scale(data, *, zero_center=True, max_value=None, copy=False, layer=None, obsm=None, mask_obs=None)[source]#; Scale data to unit variance and zero mean. Note; Variables (genes) that do not display any variation (are constant across; all observations) are retained and (for zero_center==True) set to 0; during this operation. In the future, they might be set to NaNs. Parameters:. data AnnData | spmatrix | ndarray | ArrayThe (annotated) data matrix of shape n_obs × n_vars.; Rows correspond to cells and columns to genes. zero_center bool (default: True)If False, omit zero-centering variables, which allows to handle sparse; input efficiently. max_value float | None (default: None)Clip (truncate) to this value after scaling. If None, do not clip. copy bool (default: False)Whether this function should be performed inplace. If an AnnData object; is passed, this also determines if a copy is returned. layer str | None (default: None)If provided, which element of layers to scale. obsm str | None (default: None)If provided, which element of obsm to scale. mask_obs ndarray[Any, dtype[bool]] | str | None (default: None)Restrict both the derivation of scaling parameters and the scaling itself; to a certain set of observations. The mask is specified as a boolean array; or a string referring to an array in obs.; This will transform data from csc to csr format if issparse(data). Return type:; AnnData | spmatrix | ndarray | Array | None. Returns:; Returns None if copy=False, else returns an updated AnnData object. Sets the following fields:. adata.X | adata.layers[layer]numpy.ndarray | scipy.sparse._csr.csr_matrix (dtype float)Scaled count data matrix. adata.var['mean']pandas.Series (dtype float)Means per gene before scaling. adata.var['std']pandas.Series (dtype float)Standard ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.scale.html:10096,perform,performed,10096,en/stable/generated/scanpy.pp.scale.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.scale.html,1,['perform'],['performed']
Performance,"ScanpyConfig.writedir; scanpy._settings.ScanpyConfig.N_PCS; scanpy._settings.ScanpyConfig.set_figure_params. scanpy.logging.print_header; scanpy.logging.print_versions. Datasets; scanpy.datasets.blobs; scanpy.datasets.ebi_expression_atlas; scanpy.datasets.krumsiek11; scanpy.datasets.moignard15; scanpy.datasets.pbmc3k; scanpy.datasets.pbmc3k_processed; scanpy.datasets.pbmc68k_reduced; scanpy.datasets.paul15; scanpy.datasets.toggleswitch; scanpy.datasets.visium_sge. Deprecated functions; scanpy.pp.filter_genes_dispersion; scanpy.pp.normalize_per_cell. External API; Preprocessing: PP; scanpy.external.pp.bbknn; scanpy.external.pp.harmony_integrate; scanpy.external.pp.mnn_correct; scanpy.external.pp.scanorama_integrate; scanpy.external.pp.hashsolo; scanpy.external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy._settings.ScanpyConfig.cachedir. Contents . ScanpyConfig.cachedir. scanpy._settings.ScanpyConfig.cachedir#. property ScanpyConfig.cachedir: Path[source]#; Directory for cache files (default './cache/'). previous; scanpy._settings.ScanpyConfig.cache_compression. next; scanpy._settings.ScanpyConfig.categories_to_ignore. Contents; . ScanpyConfig.cachedir. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy._settings.ScanpyConfig.cachedir.html:9277,cache,cachedir,9277,en/stable/generated/scanpy._settings.ScanpyConfig.cachedir.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy._settings.ScanpyConfig.cachedir.html,7,['cache'],"['cache', 'cachedir']"
Performance,"Types that end with “-conddisp”, assumes that dispersion is mean dependant. normalize_per_cell bool (default: True)If true, library size normalization is performed using; the sc.pp.normalize_per_cell function in Scanpy and saved into adata; object. Mean layer is re-introduces library size differences by; scaling the mean value of each cell in the output layer. See the; manuscript for more details. scale bool (default: True)If true, the input of the autoencoder is centered using; sc.pp.scale function of Scanpy. Note that the output is kept as raw; counts as loss functions are designed for the count data. log1p bool (default: True)If true, the input of the autoencoder is log transformed with a; pseudocount of one using sc.pp.log1p function of Scanpy. hidden_size Sequence[int] (default: (64, 32, 64))Width of hidden layers. hidden_dropout float | Sequence[float] (default: 0.0)Probability of weight dropout in the autoencoder (per layer if list; or tuple). batchnorm bool (default: True)If true, batch normalization is performed. activation str (default: 'relu')Activation function of hidden layers. init str (default: 'glorot_uniform')Initialization method used to initialize weights. network_kwds Mapping[str, Any] (default: mappingproxy({}))Additional keyword arguments for the autoencoder. epochs int (default: 300)Number of total epochs in training. reduce_lr int (default: 10)Reduces learning rate if validation loss does not improve in given number of epochs. early_stop int (default: 15)Stops training if validation loss does not improve in given number of epochs. batch_size int (default: 32)Number of samples in the batch used for SGD. optimizer str (default: 'RMSprop')Type of optimization method used for training. random_state Union[int, RandomState, None] (default: 0)Seed for python, numpy and tensorflow. threads int | None (default: None)Number of threads to use in training. All cores are used by default. learning_rate float | None (default: None)Learning rate to use in the",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.dca.html:11711,perform,performed,11711,en/stable/generated/scanpy.external.pp.dca.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.dca.html,1,['perform'],['performed']
Performance,"_group_labels` are different.; categories: 0, 1, 2, etc.; var_group_labels: 3. We see that CR2 recapitulates the spatial structure. sc.pl.spatial(adata, img_key=""hires"", color=[""clusters"", ""CR2""]). sc.pl.spatial(adata, img_key=""hires"", color=[""COL1A2"", ""SYPL1""], alpha=0.7). MERFISH example#; In case you have spatial data generated with FISH-based techniques, just read the cordinate table and assign it to the adata.obsm element.; Let’s take a look at the example from Xia et al. 2019.; First, we need to download the coordinate and counts data from the original publication: coordinates to ./data/pnas.1912459116.sd15.csv and counts to ./data/pnas.1912459116.sd12.csv. # If needed:; # %pip install openpyxl. coordinates = pd.read_excel(""./data/pnas.1912459116.sd15.xlsx"", index_col=0); counts = sc.read_csv(""./data/pnas.1912459116.sd12.csv"").transpose(). adata_merfish = counts[coordinates.index, :].copy(); adata_merfish.obsm[""spatial""] = coordinates.to_numpy(). We will perform standard preprocessing and dimensionality reduction. sc.pp.normalize_per_cell(adata_merfish, counts_per_cell_after=1e6); sc.pp.log1p(adata_merfish); sc.pp.pca(adata_merfish, n_comps=15); sc.pp.neighbors(adata_merfish); sc.tl.umap(adata_merfish); sc.tl.leiden(; adata_merfish,; key_added=""clusters"",; resolution=0.5,; n_iterations=2,; flavor=""igraph"",; directed=False,; ). normalizing by total count per cell; finished (0:00:00): normalized adata.X and added 'n_counts', counts per cell before normalization (adata.obs); computing PCA; with n_comps=15; finished (0:00:08); computing neighbors; using 'X_pca' with n_pcs = 15; finished: added to `.uns['neighbors']`; `.obsp['distances']`, distances for each pair of neighbors; `.obsp['connectivities']`, weighted adjacency matrix (0:00:00); computing UMAP; finished: added; 'X_umap', UMAP coordinates (adata.obsm) (0:00:01); running Leiden clustering; finished: found 6 clusters and added; 'clusters', the cluster labels (adata.obs, categorical) (0:00:00). The experiment",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/basic-analysis.html:20358,perform,perform,20358,en/stable/tutorials/spatial/basic-analysis.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/basic-analysis.html,2,['perform'],['perform']
Performance,"al_counts', 'means', 'variances', 'residual_variances', 'highly_variable_rank', 'highly_variable'; uns: 'name', 'hvg'. adata_pbmc10k. View of AnnData object with n_obs × n_vars = 10968 × 2000; obs: 'n_genes', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'outlier_mt', 'outlier_total', 'outlier_ngenes'; var: 'gene_ids', 'feature_types', 'n_cells', 'mt', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'means', 'variances', 'residual_variances', 'highly_variable_rank', 'highly_variable'; uns: 'name', 'hvg'. Transforming raw counts to Pearson residuals#; When computing Pearson residuals, the observed UMI counts are compared to the expected counts of a “null model”. This model includes only technical factors, but no biological differences between cells. We then only keep the deviations from this model, the residuals, as representation of the data.; This implicitly performs normalization by sequencing depth and variance stabilization: As the null model expects the technical sources of variance, they are removed from the data. In contrast, biological variance is preserved: The null model is designed not to predict biological differences between cells. As a result, it will deviate from the observed counts starkly whenever genes differ in their expression between subpopulations – and produce large residuals in return. This will even work for genes that mark only small subpopulations. An example of detecting a rare subpopulation consisting of just 50 cells with Pearson residuals is presented in Lause et al. (2021).; As a result, the transformed data will show less technical variability, and biological signals from variable genes will be amplified. Therefore, downstream processing like PCA will be dominated by biological rather then technical variances. This is why it makes sense to use Pearson residuals as basis for downstream processing.; After reducing the dataset to the most variable genes in the previous steps, we wil",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:22325,perform,performs,22325,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,2,['perform'],['performs']
Performance,"alantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.read. Contents . read(). scanpy.read#. scanpy.read(filename, backed=None, *, sheet=None, ext=None, delimiter=None, first_column_names=False, backup_url=None, cache=False, cache_compression=_empty, **kwargs)[source]#; Read file and return AnnData object.; To speed up reading, consider passing cache=True, which creates an hdf5; cache file. Parameters:. filename Path | strIf the filename has no file extension, it is interpreted as a key for; generating a filename via sc.settings.writedir / (filename +; sc.settings.file_format_data). This is the same behavior as in; sc.read(filename, ...). backed Optional[Literal['r', 'r+']] (default: None)If 'r', load AnnData in backed mode instead; of fully loading it into memory (memory mode). If you want to modify; backed attributes of the AnnData object, you need to choose 'r+'. sheet str | None (default: None)Name of sheet/table in hdf5 or Excel file. ext str | None (default: None)Extension that indicates the file type. If None, uses extension of; filename. delimiter str | None (default: None)Delimiter that separates data within text file. If None, will split at; arbitrary number of white spaces, which is different from enforcing; splitting at any single white space ' '. first_column_names bool (default: False)Assume the first column stores",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.read.html:9520,cache,cache,9520,en/stable/generated/scanpy.read.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.read.html,2,['cache'],['cache']
Performance,"also use the following literature markers:. B-cell: CD79A, MS4A1; Plasma: IGJ (JCHAIN); T-cell: CD3D; NK: GNLY, NKG7; Myeloid: CST3, LYZ; Monocytes: FCGR3A; Dendritic: FCER1A. Scatter plots for embeddings#; With scanpy, scatter plots for tSNE, UMAP and several other embeddings are readily available using the sc.pl.tsne, sc.pl.umap etc. functions. See here the list of options.; Those functions access the data stored in adata.obsm. For example sc.pl.umap uses the information stored in adata.obsm['X_umap']. For more flexibility, any key stored in adata.obsm can be used with the generic function sc.pl.embedding. import scanpy as sc; from matplotlib.pyplot import rc_context. sc.set_figure_params(dpi=100, color_map=""viridis_r""); sc.settings.verbosity = 0; sc.logging.print_header(). scanpy==1.10.0rc2.dev6+g14555ba4.d20240226 anndata==0.11.0.dev78+g64ab900 umap==0.5.5 numpy==1.26.3 scipy==1.11.4 pandas==2.2.0 scikit-learn==1.3.2 statsmodels==0.14.1 igraph==0.10.8 pynndescent==0.5.11. Load pbmc dataset#. pbmc = sc.datasets.pbmc68k_reduced(). # inspect pbmc contents; pbmc. AnnData object with n_obs × n_vars = 700 × 765; obs: 'bulk_labels', 'n_genes', 'percent_mito', 'n_counts', 'S_score', 'G2M_score', 'phase', 'louvain'; var: 'n_counts', 'means', 'dispersions', 'dispersions_norm', 'highly_variable'; uns: 'bulk_labels_colors', 'louvain', 'louvain_colors', 'neighbors', 'pca', 'rank_genes_groups'; obsm: 'X_pca', 'X_umap'; varm: 'PCs'; obsp: 'distances', 'connectivities'. Visualization of gene expression and other variables#; For the scatter plots, the value to plot is given as the color argument. This can be any gene or any column in .obs, where .obs is a DataFrame containing the annotations per observation/cell, see AnnData for more information. # rc_context is used for the figure size, in this case 4x4; with rc_context({""figure.figsize"": (4, 4)}):; sc.pl.umap(pbmc, color=""CD79A""). Multiple values can be given to color. In the following example we will plot 6 genes: ‘CD79A’, ‘M",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/core.html:11489,Load,Load,11489,en/stable/tutorials/plotting/core.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/core.html,1,['Load'],['Load']
Performance,"an; run neighbors on a GPU using rapids pr830 T White; param docs from typed params P Angerer; embedding_density() now only takes one positional argument; similar for embedding_density(), which gains a param groupby pr965 A Wolf; webpage overhaul, ecosystem page, release notes, tutorials overhaul pr960 pr966 A Wolf. Warning. changed default solver in pca() from auto to arpack; changed default use_raw in score_genes() from False to None. 1.4.4 2019-07-20#. New functionality#. scanpy.get adds helper functions for extracting data in convenient formats pr619 I Virshup. Bug fixes#. Stopped deprecations warnings from AnnData 0.6.22 I Virshup. Code design#. normalize_total() gains param exclude_highly_expressed, and fraction is renamed to max_fraction with better docs A Wolf. 1.4.3 2019-05-14#. Bug fixes#. neighbors() correctly infers n_neighbors again from params, which was temporarily broken in v1.4.2 I Virshup. Code design#. calculate_qc_metrics() is single threaded by default for datasets under 300,000 cells – allowing cached compilation pr615 I Virshup. 1.4.2 2019-05-06#. New functionality#. combat() supports additional covariates which may include adjustment variables or biological condition pr618 G Eraslan; highly_variable_genes() has a batch_key option which performs HVG selection in each batch separately to avoid selecting genes that vary strongly across batches pr622 G Eraslan. Bug fixes#. rank_genes_groups() t-test implementation doesn’t return NaN when variance is 0, also changed to scipy’s implementation pr621 I Virshup; umap() with init_pos='paga' detects correct dtype A Wolf; louvain() and leiden() auto-generate key_added=louvain_R upon passing restrict_to, which was temporarily changed in 1.4.1 A Wolf. Code design#. neighbors() and umap() got rid of UMAP legacy code and introduced UMAP as a dependency pr576 S Rybakov. 1.4.1 2019-04-26#. New functionality#. Scanpy has a command line interface again. Invoking it with scanpy somecommand [args] calls scanpy-some",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:42168,cache,cached,42168,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,1,['cache'],['cached']
Performance,"anpy.external.pp.hashsolo; scanpy.external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.read_10x_mtx. Contents . read_10x_mtx(). scanpy.read_10x_mtx#. scanpy.read_10x_mtx(path, *, var_names='gene_symbols', make_unique=True, cache=False, cache_compression=_empty, gex_only=True, prefix=None)[source]#; Read 10x-Genomics-formatted mtx directory. Parameters:. path Path | strPath to directory for .mtx and .tsv files,; e.g. ‘./filtered_gene_bc_matrices/hg19/’. var_names Literal['gene_symbols', 'gene_ids'] (default: 'gene_symbols')The variables index. make_unique bool (default: True)Whether to make the variables index unique by appending ‘-1’,; ‘-2’ etc. or not. cache bool (default: False)If False, read from source, if True, read from fast ‘h5ad’ cache. cache_compression Union[Literal['gzip', 'lzf'], None, Empty] (default: _empty)See the h5py Filter pipeline.; (Default: settings.cache_compression). gex_only bool (default: True)Only keep ‘Gene Expression’ data and ignore other feature types,; e.g. ‘Antibody Capture’, ‘CRISPR Guide Capture’, or ‘Custom’. prefix str | None (default: None)Any prefix before matrix.mtx, genes.tsv and barcodes.tsv. For instance,; if the files are named patientA_matrix.mtx, patientA_genes.tsv and; patientA_barcode",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.read_10x_mtx.html:9371,cache,cache,9371,en/stable/generated/scanpy.read_10x_mtx.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.read_10x_mtx.html,1,['cache'],['cache']
Performance,"ap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .ipynb. .pdf. Plotting with Marsilea. Contents . Heatmap; Matrixplot; Dot plot; Tracksplot; Stacked Violin; More information. Plotting with Marsilea#; Marsilea is a visualization library that allows user to create composable visualization in a declarative way.; You can use it to create many scanpy plots with easy customization.; Let’s first load the PBMC datdaset. import numpy as np; import scanpy as sc. pbmc = sc.datasets.pbmc3k_processed().raw.to_adata(); pbmc. AnnData object with n_obs × n_vars = 2638 × 13714; obs: 'n_genes', 'percent_mito', 'n_counts', 'louvain'; var: 'n_cells'; uns: 'draw_graph', 'louvain', 'louvain_colors', 'neighbors', 'pca', 'rank_genes_groups'; obsm: 'X_pca', 'X_tsne', 'X_umap', 'X_draw_graph_fr'; obsp: 'distances', 'connectivities'. Define the cells and markers that we want to draw. cell_markers = {; ""CD4 T cells"": [""IL7R""],; ""CD14+ Monocytes"": [""CD14"", ""LYZ""],; ""B cells"": [""MS4A1""],; ""CD8 T cells"": [""CD8A""],; ""NK cells"": [""GNLY"", ""NKG7""],; ""FCGR3A+ Monocytes"": [""FCGR3A"", ""MS4A7""],; ""Dendritic cells"": [""FCER1A"", ""CST3""],; ""Megakaryocytes"": [""PPBP""],; }. cells, markers = [], []; for c, ms in cell_markers.items():; cells += [c] * len(ms); markers += ms. uni_cells = list(cell_markers.keys()); cell_colors = [; ""#568564"",; ""#DC6B19"",; ""#F72464"",; ""#005585"",; ""#9876DE"",; ""#405559"",; ""#58DADA"",; ""#F85959"",;",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/how-to/plotting-with-marsilea.html:9562,load,load,9562,en/stable/how-to/plotting-with-marsilea.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/how-to/plotting-with-marsilea.html,1,['load'],['load']
Performance,"aphs in AnnData, sparse PCA, an interface with scvi, and others. Spatial data support#. Basic analysis Analysis and visualization of spatial transcriptomics data and integration with single cell data Integrating spatial data with scRNA-seq using scanorama G Palla; read_visium() read 10x Visium data pr1034 G Palla, P Angerer, I Virshup; visium_sge() load Visium data directly from 10x Genomics pr1013 M Mirkazemi, G Palla, P Angerer; spatial() plot spatial data pr1012 G Palla, P Angerer. New functionality#. Many functions, like neighbors() and umap(), now store cell-by-cell graphs in obsp pr1118 S Rybakov; scale() and log1p() can be used on any element in layers or obsm pr1173 I Virshup. External tools#. scanpy.external.pp.scvi for preprocessing with scVI pr1085 G Xing; Guide for using Scanpy in R pr1186 L Zappia. Performance#. pca() now uses efficient implicit centering for sparse matrices. This can lead to signifigantly improved performance for large datasets pr1066 A Tarashansky; score_genes() now has an efficient implementation for sparse matrices with missing values pr1196 redst4r. Warning; The new pca() implementation can result in slightly different results for sparse matrices. See the pr (pr1066) and documentation for more info. Code design#. stacked_violin() can now be used as a subplot pr1084 P Angerer; score_genes() has improved logging pr1119 G Eraslan; scale() now saves mean and standard deviation in the var pr1173 A Wolf; harmony_timeseries() pr1091 A Mousa. Bug fixes#. combat() now works when obs_names aren’t unique. pr1215 I Virshup; scale() can now be used on dense arrays without centering pr1160 simonwm; regress_out() now works when some features are constant pr1194 simonwm; normalize_total() errored if the passed object was a view pr1200 I Virshup; neighbors() sometimes ignored the n_pcs param pr1124 V Bergen; ebi_expression_atlas() which contained some out-of-date URLs pr1102 I Virshup; ingest() for UMAP 0.4 pr1165 S Rybakov; louvain() for Louvain 0.",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:38637,perform,performance,38637,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,1,['perform'],['performance']
Performance,"ashing_columns, *, priors=(0.01, 0.8, 0.19), pre_existing_clusters=None, number_of_noise_barcodes=None, inplace=True)[source]#; Probabilistic demultiplexing of cell hashing data using HashSolo [Bernstein et al., 2020]. Note; More information and bug reports here. Parameters:. adata AnnDataThe (annotated) data matrix of shape n_obs × n_vars.; Rows correspond to cells and columns to genes. cell_hashing_columns Sequence[str].obs columns that contain cell hashing counts. priors tuple[float, float, float] (default: (0.01, 0.8, 0.19))Prior probabilities of each hypothesis, in; the order [negative, singlet, doublet]. The default is set to; [0.01, 0.8, 0.19] assuming barcode counts are from cells that; have passed QC in the transcriptome space, e.g. UMI counts, pct; mito reads, etc. pre_existing_clusters str | None (default: None)The column in .obs containing pre-existing cluster assignments; (e.g. Leiden clusters or cell types, but not batch assignments).; If provided, demultiplexing will be performed separately for each; cluster. number_of_noise_barcodes int | None (default: None)The number of barcodes used to create the noise distribution.; Defaults to len(cell_hashing_columns) - 2. inplace bool (default: True)Whether to update adata in-place or return a copy. Return type:; AnnData | None. Returns:; A copy of the input adata if inplace=False, otherwise the input; adata. The following fields are added:. .obs[""most_likely_hypothesis""]Index of the most likely hypothesis, where 0 corresponds to negative,; 1 to singlet, and 2 to doublet. .obs[""cluster_feature""]The cluster assignments used for demultiplexing. .obs[""negative_hypothesis_probability""]Probability of the negative hypothesis. .obs[""singlet_hypothesis_probability""]Probability of the singlet hypothesis. .obs[""doublet_hypothesis_probability""]Probability of the doublet hypothesis. .obs[""Classification""]:Classification of the cell, one of the barcodes in cell_hashing_columns,; ""Negative"", or ""Doublet"". Examples; >>> impor",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.hashsolo.html:10359,perform,performed,10359,en/stable/generated/scanpy.external.pp.hashsolo.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.hashsolo.html,1,['perform'],['performed']
Performance,"at these best match the; distribution of distances in the high-dimensional space.; We use the implementation of umap-learn [McInnes et al., 2018].; For a few comparisons of UMAP with tSNE, see Becht et al. [2018]. Parameters:. adata AnnDataAnnotated data matrix. min_dist float (default: 0.5)The effective minimum distance between embedded points. Smaller values; will result in a more clustered/clumped embedding where nearby points on; the manifold are drawn closer together, while larger values will result; on a more even dispersal of points. The value should be set relative to; the spread value, which determines the scale at which embedded; points will be spread out. The default of in the umap-learn package is; 0.1. spread float (default: 1.0)The effective scale of embedded points. In combination with min_dist; this determines how clustered/clumped the embedded points are. n_components int (default: 2)The number of dimensions of the embedding. maxiter int | None (default: None)The number of iterations (epochs) of the optimization. Called n_epochs; in the original UMAP. alpha float (default: 1.0)The initial learning rate for the embedding optimization. gamma float (default: 1.0)Weighting applied to negative samples in low dimensional embedding; optimization. Values higher than one will result in greater weight; being given to negative samples. negative_sample_rate int (default: 5)The number of negative edge/1-simplex samples to use per positive; edge/1-simplex sample in optimizing the low dimensional embedding. init_pos Union[Literal['paga', 'spectral', 'random'], ndarray, None] (default: 'spectral')How to initialize the low dimensional embedding. Called init in the; original UMAP. Options are:. Any key for adata.obsm.; ’paga’: positions from paga().; ’spectral’: use a spectral embedding of the graph.; ’random’: assign initial embedding positions at random.; A numpy array of initial embedding positions. random_state Union[int, RandomState, None] (default: 0)If int, ran",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.umap.html:11040,optimiz,optimization,11040,en/stable/generated/scanpy.tl.umap.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.umap.html,1,['optimiz'],['optimization']
Performance,"bmc10k_v3/"", cache=True). adata_pbmc3k.uns[""name""] = ""PBMC 3k (v1)""; adata_pbmc10k.uns[""name""] = ""PBMC 10k (v3)"". ... writing an h5ad cache file to speedup reading next time; ... writing an h5ad cache file to speedup reading next time. To demonstrate that Pearson residuals select meaningful genes on these PBMC datasets, we will compare the gene selection to a set of marker genes that were identified in the PBMC3k tutorial. They map to PBMC cell types as follows:; ['IL7R', # CD4 T cells; 'LYZ', 'CD14', # CD14+ Monocytes; 'MS4A1', # B cells; 'CD8A', # CD8 T cells; 'GNLY', 'NKG7', # NK cells; 'FCGR3A', 'MS4A7', # FCGR3A+ Monocytes; 'FCER1A', 'CST3', # Dendritic Cells; 'PPBP'] # Megakaryocytes. A good gene selection should include these differentially expressed genes. # marker genes from table in pbmc3k tutorial; markers = [; ""IL7R"",; ""LYZ"",; ""CD14"",; ""MS4A1"",; ""CD8A"",; ""GNLY"",; ""NKG7"",; ""FCGR3A"",; ""MS4A7"",; ""FCER1A"",; ""CST3"",; ""PPBP"",; ]. Perform Quality control#; First, we remove cells and genes with few counts, then remove outlier cells. Parameters and thresholds are inspired from the PBMC3k tutorial. Basic filtering#. for adata in [adata_pbmc3k, adata_pbmc10k]:; adata.var_names_make_unique(); print(adata.uns[""name""], "": data shape:"", adata.shape); sc.pp.filter_cells(adata, min_genes=200); sc.pp.filter_genes(adata, min_cells=3). PBMC 3k (v1) : data shape: (2700, 32738); filtered out 19024 genes that are detected in less than 3 cells; PBMC 10k (v3) : data shape: (11769, 33538); filtered out 232 cells that have less than 200 genes expressed; filtered out 13246 genes that are detected in less than 3 cells. Compute quality control metrics#; We compute number of deteced genes per cell, total counts per cell and percentage of mitochondrial genes per cell. for adata in [adata_pbmc3k, adata_pbmc10k]:; adata.var[""mt""] = adata.var_names.str.startswith(""MT-""); sc.pp.calculate_qc_metrics(; adata, qc_vars=[""mt""], percent_top=None, log1p=False, inplace=True; ). Plot quality control",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:14117,Perform,Perform,14117,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,1,['Perform'],['Perform']
Performance,"brain atlas for reference). Furthermore, it seems that the dataset integration worked well, since there is a clear continuity between clusters in the two tissues. Data integration and label transfer from scRNA-seq dataset#; We can also perform data integration between one scRNA-seq dataset and one spatial transcriptomics dataset. Such task is particularly useful because it allows us to transfer cell type labels to the Visium dataset, which were dentified from the scRNA-seq dataset.; For this task, we will be using a dataset from Tasic et al., where the mouse cortex was profiled with smart-seq technology.; The dataset can be downloaded from GEO count - metadata.; Conveniently, you can also download the pre-processed dataset in h5ad format from here.; Since the dataset was generated from the mouse cortex, we will subset the visium dataset in order to select only the spots part of the cortex. Note that the integration can also be performed on the whole brain slice, but it would give rise to false positive cell type assignments and and therefore it should be interpreted with more care.; The integration task will be performed with Scanorama: each Visium dataset will be integrated with the smart-seq cortex dataset.; The following cell should be uncommented out and run if this is the first time running this notebook. if not Path(""./data/adata_processed.h5ad"").exists():; !wget https://ftp.ncbi.nlm.nih.gov/geo/series/GSE115nnn/GSE115746/suppl/GSE115746_cells_exon_counts.csv.gz -O data/GSE115746_cells_exon_counts.csv.gz; !gunzip data/GSE115746_cells_exon_counts.csv.gz; !wget https://ftp.ncbi.nlm.nih.gov/geo/series/GSE115nnn/GSE115746/suppl/GSE115746_complete_metadata_28706-cells.csv.gz -O data/GSE115746_complete_metadata_28706-cells.csv.gz; !gunzip data/GSE115746_complete_metadata_28706-cells.csv.gz; %pip install pybiomart; counts = pd.read_csv(""data/GSE115746_cells_exon_counts.csv"", index_col=0).T; meta = pd.read_csv(; ""data/GSE115746_complete_metadata_28706-cells.csv"", inde",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html:20115,perform,performed,20115,en/stable/tutorials/spatial/integration-scanorama.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html,2,['perform'],['performed']
Performance,"browser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.tl.rank_genes_groups. Contents . rank_genes_groups(). scanpy.tl.rank_genes_groups#. scanpy.tl.rank_genes_groups(adata, groupby, *, mask_var=None, use_raw=None, groups='all', reference='rest', n_genes=None, rankby_abs=False, pts=False, key_added=None, copy=False, method=None, corr_method='benjamini-hochberg', tie_correct=False, layer=None, **kwds)[source]#; Rank genes for characterizing groups.; Expects logarithmized data. Parameters:. adata AnnDataAnnotated data matrix. groupby strThe key of the observations grouping to consider. mask_var ndarray[Any, dtype[bool]] | str | None (default: None)Select subset of genes to use in statistical tests. use_raw bool | None (default: None)Use raw attribute of adata if present. layer str | None (default: None)Key from adata.layers whose value will be used to perform tests on. groups Union[Literal['all'], Iterable[str]] (default: 'all')Subset of groups, e.g. ['g1', 'g2', 'g3'], to which comparison; shall be restricted, or 'all' (default), for all groups. Note that if; reference='rest' all groups will still be used as the reference, not; just those specified in groups. reference str (default: 'rest')If 'rest', compare each group to the union of the rest of the group.; If a group identifier, compare with respect to this group. n_genes int | None (default: None)The number of genes that appear in the returned tables.; Defaults to all genes. method Optional[Literal['logreg', 't-test', 'wilcoxon', 't-test_overestim_var']] (default: None)The default method is 't-test',; 't-test_overestim_var' overestimates variance of each group,; 'wilcoxon' uses Wilcoxon rank-sum,; 'logreg' uses logistic regression. See Ntranos et al. [2019],; here and here,; for why this is meaningful. corr_method Literal['benjamini-hochberg', 'bonferroni'] (default: 'b",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.rank_genes_groups.html:10050,perform,perform,10050,en/stable/generated/scanpy.tl.rank_genes_groups.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.rank_genes_groups.html,1,['perform'],['perform']
Performance,"canpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.external.pp.harmony_integrate. Contents . harmony_integrate(). scanpy.external.pp.harmony_integrate#. scanpy.external.pp.harmony_integrate(adata, key, *, basis='X_pca', adjusted_basis='X_pca_harmony', **kwargs)[source]#; Use harmonypy [Korsunsky et al., 2019] to integrate different experiments.; Harmony [Korsunsky et al., 2019] is an algorithm for integrating single-cell; data from multiple experiments. This function uses the python; port of Harmony, harmonypy, to integrate single-cell data; stored in an AnnData object. As Harmony works by adjusting the; principal components, this function should be run after performing; PCA but before computing the neighbor graph, as illustrated in the; example below. Parameters:. adata AnnDataThe annotated data matrix. key strThe name of the column in adata.obs that differentiates; among experiments/batches. basis str (default: 'X_pca')The name of the field in adata.obsm where the PCA table is; stored. Defaults to 'X_pca', which is the default for; sc.pp.pca(). adjusted_basis str (default: 'X_pca_harmony')The name of the field in adata.obsm where the adjusted PCA; table will be stored after running this function. Defaults to; X_pca_harmony. kwargsAny additional arguments will be passed to; harmonypy.run_harmony(). Returns:; Updates adata with the field adata.obsm[obsm_out_field],; containing principal components adjusted by Harmony such that; different experiments are integrated. Example; First, load libraries and example dataset, and preprocess.; >>> import scanpy as sc; >>> import scanpy.external as sce; >>> adata = sc.datasets.pbmc3k(); >>> sc.pp.recipe",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.harmony_integrate.html:9869,perform,performing,9869,en/stable/generated/scanpy.external.pp.harmony_integrate.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.harmony_integrate.html,1,['perform'],['performing']
Performance,"canpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.datasets.pbmc3k. Contents . pbmc3k(). scanpy.datasets.pbmc3k#. scanpy.datasets.pbmc3k()[source]#; 3k PBMCs from 10x Genomics.; The data consists in 3k PBMCs from a Healthy Donor and is freely available; from 10x Genomics (file from this webpage).; The exact same data is also used in Seurat’s basic clustering tutorial. Note; This downloads 5.9 MB of data upon the first call of the function and stores it in; datasetdir/pbmc3k_raw.h5ad. The following code was run to produce the file.; adata = sc.read_10x_mtx(; # the directory with the `.mtx` file; './data/filtered_gene_bc_matrices/hg19/',; # use gene symbols for the variable names (variables-axis index); var_names='gene_symbols',; # write a cache file for faster subsequent reading; cache=True,; ). adata.var_names_make_unique() # this is unnecessary if using 'gene_ids'; adata.write('write/pbmc3k_raw.h5ad', compression='gzip'). Return type:; AnnData. Returns:; Annotated data matrix. Examples; >>> import scanpy as sc; >>> sc.datasets.pbmc3k(); AnnData object with n_obs × n_vars = 2700 × 32738; var: 'gene_ids'. previous; scanpy.datasets.moignard15. next; scanpy.datasets.pbmc3k_processed. Contents; . pbmc3k(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.datasets.pbmc3k.html:9935,cache,cache,9935,en/stable/generated/scanpy.datasets.pbmc3k.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.datasets.pbmc3k.html,2,['cache'],['cache']
Performance,"copy bool (default: False)Return a copy instead of writing to adata. Return type:; AnnData | None. Returns:; Depending on copy, returns or updates adata with the following fields:. Diffusion maps,used for magic imputation, and to generate multi-scale data matrix,. X_palantir_diff_comp - ndarray (obsm, dtype float)Array of Diffusion components. palantir_EigenValues - ndarray (uns, dtype float)Array of corresponding eigen values. palantir_diff_op - spmatrix (obsp, dtype float)The diffusion operator matrix. Multi scale space results,used to build tsne on diffusion components, and to compute branch probabilities; and waypoints,. X_palantir_multiscale - ndarray (obsm, dtype float)Multi scale data matrix. MAGIC imputation,used for plotting gene expression on tsne, and gene expression trends,. palantir_imp - ndarray (layers, dtype float)Imputed data matrix (MAGIC imputation). Example; >>> import scanpy.external as sce; >>> import scanpy as sc. A sample data is available here.; Load sample data; >>> adata = sc.read_csv(filename=""Palantir/data/marrow_sample_scseq_counts.csv.gz""). Cleanup and normalize; >>> sc.pp.filter_cells(adata, min_counts=1000); >>> sc.pp.filter_genes(adata, min_counts=10); >>> sc.pp.normalize_per_cell(adata); >>> sc.pp.log1p(adata). Data preprocessing; Palantir builds diffusion maps using one of two optional inputs:; Principal component analysis; >>> sc.pp.pca(adata, n_comps=300). or,; Nearist neighbors graph; >>> sc.pp.neighbors(adata, knn=30). Diffusion maps; Palantir determines the diffusion maps of the data as an estimate of the low; dimensional phenotypic manifold of the data.; >>> sce.tl.palantir(adata, n_components=5, knn=30). if pre-computed distances are to be used,; >>> sce.tl.palantir(; ... adata,; ... n_components=5,; ... knn=30,; ... use_adjacency_matrix=True,; ... distances_key=""distances"",; ... ). Visualizing Palantir results; tSNE visualization; important for Palantir!; Palantir constructs the tSNE map in the embedded space since these ma",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.palantir.html:12067,Load,Load,12067,en/stable/external/generated/scanpy.external.tl.palantir.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.palantir.html,1,['Load'],['Load']
Performance,"d and unpack the data:. # !mkdir tutorial_data; # !mkdir tutorial_data/pbmc3k_v1; # !mkdir tutorial_data/pbmc10k_v3. # !wget http://cf.10xgenomics.com/samples/cell-exp/1.1.0/pbmc3k/pbmc3k_filtered_gene_bc_matrices.tar.gz -O tutorial_data/pbmc3k_v1.tar.gz; # !cd tutorial_data; tar -xzf pbmc3k_v1.tar.gz -C pbmc3k_v1 --strip-components 2. # !wget https://cf.10xgenomics.com/samples/cell-exp/3.0.0/pbmc_10k_v3/pbmc_10k_v3_filtered_feature_bc_matrix.tar.gz -O tutorial_data/pbmc10k_v3.tar.gz; # !cd tutorial_data; tar -xzf pbmc10k_v3.tar.gz -C pbmc10k_v3 --strip-components 1. Load data#; Here we load the two downloaded datasets from disk and create AnnData objects for them. adata_pbmc3k = sc.read_10x_mtx(""tutorial_data/pbmc3k_v1/"", cache=True); adata_pbmc10k = sc.read_10x_mtx(""tutorial_data/pbmc10k_v3/"", cache=True). adata_pbmc3k.uns[""name""] = ""PBMC 3k (v1)""; adata_pbmc10k.uns[""name""] = ""PBMC 10k (v3)"". ... writing an h5ad cache file to speedup reading next time; ... writing an h5ad cache file to speedup reading next time. To demonstrate that Pearson residuals select meaningful genes on these PBMC datasets, we will compare the gene selection to a set of marker genes that were identified in the PBMC3k tutorial. They map to PBMC cell types as follows:; ['IL7R', # CD4 T cells; 'LYZ', 'CD14', # CD14+ Monocytes; 'MS4A1', # B cells; 'CD8A', # CD8 T cells; 'GNLY', 'NKG7', # NK cells; 'FCGR3A', 'MS4A7', # FCGR3A+ Monocytes; 'FCER1A', 'CST3', # Dendritic Cells; 'PPBP'] # Megakaryocytes. A good gene selection should include these differentially expressed genes. # marker genes from table in pbmc3k tutorial; markers = [; ""IL7R"",; ""LYZ"",; ""CD14"",; ""MS4A1"",; ""CD8A"",; ""GNLY"",; ""NKG7"",; ""FCGR3A"",; ""MS4A7"",; ""FCER1A"",; ""CST3"",; ""PPBP"",; ]. Perform Quality control#; First, we remove cells and genes with few counts, then remove outlier cells. Parameters and thresholds are inspired from the PBMC3k tutorial. Basic filtering#. for adata in [adata_pbmc3k, adata_pbmc10k]:; adata.var_names_make_uniqu",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:13362,cache,cache,13362,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,2,['cache'],['cache']
Performance,"dim=None, var_adj=True, compute_angle=False, mnn_order=None, svd_mode='rsvd', do_concatenate=True, save_raw=False, n_jobs=None, **kwargs)[source]#; Correct batch effects by matching mutual nearest neighbors [Haghverdi et al., 2018] [Kang, 2018].; This uses the implementation of mnnpy [Kang, 2018].; Depending on do_concatenate, returns matrices or AnnData objects in the; original order containing corrected expression values or a concatenated; matrix or AnnData object.; Be reminded that it is not advised to use the corrected data matrices for; differential expression testing.; More information and bug reports here. Parameters:. datas AnnData | ndarrayExpression matrices or AnnData objects. Matrices should be shaped like; n_obs × n_vars (n_cell × n_gene) and have consistent number of columns.; AnnData objects should have same number of variables. var_index Collection[str] | None (default: None)The index (list of str) of vars (genes). Necessary when using only a; subset of vars to perform MNN correction, and should be supplied with; var_subset. When datas are AnnData objects, var_index is ignored. var_subset Collection[str] | None (default: None)The subset of vars (list of str) to be used when performing MNN; correction. Typically, a list of highly variable genes (HVGs).; When set to None, uses all vars. batch_key str (default: 'batch')The batch_key for concatenate().; Only valid when do_concatenate and supplying AnnData objects. index_unique str (default: '-')The index_unique for concatenate().; Only valid when do_concatenate and supplying AnnData objects. batch_categories Collection[Any] | None (default: None)The batch_categories for concatenate().; Only valid when do_concatenate and supplying AnnData objects. k int (default: 20)Number of mutual nearest neighbors. sigma float (default: 1.0)The bandwidth of the Gaussian smoothing kernel used to compute the; correction vectors. Default is 1. cos_norm_in bool (default: True)Whether cosine normalization should be performe",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.mnn_correct.html:10512,perform,perform,10512,en/stable/generated/scanpy.external.pp.mnn_correct.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.mnn_correct.html,1,['perform'],['perform']
Performance,"e_id=""V1_Human_Lymph_Node""); adata.var_names_make_unique(); adata.var[""mt""] = adata.var_names.str.startswith(""MT-""); sc.pp.calculate_qc_metrics(adata, qc_vars=[""mt""], inplace=True). reading /Users/ilangold/Projects/Theis/scanpy-tutorials/spatial/data/V1_Human_Lymph_Node/filtered_feature_bc_matrix.h5; (0:00:01). This is how the adata structure looks like for Visium data. adata. AnnData object with n_obs × n_vars = 4035 × 36601; obs: 'in_tissue', 'array_row', 'array_col', 'n_genes_by_counts', 'log1p_n_genes_by_counts', 'total_counts', 'log1p_total_counts', 'pct_counts_in_top_50_genes', 'pct_counts_in_top_100_genes', 'pct_counts_in_top_200_genes', 'pct_counts_in_top_500_genes', 'total_counts_mt', 'log1p_total_counts_mt', 'pct_counts_mt'; var: 'gene_ids', 'feature_types', 'genome', 'mt', 'n_cells_by_counts', 'mean_counts', 'log1p_mean_counts', 'pct_dropout_by_counts', 'total_counts', 'log1p_total_counts'; uns: 'spatial'; obsm: 'spatial'. QC and preprocessing#; We perform some basic filtering of spots based on total counts and expressed genes. fig, axs = plt.subplots(1, 4, figsize=(15, 4)); sns.histplot(adata.obs[""total_counts""], kde=False, ax=axs[0]); sns.histplot(; adata.obs[""total_counts""][adata.obs[""total_counts""] < 10000],; kde=False,; bins=40,; ax=axs[1],; ); sns.histplot(adata.obs[""n_genes_by_counts""], kde=False, bins=60, ax=axs[2]); sns.histplot(; adata.obs[""n_genes_by_counts""][adata.obs[""n_genes_by_counts""] < 4000],; kde=False,; bins=60,; ax=axs[3],; ). <Axes: xlabel='n_genes_by_counts', ylabel='Count'>. sc.pp.filter_cells(adata, min_counts=5000); sc.pp.filter_cells(adata, max_counts=35000); adata = adata[adata.obs[""pct_counts_mt""] < 20].copy(); print(f""#cells after MT filter: {adata.n_obs}""); sc.pp.filter_genes(adata, min_cells=10). filtered out 44 cells that have less than 5000 counts; filtered out 130 cells that have more than 35000 counts; #cells after MT filter: 3861; filtered out 16916 genes that are detected in less than 10 cells. We proceed to normalize V",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/basic-analysis.html:13794,perform,perform,13794,en/stable/tutorials/spatial/basic-analysis.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/basic-analysis.html,2,['perform'],['perform']
Performance,"e_list Union[Literal['all_genes', 'pca_only'], Sequence[str], None] (default: None)Denoised genes to return. The default 'all_genes'/None; may require a large amount of memory if the input data is sparse.; Another possibility is 'pca_only'. knn int (default: 5)number of nearest neighbors on which to build kernel. decay float | None (default: 1)sets decay rate of kernel tails.; If None, alpha decaying kernel is not used. knn_max int | None (default: None)maximum number of nearest neighbors with nonzero connection.; If None, will be set to 3 * knn. t Union[Literal['auto'], int] (default: 3)power to which the diffusion operator is powered.; This sets the level of diffusion. If ‘auto’, t is selected; according to the Procrustes disparity of the diffused data. n_pca int | None (default: 100)Number of principal components to use for calculating; neighborhoods. For extremely large datasets, using; n_pca < 20 allows neighborhoods to be calculated in; roughly log(n_samples) time. If None, no PCA is performed. solver Literal['exact', 'approximate'] (default: 'exact')Which solver to use. “exact” uses the implementation described; in van Dijk et al. [2018]. “approximate” uses a faster; implementation that performs imputation in the PCA space and then; projects back to the gene space. Note, the “approximate” solver may; return negative values. knn_dist str (default: 'euclidean')recommended values: ‘euclidean’, ‘cosine’, ‘precomputed’; Any metric from scipy.spatial.distance can be used; distance metric for building kNN graph. If ‘precomputed’,; data should be an n_samples x n_samples distance or; affinity matrix. random_state Union[int, RandomState, None] (default: None)Random seed. Defaults to the global numpy random number generator. n_jobs int | None (default: None)Number of threads to use in training. All cores are used by default. verbose bool (default: False)If True or an integer >= 2, print status messages.; If None, sc.settings.verbosity is used. copy bool | None (default",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.magic.html:11363,perform,performed,11363,en/stable/generated/scanpy.external.pp.magic.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.magic.html,1,['perform'],['performed']
Performance,eb17.rst; scanpy.pp.recipe_zheng17.rst; scanpy.pp.scrublet.rst; scanpy.pp.scrublet_simulate_doublets.rst. classes.md; datasets.md; deprecated.md; experimental.md; get.md; index.md; metrics.md; plotting.md; preprocessing.md; queries.md; reading.md; settings.md; tools.md. /dev; ; ci.md; code.md; documentation.md; getting-set-up.md; index.md; release.md; testing.md; versioning.md. /external; . /generated; ; scanpy.external.tl.cyclone.rst; scanpy.external.tl.harmony_timeseries.rst; scanpy.external.tl.palantir.rst; scanpy.external.tl.palantir_results.rst; scanpy.external.tl.phate.rst; scanpy.external.tl.phenograph.rst; scanpy.external.tl.sam.rst; scanpy.external.tl.sandbag.rst; scanpy.external.tl.trimap.rst; scanpy.external.tl.wishbone.rst. exporting.md; index.md; plotting.md; preprocessing.md; tools.md. /generated; ; scanpy._settings.ScanpyConfig.autosave.rst; scanpy._settings.ScanpyConfig.autoshow.rst; scanpy._settings.ScanpyConfig.cache_compression.rst; scanpy._settings.ScanpyConfig.cachedir.rst; scanpy._settings.ScanpyConfig.categories_to_ignore.rst; scanpy._settings.ScanpyConfig.datasetdir.rst; scanpy._settings.ScanpyConfig.figdir.rst; scanpy._settings.ScanpyConfig.file_format_data.rst; scanpy._settings.ScanpyConfig.file_format_figs.rst; scanpy._settings.ScanpyConfig.logfile.rst; scanpy._settings.ScanpyConfig.logpath.rst; scanpy._settings.ScanpyConfig.max_memory.rst; scanpy._settings.ScanpyConfig.n_jobs.rst; scanpy._settings.ScanpyConfig.N_PCS.rst; scanpy._settings.ScanpyConfig.plot_suffix.rst; scanpy._settings.ScanpyConfig.rst; scanpy._settings.ScanpyConfig.set_figure_params.rst; scanpy._settings.ScanpyConfig.verbosity.rst; scanpy._settings.ScanpyConfig.writedir.rst; scanpy.datasets.blobs.rst; scanpy.datasets.ebi_expression_atlas.rst; scanpy.datasets.krumsiek11.rst; scanpy.datasets.moignard15.rst; scanpy.datasets.paul15.rst; scanpy.datasets.pbmc3k.rst; scanpy.datasets.pbmc3k_processed.rst; scanpy.datasets.pbmc68k_reduced.rst; scanpy.datasets.toggleswitch.rst; scanpy,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/index-wcopy.html:5564,cache,cachedir,5564,index-wcopy.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/index-wcopy.html,1,['cache'],['cachedir']
Performance,"elease notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy._settings.ScanpyConfig. Contents . ScanpyConfig. scanpy._settings.ScanpyConfig#. class scanpy._settings.ScanpyConfig(*, verbosity=Verbosity.warning, plot_suffix='', file_format_data='h5ad', file_format_figs='pdf', autosave=False, autoshow=True, writedir='./write/', cachedir='./cache/', datasetdir='./data/', figdir='./figures/', cache_compression='lzf', max_memory=15, n_jobs=1, logfile=None, categories_to_ignore=('N/A', 'dontknow', 'no_gate', '?'), _frameon=True, _vector_friendly=False, _low_resolution_warning=True, n_pcs=50)[source]#; Config manager for scanpy.; Attributes. autosave; Automatically save figures in figdir (default False). autoshow; Automatically show figures if autosave == False (default True). cache_compression; Compression for sc.read(..., cache=True) (default 'lzf'). cachedir; Directory for cache files (default './cache/'). categories_to_ignore; Categories that are omitted in plotting etc. datasetdir; Directory for example datasets (default './data/'). figdir; Directory for saving figures (default './figures/'). file_format_data; File format for saving AnnData objects. file_format_figs; File format for saving figures. logfile; The open file to write logs to. logpath; The file path logfile was set to. max_memory; Maximum memory usage in Gigabyte. n_jobs; Default number of jobs/ CPUs to use for parallel computing. plot_suffix; Global suffix that is appended to figure filenames. verbosity; Verbosity level (default warning). writedir; Directory where the function scanpy.write writes to by default. N_PCS; Default number of principal components to use. Methods. set_figure_params(*[, scanpy, dpi, ...]); Set resolution/size, styling and format of figures. previous; scanpy.set_figure_params. next; scanpy._settings.ScanpyConfig.autosave. Contents; . ScanpyConfig. By Scanpy develop",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy._settings.ScanpyConfig.html:10041,cache,cachedir,10041,en/stable/generated/scanpy._settings.ScanpyConfig.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy._settings.ScanpyConfig.html,2,['cache'],"['cache', 'cachedir']"
Performance,"er category, turning the gene labels off and swapping the axes. Notice that when the image is swapped, a color code for the categories appear instead of the ‘brackets’. sc.pl.rank_genes_groups_heatmap(; pbmc,; n_genes=10,; use_raw=False,; swap_axes=True,; show_gene_labels=False,; vmin=-3,; vmax=3,; cmap=""bwr"",; ). Visualize marker genes using tracksplot#. sc.pl.rank_genes_groups_tracksplot(pbmc, n_genes=3). Comparison of marker genes using split violin plots#; In scanpy, is very easy to compare marker genes using split violin plots for all groups at once. with rc_context({""figure.figsize"": (9, 1.5)}):; sc.pl.rank_genes_groups_violin(pbmc, n_genes=20, jitter=False). Dendrogram options#; Most of the visualizations can arrange the categories using a dendrogram. However, the dendrogram can also be plotted independently as follows:. # compute hierarchical clustering using PCs (several distance metrics and linkage methods are available).; sc.tl.dendrogram(pbmc, ""bulk_labels""). ax = sc.pl.dendrogram(pbmc, ""bulk_labels""). Plot correlation#; Together with the dendrogram it is possible to plot the correlation (by default ‘pearson’) of the categories. ax = sc.pl.correlation_matrix(pbmc, ""bulk_labels"", figsize=(5, 3.5)). previous; Plotting. next; Customizing Scanpy plots. Contents; . Scatter plots for embeddings; Load pbmc dataset; Visualization of gene expression and other variables. Identification of clusters based on known marker genes; dotplot; violin plot; stacked-violin plot; matrixplot. Combining plots in subplots; Heatmaps; Tracksplot; Visualization of marker genes; Visualize marker genes using dotplot; Focusing on particular groups. Visualize marker genes using matrixplot; Visualize marker genes using stacked violin plots; Visualize marker genes using heatmap; Visualize marker genes using tracksplot. Comparison of marker genes using split violin plots; Dendrogram options; Plot correlation. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/core.html:24093,Load,Load,24093,en/stable/tutorials/plotting/core.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/core.html,1,['Load'],['Load']
Performance,"erate very large residuals for these few cells. In turn, these cells might dominate in downstream processing. To avoid such unbalanced behavior, Hafemeister & Satija (2019) introduced a heuristic that clips all residuals to +-sqrt(n_cells). This is the default behavior of all functions for Pearson residuals discussed here. If desired, a different threshold can be set using the clip argument. If no clipping is desired, use clip=np.Inf. chunksize and best practice to obtain Pearson residuals for large datasets#; Raw scRNA UMI counts are usually sparse, and can thus be stored efficiently for large datasets. However, when the count matrix is transformed to Pearson residuals, the data becomes dense. To avoid memory problems, we recommend that you reduce the size of your count matrix by gene selection, before running normalize_pearson_residuals(adata) on the reduced data. To perform RAM-efficient gene selection, use highly_variable_genes(adata,flavor='pearson_residuals') with the chunksize argument: This will still use Pearson residual variance to identify variable genes, but won’t compute all residuals at once. Reduce the chunksize as needed if you run into RAM issues during gene selection. Note that a very small chunksize will slow down the computation, so try to set it as large as possible with your resources.; As an example, we used chunksize=1000 when processing a dataset with 2 million cells in a machine with 500 GB RAM. For smaller machines, we would recommend to reduce this below 100. Wrapper functions for Pearson residuals preprocessing#; The scanpy.experimental.pp module also ships two wrappers that run multiple pre-processing steps at once:. sc.experimental.pp.normalize_pearson_residuals_pca() performs normalization by Pearson residuals and PCA in one go. This function is helpful to quickly obtain a Pearson residual-based data representation when highly variable genes are already defined, as only those are used by default.; sc.experimental.pp.recipe_pearson_resi",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:29167,perform,perform,29167,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,2,['perform'],['perform']
Performance,"erform MNN correction, and should be supplied with; var_subset. When datas are AnnData objects, var_index is ignored. var_subset Collection[str] | None (default: None)The subset of vars (list of str) to be used when performing MNN; correction. Typically, a list of highly variable genes (HVGs).; When set to None, uses all vars. batch_key str (default: 'batch')The batch_key for concatenate().; Only valid when do_concatenate and supplying AnnData objects. index_unique str (default: '-')The index_unique for concatenate().; Only valid when do_concatenate and supplying AnnData objects. batch_categories Collection[Any] | None (default: None)The batch_categories for concatenate().; Only valid when do_concatenate and supplying AnnData objects. k int (default: 20)Number of mutual nearest neighbors. sigma float (default: 1.0)The bandwidth of the Gaussian smoothing kernel used to compute the; correction vectors. Default is 1. cos_norm_in bool (default: True)Whether cosine normalization should be performed on the input data prior; to calculating distances between cells. cos_norm_out bool (default: True)Whether cosine normalization should be performed prior to computing corrected expression values. svd_dim int | None (default: None)The number of dimensions to use for summarizing biological substructure; within each batch. If None, biological components will not be removed; from the correction vectors. var_adj bool (default: True)Whether to adjust variance of the correction vectors. Note this step; takes most computing time. compute_angle bool (default: False)Whether to compute the angle between each cell’s correction vector and; the biological subspace of the reference batch. mnn_order Sequence[int] | None (default: None)The order in which batches are to be corrected. When set to None, datas; are corrected sequentially. svd_mode Literal['svd', 'rsvd', 'irlb'] (default: 'rsvd')'svd' computes SVD using a non-randomized SVD-via-ID algorithm,; while 'rsvd' uses a randomized version. ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.mnn_correct.html:11512,perform,performed,11512,en/stable/generated/scanpy.external.pp.mnn_correct.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.mnn_correct.html,1,['perform'],['performed']
Performance,eries — scanpy; Reading — scanpy; Settings — scanpy; Tools: tl — scanpy. /dev; ; CI — scanpy; Contributing code — scanpy; Documentation — scanpy; Getting set up — scanpy; Contributing — scanpy; Making a release — scanpy; Tests — scanpy; Versioning — scanpy. /external; . /generated; ; scanpy.external.tl.cyclone — scanpy; scanpy.external.tl.harmony_timeseries — scanpy; scanpy.external.tl.palantir — scanpy; scanpy.external.tl.palantir_results — scanpy; scanpy.external.tl.phate — scanpy; scanpy.external.tl.phenograph — scanpy; scanpy.external.tl.sam — scanpy; scanpy.external.tl.sandbag — scanpy; scanpy.external.tl.trimap — scanpy; scanpy.external.tl.wishbone — scanpy. Exporting — scanpy; External API — scanpy; Plotting: PL — scanpy; Preprocessing: PP — scanpy; Tools: TL — scanpy. /generated; ; scanpy._settings.ScanpyConfig.autosave — scanpy; scanpy._settings.ScanpyConfig.autoshow — scanpy; scanpy._settings.ScanpyConfig.cache_compression — scanpy; scanpy._settings.ScanpyConfig.cachedir — scanpy; scanpy._settings.ScanpyConfig.categories_to_ignore — scanpy; scanpy._settings.ScanpyConfig.datasetdir — scanpy; scanpy._settings.ScanpyConfig.figdir — scanpy; scanpy._settings.ScanpyConfig.file_format_data — scanpy; scanpy._settings.ScanpyConfig.file_format_figs — scanpy; scanpy._settings.ScanpyConfig — scanpy; scanpy._settings.ScanpyConfig.logfile — scanpy; scanpy._settings.ScanpyConfig.logpath — scanpy; scanpy._settings.ScanpyConfig.max_memory — scanpy; scanpy._settings.ScanpyConfig.n_jobs — scanpy; scanpy._settings.ScanpyConfig.N_PCS — scanpy; scanpy._settings.ScanpyConfig.plot_suffix — scanpy; scanpy._settings.ScanpyConfig.set_figure_params — scanpy; scanpy._settings.ScanpyConfig.verbosity — scanpy; scanpy._settings.ScanpyConfig.writedir — scanpy; scanpy.datasets.blobs — scanpy; scanpy.datasets.ebi_expression_atlas — scanpy; scanpy.datasets.krumsiek11 — scanpy; scanpy.datasets.moignard15 — scanpy; scanpy.datasets.paul15 — scanpy; scanpy.datasets.pbmc3k — scanpy; scanpy.datase,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/index-wcopy.html:17454,cache,cachedir,17454,index-wcopy.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/index-wcopy.html,1,['cache'],['cachedir']
Performance,"ertain set of genes given by a boolean array; or a string referring to an array in var.; By default, uses .var['highly_variable'] if available, else everything. use_highly_variable bool | None (default: None)Whether to use highly variable genes only, stored in; .var['highly_variable'].; By default uses them if they have been determined beforehand. Deprecated since version 1.10.0: Use mask_var instead. layerLayer of adata to use as expression values. dtype Union[dtype[Any], None, type[Any], _SupportsDType[dtype[Any]], str, tuple[Any, int], tuple[Any, Union[SupportsIndex, Sequence[SupportsIndex]]], list[Any], _DTypeDict, tuple[Any, Any]] (default: 'float32')Numpy data type string to which to convert the result. chunked bool (default: False)If True, perform an incremental PCA on segments of chunk_size.; The incremental PCA automatically zero centers and ignores settings of; random_seed and svd_solver. Uses sklearn IncrementalPCA or; dask-ml IncrementalPCA. If False, perform a full PCA and; use sklearn PCA or; dask-ml PCA. chunk_size int | None (default: None)Number of observations to include in each chunk.; Required if chunked=True was passed. copy bool (default: False)If an AnnData is passed, determines whether a copy; is returned. Is ignored otherwise. Return type:; AnnData | ndarray | spmatrix | None. Returns:; If data is array-like and return_info=False was passed,; this function returns the PCA representation of data as an; array of the same type as the input array.; Otherwise, it returns None if copy=False, else an updated AnnData object.; Sets the following fields:. .obsm['X_pca']spmatrix | ndarray (shape (adata.n_obs, n_comps))PCA representation of data. .varm['PCs']ndarray (shape (adata.n_vars, n_comps))The principal components containing the loadings. .uns['pca']['variance_ratio']ndarray (shape (n_comps,))Ratio of explained variance. .uns['pca']['variance']ndarray (shape (n_comps,))Explained variance, equivalent to the eigenvalues of the; covariance matrix. pr",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.pca.html:13319,perform,perform,13319,en/stable/generated/scanpy.pp.pca.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.pca.html,1,['perform'],['perform']
Performance,"etween the graph and its; transpose. prune=True, symmetrize by taking the product between the graph; and its transpose. min_cluster_size int (default: 10)Cells that end up in a cluster smaller than min_cluster_size are considered; outliers and are assigned to -1 in the cluster labels. jaccard bool (default: True)If True, use Jaccard metric between k-neighborhoods to build graph. If; False, use a Gaussian kernel. primary_metric Literal['euclidean', 'manhattan', 'correlation', 'cosine'] (default: 'euclidean')Distance metric to define nearest neighbors. Note that performance will be; slower for correlation and cosine. n_jobs int (default: -1)Nearest Neighbors and Jaccard coefficients will be computed in parallel using; n_jobs. If 1 is given, no parallelism is used. If set to -1, all CPUs are used.; For n_jobs below -1, n_cpus + 1 + n_jobs are used. q_tol float (default: 0.001)Tolerance, i.e. precision, for monitoring modularity optimization. louvain_time_limit int (default: 2000)Maximum number of seconds to run modularity optimization. If exceeded the best; result so far is returned. nn_method Literal['kdtree', 'brute'] (default: 'kdtree')Whether to use brute force or kdtree for nearest neighbor search.; For very large high-dimensional data sets, brute force, with parallel; computation, performs faster than kdtree. partition_type type[MutableVertexPartition] | None (default: None)Defaults to RBConfigurationVertexPartition. For the; available options, consult the documentation for; find_partition(). resolution_parameter float (default: 1)A parameter value controlling the coarseness of the clustering in Leiden. Higher; values lead to more clusters. Set to None if overriding partition_type to; one that does not accept a resolution_parameter. n_iterations int (default: -1)Number of iterations to run the Leiden algorithm. If the number of iterations is; negative, the Leiden algorithm is run until an iteration in which there was no; improvement. use_weights bool (default: Tr",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.phenograph.html:11858,optimiz,optimization,11858,en/stable/external/generated/scanpy.external.tl.phenograph.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.phenograph.html,2,['optimiz'],['optimization']
Performance,"external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.queries.gene_coordinates. Contents . gene_coordinates(). scanpy.queries.gene_coordinates#. scanpy.queries.gene_coordinates(org, gene_name, *, gene_attr='external_gene_name', chr_exclude=(), host='www.ensembl.org', use_cache=False)[source]#; Retrieve gene coordinates for specific organism through BioMart. Parameters:. org strOrganism to query. Must be an organism in ensembl biomart. “hsapiens”,; “mmusculus”, “drerio”, etc. gene_name strThe gene symbol (e.g. “hgnc_symbol” for human) for which to retrieve; coordinates. gene_attr str (default: 'external_gene_name')The biomart attribute the gene symbol should show up for. chr_exclude Iterable[str] (default: ())A list of chromosomes to exclude from query. host str (default: 'www.ensembl.org')A valid BioMart host URL. Alternative values include archive urls (like; “grch37.ensembl.org”) or regional mirrors (like “useast.ensembl.org”). use_cache bool (default: False)Whether pybiomart should use a cache for requests. Will create a; .pybiomart.sqlite file in current directory if used. Return type:; DataFrame. Returns:; Dataframe containing gene coordinates for the specified gene symbol. Examples; >>> import scanpy as sc; >>> sc.queries.gene_coordinates(""hsapiens"", ""MT-TF""). previous; scanpy.queries.biomart_annotations. next; scanpy.queries.mitochondrial_genes. Contents; . gene_coordinates(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.queries.gene_coordinates.html:10199,cache,cache,10199,en/stable/generated/scanpy.queries.gene_coordinates.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.queries.gene_coordinates.html,1,['cache'],['cache']
Performance,"external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.read_10x_mtx. Contents . read_10x_mtx(). scanpy.read_10x_mtx#. scanpy.read_10x_mtx(path, *, var_names='gene_symbols', make_unique=True, cache=False, cache_compression=_empty, gex_only=True, prefix=None)[source]#; Read 10x-Genomics-formatted mtx directory. Parameters:. path Path | strPath to directory for .mtx and .tsv files,; e.g. ‘./filtered_gene_bc_matrices/hg19/’. var_names Literal['gene_symbols', 'gene_ids'] (default: 'gene_symbols')The variables index. make_unique bool (default: True)Whether to make the variables index unique by appending ‘-1’,; ‘-2’ etc. or not. cache bool (default: False)If False, read from source, if True, read from fast ‘h5ad’ cache. cache_compression Union[Literal['gzip', 'lzf'], None, Empty] (default: _empty)See the h5py Filter pipeline.; (Default: settings.cache_compression). gex_only bool (default: True)Only keep ‘Gene Expression’ data and ignore other feature types,; e.g. ‘Antibody Capture’, ‘CRISPR Guide Capture’, or ‘Custom’. prefix str | None (default: None)Any prefix before matrix.mtx, genes.tsv and barcodes.tsv. For instance,; if the files are named patientA_matrix.mtx, patientA_genes.tsv and; patientA_barcodes.tsv the prefix is patientA_.; (Default: no prefix). Return type:; AnnData. Returns:; An AnnData object. previous; scanpy.read_10x_h5. next; scanpy.read_visium. Contents; . read_10x_mtx(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.read_10x_mtx.html:9810,cache,cache,9810,en/stable/generated/scanpy.read_10x_mtx.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.read_10x_mtx.html,2,['cache'],['cache']
Performance,"finished (0:00:00): normalized adata.X and added 'n_counts', counts per cell before normalization (adata.obs); computing PCA; with n_comps=15; finished (0:00:08); computing neighbors; using 'X_pca' with n_pcs = 15; finished: added to `.uns['neighbors']`; `.obsp['distances']`, distances for each pair of neighbors; `.obsp['connectivities']`, weighted adjacency matrix (0:00:00); computing UMAP; finished: added; 'X_umap', UMAP coordinates (adata.obsm) (0:00:01); running Leiden clustering; finished: found 6 clusters and added; 'clusters', the cluster labels (adata.obs, categorical) (0:00:00). The experiment consisted in measuring gene expression counts from a single cell type (cultured U2-OS cells). Clusters consist of cell states at different stages of the cell cycle. We don’t expect to see specific structure in spatial dimensions given the experimental setup.; We can visualize the clusters obtained from running Leiden in UMAP space and spatial coordinates like this. adata_merfish. AnnData object with n_obs × n_vars = 645 × 12903; obs: 'n_counts', 'clusters'; uns: 'log1p', 'pca', 'neighbors', 'umap', 'leiden'; obsm: 'spatial', 'X_pca', 'X_umap'; varm: 'PCs'; obsp: 'distances', 'connectivities'. sc.pl.umap(adata_merfish, color=""clusters""); sc.pl.embedding(adata_merfish, basis=""spatial"", color=""clusters""). We hope you found the tutorial useful!; Report back to us which features/external tools you would like to see in Scanpy.; We are extending Scanpy and AnnData to support other spatial data types, such as Imaging Mass Cytometry and extend data structure to support spatial graphs and additional features. Stay tuned!. previous; Spatial. next; Integrating spatial data with scRNA-seq using scanorama. Contents; . Reading the data; QC and preprocessing; Manifold embedding and clustering based on transcriptional similarity; Visualization in spatial coordinates; Cluster marker genes; MERFISH example. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/basic-analysis.html:22405,tune,tuned,22405,en/stable/tutorials/spatial/basic-analysis.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/basic-analysis.html,2,['tune'],['tuned']
Performance,"g set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .ipynb. .pdf. Integrating spatial data with scRNA-seq using scanorama. Contents . Loading libraries; Reading the data; Data integration; Data integration and label transfer from scRNA-seq dataset. Integrating spatial data with scRNA-seq using scanorama#; Author: Giovanni Palla. Note; For up-to-date analysis tutorials, kindly check out SquidPy tutorials. This tutorial shows how to work with multiple Visium datasets and perform integration of scRNA-seq dataset with Scanpy. It follows the previous tutorial on analysis and visualization of spatial transcriptomics data.; We will use Scanorama paper - code to perform integration and label transfer. It has a convenient interface with scanpy and anndata.; To install the required libraries, type the following:; pip install git+https://github.com/theislab/scanpy.git; pip install git+https://github.com/theislab/anndata.git; pip install scanorama. Loading libraries#. import scanpy as sc; import anndata as an; import pandas as pd; import numpy as np; import matplotlib.pyplot as plt; import seaborn as sns; import scanorama. from pathlib import Path. sc.logging.print_versions(); sc.set_figure_params(facecolor=""white"", figsize=(8, 8)); sc.settings.verbosity = 3. -----; anndata 0.11.0.dev78+g64ab900; scanpy 1.10.0rc2.dev6+g14555ba4; -----; PIL 10.2.0; annoy NA; anyio NA; appnope 0.1.3; arrow 1.3.0; asciitree NA; asttokens NA; attr 23.2.0; attrs 23.2.0; babel 2.14.0; certifi 2023.11.17; cffi 1.16.0; charset_normalizer 3.3.2; cloudpickle 3.0.0; comm 0.2.1; cycler 0.12.1; cython_runtime NA; dask 2024.1.0; dateutil 2.8.2; debugpy 1.8.0; decorator 5.1.1; defusedxml 0.7.1; executing 2.0.1; fasteners 0.19; fastjsonschema NA; fbpca NA; fqdn NA; h5py 3.10.0; idna 3.6; igraph 0.10.8; intervaltree NA; ipykernel 6.28.0; ipywidgets 8.1.1; isoduration NA; jedi 0.19.1; jinja2 3.1.3; joblib 1.3.2; json5 NA; jsonpointer 2.4; jsonschema 4.20.0; jsonschema_spec",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html:10152,Load,Loading,10152,en/stable/tutorials/spatial/integration-scanorama.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html,1,['Load'],['Loading']
Performance,"g. use_highly_variable bool | None (default: None)Whether to use highly variable genes only, stored in; .var['highly_variable'].; By default uses them if they have been determined beforehand. Deprecated since version 1.10.0: Use mask_var instead. layerLayer of adata to use as expression values. dtype Union[dtype[Any], None, type[Any], _SupportsDType[dtype[Any]], str, tuple[Any, int], tuple[Any, Union[SupportsIndex, Sequence[SupportsIndex]]], list[Any], _DTypeDict, tuple[Any, Any]] (default: 'float32')Numpy data type string to which to convert the result. chunked bool (default: False)If True, perform an incremental PCA on segments of chunk_size.; The incremental PCA automatically zero centers and ignores settings of; random_seed and svd_solver. Uses sklearn IncrementalPCA or; dask-ml IncrementalPCA. If False, perform a full PCA and; use sklearn PCA or; dask-ml PCA. chunk_size int | None (default: None)Number of observations to include in each chunk.; Required if chunked=True was passed. copy bool (default: False)If an AnnData is passed, determines whether a copy; is returned. Is ignored otherwise. Return type:; AnnData | ndarray | spmatrix | None. Returns:; If data is array-like and return_info=False was passed,; this function returns the PCA representation of data as an; array of the same type as the input array.; Otherwise, it returns None if copy=False, else an updated AnnData object.; Sets the following fields:. .obsm['X_pca']spmatrix | ndarray (shape (adata.n_obs, n_comps))PCA representation of data. .varm['PCs']ndarray (shape (adata.n_vars, n_comps))The principal components containing the loadings. .uns['pca']['variance_ratio']ndarray (shape (n_comps,))Ratio of explained variance. .uns['pca']['variance']ndarray (shape (n_comps,))Explained variance, equivalent to the eigenvalues of the; covariance matrix. previous; scanpy.pp.log1p. next; scanpy.pp.normalize_total. Contents; . pca(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.pca.html:14120,load,loadings,14120,en/stable/generated/scanpy.pp.pca.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.pca.html,1,['load'],['loadings']
Performance,"gend_loc=""on data"", title="""", frameon=False, save="".pdf""; ). WARNING: saving figure to file figures/umap.pdf. Now that we annotated the cell types, let us visualize the marker genes. sc.pl.dotplot(adata, marker_genes, groupby=""leiden"");. There is also a very compact violin plot. sc.pl.stacked_violin(adata, marker_genes, groupby=""leiden"");. During the course of this analysis, the AnnData accumlated the following annotations. adata. AnnData object with n_obs × n_vars = 2638 × 1838; obs: 'n_genes', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'leiden'; var: 'gene_ids', 'n_cells', 'mt', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'highly_variable', 'means', 'dispersions', 'dispersions_norm', 'mean', 'std'; uns: 'hvg', 'leiden', 'leiden_colors', 'log1p', 'neighbors', 'pca', 'rank_genes_groups', 'umap'; obsm: 'X_pca', 'X_umap'; varm: 'PCs'; obsp: 'connectivities', 'distances'. # `compression='gzip'` saves disk space, and slightly slows down writing and subsequent reading; adata.write(results_file, compression=""gzip""). Get a rough overview of the file using h5ls, which has many options - for more details see here. The file format might still be subject to further optimization in the future. All reading functions will remain backwards-compatible, though.; If you want to share this file with people who merely want to use it for visualization, a simple way to reduce the file size is by removing the dense scaled and corrected data matrix. The file still contains the raw data used in the visualizations in adata.raw. adata.raw.to_adata().write(""./write/pbmc3k_withoutX.h5ad""). previous; Preprocessing and clustering. next; Integrating data using ingest and BBKNN. Contents; . Preprocessing; Principal component analysis; Computing the neighborhood graph; Embedding the neighborhood graph; Clustering the neighborhood graph; Finding marker genes. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering-2017.html:25645,optimiz,optimization,25645,en/stable/tutorials/basics/clustering-2017.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering-2017.html,2,['optimiz'],['optimization']
Performance,"grate; scanpy.external.pp.mnn_correct; scanpy.external.pp.scanorama_integrate; scanpy.external.pp.hashsolo; scanpy.external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .ipynb. .pdf. Core plotting functions. Contents . Scatter plots for embeddings; Load pbmc dataset; Visualization of gene expression and other variables. Identification of clusters based on known marker genes; dotplot; violin plot; stacked-violin plot; matrixplot. Combining plots in subplots; Heatmaps; Tracksplot; Visualization of marker genes; Visualize marker genes using dotplot; Focusing on particular groups. Visualize marker genes using matrixplot; Visualize marker genes using stacked violin plots; Visualize marker genes using heatmap; Visualize marker genes using tracksplot. Comparison of marker genes using split violin plots; Dendrogram options; Plot correlation. Core plotting functions#; Author: Fidel Ramírez; This tutorial explores the visualization possibilities of scanpy and is divided into three sections:. Scatter plots for embeddings (eg. UMAP, t-SNE); Identification of clusters using known marker genes; Visualization of differentially expressed genes. In this tutorial, we will use a dataset from 10x containing 68k cells from PBMC. Scanpy, includes in its distribution a red",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/core.html:9300,Load,Load,9300,en/stable/tutorials/plotting/core.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/core.html,1,['Load'],['Load']
Performance,"harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.external.pp.dca. Contents . dca(). scanpy.external.pp.dca#. scanpy.external.pp.dca(adata, mode='denoise', *, ae_type='nb-conddisp', normalize_per_cell=True, scale=True, log1p=True, hidden_size=(64, 32, 64), hidden_dropout=0.0, batchnorm=True, activation='relu', init='glorot_uniform', network_kwds=mappingproxy({}), epochs=300, reduce_lr=10, early_stop=15, batch_size=32, optimizer='RMSprop', random_state=0, threads=None, learning_rate=None, verbose=False, training_kwds=mappingproxy({}), return_model=False, return_info=False, copy=False)[source]#; Deep count autoencoder [Eraslan et al., 2019].; Fits a count autoencoder to the raw count data given in the anndata object; in order to denoise the data and to capture hidden representation of; cells in low dimensions. Type of the autoencoder and return values are; determined by the parameters. Note; More information and bug reports here. Parameters:. adata AnnDataAn anndata file with .raw attribute representing raw counts. mode Literal['denoise', 'latent'] (default: 'denoise')denoise overwrites adata.X with denoised expression values.; In latent mode DCA adds adata.obsm['X_dca'] to given adata; object. This matrix represent latent representation of cells via DCA. ae_type Literal['zinb-conddisp', 'zinb', 'nb-conddisp', 'nb'] (default: 'nb-conddisp')Type of the autoencoder. Return values and the architecture is; determined by the type e.g. nb do",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.dca.html:9610,optimiz,optimizer,9610,en/stable/generated/scanpy.external.pp.dca.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.dca.html,1,['optimiz'],['optimizer']
Performance,"he observed counts starkly whenever genes differ in their expression between subpopulations – and produce large residuals in return. This will even work for genes that mark only small subpopulations. An example of detecting a rare subpopulation consisting of just 50 cells with Pearson residuals is presented in Lause et al. (2021).; As a result, the transformed data will show less technical variability, and biological signals from variable genes will be amplified. Therefore, downstream processing like PCA will be dominated by biological rather then technical variances. This is why it makes sense to use Pearson residuals as basis for downstream processing.; After reducing the dataset to the most variable genes in the previous steps, we will now transform our raw counts to residuals by calling normalize_pearson_residuals(adata). In our example pipeline, we then apply PCA to reduce the dataset to the most relevant dimensions. We visualize this reduced representation with t-SNE and perform Leiden clustering, which is again taken from the PBMC3k tutorial.; This is just one of many possible pipelines: After PCA, you could also use UMAP or other embeddings to inspect the data, and cluster the data with a different algorithm than Leiden. Preparations#; Because we will transform the raw data in adata.X to residuals in the next step, we first save a copy of the raw counts to adata.layers['raw']. Also, we save a depth-normalized and square-root transformed version of the data to adata.layers['sqrt_norm'], so we can use them for plotting normalized counts later. Further background on why to use the square-root transform here can be found in Wagner (2020). # keep raw and depth-normalized counts for later; adata_pbmc3k.layers[""raw""] = adata_pbmc3k.X.copy(); adata_pbmc3k.layers[""sqrt_norm""] = np.sqrt(; sc.pp.normalize_total(adata_pbmc3k, inplace=False)[""X""]; ). adata_pbmc10k.layers[""raw""] = adata_pbmc10k.X.copy(); adata_pbmc10k.layers[""sqrt_norm""] = np.sqrt(; sc.pp.normalize_total(",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:23643,perform,perform,23643,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,2,['perform'],['perform']
Performance,"he same file as code, line length restrictions still apply. In files which are just docs, go with a sentence per line (for easier git diffs).; Check that the docs look like what you expect them too! It’s easy to forget to add a reference to function, be sure it got added and looks right. Look at sc.tl.louvain as an example for everything mentioned here. Plots in docstrings#; One of the most useful things you can include in a docstring is examples of how the function should be used.; These are a great way to demonstrate intended usage and give users a template they can copy and modify.; We’re able to include the plots produced by these snippets in the rendered docs using matplotlib’s plot directive.; For examples of this, see the Examples sections of dotplot() or calculate_qc_metrics().; Note that anything in these sections will need to be run when the docs are built, so please keep them computationally light. If you need computed features (e.g. an embedding, differential expression results) load data that has this precomputed.; Try to re-use datasets, this reduces the amount of data that needs to be downloaded to the CI server. Params section#; The Params abbreviation is a legit replacement for Parameters.; To document parameter types use type annotations on function parameters.; These will automatically populate the docstrings on import, and when the documentation is built.; Use the python standard library types (defined in collections.abc and typing modules) for containers, e.g.; Sequences (like list),; Iterables (like set), and; Mappings (like dict).; Always specify what these contain, e.g. {'a': (1, 2)} → Mapping[str, Tuple[int, int]].; If you can’t use one of those, use a concrete class like AnnData.; If your parameter only accepts an enumeration of strings, specify them like so: Literal['elem-1', 'elem-2']. Returns section#; There are three types of return sections – prose, tuple, and a mix of both. Prose is for simple cases.; Tuple return sections are formatt",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/dev/documentation.html:12355,load,load,12355,en/stable/dev/documentation.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/dev/documentation.html,1,['load'],['load']
Performance,"ing: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.tl.umap. Contents . umap(). scanpy.tl.umap#. scanpy.tl.umap(adata, *, min_dist=0.5, spread=1.0, n_components=2, maxiter=None, alpha=1.0, gamma=1.0, negative_sample_rate=5, init_pos='spectral', random_state=0, a=None, b=None, method='umap', neighbors_key='neighbors', copy=False)[source]#; Embed the neighborhood graph using UMAP [McInnes et al., 2018].; UMAP (Uniform Manifold Approximation and Projection) is a manifold learning; technique suitable for visualizing high-dimensional data. Besides tending to; be faster than tSNE, it optimizes the embedding such that it best reflects; the topology of the data, which we represent throughout Scanpy using a; neighborhood graph. tSNE, by contrast, optimizes the distribution of; nearest-neighbor distances in the embedding such that these best match the; distribution of distances in the high-dimensional space.; We use the implementation of umap-learn [McInnes et al., 2018].; For a few comparisons of UMAP with tSNE, see Becht et al. [2018]. Parameters:. adata AnnDataAnnotated data matrix. min_dist float (default: 0.5)The effective minimum distance between embedded points. Smaller values; will result in a more clustered/clumped embedding where nearby points on; the manifold are drawn closer together, while larger values will result; on a more even dispersal of points. The value should be set relative to; the spread value, which determines the scale at which embedded; points will be spread out. The default of in the umap-learn package is; 0.1. spread float (default: 1.0)The effective scale of embedded points. In combinati",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.umap.html:9763,optimiz,optimizes,9763,en/stable/generated/scanpy.tl.umap.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.umap.html,1,['optimiz'],['optimizes']
Performance,"ings int (default: 0)Number of branchings to detect. min_group_size float (default: 0.01)During recursive splitting of branches (‘dpt groups’) for n_branchings; > 1, do not consider groups that contain less than min_group_size data; points. If a float, min_group_size refers to a fraction of the total; number of data points. allow_kendall_tau_shift bool (default: True)If a very small branch is detected upon splitting, shift away from; maximum correlation in Kendall tau criterion of Haghverdi et al. [2016] to; stabilize the splitting. neighbors_key str | None (default: None)If not specified, dpt looks .uns[‘neighbors’] for neighbors settings; and .obsp[‘connectivities’], .obsp[‘distances’] for connectivities and; distances respectively (default storage places for pp.neighbors).; If specified, dpt looks .uns[neighbors_key] for neighbors settings and; .obsp[.uns[neighbors_key][‘connectivities_key’]],; .obsp[.uns[neighbors_key][‘distances_key’]] for connectivities and distances; respectively. copy bool (default: False)Copy instance before computation and return a copy.; Otherwise, perform computation inplace and return None. Return type:; AnnData | None. Returns:; Returns None if copy=False, else returns an AnnData object. Sets the following fields (If n_branchings==0, no field adata.obs['dpt_groups'] will be written):. adata.obs['dpt_pseudotime']pandas.Series (dtype float)Array of dim (number of samples) that stores the pseudotime of each; cell, that is, the DPT distance with respect to the root cell. adata.obs['dpt_groups']pandas.Series (dtype category)Array of dim (number of samples) that stores the subgroup id (‘0’,; ‘1’, …) for each cell. The groups typically correspond to; ‘progenitor cells’, ‘undecided cells’ or ‘branches’ of a process. Notes; The tool is similar to the R package destiny of Angerer et al. [2015]. previous; scanpy.tl.dendrogram. next; scanpy.tl.paga. Contents; . dpt(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.dpt.html:11908,perform,perform,11908,en/stable/generated/scanpy.tl.dpt.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.dpt.html,1,['perform'],['perform']
Performance,"ings.ScanpyConfig.set_figure_params. scanpy.logging.print_header; scanpy.logging.print_versions. Datasets; scanpy.datasets.blobs; scanpy.datasets.ebi_expression_atlas; scanpy.datasets.krumsiek11; scanpy.datasets.moignard15; scanpy.datasets.pbmc3k; scanpy.datasets.pbmc3k_processed; scanpy.datasets.pbmc68k_reduced; scanpy.datasets.paul15; scanpy.datasets.toggleswitch; scanpy.datasets.visium_sge. Deprecated functions; scanpy.pp.filter_genes_dispersion; scanpy.pp.normalize_per_cell. External API; Preprocessing: PP; scanpy.external.pp.bbknn; scanpy.external.pp.harmony_integrate; scanpy.external.pp.mnn_correct; scanpy.external.pp.scanorama_integrate; scanpy.external.pp.hashsolo; scanpy.external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy._settings.ScanpyConfig.cache_compression. Contents . ScanpyConfig.cache_compression. scanpy._settings.ScanpyConfig.cache_compression#. property ScanpyConfig.cache_compression: str | None[source]#; Compression for sc.read(..., cache=True) (default 'lzf').; May be 'lzf', 'gzip', or None. previous; scanpy._settings.ScanpyConfig.autoshow. next; scanpy._settings.ScanpyConfig.cachedir. Contents; . ScanpyConfig.cache_compression. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy._settings.ScanpyConfig.cache_compression.html:9489,cache,cache,9489,en/stable/generated/scanpy._settings.ScanpyConfig.cache_compression.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy._settings.ScanpyConfig.cache_compression.html,2,['cache'],"['cache', 'cachedir']"
Performance,"integrate; scanpy.external.pp.hashsolo; scanpy.external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.read. Contents . read(). scanpy.read#. scanpy.read(filename, backed=None, *, sheet=None, ext=None, delimiter=None, first_column_names=False, backup_url=None, cache=False, cache_compression=_empty, **kwargs)[source]#; Read file and return AnnData object.; To speed up reading, consider passing cache=True, which creates an hdf5; cache file. Parameters:. filename Path | strIf the filename has no file extension, it is interpreted as a key for; generating a filename via sc.settings.writedir / (filename +; sc.settings.file_format_data). This is the same behavior as in; sc.read(filename, ...). backed Optional[Literal['r', 'r+']] (default: None)If 'r', load AnnData in backed mode instead; of fully loading it into memory (memory mode). If you want to modify; backed attributes of the AnnData object, you need to choose 'r+'. sheet str | None (default: None)Name of sheet/table in hdf5 or Excel file. ext str | None (default: None)Extension that indicates the file type. If None, uses extension of; filename. delimiter str | None (default: None)Delimiter that separates data within text file. If None, will split at; arbitrary number of white spaces, ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.read.html:9385,cache,cache,9385,en/stable/generated/scanpy.read.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.read.html,1,['cache'],['cache']
Performance,"ion theta=100 is used, and PCA is run with 50 components.; Operates on the subset of highly variable genes in adata.var['highly_variable']; by default. Expects raw count input. Parameters:. adata AnnDataThe annotated data matrix of shape n_obs × n_vars.; Rows correspond to cells and columns to genes. theta float (default: 100)The negative binomial overdispersion parameter theta for Pearson residuals.; Higher values correspond to less overdispersion (var = mean + mean^2/theta), and theta=np.inf corresponds to a Poisson model. clip float | None (default: None)Determines if and how residuals are clipped:. If None, residuals are clipped to the interval [-sqrt(n_obs), sqrt(n_obs)], where n_obs is the number of cells in the dataset (default behavior).; If any scalar c, residuals are clipped to the interval [-c, c]. Set clip=np.inf for no clipping. n_comps int | None (default: 50)Number of principal components to compute in the PCA step. random_state float (default: 0)Random seed for setting the initial states for the optimization in the PCA step. kwargs_pca Mapping[str, Any] (default: mappingproxy({}))Dictionary of further keyword arguments passed on to scanpy.pp.pca(). mask_var ndarray | str | None | Empty (default: _empty)To run only on a certain set of genes given by a boolean array; or a string referring to an array in var.; By default, uses .var['highly_variable'] if available, else everything. use_highly_variable bool | None (default: None)Whether to use highly variable genes only, stored in; .var['highly_variable'].; By default uses them if they have been determined beforehand. Deprecated since version 1.10.0: Use mask_var instead. check_values bool (default: True)If True, checks if counts in selected layer are integers as expected by this; function, and return a warning if non-integers are found. Otherwise, proceed; without checking. Setting this to False can speed up code for large datasets. inplace bool (default: True)If True, update adata with results. Otherwis",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.normalize_pearson_residuals_pca.html:10937,optimiz,optimization,10937,en/stable/generated/scanpy.experimental.pp.normalize_pearson_residuals_pca.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.normalize_pearson_residuals_pca.html,1,['optimiz'],['optimization']
Performance,"is computed when you call an operation on a dask array, but only later when you hit compute.; In some cases it’s currently unavoidable to skip all computation, and these cases will kick off compute for all the delayed operations immediately. %%time; adata.layers[""counts""] = adata.X.copy() # Making sure we keep access to the raw counts; sc.pp.normalize_total(adata, target_sum=1e4). CPU times: user 7.1 ms, sys: 31 μs, total: 7.13 ms; Wall time: 7.49 ms. %%time; sc.pp.log1p(adata). CPU times: user 3.14 ms, sys: 2.03 ms, total: 5.17 ms; Wall time: 4.88 ms. Highly variable genes needs to add entries into obs, which currently does not support lazy column. So computation will occur immediately on call. %%time; sc.pp.highly_variable_genes(adata). CPU times: user 3.46 s, sys: 509 ms, total: 3.97 s; Wall time: 50 s. PCA currently does not support sparse data. So we will need to densify the expression matrix before passing it in. However, as we are working with only a subset of the data at a time, we are able to perform this operation with a lower memory overhead.; As this is a still a significant increase in memory usage per chunk, we will need to reduce the number of observations present in each chunk. adata.layers[""dense""] = adata.X.rechunk((DENSE_CHUNK_SIZE, -1)).map_blocks(; lambda x: x.toarray(), dtype=adata.X.dtype, meta=np.array([]); ). %%time; sc.pp.pca(adata, layer=""dense""). CPU times: user 9.31 s, sys: 1.19 s, total: 10.5 s; Wall time: 1min 27s. While most of the PCA computation runs immediately, the last step (computing the observation loadings) is lazy, so must be triggered manually to avoid recomputation. %%time; adata.obsm[""X_pca""] = adata.obsm[""X_pca""].compute(). CPU times: user 6.72 s, sys: 1.36 s, total: 8.08 s; Wall time: 1min 15s. adata. AnnData object with n_obs × n_vars = 1462702 × 27714; obs: 'celltype', 'majorType', 'City', 'sampleID', 'donor_id', 'Sample type', 'CoVID-19 severity', 'Sample time', 'Sampling day (Days after symptom onset)', 'BCR single ce",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/dask.html:15294,perform,perform,15294,en/stable/tutorials/experimental/dask.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/dask.html,2,['perform'],['perform']
Performance,"l give 'auto',; if dask-ml TruncatedSVD is used, will give 'tsqr'. 'arpack'for the ARPACK wrapper in SciPy (svds()); Not available with dask arrays. 'randomized'for the randomized algorithm due to Halko (2009). For dask arrays,; this will use svd_compressed(). 'auto'chooses automatically depending on the size of the problem. 'lobpcg'An alternative SciPy solver. Not available with dask arrays. 'tsqr'Only available with dask arrays. “tsqr”; algorithm from Benson et. al. (2013). Changed in version 1.9.3: Default value changed from 'arpack' to None. Changed in version 1.4.5: Default value changed from 'auto' to 'arpack'. Efficient computation of the principal components of a sparse matrix; currently only works with the 'arpack’ or 'lobpcg' solvers.; If X is a dask array, dask-ml classes PCA,; IncrementalPCA, or; TruncatedSVD will be used.; Otherwise their scikit-learn counterparts PCA,; IncrementalPCA, or; TruncatedSVD will be used. random_state Union[int, RandomState, None] (default: 0)Change to use different initial states for the optimization. return_info bool (default: False)Only relevant when not passing an AnnData:; see “Returns”. mask_var ndarray[Any, dtype[bool]] | str | None | Empty (default: _empty)To run only on a certain set of genes given by a boolean array; or a string referring to an array in var.; By default, uses .var['highly_variable'] if available, else everything. use_highly_variable bool | None (default: None)Whether to use highly variable genes only, stored in; .var['highly_variable'].; By default uses them if they have been determined beforehand. Deprecated since version 1.10.0: Use mask_var instead. layerLayer of adata to use as expression values. dtype Union[dtype[Any], None, type[Any], _SupportsDType[dtype[Any]], str, tuple[Any, int], tuple[Any, Union[SupportsIndex, Sequence[SupportsIndex]]], list[Any], _DTypeDict, tuple[Any, Any]] (default: 'float32')Numpy data type string to which to convert the result. chunked bool (default: False)If True, p",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.pca.html:12144,optimiz,optimization,12144,en/stable/generated/scanpy.pp.pca.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.pca.html,1,['optimiz'],['optimization']
Performance,"l.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.read_h5ad. Contents . read_h5ad(). scanpy.read_h5ad#. scanpy.read_h5ad(filename, backed=None, *, as_sparse=(), as_sparse_fmt=<class 'scipy.sparse._csr.csr_matrix'>, chunk_size=6000)[source]#; Read .h5ad-formatted hdf5 file. Parameters:. filename str | PathFile name of data file. backed Union[Literal['r', 'r+'], bool, None] (default: None)If 'r', load AnnData in backed mode; instead of fully loading it into memory (memory mode).; If you want to modify backed attributes of the AnnData object,; you need to choose 'r+'.; Currently, backed only support updates to X. That means any; changes to other slots like obs will not be written to disk in; backed mode. If you would like save changes made to these slots; of a backed AnnData, write them to a new file; (see write()). For an example, see; [here] (https://anndata-tutorials.readthedocs.io/en/latest/getting-started.html#Partial-reading-of-large-data). as_sparse Sequence[str] (default: ())If an array was saved as dense, passing its name here will read it as; a sparse_matrix, by chunk of size chunk_size. as_sparse_fmt type[spmatrix] (default: <class 'scipy.sparse._csr.csr_matrix'>)Sparse format class to read elements from as_sparse in as. chunk_size int (default: 6000)Used only when loading sparse dataset that is stored as dense.; Loading iterates through chunks of the dataset of this row size; until it reads the whole dataset.; Higher size means higher memory consumption and higher (to a point); loading speed. Return type:; AnnData. previous; scanpy.read_visium. next; scanpy.read_csv. Contents; . read_h5ad(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.read_h5ad.html:10476,load,loading,10476,en/stable/generated/scanpy.read_h5ad.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.read_h5ad.html,2,['load'],['loading']
Performance,"l.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.get.aggregate. Contents . aggregate(). scanpy.get.aggregate#. scanpy.get.aggregate(adata, by, func, *, axis=None, mask=None, dof=1, layer=None, obsm=None, varm=None)[source]#; Aggregate data matrix based on some categorical grouping.; This function is useful for pseudobulking as well as plotting.; Aggregation to perform is specified by func, which can be a single metric or a; list of metrics. Each metric is computed over the group and results in a new layer; in the output AnnData object.; If none of layer, obsm, or varm are passed in, X will be used for aggregation data. Parameters:. adata AnnDataAnnData to be aggregated. by str | Collection[str]Key of the column to be grouped-by. func Union[Literal['count_nonzero', 'mean', 'sum', 'var'], Iterable[Literal['count_nonzero', 'mean', 'sum', 'var']]]How to aggregate. axis Optional[Literal['obs', 0, 'var', 1]] (default: None)Axis on which to find group by column. mask ndarray[Any, dtype[bool]] | str | None (default: None)Boolean mask (or key to column containing mask) to apply along the axis. dof int (default: 1)Degrees of freedom for variance. Defaults to 1. layer str | None (default: None)If not None, key for aggregation data. obsm str | None (default: None)If not None, key for aggregation data. varm str | None (default: None)If not None, key for aggregation data. Return type:; ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.get.aggregate.html:9550,perform,perform,9550,en/stable/generated/scanpy.get.aggregate.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.get.aggregate.html,1,['perform'],['perform']
Performance,"ld are drawn closer together, while larger values will result; on a more even dispersal of points. The value should be set relative to; the spread value, which determines the scale at which embedded; points will be spread out. The default of in the umap-learn package is; 0.1. spread float (default: 1.0)The effective scale of embedded points. In combination with min_dist; this determines how clustered/clumped the embedded points are. n_components int (default: 2)The number of dimensions of the embedding. maxiter int | None (default: None)The number of iterations (epochs) of the optimization. Called n_epochs; in the original UMAP. alpha float (default: 1.0)The initial learning rate for the embedding optimization. gamma float (default: 1.0)Weighting applied to negative samples in low dimensional embedding; optimization. Values higher than one will result in greater weight; being given to negative samples. negative_sample_rate int (default: 5)The number of negative edge/1-simplex samples to use per positive; edge/1-simplex sample in optimizing the low dimensional embedding. init_pos Union[Literal['paga', 'spectral', 'random'], ndarray, None] (default: 'spectral')How to initialize the low dimensional embedding. Called init in the; original UMAP. Options are:. Any key for adata.obsm.; ’paga’: positions from paga().; ’spectral’: use a spectral embedding of the graph.; ’random’: assign initial embedding positions at random.; A numpy array of initial embedding positions. random_state Union[int, RandomState, None] (default: 0)If int, random_state is the seed used by the random number generator;; If RandomState or Generator, random_state is the random number generator;; If None, the random number generator is the RandomState instance used; by np.random. a float | None (default: None)More specific parameters controlling the embedding. If None these; values are set automatically as determined by min_dist and; spread. b float | None (default: None)More specific parameters controll",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.umap.html:11501,optimiz,optimizing,11501,en/stable/generated/scanpy.tl.umap.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.umap.html,1,['optimiz'],['optimizing']
Performance,"many top connectivities. May help with; population independence and improve the tidiness of clustering. The lower the value the; more independent the individual populations, at the cost of more conserved batch effect.; If None, sets the parameter value automatically to 10 times neighbors_within_batch; times the number of batches. Set to 0 to skip. annoy_n_trees int (default: 10)Only used with annoy neighbour identification. The number of trees to construct in the; annoy forest. More trees give higher precision when querying, at the cost of increased; run time and resource intensity. pynndescent_n_neighbors int (default: 30)Only used with pyNNDescent neighbour identification. The number of neighbours to include; in the approximate neighbour graph. More neighbours give higher precision when querying,; at the cost of increased run time and resource intensity. pynndescent_random_state int (default: 0)Only used with pyNNDescent neighbour identification. The RNG seed to use when creating; the graph. use_faiss bool (default: True)If approx=False and the metric is “euclidean”, use the faiss package to compute; nearest neighbours if installed. This improves performance at a minor cost to numerical; precision as faiss operates on float32. set_op_mix_ratio float (default: 1.0)UMAP connectivity computation parameter, float between 0 and 1, controlling the; blend between a connectivity matrix formed exclusively from mutual nearest neighbour; pairs (0) and a union of all observed neighbour relationships with the mutual pairs; emphasised (1). local_connectivity int (default: 1)UMAP connectivity computation parameter, how many nearest neighbors of each cell; are assumed to be fully connected (and given a connectivity value of 1). Return type:; AnnData | None. Returns:; The adata with the batch-corrected graph. previous; Preprocessing: PP. next; scanpy.external.pp.harmony_integrate. Contents; . bbknn(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.bbknn.html:13593,perform,performance,13593,en/stable/generated/scanpy.external.pp.bbknn.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.bbknn.html,1,['perform'],['performance']
Performance,"matching mutual nearest neighbors [Haghverdi et al., 2018] [Kang, 2018].; This uses the implementation of mnnpy [Kang, 2018].; Depending on do_concatenate, returns matrices or AnnData objects in the; original order containing corrected expression values or a concatenated; matrix or AnnData object.; Be reminded that it is not advised to use the corrected data matrices for; differential expression testing.; More information and bug reports here. Parameters:. datas AnnData | ndarrayExpression matrices or AnnData objects. Matrices should be shaped like; n_obs × n_vars (n_cell × n_gene) and have consistent number of columns.; AnnData objects should have same number of variables. var_index Collection[str] | None (default: None)The index (list of str) of vars (genes). Necessary when using only a; subset of vars to perform MNN correction, and should be supplied with; var_subset. When datas are AnnData objects, var_index is ignored. var_subset Collection[str] | None (default: None)The subset of vars (list of str) to be used when performing MNN; correction. Typically, a list of highly variable genes (HVGs).; When set to None, uses all vars. batch_key str (default: 'batch')The batch_key for concatenate().; Only valid when do_concatenate and supplying AnnData objects. index_unique str (default: '-')The index_unique for concatenate().; Only valid when do_concatenate and supplying AnnData objects. batch_categories Collection[Any] | None (default: None)The batch_categories for concatenate().; Only valid when do_concatenate and supplying AnnData objects. k int (default: 20)Number of mutual nearest neighbors. sigma float (default: 1.0)The bandwidth of the Gaussian smoothing kernel used to compute the; correction vectors. Default is 1. cos_norm_in bool (default: True)Whether cosine normalization should be performed on the input data prior; to calculating distances between cells. cos_norm_out bool (default: True)Whether cosine normalization should be performed prior to computing corre",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.mnn_correct.html:10729,perform,performing,10729,en/stable/generated/scanpy.external.pp.mnn_correct.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.mnn_correct.html,1,['perform'],['performing']
Performance,"mony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .md. .pdf. Documentation. Contents . Building the docs; Adding to the docs; docstrings format; Plots in docstrings; Params section; Returns section; Examples. Documentation#. Building the docs#; To build the docs, run hatch run docs:build.; Afterwards, you can run hatch run docs:open to open docs/_build/html/index.html.; Your browser and Sphinx cache docs which have been built previously.; Sometimes these caches are not invalidated when you’ve updated the docs.; If docs are not updating the way you expect, first try “force reloading” your browser page – e.g. reload the page without using the cache.; Next, if problems persist, clear the sphinx cache (hatch run docs:clean) and try building them again. Adding to the docs#; For any user-visible changes, please make sure a note has been added to the release notes using hatch run towncrier:create.; We recommend waiting on this until your PR is close to done since this can often causes merge conflicts.; Once you’ve added a new function to the documentation, you’ll need to make sure there is a link somewhere in the documentation site pointing to it.; This should be added to docs/api.md under a relevant heading.; For tutorials and more in depth examples, consider adding a notebook to the scanpy-tutorials repository.; The tutorials are tied to this repository via a submodule.; To update the submodule, run git submodule update --remote from the root of the repositor",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/dev/documentation.html:9619,cache,caches,9619,en/stable/dev/documentation.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/dev/documentation.html,1,['cache'],['caches']
Performance,"n by Pearson residuals and PCA in one go. This function is helpful to quickly obtain a Pearson residual-based data representation when highly variable genes are already defined, as only those are used by default.; sc.experimental.pp.recipe_pearson_residuals() performs gene selection and normalization by Pearson residuals, and PCA on top. This is intended to make the full Pearson residual preprocessing available in one step. All hyperparameters of the individual steps can still be controlled using the wrapper functions’ arguments. See the documentation for details. References / See also#; Hafemeister & Satija (2019), Normalization and variance stabilization of single-cell RNA-seq data using regularized negative binomial regression, Genome Biology; Lause et al. (2021), Analytic Pearson residuals for normalization of single-cell RNA-seq UMI data, Genome Biology; Wagner (2021), Normalization methods for single-cell RNA-Seq data, Youtube; Choudhary & Satija (2022), Comparison and evaluation of statistical error models for scRNA-seq, Genome Biology. previous; Experimental. next; Using dask with Scanpy. Contents; . Background; Preparations; Download data; Load data. Perform Quality control; Basic filtering; Compute quality control metrics; Plot quality control metrics. Use Pearson residuals for selection of highly variable genes; Compute 2000 variable genes with Pearson residuals; Plot gene selection; Apply gene selection; Print resulting adata objects. Transforming raw counts to Pearson residuals; Preparations; Compute Pearson residuals; Compute PCA and t-SNE; Compute Neighborhood graph and Leiden clustering; Plot Leiden clusters on tSNE and PBMC marker genes. Optional input arguments; Overdispersion parameter theta; Clipping threshold clip; chunksize and best practice to obtain Pearson residuals for large datasets. Wrapper functions for Pearson residuals preprocessing; References / See also. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:31201,Load,Load,31201,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,2,"['Load', 'Perform']","['Load', 'Perform']"
Performance,"n residual variance to identify variable genes, but won’t compute all residuals at once. Reduce the chunksize as needed if you run into RAM issues during gene selection. Note that a very small chunksize will slow down the computation, so try to set it as large as possible with your resources.; As an example, we used chunksize=1000 when processing a dataset with 2 million cells in a machine with 500 GB RAM. For smaller machines, we would recommend to reduce this below 100. Wrapper functions for Pearson residuals preprocessing#; The scanpy.experimental.pp module also ships two wrappers that run multiple pre-processing steps at once:. sc.experimental.pp.normalize_pearson_residuals_pca() performs normalization by Pearson residuals and PCA in one go. This function is helpful to quickly obtain a Pearson residual-based data representation when highly variable genes are already defined, as only those are used by default.; sc.experimental.pp.recipe_pearson_residuals() performs gene selection and normalization by Pearson residuals, and PCA on top. This is intended to make the full Pearson residual preprocessing available in one step. All hyperparameters of the individual steps can still be controlled using the wrapper functions’ arguments. See the documentation for details. References / See also#; Hafemeister & Satija (2019), Normalization and variance stabilization of single-cell RNA-seq data using regularized negative binomial regression, Genome Biology; Lause et al. (2021), Analytic Pearson residuals for normalization of single-cell RNA-seq UMI data, Genome Biology; Wagner (2021), Normalization methods for single-cell RNA-Seq data, Youtube; Choudhary & Satija (2022), Comparison and evaluation of statistical error models for scRNA-seq, Genome Biology. previous; Experimental. next; Using dask with Scanpy. Contents; . Background; Preparations; Download data; Load data. Perform Quality control; Basic filtering; Compute quality control metrics; Plot quality control metrics. Use",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:30294,perform,performs,30294,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,2,['perform'],['performs']
Performance,"n=None, *, random_state=0, restrict_to=None, key_added='louvain', adjacency=None, flavor='vtraag', directed=True, use_weights=False, partition_type=None, partition_kwargs=mappingproxy({}), neighbors_key=None, obsp=None, copy=False)[source]#; Cluster cells into subgroups [Blondel et al., 2008, Levine et al., 2015, Traag, 2015].; Cluster cells using the Louvain algorithm [Blondel et al., 2008] in the implementation; of Traag [2015]. The Louvain algorithm has been proposed for single-cell; analysis by Levine et al. [2015].; This requires having ran neighbors() or; bbknn() first,; or explicitly passing a adjacency matrix. Parameters:. adata AnnDataThe annotated data matrix. resolution float | None (default: None)For the default flavor ('vtraag') or for `RAPIDS`, you can provide a; resolution (higher resolution means finding more and smaller clusters),; which defaults to 1.0.; See “Time as a resolution parameter” in Lambiotte et al. [2014]. random_state Union[int, RandomState, None] (default: 0)Change the initialization of the optimization. restrict_to tuple[str, Sequence[str]] | None (default: None)Restrict the clustering to the categories within the key for sample; annotation, tuple needs to contain (obs_key, list_of_categories). key_added str (default: 'louvain')Key under which to add the cluster labels. (default: 'louvain'). adjacency spmatrix | None (default: None)Sparse adjacency matrix of the graph, defaults to neighbors connectivities. flavor Literal['vtraag', 'igraph', 'rapids'] (default: 'vtraag')Choose between to packages for computing the clustering. 'vtraag'Much more powerful than 'igraph', and the default. 'igraph'Built in igraph method. 'rapids'GPU accelerated implementation. Deprecated since version 1.10.0: Use rapids_singlecell.tl.louvain() instead. directed bool (default: True)Interpret the adjacency matrix as directed graph?. use_weights bool (default: False)Use weights from knn graph. partition_type type[MutableVertexPartition] | None (default: None)T",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.louvain.html:10359,optimiz,optimization,10359,en/stable/generated/scanpy.tl.louvain.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.louvain.html,1,['optimiz'],['optimization']
Performance,"n[str] | None (default: None)The subset of vars (list of str) to be used when performing MNN; correction. Typically, a list of highly variable genes (HVGs).; When set to None, uses all vars. batch_key str (default: 'batch')The batch_key for concatenate().; Only valid when do_concatenate and supplying AnnData objects. index_unique str (default: '-')The index_unique for concatenate().; Only valid when do_concatenate and supplying AnnData objects. batch_categories Collection[Any] | None (default: None)The batch_categories for concatenate().; Only valid when do_concatenate and supplying AnnData objects. k int (default: 20)Number of mutual nearest neighbors. sigma float (default: 1.0)The bandwidth of the Gaussian smoothing kernel used to compute the; correction vectors. Default is 1. cos_norm_in bool (default: True)Whether cosine normalization should be performed on the input data prior; to calculating distances between cells. cos_norm_out bool (default: True)Whether cosine normalization should be performed prior to computing corrected expression values. svd_dim int | None (default: None)The number of dimensions to use for summarizing biological substructure; within each batch. If None, biological components will not be removed; from the correction vectors. var_adj bool (default: True)Whether to adjust variance of the correction vectors. Note this step; takes most computing time. compute_angle bool (default: False)Whether to compute the angle between each cell’s correction vector and; the biological subspace of the reference batch. mnn_order Sequence[int] | None (default: None)The order in which batches are to be corrected. When set to None, datas; are corrected sequentially. svd_mode Literal['svd', 'rsvd', 'irlb'] (default: 'rsvd')'svd' computes SVD using a non-randomized SVD-via-ID algorithm,; while 'rsvd' uses a randomized version. 'irlb' perfores; truncated SVD by implicitly restarted Lanczos bidiagonalization; (forked from airysen/irlbpy). do_concatenate bool (defau",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.mnn_correct.html:11659,perform,performed,11659,en/stable/generated/scanpy.external.pp.mnn_correct.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.mnn_correct.html,1,['perform'],['performed']
Performance,"nal.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy._settings.ScanpyConfig. Contents . ScanpyConfig. scanpy._settings.ScanpyConfig#. class scanpy._settings.ScanpyConfig(*, verbosity=Verbosity.warning, plot_suffix='', file_format_data='h5ad', file_format_figs='pdf', autosave=False, autoshow=True, writedir='./write/', cachedir='./cache/', datasetdir='./data/', figdir='./figures/', cache_compression='lzf', max_memory=15, n_jobs=1, logfile=None, categories_to_ignore=('N/A', 'dontknow', 'no_gate', '?'), _frameon=True, _vector_friendly=False, _low_resolution_warning=True, n_pcs=50)[source]#; Config manager for scanpy.; Attributes. autosave; Automatically save figures in figdir (default False). autoshow; Automatically show figures if autosave == False (default True). cache_compression; Compression for sc.read(..., cache=True) (default 'lzf'). cachedir; Directory for cache files (default './cache/'). categories_to_ignore; Categories that are omitted in plotting etc. datasetdir; Directory for example datasets (default './data/'). figdir; Directory for saving figures (default './figures/'). file_format_data; File format for saving AnnData objects. file_format_figs; File format for saving figures. logfile; The open file to write logs to. logpath; The file path logfile was set to. max_memory; Maximum memory usage in Gigabyte. n_jobs; Default number of jobs/ CPUs to use for parallel computing. plot_suffix; Global suffix that is appended to figure filenames. verbosity; Verbosity level (default warning). writedir; Directory where the function scanpy.write writes to by default. N_PCS; Default number of principal components to use. Methods. set_figure_params(*[, scanpy, dpi, ...]); Set resolution/size, styling and format of figures. previous; scanpy.set_figure_params. next; scanpy._settings.ScanpyConfig.autosave. Cont",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy._settings.ScanpyConfig.html:10012,cache,cache,10012,en/stable/generated/scanpy._settings.ScanpyConfig.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy._settings.ScanpyConfig.html,1,['cache'],['cache']
Performance,"nal.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.pp.calculate_qc_metrics. Contents . calculate_qc_metrics(). scanpy.pp.calculate_qc_metrics#. scanpy.pp.calculate_qc_metrics(adata, *, expr_type='counts', var_type='genes', qc_vars=(), percent_top=(50, 100, 200, 500), layer=None, use_raw=False, inplace=False, log1p=True, parallel=None)[source]#; Calculate quality control metrics.; Calculates a number of qc metrics for an AnnData object, see section; Returns for specifics. Largely based on calculateQCMetrics from scater; [McCarthy et al., 2017]. Currently is most efficient on a sparse CSR or dense matrix.; Note that this method can take a while to compile on the first call. That; result is then cached to disk to be used later. Parameters:. adata AnnDataAnnotated data matrix. expr_type str (default: 'counts')Name of kind of values in X. var_type str (default: 'genes')The kind of thing the variables are. qc_vars Collection[str] | str (default: ())Keys for boolean columns of .var which identify variables you could; want to control for (e.g. “ERCC” or “mito”). percent_top Collection[int] | None (default: (50, 100, 200, 500))List of ranks (where genes are ranked by expression) at which the cumulative; proportion of expression will be reported as a percentage. This can be used to; assess library complexity. Ranks are considered 1-indexed, and if empty or None; don’t calculate.; E.g. percent_top=[50] finds cumulative proportion to the 50th most expressed gene. layer str | None (default: None)If provided, use adata.layers[layer] for expression values instead; of adata.X. use_raw bool (default: False)If True, use adata.raw.X for expression values instead of adata.X. inplace bool (default: ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.calculate_qc_metrics.html:9897,cache,cached,9897,en/stable/generated/scanpy.pp.calculate_qc_metrics.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.calculate_qc_metrics.html,1,['cache'],['cached']
Performance,"nal.pp.hashsolo; scanpy.external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.pl.pca_loadings. Contents . pca_loadings(). scanpy.pl.pca_loadings#. scanpy.pl.pca_loadings(adata, components=None, *, include_lowest=True, n_points=None, show=None, save=None)[source]#; Rank genes according to contributions to PCs. Parameters:. adata AnnDataAnnotated data matrix. components str | Sequence[int] | None (default: None)For example, '1,2,3' means [1, 2, 3], first, second, third; principal component. include_lowest bool (default: True)Whether to show the variables with both highest and lowest loadings. show bool | None (default: None)Show the plot, do not return axis. n_points int | None (default: None)Number of variables to plot for each component. save str | bool | None (default: None)If True or a str, save the figure.; A string is appended to the default filename.; Infer the filetype if ending on {'.pdf', '.png', '.svg'}. Examples; import scanpy as sc; adata = sc.datasets.pbmc3k_processed(). Show first 3 components loadings; sc.pl.pca_loadings(adata, components = '1,2,3'). previous; scanpy.pl.pca. next; scanpy.pl.pca_variance_ratio. Contents; . pca_loadings(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pl.pca_loadings.html:9748,load,loadings,9748,en/stable/api/generated/scanpy.pl.pca_loadings.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pl.pca_loadings.html,2,['load'],['loadings']
Performance,"nal.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy._settings.ScanpyConfig. Contents . ScanpyConfig. scanpy._settings.ScanpyConfig#. class scanpy._settings.ScanpyConfig(*, verbosity=Verbosity.warning, plot_suffix='', file_format_data='h5ad', file_format_figs='pdf', autosave=False, autoshow=True, writedir='./write/', cachedir='./cache/', datasetdir='./data/', figdir='./figures/', cache_compression='lzf', max_memory=15, n_jobs=1, logfile=None, categories_to_ignore=('N/A', 'dontknow', 'no_gate', '?'), _frameon=True, _vector_friendly=False, _low_resolution_warning=True, n_pcs=50)[source]#; Config manager for scanpy.; Attributes. autosave; Automatically save figures in figdir (default False). autoshow; Automatically show figures if autosave == False (default True). cache_compression; Compression for sc.read(..., cache=True) (default 'lzf'). cachedir; Directory for cache files (default './cache/'). categories_to_ignore; Categories that are omitted in plotting etc. datasetdir; Directory for example datasets (default './data/'). figdir; Directory for saving figures (default './figures/'). file_format_data; File format for saving AnnData objects. file_format_figs; File format for saving figures. logfile; The open file to write logs to. logpath; The file path logfile was set to. max_memory; Maximum memory usage in Gigabyte. n_job",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy._settings.ScanpyConfig.html:9523,cache,cache,9523,en/stable/generated/scanpy._settings.ScanpyConfig.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy._settings.ScanpyConfig.html,1,['cache'],['cache']
Performance,"nal.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.queries.biomart_annotations. Contents . biomart_annotations(). scanpy.queries.biomart_annotations#. scanpy.queries.biomart_annotations(org, attrs, *, host='www.ensembl.org', use_cache=False)[source]#; Retrieve gene annotations from ensembl biomart. Parameters:. org strOrganism to query. Must be an organism in ensembl biomart. “hsapiens”,; “mmusculus”, “drerio”, etc. attrs Iterable[str]Attributes to query biomart for. host str (default: 'www.ensembl.org')A valid BioMart host URL. Alternative values include archive urls (like; “grch37.ensembl.org”) or regional mirrors (like “useast.ensembl.org”). use_cache bool (default: False)Whether pybiomart should use a cache for requests. Will create a; .pybiomart.sqlite file in current directory if used. Return type:; DataFrame. Returns:; Dataframe containing annotations. Examples; Retrieve genes coordinates and chromosomes; >>> import scanpy as sc; >>> annot = sc.queries.biomart_annotations(; ... ""hsapiens"",; ... [""ensembl_gene_id"", ""start_position"", ""end_position"", ""chromosome_name""],; ... ).set_index(""ensembl_gene_id""); >>> adata.var[annot.columns] = annot. previous; Queries. next; scanpy.queries.gene_coordinates. Contents; . biomart_annotations(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.queries.biomart_annotations.html:9914,cache,cache,9914,en/stable/generated/scanpy.queries.biomart_annotations.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.queries.biomart_annotations.html,1,['cache'],['cache']
Performance,"nal.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .md. .pdf. Preprocessing: pp. Contents . Basic Preprocessing; Recipes; Batch effect correction; Doublet detection; Neighbors. Preprocessing: pp#; Filtering of highly-variable genes, batch-effect correction, per-cell normalization, preprocessing recipes.; Any transformation of the data matrix that is not a tool. Other than tools, preprocessing steps usually don’t return an easily interpretable annotation, but perform a basic transformation on the data matrix. Basic Preprocessing#; For visual quality control, see highest_expr_genes() and; filter_genes_dispersion() in scanpy.pl. pp.calculate_qc_metrics; Calculate quality control metrics. pp.filter_cells; Filter cell outliers based on counts and numbers of genes expressed. pp.filter_genes; Filter genes based on number of cells or counts. pp.highly_variable_genes; Annotate highly variable genes [Satija et al., 2015, Stuart et al., 2019, Zheng et al., 2017]. pp.log1p; Logarithmize the data matrix. pp.pca; Principal component analysis [Pedregosa et al., 2011]. pp.normalize_total; Normalize counts per cell. pp.regress_out; Regress out (mostly) unwanted sources of variation. pp.scale; Scale data to unit variance and zero mean. pp.subsample; Subsample to a fraction of the number of observations. pp.downsample_counts; Downsample counts from count matrix. Recipes#. pp.recipe_zheng17; Normalization and filtering as of Zheng et ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/preprocessing.html:9626,perform,perform,9626,en/stable/api/preprocessing.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/preprocessing.html,1,['perform'],['perform']
Performance,"nnDataAnnotated data matrix. min_dist float (default: 0.5)The effective minimum distance between embedded points. Smaller values; will result in a more clustered/clumped embedding where nearby points on; the manifold are drawn closer together, while larger values will result; on a more even dispersal of points. The value should be set relative to; the spread value, which determines the scale at which embedded; points will be spread out. The default of in the umap-learn package is; 0.1. spread float (default: 1.0)The effective scale of embedded points. In combination with min_dist; this determines how clustered/clumped the embedded points are. n_components int (default: 2)The number of dimensions of the embedding. maxiter int | None (default: None)The number of iterations (epochs) of the optimization. Called n_epochs; in the original UMAP. alpha float (default: 1.0)The initial learning rate for the embedding optimization. gamma float (default: 1.0)Weighting applied to negative samples in low dimensional embedding; optimization. Values higher than one will result in greater weight; being given to negative samples. negative_sample_rate int (default: 5)The number of negative edge/1-simplex samples to use per positive; edge/1-simplex sample in optimizing the low dimensional embedding. init_pos Union[Literal['paga', 'spectral', 'random'], ndarray, None] (default: 'spectral')How to initialize the low dimensional embedding. Called init in the; original UMAP. Options are:. Any key for adata.obsm.; ’paga’: positions from paga().; ’spectral’: use a spectral embedding of the graph.; ’random’: assign initial embedding positions at random.; A numpy array of initial embedding positions. random_state Union[int, RandomState, None] (default: 0)If int, random_state is the seed used by the random number generator;; If RandomState or Generator, random_state is the random number generator;; If None, the random number generator is the RandomState instance used; by np.random. a float | None",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.umap.html:11271,optimiz,optimization,11271,en/stable/generated/scanpy.tl.umap.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.umap.html,1,['optimiz'],['optimization']
Performance,"npyConfig.N_PCS; scanpy._settings.ScanpyConfig.set_figure_params. scanpy.logging.print_header; scanpy.logging.print_versions. Datasets; scanpy.datasets.blobs; scanpy.datasets.ebi_expression_atlas; scanpy.datasets.krumsiek11; scanpy.datasets.moignard15; scanpy.datasets.pbmc3k; scanpy.datasets.pbmc3k_processed; scanpy.datasets.pbmc68k_reduced; scanpy.datasets.paul15; scanpy.datasets.toggleswitch; scanpy.datasets.visium_sge. Deprecated functions; scanpy.pp.filter_genes_dispersion; scanpy.pp.normalize_per_cell. External API; Preprocessing: PP; scanpy.external.pp.bbknn; scanpy.external.pp.harmony_integrate; scanpy.external.pp.mnn_correct; scanpy.external.pp.scanorama_integrate; scanpy.external.pp.hashsolo; scanpy.external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy._settings.ScanpyConfig.categories_to_ignore. Contents . ScanpyConfig.categories_to_ignore. scanpy._settings.ScanpyConfig.categories_to_ignore#. property ScanpyConfig.categories_to_ignore: list[str][source]#; Categories that are omitted in plotting etc. previous; scanpy._settings.ScanpyConfig.cachedir. next; scanpy._settings.ScanpyConfig.datasetdir. Contents; . ScanpyConfig.categories_to_ignore. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy._settings.ScanpyConfig.categories_to_ignore.html:9559,cache,cachedir,9559,en/stable/generated/scanpy._settings.ScanpyConfig.categories_to_ignore.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy._settings.ScanpyConfig.categories_to_ignore.html,1,['cache'],['cachedir']
Performance,"nt | None (default: 1000)Minimum number of principal components to use. Specify None to use; pre-computed components. The higher the value the better to capture 85% of the; variance. n_jobs int (default: -2)Nearest Neighbors will be computed in parallel using n_jobs. copy bool (default: False)Return a copy instead of writing to adata. Return type:; AnnData | None. Returns:; Depending on copy, returns or updates .obsm, .obsp and .uns with the following:. X_harmony - ndarray (obsm, dtype float)force directed layout. harmony_aff - spmatrix (obsp, dtype float)affinity matrix. harmony_aff_aug - spmatrix (obsp, dtype float)augmented affinity matrix. harmony_timepoint_var - str (uns)The name of the variable passed as tp. harmony_timepoint_connections - ndarray (uns, dtype str)The links between time points. Example; >>> from itertools import product; >>> import pandas as pd; >>> from anndata import AnnData; >>> import scanpy as sc; >>> import scanpy.external as sce. Load AnnData; A sample with real data is available here.; Random data sets of three time points with two replicates each:; >>> adata_ref = sc.datasets.pbmc3k(); >>> start = [596, 615, 1682, 1663, 1409, 1432]; >>> adata = AnnData.concatenate(; ... *(adata_ref[i : i + 1000] for i in start),; ... join=""outer"",; ... batch_key=""sample"",; ... batch_categories=[f""sa{i}_Rep{j}"" for i, j in product((1, 2, 3), (1, 2))],; ... ); >>> time_points = adata.obs[""sample""].str.split(""_"", expand=True)[0]; >>> adata.obs[""time_points""] = pd.Categorical(; ... time_points, categories=['sa1', 'sa2', 'sa3']; ... ). Normalize and filter for highly expressed genes; >>> sc.pp.normalize_total(adata, target_sum=10000); >>> sc.pp.log1p(adata); >>> sc.pp.highly_variable_genes(adata, n_top_genes=1000, subset=True). Run harmony_timeseries; >>> sce.tl.harmony_timeseries(adata, tp=""time_points"", n_components=500). Plot time points:; >>> sce.pl.harmony_timeseries(adata). For further demonstration of Harmony visualizations please follow the notebook;",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.harmony_timeseries.html:11727,Load,Load,11727,en/stable/external/generated/scanpy.external.tl.harmony_timeseries.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.harmony_timeseries.html,1,['Load'],['Load']
Performance,"nts.; Harmony [Korsunsky et al., 2019] is an algorithm for integrating single-cell; data from multiple experiments. This function uses the python; port of Harmony, harmonypy, to integrate single-cell data; stored in an AnnData object. As Harmony works by adjusting the; principal components, this function should be run after performing; PCA but before computing the neighbor graph, as illustrated in the; example below. Parameters:. adata AnnDataThe annotated data matrix. key strThe name of the column in adata.obs that differentiates; among experiments/batches. basis str (default: 'X_pca')The name of the field in adata.obsm where the PCA table is; stored. Defaults to 'X_pca', which is the default for; sc.pp.pca(). adjusted_basis str (default: 'X_pca_harmony')The name of the field in adata.obsm where the adjusted PCA; table will be stored after running this function. Defaults to; X_pca_harmony. kwargsAny additional arguments will be passed to; harmonypy.run_harmony(). Returns:; Updates adata with the field adata.obsm[obsm_out_field],; containing principal components adjusted by Harmony such that; different experiments are integrated. Example; First, load libraries and example dataset, and preprocess.; >>> import scanpy as sc; >>> import scanpy.external as sce; >>> adata = sc.datasets.pbmc3k(); >>> sc.pp.recipe_zheng17(adata); >>> sc.pp.pca(adata). We now arbitrarily assign a batch metadata variable to each cell; for the sake of example, but during real usage there would already; be a column in adata.obs giving the experiment each cell came; from.; >>> adata.obs['batch'] = 1350*['a'] + 1350*['b']. Finally, run harmony. Afterwards, there will be a new table in; adata.obsm containing the adjusted PC’s.; >>> sce.pp.harmony_integrate(adata, 'batch'); >>> 'X_pca_harmony' in adata.obsm; True. previous; scanpy.external.pp.bbknn. next; scanpy.external.pp.mnn_correct. Contents; . harmony_integrate(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.harmony_integrate.html:10707,load,load,10707,en/stable/generated/scanpy.external.pp.harmony_integrate.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.harmony_integrate.html,1,['load'],['load']
Performance,"o far is returned. nn_method Literal['kdtree', 'brute'] (default: 'kdtree')Whether to use brute force or kdtree for nearest neighbor search.; For very large high-dimensional data sets, brute force, with parallel; computation, performs faster than kdtree. partition_type type[MutableVertexPartition] | None (default: None)Defaults to RBConfigurationVertexPartition. For the; available options, consult the documentation for; find_partition(). resolution_parameter float (default: 1)A parameter value controlling the coarseness of the clustering in Leiden. Higher; values lead to more clusters. Set to None if overriding partition_type to; one that does not accept a resolution_parameter. n_iterations int (default: -1)Number of iterations to run the Leiden algorithm. If the number of iterations is; negative, the Leiden algorithm is run until an iteration in which there was no; improvement. use_weights bool (default: True)Use vertices in the Leiden computation. seed int | None (default: None)Leiden initialization of the optimization. copy bool (default: False)Return a copy or write to adata. kargs AnyAdditional arguments passed to find_partition() and the; constructor of the partition_type. Return type:; tuple[ndarray | None, spmatrix, float | None] | None. Returns:; Depending on copy, returns or updates adata with the following fields:. communities - ndarray (obs, dtype int)integer array of community assignments for each row in data. graph - spmatrix (obsp, dtype float)the graph that was used for clustering. Q - float (uns, dtype float)the modularity score for communities on graph. Example; >>> from anndata import AnnData; >>> import scanpy as sc; >>> import scanpy.external as sce; >>> import numpy as np; >>> import pandas as pd. With annotated data as input:; >>> adata = sc.datasets.pbmc3k(); >>> sc.pp.normalize_per_cell(adata). Then do PCA:; >>> sc.pp.pca(adata, n_comps=100). Compute phenograph clusters:; Louvain community detection; >>> sce.tl.phenograph(adata, clustering_a",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.phenograph.html:12926,optimiz,optimization,12926,en/stable/external/generated/scanpy.external.tl.phenograph.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.phenograph.html,2,['optimiz'],['optimization']
Performance,"o use different initial states for the optimization. return_info bool (default: False)Only relevant when not passing an AnnData:; see “Returns”. mask_var ndarray[Any, dtype[bool]] | str | None | Empty (default: _empty)To run only on a certain set of genes given by a boolean array; or a string referring to an array in var.; By default, uses .var['highly_variable'] if available, else everything. use_highly_variable bool | None (default: None)Whether to use highly variable genes only, stored in; .var['highly_variable'].; By default uses them if they have been determined beforehand. Deprecated since version 1.10.0: Use mask_var instead. layerLayer of adata to use as expression values. dtype Union[dtype[Any], None, type[Any], _SupportsDType[dtype[Any]], str, tuple[Any, int], tuple[Any, Union[SupportsIndex, Sequence[SupportsIndex]]], list[Any], _DTypeDict, tuple[Any, Any]] (default: 'float32')Numpy data type string to which to convert the result. chunked bool (default: False)If True, perform an incremental PCA on segments of chunk_size.; The incremental PCA automatically zero centers and ignores settings of; random_seed and svd_solver. Uses sklearn IncrementalPCA or; dask-ml IncrementalPCA. If False, perform a full PCA and; use sklearn PCA or; dask-ml PCA. chunk_size int | None (default: None)Number of observations to include in each chunk.; Required if chunked=True was passed. copy bool (default: False)If an AnnData is passed, determines whether a copy; is returned. Is ignored otherwise. Return type:; AnnData | ndarray | spmatrix | None. Returns:; If data is array-like and return_info=False was passed,; this function returns the PCA representation of data as an; array of the same type as the input array.; Otherwise, it returns None if copy=False, else an updated AnnData object.; Sets the following fields:. .obsm['X_pca']spmatrix | ndarray (shape (adata.n_obs, n_comps))PCA representation of data. .varm['PCs']ndarray (shape (adata.n_vars, n_comps))The principal components ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.pca.html:13098,perform,perform,13098,en/stable/generated/scanpy.pp.pca.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.pca.html,1,['perform'],['perform']
Performance,"olution float (default: 1)A parameter value controlling the coarseness of the clustering.; Higher values lead to more clusters.; Set to None if overriding partition_type; to one that doesn’t accept a resolution_parameter. random_state Union[int, RandomState, None] (default: 0)Change the initialization of the optimization. restrict_to tuple[str, Sequence[str]] | None (default: None)Restrict the clustering to the categories within the key for sample; annotation, tuple needs to contain (obs_key, list_of_categories). key_added str (default: 'leiden')adata.obs key under which to add the cluster labels. adjacency spmatrix | None (default: None)Sparse adjacency matrix of the graph, defaults to neighbors connectivities. directed bool | None (default: None)Whether to treat the graph as directed or undirected. use_weights bool (default: True)If True, edge weights from the graph are used in the computation; (placing more emphasis on stronger edges). n_iterations int (default: -1)How many iterations of the Leiden clustering algorithm to perform.; Positive values above 2 define the total number of iterations to perform,; -1 has the algorithm run until it reaches its optimal clustering.; 2 is faster and the default for underlying packages. partition_type type[MutableVertexPartition] | None (default: None)Type of partition to use.; Defaults to RBConfigurationVertexPartition.; For the available options, consult the documentation for; find_partition(). neighbors_key str | None (default: None)Use neighbors connectivities as adjacency.; If not specified, leiden looks .obsp[‘connectivities’] for connectivities; (default storage place for pp.neighbors).; If specified, leiden looks; .obsp[.uns[neighbors_key][‘connectivities_key’]] for connectivities. obsp str | None (default: None)Use .obsp[obsp] as adjacency. You can’t specify both; obsp and neighbors_key at the same time. copy bool (default: False)Whether to copy adata or modify it inplace. flavor Literal['leidenalg', 'igraph'] (default",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.leiden.html:10968,perform,perform,10968,en/stable/generated/scanpy.tl.leiden.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.leiden.html,1,['perform'],['perform']
Performance,"ons of pandas, anndata, numpy, and matplotlib were fixed. pr2816 I Virshup; Fix warnings caused by internal usage of pandas.DataFrame.stack with pandas>=2.1 pr2864I Virshup; scanpy.get.aggregate() now always returns numpy.ndarray pr2893 S Dicks; Removes self from array of neighbors for use_approx_neighbors = True in scrublet() pr2896S Dicks; Compatibility with scipy 1.13 pr2943 I Virshup; Fix use of dendrogram() on highly correlated low precision data pr2928 P Angerer; Fix pytest deprecation warning pr2879 P Angerer. Development Process#. Scanpy is now tested against python 3.12 pr2863 ivirshup; Fix testing package build pr2468 P Angerer. Deprecations#. Dropped support for Python 3.8. More details here. pr2695 P Angerer; Deprecated specifying large numbers of function parameters by position as opposed to by name/keyword in all public APIs.; e.g. prefer sc.tl.umap(adata, min_dist=0.1, spread=0.8) over sc.tl.umap(adata, 0.1, 0.8) pr2702 P Angerer; Dropped support for umap<0.5 for performance reasons. pr2870 P Angerer. Version 1.9#. 1.9.8 2024-01-26#. Bug fixes#. Fix handling of numpy array palettes for old numpy versions pr2832 P Angerer. 1.9.7 2024-01-25#. Bug fixes#. Fix handling of numpy array palettes (e.g. after write-read cycle) pr2734 P Angerer; Specify correct version of matplotlib dependency pr2733 P Fisher; Fix scanpy.pl.violin() usage of seaborn.catplot pr2739 E Roellin; Fix scanpy.pp.highly_variable_genes() to handle the combinations of inplace and subset consistently pr2757 E Roellin; Replace usage of various deprecated functionality from anndata and pandas pr2678 pr2779 P Angerer; Allow to use default n_top_genes when using scanpy.pp.highly_variable_genes() flavor 'seurat_v3' pr2782 P Angerer; Fix scanpy.read_10x_mtx()’s gex_only=True mode pr2801 P Angerer. 1.9.6 2023-10-31#. Bug fixes#. Allow scanpy.pl.scatter() to accept a str palette name pr2571 P Angerer; Make scanpy.external.tl.palantir() compatible with palantir >=1.3 pr2672 DJ Otto; Fix scanpy.pl.",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:19303,perform,performance,19303,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,1,['perform'],['performance']
Performance,"orical for which paga() has been computed. pos ndarray | Path | str | None (default: None)Two-column array-like storing the x and y coordinates for drawing.; Otherwise, path to a .gdf file that has been exported from Gephi or; a similar graph visualization software. layout Union[Literal['fr', 'drl', 'kk', 'grid_fr', 'lgl', 'rt', 'rt_circular', 'fa'], Literal['eq_tree'], None] (default: None)Plotting layout that computes positions.; 'fa' stands for “ForceAtlas2”,; 'fr' stands for “Fruchterman-Reingold”,; 'rt' stands for “Reingold-Tilford”,; 'eq_tree' stands for “eqally spaced tree”.; All but 'fa' and 'eq_tree' are igraph layouts.; All other igraph layouts are also permitted.; See also parameter pos and draw_graph(). layout_kwds Mapping[str, Any] (default: mappingproxy({}))Keywords for the layout. init_pos ndarray | None (default: None)Two-column array storing the x and y coordinates for initializing the; layout. random_state int | None (default: 0)For layouts with random initialization like 'fr', change this to use; different intial states for the optimization. If None, the initial; state is not reproducible. root int | str | Sequence[int] | None (default: 0)If choosing a tree layout, this is the index of the root node or a list; of root node indices. If this is a non-empty vector then the supplied; node IDs are used as the roots of the trees (or a single tree if the; graph is connected). If this is None or an empty list, the root; vertices are automatically calculated based on topological sorting. transitions str | None (default: None)Key for .uns['paga'] that specifies the matrix that stores the; arrows, for instance 'transitions_confidence'. solid_edges str (default: 'connectivities')Key for .uns['paga'] that specifies the matrix that stores the edges; to be drawn solid black. dashed_edges str | None (default: None)Key for .uns['paga'] that specifies the matrix that stores the edges; to be drawn dashed grey. If None, no dashed edges are drawn. single_component boo",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pl.paga.html:12266,optimiz,optimization,12266,en/stable/api/generated/scanpy.pl.paga.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pl.paga.html,1,['optimiz'],['optimization']
Performance,"orithm for clustering. k int (default: 30)Number of nearest neighbors to use in first step of graph construction. directed bool (default: False)Whether to use a symmetric (default) or asymmetric ('directed') graph.; The graph construction process produces a directed graph, which is symmetrized; by one of two methods (see prune below). prune bool (default: False)prune=False, symmetrize by taking the average between the graph and its; transpose. prune=True, symmetrize by taking the product between the graph; and its transpose. min_cluster_size int (default: 10)Cells that end up in a cluster smaller than min_cluster_size are considered; outliers and are assigned to -1 in the cluster labels. jaccard bool (default: True)If True, use Jaccard metric between k-neighborhoods to build graph. If; False, use a Gaussian kernel. primary_metric Literal['euclidean', 'manhattan', 'correlation', 'cosine'] (default: 'euclidean')Distance metric to define nearest neighbors. Note that performance will be; slower for correlation and cosine. n_jobs int (default: -1)Nearest Neighbors and Jaccard coefficients will be computed in parallel using; n_jobs. If 1 is given, no parallelism is used. If set to -1, all CPUs are used.; For n_jobs below -1, n_cpus + 1 + n_jobs are used. q_tol float (default: 0.001)Tolerance, i.e. precision, for monitoring modularity optimization. louvain_time_limit int (default: 2000)Maximum number of seconds to run modularity optimization. If exceeded the best; result so far is returned. nn_method Literal['kdtree', 'brute'] (default: 'kdtree')Whether to use brute force or kdtree for nearest neighbor search.; For very large high-dimensional data sets, brute force, with parallel; computation, performs faster than kdtree. partition_type type[MutableVertexPartition] | None (default: None)Defaults to RBConfigurationVertexPartition. For the; available options, consult the documentation for; find_partition(). resolution_parameter float (default: 1)A parameter value controlling",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.phenograph.html:11390,perform,performance,11390,en/stable/external/generated/scanpy.external.tl.phenograph.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.phenograph.html,2,['perform'],['performance']
Performance,"osystem package listing. Viewers#; Interactive manifold viewers. cellxgene via direct reading of .h5ad CZI; cirrocumulus via direct reading of .h5ad Broad Inst.; cell browser via exporing through cellbrowser() UCSC; SPRING via exporting through spring_project() Harvard Med; vitessce for purely browser based viewing of zarr formatted AnnData files Harvard Med. Portals#. the Gene Expression Analysis Resource U Maryland; the Galaxy Project for the Human Cell Atlas [tweet] U Freiburg; the Expression Atlas EMBL-EBI. Modalities#. RNA velocity#. scVelo Helmholtz Munich. Spatial Transcriptomics Tools#. squidpy Helmholtz Munich. Squidpy is a comprehensive toolkit for working with spatial single cell omics data. PASTE Princeton. PASTE is a computational method to align and integrate spatial transcriptomics data across adjacent tissue slices by leveraging both gene expression similarity and spatial distances between spots. bento 🍱 UC San Diego. Bento is an accessible Python toolkit for performing subcellular analysis of spatial transcriptomics data. Multimodal integration#. MUON and MuData EMBL/ DKFZ. MUON, and it’s associated data structure MuData are designed to organise, analyse, visualise, and exchange multimodal data.; MUON enables a range of analyses for ATAC and CITE-seq, from data preprocessing to flexible multi-omics alignment. Adaptive immune receptor repertoire (AIRR)#. scirpy Medical University of Innsbruck. scirpy is a scanpy extension to expore single-cell T-cell receptor (TCR) and B-cell receptor (BCR) repertoires. dandelion University of Cambridge. dandelion is a single-cell BCR-seq network analysis package that integrates with transcriptomic data analyzed via scanpy. Long reads#. Swan UC Irvine. Swan is a Python library designed for the analysis and visualization of transcriptomes, especially with long-read transcriptomes in mind.; Users can add transcriptomes from different datasets and explore distinct splicing and expression patterns across datasets. Analysi",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/ecosystem.html:10670,perform,performing,10670,en/stable/ecosystem.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/ecosystem.html,1,['perform'],['performing']
Performance,"p; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .md. .pdf. Scanpy – Single-Cell Analysis in Python. Contents . News; rapids-singlecell brings scanpy to the GPU! 2024-03-18; Scanpy hits 100 contributors! 2022-03-31; New community channels 2022-03-31; Toolkit for spatial (squidpy) and multimodal (muon) published 2022-02-01. Scanpy – Single-Cell Analysis in Python#; Scanpy is a scalable toolkit for analyzing single-cell gene expression data; built jointly with anndata. It includes; preprocessing, visualization, clustering, trajectory inference and differential; expression testing. The Python-based implementation efficiently deals with; datasets of more than one million cells.; Discuss usage on the scverse Discourse. Read the documentation.; If you’d like to contribute by opening an issue or creating a pull request, please take a look at our contribution guide.; scanpy is part of the scverse project (website, governance) and is fiscally sponsored by NumFOCUS.; If you like scverse and want to support our mission, please consider making a donation to support our efforts. Installation ; New to scanpy? Check out the installation guide. Installation. Tutorials ; The tutorials walk you through real-world applications of scanpy. Tutorials. API reference ; The API reference contains a detailed description of; the scanpy API. API. Discussion ; Need help? Reach out on our forum to get you",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/index.html:9567,scalab,scalable,9567,en/stable/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/index.html,1,['scalab'],['scalable']
Performance,"pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.queries.mitochondrial_genes. Contents . mitochondrial_genes(). scanpy.queries.mitochondrial_genes#. scanpy.queries.mitochondrial_genes(org, *, attrname='external_gene_name', host='www.ensembl.org', use_cache=False, chromosome='MT')[source]#; Mitochondrial gene symbols for specific organism through BioMart. Parameters:. org strOrganism to query. Must be an organism in ensembl biomart. “hsapiens”,; “mmusculus”, “drerio”, etc. attrname str (default: 'external_gene_name')Biomart attribute field to return. Possible values include; “external_gene_name”, “ensembl_gene_id”, “hgnc_symbol”, “mgi_symbol”,; and “zfin_id_symbol”. host str (default: 'www.ensembl.org')A valid BioMart host URL. Alternative values include archive urls (like; “grch37.ensembl.org”) or regional mirrors (like “useast.ensembl.org”). use_cache bool (default: False)Whether pybiomart should use a cache for requests. Will create a; .pybiomart.sqlite file in current directory if used. chromosome str (default: 'MT')Mitochrondrial chromosome name used in BioMart for organism. Return type:; DataFrame. Returns:; Dataframe containing identifiers for mitochondrial genes. Examples; >>> import scanpy as sc; >>> mito_gene_names = sc.queries.mitochondrial_genes(""hsapiens""); >>> mito_ensembl_ids = sc.queries.mitochondrial_genes(""hsapiens"", attrname=""ensembl_gene_id""); >>> mito_gene_names_fly = sc.queries.mitochondrial_genes(""dmelanogaster"", chromosome=""mitochondrion_genome""). previous; scanpy.queries.gene_coordinates. next; scanpy.queries.enrich. Contents; . mitochondrial_genes(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.queries.mitochondrial_genes.html:10118,cache,cache,10118,en/stable/generated/scanpy.queries.mitochondrial_genes.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.queries.mitochondrial_genes.html,1,['cache'],['cache']
Performance,"presentation is chosen automatically:; For .n_vars < N_PCS (default: 50), .X is used, otherwise ‘X_pca’ is used.; If ‘X_pca’ is not present, it’s computed with default parameters or n_pcs if present. perplexity float | int (default: 30)The perplexity is related to the number of nearest neighbors that; is used in other manifold learning algorithms. Larger datasets; usually require a larger perplexity. Consider selecting a value; between 5 and 50. The choice is not extremely critical since t-SNE; is quite insensitive to this parameter. metric str (default: 'euclidean')Distance metric calculate neighbors on. early_exaggeration float | int (default: 12)Controls how tight natural clusters in the original space are in the; embedded space and how much space will be between them. For larger; values, the space between natural clusters will be larger in the; embedded space. Again, the choice of this parameter is not very; critical. If the cost function increases during initial optimization,; the early exaggeration factor or the learning rate might be too high. learning_rate float | int (default: 1000)Note that the R-package “Rtsne” uses a default of 200.; The learning rate can be a critical parameter. It should be; between 100 and 1000. If the cost function increases during initial; optimization, the early exaggeration factor or the learning rate; might be too high. If the cost function gets stuck in a bad local; minimum increasing the learning rate helps sometimes. random_state Union[int, RandomState, None] (default: 0)Change this to use different intial states for the optimization.; If None, the initial state is not reproducible. n_jobs int | None (default: None)Number of jobs for parallel computation.; None means using scanpy._settings.ScanpyConfig.n_jobs. copy bool (default: False)Return a copy instead of writing to adata. Return type:; AnnData | None. Returns:; Returns None if copy=False, else returns an AnnData object. Sets the following fields:. adata.obsm['X_tsne']nump",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.tsne.html:11207,optimiz,optimization,11207,en/stable/generated/scanpy.tl.tsne.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.tsne.html,1,['optimiz'],['optimization']
Performance,"pressed in the count matrix; the total counts per cell; the percentage of counts in mitochondrial genes. sc.pl.violin(; adata,; [""n_genes_by_counts"", ""total_counts"", ""pct_counts_mt""],; jitter=0.4,; multi_panel=True,; ). Additionally, it is useful to consider QC metrics jointly by inspecting a scatter plot colored by pct_counts_mt. sc.pl.scatter(adata, ""total_counts"", ""n_genes_by_counts"", color=""pct_counts_mt""). Based on the QC metric plots, one could now remove cells that have too many mitochondrial genes expressed or too many total counts by setting manual or automatic thresholds. However, sometimes what appears to be poor QC metrics can be driven by real biology so we suggest starting with a very permissive filtering strategy and revisiting it at a later point. We therefore now only filter cells with less than 100 genes expressed and genes that are detected in less than 3 cells.; Additionally, it is important to note that for datasets with multiple batches, quality control should be performed for each sample individually as quality control thresholds can very substantially between batches. sc.pp.filter_cells(adata, min_genes=100); sc.pp.filter_genes(adata, min_cells=3). Doublet detection#; As a next step, we run a doublet detection algorithm. Identifying doublets is crucial as they can lead to misclassifications or distortions in downstream analysis steps. Scanpy contains the doublet detection method Scrublet [Wolock et al., 2019]. Scrublet predicts cell doublets using a nearest-neighbor classifier of observed transcriptomes and simulated doublets. scanpy.pp.scrublet() adds doublet_score and predicted_doublet to .obs. One can now either filter directly on predicted_doublet or use the doublet_score later during clustering to filter clusters with high doublet scores. sc.pp.scrublet(adata, batch_key=""sample""). We can remove doublets by either filtering out the cells called as doublets, or waiting until we’ve done a clustering pass and filtering out any clusters with h",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering.html:13021,perform,performed,13021,en/stable/tutorials/basics/clustering.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering.html,2,['perform'],['performed']
Performance,"previously, note that there are more sensible alternatives for normalization (see discussion in sc-tutorial paper and more recent alternatives such as SCTransform or GLM-PCA). for adata in [; adata_spatial_anterior,; adata_spatial_posterior,; ]:; sc.pp.normalize_total(adata, inplace=True); sc.pp.log1p(adata); sc.pp.highly_variable_genes(adata, flavor=""seurat"", n_top_genes=2000, inplace=True). normalizing counts per cell; finished (0:00:00); extracting highly variable genes; finished (0:00:00); --> added; 'highly_variable', boolean vector (adata.var); 'means', float vector (adata.var); 'dispersions', float vector (adata.var); 'dispersions_norm', float vector (adata.var); normalizing counts per cell; finished (0:00:00); extracting highly variable genes; finished (0:00:00); --> added; 'highly_variable', boolean vector (adata.var); 'means', float vector (adata.var); 'dispersions', float vector (adata.var); 'dispersions_norm', float vector (adata.var). Data integration#; We are now ready to perform integration of the two dataset. As mentioned before, we will be using Scanorama for that. Scanorama returns two lists, one for the integrated embeddings and one for the corrected counts, for each dataset.; We would like to note that in this context using BBKNN or Ingest is also possible. adatas = [adata_spatial_anterior, adata_spatial_posterior]; adatas_cor = scanorama.correct_scanpy(adatas, return_dimred=True). Found 32285 genes among all datasets; [[0. 0.48882265]; [0. 0. ]]; Processing datasets (0, 1). We will concatenate the two datasets and save the integrated embeddings in adata_spatial.obsm['scanorama_embedding']. Furthermore we will compute UMAP to visualize the results and qualitatively assess the data integration task.; Notice that we are concatenating the two dataset with uns_merge=""unique"" strategy, in order to keep both images from the visium datasets in the concatenated anndata object. adata_spatial = sc.concat(; adatas_cor,; label=""library_id"",; uns_merge=""unique",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html:15923,perform,perform,15923,en/stable/tutorials/spatial/integration-scanorama.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html,2,['perform'],['perform']
Performance,"prune bool (default: False)prune=False, symmetrize by taking the average between the graph and its; transpose. prune=True, symmetrize by taking the product between the graph; and its transpose. min_cluster_size int (default: 10)Cells that end up in a cluster smaller than min_cluster_size are considered; outliers and are assigned to -1 in the cluster labels. jaccard bool (default: True)If True, use Jaccard metric between k-neighborhoods to build graph. If; False, use a Gaussian kernel. primary_metric Literal['euclidean', 'manhattan', 'correlation', 'cosine'] (default: 'euclidean')Distance metric to define nearest neighbors. Note that performance will be; slower for correlation and cosine. n_jobs int (default: -1)Nearest Neighbors and Jaccard coefficients will be computed in parallel using; n_jobs. If 1 is given, no parallelism is used. If set to -1, all CPUs are used.; For n_jobs below -1, n_cpus + 1 + n_jobs are used. q_tol float (default: 0.001)Tolerance, i.e. precision, for monitoring modularity optimization. louvain_time_limit int (default: 2000)Maximum number of seconds to run modularity optimization. If exceeded the best; result so far is returned. nn_method Literal['kdtree', 'brute'] (default: 'kdtree')Whether to use brute force or kdtree for nearest neighbor search.; For very large high-dimensional data sets, brute force, with parallel; computation, performs faster than kdtree. partition_type type[MutableVertexPartition] | None (default: None)Defaults to RBConfigurationVertexPartition. For the; available options, consult the documentation for; find_partition(). resolution_parameter float (default: 1)A parameter value controlling the coarseness of the clustering in Leiden. Higher; values lead to more clusters. Set to None if overriding partition_type to; one that does not accept a resolution_parameter. n_iterations int (default: -1)Number of iterations to run the Leiden algorithm. If the number of iterations is; negative, the Leiden algorithm is run until an it",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.phenograph.html:11762,optimiz,optimization,11762,en/stable/external/generated/scanpy.external.tl.phenograph.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.phenograph.html,2,['optimiz'],['optimization']
Performance,"py._settings.ScanpyConfig.verbosity; scanpy._settings.ScanpyConfig.writedir; scanpy._settings.ScanpyConfig.N_PCS; scanpy._settings.ScanpyConfig.set_figure_params. scanpy.logging.print_header; scanpy.logging.print_versions. Datasets; scanpy.datasets.blobs; scanpy.datasets.ebi_expression_atlas; scanpy.datasets.krumsiek11; scanpy.datasets.moignard15; scanpy.datasets.pbmc3k; scanpy.datasets.pbmc3k_processed; scanpy.datasets.pbmc68k_reduced; scanpy.datasets.paul15; scanpy.datasets.toggleswitch; scanpy.datasets.visium_sge. Deprecated functions; scanpy.pp.filter_genes_dispersion; scanpy.pp.normalize_per_cell. External API; Preprocessing: PP; scanpy.external.pp.bbknn; scanpy.external.pp.harmony_integrate; scanpy.external.pp.mnn_correct; scanpy.external.pp.scanorama_integrate; scanpy.external.pp.hashsolo; scanpy.external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .md. .pdf. How to. How to#; This section contains short examples on how to perform specific tasks with scanpy. Using other kNN libraries in Scanpy; Plotting with Marsilea; Heatmap; Matrixplot; Dot plot; Tracksplot; Stacked Violin; More information. previous; Usage Principles. next; Using other kNN libraries in Scanpy. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/how-to/index.html:9278,perform,perform,9278,en/stable/how-to/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/how-to/index.html,1,['perform'],['perform']
Performance,"py.datasets.krumsiek11; scanpy.datasets.moignard15; scanpy.datasets.pbmc3k; scanpy.datasets.pbmc3k_processed; scanpy.datasets.pbmc68k_reduced; scanpy.datasets.paul15; scanpy.datasets.toggleswitch; scanpy.datasets.visium_sge. Deprecated functions; scanpy.pp.filter_genes_dispersion; scanpy.pp.normalize_per_cell. External API; Preprocessing: PP; scanpy.external.pp.bbknn; scanpy.external.pp.harmony_integrate; scanpy.external.pp.mnn_correct; scanpy.external.pp.scanorama_integrate; scanpy.external.pp.hashsolo; scanpy.external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.datasets.paul15. Contents . paul15(). scanpy.datasets.paul15#. scanpy.datasets.paul15()[source]#; Development of Myeloid Progenitors [Paul et al., 2015].; Non-logarithmized raw data.; The data has been sent out by Email from the Amit Lab. An R version for; loading the data can be found here. Return type:; AnnData. Returns:; Annotated data matrix. Examples; >>> import scanpy as sc; >>> sc.datasets.paul15(); AnnData object with n_obs × n_vars = 2730 × 3451; obs: 'paul15_clusters'; uns: 'iroot'. previous; scanpy.datasets.pbmc68k_reduced. next; scanpy.datasets.toggleswitch. Contents; . paul15(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.datasets.paul15.html:9495,load,loading,9495,en/stable/generated/scanpy.datasets.paul15.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.datasets.paul15.html,1,['load'],['loading']
Performance,"py.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.external.pp.scanorama_integrate. Contents . scanorama_integrate(). scanpy.external.pp.scanorama_integrate#. scanpy.external.pp.scanorama_integrate(adata, key, *, basis='X_pca', adjusted_basis='X_scanorama', knn=20, sigma=15, approx=True, alpha=0.1, batch_size=5000, **kwargs)[source]#; Use Scanorama [Hie et al., 2019] to integrate different experiments.; Scanorama [Hie et al., 2019] is an algorithm for integrating single-cell; data from multiple experiments stored in an AnnData object. This; function should be run after performing PCA but before computing; the neighbor graph, as illustrated in the example below.; This uses the implementation of scanorama [Hie et al., 2019]. Parameters:. adata AnnDataThe annotated data matrix. key strThe name of the column in adata.obs that differentiates; among experiments/batches. Cells from the same batch must be; contiguously stored in adata. basis str (default: 'X_pca')The name of the field in adata.obsm where the PCA table is; stored. Defaults to 'X_pca', which is the default for; sc.pp.pca(). adjusted_basis str (default: 'X_scanorama')The name of the field in adata.obsm where the integrated; embeddings will be stored after running this function. Defaults; to X_scanorama. knn int (default: 20)Number of nearest neighbors to use for matching. sigma float (default: 15)Correction smoothing parameter on Gaussian kernel. approx bool (default: True)Use approximate nearest neighbors with Python annoy;; greatly speeds up matching runtime. alpha float (default: 0.1)Alignment score minimum cutoff. batc",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.scanorama_integrate.html:9779,perform,performing,9779,en/stable/generated/scanpy.external.pp.scanorama_integrate.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.scanorama_integrate.html,1,['perform'],['performing']
Performance,"r [Eraslan et al., 2019].; Fits a count autoencoder to the raw count data given in the anndata object; in order to denoise the data and to capture hidden representation of; cells in low dimensions. Type of the autoencoder and return values are; determined by the parameters. Note; More information and bug reports here. Parameters:. adata AnnDataAn anndata file with .raw attribute representing raw counts. mode Literal['denoise', 'latent'] (default: 'denoise')denoise overwrites adata.X with denoised expression values.; In latent mode DCA adds adata.obsm['X_dca'] to given adata; object. This matrix represent latent representation of cells via DCA. ae_type Literal['zinb-conddisp', 'zinb', 'nb-conddisp', 'nb'] (default: 'nb-conddisp')Type of the autoencoder. Return values and the architecture is; determined by the type e.g. nb does not provide dropout; probabilities. Types that end with “-conddisp”, assumes that dispersion is mean dependant. normalize_per_cell bool (default: True)If true, library size normalization is performed using; the sc.pp.normalize_per_cell function in Scanpy and saved into adata; object. Mean layer is re-introduces library size differences by; scaling the mean value of each cell in the output layer. See the; manuscript for more details. scale bool (default: True)If true, the input of the autoencoder is centered using; sc.pp.scale function of Scanpy. Note that the output is kept as raw; counts as loss functions are designed for the count data. log1p bool (default: True)If true, the input of the autoencoder is log transformed with a; pseudocount of one using sc.pp.log1p function of Scanpy. hidden_size Sequence[int] (default: (64, 32, 64))Width of hidden layers. hidden_dropout float | Sequence[float] (default: 0.0)Probability of weight dropout in the autoencoder (per layer if list; or tuple). batchnorm bool (default: True)If true, batch normalization is performed. activation str (default: 'relu')Activation function of hidden layers. init str (default: ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.dca.html:10838,perform,performed,10838,en/stable/generated/scanpy.external.pp.dca.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.dca.html,1,['perform'],['performed']
Performance,"r labels. jaccard bool (default: True)If True, use Jaccard metric between k-neighborhoods to build graph. If; False, use a Gaussian kernel. primary_metric Literal['euclidean', 'manhattan', 'correlation', 'cosine'] (default: 'euclidean')Distance metric to define nearest neighbors. Note that performance will be; slower for correlation and cosine. n_jobs int (default: -1)Nearest Neighbors and Jaccard coefficients will be computed in parallel using; n_jobs. If 1 is given, no parallelism is used. If set to -1, all CPUs are used.; For n_jobs below -1, n_cpus + 1 + n_jobs are used. q_tol float (default: 0.001)Tolerance, i.e. precision, for monitoring modularity optimization. louvain_time_limit int (default: 2000)Maximum number of seconds to run modularity optimization. If exceeded the best; result so far is returned. nn_method Literal['kdtree', 'brute'] (default: 'kdtree')Whether to use brute force or kdtree for nearest neighbor search.; For very large high-dimensional data sets, brute force, with parallel; computation, performs faster than kdtree. partition_type type[MutableVertexPartition] | None (default: None)Defaults to RBConfigurationVertexPartition. For the; available options, consult the documentation for; find_partition(). resolution_parameter float (default: 1)A parameter value controlling the coarseness of the clustering in Leiden. Higher; values lead to more clusters. Set to None if overriding partition_type to; one that does not accept a resolution_parameter. n_iterations int (default: -1)Number of iterations to run the Leiden algorithm. If the number of iterations is; negative, the Leiden algorithm is run until an iteration in which there was no; improvement. use_weights bool (default: True)Use vertices in the Leiden computation. seed int | None (default: None)Leiden initialization of the optimization. copy bool (default: False)Return a copy or write to adata. kargs AnyAdditional arguments passed to find_partition() and the; constructor of the partition_type.",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.phenograph.html:12128,perform,performs,12128,en/stable/external/generated/scanpy.external.tl.phenograph.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.phenograph.html,2,['perform'],['performs']
Performance,"ries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.datasets.pbmc3k_processed. Contents . pbmc3k_processed(). scanpy.datasets.pbmc3k_processed#. scanpy.datasets.pbmc3k_processed()[source]#; Processed 3k PBMCs from 10x Genomics.; Processed using the basic tutorial Preprocessing and clustering 3k PBMCs (legacy workflow).; For preprocessing, cells are filtered out that have few gene counts or too high a percent_mito.; The counts are logarithmized and only genes marked by highly_variable_genes() are retained.; The obs variables n_counts and percent_mito are corrected for; using regress_out(), and values are scaled and clipped by scale().; Finally, pca() and neighbors() are calculated.; As analysis steps, the embeddings tsne() and umap() are performed.; Communities are identified using louvain() and marker genes using rank_genes_groups(). Return type:; AnnData. Returns:; Annotated data matrix. Examples; >>> import scanpy as sc; >>> sc.datasets.pbmc3k_processed(); AnnData object with n_obs × n_vars = 2638 × 1838; obs: 'n_genes', 'percent_mito', 'n_counts', 'louvain'; var: 'n_cells'; uns: 'draw_graph', 'louvain', 'louvain_colors', 'neighbors', 'pca', 'rank_genes_groups'; obsm: 'X_pca', 'X_tsne', 'X_umap', 'X_draw_graph_fr'; varm: 'PCs'; obsp: 'distances', 'connectivities'. previous; scanpy.datasets.pbmc3k. next; scanpy.datasets.pbmc68k_reduced. Contents; . pbmc3k_processed(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.datasets.pbmc3k_processed.html:9943,perform,performed,9943,en/stable/generated/scanpy.datasets.pbmc3k_processed.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.datasets.pbmc3k_processed.html,1,['perform'],['performed']
Performance,"rimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .md. .pdf. Documentation. Contents . Building the docs; Adding to the docs; docstrings format; Plots in docstrings; Params section; Returns section; Examples. Documentation#. Building the docs#; To build the docs, run hatch run docs:build.; Afterwards, you can run hatch run docs:open to open docs/_build/html/index.html.; Your browser and Sphinx cache docs which have been built previously.; Sometimes these caches are not invalidated when you’ve updated the docs.; If docs are not updating the way you expect, first try “force reloading” your browser page – e.g. reload the page without using the cache.; Next, if problems persist, clear the sphinx cache (hatch run docs:clean) and try building them again. Adding to the docs#; For any user-visible changes, please make sure a note has been added to the release notes using hatch run towncrier:create.; We recommend waiting on this until your PR is close to done since this can often causes merge conflicts.; Once you’ve added a new function to the documentation, you’ll need to make sure there is a link somewhere in the documentation site pointing to it.; This should be added to docs/api.md under a relevant heading.; For tutorials and more in depth examples, consider adding a notebook to the scanpy-tutorials repository.; The tutorials are tied to this repository via a submodule.; To update the submodule, run git submodule update --remote from the root of the repository.; Subsequently, commit and push the changes in a PR.; This should be done before each release to ensure the tutorials are up to date. docstrings format#; We use the numpydoc style for writing docstrings.; We’d primarily suggest",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/dev/documentation.html:9861,cache,cache,9861,en/stable/dev/documentation.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/dev/documentation.html,1,['cache'],['cache']
Performance,"rsion requirement of scipy to scipy>1.4 to support rmatmat argument of LinearOperator issue1246 I Virshup; Fix asymmetry of scores for the 'wilcoxon' method in rank_genes_groups() issue754 S Rybakov; Avoid trimming of gene names in rank_genes_groups() issue753 S Rybakov. Version 1.5#. 1.5.1 2020-05-21#. Bug fixes#. Fixed a bug in pca(), where random_state did not have an effect for sparse input pr1240 I Virshup; Fixed docstring in pca() which included an unused argument pr1240 I Virshup. 1.5.0 2020-05-15#; The 1.5.0 release adds a lot of new functionality, much of which takes advantage of anndata updates 0.7.0 - 0.7.2. Highlights of this release include support for spatial data, dedicated handling of graphs in AnnData, sparse PCA, an interface with scvi, and others. Spatial data support#. Basic analysis Analysis and visualization of spatial transcriptomics data and integration with single cell data Integrating spatial data with scRNA-seq using scanorama G Palla; read_visium() read 10x Visium data pr1034 G Palla, P Angerer, I Virshup; visium_sge() load Visium data directly from 10x Genomics pr1013 M Mirkazemi, G Palla, P Angerer; spatial() plot spatial data pr1012 G Palla, P Angerer. New functionality#. Many functions, like neighbors() and umap(), now store cell-by-cell graphs in obsp pr1118 S Rybakov; scale() and log1p() can be used on any element in layers or obsm pr1173 I Virshup. External tools#. scanpy.external.pp.scvi for preprocessing with scVI pr1085 G Xing; Guide for using Scanpy in R pr1186 L Zappia. Performance#. pca() now uses efficient implicit centering for sparse matrices. This can lead to signifigantly improved performance for large datasets pr1066 A Tarashansky; score_genes() now has an efficient implementation for sparse matrices with missing values pr1196 redst4r. Warning; The new pca() implementation can result in slightly different results for sparse matrices. See the pr (pr1066) and documentation for more info. Code design#. stacked_violin() can",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:38046,load,load,38046,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,1,['load'],['load']
Performance,"s 'pca_only'. knn int (default: 5)number of nearest neighbors on which to build kernel. decay float | None (default: 1)sets decay rate of kernel tails.; If None, alpha decaying kernel is not used. knn_max int | None (default: None)maximum number of nearest neighbors with nonzero connection.; If None, will be set to 3 * knn. t Union[Literal['auto'], int] (default: 3)power to which the diffusion operator is powered.; This sets the level of diffusion. If ‘auto’, t is selected; according to the Procrustes disparity of the diffused data. n_pca int | None (default: 100)Number of principal components to use for calculating; neighborhoods. For extremely large datasets, using; n_pca < 20 allows neighborhoods to be calculated in; roughly log(n_samples) time. If None, no PCA is performed. solver Literal['exact', 'approximate'] (default: 'exact')Which solver to use. “exact” uses the implementation described; in van Dijk et al. [2018]. “approximate” uses a faster; implementation that performs imputation in the PCA space and then; projects back to the gene space. Note, the “approximate” solver may; return negative values. knn_dist str (default: 'euclidean')recommended values: ‘euclidean’, ‘cosine’, ‘precomputed’; Any metric from scipy.spatial.distance can be used; distance metric for building kNN graph. If ‘precomputed’,; data should be an n_samples x n_samples distance or; affinity matrix. random_state Union[int, RandomState, None] (default: None)Random seed. Defaults to the global numpy random number generator. n_jobs int | None (default: None)Number of threads to use in training. All cores are used by default. verbose bool (default: False)If True or an integer >= 2, print status messages.; If None, sc.settings.verbosity is used. copy bool | None (default: None)If true, a copy of anndata is returned. If None, copy is True if; genes is not 'all_genes' or 'pca_only'. copy may only be False; if genes is 'all_genes' or 'pca_only', as the resultant data; will otherwise have different",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.magic.html:11571,perform,performs,11571,en/stable/generated/scanpy.external.pp.magic.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.magic.html,1,['perform'],['performs']
Performance,"s are clipped to the interval [-c, c]. Set clip=np.inf for no clipping. n_top_genes int (default: 1000)Number of highly-variable genes to keep. Mandatory if flavor='seurat_v3' or; flavor='pearson_residuals'. batch_key str | None (default: None)If specified, highly-variable genes are selected within each batch separately; and merged. This simple process avoids the selection of batch-specific genes; and acts as a lightweight batch correction method. Genes are first sorted by; how many batches they are a HVG. If flavor='pearson_residuals', ties are; broken by the median rank (across batches) based on within-batch residual; variance. chunksize int (default: 1000)If flavor='pearson_residuals', this dertermines how many genes are processed at; once while computing the residual variance. Choosing a smaller value will reduce; the required memory. n_comps int | None (default: 50)Number of principal components to compute in the PCA step. random_state float | None (default: 0)Random seed for setting the initial states for the optimization in the PCA step. kwargs_pca dict (default: {})Dictionary of further keyword arguments passed on to scanpy.pp.pca(). check_values bool (default: True)If True, checks if counts in selected layer are integers as expected by this; function, and return a warning if non-integers are found. Otherwise, proceed; without checking. Setting this to False can speed up code for large datasets. inplace bool (default: True)If True, update adata with results. Otherwise, return results. See below for; details of what is returned. Return type:; tuple[AnnData, DataFrame] | None. Returns:; If inplace=False, separately returns the gene selection results (as; DataFrame) and Pearson residual-based PCA results (as; AnnData). If inplace=True, updates adata with the; following fields for gene selection results:. .var['highly_variable']boolboolean indicator of highly-variable genes. .var['means']floatmeans per gene. .var['variances']floatvariances per gene. .var['residua",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.recipe_pearson_residuals.html:11506,optimiz,optimization,11506,en/stable/generated/scanpy.experimental.pp.recipe_pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.recipe_pearson_residuals.html,1,['optimiz'],['optimization']
Performance,"s]"" sklearn_ann annoy. from pathlib import Path. import numpy as np; import dask.distributed as dd; import scanpy as sc; import anndata as ad; import h5py. sc.logging.print_header(). scanpy==1.10.0rc2.dev103+gc6766d75 anndata==0.11.0.dev157+ge0b81f1.d20240812 umap==0.5.6 numpy==2.0.1 scipy==1.14.0 pandas==2.2.2 scikit-learn==1.5.1 statsmodels==0.14.2 igraph==0.11.6 pynndescent==0.5.13. Here, we’ll be working with a moderately large dataset of 1.4 million cells taken from: COVID-19 immune features revealed by a large-scale single-cell transcriptome atlas. if not Path(""cell_atlas.h5ad"").exists():; !wget https://datasets.cellxgene.cziscience.com/82eac9c1-485f-4e21-ab21-8510823d4f6e.h5ad -O ""cell_atlas.h5ad"". For more information on using distributed computing via dask, please see their documentation. In short, one needs to define both a cluster and a client to have some degree of control over the compute resources dask will use. It’s very likely you will have to tune the number of workers and amount of memory per worker along with your chunk sizes. cluster = dd.LocalCluster(n_workers=3); client = dd.Client(cluster). Note; In this notebook we will be demonstrating some computations in scanpy that use scipy.sparse classes within each dask chunk. Be aware that this is currently poorly supported by dask, and that if you want to interact with the dask arrays in any way other than though the anndata and scanpy libraries you will likely need to densify each chunk.; All operations in scanpy and anndata that work with sparse chunks also work with dense chunks.; The advantage of using sparse chunks are:. The ability to work with fewer, larger chunks; Accelerated computations per chunk (e.g. don’t need to sum all those extra zeros). You can convert from sparse to dense chunks via:; X = X.map_blocks(lambda x: x.toarray(), dtype=X.dtype, meta=np.array([])). And in reverse:; X = X.map_blocks(sparse.csr_matrix). Note that you will likely have to work with smaller chunks when doing th",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/dask.html:10930,tune,tune,10930,en/stable/tutorials/experimental/dask.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/dask.html,2,['tune'],['tune']
Performance,"sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.read. Contents . read(). scanpy.read#. scanpy.read(filename, backed=None, *, sheet=None, ext=None, delimiter=None, first_column_names=False, backup_url=None, cache=False, cache_compression=_empty, **kwargs)[source]#; Read file and return AnnData object.; To speed up reading, consider passing cache=True, which creates an hdf5; cache file. Parameters:. filename Path | strIf the filename has no file extension, it is interpreted as a key for; generating a filename via sc.settings.writedir / (filename +; sc.settings.file_format_data). This is the same behavior as in; sc.read(filename, ...). backed Optional[Literal['r', 'r+']] (default: None)If 'r', load AnnData in backed mode instead; of fully loading it into memory (memory mode). If you want to modify; backed attributes of the AnnData object, you need to choose 'r+'. sheet str | None (default: None)Name of sheet/table in hdf5 or Excel file. ext str | None (default: None)Extension that indicates the file type. If None, uses extension of; filename. delimiter str | None (default: None)Delimiter that separates data within text file. If None, will split at; arbitrary number of white spaces, which is different from enforcing; splitting at any single white space ' '. first_column_names bool (default: False)Assume the first column stores row names. This is only necessary if; these are not strings: strings in the first column are automatically; assumed to be row names. backup_url str | None (default: None)Retrieve the file from an URL if not present on disk. cache bool (default: False)If False, read from source, if True, read from fast ‘h5ad’ cache. cache_compression Union[Literal['gzip', 'lzf'], No",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.read.html:9879,load,load,9879,en/stable/generated/scanpy.read.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.read.html,2,['load'],"['load', 'loading']"
Performance,"sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.experimental.pp.recipe_pearson_residuals. Contents . recipe_pearson_residuals(). scanpy.experimental.pp.recipe_pearson_residuals#. scanpy.experimental.pp.recipe_pearson_residuals(adata, *, theta=100, clip=None, n_top_genes=1000, batch_key=None, chunksize=1000, n_comps=50, random_state=0, kwargs_pca={}, check_values=True, inplace=True)[source]#; Full pipeline for HVG selection and normalization by analytic Pearson residuals [Lause et al., 2021].; Applies gene selection based on Pearson residuals. On the resulting subset,; Pearson residual normalization and PCA are performed.; Expects raw count input. Parameters:. adata AnnDataThe annotated data matrix of shape n_obs × n_vars.; Rows correspond to cells and columns to genes. theta float (default: 100)The negative binomial overdispersion parameter theta for Pearson residuals.; Higher values correspond to less overdispersion (var = mean + mean^2/theta), and theta=np.inf corresponds to a Poisson model. clip float | None (default: None)Determines if and how residuals are clipped:. If None, residuals are clipped to the interval [-sqrt(n_obs), sqrt(n_obs)], where n_obs is the number of cells in the dataset (default behavior).; If any scalar c, residuals are clipped to the interval [-c, c]. Set clip=np.inf for no clipping. n_top_genes int (default: 1000)Number of highly-variable genes to keep. Mandatory if flavor='seurat_v3' or; flavor='pearson_residuals'. batch_key str | None (default: None)If specified, highly-variable genes are selected within each batch separately; and m",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.recipe_pearson_residuals.html:9833,perform,performed,9833,en/stable/generated/scanpy.experimental.pp.recipe_pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.recipe_pearson_residuals.html,1,['perform'],['performed']
Performance,"scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .ipynb. .pdf. Integrating spatial data with scRNA-seq using scanorama. Contents . Loading libraries; Reading the data; Data integration; Data integration and label transfer from scRNA-seq dataset. Integrating spatial data with scRNA-seq using scanorama#; Author: Giovanni Palla. Note; For up-to-date analysis tutorials, kindly check out SquidPy tutorials. This tutorial shows how to work with multiple Visium datasets and perform integration of scRNA-seq dataset with Scanpy. It follows the previous tutorial on analysis and visualization of spatial transcriptomics data.; We will use Scanorama paper - code to perform integration and label transfer. It has a convenient interface with scanpy and anndata.; To install the required libraries, type the following:; pip install git+https://github.com/theislab/scanpy.git; pip install git+https://github.com/theislab/anndata.git; pip install scanorama. Loading libraries#. import scanpy as sc; import anndata as an; import pandas as pd; import numpy as np; import matplotlib.pyplot as plt; import seaborn as sns; import scanorama. from pathlib import Path. sc.logging.print_versions(); sc.set_figure_params(facecolor=""white"", figsize=(8, 8)); sc.settings.verbosity = 3. -----; anndata 0.11.0.dev78+g64ab900; scanpy 1.10.0rc2.dev6+g14555ba4; -----; PIL 10.2.0; annoy NA; anyio NA; appnope 0.1.3; arrow 1.3.0; asciitree NA; asttokens NA; attr 23.2.0; attrs 23.2.0; babel 2.14.0; certifi 2023.11.17; cffi 1.16.0; charset_normalizer 3.3.2; cloudpickle 3.0.0; comm 0.2.1; cycler 0.12.1; cython_runtime NA; dask 2024.1.0; dateutil 2.8.2; debugpy 1.8.0; decorator 5.1.1; d",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html:9864,perform,perform,9864,en/stable/tutorials/spatial/integration-scanorama.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html,2,['perform'],['perform']
Performance,"see below. It is potentially more faithful to the global connectivity of the manifold than tSNE, i.e., it better preserves trajectories. In some ocassions, you might still observe disconnected clusters and similar connectivity violations. They can usually be remedied by running:; sc.tl.paga(adata); sc.pl.paga(adata, plot=False) # remove `plot=False` if you want to see the coarse-grained graph; sc.tl.umap(adata, init_pos='paga'). sc.tl.umap(adata). computing UMAP; finished: added; 'X_umap', UMAP coordinates (adata.obsm) (0:00:03). sc.pl.umap(adata, color=[""CST3"", ""NKG7"", ""PPBP""]). As we set the .raw attribute of adata, the previous plots showed the “raw” (normalized, logarithmized, but uncorrected) gene expression. You can also plot the scaled and corrected gene expression by explicitly stating that you don’t want to use .raw. sc.pl.umap(adata, color=[""CST3"", ""NKG7"", ""PPBP""], use_raw=False). Clustering the neighborhood graph#; As with Seurat and many other frameworks, we recommend the Leiden graph-clustering method (community detection based on optimizing modularity) by Traag et al. (2018). Note that Leiden clustering directly clusters the neighborhood graph of cells, which we already computed in the previous section. sc.tl.leiden(; adata,; resolution=0.9,; random_state=0,; flavor=""igraph"",; n_iterations=2,; directed=False,; ). running Leiden clustering; finished: found 8 clusters and added; 'leiden', the cluster labels (adata.obs, categorical) (0:00:00). Plot the clusters, which agree quite well with the result of Seurat. sc.pl.umap(adata, color=[""leiden"", ""CST3"", ""NKG7""]). Save the result. adata.write(results_file). Finding marker genes#; Let us compute a ranking for the highly differential genes in each cluster. For this, by default, the .raw attribute of AnnData is used in case it has been initialized before. The simplest and fastest method to do so is the t-test. sc.tl.rank_genes_groups(adata, ""leiden"", method=""t-test""); sc.pl.rank_genes_groups(adata, n_genes=25,",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering-2017.html:18703,optimiz,optimizing,18703,en/stable/tutorials/basics/clustering-2017.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering-2017.html,2,['optimiz'],['optimizing']
Performance,"sing key=dendrogram_leiden_res_0.50). Running `sc.tl.dendrogram` with default parameters. For fine tuning it is recommended to run `sc.tl.dendrogram` independently. We can then use these genes to figure out what cell types we’re looking at. For example, Cluster 7 is expressing NKG7 and GNLY, suggesting these are NK cells.; To create your own plots, or use a more automated approach, the differentially expressed genes can be extracted in a convenient format with scanpy.get.rank_genes_groups_df(). sc.get.rank_genes_groups_df(adata, group=""7"").head(5). names; scores; logfoldchanges; pvals; pvals_adj. 0; NKG7; 35.376785; 6.544684; 3.885326e-274; 9.102153e-270. 1; KLRD1; 33.815022; 5.840619; 1.186288e-250; 1.389558e-246. 2; GNLY; 33.775005; 7.383827; 4.592379e-250; 3.586189e-246. 3; CST7; 33.003643; 5.238780; 7.201598e-239; 4.217796e-235. 4; PRF1; 32.752277; 5.397196; 2.817787e-235; 1.320246e-231. dc_cluster_genes = sc.get.rank_genes_groups_df(adata, group=""7"").head(5)[""names""]; sc.pl.umap(; adata,; color=[*dc_cluster_genes, ""leiden_res_0.50""],; legend_loc=""on data"",; frameon=False,; ncols=3,; ). You may have noticed that the p-values found here are extremely low. This is due to the statistical test being performed considering each cell as an independent sample. For a more conservative approach you may want to consider “pseudo-bulking” your data by sample (e.g. sc.get.aggregate(adata, by=[""sample"", ""cell_type""], func=""sum"", layer=""counts"")) and using a more powerful differential expression tool, like pydeseq2. previous; Basics. next; Preprocessing and clustering 3k PBMCs (legacy workflow). Contents; . Quality Control; Doublet detection. Normalization; Feature selection; Dimensionality Reduction; Nearest neighbor graph constuction and visualization; Clustering; Re-assess quality control and cell filtering; Manual cell-type annotation; Marker gene set; Differentially-expressed Genes as Markers. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering.html:24765,perform,performed,24765,en/stable/tutorials/basics/clustering.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering.html,2,['perform'],['performed']
Performance,"spatial[adata_spatial.obs.library_id == library, :].copy(); sc.pl.spatial(; ad,; img_key=""hires"",; library_id=library,; color=""clusters"",; size=1.5,; palette=[; v; for k, v in clusters_colors.items(); if k in ad.obs.clusters.unique().tolist(); ],; legend_loc=None,; show=False,; ax=axs[i],; ). plt.tight_layout(). WARNING: Length of palette colors is smaller than the number of categories (palette length: 16, categories length: 18. Some categories will have the same color.; WARNING: Length of palette colors is smaller than the number of categories (palette length: 14, categories length: 18. Some categories will have the same color. From the clusters, we can clearly see the stratification of the cortical layer in both of the tissues (see the Allen brain atlas for reference). Furthermore, it seems that the dataset integration worked well, since there is a clear continuity between clusters in the two tissues. Data integration and label transfer from scRNA-seq dataset#; We can also perform data integration between one scRNA-seq dataset and one spatial transcriptomics dataset. Such task is particularly useful because it allows us to transfer cell type labels to the Visium dataset, which were dentified from the scRNA-seq dataset.; For this task, we will be using a dataset from Tasic et al., where the mouse cortex was profiled with smart-seq technology.; The dataset can be downloaded from GEO count - metadata.; Conveniently, you can also download the pre-processed dataset in h5ad format from here.; Since the dataset was generated from the mouse cortex, we will subset the visium dataset in order to select only the spots part of the cortex. Note that the integration can also be performed on the whole brain slice, but it would give rise to false positive cell type assignments and and therefore it should be interpreted with more care.; The integration task will be performed with Scanorama: each Visium dataset will be integrated with the smart-seq cortex dataset.; The following cel",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html:19410,perform,perform,19410,en/stable/tutorials/spatial/integration-scanorama.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html,2,['perform'],['perform']
Performance,"st as tSNE,; in contrast to tSNE, UMAP directly embeds the single-cell graph and is faster;; UMAP is also used for measuring connectivities and computing neighbors,; see neighbors() A Wolf; graph abstraction: AGA is renamed to PAGA: paga(); now,; it only measures connectivities between partitions of the single-cell graph,; pseudotime and clustering need to be computed separately via; louvain() and dpt(), the; connectivity measure has been improved A Wolf; logistic regression for finding marker genes; rank_genes_groups() with parameter method='logreg' A Wolf; louvain() provides a better implementation for; reclustering via restrict_to A Wolf; scanpy no longer modifies rcParams upon import, call; settings.set_figure_params to set the ‘scanpy style’ A Wolf; default cache directory is ./cache/, set settings.cachedir to change; this; nested directories in this are avoided A Wolf; show edges in scatter plots based on graph visualization; draw_graph() and umap() by passing edges=True A Wolf; downsample_counts() for downsampling counts MD Luecken; default 'louvain_groups' are called 'louvain' A Wolf; 'X_diffmap' contains the zero component, plotting remains unchanged A Wolf. Version 0.4#. 0.4.4 2018-02-26#. embed cells using umap() [McInnes et al., 2018] pr92 G Eraslan; score sets of genes, e.g. for cell cycle, using score_genes() [Satija et al., 2015]:; notebook. 0.4.3 2018-02-09#. clustermap(): heatmap from hierarchical clustering,; based on seaborn.clustermap() [Waskom et al., 2016] A Wolf; only return matplotlib.axes.Axes in plotting functions of sc.pl; when show=False, otherwise None A Wolf. 0.4.2 2018-01-07#. amendments in PAGA and its plotting functions A Wolf. 0.4.0 2017-12-23#. export to SPRING [Weinreb et al., 2017] for interactive visualization of data:; spring tutorial S Wollock. Version 0.3#. 0.3.2 2017-11-29#. finding marker genes via rank_genes_groups_violin() improved,; see issue51 F Ramirez. 0.3.0 2017-11-16#. AnnData gains method concatenate() A Wolf; AnnD",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:50450,cache,cachedir,50450,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,1,['cache'],['cachedir']
Performance,"subset.copy(); adata_posterior_subset_transfer.obs = pd.concat(; [adata_posterior_subset.obs, cp_posterior_df], axis=1; ). We are then able to explore how cell types are propagated from the scRNA-seq dataset to the visium dataset. Let’s first visualize the neurons cortical layers. sc.pl.spatial(; adata_anterior_subset_transfer,; img_key=""hires"",; color=[""L2/3 IT"", ""L4"", ""L5 PT"", ""L6 CT""],; size=1.5,; ); sc.pl.spatial(; adata_posterior_subset_transfer,; img_key=""hires"",; color=[""L2/3 IT"", ""L4"", ""L5 PT"", ""L6 CT""],; size=1.5,; ). Interestingly, it seems that this approach worked, since sequential layers of cortical neurons could be correctly identified, both in the anterior and posterior sagittal slide.; We can go ahead an visualize astrocytes and oligodendrocytes as well. sc.pl.spatial(; adata_anterior_subset_transfer, img_key=""hires"", color=[""Oligo"", ""Astro""], size=1.5; ); sc.pl.spatial(; adata_posterior_subset_transfer, img_key=""hires"", color=[""Oligo"", ""Astro""], size=1.5; ). In this tutorial, we showed how to work with multiple slices in Scanpy, and perform label transfers between an annotated scRNA-seq dataset and an unannotated Visium dataset. We showed that such approach, that leverages the data integration performances of Scanorama, is useful and provide a straightforward tool for exploratory analysis.; However, for the label transfer task, we advise analysts to explore more principled approaches, based on cell-type deconvolution, that are likely to provide more accurate and interpretable results. See recent approaches such as:. Stereoscope paper - code; AutogeneS paper - code; MuSiC paper - code; CIBERSORT-X paper - webtool; Deconv-seq code; cell2location paper - code. previous; Analysis and visualization of spatial transcriptomics data. next; Experimental. Contents; . Loading libraries; Reading the data; Data integration; Data integration and label transfer from scRNA-seq dataset. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html:27054,perform,perform,27054,en/stable/tutorials/spatial/integration-scanorama.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html,5,"['Load', 'perform']","['Loading', 'perform', 'performances']"
Performance,"talled via pip install fa2-modified.; Force-directed graph drawing describes a class of long-established; algorithms for visualizing graphs.; It has been suggested for visualizing single-cell data by Islam et al. [2011].; Many other layouts as implemented in igraph [Csárdi and Nepusz, 2006] are available.; Similar approaches have been used by Zunder et al. [2015] or Weinreb et al. [2017]. Parameters:. adata AnnDataAnnotated data matrix. layout Literal['fr', 'drl', 'kk', 'grid_fr', 'lgl', 'rt', 'rt_circular', 'fa'] (default: 'fa')‘fa’ (ForceAtlas2) or any valid igraph layout. Of particular interest; are ‘fr’ (Fruchterman Reingold), ‘grid_fr’ (Grid Fruchterman Reingold,; faster than ‘fr’), ‘kk’ (Kamadi Kawai’, slower than ‘fr’), ‘lgl’ (Large; Graph, very fast), ‘drl’ (Distributed Recursive Layout, pretty fast) and; ‘rt’ (Reingold Tilford tree layout). root int | None (default: None)Root for tree layouts. random_state Union[int, RandomState, None] (default: 0)For layouts with random initialization like ‘fr’, change this to use; different intial states for the optimization. If None, no seed is set. adjacency spmatrix | None (default: None)Sparse adjacency matrix of the graph, defaults to neighbors connectivities. key_added_ext str | None (default: None)By default, append layout. proceedContinue computation, starting off with ‘X_draw_graph_`layout`’. init_pos str | bool | None (default: None)'paga'/True, None/False, or any valid 2d-.obsm key.; Use precomputed coordinates for initialization.; If False/None (the default), initialize randomly. neighbors_key str | None (default: None)If not specified, draw_graph looks .obsp[‘connectivities’] for connectivities; (default storage place for pp.neighbors).; If specified, draw_graph looks; .obsp[.uns[neighbors_key][‘connectivities_key’]] for connectivities. obsp str | None (default: None)Use .obsp[obsp] as adjacency. You can’t specify both; obsp and neighbors_key at the same time. copy bool (default: False)Return a copy instead of",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.draw_graph.html:10903,optimiz,optimization,10903,en/stable/generated/scanpy.tl.draw_graph.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.draw_graph.html,1,['optimiz'],['optimization']
Performance,"tem page, release notes, tutorials overhaul pr960 pr966 A Wolf. Warning. changed default solver in pca() from auto to arpack; changed default use_raw in score_genes() from False to None. 1.4.4 2019-07-20#. New functionality#. scanpy.get adds helper functions for extracting data in convenient formats pr619 I Virshup. Bug fixes#. Stopped deprecations warnings from AnnData 0.6.22 I Virshup. Code design#. normalize_total() gains param exclude_highly_expressed, and fraction is renamed to max_fraction with better docs A Wolf. 1.4.3 2019-05-14#. Bug fixes#. neighbors() correctly infers n_neighbors again from params, which was temporarily broken in v1.4.2 I Virshup. Code design#. calculate_qc_metrics() is single threaded by default for datasets under 300,000 cells – allowing cached compilation pr615 I Virshup. 1.4.2 2019-05-06#. New functionality#. combat() supports additional covariates which may include adjustment variables or biological condition pr618 G Eraslan; highly_variable_genes() has a batch_key option which performs HVG selection in each batch separately to avoid selecting genes that vary strongly across batches pr622 G Eraslan. Bug fixes#. rank_genes_groups() t-test implementation doesn’t return NaN when variance is 0, also changed to scipy’s implementation pr621 I Virshup; umap() with init_pos='paga' detects correct dtype A Wolf; louvain() and leiden() auto-generate key_added=louvain_R upon passing restrict_to, which was temporarily changed in 1.4.1 A Wolf. Code design#. neighbors() and umap() got rid of UMAP legacy code and introduced UMAP as a dependency pr576 S Rybakov. 1.4.1 2019-04-26#. New functionality#. Scanpy has a command line interface again. Invoking it with scanpy somecommand [args] calls scanpy-somecommand [args], except for builtin commands (currently scanpy settings) pr604 P Angerer; ebi_expression_atlas() allows convenient download of EBI expression atlas I Virshup; marker_gene_overlap() computes overlaps of marker genes M Luecken; filter_rank_g",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:42416,perform,performs,42416,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,1,['perform'],['performs']
Performance,"ternal.pp.mnn_correct; scanpy.external.pp.scanorama_integrate; scanpy.external.pp.hashsolo; scanpy.external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .ipynb. .pdf. How to preprocess UMI count data with analytic Pearson residuals. Contents . Background; Preparations; Download data; Load data. Perform Quality control; Basic filtering; Compute quality control metrics; Plot quality control metrics. Use Pearson residuals for selection of highly variable genes; Compute 2000 variable genes with Pearson residuals; Plot gene selection; Apply gene selection; Print resulting adata objects. Transforming raw counts to Pearson residuals; Preparations; Compute Pearson residuals; Compute PCA and t-SNE; Compute Neighborhood graph and Leiden clustering; Plot Leiden clusters on tSNE and PBMC marker genes. Optional input arguments; Overdispersion parameter theta; Clipping threshold clip; chunksize and best practice to obtain Pearson residuals for large datasets. Wrapper functions for Pearson residuals preprocessing; References / See also. How to preprocess UMI count data with analytic Pearson residuals#; With version 1.9, scanpy introduces new preprocessing functions based on Pearson residuals into the experimental.pp module. These functions implement the core steps",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:9394,Load,Load,9394,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,1,['Load'],['Load']
Performance,"ternal.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .ipynb. .pdf. Integrating spatial data with scRNA-seq using scanorama. Contents . Loading libraries; Reading the data; Data integration; Data integration and label transfer from scRNA-seq dataset. Integrating spatial data with scRNA-seq using scanorama#; Author: Giovanni Palla. Note; For up-to-date analysis tutorials, kindly check out SquidPy tutorials. This tutorial shows how to work with multiple Visium datasets and perform integration of scRNA-seq dataset with Scanpy. It follows the previous tutorial on analysis and visualization of spatial transcriptomics data.; We will use Scanorama paper - code to perform integration and label transfer. It has a convenient interface with scanpy and anndata.; To install the required libraries, type the following:; pip install git+https://github.com/theislab/scanpy.git; pip install git+https://github.com/theislab/anndata.git; pip install scanorama. Loading libraries#. import scanpy as sc; import anndata as an; import pandas as pd; import numpy as np; import matplotlib.pyplot as plt; import seaborn as sns; import scanorama. from pathlib import Path. sc.logging.print_versions(); sc.set_figure_params(facecolor=""white"", figsize=(8, 8)); sc.settings.verbosity = 3. -----; anndata 0.11.0.dev78+g64ab900; scanpy 1.10.0rc2.dev6+g14555ba4; -----; PIL 10.2.0; annoy NA; anyio NA; appnope 0.1.3; arrow 1.3.0; asciitree NA; asttokens NA; attr 23.2.0; attrs 23.2.0; babel ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html:9675,perform,perform,9675,en/stable/tutorials/spatial/integration-scanorama.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html,2,['perform'],['perform']
Performance,"the UCSC Single Cell Browser requires exporting via cellbrowser() M Haeussler. Code design#. highly_variable_genes() supersedes filter_genes_dispersion(), it gives the same results but, by default, expects logarithmized data and doesn’t subset A Wolf. 1.3.5 2018-12-09#. uncountable figure improvements pr369 F Ramirez. 1.3.4 2018-11-24#. leiden() wraps the recent graph clustering package by Traag et al. [2019] K Polanski; bbknn() wraps the recent batch correction package [Polański et al., 2019] K Polanski; calculate_qc_metrics() caculates a number of quality control metrics, similar to calculateQCMetrics from Scater [McCarthy et al., 2017] I Virshup. 1.3.3 2018-11-05#. Major updates#. a fully distributed preprocessing backend T White and the Laserson Lab. Code design#. read_10x_h5() and read_10x_mtx() read Cell Ranger 3.0 outputs pr334 Q Gong. Note; Also see changes in anndata 0.6. changed default compression to None in write_h5ad() to speed up read and write, disk space use is usually less critical; performance gains in write_h5ad() due to better handling of strings and categories S Rybakov. 1.3.1 2018-09-03#. RNA velocity in single cells [La Manno et al., 2018]#. Scanpy and AnnData support loom’s layers so that computations for single-cell RNA velocity [La Manno et al., 2018] become feasible S Rybakov and V Bergen; scvelo harmonizes with Scanpy and is able to process loom files with splicing information produced by Velocyto [La Manno et al., 2018], it runs a lot faster than the count matrix analysis of Velocyto and provides several conceptual developments. Plotting (Generic)#. dotplot() for visualizing genes across conditions and clusters, see here pr199 F Ramirez; heatmap() for pretty heatmaps pr175 F Ramirez; violin() produces very compact overview figures with many panels pr175 F Ramirez. There now is a section on imputation in external:#. magic() for imputation using data diffusion [van Dijk et al., 2018] pr187 S Gigante; dca() for imputation and latent space co",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:45808,perform,performance,45808,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,1,['perform'],['performance']
Performance,"the seurat example.; upgrading scikit-learn from 0.18 to 0.19 changed the implementation of PCA,; some results might therefore look slightly different. Further updates#. UMAP [McInnes et al., 2018] can serve as a first visualization of the data just as tSNE,; in contrast to tSNE, UMAP directly embeds the single-cell graph and is faster;; UMAP is also used for measuring connectivities and computing neighbors,; see neighbors() A Wolf; graph abstraction: AGA is renamed to PAGA: paga(); now,; it only measures connectivities between partitions of the single-cell graph,; pseudotime and clustering need to be computed separately via; louvain() and dpt(), the; connectivity measure has been improved A Wolf; logistic regression for finding marker genes; rank_genes_groups() with parameter method='logreg' A Wolf; louvain() provides a better implementation for; reclustering via restrict_to A Wolf; scanpy no longer modifies rcParams upon import, call; settings.set_figure_params to set the ‘scanpy style’ A Wolf; default cache directory is ./cache/, set settings.cachedir to change; this; nested directories in this are avoided A Wolf; show edges in scatter plots based on graph visualization; draw_graph() and umap() by passing edges=True A Wolf; downsample_counts() for downsampling counts MD Luecken; default 'louvain_groups' are called 'louvain' A Wolf; 'X_diffmap' contains the zero component, plotting remains unchanged A Wolf. Version 0.4#. 0.4.4 2018-02-26#. embed cells using umap() [McInnes et al., 2018] pr92 G Eraslan; score sets of genes, e.g. for cell cycle, using score_genes() [Satija et al., 2015]:; notebook. 0.4.3 2018-02-09#. clustermap(): heatmap from hierarchical clustering,; based on seaborn.clustermap() [Waskom et al., 2016] A Wolf; only return matplotlib.axes.Axes in plotting functions of sc.pl; when show=False, otherwise None A Wolf. 0.4.2 2018-01-07#. amendments in PAGA and its plotting functions A Wolf. 0.4.0 2017-12-23#. export to SPRING [Weinreb et al., 2017] for i",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:50408,cache,cache,50408,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,1,['cache'],['cache']
Performance,"ti-dimensional; single-cell data, such as mass cytometry or RNA-Seq data, as input and orders cells; according to their developmental progression, and it pinpoints bifurcation points; by labeling each cell as pre-bifurcation or as one of two post-bifurcation cell; fates. Note; More information and bug reports here. Parameters:. adata AnnDataAnnotated data matrix. start_cell strDesired start cell from obs_names. branch bool (default: True)Use True for Wishbone and False for Wanderlust. k int (default: 15)Number of nearest neighbors for graph construction. components Iterable[int] (default: (1, 2, 3))Components to use for running Wishbone. num_waypoints int | Collection (default: 250)Number of waypoints to sample. Returns:; Updates adata with the following fields:. trajectory_wishbone(adata.obs, dtype float64)Computed trajectory positions. branch_wishbone(adata.obs, dtype int64)Assigned branches. Example; >>> import scanpy.external as sce; >>> import scanpy as sc. Loading Data and Pre-processing; >>> adata = sc.datasets.pbmc3k(); >>> sc.pp.normalize_per_cell(adata); >>> sc.pp.pca(adata); >>> sc.tl.tsne(adata=adata, n_pcs=5, perplexity=30); >>> sc.pp.neighbors(adata, n_pcs=15, n_neighbors=10); >>> sc.tl.diffmap(adata, n_comps=10). Running Wishbone Core Function; Usually, the start cell for a dataset should be chosen based on high expression of; the gene of interest:; >>> sce.tl.wishbone(; ... adata=adata, start_cell='ACAAGAGACTTATC-1',; ... components=[2, 3], num_waypoints=150,; ... ). Visualizing Wishbone results; >>> sc.pl.tsne(adata, color=['trajectory_wishbone', 'branch_wishbone']); >>> markers = ['C1QA', 'PSAP', 'CD79A', 'CD79B', 'CST3', 'LYZ', 'MALAT1']; >>> sce.pl.wishbone_marker_trajectory(adata, markers, show=True). For further demonstration of Wishbone methods and visualization please follow the; notebooks in the package Wishbone_for_single_cell_RNAseq.ipynb. previous; scanpy.external.tl.harmony_timeseries. next; scanpy.external.tl.palantir_results. Contents; ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.wishbone.html:10659,Load,Loading,10659,en/stable/external/generated/scanpy.external.tl.wishbone.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.wishbone.html,1,['Load'],['Loading']
Performance,"tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .md. .pdf. Documentation. Contents . Building the docs; Adding to the docs; docstrings format; Plots in docstrings; Params section; Returns section; Examples. Documentation#. Building the docs#; To build the docs, run hatch run docs:build.; Afterwards, you can run hatch run docs:open to open docs/_build/html/index.html.; Your browser and Sphinx cache docs which have been built previously.; Sometimes these caches are not invalidated when you’ve updated the docs.; If docs are not updating the way you expect, first try “force reloading” your browser page – e.g. reload the page without using the cache.; Next, if problems persist, clear the sphinx cache (hatch run docs:clean) and try building them again. Adding to the docs#; For any user-visible changes, please make sure a note has been added to the release notes using hatch run towncrier:create.; We recommend waiting on this until your PR is close to done since this can often causes merge conflicts.; Once you’ve added a new function to the documentation, you’ll need to make sure there is a link somewhere in the documentation site pointing to it.; This should be added to docs/api.md under a relevant heading.; For tutorials and more in depth examples, consider adding a notebook to the scanpy-tutorials repository.; The tutorials are tied to this repository via a submodule.; To update the submodule, run git submodule update --remote from the root of the repository.; Subsequently, commit and push the changes in a PR.; This should be done before each release to ensure the tutorials are up to date. docstrings format#; W",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/dev/documentation.html:9809,cache,cache,9809,en/stable/dev/documentation.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/dev/documentation.html,1,['cache'],['cache']
Performance,"tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy._settings.ScanpyConfig. Contents . ScanpyConfig. scanpy._settings.ScanpyConfig#. class scanpy._settings.ScanpyConfig(*, verbosity=Verbosity.warning, plot_suffix='', file_format_data='h5ad', file_format_figs='pdf', autosave=False, autoshow=True, writedir='./write/', cachedir='./cache/', datasetdir='./data/', figdir='./figures/', cache_compression='lzf', max_memory=15, n_jobs=1, logfile=None, categories_to_ignore=('N/A', 'dontknow', 'no_gate', '?'), _frameon=True, _vector_friendly=False, _low_resolution_warning=True, n_pcs=50)[source]#; Config manager for scanpy.; Attributes. autosave; Automatically save figures in figdir (default False). autoshow; Automatically show figures if autosave == False (default True). cache_compression; Compression for sc.read(..., cache=True) (default 'lzf'). cachedir; Directory for cache files (default './cache/'). categories_to_ignore; Categories that are omitted in plotting etc. datasetdir; Directory for example datasets (default './data/'). figdir; Directory for saving figures (default './figures/'). file_format_data; File format for saving AnnData objects. file_format_figs; File format for saving figures. logfile; The open file to write logs to. logpath; The file path logfile was set to. max_memory; Maximum memory us",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy._settings.ScanpyConfig.html:9511,cache,cachedir,9511,en/stable/generated/scanpy._settings.ScanpyConfig.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy._settings.ScanpyConfig.html,1,['cache'],['cachedir']
Performance,"ults when _choose_representation is called i.e., neighbors() without pca() pr3079 I gold; Fix deprecated use of .A with sparse matrices pr3084 P Angerer; Fix zappy support pr3089 P Angerer; Fix dotplot group order with pandas 1.x pr3101 P Angerer. Performance#. sparse_mean_variance_axis now uses all cores for the calculations pr3015 S Dicks; pp.highly_variable_genes with flavor=seurat_v3 now uses a numba kernel pr3017 S Dicks; Speed up scrublet() pr3044 S Dicks and pr3056 P Angerer; Speed up clipping of array in scale() pr3100 P Ashish & S Dicks. 1.10.1 2024-04-09#. Documentation#. Added how-to example on plotting with Marsilea pr2974 Y Zheng. Bug fixes#. Fix aggregate when aggregating by more than two groups pr2965 I Virshup. Performance#. scale() now uses numba kernels for sparse.csr_matrix and sparse.csc_matrix when zero_center==False and mask_obs is provided. This greatly speed up execution pr2942 S Dicks. 1.10.0 2024-03-26#; scanpy 1.10 brings a large amount of new features, performance improvements, and improved documentation.; Some highlights:. Improved support for out-of-core workflows via dask. See new tutorial: Using dask with Scanpy demonstrating counts-to-clusters for 1.4 million cells in <10 min.; A new basic clustering tutorial demonstrating an updated workflow.; Opt-in increased performance for neighbor search and clustering (how to guide).; Ability to mask observations or variables from a number of methods (see Customizing Scanpy plots for an example with plotting embeddings); A new function aggregate() for computing aggregations of your data, very useful for pseudo bulking!. Features#. scrublet() and scrublet_simulate_doublets() were moved from scanpy.external.pp to scanpy.pp. The scrublet implementation is now maintained as part of scanpy pr2703 P Angerer; scanpy.pp.pca(), scanpy.pp.scale(), scanpy.pl.embedding(), and scanpy.experimental.pp.normalize_pearson_residuals_pca() now support a mask parameter pr2272 C Bright, T Marcella, & P Angerer; Enhan",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:14122,perform,performance,14122,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,1,['perform'],['performance']
Performance,"usters.; Set to None if overriding partition_type; to one that doesn’t accept a resolution_parameter. random_state Union[int, RandomState, None] (default: 0)Change the initialization of the optimization. restrict_to tuple[str, Sequence[str]] | None (default: None)Restrict the clustering to the categories within the key for sample; annotation, tuple needs to contain (obs_key, list_of_categories). key_added str (default: 'leiden')adata.obs key under which to add the cluster labels. adjacency spmatrix | None (default: None)Sparse adjacency matrix of the graph, defaults to neighbors connectivities. directed bool | None (default: None)Whether to treat the graph as directed or undirected. use_weights bool (default: True)If True, edge weights from the graph are used in the computation; (placing more emphasis on stronger edges). n_iterations int (default: -1)How many iterations of the Leiden clustering algorithm to perform.; Positive values above 2 define the total number of iterations to perform,; -1 has the algorithm run until it reaches its optimal clustering.; 2 is faster and the default for underlying packages. partition_type type[MutableVertexPartition] | None (default: None)Type of partition to use.; Defaults to RBConfigurationVertexPartition.; For the available options, consult the documentation for; find_partition(). neighbors_key str | None (default: None)Use neighbors connectivities as adjacency.; If not specified, leiden looks .obsp[‘connectivities’] for connectivities; (default storage place for pp.neighbors).; If specified, leiden looks; .obsp[.uns[neighbors_key][‘connectivities_key’]] for connectivities. obsp str | None (default: None)Use .obsp[obsp] as adjacency. You can’t specify both; obsp and neighbors_key at the same time. copy bool (default: False)Whether to copy adata or modify it inplace. flavor Literal['leidenalg', 'igraph'] (default: 'leidenalg')Which package’s implementation to use. **clustering_argsAny further arguments to pass to find_partition()",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.leiden.html:11043,perform,perform,11043,en/stable/generated/scanpy.tl.leiden.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.leiden.html,1,['perform'],['perform']
Performance,"wise, return results. See below for; details of what is returned. Return type:; tuple[AnnData, DataFrame] | None. Returns:; If inplace=False, separately returns the gene selection results (as; DataFrame) and Pearson residual-based PCA results (as; AnnData). If inplace=True, updates adata with the; following fields for gene selection results:. .var['highly_variable']boolboolean indicator of highly-variable genes. .var['means']floatmeans per gene. .var['variances']floatvariances per gene. .var['residual_variances']floatPearson residual variance per gene. Averaged in the case of multiple; batches. .var['highly_variable_rank']floatRank of the gene according to residual variance, median rank in the; case of multiple batches. .var['highly_variable_nbatches']intIf batch_key is given, this denotes in how many batches genes are; detected as HVG. .var['highly_variable_intersection']boolIf batch_key is given, this denotes the genes that are highly variable; in all batches. The following fields contain Pearson residual-based PCA results and; normalization settings:. .uns['pearson_residuals_normalization']['pearson_residuals_df']The subset of highly variable genes, normalized by Pearson residuals. .uns['pearson_residuals_normalization']['theta']The used value of the overdisperion parameter theta. .uns['pearson_residuals_normalization']['clip']The used value of the clipping parameter. .obsm['X_pca']PCA representation of data after gene selection and Pearson residual; normalization. .varm['PCs']The principal components containing the loadings. When inplace=True this; will contain empty rows for the genes not selected during HVG selection. .uns['pca']['variance_ratio']Ratio of explained variance. .uns['pca']['variance']Explained variance, equivalent to the eigenvalues of the covariance matrix. previous; scanpy.experimental.pp.highly_variable_genes. next; Classes. Contents; . recipe_pearson_residuals(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.recipe_pearson_residuals.html:13516,load,loadings,13516,en/stable/generated/scanpy.experimental.pp.recipe_pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.recipe_pearson_residuals.html,1,['load'],['loadings']
Performance,y.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. Index. A; | B; | C; | D; | E; | F; | G; | H; | I; | K; | L; | M; | N; | O; | P; | R; | S; | T; | U; | V; | W. A. add_dendrogram() (scanpy.pl.DotPlot method). (scanpy.pl.MatrixPlot method). (scanpy.pl.StackedViolin method). add_totals() (scanpy.pl.DotPlot method). (scanpy.pl.MatrixPlot method). (scanpy.pl.StackedViolin method). aggregate() (in module scanpy.get). autosave (scanpy._settings.ScanpyConfig property). autoshow (scanpy._settings.ScanpyConfig property). B. bbknn() (in module scanpy.external.pp). biomart_annotations() (in module scanpy.queries). blobs() (in module scanpy.datasets). C. cache_compression (scanpy._settings.ScanpyConfig property). cachedir (scanpy._settings.ScanpyConfig property). calculate_qc_metrics() (in module scanpy.pp). categories_to_ignore (scanpy._settings.ScanpyConfig property). cellbrowser() (in module scanpy.external.exporting). clustermap() (in module scanpy.pl). combat() (in module scanpy.pp). compute_eigen() (scanpy.Neighbors method). compute_neighbors() (scanpy.Neighbors method). compute_transitions() (scanpy.Neighbors method). confusion_matrix() (in module scanpy.metrics). connectivities (scanpy.Neighbors property). cyclone() (in module scanpy.external.tl). D. datasetdir (scanpy._settings.ScanpyConfig property). dca() (in module scanpy.external.pp). DEFAULT_CATEGORY_HEIGHT (scanpy.pl.DotPlot attribute). (scanpy.pl.MatrixPlot attribute). (scanpy.pl.StackedViolin attribute). DEFAULT_CATEGORY_WIDTH (scanpy.pl.DotPlot attribute). (scanpy.pl.MatrixPlot attribute). (scanpy.pl.StackedViolin attribute). DEFAULT_COLOR_LEGEND_TITLE (scanpy.pl.DotPlot attribute). (scanpy.pl.MatrixPlot attribute). (scanpy.pl.Stacked,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/genindex.html:9862,cache,cachedir,9862,en/stable/genindex.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/genindex.html,1,['cache'],['cachedir']
Performance,"y.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.pp.pca. Contents . pca(). scanpy.pp.pca#. scanpy.pp.pca(data, n_comps=None, *, layer=None, zero_center=True, svd_solver=None, random_state=0, return_info=False, mask_var=_empty, use_highly_variable=None, dtype='float32', chunked=False, chunk_size=None, copy=False)[source]#; Principal component analysis [Pedregosa et al., 2011].; Computes PCA coordinates, loadings and variance decomposition.; Uses the implementation of scikit-learn [Pedregosa et al., 2011]. Changed in version 1.5.0: In previous versions, computing a PCA on a sparse matrix would make; a dense copy of the array for mean centering.; As of scanpy 1.5.0, mean centering is implicit.; While results are extremely similar, they are not exactly the same.; If you would like to reproduce the old results, pass a dense array. Parameters:. data AnnData | ndarray | spmatrixThe (annotated) data matrix of shape n_obs × n_vars.; Rows correspond to cells and columns to genes. n_comps int | None (default: None)Number of principal components to compute. Defaults to 50, or 1 - minimum; dimension size of selected representation. layer str | None (default: None)If provided, which element of layers to use for PCA. zero_center bool | None (default: True)If True, compute standard PCA from covariance matrix.; If False, omit zero-centering variables; (uses scikit-learn TruncatedSVD or; dask-ml Truncated",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.pca.html:9586,load,loadings,9586,en/stable/generated/scanpy.pp.pca.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.pca.html,1,['load'],['loadings']
Performance,"y.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .md. .pdf. Documentation. Contents . Building the docs; Adding to the docs; docstrings format; Plots in docstrings; Params section; Returns section; Examples. Documentation#. Building the docs#; To build the docs, run hatch run docs:build.; Afterwards, you can run hatch run docs:open to open docs/_build/html/index.html.; Your browser and Sphinx cache docs which have been built previously.; Sometimes these caches are not invalidated when you’ve updated the docs.; If docs are not updating the way you expect, first try “force reloading” your browser page – e.g. reload the page without using the cache.; Next, if problems persist, clear the sphinx cache (hatch run docs:clean) and try building them again. Adding to the docs#; For any user-visible changes, please make sure a note has been added to the release notes using hatch run towncrier:create.; We recommend waiting on this until your PR is close to done since this can often causes merge conflicts.; Once you’ve added a new function to the documentation, you’ll need to make sure there is a link somewhere in the documentation site pointing to it.; This should be added to docs/api.md under a relevant heading.; For tutorials and more in depth examples, consider adding a notebook to the scanpy-tutorials repository.; The tutorials are tied to this repository via a submodule.; To update the sub",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/dev/documentation.html:9557,cache,cache,9557,en/stable/dev/documentation.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/dev/documentation.html,1,['cache'],['cache']
Performance,"yter notebooks and lab, you can see the documentation for a python function by hitting SHIFT + TAB. Hit it twice to expand the view. import pandas as pd; import scanpy as sc. sc.settings.verbosity = 3 # verbosity: errors (0), warnings (1), info (2), hints (3); sc.logging.print_header(); sc.settings.set_figure_params(dpi=80, facecolor=""white""). scanpy==1.10.0rc2.dev6+g14555ba4.d20240226 anndata==0.11.0.dev78+g64ab900 umap==0.5.5 numpy==1.26.3 scipy==1.11.4 pandas==2.2.0 scikit-learn==1.3.2 statsmodels==0.14.1 igraph==0.10.8 pynndescent==0.5.11. results_file = ""write/pbmc3k.h5ad"" # the file that will store the analysis results. Read in the count matrix into an AnnData object, which holds many slots for annotations and different representations of the data. It also comes with its own HDF5-based file format: .h5ad. adata = sc.read_10x_mtx(; ""data/filtered_gene_bc_matrices/hg19/"", # the directory with the `.mtx` file; var_names=""gene_symbols"", # use gene symbols for the variable names (variables-axis index); cache=True, # write a cache file for faster subsequent reading; ). ... reading from cache file cache/data-filtered_gene_bc_matrices-hg19-matrix.h5ad. Note; See anndata-tutorials/getting-started for a more comprehensive introduction to AnnData. adata.var_names_make_unique() # this is unnecessary if using `var_names='gene_ids'` in `sc.read_10x_mtx`. adata. AnnData object with n_obs × n_vars = 2700 × 32738; var: 'gene_ids'. Preprocessing#; Show those genes that yield the highest fraction of counts in each single cell, across all cells. sc.pl.highest_expr_genes(adata, n_top=20). normalizing counts per cell; finished (0:00:00). Basic filtering:. sc.pp.filter_cells(adata, min_genes=200); sc.pp.filter_genes(adata, min_cells=3). filtered out 19024 genes that are detected in less than 3 cells. Let’s assemble some information about mitochondrial genes, which are important for quality control.; Citing from “Simple Single Cell” workflows (Lun, McCarthy & Marioni, 2017):. High pro",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering-2017.html:11600,cache,cache,11600,en/stable/tutorials/basics/clustering-2017.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering-2017.html,4,['cache'],['cache']
Safety," Based on the QC metric plots, one could now remove cells that have too many mitochondrial genes expressed or too many total counts by setting manual or automatic thresholds. However, sometimes what appears to be poor QC metrics can be driven by real biology so we suggest starting with a very permissive filtering strategy and revisiting it at a later point. We therefore now only filter cells with less than 100 genes expressed and genes that are detected in less than 3 cells.; Additionally, it is important to note that for datasets with multiple batches, quality control should be performed for each sample individually as quality control thresholds can very substantially between batches. sc.pp.filter_cells(adata, min_genes=100); sc.pp.filter_genes(adata, min_cells=3). Doublet detection#; As a next step, we run a doublet detection algorithm. Identifying doublets is crucial as they can lead to misclassifications or distortions in downstream analysis steps. Scanpy contains the doublet detection method Scrublet [Wolock et al., 2019]. Scrublet predicts cell doublets using a nearest-neighbor classifier of observed transcriptomes and simulated doublets. scanpy.pp.scrublet() adds doublet_score and predicted_doublet to .obs. One can now either filter directly on predicted_doublet or use the doublet_score later during clustering to filter clusters with high doublet scores. sc.pp.scrublet(adata, batch_key=""sample""). We can remove doublets by either filtering out the cells called as doublets, or waiting until we’ve done a clustering pass and filtering out any clusters with high doublet scores. See also; Alternative methods for doublet detection within the scverse ecosystem are DoubletDetection and SOLO. You can read more about these in the Doublet Detection chapter of Single Cell Best Practices. Normalization#; The next preprocessing step is normalization. A common approach is count depth scaling with subsequent log plus one (log1p) transformation. Count depth scaling normalizes t",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering.html:13430,detect,detection,13430,en/stable/tutorials/basics/clustering.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering.html,2,['detect'],['detection']
Safety," Identify highly-variable genes. sc.pp.highly_variable_genes(adata, min_mean=0.0125, max_mean=3, min_disp=0.5). extracting highly variable genes; finished (0:00:00); --> added; 'highly_variable', boolean vector (adata.var); 'means', float vector (adata.var); 'dispersions', float vector (adata.var); 'dispersions_norm', float vector (adata.var). sc.pl.highly_variable_genes(adata). Set the .raw attribute of the AnnData object to the normalized and logarithmized raw gene expression for later use in differential testing and visualizations of gene expression. This simply freezes the state of the AnnData object. Note; You can get back an AnnData of the object in .raw by calling .raw.to_adata(). adata.raw = adata. Note; If you don’t proceed below with correcting the data with sc.pp.regress_out and scaling it via sc.pp.scale, you can also get away without using .raw at all.; The result of the previous highly-variable-genes detection is stored as an annotation in .var.highly_variable and auto-detected by PCA and hence, sc.pp.neighbors and subsequent manifold/graph tools. In that case, the step actually do the filtering below is unnecessary, too. Actually do the filtering. adata = adata[:, adata.var.highly_variable]. Regress out effects of total counts per cell and the percentage of mitochondrial genes expressed. Scale the data to unit variance. sc.pp.regress_out(adata, [""total_counts"", ""pct_counts_mt""]). regressing out ['total_counts', 'pct_counts_mt']; sparse input is densified and may lead to high memory use; finished (0:00:02). Scale each gene to unit variance. Clip values exceeding standard deviation 10. sc.pp.scale(adata, max_value=10). Principal component analysis#; Reduce the dimensionality of the data by running principal component analysis (PCA), which reveals the main axes of variation and denoises the data. sc.tl.pca(adata, svd_solver=""arpack""). computing PCA; with n_comps=50; finished (0:01:01). We can make a scatter plot in the PCA coordinates, but we will not use",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering-2017.html:15126,detect,detected,15126,en/stable/tutorials/basics/clustering-2017.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering-2017.html,2,['detect'],['detected']
Safety," are detected in less than 3 cells; PBMC 10k (v3) : data shape: (11769, 33538); filtered out 232 cells that have less than 200 genes expressed; filtered out 13246 genes that are detected in less than 3 cells. Compute quality control metrics#; We compute number of deteced genes per cell, total counts per cell and percentage of mitochondrial genes per cell. for adata in [adata_pbmc3k, adata_pbmc10k]:; adata.var[""mt""] = adata.var_names.str.startswith(""MT-""); sc.pp.calculate_qc_metrics(; adata, qc_vars=[""mt""], percent_top=None, log1p=False, inplace=True; ). Plot quality control metrics#; We plot all metrics and observe that both datasets have some outlier cells. for adata in [adata_pbmc3k, adata_pbmc10k]:; print(adata.uns[""name""], "":""); sc.pl.violin(; adata,; [""n_genes_by_counts"", ""total_counts"", ""pct_counts_mt""],; jitter=0.4,; multi_panel=True,; ). PBMC 3k (v1) :; PBMC 10k (v3) :. Based on these metrics, we define outlier cells and remove them. Afterwards, we make sure that all genes are at least detected once in the remaining cells. # define outliers and do the filtering for the 3k dataset; adata_pbmc3k.obs[""outlier_mt""] = adata_pbmc3k.obs.pct_counts_mt > 5; adata_pbmc3k.obs[""outlier_total""] = adata_pbmc3k.obs.total_counts > 5000; adata_pbmc3k.obs[""outlier_ngenes""] = adata_pbmc3k.obs.n_genes_by_counts > 2500. print(; ""%u cells with high %% of mitochondrial genes""; % (sum(adata_pbmc3k.obs[""outlier_mt""])); ); print(""%u cells with large total counts"" % (sum(adata_pbmc3k.obs[""outlier_total""]))); print(""%u cells with large number of genes"" % (sum(adata_pbmc3k.obs[""outlier_ngenes""]))). adata_pbmc3k = adata_pbmc3k[~adata_pbmc3k.obs[""outlier_mt""], :]; adata_pbmc3k = adata_pbmc3k[~adata_pbmc3k.obs[""outlier_total""], :]; adata_pbmc3k = adata_pbmc3k[~adata_pbmc3k.obs[""outlier_ngenes""], :]; sc.pp.filter_genes(adata_pbmc3k, min_cells=1). 57 cells with high % of mitochondrial genes; 69 cells with large total counts; 5 cells with large number of genes; filtered out 2 genes that are de",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:15597,detect,detected,15597,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,2,['detect'],['detected']
Safety," can; be run in a hierarchical mode by setting the parameter; n_branchings>1. We recommend, however, to only use; dpt() for computing pseudotime (n_branchings=0) and; to detect branchings via paga(). For pseudotime, you need; to annotate your data with a root cell. For instance:; adata.uns['iroot'] = np.flatnonzero(adata.obs['cell_types'] == 'Stem')[0]. This requires to run neighbors(), first. In order to; reproduce the original implementation of DPT, use method=='gauss' in; this. Using the default method=='umap' only leads to minor quantitative; differences, though. Added in version 1.1. dpt() also requires to run; diffmap() first. As previously,; dpt() came with a default parameter of n_dcs=10 but; diffmap() has a default parameter of n_comps=15,; you need to pass n_comps=10 in diffmap() in order; to exactly reproduce previous dpt() results. Parameters:. adata AnnDataAnnotated data matrix. n_dcs int (default: 10)The number of diffusion components to use. n_branchings int (default: 0)Number of branchings to detect. min_group_size float (default: 0.01)During recursive splitting of branches (‘dpt groups’) for n_branchings; > 1, do not consider groups that contain less than min_group_size data; points. If a float, min_group_size refers to a fraction of the total; number of data points. allow_kendall_tau_shift bool (default: True)If a very small branch is detected upon splitting, shift away from; maximum correlation in Kendall tau criterion of Haghverdi et al. [2016] to; stabilize the splitting. neighbors_key str | None (default: None)If not specified, dpt looks .uns[‘neighbors’] for neighbors settings; and .obsp[‘connectivities’], .obsp[‘distances’] for connectivities and; distances respectively (default storage places for pp.neighbors).; If specified, dpt looks .uns[neighbors_key] for neighbors settings and; .obsp[.uns[neighbors_key][‘connectivities_key’]],; .obsp[.uns[neighbors_key][‘distances_key’]] for connectivities and distances; respectively. copy bool (default:",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.dpt.html:10860,detect,detect,10860,en/stable/generated/scanpy.tl.dpt.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.dpt.html,1,['detect'],['detect']
Safety," pr1741 J Manning. Ecosystem#. Added Cubé to ecosystem page pr1878 C Lambden; Added triku a feature selection method to the ecosystem page pr1722 AM Ascensión; Added dorothea and progeny to the ecosystem page pr1767 P Badia-i-Mompel. Documentation#. Added Community page to docs pr1856 I Virshup; Added rendered examples to many plotting functions issue1664 A Schaar L Zappia bio-la L Hetzel L Dony M Buttner K Hrovatin F Ramirez I Virshup LouisK92 mayarali; Integrated DocSearch, a find-as-you-type documentation index search. pr1754 P Angerer; Reorganized reference docs pr1753 I Virshup; Clarified docs issues for neighbors(),; diffmap(), calculate_qc_metrics() pr1680 G Palla; Fixed typos in grouped plot doc-strings pr1877 C Rands; Extended examples for differential expression plotting. pr1529 F Ramirez. See rank_genes_groups_dotplot() or rank_genes_groups_matrixplot() for examples. Bug fixes#. Fix scanpy.pl.paga_path() TypeError with recent versions of anndata pr1047 P Angerer; Fix detection of whether IPython is running pr1844 I Virshup; Fixed reproducibility of scanpy.tl.diffmap() (added random_state) pr1858 I Kucinski; Fixed errors and warnings from embedding plots with small numbers of categories after sns.set_palette was called pr1886 I Virshup; Fixed handling of gene_symbols argument in a number of sc.pl.rank_genes_groups* functions pr1529 F Ramirez I Virshup; Fixed handling of use_raw for sc.tl.rank_genes_groups when no .raw is present pr1895 I Virshup; scanpy.pl.rank_genes_groups_violin() now works for raw=False pr1669 M van den Beek; scanpy.pl.dotplot() now uses smallest_dot argument correctly pr1771 S Flemming. Development Process#. Switched to flit for building and deploying the package, a simple tool with an easy to understand command line interface and metadata pr1527 P Angerer; Use pre-commit for style checks pr1684 pr1848 L Heumos I Virshup. Deprecations#. Dropped support for Python 3.6. More details here. pr1897 I Virshup; Deprecated layers and layers_no",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:27958,detect,detection,27958,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,1,['detect'],['detection']
Safety,".exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.external.tl.phenograph. Contents . phenograph(). scanpy.external.tl.phenograph#. scanpy.external.tl.phenograph(data, clustering_algo='louvain', *, k=30, directed=False, prune=False, min_cluster_size=10, jaccard=True, primary_metric='euclidean', n_jobs=-1, q_tol=0.001, louvain_time_limit=2000, nn_method='kdtree', partition_type=None, resolution_parameter=1, n_iterations=-1, use_weights=True, seed=None, copy=False, **kargs)[source]#; PhenoGraph clustering [Levine et al., 2015].; PhenoGraph is a clustering method designed for high-dimensional single-cell; data. It works by creating a graph (“network”) representing phenotypic similarities; between cells and then identifying communities in this graph. It supports both; Louvain and Leiden algorithms for community detection. Note; More information and bug reports here. Parameters:. data AnnData | ndarray | spmatrixAnnData, or Array of data to cluster, or sparse matrix of k-nearest neighbor; graph. If ndarray, n-by-d array of n cells in d dimensions. if sparse matrix,; n-by-n adjacency matrix. clustering_algo Optional[Literal['louvain', 'leiden']] (default: 'louvain')Choose between 'Louvain' or 'Leiden' algorithm for clustering. k int (default: 30)Number of nearest neighbors to use in first step of graph construction. directed bool (default: False)Whether to use a symmetric (default) or asymmetric ('directed') graph.; The graph construction process produces a directed graph, which is symmetrized; by one of two methods (see prune below). prune bool (default: False)prune=False, symmetrize by taking the average between the graph and its; transpose. prune=True, symmetrize by taking the product between the graph; and its transpose. min_cluster_size int (default: 10)Cells that",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.phenograph.html:10013,detect,detection,10013,en/stable/external/generated/scanpy.external.tl.phenograph.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.phenograph.html,2,['detect'],['detection']
Safety,".pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.tl.tsne. Contents . tsne(). scanpy.tl.tsne#. scanpy.tl.tsne(adata, n_pcs=None, *, use_rep=None, perplexity=30, metric='euclidean', early_exaggeration=12, learning_rate=1000, random_state=0, use_fast_tsne=False, n_jobs=None, copy=False)[source]#; t-SNE [Amir et al., 2013, Pedregosa et al., 2011, van der Maaten and Hinton, 2008].; t-distributed stochastic neighborhood embedding (tSNE, van der Maaten and Hinton [2008]) has been; proposed for visualizating single-cell data by Amir et al. [2013]. Here, by default,; we use the implementation of scikit-learn [Pedregosa et al., 2011]. You can achieve; a huge speedup and better convergence if you install Multicore-tSNE; by Ulyanov [2016], which will be automatically detected by Scanpy. Parameters:. adata AnnDataAnnotated data matrix. n_pcs int | None (default: None)Use this many PCs. If n_pcs==0 use .X if use_rep is None. use_rep str | None (default: None)Use the indicated representation. 'X' or any key for .obsm is valid.; If None, the representation is chosen automatically:; For .n_vars < N_PCS (default: 50), .X is used, otherwise ‘X_pca’ is used.; If ‘X_pca’ is not present, it’s computed with default parameters or n_pcs if present. perplexity float | int (default: 30)The perplexity is related to the number of nearest neighbors that; is used in other manifold learning algorithms. Larger datasets; usually require a larger perplexity. Consider selecting a value; between 5 and 50. The choice is not extremely critical since t-SNE; is quite insensitive to this parameter. metric str (default: 'euclidean')Distance metric calculate neighbors on. early_exaggeration float | int (default: 12)Controls",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.tsne.html:9947,detect,detected,9947,en/stable/generated/scanpy.tl.tsne.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.tsne.html,1,['detect'],['detected']
Safety,"88 ms. Highly variable genes needs to add entries into obs, which currently does not support lazy column. So computation will occur immediately on call. %%time; sc.pp.highly_variable_genes(adata). CPU times: user 3.46 s, sys: 509 ms, total: 3.97 s; Wall time: 50 s. PCA currently does not support sparse data. So we will need to densify the expression matrix before passing it in. However, as we are working with only a subset of the data at a time, we are able to perform this operation with a lower memory overhead.; As this is a still a significant increase in memory usage per chunk, we will need to reduce the number of observations present in each chunk. adata.layers[""dense""] = adata.X.rechunk((DENSE_CHUNK_SIZE, -1)).map_blocks(; lambda x: x.toarray(), dtype=adata.X.dtype, meta=np.array([]); ). %%time; sc.pp.pca(adata, layer=""dense""). CPU times: user 9.31 s, sys: 1.19 s, total: 10.5 s; Wall time: 1min 27s. While most of the PCA computation runs immediately, the last step (computing the observation loadings) is lazy, so must be triggered manually to avoid recomputation. %%time; adata.obsm[""X_pca""] = adata.obsm[""X_pca""].compute(). CPU times: user 6.72 s, sys: 1.36 s, total: 8.08 s; Wall time: 1min 15s. adata. AnnData object with n_obs × n_vars = 1462702 × 27714; obs: 'celltype', 'majorType', 'City', 'sampleID', 'donor_id', 'Sample type', 'CoVID-19 severity', 'Sample time', 'Sampling day (Days after symptom onset)', 'BCR single cell sequencing', 'TCR single cell sequencing', 'Outcome', 'Comorbidities', 'COVID-19-related medication and anti-microbials', 'Leukocytes [G over L]', 'Neutrophils [G over L]', 'Lymphocytes [G over L]', 'Unpublished', 'disease_ontology_term_id', 'cell_type_ontology_term_id', 'tissue_ontology_term_id', 'development_stage_ontology_term_id', 'self_reported_ethnicity_ontology_term_id', 'assay_ontology_term_id', 'sex_ontology_term_id', 'is_primary_data', 'organism_ontology_term_id', 'suspension_type', 'tissue_type', 'cell_type', 'assay', 'disease', 'o",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/dask.html:15892,avoid,avoid,15892,en/stable/tutorials/experimental/dask.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/dask.html,2,['avoid'],['avoid']
Safety,"; dimensions=[(0, 1), (2, 3), (0, 1), (2, 3)],; ncols=2,; size=2,; ). Nearest neighbor graph constuction and visualization#; Let us compute the neighborhood graph of cells using the PCA representation of the data matrix. sc.pp.neighbors(adata). This graph can then be embedded in two dimensions for visualiztion with UMAP (McInnes et al., 2018):. sc.tl.umap(adata). We can now visualize the UMAP according to the sample. sc.pl.umap(; adata,; color=""sample"",; # Setting a smaller point size to get prevent overlap; size=2,; ). Even though the data considered in this tutorial includes two different samples, we only observe a minor batch effect and we can continue with clustering and annotation of our data.; If you inspect batch effects in your UMAP it can be beneficial to integrate across samples and perform batch correction/integration. We recommend checking out scanorama and scvi-tools for batch integration. Clustering#; As with Seurat and many other frameworks, we recommend the Leiden graph-clustering method (community detection based on optimizing modularity) [Traag et al., 2019]. Note that Leiden clustering directly clusters the neighborhood graph of cells, which we already computed in the previous section. # Using the igraph implementation and a fixed number of iterations can be significantly faster, especially for larger datasets; sc.tl.leiden(adata, flavor=""igraph"", n_iterations=2). sc.pl.umap(adata, color=[""leiden""]). Re-assess quality control and cell filtering#; As indicated before, we will now re-assess our filtering strategy by visualizing different QC metrics using UMAP. sc.pl.umap(; adata,; color=[""leiden"", ""predicted_doublet"", ""doublet_score""],; # increase horizontal space between panels; wspace=0.5,; size=3,; ). sc.pl.umap(; adata,; color=[""leiden"", ""log1p_total_counts"", ""pct_counts_mt"", ""log1p_n_genes_by_counts""],; wspace=0.5,; ncols=2,; ). Manual cell-type annotation#. Note; This section of the tutorial is expanded upon using prior knowledge resources lik",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering.html:17466,detect,detection,17466,en/stable/tutorials/basics/clustering.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering.html,2,['detect'],['detection']
Safety,"Bug fixes#. Stopped deprecations warnings from AnnData 0.6.22 I Virshup. Code design#. normalize_total() gains param exclude_highly_expressed, and fraction is renamed to max_fraction with better docs A Wolf. 1.4.3 2019-05-14#. Bug fixes#. neighbors() correctly infers n_neighbors again from params, which was temporarily broken in v1.4.2 I Virshup. Code design#. calculate_qc_metrics() is single threaded by default for datasets under 300,000 cells – allowing cached compilation pr615 I Virshup. 1.4.2 2019-05-06#. New functionality#. combat() supports additional covariates which may include adjustment variables or biological condition pr618 G Eraslan; highly_variable_genes() has a batch_key option which performs HVG selection in each batch separately to avoid selecting genes that vary strongly across batches pr622 G Eraslan. Bug fixes#. rank_genes_groups() t-test implementation doesn’t return NaN when variance is 0, also changed to scipy’s implementation pr621 I Virshup; umap() with init_pos='paga' detects correct dtype A Wolf; louvain() and leiden() auto-generate key_added=louvain_R upon passing restrict_to, which was temporarily changed in 1.4.1 A Wolf. Code design#. neighbors() and umap() got rid of UMAP legacy code and introduced UMAP as a dependency pr576 S Rybakov. 1.4.1 2019-04-26#. New functionality#. Scanpy has a command line interface again. Invoking it with scanpy somecommand [args] calls scanpy-somecommand [args], except for builtin commands (currently scanpy settings) pr604 P Angerer; ebi_expression_atlas() allows convenient download of EBI expression atlas I Virshup; marker_gene_overlap() computes overlaps of marker genes M Luecken; filter_rank_genes_groups() filters out genes based on fold change and fraction of cells expressing genes F Ramirez; normalize_total() replaces normalize_per_cell(), is more efficient and provides a parameter to only normalize using a fraction of expressed genes S Rybakov; downsample_counts() has been sped up, changed default val",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:42717,detect,detects,42717,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,1,['detect'],['detects']
Safety,"_correct; scanpy.external.pp.scanorama_integrate; scanpy.external.pp.hashsolo; scanpy.external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .ipynb. .pdf. Using other kNN libraries in Scanpy. Using other kNN libraries in Scanpy#; Since Scanpy was released, there has been quite some development in the space of approximate nearest neighbor detection.; In our example, we’re going to use Annoy:. %pip install -qU ""pip""; %pip install -q ""scanpy"" ""sklearn-ann[annoy]"". Note: you may need to restart the kernel to use updated packages.; Note: you may need to restart the kernel to use updated packages. import scanpy as sc; from sklearn_ann.kneighbors.annoy import AnnoyTransformer # noqa: F401. sc.logging.print_header(). scanpy==1.10.0rc2.dev0+g48b495d9.d20240222 anndata==0.10.5.post1 umap==0.5.5 numpy==1.26.4 scipy==1.12.0 pandas==2.2.0 scikit-learn==1.4.1.post1 statsmodels==0.14.1 igraph==0.11.4 pynndescent==0.5.11. Our nearest neighbors implementation uses the PCA embedding by default, so let’s pre-compute that:. adata_default = sc.datasets.paul15(); sc.pp.pca(adata_default); adata_annoy, adata_pynnd = adata_default.copy(), adata_default.copy(). WARNING: In Scanpy 0.*, this returned logarithmized data. Now it returns non-logarithmized data. The best way to use",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/how-to/knn-transformers.html:9431,detect,detection,9431,en/stable/how-to/knn-transformers.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/how-to/knn-transformers.html,1,['detect'],['detection']
Safety,"able_rank', 'highly_variable'; uns: 'name', 'hvg'. Transforming raw counts to Pearson residuals#; When computing Pearson residuals, the observed UMI counts are compared to the expected counts of a “null model”. This model includes only technical factors, but no biological differences between cells. We then only keep the deviations from this model, the residuals, as representation of the data.; This implicitly performs normalization by sequencing depth and variance stabilization: As the null model expects the technical sources of variance, they are removed from the data. In contrast, biological variance is preserved: The null model is designed not to predict biological differences between cells. As a result, it will deviate from the observed counts starkly whenever genes differ in their expression between subpopulations – and produce large residuals in return. This will even work for genes that mark only small subpopulations. An example of detecting a rare subpopulation consisting of just 50 cells with Pearson residuals is presented in Lause et al. (2021).; As a result, the transformed data will show less technical variability, and biological signals from variable genes will be amplified. Therefore, downstream processing like PCA will be dominated by biological rather then technical variances. This is why it makes sense to use Pearson residuals as basis for downstream processing.; After reducing the dataset to the most variable genes in the previous steps, we will now transform our raw counts to residuals by calling normalize_pearson_residuals(adata). In our example pipeline, we then apply PCA to reduce the dataset to the most relevant dimensions. We visualize this reduced representation with t-SNE and perform Leiden clustering, which is again taken from the PBMC3k tutorial.; This is just one of many possible pipelines: After PCA, you could also use UMAP or other embeddings to inspect the data, and cluster the data with a different algorithm than Leiden. Preparations#",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:22865,detect,detecting,22865,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,2,['detect'],['detecting']
Safety,"al variance. Choosing a smaller value will reduce; the required memory. flavor Literal['pearson_residuals'] (default: 'pearson_residuals')Choose the flavor for identifying highly variable genes. In this experimental; version, only ‘pearson_residuals’ is functional. check_values bool (default: True)If True, checks if counts in selected layer are integers as expected by this; function, and return a warning if non-integers are found. Otherwise, proceed; without checking. Setting this to False can speed up code for large datasets. layer str | None (default: None)Layer to use as input instead of X. If None, X is used. subset bool (default: False)If True, subset the data to highly-variable genes after finding them.; Otherwise merely indicate highly variable genes in adata.var (see below). inplace bool (default: True)If True, update adata with results. Otherwise, return results. See below for; details of what is returned. Return type:; DataFrame | None. Returns:; If inplace=True, adata.var is updated with the following fields. Otherwise,; returns the same fields as DataFrame. highly_variableboolboolean indicator of highly-variable genes. meansfloatmeans per gene. variancesfloatvariance per gene. residual_variancesfloatFor flavor='pearson_residuals', residual variance per gene. Averaged in the; case of multiple batches. highly_variable_rankfloatFor flavor='pearson_residuals', rank of the gene according to residual.; variance, median rank in the case of multiple batches. highly_variable_nbatchesintIf batch_key given, denotes in how many batches genes are detected as HVG. highly_variable_intersectionboolIf batch_key given, denotes the genes that are highly variable in all batches. Notes; Experimental version of sc.pp.highly_variable_genes(). previous; scanpy.experimental.pp.normalize_pearson_residuals_pca. next; scanpy.experimental.pp.recipe_pearson_residuals. Contents; . highly_variable_genes(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.highly_variable_genes.html:12958,detect,detected,12958,en/stable/generated/scanpy.experimental.pp.highly_variable_genes.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.highly_variable_genes.html,1,['detect'],['detected']
Safety,"al.pp.harmony_integrate; scanpy.external.pp.mnn_correct; scanpy.external.pp.scanorama_integrate; scanpy.external.pp.hashsolo; scanpy.external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .md. .pdf. Preprocessing: pp. Contents . Basic Preprocessing; Recipes; Batch effect correction; Doublet detection; Neighbors. Preprocessing: pp#; Filtering of highly-variable genes, batch-effect correction, per-cell normalization, preprocessing recipes.; Any transformation of the data matrix that is not a tool. Other than tools, preprocessing steps usually don’t return an easily interpretable annotation, but perform a basic transformation on the data matrix. Basic Preprocessing#; For visual quality control, see highest_expr_genes() and; filter_genes_dispersion() in scanpy.pl. pp.calculate_qc_metrics; Calculate quality control metrics. pp.filter_cells; Filter cell outliers based on counts and numbers of genes expressed. pp.filter_genes; Filter genes based on number of cells or counts. pp.highly_variable_genes; Annotate highly variable genes [Satija et al., 2015, Stuart et al., 2019, Zheng et al., 2017]. pp.log1p; Logarithmize the data matrix. pp.pca; Principal component analysis [Pedregosa et al., 2011]. pp.normalize_total; Normalize counts per cell. pp.regress_out; R",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/preprocessing.html:9318,detect,detection,9318,en/stable/api/preprocessing.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/preprocessing.html,1,['detect'],['detection']
Safety,"at generated the; doublet neighbors of each observed transcriptome. This information can; be used to infer the cell states that generated a given doublet state. n_neighbors int | None (default: None)Number of neighbors used to construct the KNN graph of observed; transcriptomes and simulated doublets. If None, this is; automatically set to np.round(0.5 * np.sqrt(n_obs)). threshold float | None (default: None)Doublet score threshold for calling a transcriptome a doublet. If; None, this is set automatically by looking for the minimum between; the two modes of the doublet_scores_sim_ histogram. It is best; practice to check the threshold visually using the; doublet_scores_sim_ histogram and/or based on co-localization of; predicted doublets in a 2-D embedding. verbose bool (default: True)If True, log progress updates. copy bool (default: False)If True, return a copy of the input adata with Scrublet results; added. Otherwise, Scrublet results are added in place. random_state Union[int, RandomState, None] (default: 0)Initial state for doublet simulation and nearest neighbors. Return type:; AnnData | None. Returns:; if copy=True it returns or else adds fields to adata. Those fields:. .obs['doublet_score']Doublet scores for each observed transcriptome. .obs['predicted_doublet']Boolean indicating predicted doublet status. .uns['scrublet']['doublet_scores_sim']Doublet scores for each simulated doublet transcriptome. .uns['scrublet']['doublet_parents']Pairs of .obs_names used to generate each simulated doublet; transcriptome. .uns['scrublet']['parameters']Dictionary of Scrublet parameters. See also. scrublet_simulate_doublets()Run Scrublet’s doublet simulation separately for advanced usage. scrublet_score_distribution()Plot histogram of doublet scores for observed transcriptomes and simulated doublets. previous; scanpy.pp.combat. next; scanpy.pp.scrublet_simulate_doublets. Contents; . scrublet(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pp.scrublet.html:14596,predict,predicted,14596,en/stable/api/generated/scanpy.pp.scrublet.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pp.scrublet.html,1,['predict'],['predicted']
Safety,"behavior is desired, the overdispersion parameter can instead be set to infinity (theta=np.Inf). Clipping threshold clip#; When a gene is expressed in only very few cells, and missing in all others, it will generate very large residuals for these few cells. In turn, these cells might dominate in downstream processing. To avoid such unbalanced behavior, Hafemeister & Satija (2019) introduced a heuristic that clips all residuals to +-sqrt(n_cells). This is the default behavior of all functions for Pearson residuals discussed here. If desired, a different threshold can be set using the clip argument. If no clipping is desired, use clip=np.Inf. chunksize and best practice to obtain Pearson residuals for large datasets#; Raw scRNA UMI counts are usually sparse, and can thus be stored efficiently for large datasets. However, when the count matrix is transformed to Pearson residuals, the data becomes dense. To avoid memory problems, we recommend that you reduce the size of your count matrix by gene selection, before running normalize_pearson_residuals(adata) on the reduced data. To perform RAM-efficient gene selection, use highly_variable_genes(adata,flavor='pearson_residuals') with the chunksize argument: This will still use Pearson residual variance to identify variable genes, but won’t compute all residuals at once. Reduce the chunksize as needed if you run into RAM issues during gene selection. Note that a very small chunksize will slow down the computation, so try to set it as large as possible with your resources.; As an example, we used chunksize=1000 when processing a dataset with 2 million cells in a machine with 500 GB RAM. For smaller machines, we would recommend to reduce this below 100. Wrapper functions for Pearson residuals preprocessing#; The scanpy.experimental.pp module also ships two wrappers that run multiple pre-processing steps at once:. sc.experimental.pp.normalize_pearson_residuals_pca() performs normalization by Pearson residuals and PCA in one go. ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:28992,avoid,avoid,28992,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,2,['avoid'],['avoid']
Safety,"but perform a basic transformation on the data matrix. Basic Preprocessing#; For visual quality control, see highest_expr_genes() and; filter_genes_dispersion() in scanpy.pl. pp.calculate_qc_metrics; Calculate quality control metrics. pp.filter_cells; Filter cell outliers based on counts and numbers of genes expressed. pp.filter_genes; Filter genes based on number of cells or counts. pp.highly_variable_genes; Annotate highly variable genes [Satija et al., 2015, Stuart et al., 2019, Zheng et al., 2017]. pp.log1p; Logarithmize the data matrix. pp.pca; Principal component analysis [Pedregosa et al., 2011]. pp.normalize_total; Normalize counts per cell. pp.regress_out; Regress out (mostly) unwanted sources of variation. pp.scale; Scale data to unit variance and zero mean. pp.subsample; Subsample to a fraction of the number of observations. pp.downsample_counts; Downsample counts from count matrix. Recipes#. pp.recipe_zheng17; Normalization and filtering as of Zheng et al. [2017]. pp.recipe_weinreb17; Normalization and filtering as of [Weinreb et al., 2017]. pp.recipe_seurat; Normalization and filtering as of Seurat [Satija et al., 2015]. Batch effect correction#; Also see [Data integration]. Note that a simple batch correction method is available via pp.regress_out(). Checkout scanpy.external for more. pp.combat; ComBat function for batch effect correction [Johnson et al., 2006, Leek et al., 2017, Pedersen, 2012]. Doublet detection#. pp.scrublet; Predict doublets using Scrublet [Wolock et al., 2019]. pp.scrublet_simulate_doublets; Simulate doublets by adding the counts of random observed transcriptome pairs. Neighbors#. pp.neighbors; Computes the nearest neighbors distance matrix and a neighborhood graph of observations [McInnes et al., 2018]. previous; API. next; scanpy.pp.calculate_qc_metrics. Contents; . Basic Preprocessing; Recipes; Batch effect correction; Doublet detection; Neighbors. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/preprocessing.html:11064,detect,detection,11064,en/stable/api/preprocessing.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/preprocessing.html,2,['detect'],['detection']
Safety,"canpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.external.tl.harmony_timeseries. Contents . harmony_timeseries(). scanpy.external.tl.harmony_timeseries#. scanpy.external.tl.harmony_timeseries(adata, tp, *, n_neighbors=30, n_components=1000, n_jobs=-2, copy=False)[source]#; Harmony time series for data visualization with augmented affinity matrix; at discrete time points [Nowotschin et al., 2019].; Harmony time series is a framework for data visualization, trajectory; detection and interpretation for scRNA-seq data measured at discrete; time points. Harmony constructs an augmented affinity matrix by augmenting; the kNN graph affinity matrix with mutually nearest neighbors between; successive time points. This augmented affinity matrix forms the basis for; generated a force directed layout for visualization and also serves as input; for computing the diffusion operator which can be used for trajectory; detection using Palantir. Note; More information and bug reports here. Parameters:. adata AnnDataAnnotated data matrix of shape n_obs × n_vars. Rows correspond to; cells and columns to genes. Rows represent two or more time points,; where replicates of the same time point are consecutive in order. tp strkey name of observation annotation .obs representing time points. Time; points should be categorical of dtype=category. The unique categories for; the categorical will be used as the time points to construct the timepoint; connections. n_neighbors int (defau",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.harmony_timeseries.html:9676,detect,detection,9676,en/stable/external/generated/scanpy.external.tl.harmony_timeseries.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.harmony_timeseries.html,2,['detect'],['detection']
Safety,"ces in the Leiden computation. seed int | None (default: None)Leiden initialization of the optimization. copy bool (default: False)Return a copy or write to adata. kargs AnyAdditional arguments passed to find_partition() and the; constructor of the partition_type. Return type:; tuple[ndarray | None, spmatrix, float | None] | None. Returns:; Depending on copy, returns or updates adata with the following fields:. communities - ndarray (obs, dtype int)integer array of community assignments for each row in data. graph - spmatrix (obsp, dtype float)the graph that was used for clustering. Q - float (uns, dtype float)the modularity score for communities on graph. Example; >>> from anndata import AnnData; >>> import scanpy as sc; >>> import scanpy.external as sce; >>> import numpy as np; >>> import pandas as pd. With annotated data as input:; >>> adata = sc.datasets.pbmc3k(); >>> sc.pp.normalize_per_cell(adata). Then do PCA:; >>> sc.pp.pca(adata, n_comps=100). Compute phenograph clusters:; Louvain community detection; >>> sce.tl.phenograph(adata, clustering_algo=""louvain"", k=30). Leiden community detection; >>> sce.tl.phenograph(adata, clustering_algo=""leiden"", k=30). Return only Graph object; >>> sce.tl.phenograph(adata, clustering_algo=None, k=30). Now to show phenograph on tSNE (for example):; Compute tSNE:; >>> sc.tl.tsne(adata, random_state=7). Plot phenograph clusters on tSNE:; >>> sc.pl.tsne(; ... adata, color = [""pheno_louvain"", ""pheno_leiden""], s = 100,; ... palette = sc.pl.palettes.vega_20_scanpy, legend_fontsize = 10; ... ). Cluster and cluster centroids for input Numpy ndarray; >>> df = np.random.rand(1000, 40); >>> dframe = pd.DataFrame(df); >>> dframe.index, dframe.columns = (map(str, dframe.index), map(str, dframe.columns)); >>> adata = AnnData(dframe); >>> sc.pp.pca(adata, n_comps=20); >>> sce.tl.phenograph(adata, clustering_algo=""leiden"", k=50); >>> sc.tl.tsne(adata, random_state=1); >>> sc.pl.tsne(; ... adata, color=['pheno_leiden'], s=100,; ... palette=sc",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.phenograph.html:13850,detect,detection,13850,en/stable/external/generated/scanpy.external.tl.phenograph.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.phenograph.html,2,['detect'],['detection']
Safety,"components used to embed the transcriptomes prior; to k-nearest-neighbor graph construction. use_approx_neighbors bool | None (default: None)Use approximate nearest neighbor method (annoy) for the KNN; classifier. get_doublet_neighbor_parents bool (default: False)If True, return (in .uns) the parent transcriptomes that generated the; doublet neighbors of each observed transcriptome. This information can; be used to infer the cell states that generated a given doublet state. n_neighbors int | None (default: None)Number of neighbors used to construct the KNN graph of observed; transcriptomes and simulated doublets. If None, this is; automatically set to np.round(0.5 * np.sqrt(n_obs)). threshold float | None (default: None)Doublet score threshold for calling a transcriptome a doublet. If; None, this is set automatically by looking for the minimum between; the two modes of the doublet_scores_sim_ histogram. It is best; practice to check the threshold visually using the; doublet_scores_sim_ histogram and/or based on co-localization of; predicted doublets in a 2-D embedding. verbose bool (default: True)If True, log progress updates. copy bool (default: False)If True, return a copy of the input adata with Scrublet results; added. Otherwise, Scrublet results are added in place. random_state Union[int, RandomState, None] (default: 0)Initial state for doublet simulation and nearest neighbors. Return type:; AnnData | None. Returns:; if copy=True it returns or else adds fields to adata. Those fields:. .obs['doublet_score']Doublet scores for each observed transcriptome. .obs['predicted_doublet']Boolean indicating predicted doublet status. .uns['scrublet']['doublet_scores_sim']Doublet scores for each simulated doublet transcriptome. .uns['scrublet']['doublet_parents']Pairs of .obs_names used to generate each simulated doublet; transcriptome. .uns['scrublet']['parameters']Dictionary of Scrublet parameters. See also. scrublet_simulate_doublets()Run Scrublet’s doublet simulation sepa",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pp.scrublet.html:14015,predict,predicted,14015,en/stable/api/generated/scanpy.pp.scrublet.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pp.scrublet.html,1,['predict'],['predicted']
Safety,"ct with n_obs × n_vars = 10968 × 2000; obs: 'n_genes', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'outlier_mt', 'outlier_total', 'outlier_ngenes'; var: 'gene_ids', 'feature_types', 'n_cells', 'mt', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'means', 'variances', 'residual_variances', 'highly_variable_rank', 'highly_variable'; uns: 'name', 'hvg'. Transforming raw counts to Pearson residuals#; When computing Pearson residuals, the observed UMI counts are compared to the expected counts of a “null model”. This model includes only technical factors, but no biological differences between cells. We then only keep the deviations from this model, the residuals, as representation of the data.; This implicitly performs normalization by sequencing depth and variance stabilization: As the null model expects the technical sources of variance, they are removed from the data. In contrast, biological variance is preserved: The null model is designed not to predict biological differences between cells. As a result, it will deviate from the observed counts starkly whenever genes differ in their expression between subpopulations – and produce large residuals in return. This will even work for genes that mark only small subpopulations. An example of detecting a rare subpopulation consisting of just 50 cells with Pearson residuals is presented in Lause et al. (2021).; As a result, the transformed data will show less technical variability, and biological signals from variable genes will be amplified. Therefore, downstream processing like PCA will be dominated by biological rather then technical variances. This is why it makes sense to use Pearson residuals as basis for downstream processing.; After reducing the dataset to the most variable genes in the previous steps, we will now transform our raw counts to residuals by calling normalize_pearson_residuals(adata). In our example pipeline, we then apply PCA to reduce the datase",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:22570,predict,predict,22570,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,2,['predict'],['predict']
Safety,"d genes. fig, axs = plt.subplots(1, 4, figsize=(15, 4)); sns.histplot(adata.obs[""total_counts""], kde=False, ax=axs[0]); sns.histplot(; adata.obs[""total_counts""][adata.obs[""total_counts""] < 10000],; kde=False,; bins=40,; ax=axs[1],; ); sns.histplot(adata.obs[""n_genes_by_counts""], kde=False, bins=60, ax=axs[2]); sns.histplot(; adata.obs[""n_genes_by_counts""][adata.obs[""n_genes_by_counts""] < 4000],; kde=False,; bins=60,; ax=axs[3],; ). <Axes: xlabel='n_genes_by_counts', ylabel='Count'>. sc.pp.filter_cells(adata, min_counts=5000); sc.pp.filter_cells(adata, max_counts=35000); adata = adata[adata.obs[""pct_counts_mt""] < 20].copy(); print(f""#cells after MT filter: {adata.n_obs}""); sc.pp.filter_genes(adata, min_cells=10). filtered out 44 cells that have less than 5000 counts; filtered out 130 cells that have more than 35000 counts; #cells after MT filter: 3861; filtered out 16916 genes that are detected in less than 10 cells. We proceed to normalize Visium counts data with the built-in normalize_total method from Scanpy, and detect highly-variable genes (for later). Note that there are alternatives for normalization (see discussion in [Luecken19], and more recent alternatives such as SCTransform or GLM-PCA). sc.pp.normalize_total(adata, inplace=True); sc.pp.log1p(adata); sc.pp.highly_variable_genes(adata, flavor=""seurat"", n_top_genes=2000). normalizing counts per cell; finished (0:00:00); extracting highly variable genes; finished (0:00:00); --> added; 'highly_variable', boolean vector (adata.var); 'means', float vector (adata.var); 'dispersions', float vector (adata.var); 'dispersions_norm', float vector (adata.var). Manifold embedding and clustering based on transcriptional similarity#; To embed and cluster the manifold encoded by transcriptional similarity, we proceed as in the standard clustering tutorial. sc.pp.pca(adata); sc.pp.neighbors(adata); sc.tl.umap(adata); sc.tl.leiden(; adata, key_added=""clusters"", flavor=""igraph"", directed=False, n_iterations=2; ). computing PC",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/basic-analysis.html:14897,detect,detect,14897,en/stable/tutorials/spatial/basic-analysis.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/basic-analysis.html,2,['detect'],['detect']
Safety,"d remove them. Afterwards, we make sure that all genes are at least detected once in the remaining cells. # define outliers and do the filtering for the 3k dataset; adata_pbmc3k.obs[""outlier_mt""] = adata_pbmc3k.obs.pct_counts_mt > 5; adata_pbmc3k.obs[""outlier_total""] = adata_pbmc3k.obs.total_counts > 5000; adata_pbmc3k.obs[""outlier_ngenes""] = adata_pbmc3k.obs.n_genes_by_counts > 2500. print(; ""%u cells with high %% of mitochondrial genes""; % (sum(adata_pbmc3k.obs[""outlier_mt""])); ); print(""%u cells with large total counts"" % (sum(adata_pbmc3k.obs[""outlier_total""]))); print(""%u cells with large number of genes"" % (sum(adata_pbmc3k.obs[""outlier_ngenes""]))). adata_pbmc3k = adata_pbmc3k[~adata_pbmc3k.obs[""outlier_mt""], :]; adata_pbmc3k = adata_pbmc3k[~adata_pbmc3k.obs[""outlier_total""], :]; adata_pbmc3k = adata_pbmc3k[~adata_pbmc3k.obs[""outlier_ngenes""], :]; sc.pp.filter_genes(adata_pbmc3k, min_cells=1). 57 cells with high % of mitochondrial genes; 69 cells with large total counts; 5 cells with large number of genes; filtered out 2 genes that are detected in less than 1 cells. # define outliers and do the filtering for the 10k dataset; adata_pbmc10k.obs[""outlier_mt""] = adata_pbmc10k.obs.pct_counts_mt > 20; adata_pbmc10k.obs[""outlier_total""] = adata_pbmc10k.obs.total_counts > 25000; adata_pbmc10k.obs[""outlier_ngenes""] = adata_pbmc10k.obs.n_genes_by_counts > 6000. print(; ""%u cells with high %% of mitochondrial genes""; % (sum(adata_pbmc10k.obs[""outlier_mt""])); ); print(""%u cells with large total counts"" % (sum(adata_pbmc10k.obs[""outlier_total""]))); print(; ""%u cells with large number of genes"" % (sum(adata_pbmc10k.obs[""outlier_ngenes""])); ). adata_pbmc10k = adata_pbmc10k[~adata_pbmc10k.obs[""outlier_mt""], :]; adata_pbmc10k = adata_pbmc10k[~adata_pbmc10k.obs[""outlier_total""], :]; adata_pbmc10k = adata_pbmc10k[~adata_pbmc10k.obs[""outlier_ngenes""], :]; sc.pp.filter_genes(adata_pbmc10k, min_cells=1). 494 cells with high % of mitochondrial genes; 75 cells with large total counts",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:16587,detect,detected,16587,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,2,['detect'],['detected']
Safety,"data.var); 'dispersions', float vector (adata.var); 'dispersions_norm', float vector (adata.var). Manifold embedding and clustering based on transcriptional similarity#; To embed and cluster the manifold encoded by transcriptional similarity, we proceed as in the standard clustering tutorial. sc.pp.pca(adata); sc.pp.neighbors(adata); sc.tl.umap(adata); sc.tl.leiden(; adata, key_added=""clusters"", flavor=""igraph"", directed=False, n_iterations=2; ). computing PCA; with n_comps=50; finished (0:00:30); computing neighbors; using 'X_pca' with n_pcs = 50; finished: added to `.uns['neighbors']`; `.obsp['distances']`, distances for each pair of neighbors; `.obsp['connectivities']`, weighted adjacency matrix (0:00:05); computing UMAP; finished: added; 'X_umap', UMAP coordinates (adata.obsm) (0:00:12); running Leiden clustering; finished: found 10 clusters and added; 'clusters', the cluster labels (adata.obs, categorical) (0:00:00). We plot some covariates to check if there is any particular structure in the UMAP associated with total counts and detected genes. plt.rcParams[""figure.figsize""] = (4, 4); sc.pl.umap(adata, color=[""total_counts"", ""n_genes_by_counts"", ""clusters""], wspace=0.4). Visualization in spatial coordinates#; Let us now take a look at how total_counts and n_genes_by_counts behave in spatial coordinates. We will overlay the circular spots on top of the Hematoxylin and eosin stain (H&E) image provided, using the function sc.pl.spatial. plt.rcParams[""figure.figsize""] = (8, 8); sc.pl.spatial(adata, img_key=""hires"", color=[""total_counts"", ""n_genes_by_counts""]). The function sc.pl.spatial accepts 4 additional parameters:. img_key: key where the img is stored in the adata.uns element; crop_coord: coordinates to use for cropping (left, right, top, bottom); alpha_img: alpha value for the transcparency of the image; bw: flag to convert the image into gray scale. Furthermore, in sc.pl.spatial, the size parameter changes its behaviour: it becomes a scaling factor for the s",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/basic-analysis.html:16455,detect,detected,16455,en/stable/tutorials/spatial/basic-analysis.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/basic-analysis.html,2,['detect'],['detected']
Safety,"e Pearson residuals, we need an estimation of the technical variance in the data. There is still a debate on which noise distribution is most appropiate for scRNA UMI data, with Poisson or the Negative binomial being likely candidates. We implemented the negative binomial model here, which is overdispersed compared to Poisson. The amount of overdispersion is controlled by the argument theta, where a smaller theta corresponds to larger overdispersion. Lause et al. (2021) recommend using the default theta=100, as noise in negative control data without biological variation was fit well by this value. If Poisson behavior is desired, the overdispersion parameter can instead be set to infinity (theta=np.Inf). Clipping threshold clip#; When a gene is expressed in only very few cells, and missing in all others, it will generate very large residuals for these few cells. In turn, these cells might dominate in downstream processing. To avoid such unbalanced behavior, Hafemeister & Satija (2019) introduced a heuristic that clips all residuals to +-sqrt(n_cells). This is the default behavior of all functions for Pearson residuals discussed here. If desired, a different threshold can be set using the clip argument. If no clipping is desired, use clip=np.Inf. chunksize and best practice to obtain Pearson residuals for large datasets#; Raw scRNA UMI counts are usually sparse, and can thus be stored efficiently for large datasets. However, when the count matrix is transformed to Pearson residuals, the data becomes dense. To avoid memory problems, we recommend that you reduce the size of your count matrix by gene selection, before running normalize_pearson_residuals(adata) on the reduced data. To perform RAM-efficient gene selection, use highly_variable_genes(adata,flavor='pearson_residuals') with the chunksize argument: This will still use Pearson residual variance to identify variable genes, but won’t compute all residuals at once. Reduce the chunksize as needed if you run into RAM ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:28398,avoid,avoid,28398,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,2,['avoid'],['avoid']
Safety,"e number of genes; filtered out 2 genes that are detected in less than 1 cells. # define outliers and do the filtering for the 10k dataset; adata_pbmc10k.obs[""outlier_mt""] = adata_pbmc10k.obs.pct_counts_mt > 20; adata_pbmc10k.obs[""outlier_total""] = adata_pbmc10k.obs.total_counts > 25000; adata_pbmc10k.obs[""outlier_ngenes""] = adata_pbmc10k.obs.n_genes_by_counts > 6000. print(; ""%u cells with high %% of mitochondrial genes""; % (sum(adata_pbmc10k.obs[""outlier_mt""])); ); print(""%u cells with large total counts"" % (sum(adata_pbmc10k.obs[""outlier_total""]))); print(; ""%u cells with large number of genes"" % (sum(adata_pbmc10k.obs[""outlier_ngenes""])); ). adata_pbmc10k = adata_pbmc10k[~adata_pbmc10k.obs[""outlier_mt""], :]; adata_pbmc10k = adata_pbmc10k[~adata_pbmc10k.obs[""outlier_total""], :]; adata_pbmc10k = adata_pbmc10k[~adata_pbmc10k.obs[""outlier_ngenes""], :]; sc.pp.filter_genes(adata_pbmc10k, min_cells=1). 494 cells with high % of mitochondrial genes; 75 cells with large total counts; 6 cells with large number of genes; filtered out 1 genes that are detected in less than 1 cells. Use Pearson residuals for selection of highly variable genes#; Analytic Pearson residuals can be used to identify biologically variable genes. For that, the observed counts are compared to the expected counts of a “null model”. This model includes no biological variability between cells. Pearson residuals are defined such that genes that are not differentially expressed will have variance close to 1. In contrast, if a gene is differentially expressed, it will deviate from the null model, causing larger residuals and residual variance >1 for this gene. More details and comparisons to other gene selection methods can be found in Lause et al. (2021).; The call to highly_variable_genes(flavor='pearson_residuals',n_top_genes=2000) computes the residual variances and selects 2000 genes based on this. As shown in the plots below, cell type marker genes known a priori are successfully selected. Compute 200",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:17597,detect,detected,17597,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,2,['detect'],['detected']
Safety,"es; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.pl.highest_expr_genes. Contents . highest_expr_genes(). scanpy.pl.highest_expr_genes#. scanpy.pl.highest_expr_genes(adata, n_top=30, *, show=None, save=None, ax=None, gene_symbols=None, log=False, **kwds)[source]#; Fraction of counts assigned to each gene over all cells.; Computes, for each gene, the fraction of counts assigned to that gene within; a cell. The n_top genes with the highest mean fraction over all cells are; plotted as boxplots.; This plot is similar to the scater package function plotHighestExprs(type; = ""highest-expression""), see here. Quoting; from there:. We expect to see the “usual suspects”, i.e., mitochondrial genes, actin,; ribosomal protein, MALAT1. A few spike-in transcripts may also be; present here, though if all of the spike-ins are in the top 50, it; suggests that too much spike-in RNA was added. A large number of; pseudo-genes or predicted genes may indicate problems with alignment.; – Davis McCarthy and Aaron Lun. Parameters:. adata AnnDataAnnotated data matrix. n_top int (default: 30)Number of top. show bool | None (default: None)Show the plot, do not return axis. save str | bool | None (default: None)If True or a str, save the figure.; A string is appended to the default filename.; Infer the filetype if ending on {'.pdf', '.png', '.svg'}. ax Axes | None (default: None)A matplotlib axes object. Only works if plotting a single component. gene_symbols str | None (default: None)Key for field in .var that stores gene symbols if you do not want to use .var_names. log bool (default: False)Plot x-axis in log scale. **kwdsAre passed to boxplot(). Returns:; If show==False a Axes. previous; scanpy.pl.StackedViolin.swap_axes. next; scanpy.pl.filter_genes_dispersion. Contents; . highest_expr_genes(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pl.highest_expr_genes.html:10115,predict,predicted,10115,en/stable/api/generated/scanpy.pl.highest_expr_genes.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pl.highest_expr_genes.html,1,['predict'],['predicted']
Safety,"etrics(; adata, qc_vars=[""mt"", ""ribo"", ""hb""], inplace=True, log1p=True; ). One can now inspect violin plots of some of the computed QC metrics:. the number of genes expressed in the count matrix; the total counts per cell; the percentage of counts in mitochondrial genes. sc.pl.violin(; adata,; [""n_genes_by_counts"", ""total_counts"", ""pct_counts_mt""],; jitter=0.4,; multi_panel=True,; ). Additionally, it is useful to consider QC metrics jointly by inspecting a scatter plot colored by pct_counts_mt. sc.pl.scatter(adata, ""total_counts"", ""n_genes_by_counts"", color=""pct_counts_mt""). Based on the QC metric plots, one could now remove cells that have too many mitochondrial genes expressed or too many total counts by setting manual or automatic thresholds. However, sometimes what appears to be poor QC metrics can be driven by real biology so we suggest starting with a very permissive filtering strategy and revisiting it at a later point. We therefore now only filter cells with less than 100 genes expressed and genes that are detected in less than 3 cells.; Additionally, it is important to note that for datasets with multiple batches, quality control should be performed for each sample individually as quality control thresholds can very substantially between batches. sc.pp.filter_cells(adata, min_genes=100); sc.pp.filter_genes(adata, min_cells=3). Doublet detection#; As a next step, we run a doublet detection algorithm. Identifying doublets is crucial as they can lead to misclassifications or distortions in downstream analysis steps. Scanpy contains the doublet detection method Scrublet [Wolock et al., 2019]. Scrublet predicts cell doublets using a nearest-neighbor classifier of observed transcriptomes and simulated doublets. scanpy.pp.scrublet() adds doublet_score and predicted_doublet to .obs. One can now either filter directly on predicted_doublet or use the doublet_score later during clustering to filter clusters with high doublet scores. sc.pp.scrublet(adata, batch_key=""sa",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering.html:12884,detect,detected,12884,en/stable/tutorials/basics/clustering.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering.html,2,['detect'],['detected']
Safety,"external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.external.tl.cyclone. Contents . cyclone(). scanpy.external.tl.cyclone#. scanpy.external.tl.cyclone(adata, marker_pairs=None, *, iterations=1000, min_iter=100, min_pairs=50)[source]#; Assigns scores and predicted class to observations [Scialdone et al., 2015] [Fechtner, 2018].; Calculates scores for each observation and each phase and assigns prediction; based on marker pairs indentified by sandbag().; This reproduces the approach of Scialdone et al. [2015] in the implementation of; Fechtner [2018]. Parameters:. adata AnnDataThe annotated data matrix. marker_pairs Mapping[str, Collection[tuple[str, str]]] | None (default: None)Mapping of categories to lists of marker pairs.; See sandbag() output. iterations int (default: 1000)An integer scalar specifying the number of; iterations for random sampling to obtain a cycle score. min_iter int (default: 100)An integer scalar specifying the minimum number of iterations; for score estimation. min_pairs int (default: 50)An integer scalar specifying the minimum number of pairs; for score estimation. Return type:; DataFrame. Returns:; A DataFrame with samples as index and categories as columns; with scores for each category for each sample and a additional column with; the name of the max scoring category for each sample.; If marker_pairs contains only the cell cycle categories G1,",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.cyclone.html:9586,predict,prediction,9586,en/stable/external/generated/scanpy.external.tl.cyclone.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.cyclone.html,2,['predict'],['prediction']
Safety,"g_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .md. .pdf. Tools: TL. Contents . Embeddings; Clustering and trajectory inference; Gene scores, Cell cycle. Tools: TL#. Embeddings#. tl.phate(adata[, n_components, k, a, ...]); PHATE [Moon et al., 2019]. tl.palantir(adata, *[, n_components, knn, ...]); Run Diffusion maps using the adaptive anisotropic kernel [Setty et al., 2019]. tl.trimap(adata[, n_components, n_inliers, ...]); TriMap: Large-scale Dimensionality Reduction Using Triplets [Amid and Warmuth, 2019]. tl.sam(adata, *[, max_iter, num_norm_avg, ...]); Self-Assembling Manifolds single-cell RNA sequencing analysis tool [Tarashansky et al., 2019]. Clustering and trajectory inference#. tl.phenograph(data[, clustering_algo, k, ...]); PhenoGraph clustering [Levine et al., 2015]. tl.harmony_timeseries(adata, tp, *[, ...]); Harmony time series for data visualization with augmented affinity matrix at discrete time points [Nowotschin et al., 2019]. tl.wishbone(adata, start_cell, *[, branch, ...]); Wishbone identifies bifurcating developmental trajectories from single-cell data [Setty et al., 2016]. tl.palantir(adata, *[, n_components, knn, ...]); Run Diffusion maps using the adaptive anisotropic kernel [Setty et al., 2019]. tl.palantir_results(adata, early_cell, *[, ...]); Running Palantir. Gene scores, Cell cycle#. tl.sandbag(adata[, annotation, fraction, ...]); Calculate marker pairs of genes [Fechtner, 2018, Scialdone et al., 2015]. tl.cyclone(adata[, marker_pairs, ...]); Assigns scores and predicted class to observations [Scialdone et al., 2015] [Fechtner, 2018]. previous; scanpy.external.pp.magic. next; scanpy.external.tl.phate. Contents; . Embeddings; Clustering and trajectory inference; Gene scores, Cell cycle. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/tools.html:10673,predict,predicted,10673,en/stable/external/tools.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/tools.html,1,['predict'],['predicted']
Safety,"ies; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.external.pp.magic. Contents . magic(). scanpy.external.pp.magic#. scanpy.external.pp.magic(adata, name_list=None, *, knn=5, decay=1, knn_max=None, t=3, n_pca=100, solver='exact', knn_dist='euclidean', random_state=None, n_jobs=None, verbose=False, copy=None, **kwargs)[source]#; Markov Affinity-based Graph Imputation of Cells (MAGIC) API [van Dijk et al., 2018].; MAGIC is an algorithm for denoising and transcript recover of single cells; applied to single-cell sequencing data. MAGIC builds a graph from the data; and uses diffusion to smooth out noise and recover the data manifold.; The algorithm implemented here has changed primarily in two ways; compared to the algorithm described in van Dijk et al. [2018]. Firstly, we use; the adaptive kernel described in Moon et al. [2019] for; improved stability. Secondly, data diffusion is applied; in the PCA space, rather than the data space, for speed and; memory improvements.; More information and bug reports; here. For help, visit; <https://krishnaswamylab.org/get-help>. Parameters:. adata AnnDataAn anndata file with .raw attribute representing raw counts. name_list Union[Literal['all_genes', 'pca_only'], Sequence[str], None] (default: None)Denoised genes to return. The default 'all_genes'/None; may require a large amount of memory if the input data is sparse.; Another possibility is 'pca_only'. knn int (default: 5)number of nearest neighbors on which to bui",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.magic.html:9656,recover,recover,9656,en/stable/generated/scanpy.external.pp.magic.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.magic.html,1,['recover'],['recover']
Safety,"ishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.pp.filter_genes_dispersion. Contents . filter_genes_dispersion(). scanpy.pp.filter_genes_dispersion#. scanpy.pp.filter_genes_dispersion(data, *, flavor='seurat', min_disp=None, max_disp=None, min_mean=None, max_mean=None, n_bins=20, n_top_genes=None, log=True, subset=True, copy=False)[source]#; Extract highly variable genes [Satija et al., 2015, Zheng et al., 2017]. Warning. Deprecated since version 1.3.6: Use highly_variable_genes(); instead. The new function is equivalent to the present; function, except that. the new function always expects logarithmized data; subset=False in the new function, it suffices to; merely annotate the genes, tools like pp.pca will; detect the annotation; you can now call: sc.pl.highly_variable_genes(adata); copy is replaced by inplace. If trying out parameters, pass the data matrix instead of AnnData.; Depending on flavor, this reproduces the R-implementations of Seurat; [Satija et al., 2015] and Cell Ranger [Zheng et al., 2017].; The normalized dispersion is obtained by scaling with the mean and standard; deviation of the dispersions for genes falling into a given bin for mean; expression of genes. This means that for each bin of mean expression, highly; variable genes are selected.; Use flavor='cell_ranger' with care and in the same way as in; recipe_zheng17(). Parameters:. data AnnData | spmatrix | ndarrayThe (annotated) data matrix of shape n_obs × n_vars. Rows correspond; to cells and columns to genes. flavor Literal['seurat', 'cell_ranger'] (default: 'seurat')Choose the flavor for computing normalized dispersion. If choosing; ‘seurat’, this expects non-logarithmized data – the logarithm of mean; and dispersion is taken inte",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.filter_genes_dispersion.html:9920,detect,detect,9920,en/stable/generated/scanpy.pp.filter_genes_dispersion.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.filter_genes_dispersion.html,1,['detect'],['detect']
Safety,"k. Analytic pearson residuals for normalization of single-cell rna-seq umi data. Genome Biology, sep 2021. URL: https://doi.org/10.1186/s13059-021-02451-7, doi:10.1186/s13059-021-02451-7. [LJP+17]; Jeffrey T. Leek, W. Evan Johnson, Hilary S. Parker, Elana J.Fertig, Andrew E. Jaffe, John D. Storey, Yuqing Zhang, and Leonardo Collado Torres. Sva. 2017. URL: https://bioconductor.org/packages/sva, doi:10.18129/B9.BIOC.SVA. [LSB+15]; Jacob H. Levine, Erin F. Simonds, Sean C. Bendall, Kara L. Davis, El-ad D. Amir, Michelle D. Tadmor, Oren Litvin, Harris G. Fienberg, Astraea Jager, Eli R. Zunder, Rachel Finck, Amanda L. Gedman, Ina Radtke, James R. Downing, Dana Pe’er, and Garry P. Nolan. Data-driven phenotypic dissection of aml reveals progenitor-like cells that correlate with prognosis. Cell, 162(1):184–197, jul 2015. URL: https://doi.org/10.1016/j.cell.2015.05.047, doi:10.1016/j.cell.2015.05.047. [LWT19]; Mohammad Lotfollahi, F. Alexander Wolf, and Fabian J. Theis. Scgen predicts single-cell perturbation responses. Nature Methods, 16(8):715–721, jul 2019. URL: https://doi.org/10.1038/s41592-019-0494-8, doi:10.1038/s41592-019-0494-8. [LBC+21]; Malte Luecken, Daniel Burkhardt, Robrecht Cannoodt, Christopher Lance, Aditi Agrawal, Hananeh Aliee, Ann Chen, Louise Deconinck, Angela Detweiler, Alejandro Granados, Shelly Huynh, Laura Isacco, Yang Kim, Dominik Klein, Bony De Kumar, Sunil Kuppasani, Heiko Lickert, Aaron McGeever, Joaquin Melgarejo, Honey Mekonen, Maurizio Morri, Michaela Müller, Norma Neff, Sheryl Paul, Bastian Rieck, Kaylie Schneider, Scott Steelman, Michael Sterr, Daniel Treacy, Alexander Tong, Alexandra-Chloe Villani, Guilin Wang, Jia Yan, Ce Zhang, Angela Pisco, Smita Krishnaswamy, Fabian Theis, and Jonathan M Bloom. A sandbox for prediction and integration of dna, rna, and proteins in single cells. In J. Vanschoren and S. Yeung, editors, Proceedings of the Neural Information Processing Systems Track on Datasets and Benchmarks, volume 1. Curran, 2021. URL: htt",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/references.html:18043,predict,predicts,18043,en/stable/references.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/references.html,1,['predict'],['predicts']
Safety,"ll, 162(1):184–197, jul 2015. URL: https://doi.org/10.1016/j.cell.2015.05.047, doi:10.1016/j.cell.2015.05.047. [LWT19]; Mohammad Lotfollahi, F. Alexander Wolf, and Fabian J. Theis. Scgen predicts single-cell perturbation responses. Nature Methods, 16(8):715–721, jul 2019. URL: https://doi.org/10.1038/s41592-019-0494-8, doi:10.1038/s41592-019-0494-8. [LBC+21]; Malte Luecken, Daniel Burkhardt, Robrecht Cannoodt, Christopher Lance, Aditi Agrawal, Hananeh Aliee, Ann Chen, Louise Deconinck, Angela Detweiler, Alejandro Granados, Shelly Huynh, Laura Isacco, Yang Kim, Dominik Klein, Bony De Kumar, Sunil Kuppasani, Heiko Lickert, Aaron McGeever, Joaquin Melgarejo, Honey Mekonen, Maurizio Morri, Michaela Müller, Norma Neff, Sheryl Paul, Bastian Rieck, Kaylie Schneider, Scott Steelman, Michael Sterr, Daniel Treacy, Alexander Tong, Alexandra-Chloe Villani, Guilin Wang, Jia Yan, Ce Zhang, Angela Pisco, Smita Krishnaswamy, Fabian Theis, and Jonathan M Bloom. A sandbox for prediction and integration of dna, rna, and proteins in single cells. In J. Vanschoren and S. Yeung, editors, Proceedings of the Neural Information Processing Systems Track on Datasets and Benchmarks, volume 1. Curran, 2021. URL: https://datasets-benchmarks-proceedings.neurips.cc/paper_files/paper/2021/file/158f3069a435b314a80bdcb024f8e422-Paper-round2.pdf. [MCLW17]; Davis J McCarthy, Kieran R Campbell, Aaron T L Lun, and Quin F Wills. Scater: pre-processing, quality control, normalization and visualization of single-cell RNA-seq data in r. Bioinformatics, 33(8):1179–1186, jan 2017. URL: https://doi.org/10.1093/bioinformatics/btw777, doi:10.1093/bioinformatics/btw777. [MHM18]; Leland McInnes, John Healy, and James Melville. Umap: uniform manifold approximation and projection for dimension reduction. 2018. URL: https://arxiv.org/abs/1802.03426, doi:10.48550/ARXIV.1802.03426. [MWH+15]; Victoria Moignard, Steven Woodhouse, Laleh Haghverdi, Andrew J Lilly, Yosuke Tanaka, Adam C Wilkinson, Florian Buettner, Iain C Ma",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/references.html:18829,predict,prediction,18829,en/stable/references.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/references.html,1,['predict'],['prediction']
Safety,"loess; model fit if flavor='seurat_v3'. n_bins int (default: 20)Number of bins for binning the mean gene expression. Normalization is; done with respect to each bin. If just a single gene falls into a bin,; the normalized dispersion is artificially set to 1. You’ll be informed; about this if you set settings.verbosity = 4. flavor Literal['seurat', 'cell_ranger', 'seurat_v3', 'seurat_v3_paper'] (default: 'seurat')Choose the flavor for identifying highly variable genes. For the dispersion; based methods in their default workflows, Seurat passes the cutoffs whereas; Cell Ranger passes n_top_genes. subset bool (default: False)Inplace subset to highly-variable genes if True otherwise merely indicate; highly variable genes. inplace bool (default: True)Whether to place calculated metrics in .var or return them. batch_key str | None (default: None)If specified, highly-variable genes are selected within each batch separately and merged.; This simple process avoids the selection of batch-specific genes and acts as a; lightweight batch correction method. For all flavors, except seurat_v3, genes are first sorted; by how many batches they are a HVG. For dispersion-based flavors ties are broken; by normalized dispersion. For flavor = 'seurat_v3_paper', ties are broken by the median; (across batches) rank based on within-batch normalized variance. check_values bool (default: True)Check if counts in selected layer are integers. A Warning is returned if set to True.; Only used if flavor='seurat_v3'/'seurat_v3_paper'. Return type:; DataFrame | None. Returns:; Returns a pandas.DataFrame with calculated metrics if inplace=True, else returns an AnnData object where it sets the following field:. adata.var['highly_variable']pandas.Series (dtype bool)boolean indicator of highly-variable genes. adata.var['means']pandas.Series (dtype float)means per gene. adata.var['dispersions']pandas.Series (dtype float)For dispersion-based flavors, dispersions per gene. adata.var['dispersions_norm']pandas",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.highly_variable_genes.html:13849,avoid,avoids,13849,en/stable/generated/scanpy.pp.highly_variable_genes.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.highly_variable_genes.html,1,['avoid'],['avoids']
Safety,"meters:. adata AnnDataThe annotated data matrix of shape n_obs × n_vars.; Rows correspond to cells and columns to genes. theta float (default: 100)The negative binomial overdispersion parameter theta for Pearson residuals.; Higher values correspond to less overdispersion (var = mean + mean^2/theta), and theta=np.inf corresponds to a Poisson model. clip float | None (default: None)Determines if and how residuals are clipped:. If None, residuals are clipped to the interval [-sqrt(n_obs), sqrt(n_obs)], where n_obs is the number of cells in the dataset (default behavior).; If any scalar c, residuals are clipped to the interval [-c, c]. Set clip=np.inf for no clipping. n_top_genes int | None (default: None)Number of highly-variable genes to keep. Mandatory if flavor='seurat_v3' or; flavor='pearson_residuals'. batch_key str | None (default: None)If specified, highly-variable genes are selected within each batch separately; and merged. This simple process avoids the selection of batch-specific genes; and acts as a lightweight batch correction method. Genes are first sorted by; how many batches they are a HVG. If flavor='pearson_residuals', ties are; broken by the median rank (across batches) based on within-batch residual; variance. chunksize int (default: 1000)If flavor='pearson_residuals', this dertermines how many genes are processed at; once while computing the residual variance. Choosing a smaller value will reduce; the required memory. flavor Literal['pearson_residuals'] (default: 'pearson_residuals')Choose the flavor for identifying highly variable genes. In this experimental; version, only ‘pearson_residuals’ is functional. check_values bool (default: True)If True, checks if counts in selected layer are integers as expected by this; function, and return a warning if non-integers are found. Otherwise, proceed; without checking. Setting this to False can speed up code for large datasets. layer str | None (default: None)Layer to use as input instead of X. If None, X is",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.highly_variable_genes.html:10962,avoid,avoids,10962,en/stable/generated/scanpy.experimental.pp.highly_variable_genes.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.highly_variable_genes.html,1,['avoid'],['avoids']
Safety,"n-Whitney-U) test is very similar. We recommend using the latter in publications, see e.g., Sonison & Robinson (2018). You might also consider much more powerful differential testing packages like MAST, limma, DESeq2 and, for python, the recent diffxpy. sc.tl.rank_genes_groups(adata, ""leiden"", method=""wilcoxon""); sc.pl.rank_genes_groups(adata, n_genes=25, sharey=False). ranking genes; finished (0:00:03). Save the result. adata.write(results_file). As an alternative, let us rank genes using logistic regression. For instance, this has been suggested by Natranos et al. (2018). The essential difference is that here, we use a multi-variate appraoch whereas conventional differential tests are uni-variate. Clark et al. (2014) has more details. sc.tl.rank_genes_groups(adata, ""leiden"", method=""logreg"", max_iter=1000); sc.pl.rank_genes_groups(adata, n_genes=25, sharey=False). ranking genes; finished (0:00:32). With the exceptions of IL7R, which is only found by the t-test and FCER1A, which is only found by the other two appraoches, all marker genes are recovered in all approaches. Louvain Group; Markers; Cell Type. 0; IL7R; CD4 T cells. 1; CD14, LYZ; CD14+ Monocytes. 2; MS4A1; B cells. 3; CD8A; CD8 T cells. 4; GNLY, NKG7; NK cells. 5; FCGR3A, MS4A7; FCGR3A+ Monocytes. 6; FCER1A, CST3; Dendritic Cells. 7; PPBP; Megakaryocytes. Let us also define a list of marker genes for later reference. marker_genes = [; *[""IL7R"", ""CD79A"", ""MS4A1"", ""CD8A"", ""CD8B"", ""LYZ"", ""CD14""],; *[""LGALS3"", ""S100A8"", ""GNLY"", ""NKG7"", ""KLRB1""],; *[""FCGR3A"", ""MS4A7"", ""FCER1A"", ""CST3"", ""PPBP""],; ]. Reload the object that has been save with the Wilcoxon Rank-Sum test result. adata = sc.read(results_file). Show the 10 top ranked genes per cluster 0, 1, …, 7 in a dataframe. pd.DataFrame(adata.uns[""rank_genes_groups""][""names""]).head(5). 0; 1; 2; 3; 4; 5; 6; 7. 0; RPS12; CD74; LST1; NKG7; CCL5; LYZ; HLA-DPA1; PF4. 1; LDHB; CD79A; FCER1G; GZMB; NKG7; S100A9; HLA-DPB1; SDPR. 2; RPS25; HLA-DRA; AIF1; GNLY; CST7; S100A",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering-2017.html:21174,recover,recovered,21174,en/stable/tutorials/basics/clustering-2017.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering-2017.html,2,['recover'],['recovered']
Safety,"n_cells=3). Doublet detection#; As a next step, we run a doublet detection algorithm. Identifying doublets is crucial as they can lead to misclassifications or distortions in downstream analysis steps. Scanpy contains the doublet detection method Scrublet [Wolock et al., 2019]. Scrublet predicts cell doublets using a nearest-neighbor classifier of observed transcriptomes and simulated doublets. scanpy.pp.scrublet() adds doublet_score and predicted_doublet to .obs. One can now either filter directly on predicted_doublet or use the doublet_score later during clustering to filter clusters with high doublet scores. sc.pp.scrublet(adata, batch_key=""sample""). We can remove doublets by either filtering out the cells called as doublets, or waiting until we’ve done a clustering pass and filtering out any clusters with high doublet scores. See also; Alternative methods for doublet detection within the scverse ecosystem are DoubletDetection and SOLO. You can read more about these in the Doublet Detection chapter of Single Cell Best Practices. Normalization#; The next preprocessing step is normalization. A common approach is count depth scaling with subsequent log plus one (log1p) transformation. Count depth scaling normalizes the data to a “size factor” such as the median count depth in the dataset, ten thousand (CP10k) or one million (CPM, counts per million). The size factor for count depth scaling can be controlled via target_sum in pp.normalize_total. We are applying median count depth normalization with log1p transformation (AKA log1PF). # Saving count data; adata.layers[""counts""] = adata.X.copy(). # Normalizing to median total counts; sc.pp.normalize_total(adata); # Logarithmize the data; sc.pp.log1p(adata). Feature selection#; As a next step, we want to reduce the dimensionality of the dataset and only include the most informative genes. This step is commonly known as feature selection. The scanpy function pp.highly_variable_genes annotates highly variable genes by repr",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering.html:14199,Detect,Detection,14199,en/stable/tutorials/basics/clustering.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering.html,1,['Detect'],['Detection']
Safety,"nal.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .md. .pdf. API. API#; Import Scanpy as:; import scanpy as sc. Note; Additional functionality is available in the broader ecosystem, with some tools being wrapped in the scanpy.external module. Preprocessing: pp; Basic Preprocessing; Recipes; Batch effect correction; Doublet detection; Neighbors. Tools: tl; Embeddings; Clustering and trajectory inference; Data integration; Marker genes; Gene scores, Cell cycle; Simulations. Plotting: pl; Generic; Classes; Preprocessing; Tools. Reading; scanpy.read; scanpy.read_10x_h5; scanpy.read_10x_mtx; scanpy.read_visium; scanpy.read_h5ad; scanpy.read_csv; scanpy.read_excel; scanpy.read_hdf; scanpy.read_loom; scanpy.read_mtx; scanpy.read_text; scanpy.read_umi_tools. Get object from AnnData: get; scanpy.get.obs_df; scanpy.get.var_df; scanpy.get.rank_genes_groups_df; scanpy.get.aggregate. Queries; scanpy.queries.biomart_annotations; scanpy.queries.gene_coordinates; scanpy.queries.mitochondrial_genes; scanpy.queries.enrich. Metrics; scanpy.metrics.confusion_matrix; scanpy.metrics.gearys_c; scanpy.metrics.morans_i. Experimental; scanpy.experimental.pp.normalize_pearson_residuals; scanpy.experimental.pp.normalize_pearson_residuals_pca; scanpy.experimental.pp.highly_variable_genes; scanpy.experi",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/index.html:9475,detect,detection,9475,en/stable/api/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/index.html,1,['detect'],['detection']
Safety,"nal.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.external.pp.magic. Contents . magic(). scanpy.external.pp.magic#. scanpy.external.pp.magic(adata, name_list=None, *, knn=5, decay=1, knn_max=None, t=3, n_pca=100, solver='exact', knn_dist='euclidean', random_state=None, n_jobs=None, verbose=False, copy=None, **kwargs)[source]#; Markov Affinity-based Graph Imputation of Cells (MAGIC) API [van Dijk et al., 2018].; MAGIC is an algorithm for denoising and transcript recover of single cells; applied to single-cell sequencing data. MAGIC builds a graph from the data; and uses diffusion to smooth out noise and recover the data manifold.; The algorithm implemented here has changed primarily in two ways; compared to the algorithm described in van Dijk et al. [2018]. Firstly, we use; the adaptive kernel described in Moon et al. [2019] for; improved stability. Secondly, data diffusion is applied; in the PCA space, rather than the data space, for speed and; memory improvements.; More information and bug reports; here. For help, visit; <https://krishnaswamylab.org/get-help>. Parameters:. adata AnnDataAn anndata file with .raw attribute representing raw counts. name_list Union[Literal['all_genes', 'pca_only'], Sequence[str], None] (default: None)Denoised genes to return. The default 'all_genes'/None; may require a large amount of memory if the input data is sparse.; Another possibility is 'pca_only'. knn int (default: 5)number of nearest neighbors on which to build kernel. decay float | None (default: 1)sets decay rate of kernel tails.; If None, alpha decaying kernel is n",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.magic.html:9800,recover,recover,9800,en/stable/generated/scanpy.external.pp.magic.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.magic.html,1,['recover'],['recover']
Safety,"nally, it is useful to consider QC metrics jointly by inspecting a scatter plot colored by pct_counts_mt. sc.pl.scatter(adata, ""total_counts"", ""n_genes_by_counts"", color=""pct_counts_mt""). Based on the QC metric plots, one could now remove cells that have too many mitochondrial genes expressed or too many total counts by setting manual or automatic thresholds. However, sometimes what appears to be poor QC metrics can be driven by real biology so we suggest starting with a very permissive filtering strategy and revisiting it at a later point. We therefore now only filter cells with less than 100 genes expressed and genes that are detected in less than 3 cells.; Additionally, it is important to note that for datasets with multiple batches, quality control should be performed for each sample individually as quality control thresholds can very substantially between batches. sc.pp.filter_cells(adata, min_genes=100); sc.pp.filter_genes(adata, min_cells=3). Doublet detection#; As a next step, we run a doublet detection algorithm. Identifying doublets is crucial as they can lead to misclassifications or distortions in downstream analysis steps. Scanpy contains the doublet detection method Scrublet [Wolock et al., 2019]. Scrublet predicts cell doublets using a nearest-neighbor classifier of observed transcriptomes and simulated doublets. scanpy.pp.scrublet() adds doublet_score and predicted_doublet to .obs. One can now either filter directly on predicted_doublet or use the doublet_score later during clustering to filter clusters with high doublet scores. sc.pp.scrublet(adata, batch_key=""sample""). We can remove doublets by either filtering out the cells called as doublets, or waiting until we’ve done a clustering pass and filtering out any clusters with high doublet scores. See also; Alternative methods for doublet detection within the scverse ecosystem are DoubletDetection and SOLO. You can read more about these in the Doublet Detection chapter of Single Cell Best Practices. ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering.html:13220,detect,detection,13220,en/stable/tutorials/basics/clustering.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering.html,4,['detect'],['detection']
Safety,"npy.external.pp.harmony_integrate; scanpy.external.pp.mnn_correct; scanpy.external.pp.scanorama_integrate; scanpy.external.pp.hashsolo; scanpy.external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .ipynb. .pdf. Preprocessing and clustering. Contents . Quality Control; Doublet detection. Normalization; Feature selection; Dimensionality Reduction; Nearest neighbor graph constuction and visualization; Clustering; Re-assess quality control and cell filtering; Manual cell-type annotation; Marker gene set; Differentially-expressed Genes as Markers. Preprocessing and clustering#. # Core scverse libraries; import scanpy as sc; import anndata as ad. # Data retrieval; import pooch. sc.settings.set_figure_params(dpi=50, facecolor=""white""). The data used in this basic preprocessing and clustering tutorial was collected from bone marrow mononuclear cells of healthy human donors and was part of openproblem’s NeurIPS 2021 benchmarking dataset [Luecken et al., 2021]. The samples used in this tutorial were measured using the 10X Multiome Gene Expression and Chromatin Accessability kit.; We are reading in the count matrix into an AnnData object, which holds many slots for annotations and different representations of the data. EXAMPLE_DATA = pooch.create(; path=pooch.",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering.html:9306,detect,detection,9306,en/stable/tutorials/basics/clustering.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering.html,2,['detect'],['detection']
Safety,"nts per cell; finished (0:00:00). Logarithmize the data:. sc.pp.log1p(adata). Identify highly-variable genes. sc.pp.highly_variable_genes(adata, min_mean=0.0125, max_mean=3, min_disp=0.5). extracting highly variable genes; finished (0:00:00); --> added; 'highly_variable', boolean vector (adata.var); 'means', float vector (adata.var); 'dispersions', float vector (adata.var); 'dispersions_norm', float vector (adata.var). sc.pl.highly_variable_genes(adata). Set the .raw attribute of the AnnData object to the normalized and logarithmized raw gene expression for later use in differential testing and visualizations of gene expression. This simply freezes the state of the AnnData object. Note; You can get back an AnnData of the object in .raw by calling .raw.to_adata(). adata.raw = adata. Note; If you don’t proceed below with correcting the data with sc.pp.regress_out and scaling it via sc.pp.scale, you can also get away without using .raw at all.; The result of the previous highly-variable-genes detection is stored as an annotation in .var.highly_variable and auto-detected by PCA and hence, sc.pp.neighbors and subsequent manifold/graph tools. In that case, the step actually do the filtering below is unnecessary, too. Actually do the filtering. adata = adata[:, adata.var.highly_variable]. Regress out effects of total counts per cell and the percentage of mitochondrial genes expressed. Scale the data to unit variance. sc.pp.regress_out(adata, [""total_counts"", ""pct_counts_mt""]). regressing out ['total_counts', 'pct_counts_mt']; sparse input is densified and may lead to high memory use; finished (0:00:02). Scale each gene to unit variance. Clip values exceeding standard deviation 10. sc.pp.scale(adata, max_value=10). Principal component analysis#; Reduce the dimensionality of the data by running principal component analysis (PCA), which reveals the main axes of variation and denoises the data. sc.tl.pca(adata, svd_solver=""arpack""). computing PCA; with n_comps=50; finished (0:",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering-2017.html:15056,detect,detection,15056,en/stable/tutorials/basics/clustering-2017.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering-2017.html,2,['detect'],['detection']
Safety,"nts', 'total_counts', 'log1p_total_counts'; uns: 'spatial'; obsm: 'spatial'. QC and preprocessing#; We perform some basic filtering of spots based on total counts and expressed genes. fig, axs = plt.subplots(1, 4, figsize=(15, 4)); sns.histplot(adata.obs[""total_counts""], kde=False, ax=axs[0]); sns.histplot(; adata.obs[""total_counts""][adata.obs[""total_counts""] < 10000],; kde=False,; bins=40,; ax=axs[1],; ); sns.histplot(adata.obs[""n_genes_by_counts""], kde=False, bins=60, ax=axs[2]); sns.histplot(; adata.obs[""n_genes_by_counts""][adata.obs[""n_genes_by_counts""] < 4000],; kde=False,; bins=60,; ax=axs[3],; ). <Axes: xlabel='n_genes_by_counts', ylabel='Count'>. sc.pp.filter_cells(adata, min_counts=5000); sc.pp.filter_cells(adata, max_counts=35000); adata = adata[adata.obs[""pct_counts_mt""] < 20].copy(); print(f""#cells after MT filter: {adata.n_obs}""); sc.pp.filter_genes(adata, min_cells=10). filtered out 44 cells that have less than 5000 counts; filtered out 130 cells that have more than 35000 counts; #cells after MT filter: 3861; filtered out 16916 genes that are detected in less than 10 cells. We proceed to normalize Visium counts data with the built-in normalize_total method from Scanpy, and detect highly-variable genes (for later). Note that there are alternatives for normalization (see discussion in [Luecken19], and more recent alternatives such as SCTransform or GLM-PCA). sc.pp.normalize_total(adata, inplace=True); sc.pp.log1p(adata); sc.pp.highly_variable_genes(adata, flavor=""seurat"", n_top_genes=2000). normalizing counts per cell; finished (0:00:00); extracting highly variable genes; finished (0:00:00); --> added; 'highly_variable', boolean vector (adata.var); 'means', float vector (adata.var); 'dispersions', float vector (adata.var); 'dispersions_norm', float vector (adata.var). Manifold embedding and clustering based on transcriptional similarity#; To embed and cluster the manifold encoded by transcriptional similarity, we proceed as in the standard clustering tut",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/basic-analysis.html:14764,detect,detected,14764,en/stable/tutorials/spatial/basic-analysis.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/basic-analysis.html,2,['detect'],['detected']
Safety,"opy bool (default: False)Return a copy or write to adata. kargs AnyAdditional arguments passed to find_partition() and the; constructor of the partition_type. Return type:; tuple[ndarray | None, spmatrix, float | None] | None. Returns:; Depending on copy, returns or updates adata with the following fields:. communities - ndarray (obs, dtype int)integer array of community assignments for each row in data. graph - spmatrix (obsp, dtype float)the graph that was used for clustering. Q - float (uns, dtype float)the modularity score for communities on graph. Example; >>> from anndata import AnnData; >>> import scanpy as sc; >>> import scanpy.external as sce; >>> import numpy as np; >>> import pandas as pd. With annotated data as input:; >>> adata = sc.datasets.pbmc3k(); >>> sc.pp.normalize_per_cell(adata). Then do PCA:; >>> sc.pp.pca(adata, n_comps=100). Compute phenograph clusters:; Louvain community detection; >>> sce.tl.phenograph(adata, clustering_algo=""louvain"", k=30). Leiden community detection; >>> sce.tl.phenograph(adata, clustering_algo=""leiden"", k=30). Return only Graph object; >>> sce.tl.phenograph(adata, clustering_algo=None, k=30). Now to show phenograph on tSNE (for example):; Compute tSNE:; >>> sc.tl.tsne(adata, random_state=7). Plot phenograph clusters on tSNE:; >>> sc.pl.tsne(; ... adata, color = [""pheno_louvain"", ""pheno_leiden""], s = 100,; ... palette = sc.pl.palettes.vega_20_scanpy, legend_fontsize = 10; ... ). Cluster and cluster centroids for input Numpy ndarray; >>> df = np.random.rand(1000, 40); >>> dframe = pd.DataFrame(df); >>> dframe.index, dframe.columns = (map(str, dframe.index), map(str, dframe.columns)); >>> adata = AnnData(dframe); >>> sc.pp.pca(adata, n_comps=20); >>> sce.tl.phenograph(adata, clustering_algo=""leiden"", k=50); >>> sc.tl.tsne(adata, random_state=1); >>> sc.pl.tsne(; ... adata, color=['pheno_leiden'], s=100,; ... palette=sc.pl.palettes.vega_20_scanpy, legend_fontsize=10; ... ). previous; scanpy.external.tl.sam. next; scanpy.exte",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.phenograph.html:13941,detect,detection,13941,en/stable/external/generated/scanpy.external.tl.phenograph.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.phenograph.html,2,['detect'],['detection']
Safety,"ors_within_batch=3, n_pcs=50, trim=None, annoy_n_trees=10, pynndescent_n_neighbors=30, pynndescent_random_state=0, use_faiss=True, set_op_mix_ratio=1.0, local_connectivity=1, **kwargs)[source]#; Batch balanced kNN [Polański et al., 2019].; Batch balanced kNN alters the kNN procedure to identify each cell’s top neighbours in; each batch separately instead of the entire cell pool with no accounting for batch.; The nearest neighbours for each batch are then merged to create a final list of; neighbours for the cell. Aligns batches in a quick and lightweight manner.; For use in the scanpy workflow as an alternative to neighbors(). Note; This is just a wrapper of bbknn.bbknn(): up to date docstring,; more information and bug reports there. Parameters:. adata AnnDataNeeds the PCA computed and stored in adata.obsm[""X_pca""]. batch_key str (default: 'batch')adata.obs column name discriminating between your batches. use_rep str (default: 'X_pca')The dimensionality reduction in .obsm to use for neighbour detection. Defaults to PCA. approx bool (default: True)If True, use approximate neighbour finding - annoy or PyNNDescent. This results; in a quicker run time for large datasets while also potentially increasing the degree of; batch correction. use_annoy bool (default: True)Only used when approx=True. If True, will use annoy for neighbour finding. If; False, will use pyNNDescent instead. metric Union[str, Callable, DistanceMetric] (default: 'euclidean')What distance metric to use. The options depend on the choice of neighbour algorithm.; ”euclidean”, the default, is always available.; Annoy supports “angular”, “manhattan” and “hamming”.; PyNNDescent supports metrics listed in pynndescent.distances.named_distances; and custom functions, including compiled Numba code.; >>> import pynndescent; >>> pynndescent.distances.named_distances.keys() ; dict_keys(['euclidean', 'l2', 'sqeuclidean', 'manhattan', 'taxicab', 'l1', 'chebyshev', 'linfinity',; 'linfty', 'linf', 'minkowski', 'seucli",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.bbknn.html:10452,detect,detection,10452,en/stable/generated/scanpy.external.pp.bbknn.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.bbknn.html,1,['detect'],['detection']
Safety,"orted; by how many batches they are a HVG. For dispersion-based flavors ties are broken; by normalized dispersion. For flavor = 'seurat_v3_paper', ties are broken by the median; (across batches) rank based on within-batch normalized variance. check_values bool (default: True)Check if counts in selected layer are integers. A Warning is returned if set to True.; Only used if flavor='seurat_v3'/'seurat_v3_paper'. Return type:; DataFrame | None. Returns:; Returns a pandas.DataFrame with calculated metrics if inplace=True, else returns an AnnData object where it sets the following field:. adata.var['highly_variable']pandas.Series (dtype bool)boolean indicator of highly-variable genes. adata.var['means']pandas.Series (dtype float)means per gene. adata.var['dispersions']pandas.Series (dtype float)For dispersion-based flavors, dispersions per gene. adata.var['dispersions_norm']pandas.Series (dtype float)For dispersion-based flavors, normalized dispersions per gene. adata.var['variances']pandas.Series (dtype float)For flavor='seurat_v3'/'seurat_v3_paper', variance per gene. adata.var['variances_norm']/'seurat_v3_paper'pandas.Series (dtype float)For flavor='seurat_v3'/'seurat_v3_paper', normalized variance per gene, averaged in; the case of multiple batches. adata.var['highly_variable_rank']pandas.Series (dtype float)For flavor='seurat_v3'/'seurat_v3_paper', rank of the gene according to normalized; variance, in case of multiple batches description above. adata.var['highly_variable_nbatches']pandas.Series (dtype int)If batch_key is given, this denotes in how many batches genes are detected as HVG. adata.var['highly_variable_intersection']pandas.Series (dtype bool)If batch_key is given, this denotes the genes that are highly variable in all batches. Notes; This function replaces filter_genes_dispersion(). previous; scanpy.pp.filter_genes. next; scanpy.pp.log1p. Contents; . highly_variable_genes(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.highly_variable_genes.html:15596,detect,detected,15596,en/stable/generated/scanpy.pp.highly_variable_genes.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.highly_variable_genes.html,1,['detect'],['detected']
Safety,"orting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.tl.dpt. Contents . dpt(). scanpy.tl.dpt#. scanpy.tl.dpt(adata, n_dcs=10, *, n_branchings=0, min_group_size=0.01, allow_kendall_tau_shift=True, neighbors_key=None, copy=False)[source]#; Infer progression of cells through geodesic distance along the graph; [Haghverdi et al., 2016, Wolf et al., 2019].; Reconstruct the progression of a biological process from snapshot; data. Diffusion Pseudotime has been introduced by Haghverdi et al. [2016] and; implemented within Scanpy [Wolf et al., 2018]. Here, we use a further developed; version, which is able to deal with disconnected graphs [Wolf et al., 2019] and can; be run in a hierarchical mode by setting the parameter; n_branchings>1. We recommend, however, to only use; dpt() for computing pseudotime (n_branchings=0) and; to detect branchings via paga(). For pseudotime, you need; to annotate your data with a root cell. For instance:; adata.uns['iroot'] = np.flatnonzero(adata.obs['cell_types'] == 'Stem')[0]. This requires to run neighbors(), first. In order to; reproduce the original implementation of DPT, use method=='gauss' in; this. Using the default method=='umap' only leads to minor quantitative; differences, though. Added in version 1.1. dpt() also requires to run; diffmap() first. As previously,; dpt() came with a default parameter of n_dcs=10 but; diffmap() has a default parameter of n_comps=15,; you need to pass n_comps=10 in diffmap() in order; to exactly reproduce previous dpt() results. Parameters:. adata AnnDataAnnotated data matrix. n_dcs int (default: 10)The number of diffusion components to use. n_branchings int (default: 0)Number of branchings to detect. min_group_size float (default: 0.01)During recursive splitting of branches (‘dpt groups’) for n_branchings",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.dpt.html:10006,detect,detect,10006,en/stable/generated/scanpy.tl.dpt.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.dpt.html,1,['detect'],['detect']
Safety,"oxon rank-sum,; 'logreg' uses logistic regression. See Ntranos et al. [2019],; here and here,; for why this is meaningful. corr_method Literal['benjamini-hochberg', 'bonferroni'] (default: 'benjamini-hochberg')p-value correction method.; Used only for 't-test', 't-test_overestim_var', and 'wilcoxon'. tie_correct bool (default: False)Use tie correction for 'wilcoxon' scores.; Used only for 'wilcoxon'. rankby_abs bool (default: False)Rank genes by the absolute value of the score, not by the; score. The returned scores are never the absolute values. pts bool (default: False)Compute the fraction of cells expressing the genes. key_added str | None (default: None)The key in adata.uns information is saved to. copy bool (default: False)Whether to copy adata or modify it inplace. kwdsAre passed to test methods. Currently this affects only parameters that; are passed to sklearn.linear_model.LogisticRegression.; For instance, you can pass penalty='l1' to try to come up with a; minimal set of genes that are good predictors (sparse solution meaning; few non-zero fitted coefficients). Return type:; AnnData | None. Returns:; Returns None if copy=False, else returns an AnnData object. Sets the following fields:. adata.uns['rank_genes_groups' | key_added]['names']structured numpy.ndarray (dtype object)Structured array to be indexed by group id storing the gene; names. Ordered according to scores. adata.uns['rank_genes_groups' | key_added]['scores']structured numpy.ndarray (dtype object)Structured array to be indexed by group id storing the z-score; underlying the computation of a p-value for each gene for each; group. Ordered according to scores. adata.uns['rank_genes_groups' | key_added]['logfoldchanges']structured numpy.ndarray (dtype object)Structured array to be indexed by group id storing the log2; fold change for each gene for each group. Ordered according to; scores. Only provided if method is ‘t-test’ like.; Note: this is an approximation calculated from mean-log values. ada",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.rank_genes_groups.html:11866,predict,predictors,11866,en/stable/generated/scanpy.tl.rank_genes_groups.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.rank_genes_groups.html,1,['predict'],['predictors']
Safety,"popular approximate nearest neighbor libraries.; Explicitly setting the transformer parameter allows customizing how this function behaves.; By default, for small datasets, Scanpy just calculates all distances.; Setting the transformer parameter to ""pynndescent"" makes Scanpy always use its default for large datasets. %timeit sc.pp.neighbors(adata_default, n_neighbors=15); %timeit sc.pp.neighbors(adata_pynnd, transformer=""pynndescent"", n_neighbors=15); %timeit sc.pp.neighbors(adata_annoy, transformer=AnnoyTransformer(15)). 29.3 ms ± 1.53 ms per loop (mean ± std. dev. of 7 runs, 1 loop each); 683 ms ± 28.9 ms per loop (mean ± std. dev. of 7 runs, 1 loop each); 50.1 ms ± 350 µs per loop (mean ± std. dev. of 7 runs, 10 loops each). Looks like Annoy is quite a bit faster than PyNNDescent (but of course not as fast as Scanpy’s brute-force shortcut on a small dataset like this).; Let’s see if Leidenalg and UMAP get reasonable results when using each of the kNN graphs. for adata in [adata_default, adata_annoy, adata_pynnd]:; sc.tl.leiden(adata, flavor=""igraph""); sc.tl.umap(adata). import matplotlib.pyplot as plt. with plt.ioff():; fig, axs = plt.subplots(1, 3, figsize=(18, 5), layout=""constrained""); sc.pl.umap(adata_default, color=""leiden"", ax=axs[0], show=False, title=""Default""); sc.pl.umap(adata_pynnd, color=""leiden"", ax=axs[1], show=False, title=""PyNNDescent""); sc.pl.umap(adata_annoy, color=""leiden"", ax=axs[2], show=False, title=""Annoy""); fig. The results look sensible enough.; Both embedding and community detection show some differences but are qualitatively the same:; The more narrow branch is divided into clusters length-wise, the wider one also horizontally,; and the small subpopulation is detected by both community detection and embedding.; This indicates that the underlying graph is similar enough to capture these features of the dataset. previous; How to. next; Plotting with Marsilea. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/how-to/knn-transformers.html:12025,detect,detection,12025,en/stable/how-to/knn-transformers.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/how-to/knn-transformers.html,3,['detect'],"['detected', 'detection']"
Safety,"return a warning if non-integers are found. Otherwise, proceed; without checking. Setting this to False can speed up code for large datasets. inplace bool (default: True)If True, update adata with results. Otherwise, return results. See below for; details of what is returned. Return type:; tuple[AnnData, DataFrame] | None. Returns:; If inplace=False, separately returns the gene selection results (as; DataFrame) and Pearson residual-based PCA results (as; AnnData). If inplace=True, updates adata with the; following fields for gene selection results:. .var['highly_variable']boolboolean indicator of highly-variable genes. .var['means']floatmeans per gene. .var['variances']floatvariances per gene. .var['residual_variances']floatPearson residual variance per gene. Averaged in the case of multiple; batches. .var['highly_variable_rank']floatRank of the gene according to residual variance, median rank in the; case of multiple batches. .var['highly_variable_nbatches']intIf batch_key is given, this denotes in how many batches genes are; detected as HVG. .var['highly_variable_intersection']boolIf batch_key is given, this denotes the genes that are highly variable; in all batches. The following fields contain Pearson residual-based PCA results and; normalization settings:. .uns['pearson_residuals_normalization']['pearson_residuals_df']The subset of highly variable genes, normalized by Pearson residuals. .uns['pearson_residuals_normalization']['theta']The used value of the overdisperion parameter theta. .uns['pearson_residuals_normalization']['clip']The used value of the clipping parameter. .obsm['X_pca']PCA representation of data after gene selection and Pearson residual; normalization. .varm['PCs']The principal components containing the loadings. When inplace=True this; will contain empty rows for the genes not selected during HVG selection. .uns['pca']['variance_ratio']Ratio of explained variance. .uns['pca']['variance']Explained variance, equivalent to the eigenvalues of the ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.recipe_pearson_residuals.html:12803,detect,detected,12803,en/stable/generated/scanpy.experimental.pp.recipe_pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.recipe_pearson_residuals.html,1,['detect'],['detected']
Safety,"rnal.pp.bbknn; scanpy.external.pp.harmony_integrate; scanpy.external.pp.mnn_correct; scanpy.external.pp.scanorama_integrate; scanpy.external.pp.hashsolo; scanpy.external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.pl.StackedViolin.savefig. Contents . StackedViolin.savefig(). scanpy.pl.StackedViolin.savefig#. StackedViolin.savefig(filename, bbox_inches='tight', **kwargs)[source]#; Save the current figure. Parameters:. filename strFigure filename. Figure format is taken from the file ending unless; the parameter format is given. bbox_inches str | None (default: 'tight')By default is set to ‘tight’ to avoid cropping of the legends. kwargsPassed to matplotlib.pyplot.savefig(). See also; render(): Renders the plot but does not call matplotlib.pyplot.show(); show(): Renders and shows the plot. Examples; >>> import scanpy as sc; >>> adata = sc.datasets.pbmc68k_reduced(); >>> markers = [""C1QA"", ""PSAP"", ""CD79A"", ""CD79B"", ""CST3"", ""LYZ""]; >>> sc.pl._baseplot_class.BasePlot(; ... adata, markers, groupby=""bulk_labels""; ... ).savefig(""plot.pdf""). previous; scanpy.pl.StackedViolin.make_figure. next; scanpy.pl.StackedViolin.show. Contents; . StackedViolin.savefig(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.savefig.html:9639,avoid,avoid,9639,en/stable/api/generated/classes/scanpy.pl.StackedViolin.savefig.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.StackedViolin.savefig.html,2,['avoid'],['avoid']
Safety,"rnal.pp.hashsolo; scanpy.external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.external.tl.cyclone. Contents . cyclone(). scanpy.external.tl.cyclone#. scanpy.external.tl.cyclone(adata, marker_pairs=None, *, iterations=1000, min_iter=100, min_pairs=50)[source]#; Assigns scores and predicted class to observations [Scialdone et al., 2015] [Fechtner, 2018].; Calculates scores for each observation and each phase and assigns prediction; based on marker pairs indentified by sandbag().; This reproduces the approach of Scialdone et al. [2015] in the implementation of; Fechtner [2018]. Parameters:. adata AnnDataThe annotated data matrix. marker_pairs Mapping[str, Collection[tuple[str, str]]] | None (default: None)Mapping of categories to lists of marker pairs.; See sandbag() output. iterations int (default: 1000)An integer scalar specifying the number of; iterations for random sampling to obtain a cycle score. min_iter int (default: 100)An integer scalar specifying the minimum number of iterations; for score estimation. min_pairs int (default: 50)An integer scalar specifying the minimum number of pairs; for score estimation. Return type:; DataFrame. Returns:; A DataFrame with samples as index and categories as columns; with scores for each ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.cyclone.html:9444,predict,predicted,9444,en/stable/external/generated/scanpy.external.tl.cyclone.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.cyclone.html,2,['predict'],['predicted']
Safety,"rst. In order to; reproduce the original implementation of DPT, use method=='gauss' in; this. Using the default method=='umap' only leads to minor quantitative; differences, though. Added in version 1.1. dpt() also requires to run; diffmap() first. As previously,; dpt() came with a default parameter of n_dcs=10 but; diffmap() has a default parameter of n_comps=15,; you need to pass n_comps=10 in diffmap() in order; to exactly reproduce previous dpt() results. Parameters:. adata AnnDataAnnotated data matrix. n_dcs int (default: 10)The number of diffusion components to use. n_branchings int (default: 0)Number of branchings to detect. min_group_size float (default: 0.01)During recursive splitting of branches (‘dpt groups’) for n_branchings; > 1, do not consider groups that contain less than min_group_size data; points. If a float, min_group_size refers to a fraction of the total; number of data points. allow_kendall_tau_shift bool (default: True)If a very small branch is detected upon splitting, shift away from; maximum correlation in Kendall tau criterion of Haghverdi et al. [2016] to; stabilize the splitting. neighbors_key str | None (default: None)If not specified, dpt looks .uns[‘neighbors’] for neighbors settings; and .obsp[‘connectivities’], .obsp[‘distances’] for connectivities and; distances respectively (default storage places for pp.neighbors).; If specified, dpt looks .uns[neighbors_key] for neighbors settings and; .obsp[.uns[neighbors_key][‘connectivities_key’]],; .obsp[.uns[neighbors_key][‘distances_key’]] for connectivities and distances; respectively. copy bool (default: False)Copy instance before computation and return a copy.; Otherwise, perform computation inplace and return None. Return type:; AnnData | None. Returns:; Returns None if copy=False, else returns an AnnData object. Sets the following fields (If n_branchings==0, no field adata.obs['dpt_groups'] will be written):. adata.obs['dpt_pseudotime']pandas.Series (dtype float)Array of dim (number of",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.dpt.html:11211,detect,detected,11211,en/stable/generated/scanpy.tl.dpt.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.tl.dpt.html,1,['detect'],['detected']
Safety,"s(adata_spatial_anterior, inplace=True); sc.pp.calculate_qc_metrics(adata_spatial_posterior, inplace=True). for name, adata in [; (""anterior"", adata_spatial_anterior),; (""posterior"", adata_spatial_posterior),; ]:; fig, axs = plt.subplots(1, 4, figsize=(12, 3)); fig.suptitle(f""Covariates for filtering: {name}""). sns.histplot(adata.obs[""total_counts""], kde=False, ax=axs[0]); sns.histplot(; adata.obs[""total_counts""][adata.obs[""total_counts""] < 20000],; kde=False,; bins=40,; ax=axs[1],; ); sns.histplot(adata.obs[""n_genes_by_counts""], kde=False, bins=60, ax=axs[2]); sns.histplot(; adata.obs[""n_genes_by_counts""][adata.obs[""n_genes_by_counts""] < 4000],; kde=False,; bins=60,; ax=axs[3],; ). sc.datasets.visium_sge downloads the filtered visium dataset, the output of spaceranger that contains only spots within the tissue slice. Indeed, looking at standard QC metrics we can observe that the samples do not contain empty spots.; We proceed to normalize Visium counts data with the built-in normalize_total method from Scanpy, and detect highly-variable genes (for later). As discussed previously, note that there are more sensible alternatives for normalization (see discussion in sc-tutorial paper and more recent alternatives such as SCTransform or GLM-PCA). for adata in [; adata_spatial_anterior,; adata_spatial_posterior,; ]:; sc.pp.normalize_total(adata, inplace=True); sc.pp.log1p(adata); sc.pp.highly_variable_genes(adata, flavor=""seurat"", n_top_genes=2000, inplace=True). normalizing counts per cell; finished (0:00:00); extracting highly variable genes; finished (0:00:00); --> added; 'highly_variable', boolean vector (adata.var); 'means', float vector (adata.var); 'dispersions', float vector (adata.var); 'dispersions_norm', float vector (adata.var); normalizing counts per cell; finished (0:00:00); extracting highly variable genes; finished (0:00:00); --> added; 'highly_variable', boolean vector (adata.var); 'means', float vector (adata.var); 'dispersions', float vector (adata.var)",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html:14867,detect,detect,14867,en/stable/tutorials/spatial/integration-scanorama.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/spatial/integration-scanorama.html,2,['detect'],['detect']
Safety,"s; 'LYZ', 'CD14', # CD14+ Monocytes; 'MS4A1', # B cells; 'CD8A', # CD8 T cells; 'GNLY', 'NKG7', # NK cells; 'FCGR3A', 'MS4A7', # FCGR3A+ Monocytes; 'FCER1A', 'CST3', # Dendritic Cells; 'PPBP'] # Megakaryocytes. A good gene selection should include these differentially expressed genes. # marker genes from table in pbmc3k tutorial; markers = [; ""IL7R"",; ""LYZ"",; ""CD14"",; ""MS4A1"",; ""CD8A"",; ""GNLY"",; ""NKG7"",; ""FCGR3A"",; ""MS4A7"",; ""FCER1A"",; ""CST3"",; ""PPBP"",; ]. Perform Quality control#; First, we remove cells and genes with few counts, then remove outlier cells. Parameters and thresholds are inspired from the PBMC3k tutorial. Basic filtering#. for adata in [adata_pbmc3k, adata_pbmc10k]:; adata.var_names_make_unique(); print(adata.uns[""name""], "": data shape:"", adata.shape); sc.pp.filter_cells(adata, min_genes=200); sc.pp.filter_genes(adata, min_cells=3). PBMC 3k (v1) : data shape: (2700, 32738); filtered out 19024 genes that are detected in less than 3 cells; PBMC 10k (v3) : data shape: (11769, 33538); filtered out 232 cells that have less than 200 genes expressed; filtered out 13246 genes that are detected in less than 3 cells. Compute quality control metrics#; We compute number of deteced genes per cell, total counts per cell and percentage of mitochondrial genes per cell. for adata in [adata_pbmc3k, adata_pbmc10k]:; adata.var[""mt""] = adata.var_names.str.startswith(""MT-""); sc.pp.calculate_qc_metrics(; adata, qc_vars=[""mt""], percent_top=None, log1p=False, inplace=True; ). Plot quality control metrics#; We plot all metrics and observe that both datasets have some outlier cells. for adata in [adata_pbmc3k, adata_pbmc10k]:; print(adata.uns[""name""], "":""); sc.pl.violin(; adata,; [""n_genes_by_counts"", ""total_counts"", ""pct_counts_mt""],; jitter=0.4,; multi_panel=True,; ). PBMC 3k (v1) :; PBMC 10k (v3) :. Based on these metrics, we define outlier cells and remove them. Afterwards, we make sure that all genes are at least detected once in the remaining cells. # define outliers and",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html:14593,detect,detected,14593,en/stable/tutorials/experimental/pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/pearson_residuals.html,4,['detect'],['detected']
Safety,"see below. It is potentially more faithful to the global connectivity of the manifold than tSNE, i.e., it better preserves trajectories. In some ocassions, you might still observe disconnected clusters and similar connectivity violations. They can usually be remedied by running:; sc.tl.paga(adata); sc.pl.paga(adata, plot=False) # remove `plot=False` if you want to see the coarse-grained graph; sc.tl.umap(adata, init_pos='paga'). sc.tl.umap(adata). computing UMAP; finished: added; 'X_umap', UMAP coordinates (adata.obsm) (0:00:03). sc.pl.umap(adata, color=[""CST3"", ""NKG7"", ""PPBP""]). As we set the .raw attribute of adata, the previous plots showed the “raw” (normalized, logarithmized, but uncorrected) gene expression. You can also plot the scaled and corrected gene expression by explicitly stating that you don’t want to use .raw. sc.pl.umap(adata, color=[""CST3"", ""NKG7"", ""PPBP""], use_raw=False). Clustering the neighborhood graph#; As with Seurat and many other frameworks, we recommend the Leiden graph-clustering method (community detection based on optimizing modularity) by Traag et al. (2018). Note that Leiden clustering directly clusters the neighborhood graph of cells, which we already computed in the previous section. sc.tl.leiden(; adata,; resolution=0.9,; random_state=0,; flavor=""igraph"",; n_iterations=2,; directed=False,; ). running Leiden clustering; finished: found 8 clusters and added; 'leiden', the cluster labels (adata.obs, categorical) (0:00:00). Plot the clusters, which agree quite well with the result of Seurat. sc.pl.umap(adata, color=[""leiden"", ""CST3"", ""NKG7""]). Save the result. adata.write(results_file). Finding marker genes#; Let us compute a ranking for the highly differential genes in each cluster. For this, by default, the .raw attribute of AnnData is used in case it has been initialized before. The simplest and fastest method to do so is the t-test. sc.tl.rank_genes_groups(adata, ""leiden"", method=""t-test""); sc.pl.rank_genes_groups(adata, n_genes=25,",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering-2017.html:18684,detect,detection,18684,en/stable/tutorials/basics/clustering-2017.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering-2017.html,2,['detect'],['detection']
Safety,"sing key=dendrogram_leiden_res_0.50). Running `sc.tl.dendrogram` with default parameters. For fine tuning it is recommended to run `sc.tl.dendrogram` independently. We can then use these genes to figure out what cell types we’re looking at. For example, Cluster 7 is expressing NKG7 and GNLY, suggesting these are NK cells.; To create your own plots, or use a more automated approach, the differentially expressed genes can be extracted in a convenient format with scanpy.get.rank_genes_groups_df(). sc.get.rank_genes_groups_df(adata, group=""7"").head(5). names; scores; logfoldchanges; pvals; pvals_adj. 0; NKG7; 35.376785; 6.544684; 3.885326e-274; 9.102153e-270. 1; KLRD1; 33.815022; 5.840619; 1.186288e-250; 1.389558e-246. 2; GNLY; 33.775005; 7.383827; 4.592379e-250; 3.586189e-246. 3; CST7; 33.003643; 5.238780; 7.201598e-239; 4.217796e-235. 4; PRF1; 32.752277; 5.397196; 2.817787e-235; 1.320246e-231. dc_cluster_genes = sc.get.rank_genes_groups_df(adata, group=""7"").head(5)[""names""]; sc.pl.umap(; adata,; color=[*dc_cluster_genes, ""leiden_res_0.50""],; legend_loc=""on data"",; frameon=False,; ncols=3,; ). You may have noticed that the p-values found here are extremely low. This is due to the statistical test being performed considering each cell as an independent sample. For a more conservative approach you may want to consider “pseudo-bulking” your data by sample (e.g. sc.get.aggregate(adata, by=[""sample"", ""cell_type""], func=""sum"", layer=""counts"")) and using a more powerful differential expression tool, like pydeseq2. previous; Basics. next; Preprocessing and clustering 3k PBMCs (legacy workflow). Contents; . Quality Control; Doublet detection. Normalization; Feature selection; Dimensionality Reduction; Nearest neighbor graph constuction and visualization; Clustering; Re-assess quality control and cell filtering; Manual cell-type annotation; Marker gene set; Differentially-expressed Genes as Markers. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering.html:25194,detect,detection,25194,en/stable/tutorials/basics/clustering.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering.html,2,['detect'],['detection']
Safety,"sing: PP; scanpy.external.pp.bbknn; scanpy.external.pp.harmony_integrate; scanpy.external.pp.mnn_correct; scanpy.external.pp.scanorama_integrate; scanpy.external.pp.hashsolo; scanpy.external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.pl.MatrixPlot.savefig. Contents . MatrixPlot.savefig(). scanpy.pl.MatrixPlot.savefig#. MatrixPlot.savefig(filename, bbox_inches='tight', **kwargs)[source]#; Save the current figure. Parameters:. filename strFigure filename. Figure format is taken from the file ending unless; the parameter format is given. bbox_inches str | None (default: 'tight')By default is set to ‘tight’ to avoid cropping of the legends. kwargsPassed to matplotlib.pyplot.savefig(). See also; render(): Renders the plot but does not call matplotlib.pyplot.show(); show(): Renders and shows the plot. Examples; >>> import scanpy as sc; >>> adata = sc.datasets.pbmc68k_reduced(); >>> markers = [""C1QA"", ""PSAP"", ""CD79A"", ""CD79B"", ""CST3"", ""LYZ""]; >>> sc.pl._baseplot_class.BasePlot(; ... adata, markers, groupby=""bulk_labels""; ... ).savefig(""plot.pdf""). previous; scanpy.pl.MatrixPlot.make_figure. next; scanpy.pl.MatrixPlot.show. Contents; . MatrixPlot.savefig(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.MatrixPlot.savefig.html:9624,avoid,avoid,9624,en/stable/api/generated/classes/scanpy.pl.MatrixPlot.savefig.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.MatrixPlot.savefig.html,2,['avoid'],['avoid']
Safety,"ssed or too many total counts by setting manual or automatic thresholds. However, sometimes what appears to be poor QC metrics can be driven by real biology so we suggest starting with a very permissive filtering strategy and revisiting it at a later point. We therefore now only filter cells with less than 100 genes expressed and genes that are detected in less than 3 cells.; Additionally, it is important to note that for datasets with multiple batches, quality control should be performed for each sample individually as quality control thresholds can very substantially between batches. sc.pp.filter_cells(adata, min_genes=100); sc.pp.filter_genes(adata, min_cells=3). Doublet detection#; As a next step, we run a doublet detection algorithm. Identifying doublets is crucial as they can lead to misclassifications or distortions in downstream analysis steps. Scanpy contains the doublet detection method Scrublet [Wolock et al., 2019]. Scrublet predicts cell doublets using a nearest-neighbor classifier of observed transcriptomes and simulated doublets. scanpy.pp.scrublet() adds doublet_score and predicted_doublet to .obs. One can now either filter directly on predicted_doublet or use the doublet_score later during clustering to filter clusters with high doublet scores. sc.pp.scrublet(adata, batch_key=""sample""). We can remove doublets by either filtering out the cells called as doublets, or waiting until we’ve done a clustering pass and filtering out any clusters with high doublet scores. See also; Alternative methods for doublet detection within the scverse ecosystem are DoubletDetection and SOLO. You can read more about these in the Doublet Detection chapter of Single Cell Best Practices. Normalization#; The next preprocessing step is normalization. A common approach is count depth scaling with subsequent log plus one (log1p) transformation. Count depth scaling normalizes the data to a “size factor” such as the median count depth in the dataset, ten thousand (CP10k) or one ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering.html:13488,predict,predicts,13488,en/stable/tutorials/basics/clustering.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering.html,2,['predict'],['predicts']
Safety,"st as tSNE,; in contrast to tSNE, UMAP directly embeds the single-cell graph and is faster;; UMAP is also used for measuring connectivities and computing neighbors,; see neighbors() A Wolf; graph abstraction: AGA is renamed to PAGA: paga(); now,; it only measures connectivities between partitions of the single-cell graph,; pseudotime and clustering need to be computed separately via; louvain() and dpt(), the; connectivity measure has been improved A Wolf; logistic regression for finding marker genes; rank_genes_groups() with parameter method='logreg' A Wolf; louvain() provides a better implementation for; reclustering via restrict_to A Wolf; scanpy no longer modifies rcParams upon import, call; settings.set_figure_params to set the ‘scanpy style’ A Wolf; default cache directory is ./cache/, set settings.cachedir to change; this; nested directories in this are avoided A Wolf; show edges in scatter plots based on graph visualization; draw_graph() and umap() by passing edges=True A Wolf; downsample_counts() for downsampling counts MD Luecken; default 'louvain_groups' are called 'louvain' A Wolf; 'X_diffmap' contains the zero component, plotting remains unchanged A Wolf. Version 0.4#. 0.4.4 2018-02-26#. embed cells using umap() [McInnes et al., 2018] pr92 G Eraslan; score sets of genes, e.g. for cell cycle, using score_genes() [Satija et al., 2015]:; notebook. 0.4.3 2018-02-09#. clustermap(): heatmap from hierarchical clustering,; based on seaborn.clustermap() [Waskom et al., 2016] A Wolf; only return matplotlib.axes.Axes in plotting functions of sc.pl; when show=False, otherwise None A Wolf. 0.4.2 2018-01-07#. amendments in PAGA and its plotting functions A Wolf. 0.4.0 2017-12-23#. export to SPRING [Weinreb et al., 2017] for interactive visualization of data:; spring tutorial S Wollock. Version 0.3#. 0.3.2 2017-11-29#. finding marker genes via rank_genes_groups_violin() improved,; see issue51 F Ramirez. 0.3.0 2017-11-16#. AnnData gains method concatenate() A Wolf; AnnD",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:50507,avoid,avoided,50507,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,1,['avoid'],['avoided']
Safety,"t. Parameters:. adata AnnDataThe annotated data matrix of shape n_obs × n_vars.; Rows correspond to cells and columns to genes. theta float (default: 100)The negative binomial overdispersion parameter theta for Pearson residuals.; Higher values correspond to less overdispersion (var = mean + mean^2/theta), and theta=np.inf corresponds to a Poisson model. clip float | None (default: None)Determines if and how residuals are clipped:. If None, residuals are clipped to the interval [-sqrt(n_obs), sqrt(n_obs)], where n_obs is the number of cells in the dataset (default behavior).; If any scalar c, residuals are clipped to the interval [-c, c]. Set clip=np.inf for no clipping. n_top_genes int (default: 1000)Number of highly-variable genes to keep. Mandatory if flavor='seurat_v3' or; flavor='pearson_residuals'. batch_key str | None (default: None)If specified, highly-variable genes are selected within each batch separately; and merged. This simple process avoids the selection of batch-specific genes; and acts as a lightweight batch correction method. Genes are first sorted by; how many batches they are a HVG. If flavor='pearson_residuals', ties are; broken by the median rank (across batches) based on within-batch residual; variance. chunksize int (default: 1000)If flavor='pearson_residuals', this dertermines how many genes are processed at; once while computing the residual variance. Choosing a smaller value will reduce; the required memory. n_comps int | None (default: 50)Number of principal components to compute in the PCA step. random_state float | None (default: 0)Random seed for setting the initial states for the optimization in the PCA step. kwargs_pca dict (default: {})Dictionary of further keyword arguments passed on to scanpy.pp.pca(). check_values bool (default: True)If True, checks if counts in selected layer are integers as expected by this; function, and return a warning if non-integers are found. Otherwise, proceed; without checking. Setting this to False can ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.recipe_pearson_residuals.html:10830,avoid,avoids,10830,en/stable/generated/scanpy.experimental.pp.recipe_pearson_residuals.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.experimental.pp.recipe_pearson_residuals.html,1,['avoid'],['avoids']
Safety,"tem page, release notes, tutorials overhaul pr960 pr966 A Wolf. Warning. changed default solver in pca() from auto to arpack; changed default use_raw in score_genes() from False to None. 1.4.4 2019-07-20#. New functionality#. scanpy.get adds helper functions for extracting data in convenient formats pr619 I Virshup. Bug fixes#. Stopped deprecations warnings from AnnData 0.6.22 I Virshup. Code design#. normalize_total() gains param exclude_highly_expressed, and fraction is renamed to max_fraction with better docs A Wolf. 1.4.3 2019-05-14#. Bug fixes#. neighbors() correctly infers n_neighbors again from params, which was temporarily broken in v1.4.2 I Virshup. Code design#. calculate_qc_metrics() is single threaded by default for datasets under 300,000 cells – allowing cached compilation pr615 I Virshup. 1.4.2 2019-05-06#. New functionality#. combat() supports additional covariates which may include adjustment variables or biological condition pr618 G Eraslan; highly_variable_genes() has a batch_key option which performs HVG selection in each batch separately to avoid selecting genes that vary strongly across batches pr622 G Eraslan. Bug fixes#. rank_genes_groups() t-test implementation doesn’t return NaN when variance is 0, also changed to scipy’s implementation pr621 I Virshup; umap() with init_pos='paga' detects correct dtype A Wolf; louvain() and leiden() auto-generate key_added=louvain_R upon passing restrict_to, which was temporarily changed in 1.4.1 A Wolf. Code design#. neighbors() and umap() got rid of UMAP legacy code and introduced UMAP as a dependency pr576 S Rybakov. 1.4.1 2019-04-26#. New functionality#. Scanpy has a command line interface again. Invoking it with scanpy somecommand [args] calls scanpy-somecommand [args], except for builtin commands (currently scanpy settings) pr604 P Angerer; ebi_expression_atlas() allows convenient download of EBI expression atlas I Virshup; marker_gene_overlap() computes overlaps of marker genes M Luecken; filter_rank_g",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:42467,avoid,avoid,42467,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,1,['avoid'],['avoid']
Safety,"ternal API; Preprocessing: PP; scanpy.external.pp.bbknn; scanpy.external.pp.harmony_integrate; scanpy.external.pp.mnn_correct; scanpy.external.pp.scanorama_integrate; scanpy.external.pp.hashsolo; scanpy.external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.pl.DotPlot.savefig. Contents . DotPlot.savefig(). scanpy.pl.DotPlot.savefig#. DotPlot.savefig(filename, bbox_inches='tight', **kwargs)[source]#; Save the current figure. Parameters:. filename strFigure filename. Figure format is taken from the file ending unless; the parameter format is given. bbox_inches str | None (default: 'tight')By default is set to ‘tight’ to avoid cropping of the legends. kwargsPassed to matplotlib.pyplot.savefig(). See also; render(): Renders the plot but does not call matplotlib.pyplot.show(); show(): Renders and shows the plot. Examples; >>> import scanpy as sc; >>> adata = sc.datasets.pbmc68k_reduced(); >>> markers = [""C1QA"", ""PSAP"", ""CD79A"", ""CD79B"", ""CST3"", ""LYZ""]; >>> sc.pl._baseplot_class.BasePlot(; ... adata, markers, groupby=""bulk_labels""; ... ).savefig(""plot.pdf""). previous; scanpy.pl.DotPlot.make_figure. next; scanpy.pl.DotPlot.show. Contents; . DotPlot.savefig(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.savefig.html:9609,avoid,avoid,9609,en/stable/api/generated/classes/scanpy.pl.DotPlot.savefig.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/classes/scanpy.pl.DotPlot.savefig.html,2,['avoid'],['avoid']
Safety,"th its own HDF5-based file format: .h5ad. adata = sc.read_10x_mtx(; ""data/filtered_gene_bc_matrices/hg19/"", # the directory with the `.mtx` file; var_names=""gene_symbols"", # use gene symbols for the variable names (variables-axis index); cache=True, # write a cache file for faster subsequent reading; ). ... reading from cache file cache/data-filtered_gene_bc_matrices-hg19-matrix.h5ad. Note; See anndata-tutorials/getting-started for a more comprehensive introduction to AnnData. adata.var_names_make_unique() # this is unnecessary if using `var_names='gene_ids'` in `sc.read_10x_mtx`. adata. AnnData object with n_obs × n_vars = 2700 × 32738; var: 'gene_ids'. Preprocessing#; Show those genes that yield the highest fraction of counts in each single cell, across all cells. sc.pl.highest_expr_genes(adata, n_top=20). normalizing counts per cell; finished (0:00:00). Basic filtering:. sc.pp.filter_cells(adata, min_genes=200); sc.pp.filter_genes(adata, min_cells=3). filtered out 19024 genes that are detected in less than 3 cells. Let’s assemble some information about mitochondrial genes, which are important for quality control.; Citing from “Simple Single Cell” workflows (Lun, McCarthy & Marioni, 2017):. High proportions are indicative of poor-quality cells (Islam et al. 2014; Ilicic et al. 2016), possibly because of loss of cytoplasmic RNA from perforated cells. The reasoning is that mitochondria are larger than individual transcript molecules and less likely to escape through tears in the cell membrane. With pp.calculate_qc_metrics, we can compute many metrics very efficiently. # annotate the group of mitochondrial genes as ""mt""; adata.var[""mt""] = adata.var_names.str.startswith(""MT-""); sc.pp.calculate_qc_metrics(; adata, qc_vars=[""mt""], percent_top=None, log1p=False, inplace=True; ). A violin plot of some of the computed quality measures:. the number of genes expressed in the count matrix; the total counts per cell; the percentage of counts in mitochondrial genes. sc.pl.violin",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering-2017.html:12365,detect,detected,12365,en/stable/tutorials/basics/clustering-2017.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering-2017.html,2,['detect'],['detected']
Safety,"xternal.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.external.tl.harmony_timeseries. Contents . harmony_timeseries(). scanpy.external.tl.harmony_timeseries#. scanpy.external.tl.harmony_timeseries(adata, tp, *, n_neighbors=30, n_components=1000, n_jobs=-2, copy=False)[source]#; Harmony time series for data visualization with augmented affinity matrix; at discrete time points [Nowotschin et al., 2019].; Harmony time series is a framework for data visualization, trajectory; detection and interpretation for scRNA-seq data measured at discrete; time points. Harmony constructs an augmented affinity matrix by augmenting; the kNN graph affinity matrix with mutually nearest neighbors between; successive time points. This augmented affinity matrix forms the basis for; generated a force directed layout for visualization and also serves as input; for computing the diffusion operator which can be used for trajectory; detection using Palantir. Note; More information and bug reports here. Parameters:. adata AnnDataAnnotated data matrix of shape n_obs × n_vars. Rows correspond to; cells and columns to genes. Rows represent two or more time points,; where replicates of the same time point are consecutive in order. tp strkey name of observation annotation .obs representing time points. Time; points should be categorical of dtype=category. The unique categories for; the categorical will be used as the time points to construct the timepoint; connections. n_neighbors int (default: 30)Number of nearest neighbors for graph construction. n_components int | None (default: 1000)Minimum number of principal components to use. Specify None to use; pre-computed components. The higher the value the better to capture 85% of the; variance. n_jobs int (default: -2)Nearest Neighbors will be computed in parallel using n_jobs. copy boo",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.harmony_timeseries.html:10118,detect,detection,10118,en/stable/external/generated/scanpy.external.tl.harmony_timeseries.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/generated/scanpy.external.tl.harmony_timeseries.html,2,['detect'],['detection']
Safety,"y substantially between batches. sc.pp.filter_cells(adata, min_genes=100); sc.pp.filter_genes(adata, min_cells=3). Doublet detection#; As a next step, we run a doublet detection algorithm. Identifying doublets is crucial as they can lead to misclassifications or distortions in downstream analysis steps. Scanpy contains the doublet detection method Scrublet [Wolock et al., 2019]. Scrublet predicts cell doublets using a nearest-neighbor classifier of observed transcriptomes and simulated doublets. scanpy.pp.scrublet() adds doublet_score and predicted_doublet to .obs. One can now either filter directly on predicted_doublet or use the doublet_score later during clustering to filter clusters with high doublet scores. sc.pp.scrublet(adata, batch_key=""sample""). We can remove doublets by either filtering out the cells called as doublets, or waiting until we’ve done a clustering pass and filtering out any clusters with high doublet scores. See also; Alternative methods for doublet detection within the scverse ecosystem are DoubletDetection and SOLO. You can read more about these in the Doublet Detection chapter of Single Cell Best Practices. Normalization#; The next preprocessing step is normalization. A common approach is count depth scaling with subsequent log plus one (log1p) transformation. Count depth scaling normalizes the data to a “size factor” such as the median count depth in the dataset, ten thousand (CP10k) or one million (CPM, counts per million). The size factor for count depth scaling can be controlled via target_sum in pp.normalize_total. We are applying median count depth normalization with log1p transformation (AKA log1PF). # Saving count data; adata.layers[""counts""] = adata.X.copy(). # Normalizing to median total counts; sc.pp.normalize_total(adata); # Logarithmize the data; sc.pp.log1p(adata). Feature selection#; As a next step, we want to reduce the dimensionality of the dataset and only include the most informative genes. This step is commonly known as ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering.html:14084,detect,detection,14084,en/stable/tutorials/basics/clustering.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering.html,2,['detect'],['detection']
Security," plotting functions#; Author: Fidel Ramírez; This tutorial explores the visualization possibilities of scanpy and is divided into three sections:. Scatter plots for embeddings (eg. UMAP, t-SNE); Identification of clusters using known marker genes; Visualization of differentially expressed genes. In this tutorial, we will use a dataset from 10x containing 68k cells from PBMC. Scanpy, includes in its distribution a reduced sample of this dataset consisting of only 700 cells and 765 highly variable genes. This dataset has been already preprocessed and UMAP computed.; In this tutorial, we will also use the following literature markers:. B-cell: CD79A, MS4A1; Plasma: IGJ (JCHAIN); T-cell: CD3D; NK: GNLY, NKG7; Myeloid: CST3, LYZ; Monocytes: FCGR3A; Dendritic: FCER1A. Scatter plots for embeddings#; With scanpy, scatter plots for tSNE, UMAP and several other embeddings are readily available using the sc.pl.tsne, sc.pl.umap etc. functions. See here the list of options.; Those functions access the data stored in adata.obsm. For example sc.pl.umap uses the information stored in adata.obsm['X_umap']. For more flexibility, any key stored in adata.obsm can be used with the generic function sc.pl.embedding. import scanpy as sc; from matplotlib.pyplot import rc_context. sc.set_figure_params(dpi=100, color_map=""viridis_r""); sc.settings.verbosity = 0; sc.logging.print_header(). scanpy==1.10.0rc2.dev6+g14555ba4.d20240226 anndata==0.11.0.dev78+g64ab900 umap==0.5.5 numpy==1.26.3 scipy==1.11.4 pandas==2.2.0 scikit-learn==1.3.2 statsmodels==0.14.1 igraph==0.10.8 pynndescent==0.5.11. Load pbmc dataset#. pbmc = sc.datasets.pbmc68k_reduced(). # inspect pbmc contents; pbmc. AnnData object with n_obs × n_vars = 700 × 765; obs: 'bulk_labels', 'n_genes', 'percent_mito', 'n_counts', 'S_score', 'G2M_score', 'phase', 'louvain'; var: 'n_counts', 'means', 'dispersions', 'dispersions_norm', 'highly_variable'; uns: 'bulk_labels_colors', 'louvain', 'louvain_colors', 'neighbors', 'pca', 'rank_genes_grou",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/core.html:10894,access,access,10894,en/stable/tutorials/plotting/core.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/core.html,2,['access'],['access']
Security," scanpy.external.pp.scanorama_integrate; scanpy.external.pp.hashsolo; scanpy.external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.external.pp.hashsolo. Contents . hashsolo(). scanpy.external.pp.hashsolo#. scanpy.external.pp.hashsolo(adata, cell_hashing_columns, *, priors=(0.01, 0.8, 0.19), pre_existing_clusters=None, number_of_noise_barcodes=None, inplace=True)[source]#; Probabilistic demultiplexing of cell hashing data using HashSolo [Bernstein et al., 2020]. Note; More information and bug reports here. Parameters:. adata AnnDataThe (annotated) data matrix of shape n_obs × n_vars.; Rows correspond to cells and columns to genes. cell_hashing_columns Sequence[str].obs columns that contain cell hashing counts. priors tuple[float, float, float] (default: (0.01, 0.8, 0.19))Prior probabilities of each hypothesis, in; the order [negative, singlet, doublet]. The default is set to; [0.01, 0.8, 0.19] assuming barcode counts are from cells that; have passed QC in the transcriptome space, e.g. UMI counts, pct; mito reads, etc. pre_existing_clusters str | None (default: None)The column in .obs containing pre-existing cluster assignments; (e.g. Leiden clusters or cell types, but not batch assignments).; If provided, demultiplexing will be perf",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.hashsolo.html:9337,hash,hashsolo,9337,en/stable/generated/scanpy.external.pp.hashsolo.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.hashsolo.html,1,['hash'],['hashsolo']
Security,"(default: 'X_pca')The name of the field in adata.obsm where the PCA table is; stored. Defaults to 'X_pca', which is the default for; sc.pp.pca(). adjusted_basis str (default: 'X_scanorama')The name of the field in adata.obsm where the integrated; embeddings will be stored after running this function. Defaults; to X_scanorama. knn int (default: 20)Number of nearest neighbors to use for matching. sigma float (default: 15)Correction smoothing parameter on Gaussian kernel. approx bool (default: True)Use approximate nearest neighbors with Python annoy;; greatly speeds up matching runtime. alpha float (default: 0.1)Alignment score minimum cutoff. batch_size int (default: 5000)The batch size used in the alignment vector computation. Useful; when integrating very large (>100k samples) datasets. Set to; large value that runs within available memory. kwargsAny additional arguments will be passed to; scanorama.assemble(). Return type:; None. Returns:; Updates adata with the field adata.obsm[adjusted_basis],; containing Scanorama embeddings such that different experiments; are integrated. Example; First, load libraries and example dataset, and preprocess.; >>> import scanpy as sc; >>> import scanpy.external as sce; >>> adata = sc.datasets.pbmc3k(); >>> sc.pp.recipe_zheng17(adata); >>> sc.pp.pca(adata). We now arbitrarily assign a batch metadata variable to each cell; for the sake of example, but during real usage there would already; be a column in adata.obs giving the experiment each cell came; from.; >>> adata.obs['batch'] = 1350*['a'] + 1350*['b']. Finally, run Scanorama. Afterwards, there will be a new table in; adata.obsm containing the Scanorama embeddings.; >>> sce.pp.scanorama_integrate(adata, 'batch', verbose=1); Processing datasets a <=> b; >>> 'X_scanorama' in adata.obsm; True. previous; scanpy.external.pp.mnn_correct. next; scanpy.external.pp.hashsolo. Contents; . scanorama_integrate(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.scanorama_integrate.html:12030,hash,hashsolo,12030,en/stable/generated/scanpy.external.pp.scanorama_integrate.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.scanorama_integrate.html,1,['hash'],['hashsolo']
Security,. scanpy.external.pp.hashsolo — scanpy. Skip to main content. Back to top. Ctrl+K. Installation; Tutorials; Basics; Preprocessing and clustering; Preprocessing and clustering 3k PBMCs (legacy workflow); Integrating data using ingest and BBKNN. Plotting; Core plotting functions; Customizing Scanpy plots. Trajectories; Trajectory inference for hematopoiesis in mouse. Spatial; Analysis and visualization of spatial transcriptomics data; Integrating spatial data with scRNA-seq using scanorama. Experimental; How to preprocess UMI count data with analytic Pearson residuals; Using dask with Scanpy. Usage Principles; How to; Using other kNN libraries in Scanpy; Plotting with Marsilea. API; Preprocessing: pp; scanpy.pp.calculate_qc_metrics; scanpy.pp.filter_cells; scanpy.pp.filter_genes; scanpy.pp.highly_variable_genes; scanpy.pp.log1p; scanpy.pp.pca; scanpy.pp.normalize_total; scanpy.pp.regress_out; scanpy.pp.scale; scanpy.pp.subsample; scanpy.pp.downsample_counts; scanpy.pp.recipe_zheng17; scanpy.pp.recipe_weinreb17; scanpy.pp.recipe_seurat; scanpy.pp.combat; scanpy.pp.scrublet; scanpy.pp.scrublet_simulate_doublets; scanpy.pp.neighbors. Tools: tl; scanpy.pp.pca; scanpy.tl.tsne; scanpy.tl.umap; scanpy.tl.draw_graph; scanpy.tl.diffmap; scanpy.tl.embedding_density; scanpy.tl.leiden; scanpy.tl.louvain; scanpy.tl.dendrogram; scanpy.tl.dpt; scanpy.tl.paga; scanpy.tl.ingest; scanpy.tl.rank_genes_groups; scanpy.tl.filter_rank_genes_groups; scanpy.tl.marker_gene_overlap; scanpy.tl.score_genes; scanpy.tl.score_genes_cell_cycle; scanpy.tl.sim. Plotting: pl; scanpy.pl.scatter; scanpy.pl.heatmap; scanpy.pl.dotplot; scanpy.pl.tracksplot; scanpy.pl.violin; scanpy.pl.stacked_violin; scanpy.pl.matrixplot; scanpy.pl.clustermap; scanpy.pl.ranking; scanpy.pl.dendrogram; scanpy.pl.DotPlot; scanpy.pl.DotPlot.DEFAULT_CATEGORY_HEIGHT; scanpy.pl.DotPlot.DEFAULT_CATEGORY_WIDTH; scanpy.pl.DotPlot.DEFAULT_COLORMAP; scanpy.pl.DotPlot.DEFAULT_COLOR_LEGEND_TITLE; scanpy.pl.DotPlot.DEFAULT_COLOR_ON; scanpy,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.hashsolo.html:21,hash,hashsolo,21,en/stable/generated/scanpy.external.pp.hashsolo.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.hashsolo.html,1,['hash'],['hashsolo']
Security,".tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.external.pp.hashsolo. Contents . hashsolo(). scanpy.external.pp.hashsolo#. scanpy.external.pp.hashsolo(adata, cell_hashing_columns, *, priors=(0.01, 0.8, 0.19), pre_existing_clusters=None, number_of_noise_barcodes=None, inplace=True)[source]#; Probabilistic demultiplexing of cell hashing data using HashSolo [Bernstein et al., 2020]. Note; More information and bug reports here. Parameters:. adata AnnDataThe (annotated) data matrix of shape n_obs × n_vars.; Rows correspond to cells and columns to genes. cell_hashing_columns Sequence[str].obs columns that contain cell hashing counts. priors tuple[float, float, float] (default: (0.01, 0.8, 0.19))Prior probabilities of each hypothesis, in; the order [negative, singlet, doublet]. The default is set to; [0.01, 0.8, 0.19] assuming barcode counts are from cells that; have passed QC in the transcriptome space, e.g. UMI counts, pct; mito reads, etc. pre_existing_clusters str | None (default: None)The column in .obs containing pre-existing cluster assignments; (e.g. Leiden clusters or cell types, but not batch assignments).; If provided, demultiplexing will be performed separately for each; cluster. number_of_noise_barcodes int | None (default: None)The number of barcodes used to create the noise distribution.; Defaults to len(cell_hashing_columns) - 2. inplace bool (default: True)Whether to update adata in-place or return a copy. Return type:; AnnData | None. Returns:; A copy of the input adata if inplace=False, otherwise the input; adata. The following fields are added:. .obs[""most_likely_hypothesis",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.hashsolo.html:9815,hash,hashing,9815,en/stable/generated/scanpy.external.pp.hashsolo.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.hashsolo.html,1,['hash'],['hashing']
Security,"3; . Dashboard: http://127.0.0.1:8787/status. Total threads: 18; . Started: Just now; . Total memory: 128.00 GiB; . Workers. . Worker: 0. Comm: tcp://127.0.0.1:36805; . Total threads: 6; . Dashboard: http://127.0.0.1:45909/status. Memory: 42.67 GiB; . Nanny: tcp://127.0.0.1:39225; . Local directory: /tmp/dask-scratch-space/worker-pz4wcxmk; . . Worker: 1. Comm: tcp://127.0.0.1:35183; . Total threads: 6; . Dashboard: http://127.0.0.1:43387/status. Memory: 42.67 GiB; . Nanny: tcp://127.0.0.1:42555; . Local directory: /tmp/dask-scratch-space/worker-a11nkkx1; . . Worker: 2. Comm: tcp://127.0.0.1:36599; . Total threads: 6; . Dashboard: http://127.0.0.1:39033/status. Memory: 42.67 GiB; . Nanny: tcp://127.0.0.1:45463; . Local directory: /tmp/dask-scratch-space/worker-mcr71xvg; . We’ll convert the X representation to dask using anndata.experimental.read_elem_as_dask.; The file we’ve retrieved from cellxgene has already been processed. Since this tutorial is demonstrating processing from counts, we’re just going to access the counts matrix and annotations. %%time; with h5py.File(""cell_atlas.h5ad"", ""r"") as f:; adata = ad.AnnData(; obs=ad.experimental.read_elem(f[""obs""]),; var=ad.experimental.read_elem(f[""var""]),; ); adata.X = ad.experimental.read_elem_as_dask(; f[""raw/X""], chunks=(SPARSE_CHUNK_SIZE, adata.shape[1]); ). CPU times: user 2.4 s, sys: 673 ms, total: 3.08 s; Wall time: 3.22 s. We’ve optimized a number of scanpy functions to be completely lazy. That means it will look like nothing is computed when you call an operation on a dask array, but only later when you hit compute.; In some cases it’s currently unavoidable to skip all computation, and these cases will kick off compute for all the delayed operations immediately. %%time; adata.layers[""counts""] = adata.X.copy() # Making sure we keep access to the raw counts; sc.pp.normalize_total(adata, target_sum=1e4). CPU times: user 7.1 ms, sys: 31 μs, total: 7.13 ms; Wall time: 7.49 ms. %%time; sc.pp.log1p(adata). CPU times: u",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/dask.html:13793,access,access,13793,en/stable/tutorials/experimental/dask.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/experimental/dask.html,2,['access'],['access']
Security,"I Virshup. Ecosystem#; Multiple packages have been added to our ecosystem page, including:. decoupler a for footprint analysis and pathway enrichement pr2186 PB Mompel; dandelion for B-cell receptor analysis pr1953 Z Tuong; CIARA a feature selection tools for identifying rare cell types pr2175 M Stock. Bug fixes#. Fixed finding variables with use_raw=True and basis=None in scanpy.pl.scatter() pr2027 E Rice; Fixed scanpy.pp.scrublet() to address issue1957 FlMai and ensure raw counts are used for simulation; Functions in scanpy.datasets no longer throw OldFormatWarnings when using anndata 0.8 pr2096 I Virshup; Fixed use of scanpy.pp.neighbors() with method='rapids': RAPIDS cuML no longer returns a squared Euclidean distance matrix, so we should not square-root the kNN distance matrix. pr1828 M Zaslavsky; Removed pytables dependency by implementing read_10x_h5 with h5py due to installation errors on Windows pr2064; Fixed bug in scanpy.external.pp.hashsolo() where default value was set improperly pr2190 B Reiz; Fixed bug in scanpy.pl.embedding() functions where an error could be raised when there were missing values and large numbers of categories pr2187 I Virshup. Version 1.8#. 1.8.2 2021-11-3#. Documentation#. Update conda installation instructions pr1974 L Heumos. Bug fixes#. Fix plotting after scanpy.tl.filter_rank_genes_groups() pr1942 S Rybakov; Fix use_raw=None using anndata.AnnData.var_names if anndata.AnnData.raw; is present in scanpy.tl.score_genes() pr1999 M Klein; Fix compatibility with UMAP 0.5.2 pr2028 L Mcinnes; Fixed non-determinism in scanpy.pl.paga() node positions pr1922 I Virshup. Ecosystem#. Added PASTE (a tool to align and integrate spatial transcriptomics data) to scanpy ecosystem. 1.8.1 2021-07-07#. Bug fixes#. Fixed reproducibility of scanpy.tl.score_genes(). Calculation and output is now float64 type. pr1890 I Kucinski; Workarounds for some changes/ bugs in pandas 1.3 pr1918 I Virshup; Fixed bug where sc.pl.paga_compare could mislabel nodes on t",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/release-notes/index.html:24891,hash,hashsolo,24891,en/stable/release-notes/index.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/release-notes/index.html,1,['hash'],['hashsolo']
Security,"anpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .md. .pdf. Preprocessing: PP. Contents . Data integration; Sample demultiplexing; Imputation. Preprocessing: PP#. Data integration#. pp.bbknn(adata, *[, batch_key, use_rep, ...]); Batch balanced kNN [Polański et al., 2019]. pp.harmony_integrate(adata, key, *[, basis, ...]); Use harmonypy [Korsunsky et al., 2019] to integrate different experiments. pp.mnn_correct(*datas[, var_index, ...]); Correct batch effects by matching mutual nearest neighbors [Haghverdi et al., 2018] [Kang, 2018]. pp.scanorama_integrate(adata, key, *[, ...]); Use Scanorama [Hie et al., 2019] to integrate different experiments. Sample demultiplexing#. pp.hashsolo(adata, cell_hashing_columns, *); Probabilistic demultiplexing of cell hashing data using HashSolo [Bernstein et al., 2020]. Imputation#; Note that the fundamental limitations of imputation are still under debate. pp.dca(adata[, mode, ae_type, ...]); Deep count autoencoder [Eraslan et al., 2019]. pp.magic(adata[, name_list, knn, decay, ...]); Markov Affinity-based Graph Imputation of Cells (MAGIC) API [van Dijk et al., 2018]. previous; External API. next; scanpy.external.pp.bbknn. Contents; . Data integration; Sample demultiplexing; Imputation. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/external/preprocessing.html:9846,hash,hashsolo,9846,en/stable/external/preprocessing.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/external/preprocessing.html,2,['hash'],"['hashing', 'hashsolo']"
Security,"anpyConfig.file_format_figs; scanpy._settings.ScanpyConfig.logfile; scanpy._settings.ScanpyConfig.logpath; scanpy._settings.ScanpyConfig.max_memory; scanpy._settings.ScanpyConfig.n_jobs; scanpy._settings.ScanpyConfig.plot_suffix; scanpy._settings.ScanpyConfig.verbosity; scanpy._settings.ScanpyConfig.writedir; scanpy._settings.ScanpyConfig.N_PCS; scanpy._settings.ScanpyConfig.set_figure_params. scanpy.logging.print_header; scanpy.logging.print_versions. Datasets; scanpy.datasets.blobs; scanpy.datasets.ebi_expression_atlas; scanpy.datasets.krumsiek11; scanpy.datasets.moignard15; scanpy.datasets.pbmc3k; scanpy.datasets.pbmc3k_processed; scanpy.datasets.pbmc68k_reduced; scanpy.datasets.paul15; scanpy.datasets.toggleswitch; scanpy.datasets.visium_sge. Deprecated functions; scanpy.pp.filter_genes_dispersion; scanpy.pp.normalize_per_cell. External API; Preprocessing: PP; scanpy.external.pp.bbknn; scanpy.external.pp.harmony_integrate; scanpy.external.pp.mnn_correct; scanpy.external.pp.scanorama_integrate; scanpy.external.pp.hashsolo; scanpy.external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. Search. Error; Please activate JavaScript to enable the search functionality. Ctrl+K. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/search.html:8401,hash,hashsolo,8401,en/stable/search.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/search.html,1,['hash'],['hashsolo']
Security,"ber of threads to use in training. All cores are used by default. learning_rate float | None (default: None)Learning rate to use in the training. verbose bool (default: False)If true, prints additional information about training and architecture. training_kwds Mapping[str, Any] (default: mappingproxy({}))Additional keyword arguments for the training process. return_model bool (default: False)If true, trained autoencoder object is returned. See “Returns”. return_info bool (default: False)If true, all additional parameters of DCA are stored in adata.obsm such as dropout; probabilities (obsm[‘X_dca_dropout’]) and estimated dispersion values; (obsm[‘X_dca_dispersion’]), in case that autoencoder is of type; zinb or zinb-conddisp. copy bool (default: False)If true, a copy of anndata is returned. Return type:; AnnData | None. Returns:; If copy is true and return_model is false, AnnData object is returned.; In “denoise” mode, adata.X is overwritten with the denoised values.; In “latent” mode, latent low dimensional representation of cells are stored; in adata.obsm['X_dca'] and adata.X is not modified.; Note that these values are not corrected for library size effects.; If return_info is true, all estimated distribution parameters are stored; in AnnData like this:. .obsm[""X_dca_dropout""]The mixture coefficient (pi) of the zero component in ZINB,; i.e. dropout probability (if ae_type is zinb or zinb-conddisp). .obsm[""X_dca_dispersion""]The dispersion parameter of NB. .uns[""dca_loss_history""]The loss history of the training.; See .history attribute of Keras History class for mode details. Finally, the raw counts are stored in .raw attribute of AnnData object.; If return_model is given, trained model is returned.; When both copy and return_model are true,; a tuple of anndata and model is returned in that order. previous; scanpy.external.pp.hashsolo. next; scanpy.external.pp.magic. Contents; . dca(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.dca.html:14409,hash,hashsolo,14409,en/stable/generated/scanpy.external.pp.dca.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.dca.html,1,['hash'],['hashsolo']
Security,canpy; scanpy.datasets.ebi_expression_atlas — scanpy; scanpy.datasets.krumsiek11 — scanpy; scanpy.datasets.moignard15 — scanpy; scanpy.datasets.paul15 — scanpy; scanpy.datasets.pbmc3k — scanpy; scanpy.datasets.pbmc3k_processed — scanpy; scanpy.datasets.pbmc68k_reduced — scanpy; scanpy.datasets.toggleswitch — scanpy; scanpy.datasets.visium_sge — scanpy; scanpy.experimental.pp.highly_variable_genes — scanpy; scanpy.experimental.pp.normalize_pearson_residuals — scanpy; scanpy.experimental.pp.normalize_pearson_residuals_pca — scanpy; scanpy.experimental.pp.recipe_pearson_residuals — scanpy; scanpy.external.exporting.cellbrowser — scanpy; scanpy.external.exporting.spring_project — scanpy; scanpy.external.pl.phate — scanpy; scanpy.external.pl.sam — scanpy; scanpy.external.pl.trimap — scanpy; scanpy.external.pl.wishbone_marker_trajectory — scanpy; scanpy.external.pp.bbknn — scanpy; scanpy.external.pp.dca — scanpy; scanpy.external.pp.harmony_integrate — scanpy; scanpy.external.pp.hashsolo — scanpy; scanpy.external.pp.magic — scanpy; scanpy.external.pp.mnn_correct — scanpy; scanpy.external.pp.scanorama_integrate — scanpy; scanpy.get.aggregate — scanpy; scanpy.get.obs_df — scanpy; scanpy.get.rank_genes_groups_df — scanpy; scanpy.get.var_df — scanpy; scanpy.logging.print_header — scanpy; scanpy.logging.print_versions — scanpy; scanpy.metrics.confusion_matrix — scanpy; scanpy.metrics.gearys_c — scanpy; scanpy.metrics.morans_i — scanpy; scanpy.Neighbors.compute_eigen — scanpy; scanpy.Neighbors.compute_neighbors — scanpy; scanpy.Neighbors.compute_transitions — scanpy; scanpy.Neighbors.connectivities — scanpy; scanpy.Neighbors.distances — scanpy; scanpy.Neighbors.distances_dpt — scanpy; scanpy.Neighbors.eigen_basis — scanpy; scanpy.Neighbors.eigen_values — scanpy; scanpy.Neighbors.getdoc — scanpy; scanpy.Neighbors — scanpy; scanpy.Neighbors.rp_forest — scanpy; scanpy.Neighbors.to_igraph — scanpy; scanpy.Neighbors.transitions — scanpy; scanpy.Neighbors.transitions_sym — scanpy; sca,MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/index-wcopy.html:19247,hash,hashsolo,19247,index-wcopy.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/index-wcopy.html,1,['hash'],['hashsolo']
Security,"data using UMAP. where adata is an AnnData object.; Each of these calls adds annotation to an expression matrix X,; which stores n_obs observations (cells) of n_vars variables (genes).; For each tool, there typically is an associated plotting function in sc.pl:; sc.pl.umap(adata, **plotting_params). If you pass show=False, a Axes instance is returned; and you have all of matplotlib’s detailed configuration possibilities.; To facilitate writing memory-efficient pipelines, by default,; Scanpy tools operate inplace on adata and return None –; this also allows to easily transition to out-of-memory pipelines.; If you want to return a copy of the AnnData object; and leave the passed adata unchanged, pass copy=True or inplace=False. AnnData#; Scanpy is based on anndata, which provides the AnnData class. At the most basic level, an AnnData object adata stores; a data matrix adata.X, annotation of observations; adata.obs and variables adata.var as pd.DataFrame and unstructured; annotation adata.uns as dict. Names of observations and; variables can be accessed via adata.obs_names and adata.var_names,; respectively. AnnData objects can be sliced like; dataframes, for example, adata_subset = adata[:, list_of_gene_names].; For more, see this blog post.; To read a data file to an AnnData object, call:; adata = sc.read(filename). to initialize an AnnData object. Possibly add further annotation using, e.g., pd.read_csv:; import pandas as pd; anno = pd.read_csv(filename_sample_annotation); adata.obs['cell_groups'] = anno['cell_groups'] # categorical annotation of type pandas.Categorical; adata.obs['time'] = anno['time'] # numerical annotation of type float; # alternatively, you could also set the whole dataframe; # adata.obs = anno. To write, use:; adata.write(filename); adata.write_csvs(filename); adata.write_loom(filename). previous; Using dask with Scanpy. next; How to. Contents; . Workflow; AnnData. By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/usage-principles.html:10560,access,accessed,10560,en/stable/usage-principles.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/usage-principles.html,1,['access'],['accessed']
Security,"ernal.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.pl.violin. Contents . violin(). scanpy.pl.violin#. scanpy.pl.violin(adata, keys, groupby=None, *, log=False, use_raw=None, stripplot=True, jitter=True, size=1, layer=None, scale='width', order=None, multi_panel=None, xlabel='', ylabel=None, rotation=None, show=None, save=None, ax=None, **kwds)[source]#; Violin plot.; Wraps seaborn.violinplot() for AnnData. Parameters:. adata AnnDataAnnotated data matrix. keys str | Sequence[str]Keys for accessing variables of .var_names or fields of .obs. groupby str | None (default: None)The key of the observation grouping to consider. log bool (default: False)Plot on logarithmic axis. use_raw bool | None (default: None)Whether to use raw attribute of adata. Defaults to True if .raw is present. stripplot bool (default: True)Add a stripplot on top of the violin plot.; See stripplot(). jitter float | bool (default: True)Add jitter to the stripplot (only when stripplot is True); See stripplot(). size int (default: 1)Size of the jitter points. layer str | None (default: None)Name of the AnnData object layer that wants to be plotted. By; default adata.raw.X is plotted. If use_raw=False is set,; then adata.X is plotted. If layer is set to a valid layer name,; then the layer is plotted. layer takes precedence over use_raw. scale Literal['area', 'count', 'width'] (default: 'width')The method used to scale the width of each violin.; If ‘width’ (the default), each violin will have the sam",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pl.violin.html:9673,access,accessing,9673,en/stable/generated/scanpy.pl.violin.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pl.violin.html,1,['access'],['accessing']
Security,"ets.pbmc3k_processed; scanpy.datasets.pbmc68k_reduced; scanpy.datasets.paul15; scanpy.datasets.toggleswitch; scanpy.datasets.visium_sge. Deprecated functions; scanpy.pp.filter_genes_dispersion; scanpy.pp.normalize_per_cell. External API; Preprocessing: PP; scanpy.external.pp.bbknn; scanpy.external.pp.harmony_integrate; scanpy.external.pp.mnn_correct; scanpy.external.pp.scanorama_integrate; scanpy.external.pp.hashsolo; scanpy.external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.pl.ranking. Contents . ranking(). scanpy.pl.ranking#. scanpy.pl.ranking(adata, attr, keys, *, dictionary=None, indices=None, labels=None, color='black', n_points=30, log=False, include_lowest=False, show=None)[source]#; Plot rankings.; See, for example, how this is used in pl.pca_loadings. Parameters:. adata AnnDataThe data. attr Literal['var', 'obs', 'uns', 'varm', 'obsm']The attribute of AnnData that contains the score. keys str | Sequence[str]The scores to look up an array from the attribute of adata. Return type:; GridSpec | None. Returns:; Returns matplotlib gridspec with access to the axes. previous; scanpy.pl.clustermap. next; scanpy.pl.dendrogram. Contents; . ranking(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pl.ranking.html:9817,access,access,9817,en/stable/generated/scanpy.pl.ranking.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.pl.ranking.html,1,['access'],['access']
Security,"harmony_integrate; scanpy.external.pp.mnn_correct; scanpy.external.pp.scanorama_integrate; scanpy.external.pp.hashsolo; scanpy.external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.external.pp.hashsolo. Contents . hashsolo(). scanpy.external.pp.hashsolo#. scanpy.external.pp.hashsolo(adata, cell_hashing_columns, *, priors=(0.01, 0.8, 0.19), pre_existing_clusters=None, number_of_noise_barcodes=None, inplace=True)[source]#; Probabilistic demultiplexing of cell hashing data using HashSolo [Bernstein et al., 2020]. Note; More information and bug reports here. Parameters:. adata AnnDataThe (annotated) data matrix of shape n_obs × n_vars.; Rows correspond to cells and columns to genes. cell_hashing_columns Sequence[str].obs columns that contain cell hashing counts. priors tuple[float, float, float] (default: (0.01, 0.8, 0.19))Prior probabilities of each hypothesis, in; the order [negative, singlet, doublet]. The default is set to; [0.01, 0.8, 0.19] assuming barcode counts are from cells that; have passed QC in the transcriptome space, e.g. UMI counts, pct; mito reads, etc. pre_existing_clusters str | None (default: None)The column in .obs containing pre-existing cluster assignments; (e.g. Leiden clusters or cell types, but not batch assi",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.hashsolo.html:9307,hash,hashsolo,9307,en/stable/generated/scanpy.external.pp.hashsolo.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.hashsolo.html,1,['hash'],['hashsolo']
Security,"he output is kept as raw; counts as loss functions are designed for the count data. log1p bool (default: True)If true, the input of the autoencoder is log transformed with a; pseudocount of one using sc.pp.log1p function of Scanpy. hidden_size Sequence[int] (default: (64, 32, 64))Width of hidden layers. hidden_dropout float | Sequence[float] (default: 0.0)Probability of weight dropout in the autoencoder (per layer if list; or tuple). batchnorm bool (default: True)If true, batch normalization is performed. activation str (default: 'relu')Activation function of hidden layers. init str (default: 'glorot_uniform')Initialization method used to initialize weights. network_kwds Mapping[str, Any] (default: mappingproxy({}))Additional keyword arguments for the autoencoder. epochs int (default: 300)Number of total epochs in training. reduce_lr int (default: 10)Reduces learning rate if validation loss does not improve in given number of epochs. early_stop int (default: 15)Stops training if validation loss does not improve in given number of epochs. batch_size int (default: 32)Number of samples in the batch used for SGD. optimizer str (default: 'RMSprop')Type of optimization method used for training. random_state Union[int, RandomState, None] (default: 0)Seed for python, numpy and tensorflow. threads int | None (default: None)Number of threads to use in training. All cores are used by default. learning_rate float | None (default: None)Learning rate to use in the training. verbose bool (default: False)If true, prints additional information about training and architecture. training_kwds Mapping[str, Any] (default: mappingproxy({}))Additional keyword arguments for the training process. return_model bool (default: False)If true, trained autoencoder object is returned. See “Returns”. return_info bool (default: False)If true, all additional parameters of DCA are stored in adata.obsm such as dropout; probabilities (obsm[‘X_dca_dropout’]) and estimated dispersion values; (obsm[‘X_dca_d",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.dca.html:12205,validat,validation,12205,en/stable/generated/scanpy.external.pp.dca.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.dca.html,1,['validat'],['validation']
Security,"her differences, such as which types of legends are used (i.e. continous Colorbar or discrete Legend), etc. Figure and Axes objects#; scanpy plotting functions can return Figure or the plot object (by setting return_fig=True) or Axes (by setting show=False).; The show parameter also regulates when the plot is rendered. If we want to customize Axes after the scanpy plotting function was called we need to set show=False to ensure that the plot will be rendered only after we made all adjustments.; For example, from embedding plots (such as umap) we can obtain either axes (by setting show=False) or the whole figure (by setting return_fig=True) that stores axes in figure.axes. For every plotted category one Axes object will be created and for every continuous category two Axes objects: the UMAP plot and colorbar on the side. However, if we want to obtain the colorbar axes object we need to use return_fig=True rather than show=False. When accessing Axes from Figure the returned object is a list and we need to select the relevant Axes to modify them. When returning Axes directly (e.g. with show=False) we obtain either an individual Axes object (if this is the only Axes object on the Figure) or a list of Axes (if multiple Axes were created). # Examples of returned objects from the UMAP function. print(""Categorical plots:""); axes = sc.pl.umap(adata, color=[""bulk_labels""], show=False); print(""Axis from a single category plot:"", axes); plt.close(); axes = sc.pl.umap(adata, color=[""bulk_labels"", ""S_score""], show=False); print(""Axes list from two categorical plots:"", axes); plt.close(); fig = sc.pl.umap(adata, color=[""bulk_labels""], return_fig=True); print(""Axes list from a figure with one categorical plot:"", fig.axes); plt.close(). print(""\nContinous plots:""); axes = sc.pl.umap(adata, color=[""IGJ""], show=False); print(""Axes from one continuous plot:"", axes); plt.close(); fig = sc.pl.umap(adata, color=[""IGJ""], return_fig=True); print(""Axes list from a figure of one continous plo",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/advanced.html:11845,access,accessing,11845,en/stable/tutorials/plotting/advanced.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/tutorials/plotting/advanced.html,2,['access'],['accessing']
Security,"hsolo; scanpy.external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.datasets.ebi_expression_atlas. Contents . ebi_expression_atlas(). scanpy.datasets.ebi_expression_atlas#. scanpy.datasets.ebi_expression_atlas(accession, *, filter_boring=False)[source]#; Load a dataset from the EBI Single Cell Expression Atlas.; The atlas can be browsed online to find the accession you want.; Downloaded datasets are saved in the directory specified by; datasetdir. Parameters:. accession strDataset accession. Like E-GEOD-98816 or E-MTAB-4888.; This can be found in the url on the datasets page, for example E-GEOD-98816. filter_boring bool (default: False)Whether boring labels in .obs should be automatically removed, such as; labels with a single or n_obs distinct values. Return type:; AnnData. Returns:; Annotated data matrix. Example; >>> import scanpy as sc; >>> sc.datasets.ebi_expression_atlas(""E-MTAB-4888"") ; AnnData object with n_obs × n_vars = 2261 × 23899; obs: 'Sample Characteristic[organism]', 'Sample Characteristic Ontology Term[organism]', ..., 'Factor Value[cell type]', 'Factor Value Ontology Term[cell type]'. previous; scanpy.datasets.blobs. next; scanpy.datasets.krumsiek11. Contents; . ebi_expression_atlas(). By Scanpy development team. ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.datasets.ebi_expression_atlas.html:9394,access,accession,9394,en/stable/generated/scanpy.datasets.ebi_expression_atlas.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.datasets.ebi_expression_atlas.html,1,['access'],['accession']
Security,"ic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.datasets.ebi_expression_atlas. Contents . ebi_expression_atlas(). scanpy.datasets.ebi_expression_atlas#. scanpy.datasets.ebi_expression_atlas(accession, *, filter_boring=False)[source]#; Load a dataset from the EBI Single Cell Expression Atlas.; The atlas can be browsed online to find the accession you want.; Downloaded datasets are saved in the directory specified by; datasetdir. Parameters:. accession strDataset accession. Like E-GEOD-98816 or E-MTAB-4888.; This can be found in the url on the datasets page, for example E-GEOD-98816. filter_boring bool (default: False)Whether boring labels in .obs should be automatically removed, such as; labels with a single or n_obs distinct values. Return type:; AnnData. Returns:; Annotated data matrix. Example; >>> import scanpy as sc; >>> sc.datasets.ebi_expression_atlas(""E-MTAB-4888"") ; AnnData object with n_obs × n_vars = 2261 × 23899; obs: 'Sample Characteristic[organism]', 'Sample Characteristic Ontology Term[organism]', ..., 'Factor Value[cell type]', 'Factor Value Ontology Term[cell type]'. previous; scanpy.datasets.blobs. next; scanpy.datasets.krumsiek11. Contents; . ebi_expression_atlas(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.datasets.ebi_expression_atlas.html:9542,access,accession,9542,en/stable/generated/scanpy.datasets.ebi_expression_atlas.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.datasets.ebi_expression_atlas.html,3,['access'],['accession']
Security,"if ``transformer`` is an instance. random_state Union[int, RandomState, None] (default: 0)A numpy random seed.; ignored if ``transformer`` is an instance. key_added str | None (default: None)If not specified, the neighbors data is stored in .uns['neighbors'],; distances and connectivities are stored in .obsp['distances'] and; .obsp['connectivities'] respectively.; If specified, the neighbors data is added to .uns[key_added],; distances are stored in .obsp[key_added+'_distances'] and; connectivities in .obsp[key_added+'_connectivities']. copy bool (default: False)Return a copy instead of writing to adata. Return type:; AnnData | None. Returns:; Returns None if copy=False, else returns an AnnData object. Sets the following fields:. adata.obsp['distances' | key_added+'_distances']scipy.sparse.csr_matrix (dtype float)Distance matrix of the nearest neighbors search. Each row (cell) has n_neighbors-1 non-zero entries. These are the distances to their n_neighbors-1 nearest neighbors (excluding the cell itself). adata.obsp['connectivities' | key_added+'_connectivities']scipy.sparse._csr.csr_matrix (dtype float)Weighted adjacency matrix of the neighborhood graph of data; points. Weights should be interpreted as connectivities. adata.uns['neighbors' | key_added]dictneighbors parameters. Examples; >>> import scanpy as sc; >>> adata = sc.datasets.pbmc68k_reduced(); >>> # Basic usage; >>> sc.pp.neighbors(adata, 20, metric='cosine'); >>> # Provide your own transformer for more control and flexibility; >>> from sklearn.neighbors import KNeighborsTransformer; >>> transformer = KNeighborsTransformer(n_neighbors=10, metric='manhattan', algorithm='kd_tree'); >>> sc.pp.neighbors(adata, transformer=transformer); >>> # now you can e.g. access the index: `transformer._tree`. See also; Using other kNN libraries in Scanpy. previous; scanpy.pp.scrublet_simulate_doublets. next; Tools: tl. Contents; . neighbors(). By Scanpy development team. ; © Copyright 2024, the Scanpy development team.; . ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pp.neighbors.html:14347,access,access,14347,en/stable/api/generated/scanpy.pp.neighbors.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/api/generated/scanpy.pp.neighbors.html,1,['access'],['access']
Security,"l.pp.bbknn; scanpy.external.pp.harmony_integrate; scanpy.external.pp.mnn_correct; scanpy.external.pp.scanorama_integrate; scanpy.external.pp.hashsolo; scanpy.external.pp.dca; scanpy.external.pp.magic. Tools: TL; scanpy.external.tl.phate; scanpy.external.tl.palantir; scanpy.external.tl.trimap; scanpy.external.tl.sam; scanpy.external.tl.phenograph; scanpy.external.tl.harmony_timeseries; scanpy.external.tl.wishbone; scanpy.external.tl.palantir; scanpy.external.tl.palantir_results; scanpy.external.tl.sandbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .rst. .pdf. scanpy.external.pp.hashsolo. Contents . hashsolo(). scanpy.external.pp.hashsolo#. scanpy.external.pp.hashsolo(adata, cell_hashing_columns, *, priors=(0.01, 0.8, 0.19), pre_existing_clusters=None, number_of_noise_barcodes=None, inplace=True)[source]#; Probabilistic demultiplexing of cell hashing data using HashSolo [Bernstein et al., 2020]. Note; More information and bug reports here. Parameters:. adata AnnDataThe (annotated) data matrix of shape n_obs × n_vars.; Rows correspond to cells and columns to genes. cell_hashing_columns Sequence[str].obs columns that contain cell hashing counts. priors tuple[float, float, float] (default: (0.01, 0.8, 0.19))Prior probabilities of each hypothesis, in; the order [negative, singlet, doublet]. The default is set to; [0.01, 0.8, 0.19] assuming barcode counts are from cells that; have passed QC in the transcriptome space, e.g. UMI counts, pct; mito reads, etc. pre_existing_clusters str | None (default: None)The column in .obs containing pre-existing cluster assignments; (e.g. Leiden clusters or",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.hashsolo.html:9276,hash,hashsolo,9276,en/stable/generated/scanpy.external.pp.hashsolo.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.hashsolo.html,1,['hash'],['hashsolo']
Security,"lt: True)If true, the input of the autoencoder is centered using; sc.pp.scale function of Scanpy. Note that the output is kept as raw; counts as loss functions are designed for the count data. log1p bool (default: True)If true, the input of the autoencoder is log transformed with a; pseudocount of one using sc.pp.log1p function of Scanpy. hidden_size Sequence[int] (default: (64, 32, 64))Width of hidden layers. hidden_dropout float | Sequence[float] (default: 0.0)Probability of weight dropout in the autoencoder (per layer if list; or tuple). batchnorm bool (default: True)If true, batch normalization is performed. activation str (default: 'relu')Activation function of hidden layers. init str (default: 'glorot_uniform')Initialization method used to initialize weights. network_kwds Mapping[str, Any] (default: mappingproxy({}))Additional keyword arguments for the autoencoder. epochs int (default: 300)Number of total epochs in training. reduce_lr int (default: 10)Reduces learning rate if validation loss does not improve in given number of epochs. early_stop int (default: 15)Stops training if validation loss does not improve in given number of epochs. batch_size int (default: 32)Number of samples in the batch used for SGD. optimizer str (default: 'RMSprop')Type of optimization method used for training. random_state Union[int, RandomState, None] (default: 0)Seed for python, numpy and tensorflow. threads int | None (default: None)Number of threads to use in training. All cores are used by default. learning_rate float | None (default: None)Learning rate to use in the training. verbose bool (default: False)If true, prints additional information about training and architecture. training_kwds Mapping[str, Any] (default: mappingproxy({}))Additional keyword arguments for the training process. return_model bool (default: False)If true, trained autoencoder object is returned. See “Returns”. return_info bool (default: False)If true, all additional parameters of DCA are stored in adat",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.dca.html:12099,validat,validation,12099,en/stable/generated/scanpy.external.pp.dca.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/generated/scanpy.external.pp.dca.html,1,['validat'],['validation']
Security,"ndbag; scanpy.external.tl.cyclone. Plotting: PL; scanpy.external.pl.phate; scanpy.external.pl.trimap; scanpy.external.pl.sam; scanpy.external.pl.wishbone_marker_trajectory. Exporting; scanpy.external.exporting.spring_project; scanpy.external.exporting.cellbrowser. Ecosystem; Release notes; Community; News; Contributing; Contributing code; Getting set up; Tests; Documentation; CI; Versioning; Making a release. Contributors; References. .md. .pdf. Installation. Contents . Development Version; Docker; Troubleshooting. Installation#; To use scanpy from another project, install it using your favourite environment manager:. Hatch (recommended)Pip/PyPICondaAdding scanpy[leiden] to your dependencies is enough.; See below for how to use Scanpy’s Development Version.; If you prefer to exclusively use PyPI run:; $ pip install 'scanpy[leiden]'. After installing installing e.g. Miniconda, run:; $ conda install -c conda-forge scanpy python-igraph leidenalg. Pull Scanpy from PyPI (consider using pip3 to access Python 3):; $ pip install scanpy. If you use Hatch or pip, the extra [leiden] installs two packages that are needed for popular; parts of scanpy but aren’t requirements: igraph [Csárdi and Nepusz, 2006] and leiden [Traag et al., 2019].; If you use conda, you should to add these dependencies to your environment individually. Development Version#; To work with the latest version on GitHub: clone the repository and cd into its root directory.; $ gh repo clone scverse/scanpy; $ cd scanpy. Hatch (recommended)Pip/PyPICondaTo use one of the predefined Hatch environments in hatch.toml,; run either hatch test [args] or hatch run [env:]command [...args], e.g.:; $ hatch test -p # run tests in parallel; $ hatch run docs:build # build docs; $ hatch run towncrier:create # create changelog entry. If you are using pip>=21.3, an editable install can be made:; $ python -m venv .venv; $ source .venv/bin/activate; $ pip install -e '.[dev,test]'. If you want to let conda handle the installations ",MatchSource.WIKI,scverse,scanpy,1.10.2,https://scanpy.readthedocs.io/en/stable/installation.html:9774,access,access,9774,en/stable/installation.html,https://scanpy.readthedocs.io,https://scanpy.readthedocs.io/en/stable/installation.html,1,['access'],['access']
