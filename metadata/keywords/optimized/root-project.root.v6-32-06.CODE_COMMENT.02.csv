quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Availability,"// If we're implicitly loading a module, the base directory can't; // change between the build and use.; // Don't emit module relocation error if we have -fno-validate-pch",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:137,error,error,137,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['error'],['error']
Availability,"// If we're in microsoft extensions mode, downgrade this from a hard; // error to an extension that defaults to an error. This allows; // disabling it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:42,down,downgrade,42,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,3,"['down', 'error']","['downgrade', 'error']"
Availability,"// If we're in template instantiation, it's an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:47,error,error,47,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp,1,['error'],['error']
Availability,"// If we're inserting into a constant, mask off the inserted index; // and OR with the zero-extended scalar.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:39,mask,mask,39,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// If we're just performing this lookup for error-recovery purposes,; // don't extend the nested-name-specifier. Just return now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:44,error,error-recovery,44,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,1,['error'],['error-recovery']
Availability,"// If we're memsetting or bzeroing 0 bytes, then this is likely an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:67,error,error,67,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['error'],['error']
Availability,"// If we're negating a FMUL node on a target with FMA, then we can avoid the; // use of a constant by performing (-0 - A*B) instead.; // FIXME: Check rounding control flags as well once it becomes available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:197,avail,available,197,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avail'],['available']
Availability,"// If we're not in a function, it's an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:39,error,error,39,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp,1,['error'],['error']
Availability,"// If we're not in a record, this is an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:40,error,error,40,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['error'],['error']
Availability,"// If we're not in an ObjC method, error out. Note that, unlike the; // C++ case, we don't require an instance method --- class methods; // still have a 'self', and we really do still need to capture it!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:35,error,error,35,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,1,['error'],['error']
Availability,"// If we're not using both lanes in each lane and the inlane mask is not; // repeating, then we're better off splitting.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:61,mask,mask,61,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// If we're now down to one manifest, all is good.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/WindowsResource.cpp:16,down,down,16,interpreter/llvm-project/llvm/lib/Object/WindowsResource.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/WindowsResource.cpp,1,['down'],['down']
Availability,"// If we're optimizing for size, only fold if at least one of the constants is; // only used once or the combined shuffle has included a variable mask; // shuffle, this is to avoid constant pool bloat.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:146,mask,mask,146,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// If we're optimizing, collapse all calls to trap down to just one per; // check-type per function to save on code size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:51,down,down,51,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['down'],['down']
Availability,"// If we're parsing Thumb2, the .w variant is available and handles; // most cases that are normally illegal for a Thumb1 LDM instruction.; // We'll make the transformation in processInstruction() if necessary.; //; // Thumb LDM instructions are writeback iff the base register is not; // in the register list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:46,avail,available,46,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['avail'],['available']
Availability,"// If we're performing qualified name lookup into a dependent class,; // then we are actually looking into a current instantiation. If we have any; // dependent base classes, then we either have to delay lookup until; // template instantiation time (at which point all bases will be available); // or we have to fail.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:283,avail,available,283,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,1,['avail'],['available']
Availability,"// If we're producing a smaller vector than our minimum legal integer; // type, bitcast to the equivalent (known-legal) mask type, and extract; // our final mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:120,mask,mask,120,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,2,['mask'],['mask']
Availability,"// If we're referencing an invalid decl, just return this as a silent; // error node. The error diagnostic was already emitted on the decl.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:74,error,error,74,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,2,['error'],['error']
Availability,"// If we're tracking CR bits, we need to be careful that we don't have:; // zext(binary-ops(trunc(x), trunc(y))); // or; // zext(binary-ops(binary-ops(trunc(x), trunc(y)), ...); // such that we're unnecessarily moving things into CR bits that can more; // efficiently stay in GPRs. Note that if we're not certain that the high; // bits are set as required by the final extension, we still may need to do; // some masking to get the proper behavior.; // This same functionality is important on PPC64 when dealing with; // 32-to-64-bit extensions; these occur often when 32-bit values are used as; // the return values of functions. Because it is so similar, it is handled; // here as well.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:413,mask,masking,413,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['mask'],['masking']
Availability,"// If we're using the '*' case here or if this check is redundant, then we; // use the enclosing version to check both branches.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:56,redundant,redundant,56,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,1,['redundant'],['redundant']
Availability,"// If we've added to the set of alive bits (or the operand has not; // been previously visited), then re-queue the operand to be visited; // again.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp:32,alive,alive,32,interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,1,['alive'],['alive']
Availability,"// If we've already decided this function is invalid, e.g. because; // we saw a `return` whose expression had an error, don't keep; // trying to deduce its return type.; // (Some return values may be needlessly wrapped in RecoveryExpr).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:113,error,error,113,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,2,"['Recover', 'error']","['RecoveryExpr', 'error']"
Availability,"// If we've already decided this lambda is invalid, e.g. because; // we saw a `return` whose expression had an error, don't keep; // trying to deduce its return type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:111,error,error,111,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,1,['error'],['error']
Availability,"// If we've already handled this import, just return the cached result.; // This one-element cache is important to eliminate redundant diagnostics; // when both the preprocessor and parser see the same import declaration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:125,redundant,redundant,125,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,1,['redundant'],['redundant']
Availability,"// If we've already visited this path with this MemoryLocation, we don't; // need to do so again.; //; // NOTE: That we just drop these paths on the ground makes caching; // behavior sporadic. e.g. given a diamond:; // A; // B C; // D; //; // ...If we walk D, B, A, C, we'll only cache the result of phi; // optimization for A, B, and D; C will be skipped because it dies here.; // This arguably isn't the worst thing ever, since:; // - We generally query things in a top-down order, so if we got below D; // without needing cache entries for {C, MemLoc}, then chances are; // that those cache entries would end up ultimately unused.; // - We still cache things for A, so C only needs to walk up a bit.; // If this behavior becomes problematic, we can fix without a ton of extra; // work.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:472,down,down,472,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,1,['down'],['down']
Availability,"// If we've been asked to forbid guard variables, emit an error now.; // This diagnostic is hard-coded for Darwin's use case; we can find; // better phrasing if someone else needs it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp:58,error,error,58,interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp,1,['error'],['error']
Availability,// If we've been handed an error or received one back from a generator then; // fail the query. We don't need to unlink: At this stage the query hasn't; // actually been lodged.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:27,error,error,27,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,1,['error'],['error']
Availability,"// If we've emitted a lot of errors, emit a fatal error instead of it to; // stop a flood of bogus errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:29,error,errors,29,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,3,['error'],"['error', 'errors']"
Availability,"// If we've performed some kind of recovery, (re-)build the type source; // information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:35,recover,recovery,35,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['recover'],['recovery']
Availability,"// If we've run into the poison token we inserted before, or there; // was a parsing error, then claim the entire line.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp:85,error,error,85,interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp,1,['error'],['error']
Availability,"// If we've set the mask, we can transform.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:20,mask,mask,20,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['mask'],['mask']
Availability,"// If yes, list node eligible for caching, if not test nodes one level down",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx:71,down,down,71,roofit/roofitcore/src/RooAbsArg.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx,1,['down'],['down']
Availability,"// Ignore ARGUMENTS; it's just used to keep the ARGUMENT_* instructions; // from moving down, and we've already checked for that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp:88,down,down,88,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp,1,['down'],['down']
Availability,// Ignore Lexing errors in macros.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp:17,error,errors,17,interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,2,['error'],['errors']
Availability,"// Ignore any error here, we assume it will be handled in another place.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:14,error,error,14,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,1,['error'],['error']
Availability,"// Ignore any error here, we assume it will handled in another place.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:14,error,error,14,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,1,['error'],['error']
Availability,"// Ignore any error here.; // If this is not the end of the section parseNext() will still be; // attempted, where this error will occur again (and can be handled).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFDebugLine.cpp:14,error,error,14,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFDebugLine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFDebugLine.cpp,2,['error'],['error']
Availability,// Ignore any errors,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:14,error,errors,14,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['error'],['errors']
Availability,"// Ignore any forward declaration issued after a definition. Fixes ""error; // : reference to 'xxx' is ambiguous"" in `class C {}; class C; C foo;`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DefinitionShadower.cpp:68,error,error,68,interpreter/cling/lib/Interpreter/DefinitionShadower.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DefinitionShadower.cpp,1,['error'],['error']
Availability,// Ignore attributes that don't validate or can't apply to the; // function type. We'll diagnose the failure to apply them in; // handleFunctionTypeAttr.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:101,failure,failure,101,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,1,['failure'],['failure']
Availability,// Ignore comparisons which are only used masked with exec.; // This allows some hoisting/sinking of VALU comparisons.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp:42,mask,masked,42,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,1,['mask'],['masked']
Availability,// Ignore deprecated/unavailable/availability attributes if requested.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:33,avail,availability,33,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['avail'],['availability']
Availability,"// Ignore diagnostics when we tab complete.; // This is because we get redefinition errors due to the import of the decls.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Interpreter.cpp:84,error,errors,84,interpreter/cling/lib/Interpreter/Interpreter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Interpreter.cpp,1,['error'],['errors']
Availability,"// Ignore error caused by the inside of std::unique_ptr; // This is needed solely because of rootclingIO's IsUnsupportedUniquePointer; // which checks the number of elements in the GetListOfRealData.; // If this usage is removed, this can be replaced with a return statement.; // See https://github.com/root-project/root/issues/13574",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:10,error,error,10,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['error'],['error']
Availability,"// Ignore error for re-creating existing container.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RDaos.cxx:10,error,error,10,tree/ntuple/v7/src/RDaos.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RDaos.cxx,1,['error'],['error']
Availability,// Ignore error here. Indirect calls are ignored if this fails.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/CGProfile.cpp:10,error,error,10,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/CGProfile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/CGProfile.cpp,1,['error'],['error']
Availability,// Ignore errors here where the dynsym is empty or sh_size less than the; // size of one symbol. These should be handled elsewhere.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELFObjectFile.h:10,error,errors,10,interpreter/llvm-project/llvm/include/llvm/Object/ELFObjectFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELFObjectFile.h,1,['error'],['errors']
Availability,"// Ignore errors here: If an error occurred during increment then getNext; // will have been set to child_end(), and the following comparison should; // do the right thing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/Archive.h:10,error,errors,10,interpreter/llvm-project/llvm/include/llvm/Object/Archive.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/Archive.h,2,['error'],"['error', 'errors']"
Availability,// Ignore errors that occur when trying to discard the temp file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:10,error,errors,10,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,1,['error'],['errors']
Availability,"// Ignore errors, the file might not exist.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/Symbolize/Symbolize.cpp:10,error,errors,10,interpreter/llvm-project/llvm/lib/DebugInfo/Symbolize/Symbolize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/Symbolize/Symbolize.cpp,2,['error'],['errors']
Availability,// Ignore failures; dropping the entire initializer list because; // of one failure would be terrible for indexing/etc.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:10,failure,failures,10,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,2,['failure'],"['failure', 'failures']"
Availability,"// Ignore indent from <built-in>.; // FIXME: Identify headers in a more robust way than comparing their name to; // ""<command line>"" and ""<built-in>"" in a bunch of places.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/HeaderIncludeGen.cpp:72,robust,robust,72,interpreter/llvm-project/clang/lib/Frontend/HeaderIncludeGen.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/HeaderIncludeGen.cpp,1,['robust'],['robust']
Availability,// Ignore instructions which shouldn't be matched and diagnose invalid; // instruction definitions with an error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp:107,error,error,107,interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp,1,['error'],['error']
Availability,// Ignore invalid (undefined) mask elements.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:30,mask,mask,30,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,1,['mask'],['mask']
Availability,"// Ignore legacy tests if legacy backend is not available",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/vectorisedPDFs/VectorisedPDFTests.h:48,avail,available,48,roofit/roofit/test/vectorisedPDFs/VectorisedPDFTests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/vectorisedPDFs/VectorisedPDFTests.h,1,['avail'],['available']
Availability,// Ignore noise and errors. FIXME: take noise into account ?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp:20,error,errors,20,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp,1,['error'],['errors']
Availability,"// Ignore non-leaf subregisters, their lane masks are fully covered by; // the leaf subregisters anyway.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp:44,mask,masks,44,interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp,1,['mask'],['masks']
Availability,// Ignore options that are excluded via masks,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Option/OptTable.cpp:40,mask,masks,40,interpreter/llvm-project/llvm/lib/Option/OptTable.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Option/OptTable.cpp,1,['mask'],['masks']
Availability,"// Ignore parsing error, just go 3rd step.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp:18,error,error,18,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp,1,['error'],['error']
Availability,// Ignore parsing error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:18,error,error,18,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,2,['error'],['error']
Availability,"// Ignore request if GL window or context not yet available or shown.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLViewer.cxx:50,avail,available,50,graf3d/gl/src/TGLViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLViewer.cxx,1,['avail'],['available']
Availability,// Ignore the error and retry parsing as a literal.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:14,error,error,14,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,1,['error'],['error']
Availability,"// Ignore the name-fetch error, just report the index.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-tli-checker/llvm-tli-checker.cpp:25,error,error,25,interpreter/llvm-project/llvm/tools/llvm-tli-checker/llvm-tli-checker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-tli-checker/llvm-tli-checker.cpp,1,['error'],['error']
Availability,"// Ignore this builtin function if it carries an extension macro that is; // not defined. This indicates that the extension is not supported by the; // target, so the builtin function should not be available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:198,avail,available,198,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,1,['avail'],['available']
Availability,// Ignore this builtin function if it is not available in the currently; // selected language version.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:45,avail,available,45,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,1,['avail'],['available']
Availability,// Ignore undef mask elements.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:16,mask,mask,16,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['mask'],['mask']
Availability,// Illegal SCSs map to None: error reporting is up to the caller.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:29,error,error,29,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['error'],['error']
Availability,"// Immediate operand kind.; // It helps to identify the location of an offending operand after an error.; // Note that regular literals and mandatory literals (KImm) must be handled; // differently. When looking for an offending operand, we should usually; // ignore mandatory literals because they are part of the instruction and; // cannot be changed. Report location of mandatory operands only for VOPD,; // when both OpX and OpY have a KImm and there are no other literals.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp:98,error,error,98,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp,1,['error'],['error']
Availability,"// Implement EmitInstrWithCustomInserter for pseudo CondStore* instruction MI.; // StoreOpcode is the store to use and Invert says whether the store should; // happen when the condition is false rather than true. If a STORE ON; // CONDITION is available, STOCOpcode is its opcode, otherwise it is 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:244,avail,available,244,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['avail'],['available']
Availability,"// Implement EmitInstrWithCustomInserter for subword pseudo; // ATOMIC_LOADW_{,U}{MIN,MAX} instruction MI. CompareOpcode is the; // instruction that should be used to compare the current field with the; // minimum or maximum value. KeepOldMask is the BRC condition-code mask; // for when the current field should be kept.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:270,mask,mask,270,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['mask'],['mask']
Availability,// Implement VP_MERGE in terms of VSELECT. Construct a mask where vector; // indices less than the EVL/pivot are true. Combine that with the original; // mask for a full-length mask. Use a full-length VSELECT to select between; // the true and false values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp:55,mask,mask,55,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,3,['mask'],['mask']
Availability,"// Implement a lookup table in register by using an algorithm based on:; // http://wm.ite.pl/articles/sse-popcount.html; //; // The general idea is that every lower byte nibble in the input vector is an; // index into a in-register pre-computed pop count table. We then split up the; // input vector in two new ones: (1) a vector with only the shifted-right; // higher nibbles for each byte and (2) a vector with the lower nibbles (and; // masked out higher ones) for each byte. PSHUFB is used separately with both; // to index the in-register table. Next, both are added and the result is a; // i8 vector where each element contains the pop count for input byte.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:440,mask,masked,440,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['masked']
Availability,"// Implement some heroics to detect shifts of masked values where the mask can; // be replaced by extending the shift and undoing that in the addressing mode; // scale. Patterns such as (shl (srl x, c1), c2) are canonicalized into (and; // (srl x, SHIFT), MASK) by DAGCombines that don't know the shl can be done in; // the addressing mode. This results in code such as:; //; // int f(short *y, int *lookup_table) {; // ...; // return *y + lookup_table[*y >> 11];; // }; //; // Turning into:; // movzwl (%rdi), %eax; // movl %eax, %ecx; // shrl $11, %ecx; // addl (%rsi,%rcx,4), %eax; //; // Instead of:; // movzwl (%rdi), %eax; // movl %eax, %ecx; // shrl $9, %ecx; // andl $124, %rcx; // addl (%rsi,%rcx), %eax; //; // Note that this function assumes the mask is provided as a mask *after* the; // value is shifted. The input chain may or may not match that, but computing; // such a mask is trivial.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:46,mask,masked,46,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,6,"['MASK', 'mask']","['MASK', 'mask', 'masked']"
Availability,// Implementing VirtualIntegrator Interface; /** Set the desired relative Error. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/GaussIntegrator.h:74,Error,Error,74,math/mathcore/inc/Math/GaussIntegrator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/GaussIntegrator.h,1,['Error'],['Error']
Availability,"// Implements a vector truncate that fits in a vector register as a shuffle.; // We want to legalize vector truncates down to where the source fits in; // a vector register (and target is therefore smaller than vector register; // size). At that point legalization will try to custom lower the sub-legal; // result and get here - where we can contain the truncate as a single target; // operation.; // For example a trunc <2 x i16> to <2 x i8> could be visualized as follows:; // <MSB1|LSB1, MSB2|LSB2> to <LSB1, LSB2>; //; // We will implement it for big-endian ordering as this (where x denotes; // undefined):; // < MSB1|LSB1, MSB2|LSB2, uu, uu, uu, uu, uu, uu> to; // < LSB1, LSB2, u, u, u, u, u, u, u, u, u, u, u, u, u, u>; //; // The same operation in little-endian ordering will be:; // <uu, uu, uu, uu, uu, uu, LSB2|MSB2, LSB1|MSB1> to; // <u, u, u, u, u, u, u, u, u, u, u, u, u, u, LSB2, LSB1>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:118,down,down,118,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['down'],['down']
Availability,// Implements the LoongArch calling convention. Returns true upon failure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:66,failure,failure,66,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,1,['failure'],['failure']
Availability,// Implements the RISC-V calling convention. Returns true upon failure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:63,failure,failure,63,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['failure'],['failure']
Availability,"// Implements the hardware dispatch logic.; //; // This class is responsible for the dispatch stage, in which instructions are; // dispatched in groups to the Scheduler. An instruction can be dispatched if; // the following conditions are met:; // 1) There are enough entries in the reorder buffer (see class; // RetireControlUnit) to write the opcodes associated with the instruction.; // 2) There are enough physical registers to rename output register operands.; // 3) There are enough entries available in the used buffered resource(s).; //; // The number of micro opcodes that can be dispatched in one cycle is limited by; // the value of field 'DispatchWidth'. A ""dynamic dispatch stall"" occurs when; // processor resources are not available. Dispatch stall events are counted; // during the entire execution of the code, and displayed by the performance; // report when flag '-dispatch-stats' is specified.; //; // If the number of micro opcodes exceedes DispatchWidth, then the instruction; // is dispatched in multiple cycles.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Stages/DispatchStage.h:497,avail,available,497,interpreter/llvm-project/llvm/include/llvm/MCA/Stages/DispatchStage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Stages/DispatchStage.h,2,['avail'],['available']
Availability,"// Implicit ABI tags (from namespace) are not available in the following; // entity; reset to actually emitted tags, which are available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:46,avail,available,46,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,2,['avail'],['available']
Availability,"// Import every item from a container structure into an output container.; // If error occurs, stops at first error and returns the error.; // The output container should have space for all needed elements (it is not; // expanded, new items are put into from the beginning).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:81,error,error,81,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,3,['error'],['error']
Availability,"// Import first, then allocate memory and copy if there was no error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:63,error,error,63,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['error'],['error']
Availability,"// Import hot CallTargets, which may not be available in IR because full; // profile annotation cannot be done until backend compilation in ThinLTO.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h:44,avail,available,44,interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h,2,['avail'],['available']
Availability,// Imported vtables are available externally.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGVTables.cpp:24,avail,available,24,interpreter/llvm-project/clang/lib/CodeGen/CGVTables.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGVTables.cpp,1,['avail'],['available']
Availability,"// Improve ""get low bit mask up to and including bit X"" pattern:; // (1 << X) | ((1 << X) + -1) --> -1 l>> (bitwidth(x) - 1 - X)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:24,mask,mask,24,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['mask'],['mask']
Availability,"// In -verify mode, print DIEs without children in error messages.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp:51,error,error,51,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp,1,['error'],['error']
Availability,"// In 64-bit mode, rlwinm and friends have a rotation operator that; // replicates the low-order 32 bits into the high-order 32-bits. The mask; // indices of these instructions can only be in the lower 32 bits, so they; // can only represent some 64-bit bit groups. However, when they can be used,; // the 32-bit replication can be used to represent, as a single bit group,; // otherwise separate bit groups. We'll convert to replicated-32-bit bit; // groups when possible. Returns true if any of the bit groups were; // converted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:138,mask,mask,138,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,"// In ARC, we may need to do extra work to keep all the keys and; // values alive until after the call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:76,alive,alive,76,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['alive'],['alive']
Availability,"// In AVX-512 architecture setcc returns mask with i1 elements,; // But there is no compare instruction for i8 and i16 elements in KNL.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:41,mask,mask,41,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// In C++ and OpenCL (spec v1.2 s6.9.f), we don't have any predefined; // library functions like 'malloc'. Instead, we'll just error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:127,error,error,127,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,1,['error'],['error']
Availability,"// In C++, don't return an invalid declaration. We can't recover well from; // the cases where we make the type anonymous.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:57,recover,recover,57,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['recover'],['recover']
Availability,"// In C++, we need to do a redeclaration lookup to properly; // diagnose some problems.; // FIXME: redeclaration lookup is also used (with and without C++) to find a; // hidden declaration so that we don't get ambiguity errors when using a; // type declared by an elaborated-type-specifier. In C that is not correct; // and we should instead merge compatible types found by lookup.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:220,error,errors,220,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['error'],['errors']
Availability,"// In C++11, the 'register' storage class specifier is deprecated.; // In C++17, it is not allowed, but we tolerate it as an extension.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:107,toler,tolerate,107,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['toler'],['tolerate']
Availability,"// In C++17, classes with non-virtual bases may be aggregates, so they would; // be initialized as aggregates without a constructor call, so we may have; // a base class constructed directly into an initializer list without; // having the derived-class constructor call on the previous stack frame.; // Initializer lists may be nested into more initializer lists that; // correspond to surrounding aggregate initializations.; // FIXME: For now this code essentially bails out. We need to find the; // correct target region and set it.; // FIXME: Instead of relying on the ParentMap, we should have the; // trigger-statement (InitListExpr in this case) passed down from CFG or; // otherwise always available during construction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:659,down,down,659,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,2,"['avail', 'down']","['available', 'down']"
Availability,"// In C, we allow this as a (popular) extension / bug. Don't bother; // producing further diagnostics for redundant qualifiers after this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:106,redundant,redundant,106,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['redundant'],['redundant']
Availability,"// In CL mode, don't error on apparently non-existent linker inputs, because; // they can be influenced by linker flags the clang driver might not; // understand.; // Examples:; // - `clang-cl main.cc ole32.lib` in a non-MSVC shell will make the driver; // module look for an MSVC installation in the registry. (We could ask; // the MSVCToolChain object if it can find `ole32.lib`, but the logic to; // look in the registry might move into lld-link in the future so that; // lld-link invocations in non-MSVC shells just work too.); // - `clang-cl ... /link ...` can pass arbitrary flags to the linker,; // including /libpath:, which is used to find .lib and .obj files.; // So do not diagnose this on the driver level. Rely on the linker diagnosing; // it. (If we don't end up invoking the linker, this means we'll emit a; // ""'linker' input unused [-Wunused-command-line-argument]"" warning instead; // of an error.); //; // Only do this skip after the typo correction step above. `/Brepo` is treated; // as TY_Object, but it's clearly a typo for `/Brepro`. It seems fine to emit; // an error if we have a flag that's within an edit distance of 1 from a; // flag. (Users can use `-Wl,` or `/linker` to launder the flag past the; // driver in the unlikely case they run into this.); //; // Don't do this for inputs that start with a '/', else we'd pass options; // like /libpath: through to the linker silently.; //; // Emitting an error for linker inputs can also cause incorrect diagnostics; // with the gcc driver. The command; // clang -fuse-ld=lld -Wl,--chroot,some/dir /file.o; // will make lld look for some/dir/file.o, while we will diagnose here that; // `/file.o` does not exist. However, configure scripts check if; // `clang /GR-` compiles without error to see if the compiler is cl.exe,; // so we can't downgrade diagnostics for `/GR-` from an error to a warning; // in cc mode. (We can in cl mode because cl.exe itself only warns on; // unknown flags.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:21,error,error,21,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,7,"['down', 'error']","['downgrade', 'error']"
Availability,"// In CUDA, there are some constructs which may appear in semantically-valid; // code, but trigger errors if we ever generate code for the function in which; // they appear. Essentially every construct you're not allowed to use on the; // device falls into this category, because you are allowed to use these; // constructs in a __host__ __device__ function, but only if that function is; // never codegen'ed on the device.; //; // To handle semantic checking for these constructs, we keep track of the set of; // functions we know will be emitted, either because we could tell a priori that; // they would be emitted, or because they were transitively called by a; // known-emitted function.; //; // We also keep a partial call graph of which not-known-emitted functions call; // which other not-known-emitted functions.; //; // When we see something which is illegal if the current function is emitted; // (usually by way of CUDADiagIfDeviceCode, CUDADiagIfHostCode, or; // CheckCUDACall), we first check if the current function is known-emitted. If; // so, we immediately output the diagnostic.; //; // Otherwise, we ""defer"" the diagnostic. It sits in Sema::DeviceDeferredDiags; // until we discover that the function is known-emitted, at which point we take; // it out of this map and emit the diagnostic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:99,error,errors,99,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp,1,['error'],['errors']
Availability,"// In MI, we only need low 32 bits of SrcMI, just consider about low 32; // bit of SrcMI mask. Note that in APInt, lowerest bit is at index 0,; // while in PowerPC ISA, lowerest bit is at index 63.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:89,mask,mask,89,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['mask'],['mask']
Availability,"// In MS C++ if you have a class with virtual functions in which you are using; // selective member import/export, then all virtual functions must be exported; // unless they are inline, otherwise a link error will result. To match this; // behavior, for such classes, we dllimport the vtable if it is defined; // externally and all the non-inline virtual methods are marked dllimport, and; // we dllexport the vtable if it is defined in this TU and all the non-inline; // virtual methods are marked dllexport.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp:204,error,error,204,interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,1,['error'],['error']
Availability,"// In Microsoft mode (below 19.28), prefer an integral conversion to a; // floating-to-integral conversion if the integral conversion; // is between types of the same size.; // For example:; // void f(float);; // void f(int);; // int main {; // long a;; // f(a);; // }; // Here, MSVC will call f(int) instead of generating a compile error; // as clang will do in standard mode.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:333,error,error,333,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['error'],['error']
Availability,"// In NaCl, instructions that must be masked are forbidden in delay slots.; // We only check for loads, stores and SP changes. Calls, returns and; // branches are not checked because non-NaCl targets never put them in; // delay slots.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp:38,mask,masked,38,interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp,1,['mask'],['masked']
Availability,// In Objective-C it is an error to use 'auto' on a function declarator; // (and everywhere for '__auto_type').,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:27,error,error,27,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,1,['error'],['error']
Availability,"// In Objective-C, message sends can send interfaces. In Objective-C++,; // all types are available due to functional casts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:90,avail,available,90,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,1,['avail'],['available']
Availability,"// In ThinLTO mode, when flattened profile is used, all the available; // profile information will be annotated in PreLink phase so there is; // no need to load the profile again in PostLink.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:60,avail,available,60,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,1,['avail'],['available']
Availability,"// In TypeScript, ""enum"" can also be used as property name, e.g. in interface; // declarations. An ""enum"" keyword followed by a colon would be a syntax; // error and thus assume it is just an identifier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:156,error,error,156,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,1,['error'],['error']
Availability,"// In Windows Itanium environments, try to mark runtime functions; // dllimport. For Mingw and MSVC, don't. We don't really know if the user; // will link their standard library statically or dynamically. Marking; // functions imported when they are not imported can cause linker errors; // and warnings.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp:280,error,errors,280,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,1,['error'],['errors']
Availability,"// In a Thumb instruction stream, a halfword is a standalone 2-byte; // instruction if and only if its value is less than 0xE800.; // Otherwise, it's the first halfword of a 4-byte instruction.; //; // So, if we can see the upcoming halfword, we can judge on that; // basis, and maybe skip a whole 4-byte instruction that we don't; // know how to decode, without accidentally trying to interpret its; // second half as something else.; //; // If we don't have the instruction data available, we just have to; // recommend skipping the minimum sensible distance, which is 2; // bytes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:481,avail,available,481,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,1,['avail'],['available']
Availability,"// In a debug build, scan through any files that may have been missed; // during parsing and issue a fatal error if directives are contained; // within these files. If a fatal error occurs, this suggests that; // this file is being parsed separately from the main file, in which; // case consider moving the directives to the correct place, if this; // is applicable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp:107,error,error,107,interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp,2,['error'],['error']
Availability,// In a record describing a template the type should be an; // InjectedClassNameType (see Sema::CheckClassTemplate). Update the; // previously set type to the correct value here (ToDescribed is not; // available at record create).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:202,avail,available,202,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['avail'],['available']
Availability,"// In a register that is covered by its sub-registers, try to find redundant; // sub-registers. For example:; //; // QQ0 = {Q0, Q1}; // Q0 = {D0, D1}; // Q1 = {D2, D3}; //; // We can infer that D1_D2 is also a sub-register, even if it wasn't named in; // the register definition.; //; // The explicitly specified registers form a tree. This function discovers; // sub-register relationships that would force a DAG.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp:67,redundant,redundant,67,interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp,1,['redundant'],['redundant']
Availability,"// In a relocatable output we might have many .ARM.exidx sections linked to; // their code sections via the sh_link field. For a non-relocatable ELF file; // the sh_link field is not reliable, because we have one .ARM.exidx section; // normally, but might have many code sections.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/ARMEHABIPrinter.h:183,reliab,reliable,183,interpreter/llvm-project/llvm/tools/llvm-readobj/ARMEHABIPrinter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/ARMEHABIPrinter.h,1,['reliab'],['reliable']
Availability,"// In addition to the cases above, we also disable Tail Call Optimization if; // the calling convention code that at least one outgoing argument needs to; // go on the stack. We cannot check that here because at this point that; // information is not available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:251,avail,available,251,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,1,['avail'],['available']
Availability,"// In big-endian mode we must adjust the pointer when the load size is smaller; // than the argument slot size. We must also reduce the known alignment to; // match. For example in the N64 ABI, we must add 4 bytes to the offset to get; // the correct half of the slot, and reduce the alignment from 8 (slot; // alignment) down to 4 (type alignment).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:322,down,down,322,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,1,['down'],['down']
Availability,"// In case Opc==SRL we've already prepared ExtVT/ExtType/ShAmt based on doing; // a right shift. Here we redo some of those checks, to possibly adjust the; // ExtVT even further based on ""a masking AND"". We could also end up here for; // other reasons (e.g. based on Opc==TRUNCATE) and that is why some checks; // need to be done here as well.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:190,mask,masking,190,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['masking']
Availability,"// In case of VersionID<=0 write dummy streamer only calling; // its base class Streamer(s). If no base class(es) let Streamer; // print error message, i.e. this Streamer should never have been called.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx:137,error,error,137,core/dictgen/src/rootcling_impl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx,1,['error'],['error']
Availability,"// In case of a Cling Error check components which are not found in Cling; // check that all formula components are matched otherwise emit an error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:22,Error,Error,22,hist/hist/src/TFormula.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx,2,"['Error', 'error']","['Error', 'error']"
Availability,"// In case of an error, let the declaration parsing code handle it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:17,error,error,17,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,3,['error'],['error']
Availability,// In case of inner pointer SVal is not available we create; // conjureSymbolVal for inner pointer value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp:40,avail,available,40,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp,1,['avail'],['available']
Availability,"// In case of multi-level nested loops, it may occur that lcssa phis exist in; // the latch of InnerLoop, i.e., when defs of the incoming values are further; // inside the loopnest. Sometimes those incoming values are not available; // after interchange, since the original inner latch will become the new outer; // latch which may have predecessor paths that do not include those incoming; // values.; // TODO: Handle transformation of lcssa phis in the InnerLoop latch in case of; // multi-level loop nests.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:222,avail,available,222,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,1,['avail'],['available']
Availability,"// In case the user re-routes the error handler to not die when Fatal is called",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferFile.cxx:34,error,error,34,io/io/src/TBufferFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferFile.cxx,30,['error'],['error']
Availability,"// In case there is no available scratch register, we can still read; // from RSP to assert that RSP points to a valid page. The write to RSP; // is also helpful because it verifies that the stack's write; // permissions are intact.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86LoadValueInjectionRetHardening.cpp:23,avail,available,23,interpreter/llvm-project/llvm/lib/Target/X86/X86LoadValueInjectionRetHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86LoadValueInjectionRetHardening.cpp,1,['avail'],['available']
Availability,"// In case we did not find an available XMM register for a vector -; // pass it indirectly.; // It is similar to CCPassIndirect, with the addition of inreg.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp:30,avail,available,30,interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp,1,['avail'],['available']
Availability,"// In case we exited early from the previous loop, there are other types to; // read from TypeStr. So we need to read them all to ensure we have the right; // number of arguments in TheCall and if it is not the case, to display a; // better error message.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:241,error,error,241,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['error'],['error']
Availability,"// In case when MaskVT equals v2i1 or v4i1, low 2 or 4 elements; // are extracted by EXTRACT_SUBVECTOR.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:16,Mask,MaskVT,16,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Mask'],['MaskVT']
Availability,// In error-recovery cases it's possible to get here even if we failed to; // synthesize the __begin and __end variables.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:6,error,error-recovery,6,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['error'],['error-recovery']
Availability,// In general we cannot safely assume that the subscripts recovered from GEPs; // are in the range of values defined for their corresponding array; // dimensions. For example some C language usage/interpretation make it; // impossible to verify this at compile-time. As such we can only delinearize; // iff the subscripts are positive and are less than the range of the; // dimension.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:58,recover,recovered,58,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,1,['recover'],['recovered']
Availability,"// In general, Instantiation isn't marked invalid to get more than one; // error for multiple undefined instantiations. But the code that does; // explicit declaration -> explicit definition conversion can't handle; // invalid declarations, so mark as invalid in that case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:75,error,error,75,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['error'],['error']
Availability,"// In general, for error recovery purposes, the initalizer doesn't play; // part in the valid bit of the declaration. There are a few exceptions:; // 1) if the var decl has a deduced auto type, and the type cannot be; // deduced by an invalid initializer;; // 2) if the var decl is decompsition decl with a non-deduced type, and; // the initialization fails (e.g. `int [a] = {1, 2};`);; // Case 1) was already handled elsewhere.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:19,error,error,19,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,2,"['error', 'recover']","['error', 'recovery']"
Availability,"// In general, we would need an 'and' for this transform, but; // canEvaluateShiftedShift() guarantees that the masked-off bits are not used.; // lshr (shl X, C1), C2 --> shl X, C1 - C2; // shl (lshr X, C1), C2 --> lshr X, C1 - C2",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:112,mask,masked-off,112,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,1,['mask'],['masked-off']
Availability,"// In implementations which use a barrier to achieve release semantics, we can; // delay emitting this barrier until we know a store is actually going to be; // attempted. The cost of this delay is that we need 2 copies of the block; // emitting the load-linked, affecting code size.; //; // Ideally, this logic would be unconditional except for the minsize check; // since in other cases the extra blocks naturally collapse down to the; // minimal loop. Unfortunately, this puts too much stress on later; // optimisations so we avoid emitting the extra logic in those cases too.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:425,down,down,425,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,1,['down'],['down']
Availability,"// In minimal SSA form, all Phi nodes are MultiVal.; // During conversion to SSA, incomplete Phi nodes may be introduced, which; // are later determined to be SingleVal, and are thus redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTIL.h:183,redundant,redundant,183,interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTIL.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTIL.h,1,['redundant'],['redundant']
Availability,"// In normal use, ASTUnit's diagnostics should not change unless we reparse.; // Currently they can only change by using the internal testing flag; // '-error-on-deserialized-decl' which will error during deserialization of; // a declaration. What will happen is:; //; // -c-index-test gets a CXTranslationUnit; // -checks the diagnostics, the diagnostics set is lazily created,; // no errors are reported; // -later does an operation, like annotation of tokens, that triggers; // -error-on-deserialized-decl, that will emit a diagnostic error,; // that ASTUnit will catch and add to its stored diagnostics vector.; // -c-index-test wants to check whether an error occurred after performing; // the operation but can only query the lazily created set.; //; // We check here if a new diagnostic was appended since the last time the; // diagnostic set was created, in which case we reset it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp:153,error,error-on-deserialized-decl,153,interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexDiagnostic.cpp,6,['error'],"['error', 'error-on-deserialized-decl', 'errors']"
Availability,"// In not opened state error state should always NoError, so comparison; // here is no problem.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:23,error,error,23,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,1,['error'],['error']
Availability,"// In order to be consistent, we clear the top down pointers when by adding; // BottomUpPathCount becomes OverflowOccurredValue even though ""true"" overflow; // has not occurred.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:47,down,down,47,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,1,['down'],['down']
Availability,"// In order to be consistent, we clear the top down pointers when by adding; // TopDownPathCount becomes OverflowOccurredValue even though ""true"" overflow; // has not occurred.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:47,down,down,47,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,1,['down'],['down']
Availability,"// In order to coalesce close-by pages, we collect the sizes of the gaps between pages on disk. We then order; // the gaps by size, sum them up and find a cutoff for the largest gap that we tolerate when coalescing pages.; // The size of the cutoff is given by the fraction of extra bytes we are willing to read in order to reduce; // the number of read requests. We thus schedule the lowest number of requests given a tolerable fraction; // of extra bytes.; // TODO(jblomer): Eventually we may want to select the parameter at runtime according to link latency and speed,; // memory consumption, device block size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageFile.cxx:190,toler,tolerate,190,tree/ntuple/v7/src/RPageStorageFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageFile.cxx,2,['toler'],"['tolerable', 'tolerate']"
Availability,"// In order to not have to add the equivalent to -I${PWD} to the; // command line, include the complete file name, even if it is a; // full pathname, when we write it down in the dictionary.; // Note: have -I${PWD} means in that (at least in the case of; // ACLiC) we inadvertently pick local file that have the same; // name as system header (e.g. new or list) and -iquote has not; // equivalent on some platforms.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx:167,down,down,167,core/dictgen/src/rootcling_impl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx,1,['down'],['down']
Availability,"// In order to provide direct access to remote sqlite files through HTTP and HTTPS, this datasource provides a custom; // ""SQlite VFS module"" that uses Davix for data access. The SQlite VFS modules are roughly what TSystem is; // for ROOT -- an abstraction of the operating system interface.; //; // SQlite allows for registering custom VFS modules, which are a set of C callback functions that SQlite invokes when; // it needs to read from a file, write to a file, etc. More information is available under https://sqlite.org/vfs.html; //; // In the context of a data source, SQlite will only ever call reading functions from the VFS module, the sqlite; // files are not modified. Therefore, only a subset of the callback functions provide a non-trivial implementation.; // The custom VFS module uses a RRawFile for the byte access, thereby it can access local and remote files.; ////////////////////////////////////////////////////////////////////////////; /// SQlite VFS modules are identified by string names. The name has to be unique for the entire application.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx:491,avail,available,491,tree/dataframe/src/RSqliteDS.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx,1,['avail'],['available']
Availability,"// In production code, we would expect error handling code other than throw",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/v7/test/base_exception.cxx:39,error,error,39,core/foundation/v7/test/base_exception.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/v7/test/base_exception.cxx,1,['error'],['error']
Availability,"// In rare cases, there are trivial arithmetic ops in source operands. Sink; // this assert down to source operands so that those arithmetic ops could be; // exposed to the DAG combining.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:92,down,down,92,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['down'],['down']
Availability,// In some calling conventions we need to remove the used physical registers; // from the reg mask. Create a new RegMask for such calling conventions.; // RegMask for calling conventions that disable only return registers (e.g.; // preserve_most) will be modified later in LowerCallResult.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp:94,mask,mask,94,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,1,['mask'],['mask']
Availability,// In some calling conventions we need to remove the used registers; // from the register mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp:90,mask,mask,90,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,1,['mask'],['mask']
Availability,"// In some error cases, the input could be Nothing; skip those.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp:11,error,error,11,interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp,1,['error'],['error']
Availability,"// In the MS C++ ABI, the compiler emits destructor variants where they are; // used. If the destructor is used here but defined elsewhere, mark the; // virtual base destructors referenced. If those virtual base destructors; // are inline, this will ensure they are defined when emitting the complete; // destructor variant. This checking may be redundant if the destructor is; // provided later in this TU.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:346,redundant,redundant,346,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['redundant'],['redundant']
Availability,"// In the both nodes address is Op1, mask is Op2:; // MaskedGatherSDNode (Chain, passthru, mask, base, index, scale); // MaskedScatterSDNode (Chain, value, mask, base, index, scale); // Mask is a vector of i1 elements",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:37,mask,mask,37,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,6,"['Mask', 'mask']","['Mask', 'MaskedGatherSDNode', 'MaskedScatterSDNode', 'mask']"
Availability,"// In the both nodes address is Op1, mask is Op2:; // VPGatherSDNode (Chain, base, index, scale, mask, vlen); // VPScatterSDNode (Chain, value, base, index, scale, mask, vlen); // Mask is a vector of i1 elements",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:37,mask,mask,37,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,4,"['Mask', 'mask']","['Mask', 'mask']"
Availability,"// In the case Repl is a load or a store, we make all their GEPs; // available: GEPs are not hoisted by default to avoid the address; // computations to be hoisted without the associated load or store.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:69,avail,available,69,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,1,['avail'],['available']
Availability,"// In the case of a Mach-O STAB symbol, get its section only if; // the STAB symbol's section field refers to a valid section index.; // Otherwise the symbol may error trying to load a section that; // does not exist.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVELFReader.cpp:162,error,error,162,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVELFReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVELFReader.cpp,1,['error'],['error']
Availability,// In the case of a truncating shuffle it's possible for the mask; // to have an index greater than the size of the resulting vector.; // This requires special handling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:61,mask,mask,61,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,1,['mask'],['mask']
Availability,"// In the case of an atomicrmw xchg with a constant 0/-1 operand, replace; // the atomic instruction with an AtomicRMWInst::And/Or with appropriate; // mask, as this produces better code than the LL/SC loop emitted by; // int_loongarch_masked_atomicrmw_xchg.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:152,mask,mask,152,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,1,['mask'],['mask']
Availability,"// In the case of an atomicrmw xchg with a constant 0/-1 operand, replace; // the atomic instruction with an AtomicRMWInst::And/Or with appropriate; // mask, as this produces better code than the LR/SC loop emitted by; // int_riscv_masked_atomicrmw_xchg.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:152,mask,mask,152,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['mask'],['mask']
Availability,"// In the case of multiple select instructions in the same group, the order; // of non-dependent instructions (instructions of different dependence; // slices) in the true/false blocks appears to affect performance.; // Interleaving the slices seems to experimentally be the optimal approach.; // This interleaving scheduling allows for more ILP (with a natural downside; // of increasing a bit register pressure) compared to a simple ordering of; // one whole chain after another. One would expect that this ordering would; // not matter since the scheduling in the backend of the compiler would; // take care of it, but apparently the scheduler fails to deliver optimal; // ILP with a naive ordering here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:362,down,downside,362,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,1,['down'],['downside']
Availability,"// In the case of unnamed scopes, try to generate a name for it, using; // the parents name and the line information. In the case of compiler; // generated functions, use its linkage name if is available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVScope.cpp:194,avail,available,194,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVScope.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVScope.cpp,1,['avail'],['available']
Availability,"// In the case the method to call was not selected by the overloading; // resolution process, we still need to handle the enable_if attribute. Do; // that here, so it will not hide previous -- and more relevant -- errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:214,error,errors,214,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['error'],['errors']
Availability,"// In the case where we parse an expression starting with a '.', we will; // not generate an error, nor will we create a symbol. In this case we; // should just return out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp:93,error,error,93,interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,1,['error'],['error']
Availability,"// In the epilogue, addi sp, sp, 496 is used to recover the sp and it; // can be compressed(C.ADDI16SP, offset can be [-512, 496]), but; // addi sp, sp, 512 can not be compressed. So try to use 496 first.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:48,recover,recover,48,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,1,['recover'],['recover']
Availability,"// In the fully general case, we need to handle NaNs and infinities; // robustly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:72,robust,robustly,72,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['robust'],['robustly']
Availability,"// In the function PPCFunctionInfo::getParmsType(), when there are no vector; // parameters, the 31st bit of ParmsType is always zero even if it indicates a; // floating point parameter. The parameter type information is lost. There; // are only 8 GPRs used for parameters passing, the floating parameters; // also occupy GPRs if there are available, so the 31st bit can never be a; // fixed parameter. At the same time, we also do not know whether the zero of; // the 31st bit indicates a float or double parameter type here. Therefore, we; // ignore the 31st bit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/XCOFF.cpp:340,avail,available,340,interpreter/llvm-project/llvm/lib/BinaryFormat/XCOFF.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/XCOFF.cpp,1,['avail'],['available']
Availability,"// In the inverse CFG, the dominance frontier of basic block (BB) is the; // point where ANTIC needs to be computed for instructions which are going; // to be hoisted. Since this point does not change during gvn-hoist,; // we compute it only once (on demand).; // The ides is inspired from:; // ""Partial Redundancy Elimination in SSA Form""; // ROBERT KENNEDY, SUN CHAN, SHIN-MING LIU, RAYMOND LO, PENG TU and FRED CHOW; // They use similar idea in the forward graph to find fully redundant and; // partially redundant expressions, here it is used in the inverse graph to; // find fully anticipable instructions at merge point (post-dominator in; // the inverse CFG).; // Returns the edge via which an instruction in BB will get the values from.; // Returns true when the values are flowing out to each edge.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:480,redundant,redundant,480,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,2,['redundant'],['redundant']
Availability,"// In the more general case, we can clear the high bits after the shift:; // srl (trunc (srl x, c1)), c2 --> trunc (and (srl x, (c1+c2)), Mask)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:138,Mask,Mask,138,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['Mask'],['Mask']
Availability,"// In the past, when Minuit2 was not the default minimizer yet, there was; // also a check that the number of invalid NLL evaluations was reduced with; // the error recovery:; //; // EXPECT_LT(fitResultNew->numInvalidNLL(), fitResultOld->numInvalidNLL());; //; // However, Minuit2 takes less evaluations to realize that the minimization; // without error recovery is hopeless, resulting in less invalid NLL; // evaluations when the error recovery is off. Hence, the comparison is not; // meaningful and was commended out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testNaNPacker.cxx:159,error,error,159,roofit/roofitcore/test/testNaNPacker.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testNaNPacker.cxx,6,"['error', 'recover']","['error', 'recovery']"
Availability,"// In the presence of variable sized objects or funclets, if the fixed stack; // size is large enough that referencing from the FP won't result in things; // being in range relatively often, we can use a base pointer to allow access; // from the other direction like the SP normally works.; //; // Furthermore, if both variable sized objects are present, and the; // stack needs to be dynamically re-aligned, the base pointer is the only; // reliable way to reference the locals.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64RegisterInfo.cpp:442,reliab,reliable,442,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64RegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64RegisterInfo.cpp,1,['reliab'],['reliable']
Availability,"// In the register calling convention, up to one FP argument could be; // saved in the first FP register.; // If bundle.mask is non-zero and Bundle.FixCount is zero, it means; // that the FP registers contain arguments.; // The actual value is passed in FP0.; // Here we fix the stack and mark FP0 as pre-assigned register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp:120,mask,mask,120,interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp,1,['mask'],['mask']
Availability,"// In theory, the filename component should also be canonicalized if it; // on a case-insensitive filesystem. However, the extra canonicalization is; // expensive and if clang looked up the filename it will always be lowercase.; // Remove ., remove redundant separators, and switch to native separators.; // This is needed for separators between CanonicalDir and the filename.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:249,redundant,redundant,249,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,1,['redundant'],['redundant']
Availability,"// In this case we can ignore an error, because we have already reported a; // warning about the broken section header table earlier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp:33,error,error,33,interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp,2,['error'],['error']
Availability,"// In this test, we setup a model that we know will give evaluation errors, because Minuit will try parameters; // outside of the physical range during line search. Using the error handling mechanism in RooMinimizerFcn and; // MinuitFcnGrad, Minuit should get sent out of this area again.; // Specifically, this test triggers the classic error handling mechanism (logEvalError).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/TestStatistics/testLikelihoodGradientJob.cxx:68,error,errors,68,roofit/roofitcore/test/TestStatistics/testLikelihoodGradientJob.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/TestStatistics/testLikelihoodGradientJob.cxx,3,['error'],"['error', 'errors']"
Availability,// Include GetLastError() in a fatal error message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Windows/WindowsSupport.h:37,error,error,37,interpreter/llvm-project/llvm/include/llvm/Support/Windows/WindowsSupport.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Windows/WindowsSupport.h,1,['error'],['error']
Availability,// Include StrError(errnum) in a fatal error message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Unix/Unix.h:39,error,error,39,interpreter/llvm-project/llvm/lib/Support/Unix/Unix.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Unix/Unix.h,1,['error'],['error']
Availability,"// Include the component table. This creates an array of struct; // AvailableComponent entries, which record the component name, library name,; // and required components for all of the available libraries.; //; // Not all components define a library, we also use ""library groups"" as a way to; // create entries for pseudo groups like x86 or all-targets.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:68,Avail,AvailableComponent,68,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,2,"['Avail', 'avail']","['AvailableComponent', 'available']"
Availability,"// Includes an error, and depends on how it is resolved.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h:15,error,error,15,interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h,1,['error'],['error']
Availability,"// Increase the value of the diagnostics pointing out from which; // dictionary this payload comes from in case of errors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/TModuleGenerator.cxx:115,error,errors,115,core/dictgen/src/TModuleGenerator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/TModuleGenerator.cxx,1,['error'],['errors']
Availability,// Incrementing the pointer according to number of '1's in the mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:63,mask,mask,63,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['mask'],['mask']
Availability,// Index of the first operand which holds a non-mask vector operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:48,mask,mask,48,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['mask'],['mask']
Availability,// Indicates if ranges data are available; in the case of split DWARF any; // reference to ranges is valid only if the skeleton DIE has been loaded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/LogicalView/Readers/LVELFReader.h:32,avail,available,32,interpreter/llvm-project/llvm/include/llvm/DebugInfo/LogicalView/Readers/LVELFReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/LogicalView/Readers/LVELFReader.h,1,['avail'],['available']
Availability,// Indicates it is profitable to form an AVX512 masked operation. Returning; // false will favor a masked register-register masked move or vblendm and the; // operation will be selected separately.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:48,mask,masked,48,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,3,['mask'],['masked']
Availability,"// Indirect tail calls cannot be optimized for Thumb1 if the args; // to the call take up r0-r3. The reason is that there are no legal registers; // left to hold the pointer to the function to be called.; // Similarly, if the function uses return address sign and authentication,; // r12 is needed to hold the PAC and is not available to hold the callee; // address.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:325,avail,available,325,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['avail'],['available']
Availability,// Infer Mac Catalyst availability from the macOS availability attribute; // if it has versioned availability. Don't infer 'unavailable'. This; // inferred availability has lower priority than the other availability; // attributes that are inferred from 'ios'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:22,avail,availability,22,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,5,['avail'],['availability']
Availability,"// Infer as many types as possible. Don't worry about it if we don't infer; // all of them, some may depend on the inputs of the pattern. Also, don't; // validate type sets; validation may cause spurious failures e.g. if a; // fragment needs floating-point types but the current target does not have; // any (this is only an error if that fragment is ever used!).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp:204,failure,failures,204,interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,2,"['error', 'failure']","['error', 'failures']"
Availability,"// Infinite loops need special handling. If we give the back edge an infinite; // mass, they may saturate all the other scales in the function down to 1,; // making all the other region temperatures look exactly the same. Choose an; // arbitrary scale to avoid these issues.; //; // FIXME: An alternate way would be to select a symbolic scale which is later; // replaced to be the maximum of all computed scales plus 1. This would; // appropriately describe the loop as having a large scale, without skewing; // the final frequency computation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:143,down,down,143,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,1,['down'],['down']
Availability,"// Inform caller that recovery failed, the error must be handled at upper; // level. This will generate the desired ""missing '}' at end of module""; // diagnostics on the way out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:22,recover,recovery,22,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp,2,"['error', 'recover']","['error', 'recovery']"
Availability,"// Information about available colors.; //; // The widget will use at most N_COLOR colors. 4 of these colors are; // predefined. The rest are user selectable by options to various markups.; // (Ex: <font color=red>); //; // All colors are stored in the apColor[] array of the main widget object.; // The "".color"" field of the SHtmlStyle_t is an integer between 0 and; // N_COLOR-1 which indicates which of these colors to use.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/inc/TGHtml.h:21,avail,available,21,gui/guihtml/inc/TGHtml.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/inc/TGHtml.h,1,['avail'],['available']
Availability,"// Information not yet available",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:23,avail,available,23,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,1,['avail'],['available']
Availability,"// Init error handlers",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/DaemonUtils.cxx:8,error,error,8,net/rpdutils/src/DaemonUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/DaemonUtils.cxx,1,['error'],['error']
Availability,// Initialise a new builder with the iteration count expression. In; // combination with the value's SCEV this enables recovery.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:119,recover,recovery,119,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,1,['recover'],['recovery']
Availability,"// Initialization is not going well, but we still have to commit what; // we've been given. Don't clear the DiagnosticsConsumer so the caller; // can inspect any errors that have been generated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Interpreter.cpp:162,error,errors,162,interpreter/cling/lib/Interpreter/Interpreter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Interpreter.cpp,1,['error'],['errors']
Availability,// Initialize AvailableFunctionAttrs and AvailableSomewhereAttrs; // summary bitsets.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Attributes.cpp:14,Avail,AvailableFunctionAttrs,14,interpreter/llvm-project/llvm/lib/IR/Attributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Attributes.cpp,2,['Avail'],"['AvailableFunctionAttrs', 'AvailableSomewhereAttrs']"
Availability,// Initialize AvailableIn/Out sets of each BB using only information about; // dominating BBs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:14,Avail,AvailableIn,14,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,1,['Avail'],['AvailableIn']
Availability,"// Initialize errors with hesse",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/FitHelpers.cxx:14,error,errors,14,roofit/roofitcore/src/FitHelpers.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/FitHelpers.cxx,1,['error'],['errors']
Availability,// Initialize mask to undef.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:14,mask,mask,14,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['mask']
Availability,// Initialize the set of available features.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp:25,avail,available,25,interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp,9,['avail'],['available']
Availability,// Initialize the splat index to the 1st non-negative mask element.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:54,mask,mask,54,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,1,['mask'],['mask']
Availability,// Initialize to a non-error state.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp:23,error,error,23,interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp,1,['error'],['error']
Availability,// Initializers are unimplemented for LDS address space.; // Leave such variables in place for consistent error reporting.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUMemoryUtils.cpp:106,error,error,106,interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUMemoryUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUMemoryUtils.cpp,1,['error'],['error']
Availability,"// Input echo",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/TGWin32.cxx:9,echo,echo,9,graf2d/win32gdk/src/TGWin32.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/TGWin32.cxx,2,['echo'],['echo']
Availability,"// Input event masks, used to set SetWindowAttributes_t::fEventMask; // and to be passed to TVirtualX::SelectInput()",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/gui/inc/GuiTypes.h:15,mask,masks,15,core/gui/inc/GuiTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/gui/inc/GuiTypes.h,1,['mask'],['masks']
Availability,// Input operand modifiers bit-masks; // NEG and SEXT share same bit-mask because they can't be set simultaneously.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIDefines.h:31,mask,masks,31,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIDefines.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIDefines.h,2,['mask'],"['mask', 'masks']"
Availability,// Insert VXRM write if anticipated and not available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp:44,avail,available,44,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp,1,['avail'],['available']
Availability,// Insert a copy from source to the end of the block. The def register is the; // available value liveout of the block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:82,avail,available,82,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,1,['avail'],['available']
Availability,"// Insert a faulting instruction where the conditional branch was; // originally. We check earlier ensures that this bit of code motion; // is legal. We do not touch the successors list for any basic block; // since we haven't changed control flow, we've just made it implicit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:12,fault,faulting,12,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,1,['fault'],['faulting']
Availability,// Insert a new mask to keep the shift amount legal. This should be removed; // by isel patterns.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:16,mask,mask,16,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,"// Insert a trivial phi at the exit block (where the CHR hot path and the; // cold path merges) for a value that's defined in the scope but used; // outside it (meaning it's alive at the exit block). We will add the; // incoming values for the CHR cold paths to it below. Without this, we'd; // miss updating phi's for such values unless there happens to already be a; // phi for that value there.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:174,alive,alive,174,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,1,['alive'],['alive']
Availability,"// Insert alignment padding, we need 16-byte alignment. Note: for positive; // number the alignment formula is : y = (x + (n-1)) & (~(n-1)). But since; // we are using negative number here (the stack grows downward). We should; // use formula : y = x & (~(n-1)). Where x is the size before aligning, n; // is the alignment size ( n = 16 here) and y is the size after aligning.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:206,down,downward,206,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,1,['down'],['downward']
Availability,"// Insert error band in plot frame",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:10,error,error,10,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,1,['error'],['error']
Availability,// Insert mask and evl operands in between the instruction operands.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VectorBuilder.cpp:10,mask,mask,10,interpreter/llvm-project/llvm/lib/IR/VectorBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VectorBuilder.cpp,1,['mask'],['mask']
Availability,// Insert neutral element in masked-out positions,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp:29,mask,masked-out,29,interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,1,['mask'],['masked-out']
Availability,"// Insert spill or restore instructions.; // When lowering spill pseudos, the RegScavenger should be set.; // For creating spill instructions during frame lowering, where no scavenger; // is available, LiveUnits can be used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.h:191,avail,available,191,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.h,1,['avail'],['available']
Availability,// Insert the defined registers into the list of available registers; // after they have been processed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp:49,avail,available,49,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp,1,['avail'],['available']
Availability,// Insert the element into the desired chunk.; // Since NumEltsIn128 is a power of 2 we can use mask instead of modulo.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:96,mask,mask,96,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Insert the extracted elements into the mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:42,mask,mask,42,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// Insert the second operand into the first operand.; // Note that there is no guarantee that instruction lowering will actually; // produce a vinsertf128 instruction for the created shuffles. In; // particular, the 0 immediate case involves no lane changes, so it can; // be handled as a blend.; // Example of shuffle mask for 32-bit elements:; // Imm = 1 <i32 0, i32 1, i32 2, i32 3, i32 8, i32 9, i32 10, i32 11>; // Imm = 0 <i32 8, i32 9, i32 10, i32 11, i32 4, i32 5, i32 6, i32 7 >; // First fill with identify mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:319,mask,mask,319,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,2,['mask'],['mask']
Availability,"// InsertAt points at the first instruction that will be removed. We need; // to move it out of the way, so it remains valid after removing all the; // old stores, and so we are able to recover it back to the proper insertion; // position.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp:186,recover,recover,186,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp,1,['recover'],['recover']
Availability,"// Insertion failed, the user supplied this package/checker option on the; // command line. If the supplied value is invalid, we'll restore the option; // to it's default value, and if we're in non-compatibility mode, we'll also; // emit an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:241,error,error,241,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,1,['error'],['error']
Availability,// Inspect the supplied flags string and set the bits in the mask for; // the relevant and valid flags allowed for cpsr and spsr.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp:61,mask,mask,61,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,"// InstCombine may have combined a constant shl, srl, mul, or udiv with one; // side of the rotate, so try to handle that here. In all cases we need to; // pass the matched shift from the opposite side to compute the opcode and; // needed shift amount to extract. We still want to do this if both sides; // matched a rotate half because one half may be a potential overshift that; // can be broken down (ie if InstCombine merged two shl or srl ops into a; // single one).; // Have LHS side of the rotate, try to extract the needed shift from the RHS.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:398,down,down,398,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['down'],['down']
Availability,"// Install SigPipe handler to handle kKeepAlive failure",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServLite.cxx:48,failure,failure,48,proof/proof/src/TProofServLite.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServLite.cxx,1,['failure'],['failure']
Availability,// Installs new handler that causes crash on allocation failure. It is called by; // InitLLVM.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ErrorHandling.cpp:56,failure,failure,56,interpreter/llvm-project/llvm/lib/Support/ErrorHandling.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ErrorHandling.cpp,1,['failure'],['failure']
Availability,"// Instantiating this base template definition should never happen and is an error!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField/RFieldFundamental.hxx:77,error,error,77,tree/ntuple/v7/inc/ROOT/RField/RFieldFundamental.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField/RFieldFundamental.hxx,1,['error'],['error']
Availability,"// Instcombine's ShrinkDemandedConstant may strip bits out of; // constants, obscuring what would otherwise be a low-bits mask.; // Use computeKnownBits to compute what ShrinkDemandedConstant; // knew about to reconstruct a low-bits mask value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:122,mask,mask,122,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,2,['mask'],['mask']
Availability,"// Instead of casting everything to bytes for the vselect, cast to the; // original value type. This will avoid complications with casting masks.; // For example, in cases when the original mask applied to i32, it could; // be converted to a mask applicable to i8 via pred_typecast intrinsic,; // but if the mask is not exactly of HVX length, extra handling would be; // needed to make it work.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:139,mask,masks,139,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,4,['mask'],"['mask', 'masks']"
Availability,"// Instead of explictly marking kernels that access dynamic variables; // using special case metadata, annotate with min-lds == max-lds, i.e.; // that there is no more space available for allocating more static; // LDS variables. That is the right condition to prevent allocating; // more variables which would collide with the addresses assigned to; // dynamic variables.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp:174,avail,available,174,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,1,['avail'],['available']
Availability,"// Instruction Parsing. Each instruction parsing routine can return with a; // normal result, an error result, or return having eaten an extra comma.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h:97,error,error,97,interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h,1,['error'],['error']
Availability,// Instruction will error in AMDGPUAsmParser::MatchAndEmitInstruction,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp:20,error,error,20,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp,1,['error'],['error']
Availability,"// Instructions dispatched to the Scheduler are internally classified based on; // the instruction stage (see Instruction::InstrStage).; //; // An Instruction dispatched to the Scheduler is added to the WaitSet if not; // all its register operands are available, and at least one latency is; // unknown. By construction, the WaitSet only contains instructions that are; // in the IS_DISPATCHED stage.; //; // An Instruction transitions from the WaitSet to the PendingSet if the; // instruction is not ready yet, but the latency of every register read is; // known. Instructions in the PendingSet can only be in the IS_PENDING or; // IS_READY stage. Only IS_READY instructions that are waiting on memory; // dependencies can be added to the PendingSet.; //; // Instructions in the PendingSet are immediately dominated only by; // instructions that have already been issued to the underlying pipelines. In; // the presence of bottlenecks caused by data dependencies, the PendingSet can; // be inspected to identify problematic data dependencies between; // instructions.; //; // An instruction is moved to the ReadySet when all register operands become; // available, and all memory dependencies are met. Instructions that are; // moved from the PendingSet to the ReadySet must transition to the 'IS_READY'; // stage.; //; // On every cycle, the Scheduler checks if it can promote instructions from the; // PendingSet to the ReadySet.; //; // An Instruction is moved from the ReadySet to the `IssuedSet` when it starts; // exection. This event also causes an instruction state transition (i.e. from; // state IS_READY, to state IS_EXECUTING). An Instruction leaves the IssuedSet; // only when it reaches the write-back stage.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h:252,avail,available,252,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h,2,['avail'],['available']
Availability,// Instructions marked for predication are replicated and a mask operand is; // added initially. Masked replicate recipes will later be placed under an; // if-then construct to prevent side-effects. Generate recipes to compute; // the block mask for this region.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:60,mask,mask,60,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,3,"['Mask', 'mask']","['Masked', 'mask']"
Availability,"// Instructions used for type-casts of the induction variable,; // that are redundant when guarded with a runtime SCEV overflow check.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h:76,redundant,redundant,76,interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,1,['redundant'],['redundant']
Availability,// Instructions with mask or 512-bit vector can't be converted to VEX.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CompressEVEX.cpp:21,mask,mask,21,interpreter/llvm-project/llvm/lib/Target/X86/X86CompressEVEX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CompressEVEX.cpp,1,['mask'],['mask']
Availability,// Instrument vector.reduce.and intrinsic.; // Valid (non-poisoned) unset bits in the operand pull down the; // corresponding shadow bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:99,down,down,99,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,1,['down'],['down']
Availability,"// Instrumenting some of the accesses may be proven redundant.; // Currently handled:; // - read-before-write (within same BB, no calls between); // - not captured variables; //; // We do not handle some of the patterns that should not survive; // after the classic compiler optimizations.; // E.g. two reads from the same temp should be eliminated by CSE,; // two writes should be eliminated by DSE, etc.; //; // 'Local' is a vector of insns within the same BB (no calls between).; // 'All' is a vector of insns that will be instrumented.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:52,redundant,redundant,52,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,1,['redundant'],['redundant']
Availability,"// Insure that the files, canvases and sockets are closed.; // If we get here, the tear down has started. We have no way to know what; // has or has not yet been done. In particular on Ubuntu, this was called; // after the function static in TSystem.cxx has been destructed. So we; // set gROOT in its end-of-life mode which prevents executing code, like; // autoloading libraries (!) that is pointless ...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx:88,down,down,88,core/base/src/TApplication.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx,1,['down'],['down']
Availability,"// Intentionally ignore invokes here -- since the catchswitch is; // marked ""unwind to caller"", it would be a verifier error if it; // contained an invoke which unwinds out of it, so any invoke we'd; // encounter must unwind to some child of the catch.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:119,error,error,119,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,1,['error'],['error']
Availability,"// Intentionally ignore the Fatal error due to the shread thread-local storage.; // In this test we need to be 'careful' to not use all those mutex at the same time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/thread/test/testRWLock.cxx:34,error,error,34,core/thread/test/testRWLock.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/thread/test/testRWLock.cxx,1,['error'],['error']
Availability,"// Intentionally use struct instead of pair because we don't need default; // init.; // Add macro decls to be able to revert them for error recovery.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/Transaction.h:134,error,error,134,interpreter/cling/include/cling/Interpreter/Transaction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/Transaction.h,2,"['error', 'recover']","['error', 'recovery']"
Availability,// Interleave-store-group with gaps is implemented using masked wide store.; // Remove interleaved store groups with gaps if; // masked-interleaved-accesses are not enabled by the target.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:57,mask,masked,57,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,2,['mask'],"['masked', 'masked-interleaved-accesses']"
Availability,"// InterleavedLoadCombine; /// First Order Polynomial on an n-Bit Integer Value; ///; /// Polynomial(Value) = Value * B + A + E*2^(n-e); ///; /// A and B are the coefficients. E*2^(n-e) is an error within 'e' most; /// significant bits. It is introduced if an exact computation cannot be proven; /// (e.q. division by 2).; ///; /// As part of this optimization multiple loads will be combined. It necessary; /// to prove that loads are within some relative offset to each other. This; /// class is used to prove relative offsets of values loaded from memory.; ///; /// Representing an integer in this form is sound since addition in two's; /// complement is associative (trivial) and multiplication distributes over the; /// addition (see Proof(1) in Polynomial::mul). Further, both operations; /// commute.; //; // Example:; // declare @fn(i64 %IDX, <4 x float>* %PTR) {; // %Pa1 = add i64 %IDX, 2; // %Pa2 = lshr i64 %Pa1, 1; // %Pa3 = getelementptr inbounds <4 x float>, <4 x float>* %PTR, i64 %Pa2; // %Va = load <4 x float>, <4 x float>* %Pa3; //; // %Pb1 = add i64 %IDX, 4; // %Pb2 = lshr i64 %Pb1, 1; // %Pb3 = getelementptr inbounds <4 x float>, <4 x float>* %PTR, i64 %Pb2; // %Vb = load <4 x float>, <4 x float>* %Pb3; // ... }; //; // The goal is to prove that two loads load consecutive addresses.; //; // In this case the polynomials are constructed by the following; // steps.; //; // The number tag #e specifies the error bits.; //; // Pa_0 = %IDX #0; // Pa_1 = %IDX + 2 #0 | add 2; // Pa_2 = %IDX/2 + 1 #1 | lshr 1; // Pa_3 = %IDX/2 + 1 #1 | GEP, step signext to i64; // Pa_4 = (%IDX/2)*16 + 16 #0 | GEP, multiply index by sizeof(4) for floats; // Pa_5 = (%IDX/2)*16 + 16 #0 | GEP, add offset of leading components; //; // Pb_0 = %IDX #0; // Pb_1 = %IDX + 4 #0 | add 2; // Pb_2 = %IDX/2 + 2 #1 | lshr 1; // Pb_3 = %IDX/2 + 2 #1 | GEP, step signext to i64; // Pb_4 = (%IDX/2)*16 + 32 #0 | GEP, multiply index by sizeof(4) for floats; // Pb_5 = (%IDX/2)*16 + 16 #0 | GEP, add offset of l",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:192,error,error,192,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,1,['error'],['error']
Availability,"// Interrupt, exception, error trap Return",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h:25,error,error,25,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,1,['error'],['error']
Availability,// Intersect the variable slice with AssignRecord's fragment to trim it down; // to size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:72,down,down,72,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,1,['down'],['down']
Availability,"// Intrinsic @llvm.get.active.lane.mask is supported.; // It is used in the MVETailPredication pass, which requires the number of; // elements processed by this vector loop to setup the tail-predicated; // loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:35,mask,mask,35,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,1,['mask'],['mask']
Availability,// Introduce DefRegs set to skip the redundant register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp:37,redundant,redundant,37,interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp,1,['redundant'],['redundant']
Availability,"// Introduce the early-exit compare IV <= BTC to form header block mask.; // This is used instead of IV < TC because TC may wrap, unlike BTC. Start by; // constructing the desired canonical IV in the header block as its first; // non-phi instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:67,mask,mask,67,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['mask'],['mask']
Availability,// Invalid UTF is not a JSON error (RFC 8529§8.2). It gets replaced by U+FFFD.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/JSON.cpp:29,error,error,29,interpreter/llvm-project/llvm/lib/Support/JSON.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/JSON.cpp,1,['error'],['error']
Availability,"// Invalid array specification.; // FIXME: We need an error message here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:54,error,error,54,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['error'],['error']
Availability,// Invalid types must be hard errors for SFINAE in C++.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:30,error,errors,30,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['error'],['errors']
Availability,"// Invalid, punt to a verifier error.; // Check if the tag uses struct-path aware TBAA format.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:31,error,error,31,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,1,['error'],['error']
Availability,// Invalidate AAManager so it can be recreated and pick up the newly; // available GlobalsAA.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:73,avail,available,73,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,2,['avail'],['available']
Availability,// Invalidate all created iterator declarations if error is found.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:51,error,error,51,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,2,['error'],['error']
Availability,// Invalidate the decl as we don't know the type for recovery-expr yet.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:53,recover,recovery-expr,53,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['recover'],['recovery-expr']
Availability,// Invert mask and erase bits for types of instructions that are implied to be; // allowed past the SCHED_BARRIER.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp:10,mask,mask,10,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp,1,['mask'],['mask']
Availability,// Invert mask for s_andn2,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIPreEmitPeephole.cpp:10,mask,mask,10,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIPreEmitPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIPreEmitPeephole.cpp,1,['mask'],['mask']
Availability,// Invert the mask to only clear the lower bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:14,mask,mask,14,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,1,['mask'],['mask']
Availability,// Invert the mask. NOTE: if we had native ROL instructions we could; // use inverted mask,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ISelLowering.cpp:14,mask,mask,14,interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ISelLowering.cpp,2,['mask'],['mask']
Availability,"// Is LR available? If so, we don't need a save.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:9,avail,available,9,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['avail'],['available']
Availability,// Is Line an #error directive mentioning includes?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Inclusions/HeaderAnalysis.cpp:15,error,error,15,interpreter/llvm-project/clang/lib/Tooling/Inclusions/HeaderAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Inclusions/HeaderAnalysis.cpp,1,['error'],['error']
Availability,// Is a comma available to be removed?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:14,avail,available,14,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,1,['avail'],['available']
Availability,"// Is an unused register available? If so, we won't modify the stack, so; // we can outline with the same frame type as those that don't save LR.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:25,avail,available,25,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,2,['avail'],['available']
Availability,// Is it alive in this successor?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:9,alive,alive,9,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,1,['alive'],['alive']
Availability,"// Is it icmp eq (X & Mask), 0 already?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:22,Mask,Mask,22,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['Mask'],['Mask']
Availability,// Is it the same file and same offset? Provide more information on why; // this leads to a redefinition error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:105,error,error,105,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['error'],['error']
Availability,"// Is one of the operands an AND or a BICi? The AND may have been optimised to; // a BICi in order to use an immediate instead of a register.; // Is the other operand an shl or lshr? This will have been turned into:; // AArch64ISD::VSHL vector, #shift or AArch64ISD::VLSHR vector, #shift; // or (AArch64ISD::SHL_PRED || AArch64ISD::SRL_PRED) mask, vector, #shiftVec.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:342,mask,mask,342,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['mask'],['mask']
Availability,// Is option available in OpenCL version \p LO.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/OpenCLOptions.h:13,avail,available,13,interpreter/llvm-project/clang/include/clang/Basic/OpenCLOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/OpenCLOptions.h,1,['avail'],['available']
Availability,// Is the and mask vector all constant?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:14,mask,mask,14,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['mask'],['mask']
Availability,// Is the error status of posix_memalign correctly checked? If not it; // would be incorrect to assume it succeeds and load doesn't see the; // previous value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:10,error,error,10,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,1,['error'],['error']
Availability,// Is the first def operand tied to the first use operand. This is true for; // vector pseudo instructions that have a merge operand for tail/mask; // undisturbed. It's also true for vector FMA instructions where one of the; // operands is also the destination register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h:142,mask,mask,142,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h,1,['mask'],['mask']
Availability,// Is the linker in an error state?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h:23,error,error,23,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h,1,['error'],['error']
Availability,// Is the radius negative? Error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:27,Error,Error,27,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,4,['Error'],['Error']
Availability,// Is the trip count available in the preheader?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:21,avail,available,21,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,1,['avail'],['available']
Availability,"// Is this a scope?; // We look into the list of classes available,; // the ones in the dictionaries and the protoclasses.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TListOfTypes.cxx:57,avail,available,57,core/base/src/TListOfTypes.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TListOfTypes.cxx,1,['avail'],['available']
Availability,"// Issue Error about invalid proxy.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TCollectionProxyFactory.cxx:9,Error,Error,9,io/io/src/TCollectionProxyFactory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TCollectionProxyFactory.cxx,1,['Error'],['Error']
Availability,// Issue ODR failures diagnostics for enums.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:13,failure,failures,13,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['failure'],['failures']
Availability,// Issue ODR failures diagnostics for functions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:13,failure,failures,13,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['failure'],['failures']
Availability,// Issue __sincos_stret if available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:27,avail,available,27,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['avail'],['available']
Availability,// Issue any pending ODR-failure diagnostics for RecordDecl in C/ObjC. Note; // that in C++ this is done as a part of CXXRecordDecl ODR checking.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:25,failure,failure,25,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['failure'],['failure']
Availability,// Issue any pending ODR-failure diagnostics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:25,failure,failure,25,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['failure'],['failure']
Availability,"// Issue diagnostics for unterminated #if and missing newline.; // If we are in a #if directive, emit an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:105,error,error,105,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,1,['error'],['error']
Availability,// Issue error diagnostic if libgcc is explicitly specified; // through command line as --rtlib option argument.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp:9,error,error,9,interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp,1,['error'],['error']
Availability,// Issue error if third argument is not within the valid range.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:9,error,error,9,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,1,['error'],['error']
Availability,"// Issue error, unless ns_returns_not_retained.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:9,error,error,9,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,1,['error'],['error']
Availability,// Issue errors on unknown arguments.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:9,error,errors,9,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,2,['error'],['errors']
Availability,// It could happen that SectionNames has been removed and yet the user wants; // a section header table output. We need to throw an error if a user tries; // to do that.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObject.cpp:132,error,error,132,interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObject.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObject.cpp,1,['error'],['error']
Availability,"// It does! Return ""A op V"" if it simplifies or is already available.; // If V equals B then ""A op V"" is just the LHS.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:59,avail,available,59,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['avail'],['available']
Availability,"// It does! Return ""B op V"" if it simplifies or is already available.; // If V equals C then ""B op V"" is just the RHS.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:59,avail,available,59,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['avail'],['available']
Availability,"// It does! Return ""V op B"" if it simplifies or is already available.; // If V equals A then ""V op B"" is just the LHS.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:59,avail,available,59,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['avail'],['available']
Availability,"// It does! Return ""V op C"" if it simplifies or is already available.; // If V equals B then ""V op C"" is just the RHS.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:59,avail,available,59,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['avail'],['available']
Availability,// It doesn't make sense to generate debug info for PowerPC MMA vector types.; // So we return a safe type here to avoid generating an error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:135,error,error,135,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,1,['error'],['error']
Availability,"// It is an error to provide a -o option if we are making multiple output; // files. There are exceptions:; //; // IfsMergeJob: when generating interface stubs enabled we want to be able to; // generate the stub file at the same time that we generate the real; // library/a.out. So when a .o, .so, etc are the output, with clang interface; // stubs there will also be a .ifs and .ifso at the same location.; //; // CompileJob of type TY_IFS_CPP: when generating interface stubs is enabled; // and -c is passed, we still want to be able to generate a .ifs file while; // we are also generating .o files. So we allow more than one output file in; // this case as well.; //; // OffloadClass of type TY_Nothing: device-only output will place many outputs; // into a single offloading action. We should count all inputs to the action; // as outputs. Also ignore device-only outputs if we're compiling with; // -fsyntax-only.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:12,error,error,12,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['error'],['error']
Availability,// It is an error to see the same number more than once.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp:12,error,error,12,interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp,1,['error'],['error']
Availability,// It is available if it has no predecessors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:9,avail,available,9,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,2,['avail'],['available']
Availability,"// It is good practice to always have a ""default"" label in a ""switch"", even; // if we should never get there. It can be used to detect errors, for; // instance. Unreachable code directly under a ""default"" label is therefore; // likely to be a false positive.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnreachableCodeChecker.cpp:135,error,errors,135,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnreachableCodeChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnreachableCodeChecker.cpp,1,['error'],['errors']
Availability,"// It is important to remove the sections first. For example, we want to; // remove the relocation sections before removing the symbols. That allows; // us to avoid reporting the inappropriate errors about removing symbols; // named in relocations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObjcopy.cpp:193,error,errors,193,interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObjcopy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObjcopy.cpp,1,['error'],['errors']
Availability,"// It is not an error for shuffle masks to not be a vector of; // MaskEltSizeInBits because the constant pool uniques constants by their; // bit representation.; // e.g. the following take up the same space in the constant pool:; // i128 -170141183420855150465331762880109871104; //; // <2 x i64> <i64 -9223372034707292160, i64 -9223372034707292160>; //; // <4 x i32> <i32 -2147483648, i32 -2147483648,; // i32 -2147483648, i32 -2147483648>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ShuffleDecodeConstantPool.cpp:16,error,error,16,interpreter/llvm-project/llvm/lib/Target/X86/X86ShuffleDecodeConstantPool.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ShuffleDecodeConstantPool.cpp,3,"['Mask', 'error', 'mask']","['MaskEltSizeInBits', 'error', 'masks']"
Availability,"// It is okay to include this attribute on properties, e.g.:; //; // @property (retain, nonatomic) struct Bork *Q __attribute__((NSObject));; //; // In this case it follows tradition and suppresses an error in the above; // case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:201,error,error,201,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,1,['error'],['error']
Availability,"// It is possible that init SCEV contains an invariant load but it does; // not dominate MDL and is not available at MDL loop entry, so we should; // check it here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:104,avail,available,104,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['avail'],['available']
Availability,// It is possible that the type refers to a RecoveryExpr created earlier; // in the tree transformation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:44,Recover,RecoveryExpr,44,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['Recover'],['RecoveryExpr']
Availability,"// It is possible to receive a scope token. Read the ""::"", if it is; // available, and the subsequent identifier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:72,avail,available,72,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,1,['avail'],['available']
Availability,"// It is possible we're using MorphNodeTo to replace a node with no; // normal results with one that has a normal result (or we could be; // adding a chain) and the input could have glue and chains as well.; // In this case we need to shift the operands down.; // FIXME: This is a horrible hack and broken in obscure cases, no worse; // than the old isel though.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp:254,down,down,254,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,1,['down'],['down']
Availability,"// It is redundant to fully-specify this here, but nice to make it explicit; // so that it is clear the DXIL module version is different.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp:9,redundant,redundant,9,interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp,1,['redundant'],['redundant']
Availability,"// It is safe to down cast from int64_t, NumInsts is always positive.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp:17,down,down,17,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp,1,['down'],['down']
Availability,// It is safe to down cast since we know the arguments; // cannot be negative and Cost is of type int64_t.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/FunctionSpecialization.h:17,down,down,17,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/FunctionSpecialization.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/FunctionSpecialization.h,1,['down'],['down']
Availability,// It is safe to drop mask parameter as masked-off elements are undef.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:22,mask,mask,22,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,2,['mask'],"['mask', 'masked-off']"
Availability,"// It is twice the size of the block because there might be easily around 8; // transactions in flight which can be empty, which might lead to refill of; // the smallvector and then the return for reuse will exceed the capacity; // of the smallvector causing redundant copy of the elements.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/TransactionPool.h:259,redundant,redundant,259,interpreter/cling/lib/Interpreter/TransactionPool.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/TransactionPool.h,1,['redundant'],['redundant']
Availability,"// It loads same immediate value to the same Reg, which is redundant.; // We would unset kill flag in previous Reg usage to extend live range; // of Reg first, then remove the redundancy.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:59,redundant,redundant,59,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,1,['redundant'],['redundant']
Availability,"// It may be the case that GV is on a chain of an ifunc, its alias and; // subsequent aliases. In this case, the summary for the value is not; // available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:146,avail,available,146,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,1,['avail'],['available']
Availability,"// It may be worth creating extending masked loads if there are multiple; // masked loads using the same predicate. That way we'll end up creating; // extending masked loads that may then get split by the legaliser. This; // results in just one set of predicate unpacks at the start, instead of; // multiple sets of vector unpacks after each load.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:38,mask,masked,38,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,3,['mask'],['masked']
Availability,"// It may happen that AP will be absent even HasAlloca && HasExtraAlign; // is true. HasExtraAlign may be set because of vector spills, without; // aligned locals or aligned outgoing function arguments. Since vector; // spills will ultimately be ""unaligned"", it is safe to use FP as the; // base register.; // In fact, in such a scenario the stack is actually not required to be; // aligned, although it may end up being aligned anyway, since this; // particular case is not easily detectable. The alignment will be; // unnecessary, but not incorrect.; // Unfortunately there is no quick way to verify that the above is; // indeed the case (and that it's not a result of an error), so just; // assume that missing AP will be replaced by FP.; // (A better fix would be to rematerialize AP from FP and always align; // vector spills.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:674,error,error,674,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,1,['error'],['error']
Availability,// It might be worthwhile to try to recover by creating an; // appropriate declaration.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:36,recover,recover,36,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['recover'],['recover']
Availability,// It should be impossible to have FGR64 on MIPS-II or MIPS32r1 (which are; // the cases where mfhc1 is not available). 64-bit architectures and; // MIPS32r2 or later can use FGR64 though.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:108,avail,available,108,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,1,['avail'],['available']
Availability,// It should be impossible to have FGR64 on MIPS-II or MIPS32r1 (which are; // the cases where mthc1 is not available). 64-bit architectures and; // MIPS32r2 or later can use FGR64 though.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:108,avail,available,108,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,1,['avail'],['available']
Availability,// It's a bit hacky: At this point we've raised an error but we want the; // rest of the compiler to continue somehow working. However almost; // everything we'll try to do with the class will depend on there being a; // destructor. So let's pretend the first one is selected and hope for the; // best.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:51,error,error,51,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['error'],['error']
Availability,"// It's a little bit hard to see why the following transformations are; // correct. Here is a CVC3 program to verify them for 64-bit values:; /*; ONE : BITVECTOR(64) = BVZEROEXTEND(0bin1, 63);; x : BITVECTOR(64);; y : BITVECTOR(64);; z : BITVECTOR(64);; mask : BITVECTOR(64) = BVSHL(ONE, z);; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; QUERY( (y | mask = y) =>; ((x | mask = y) <=> (x = y OR x = (y & ~mask))); );; */; // Please note that each pattern must be a dual implication (<--> or; // iff). One directional implication can create spurious matches. If the; // implication is only one-way, an unsatisfiable condition on the left; // side can imply a satisfiable condition on the right side. Dual; // implication ensures that satisfiable conditions are transformed to; // other satisfiable conditions and unsatisfiable conditions are; // transformed to other unsatisfiable conditions.; // Here is a concrete example of a unsatisfiable condition on the left; // implying a satisfiable condition on the right:; //; // mask = (1 << z); // (x & ~mask) == y --> (x == y || x == (y | mask)); //; // Substituting y = 3, z = 0 yields:; // (x & -2) == 3 --> (x == 3 || x == 2); // Pattern match a special case:; /*; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:254,mask,mask,254,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,13,['mask'],['mask']
Availability,"// It's a string: echo it",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:18,echo,echo,18,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['echo'],['echo']
Availability,// It's about to be alive again.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:20,alive,alive,20,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,1,['alive'],['alive']
Availability,// It's an error for a slot to have this type,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackFrameLayoutAnalysisPass.cpp:11,error,error,11,interpreter/llvm-project/llvm/lib/CodeGen/StackFrameLayoutAnalysisPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackFrameLayoutAnalysisPass.cpp,1,['error'],['error']
Availability,// It's an error if we have to do this and the user didn't; // explicitly write an ownership attribute on the property.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:11,error,error,11,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,1,['error'],['error']
Availability,"// It's an error to translate this:; //; // %reg1025 = <sext> %reg1024; // ...; // %reg1026 = SUBREG_TO_REG 0, %reg1024, 4; //; // into this:; //; // %reg1025 = <sext> %reg1024; // ...; // %reg1027 = COPY %reg1025:4; // %reg1026 = SUBREG_TO_REG 0, %reg1027, 4; //; // The problem here is that SUBREG_TO_REG is there to assert that an; // implicit zext occurs. It doesn't insert a zext instruction. If we allow; // the COPY here, it will give us the value after the <sext>, not the; // original value of %reg1024 before <sext>.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:11,error,error,11,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,1,['error'],['error']
Availability,// It's an error to try to associate with an undefined symbol or a symbol; // without a section.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/WinCOFFObjectWriter.cpp:11,error,error,11,interpreter/llvm-project/llvm/lib/MC/WinCOFFObjectWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/WinCOFFObjectWriter.cpp,1,['error'],['error']
Availability,// It's fine (but redundant) to check this for __generic on the; // fallthrough path; we only form the __generic token in OpenCL mode.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:18,redundant,redundant,18,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['redundant'],['redundant']
Availability,"// It's highly likely that most programs do not contain CallBrInsts. Follow a; // similar pattern from SafeStackLegacyPass::runOnFunction to reuse previous; // domtree analysis if available, otherwise compute it lazily. This avoids; // forcing Dominator Tree Construction at -O0 for programs that likely do not; // contain CallBrInsts. It does pessimize programs with callbr at higher; // optimization levels, as the DominatorTree created here is not reused by; // subsequent passes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallBrPrepare.cpp:180,avail,available,180,interpreter/llvm-project/llvm/lib/CodeGen/CallBrPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallBrPrepare.cpp,1,['avail'],['available']
Availability,"// It's important that we define the states unchecked, because for checking that name; // or index are available, recomputeShape() would be called.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMultiCategory.cxx:103,avail,available,103,roofit/roofitcore/src/RooMultiCategory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMultiCategory.cxx,1,['avail'],['available']
Availability,// It's not an insertion of Op.getOperand(0) if the two masks overlap.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:56,mask,masks,56,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,1,['mask'],['masks']
Availability,// It's possible that the mask has a different number of elements from; // the original cast. We recompute the destination type to match the mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:26,mask,mask,26,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,2,['mask'],['mask']
Availability,"// It's possible that this symbol has already been removed, e.g. if a; // materialization failure happens concurrently with a ResourceTracker or; // JITDylib removal. In that case we can safely skip this symbol and; // continue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:90,failure,failure,90,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,1,['failure'],['failure']
Availability,"// It's rather unlikely we end up here. But it could happen, so report an; // error instead of crashing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexer.cpp:78,error,error,78,interpreter/llvm-project/clang/tools/libclang/CIndexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexer.cpp,1,['error'],['error']
Availability,"// Itanium ABI 5.2.2: ""Each COMDAT group [for a static local variable] must; // be emitted in any object with references to the symbol for the object it; // contains, whether inline or out-of-line.""; // Similar behavior is observed with MSVC. An alternative ABI could use; // StrongODR/AvailableExternally to match the function, but none are; // known/supported currently.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:286,Avail,AvailableExternally,286,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['Avail'],['AvailableExternally']
Availability,"// Itanium C++ ABI 2.9.5p7:; // In addition, it and all of the intermediate abi::__pointer_type_info; // structs in the chain down to the abi::__class_type_info for the; // incomplete class type must be prevented from resolving to the; // corresponding type_info structs for the complete class type, possibly; // by making them local static objects. Finally, a dummy class RTTI is; // generated for the incomplete type that will not resolve to the final; // complete class RTTI (because the latter need not exist), possibly by; // making it a local static object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp:126,down,down,126,interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,1,['down'],['down']
Availability,// Iterate over the worklist adding blocks to AliveBlocks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:46,Alive,AliveBlocks,46,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,1,['Alive'],['AliveBlocks']
Availability,"// Iterate through all nodes, interested in the following case:; //; // . loads from ConstantStruct or ConstantArray of constructs; // which can be turns into constant itself, with this we can; // avoid reading from read-only section at runtime.; //; // . Removing redundant AND for intrinsic narrow loads.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelDAGToDAG.cpp:265,redundant,redundant,265,interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelDAGToDAG.cpp,1,['redundant'],['redundant']
Availability,"// Iterate through ifuncs, set their resolvers all alive.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:51,alive,alive,51,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,1,['alive'],['alive']
Availability,"// Iterate through the predecessor blocks and warn if the lockset for all; // predecessors is not the same. We take the entry lockset of the current; // block to be the intersection of all previous locksets.; // FIXME: By keeping the intersection, we may output more errors in future; // for a lock which is not in the intersection, but was in the union. We; // may want to also keep the union in future. As an example, let's say; // the intersection contains Mutex L, and the union contains L and M.; // Later we unlock M. At this point, we would output an error because we; // never locked M; although the real error is probably that we forgot to; // lock M on all code paths. Conversely, let's say that later we lock M.; // In this case, we should compare against the intersection instead of the; // union because the real error is probably that we forgot to unlock M on; // all code paths.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:267,error,errors,267,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,4,['error'],"['error', 'errors']"
Availability,"// Iterate through the stack of lambdas starting from the innermost lambda to; // the outermost lambda, checking if '*this' is ever captured by copy - since; // that could change the cv-qualifiers of the '*this' object.; // The object referred to by '*this' starts out with the cv-qualifiers of its; // member function. We then start with the innermost lambda and iterate; // outward checking to see if any lambda performs a by-copy capture of '*this'; // - and if so, any nested lambda must respect the 'constness' of that; // capturing lamdbda's call operator.; //; // Since the FunctionScopeInfo stack is representative of the lexical; // nesting of the lambda expressions during initial parsing (and is the best; // place for querying information about captures about lambdas that are; // partially processed) and perhaps during instantiation of function templates; // that contain lambda expressions that need to be transformed BUT not; // necessarily during instantiation of a nested generic lambda's function call; // operator (which might even be instantiated at the end of the TU) - at which; // time the DeclContext tree is mature enough to query capture information; // reliably - we use a two pronged approach to walk through all the lexically; // enclosing lambda expressions:; //; // 1) Climb down the FunctionScopeInfo stack as long as each item represents; // a Lambda (i.e. LambdaScopeInfo) AND each LSI's 'closure-type' is lexically; // enclosed by the call-operator of the LSI below it on the stack (while; // tracking the enclosing DC for step 2 if needed). Note the topmost LSI on; // the stack represents the innermost lambda.; //; // 2) If we run out of enclosing LSI's, check if the enclosing DeclContext; // represents a lambda's call operator. If it does, we must be instantiating; // a generic lambda's call operator (represented by the Current LSI, and; // should be the only scenario where an inconsistency between the LSI and the; // DeclContext should occur), so climb o",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:1181,reliab,reliably,1181,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,2,"['down', 'reliab']","['down', 'reliably']"
Availability,"// Iterator for sub-branches; // Always start with the first available sub-branch and if it does not match the element,; // try the next ones",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReaderGenerator.cxx:61,avail,available,61,tree/treeplayer/src/TTreeReaderGenerator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReaderGenerator.cxx,1,['avail'],['available']
Availability,"// Ivar's can only appear in interfaces, implementations (via synthesized; // properties), and class extensions (via direct declaration, or synthesized; // properties).; //; // FIXME: This should really be asserting this:; // (isa<ObjCCategoryDecl>(DC) &&; // cast<ObjCCategoryDecl>(DC)->IsClassExtension())); // but unfortunately we sometimes place ivars into non-class extension; // categories on error. This breaks an AST invariant, and should not be; // fixed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:399,error,error,399,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,1,['error'],['error']
Availability,"// JavaScript (or more precisely TypeScript) can have semicolons in braced; // lists (in so-called TypeMemberLists). Thus, the semicolon cannot be; // used for error recovery if we have otherwise determined that this is; // a braced list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:160,error,error,160,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,2,"['error', 'recover']","['error', 'recovery']"
Availability,"// JavaScript and Java do not allow to escape the end of the line with a; // backslash. Backslashes are syntax errors in plain source, but can occur in; // comments. When a single line comment ends with a \, it'll cause the next; // line of code to be lexed as a comment, breaking formatting. The code below; // finds comments that contain a backslash followed by a line break, truncates; // the comment token at the backslash, and resets the lexer to restart behind; // the backslash.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp:111,error,errors,111,interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp,1,['error'],['errors']
Availability,"// Jitted nodes of the computation graph (e.g. RJittedAction, RJittedDefine) usually don't need to register; // themselves with the RLoopManager: the _concrete_ nodes will be registered with the RLoopManager right before; // the event loop, at jitting time, and that is good enough.; // RJittedFilter is an exception: RLoopManager needs to know about what filters have been booked even before; // the event loop in order to return a correct list from RLoopManager::GetFiltersNames().; // So RJittedFilters register themselves with RLoopManager at construction time and deregister themselves; // in SetFilter, i.e. when they are sure that the concrete filter has been instantiated in jitted code and it has; // been registered with RLoopManager, making the RJittedFilter registration redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RJittedFilter.cxx:783,redundant,redundant,783,tree/dataframe/src/RJittedFilter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RJittedFilter.cxx,1,['redundant'],['redundant']
Availability,"// Jitted; // If some other test case called EnableThreadSafety, the error printed here is of the form; // ""SysError in <TFile::TFile>: file /definitely/not/a/valid/path/f.root can not be opened No such file or; // directory\nError in <TReentrantRWLock::WriteUnLock>: Write lock already released for 0x55f179989378\n"" but the; // address printed changes every time",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx:69,error,error,69,tree/dataframe/test/dataframe_snapshot.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx,1,['error'],['error']
Availability,"// Jitted; // the error printed here is; // ""SysError in <TFile::TFile>: file /definitely/not/a/valid/path/f.root can not be opened No such file or; // directory\nError in <TReentrantRWLock::WriteUnLock>: Write lock already released for 0x55f179989378\n"" but the; // address printed changes every time",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx:18,error,error,18,tree/dataframe/test/dataframe_snapshot.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx,1,['error'],['error']
Availability,// Jump threading may have introduced redundant debug values into BB; // which should be removed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:38,redundant,redundant,38,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['redundant'],['redundant']
Availability,"// Just a list of available datasets",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDataSetManagerFile.cxx:18,avail,available,18,proof/proof/src/TDataSetManagerFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDataSetManagerFile.cxx,1,['avail'],['available']
Availability,"// Just because the canonical type is correct does not mean we can use cast<>,; // since we may not have stripped off all the sugar down to the base type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:132,down,down,132,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,1,['down'],['down']
Availability,"// Just delegate to the generic legality, clear masks aren't special.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:48,mask,masks,48,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,2,['mask'],['masks']
Availability,"// Just figure out the dimensions of the downsampled (lazy) matrix",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/vlazy.cxx:41,down,downsampled,41,test/vlazy.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/vlazy.cxx,1,['down'],['downsampled']
Availability,// Just ignore and skip the k-mask operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:30,mask,mask,30,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['mask'],['mask']
Availability,// Just insert the scaled root mask value if it references an input other; // than the SrcOp we're currently inserting.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:31,mask,mask,31,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// Just skip the next few entries in the currently available bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/RanluxppEngineImpl.cxx:51,avail,available,51,math/mathcore/src/RanluxppEngineImpl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/RanluxppEngineImpl.cxx,1,['avail'],['available']
Availability,"// KNL does not recognize dependency-breaking idioms for mask registers,; // so kxnor %k1, %k1, %k2 has a RAW dependence on %k1.; // Using %k0 as the undef input register is a performance heuristic based; // on the assumption that %k0 is used less frequently than the other mask; // registers, since it is not usable as a write mask.; // FIXME: A more advanced approach would be to choose the best input mask; // register based on context.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:57,mask,mask,57,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,4,['mask'],['mask']
Availability,// Keep PP alive for now.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Testing/TestAST.cpp:11,alive,alive,11,interpreter/llvm-project/clang/lib/Testing/TestAST.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Testing/TestAST.cpp,1,['alive'],['alive']
Availability,"// Keep a separate set of registers defined in this block, so that we; // can remove them from the list of available registers once all DT; // successors have been processed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp:107,avail,available,107,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp,1,['avail'],['available']
Availability,// Keep clustered nodes together to encourage downstream peephole; // optimizations which may reduce resource requirements.; //; // This is a best effort to set things up for a post-RA pass. Optimizations; // like generating loads of multiple registers should ideally be done within; // the scheduler pass by combining the loads during DAG postprocessing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:46,down,downstream,46,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,3,['down'],['downstream']
Availability,"// Keep frame pointer to make JIT stack unwinding reliable for profiling",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/CIFactory.cpp:50,reliab,reliable,50,interpreter/cling/lib/Interpreter/CIFactory.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/CIFactory.cpp,1,['reliab'],['reliable']
Availability,"// Keep going after an error, if we can, assuming that the length field; // could be read. If it couldn't, stop reading the section.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFContext.cpp:23,error,error,23,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFContext.cpp,2,['error'],['error']
Availability,// Keep going after reporting the error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.cpp:34,error,error,34,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.cpp,1,['error'],['error']
Availability,"// Keep integral alive until the prodSet is cloned later",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooGenProdProj.cxx:17,alive,alive,17,roofit/roofitcore/src/RooGenProdProj.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooGenProdProj.cxx,1,['alive'],['alive']
Availability,// Keep left all the way down.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/IntervalMap.cpp:25,down,down,25,interpreter/llvm-project/llvm/lib/Support/IntervalMap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/IntervalMap.cpp,1,['down'],['down']
Availability,// Keep llvm::Error happy.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rc/ResourceScriptParser.h:14,Error,Error,14,interpreter/llvm-project/llvm/tools/llvm-rc/ResourceScriptParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rc/ResourceScriptParser.h,1,['Error'],['Error']
Availability,// Keep output if no errors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mc/llvm-mc.cpp:21,error,errors,21,interpreter/llvm-project/llvm/tools/llvm-mc/llvm-mc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mc/llvm-mc.cpp,2,['error'],['errors']
Availability,// Keep right all the way down.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/IntervalMap.cpp:26,down,down,26,interpreter/llvm-project/llvm/lib/Support/IntervalMap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/IntervalMap.cpp,1,['down'],['down']
Availability,// Keep symbolic expressions of container begins and ends alive,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ContainerModeling.cpp:58,alive,alive,58,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ContainerModeling.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ContainerModeling.cpp,1,['alive'],['alive']
Availability,// Keep symbolic expressions of iterator positions alive,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IteratorModeling.cpp:51,alive,alive,51,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IteratorModeling.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IteratorModeling.cpp,1,['alive'],['alive']
Availability,// Keep the buffer alive.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Remarks/YAMLRemarkParser.cpp:19,alive,alive,19,interpreter/llvm-project/llvm/lib/Remarks/YAMLRemarkParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Remarks/YAMLRemarkParser.cpp,1,['alive'],['alive']
Availability,// Keep the offset available for base register allocation,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp:19,avail,available,19,interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,1,['avail'],['available']
Availability,"// Keep track of implicit defs of CSMI and MI, to clear possibly; // made-redundant kill flags.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:74,redundant,redundant,74,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,1,['redundant'],['redundant']
Availability,"// Keep track of sum-of-weights error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsData.cxx:32,error,error,32,roofit/roofitcore/src/RooAbsData.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsData.cxx,1,['error'],['error']
Availability,"// Keep track of the bits in the register we already emitted, so we; // can avoid emitting redundant aliasing subregs. Because this is; // just doing a greedy scan of all subregisters, it is possible that; // this doesn't find a combination of subregisters that fully cover; // the register (even though one may exist).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp:91,redundant,redundant,91,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp,1,['redundant'],['redundant']
Availability,"// Keep track of the warnings/errors we printed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/res/TClingUtils.h:30,error,errors,30,core/clingutils/res/TClingUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/res/TClingUtils.h,1,['error'],['errors']
Availability,// Keep track of the widest and mask we see.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:32,mask,mask,32,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['mask'],['mask']
Availability,// Keep track of whether the previous instruction was an LFENCE to avoid; // adding redundant LFENCEs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeExecutionSideEffectSuppression.cpp:84,redundant,redundant,84,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeExecutionSideEffectSuppression.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeExecutionSideEffectSuppression.cpp,1,['redundant'],['redundant']
Availability,// Keep track of whether we produce any errors while trying to produce; // preprocessed sources.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:40,error,errors,40,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['error'],['errors']
Availability,"// Keep underlying buffer alive until actually used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfo.cxx:26,alive,alive,26,io/io/src/TStreamerInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfo.cxx,1,['alive'],['alive']
Availability,"// Keeping LVI alive is expensive, both because it uses a lot of memory, and; // because invalidating values in LVI is expensive. While CVP does preserve; // LVI, we know that passes after JumpThreading+CVP will not need the result; // of this analysis, so we forcefully discard it early.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:15,alive,alive,15,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,1,['alive'],['alive']
Availability,// Keeping zombie handle symbols. In case the error symbol is dying later; // than the handle symbol we might produce spurious leak warnings (in case; // we find out later from the status code that the handle allocation failed; // in the first place).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp:46,error,error,46,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp,1,['error'],['error']
Availability,// Keeps target alive. Offset/addend zero.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h:16,alive,alive,16,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,1,['alive'],['alive']
Availability,// Keeps track of the available VXRM value at the end of the basic block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp:22,avail,available,22,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp,1,['avail'],['available']
Availability,// Keeps track of the available VXRM value at the start of the basic bloc.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp:22,avail,available,22,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp,1,['avail'],['available']
Availability,"// Keeps track of the starting position of the location; // information (e.g., ""foo.c:10:4:"") that precedes the error; // message. We use this information to determine how long the; // file+line+column number prefix is.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticPrinter.cpp:112,error,error,112,interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticPrinter.cpp,1,['error'],['error']
Availability,// KeptBits = bitwidth(%x) - MaskedBits,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:29,Mask,MaskedBits,29,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['Mask'],['MaskedBits']
Availability,"// Key masks, used as modifiers to GrabButton and GrabKey and; // in Event_t::fState in various key-, mouse-, and button-related events",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/gui/inc/GuiTypes.h:7,mask,masks,7,core/gui/inc/GuiTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/gui/inc/GuiTypes.h,1,['mask'],['masks']
Availability,"// Key or button mask",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/recorder/inc/TRecorder.h:17,mask,mask,17,gui/recorder/inc/TRecorder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/recorder/inc/TRecorder.h,1,['mask'],['mask']
Availability,// Kill - deactivate lanes no longer in live mask,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp:45,mask,mask,45,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,1,['mask'],['mask']
Availability,// Kill any masked registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:12,mask,masked,12,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,1,['mask'],['masked']
Availability,"// Kill off any remaining uses that don't match available, and build a list of; // incoming DomainValues that we want to merge.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp:48,avail,available,48,interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp,1,['avail'],['available']
Availability,// Kill zero bytes selected by other mask. Zero value is 0xc.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:37,mask,mask,37,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['mask'],['mask']
Availability,"// Known bits are automatically intersected across demanded elements of a; // vector. So for example, if a bit is computed as known zero, it must be; // zero across all demanded elements of the vector.; //; // For this bitcast, each demanded element of the output is sub-divided; // across a set of smaller vector elements in the source vector. To get; // the known bits for an entire element of the output, compute the known; // bits for each sub-element sequentially. This is done by shifting the; // one-set-bit demanded elements parameter across the sub-elements for; // consecutive calls to computeKnownBits. We are using the demanded; // elements parameter as a mask operator.; //; // The known bits of each sub-element are then inserted into place; // (dependent on endian) to form the full result of known bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:668,mask,mask,668,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['mask'],['mask']
Availability,"// Known or unknown error state without FEOF possible.; // Stop analysis, report error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:20,error,error,20,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,2,['error'],['error']
Availability,"// LHS and RHS are now:; // LHS = shuffle A, B, LMask; // RHS = shuffle A, B, RMask; // Check that the masks correspond to performing a horizontal operation.; // AVX defines horizontal add/sub to operate independently on 128-bit lanes,; // so we just repeat the inner loop if this is a 256-bit op.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:103,mask,masks,103,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['masks']
Availability,// LHS and RHS must be cast-expressions. We allow an arbitrary expression; // in the parser and reduce down to just cast-expressions here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateVariadic.cpp:103,down,down,103,interpreter/llvm-project/clang/lib/Sema/SemaTemplateVariadic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateVariadic.cpp,1,['down'],['down']
Availability,"// LLVM register Num, which has kind Kind. In some ways it might be; // easier for this class to have a register bank (general, floating-point; // or access) and a raw register number (0-15). This would postpone the; // interpretation of the operand to the add*() methods and avoid the need; // for context-dependent parsing. However, we do things the current way; // because of the virtual getReg() method, which needs to distinguish; // between (say) %r0 used as a single register and %r0 used as a pair.; // Context-dependent parsing can also give us slightly better error; // messages when invalid pairs like %r1 are used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp:570,error,error,570,interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp,1,['error'],['error']
Availability,"// LM : fix for numerical problems if nppm is actually equal to j, but results different for numerical error; // g in the paper is nppm -j",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/TMath.cxx:103,error,error,103,math/mathcore/src/TMath.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/TMath.cxx,1,['error'],['error']
Availability,"// LM use a tolerance 1.E-12 (integral precision)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:12,toler,tolerance,12,hist/hist/src/TF1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx,1,['toler'],['tolerance']
Availability,"// LM: fConditionalMLEsAlt must be nuisance parameters otherwise an error message will be printed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/FrequentistCalculator.cxx:68,error,error,68,roofit/roostats/src/FrequentistCalculator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/FrequentistCalculator.cxx,1,['error'],['error']
Availability,"// LM: fConditionalMLEsNull must be nuisance parameters otherwise an error message will be printed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/FrequentistCalculator.cxx:69,error,error,69,roofit/roostats/src/FrequentistCalculator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/FrequentistCalculator.cxx,1,['error'],['error']
Availability,"// LSB mask for VGPR banks per VOPD component operand.; // 4 banks result in a mask 3, setting 2 lower bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.h:7,mask,mask,7,interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.h,2,['mask'],['mask']
Availability,// Label failure to capture.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:9,failure,failure,9,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,1,['failure'],['failure']
Availability,// Lane computes x's position in the Mask,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:37,Mask,Mask,37,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,1,['Mask'],['Mask']
Availability,// Lane mask map.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h:8,mask,mask,8,interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h,1,['mask'],['mask']
Availability,// Lane masks are only defined for vregs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp:8,mask,masks,8,interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp,1,['mask'],['masks']
Availability,"// Larger sanity check. Using uniform dist as signal; // and triangular as background should yield AUC of 2/3.; //; // Using 0.002 as the limit should yield a probability; // of an error of 0.0001%. (Estimated numerically).; // If the error is triggered, consider changing the seed of ""generator"" and/or; // increase either the error limit, the number of datapoints or the number of; // averagings.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/ROC/testRocWeights.cxx:181,error,error,181,tmva/tmva/test/ROC/testRocWeights.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/ROC/testRocWeights.cxx,3,['error'],['error']
Availability,"// Last error code processed by AuthError()",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/inc/TAuthenticate.h:8,error,error,8,net/auth/inc/TAuthenticate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/inc/TAuthenticate.h,1,['error'],['error']
Availability,"// Last, check that the mask chooses the correct low bits for each narrow; // element in the result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:24,mask,mask,24,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['mask'],['mask']
Availability,"// LastInst can still be null at this point if there's either not an entry; // for BB in BlocksSchedules or there's no ScheduleData available for; // VL.back(). This can be the case if buildTree_rec aborts for various; // reasons (e.g., the maximum recursion depth is reached, the maximum region; // size is reached, etc.). ScheduleData is initialized in the scheduling; // ""dry-run"".; //; // If this happens, we can still find the last instruction by brute force. We; // iterate forwards from Front (inclusive) until we either see all; // instructions in the bundle or reach the end of the block. If Front is the; // last instruction in program order, LastInst will be set to Front, and we; // will visit all the remaining instructions in the block.; //; // One of the reasons we exit early from buildTree_rec is to place an upper; // bound on compile-time. Thus, taking an additional compile-time hit here is; // not ideal. However, this should be exceedingly rare since it requires that; // we both exit early from buildTree_rec and that the bundle be out-of-order; // (causing us to iterate all the way to the end of the block).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:132,avail,available,132,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['avail'],['available']
Availability,// Leave everything empty. Can be used as an; // error marker or for void return values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/EvaluationResult.h:49,error,error,49,interpreter/llvm-project/clang/lib/AST/Interp/EvaluationResult.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/EvaluationResult.h,1,['error'],['error']
Availability,// Left or right might be masked.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:26,mask,masked,26,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,1,['mask'],['masked']
Availability,// Legalize Mask (unpack or all-true),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.cpp:12,Mask,Mask,12,interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.cpp,1,['Mask'],['Mask']
Availability,// Legalize ret f64 -> ret 2 x i32. We always have fmrrd if f64 is; // available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:71,avail,available,71,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['avail'],['available']
Availability,"// LegalizeUpdates function simplifies updates assuming a graph structure.; // This function serves double purpose:; // a) It removes redundant updates, which makes it easier to reverse-apply; // them when traversing CFG.; // b) It optimizes away updates that cancel each other out, as the end result; // is the same.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CFGUpdate.h:134,redundant,redundant,134,interpreter/llvm-project/llvm/include/llvm/Support/CFGUpdate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CFGUpdate.h,1,['redundant'],['redundant']
Availability,// Length of the current node from the root down to here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/SuffixTree.cpp:44,down,down,44,interpreter/llvm-project/llvm/lib/Support/SuffixTree.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/SuffixTree.cpp,1,['down'],['down']
Availability,"// Less defined shuffles can be replaced by the more defined copies.; // Between two shuffles one is less defined if it has the same vector operands; // and its mask indeces are the same as in the first one or undefs. E.g.; // shuffle %0, poison, <0, 0, 0, undef> is less defined than shuffle %0,; // poison, <0, 0, 0, 0>.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:161,mask,mask,161,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['mask'],['mask']
Availability,"// Let 0xABCDEFGH be given unsigned in MI.getOperand(1). First let's convert; // unsigned to double. Mantissa has 52 bits so we use following trick:; // First make floating point bit mask 0x43300000ABCDEFGH.; // Mask represents 2^52 * 0x1.00000ABCDEFGH i.e. 0x100000ABCDEFGH.0 .; // Next, subtract 2^52 * 0x1.0000000000000 i.e. 0x10000000000000.0 from it.; // Done. Trunc double to float if needed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp:183,mask,mask,183,interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp,2,"['Mask', 'mask']","['Mask', 'mask']"
Availability,"// Let f16->f80 get lowered to a libcall, except for darwin, where we should; // lower it to an fp_extend via f32 (as only f16<>f32 libcalls are available)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:145,avail,available,145,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avail'],['available']
Availability,// Let template instantiation know whether we had errors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:50,error,errors,50,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['error'],['errors']
Availability,"// Let the addend be ""c * x"". If ""c == +/-1"", the value of the addend; // is immediately available; otherwise, it needs exactly one instruction; // to evaluate the value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:89,avail,available,89,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,1,['avail'],['available']
Availability,"// Let the linker choose between libunwind.so and libunwind.a; // depending on what's available, and depending on the -static flag",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp:86,avail,available,86,interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp,1,['avail'],['available']
Availability,// Let this error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelDAGToDAG.cpp:12,error,error,12,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelDAGToDAG.cpp,1,['error'],['error']
Availability,"// Let's see if it has already been written down in the; // Streamer.; // Let's see if we already wrote it down in the; // streamer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx:44,down,down,44,core/clingutils/src/TClingUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx,2,['down'],['down']
Availability,"// Let's take the first available StreamerInfo as a start",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:24,avail,available,24,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,2,['avail'],['available']
Availability,"// Lex an ID: [0-9]+. On success, the ID is stored in UIntVal and Token is; // returned, otherwise the Error token is returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp:103,Error,Error,103,interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp,1,['Error'],['Error']
Availability,"// Lex name of the macro after either #ifdef or #define. We could have used; // LexIdentifier(), but it has special handling of ""include"" word, which; // could result in awkward diagnostic errors. Consider:; // ----; // #ifdef include; // class ...; // ----; // LexIdentifier() will engage LexInclude(), which will complain about; // missing file with name ""class"". Instead, prepLexMacroName() will treat; // ""include"" as a normal macro name.; //; // On entry, CurPtr points to the end of a preprocessing directive word.; // The method allows for whitespaces between the preprocessing directive; // and the macro name. The allowed whitespaces are ' ' and '\t'.; //; // If the first non-whitespace symbol after the preprocessing directive; // is a valid start symbol for an identifier (i.e. [a-zA-Z_]), then; // the method updates TokStart to the position of the first non-whitespace; // symbol, sets CurPtr to the position of the macro name's last symbol,; // and returns a string reference to the macro name. Otherwise,; // TokStart is set to the first non-whitespace symbol after the preprocessing; // directive, and the method returns an empty string reference.; //; // In all cases, TokStart may be used to point to the word following; // the preprocessing directive.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGLexer.h:189,error,errors,189,interpreter/llvm-project/llvm/lib/TableGen/TGLexer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGLexer.h,1,['error'],['errors']
Availability,"// Lib calls can be materialized by some passes, and won't be; // marked as 'gc-leaf-function.' All available Libcalls are; // GC-leaf.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:100,avail,available,100,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,1,['avail'],['available']
Availability,"// Lift this: one may had an empty attribute value; // if (attr_value.length() == 0) { // checks if the attribute value is empty; // ROOT::TMetaUtils::Error(0,""Attribute - missing attibute value!\n"");; // return false;; // }; // creates new Attributes object and pushes it back in the vector; // then Sets the variables in the initial state - if there are other attributes to be read; // For the moment the proto pattern is not implemented. The current ROOT6 architecture; // relies on ABI compatibility for calling functions, no stub functions are present.; // The concept of selecting/excluding functions is not defined.; // if (attr_name == ""proto_pattern"") {; // printf(""XMLReader::GetAttributes(): proto_pattern selection not implemented yet!\n"");; // }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/XMLReader.cxx:151,Error,Error,151,core/dictgen/src/XMLReader.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/XMLReader.cxx,1,['Error'],['Error']
Availability,"// Like static constructors, the remote target MCJIT support doesn't handle; // this yet. It could. FIXME.; // Delete the EE - we need to tear it down *before* we terminate the session; // with the remote, otherwise it'll crash when it tries to release resources; // on a remote that has already been disconnected.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:146,down,down,146,interpreter/llvm-project/llvm/tools/lli/lli.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp,1,['down'],['down']
Availability,"// Likewise, try masking out a splat value first.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h:17,mask,masking,17,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h,1,['mask'],['masking']
Availability,"// LimitFloatPrecision <= 18; // For floating-point precision of 18:; //; // Log10ofMantissa =; // -0.84299375f +; // (1.5327582f +; // (-1.0688956f +; // (0.49102474f +; // (-0.12539807f + 0.13508273e-1f * x) * x) * x) * x) * x;; //; // error 0.0000037995730, which is better than 18 bits",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:238,error,error,238,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['error'],['error']
Availability,"// LimitFloatPrecision <= 18; // For floating-point precision of 18:; //; // Log2ofMantissa =; // -3.0400495f +; // (6.1129976f +; // (-5.3420409f +; // (3.2865683f +; // (-1.2669343f +; // (0.27515199f -; // 0.25691327e-1f * x) * x) * x) * x) * x) * x;; //; // error 0.0000018516, which is better than 18 bits",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:262,error,error,262,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['error'],['error']
Availability,"// LimitFloatPrecision <= 18; // For floating-point precision of 18:; //; // LogOfMantissa =; // -2.1072184f +; // (4.2372794f +; // (-3.7029485f +; // (2.2781945f +; // (-0.87823314f +; // (0.19073739f - 0.17809712e-1f * x) * x) * x) * x) * x)*x;; //; // error 0.0000023660568, which is better than 18 bits",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:256,error,error,256,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['error'],['error']
Availability,"// LimitFloatPrecision <= 18; // For floating-point precision of 18:; //; // TwoToFractionalPartOfX =; // 0.999999982f +; // (0.693148872f +; // (0.240227044f +; // (0.554906021e-1f +; // (0.961591928e-2f +; // (0.136028312e-2f + 0.157059148e-3f *x)*x)*x)*x)*x)*x;; // error 2.47208000*10^(-7), which is better than 18 bits",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:269,error,error,269,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['error'],['error']
Availability,"// Line Search Tolerance",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLMinimizer.h:15,Toler,Tolerance,15,math/mathmore/inc/Math/GSLMinimizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLMinimizer.h,2,['Toler'],['Tolerance']
Availability,"// Linearizing the control flow by placing TRY / END_TRY markers can create; // mismatches in unwind destinations for throwing instructions, such as calls.; //; // We use the 'delegate' instruction to fix the unwind mismatches. 'delegate'; // instruction delegates an exception to an outer 'catch'. It can target not; // only 'catch' but all block-like structures including another 'delegate',; // but with slightly different semantics than branches. When it targets a; // 'catch', it will delegate the exception to that catch. It is being; // discussed how to define the semantics when 'delegate''s target is a non-try; // block: it will either be a validation failure or it will target the next; // outer try-catch. But anyway our LLVM backend currently does not generate; // such code. The example below illustrates where the 'delegate' instruction; // in the middle will delegate the exception to, depending on the value of N.; // try; // try; // block; // try; // try; // call @foo; // delegate N ;; Where will this delegate to?; // catch ;; N == 0; // end; // end ;; N == 1 (invalid; will not be generated); // delegate ;; N == 2; // catch ;; N == 3; // end; // ;; N == 4 (to caller); // 1. When an instruction may throw, but the EH pad it will unwind to can be; // different from the original CFG.; //; // Example: we have the following CFG:; // bb0:; // call @foo ; if it throws, unwind to bb2; // bb1:; // call @bar ; if it throws, unwind to bb3; // bb2 (ehpad):; // catch; // ...; // bb3 (ehpad); // catch; // ...; //; // And the CFG is sorted in this order. Then after placing TRY markers, it; // will look like: (BB markers are omitted); // try; // try; // call @foo; // call @bar ;; if it throws, unwind to bb3; // catch ;; ehpad (bb2); // ...; // end_try; // catch ;; ehpad (bb3); // ...; // end_try; //; // Now if bar() throws, it is going to end up ip in bb2, not bb3, where it; // is supposed to end up. We solve this problem by wrapping the mismatching; // call with an inner try-del",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp:662,failure,failure,662,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,1,['failure'],['failure']
Availability,"// Link to a stylesheet if one is available. Otherwise, use the default style.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp:34,avail,available,34,interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp,1,['avail'],['available']
Availability,"// LinkModeAuto will link with the default link mode for the installation,; // which is dependent on the value of LLVM_LINK_LLVM_DYLIB, and fall back; // to the alternative if the required libraries are not available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:207,avail,available,207,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,1,['avail'],['available']
Availability,"// LinkModeShared will link with the dynamic component libraries if they; // exist, and return an error otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:98,error,error,98,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,1,['error'],['error']
Availability,"// LinkModeStatic will link with the static component libraries if they; // exist, and return an error otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:97,error,error,97,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,1,['error'],['error']
Availability,// Linking object files with different code models is undefined behavior; // because the compiler would have to generate additional code (to span; // longer jumps) if a larger code model is used with a smaller one.; // Therefore we will treat attempts to mix code models as an error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Module.cpp:277,error,error,277,interpreter/llvm-project/llvm/lib/IR/Module.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Module.cpp,1,['error'],['error']
Availability,// Links each entry in LinkModules into our module. Returns true on error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendConsumer.h:68,error,error,68,interpreter/llvm-project/clang/lib/CodeGen/BackendConsumer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendConsumer.h,2,['error'],['error']
Availability,// List bundle IDs. Return true if an error was found.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/OffloadBundler.h:38,error,error,38,interpreter/llvm-project/clang/include/clang/Driver/OffloadBundler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/OffloadBundler.h,2,['error'],['error']
Availability,// List of GPR registers that are available to store values in regcall; // calling convention.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp:34,avail,available,34,interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp,1,['avail'],['available']
Availability,"// List of available applications; ////////////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx:11,avail,available,11,core/base/src/TApplication.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx,1,['avail'],['available']
Availability,"// List of branches for which we want to suppress the printed error about; // missing branch when switching to a new tree",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreeReader.h:62,error,error,62,tree/treeplayer/inc/TTreeReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreeReader.h,2,['error'],['error']
Availability,"// List of branches for which we want to suppress the printed error about; // missing branch when switching to a new tree. This is modified by readers,; // so must be declared before them in this class.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RLoopManager.hxx:62,error,error,62,tree/dataframe/inc/ROOT/RDF/RLoopManager.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RLoopManager.hxx,1,['error'],['error']
Availability,// List of lane masks accompanying register unit sequences.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/RegisterInfoEmitter.cpp:16,mask,masks,16,interpreter/llvm-project/llvm/utils/TableGen/RegisterInfoEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/RegisterInfoEmitter.cpp,1,['mask'],['masks']
Availability,// LiveIn management methods.; /// Adds the specified register as a live in. Note that it is an error to add; /// the same register to the same set more than once unless the intention is; /// to call sortUniqueLiveIns after all registers are added.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:96,error,error,96,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,1,['error'],['error']
Availability,"// LiveIn, LiveOut and BitsIn have a different meaning deppends on type.; // ::Maybe true bits represent ""may be alive"" allocas, ::Must true bits; // represent ""may be dead"". After the loop we will convert ::Must bits from; // ""may be dead"" to ""must be alive"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackLifetime.cpp:113,alive,alive,113,interpreter/llvm-project/llvm/lib/Analysis/StackLifetime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackLifetime.cpp,2,['alive'],['alive']
Availability,// Load are scheduled for latency even if there instruction itinerary; // is not available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:81,avail,available,81,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['avail'],['available']
Availability,"// Load library containing specified class. Returns 0 in case of error; // and 1 in case if success.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:65,error,error,65,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['error'],['error']
Availability,"// Load the entire current word, and mask into place the expected and new; // values",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:37,mask,mask,37,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,1,['mask'],['mask']
Availability,// Load the one scalar element that is specified by the mask using the; // appropriate offset from the base pointer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:56,mask,mask,56,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Load the whole vector and avoid masking off the top bits as it makes; // the codegen worse.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:35,mask,masking,35,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['mask'],['masking']
Availability,// LoadFO - depth-first!; // Optimistically assume that the block is Speculatively Available and check; // to see if we already know about this block in one lookup.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:83,Avail,Available,83,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['Avail'],['Available']
Availability,// Loaded SLocEntries have indexes counting downwards from -2.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:44,down,downwards,44,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,1,['down'],['downwards']
Availability,"// Loading address from XGOT; // External GOT: lui $tmp, %got_hi(symbol)($gp); // addu $tmp, $tmp, $gp; // lw $tmp, %got_lo(symbol)($tmp); // >addiu $tmp, $tmp, offset; // >addiu $rd, $tmp, $rs; // The addiu's marked with a '>' may be omitted if they are redundant. If; // this happens then the last instruction must use $rd as the result; // register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:255,redundant,redundant,255,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,1,['redundant'],['redundant']
Availability,"// Loading/storing mask pairs requires two kmov operations. The second one of; // these needs a 2 byte displacement relative to the specified address (with; // 32 bit spill size). The pairs of 1bit masks up to 16 bit masks all use the; // same spill size, they all are stored using MASKPAIR16STORE, loaded using; // MASKPAIR16LOAD.; //; // The displacement value might wrap around in theory, thus the asserts in; // both cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp:19,mask,mask,19,interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp,3,['mask'],"['mask', 'masks']"
Availability,// Loads are handled via masking (or speculated if safe to do so.),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:25,mask,masking,25,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,1,['mask'],['masking']
Availability,// Loads are inserted at the head of the tree because we don't want to; // sink them all the way down past store instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:97,down,down,97,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['down'],['down']
Availability,"// Loads get hoisted up to the first load in the chain. Stores get sunk; // down to the last store in the chain. Our algorithm for loads is:; //; // - Take the first element of the chain. This is the start of a new chain.; // - Take the next element of `Chain` and check for may-alias instructions; // up to the start of NewChain. If no may-alias instrs, add it to; // NewChain. Otherwise, start a new NewChain.; //; // For stores it's the same except in the reverse direction.; //; // We expect IsLoad to be an std::bool_constant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:76,down,down,76,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,1,['down'],['down']
Availability,"// Location list entries with empty location descriptions are redundant; // information in DWARF, so do not emit those.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:62,redundant,redundant,62,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,1,['redundant'],['redundant']
Availability,// Location to use for error messages.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:23,error,error,23,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,1,['error'],['error']
Availability,"// Lock down the inheritance model right now in MS ABI, whether or not the; // pointee types are the same.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:8,down,down,8,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,1,['down'],['down']
Availability,"// Log() << kDEBUG << ""DataSet MVA Signal efficiency at bkg eff.(error):; // | Sepa- Signifi- "" << Endl; Log() << kDEBUG << ""Name: Method: @B=0.01; // @B=0.10 @B=0.30 ROC-integ ROCCurve| ration: cance: "" << Endl;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Factory.cxx:65,error,error,65,tmva/tmva/src/Factory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Factory.cxx,1,['error'],['error']
Availability,"// LongSize == 64; // Fuchsia is always PIE, which means that the beginning of the address; // space is always available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:111,avail,available,111,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,1,['avail'],['available']
Availability,"// Look at the callee, if available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h:26,avail,available,26,interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,1,['avail'],['available']
Availability,"// Look at the use_device_ptr and use_device_addr clauses information and; // mark the existing map entries as such. If there is no map information for; // an entry in the use_device_ptr and use_device_addr list, we create one; // with map type 'alloc' and zero size section. It is the user fault if that; // was not mapped before. If there is no map information and the pointer is; // a struct member, then we defer the emission of that entry until the whole; // struct has been processed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:291,fault,fault,291,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,1,['fault'],['fault']
Availability,"// Look at the use_device_ptr clause information and mark the existing map; // entries as such. If there is no map information for an entry in the; // use_device_ptr list, we create one with map type 'alloc' and zero size; // section. It is the user fault if that was not mapped before. If there is; // no map information and the pointer is a struct member, then we defer the; // emission of that entry until the whole struct has been processed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:250,fault,fault,250,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,1,['fault'],['fault']
Availability,"// Look for (and (bitcast (vXi1 (concat_vectors (vYi1 setcc), undef,))), C); // Where C is a mask containing the same number of bits as the setcc and; // where the setcc will freely 0 upper bits of k-register. We can replace the; // undef in the concat with 0s and remove the AND. This mainly helps with; // v2i1/v4i1 setcc being casted to scalar.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:93,mask,mask,93,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// Look for (and (shl y, c2), c1) where c1 is a shifted mask with no; // leading zeros and c3 trailing zeros. We can use an SRLI by c2+c3; // followed by a SHXADD with c3 for the X amount.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:56,mask,mask,56,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,"// Look for (and (shl y, c2), c1) where c1 is a shifted mask with; // 32-ShAmt leading zeros and c2 trailing zeros. We can use SLLI by; // c2-ShAmt followed by SHXADD_UW with ShAmt for the X amount.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:56,mask,mask,56,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,"// Look for (and (shr y, c2), c1) where c1 is a shifted mask with c2; // leading zeros and c3 trailing zeros. We can use an SRLI by C3; // followed by a SHXADD using c3 for the X amount.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:56,mask,mask,56,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,"// Look for (shl (and X, Mask), C1) where Mask has 32 leading zeros and; // C3 trailing zeros. If C1+C3==ShAmt we can use SRLIW+SHXADD.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:25,Mask,Mask,25,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,2,['Mask'],['Mask']
Availability,"// Look for (srl (and X, Mask), C1) where Mask has 32 leading zeros and; // C3 trailing zeros. If C3-C1==ShAmt we can use SRLIW+SHXADD.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:25,Mask,Mask,25,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,2,['Mask'],['Mask']
Availability,"// Look for PHI uses of the extended result, we don't want to extend the; // liveness of a PHI input. It breaks all kinds of assumptions down; // stream. A PHI use is expected to be the kill of its source values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:137,down,down,137,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,1,['down'],['down']
Availability,"// Look for a ""splat"" mul pattern - it replicates bits across each half of; // a value, so a right shift is just a mask of the low bits:; // lshr i[2N] (mul nuw X, (2^N)+1), N --> and iN X, (2^N)-1; // TODO: Generalize to allow more than just half-width shifts?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:115,mask,mask,115,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,1,['mask'],['mask']
Availability,// Look for a KAND+KORTEST and turn it into KTEST if only the zero flag is; // used. We're doing this late so we can prefer to fold the AND into masked; // comparisons. Doing that can be better for the live range of the mask; // register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:145,mask,masked,145,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,2,['mask'],"['mask', 'masked']"
Availability,"// Look for a binop feeding into an AND with a mask:; //; // %add = G_ADD %lhs, %rhs; // %and = G_AND %add, 000...11111111; //; // Check if it's possible to perform the binop at a narrower width and zext; // back to the original width like so:; //; // %narrow_lhs = G_TRUNC %lhs; // %narrow_rhs = G_TRUNC %rhs; // %narrow_add = G_ADD %narrow_lhs, %narrow_rhs; // %new_add = G_ZEXT %narrow_add; // %and = G_AND %new_add, 000...11111111; //; // This can allow later combines to eliminate the G_AND if it turns out; // that the mask is irrelevant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:47,mask,mask,47,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,2,['mask'],['mask']
Availability,// Look for a redundant movzx/movsx that can occur after an 8-bit divrem.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:14,redundant,redundant,14,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['redundant'],['redundant']
Availability,"// Look for a shuffle with the mask u,0,1,2,3,4,5,6 or 1,2,3,4,5,6,7,u; // depending on the InsIndex.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:31,mask,mask,31,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['mask']
Availability,// Look for an inverted mask: (X & ~M) op (Y & M).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:24,mask,mask,24,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['mask'],['mask']
Availability,// Look for any clobbers performed by a register mask. Only test locations; // that are actually being tracked.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:49,mask,mask,49,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['mask'],['mask']
Availability,"// Look for cases where the source of a simple store or the destination; // of a simple load is being spilled. Try to use MVC instead.; //; // Although MVC is in practice a fast choice in these cases, it is still; // logically a bytewise copy. This means that we cannot use it if the; // load or store is volatile. We also wouldn't be able to use MVC if; // the two memories partially overlap, but that case cannot occur here,; // because we know that one of the memories is a full frame index.; //; // For performance reasons, we also want to avoid using MVC if the addresses; // might be equal. We don't worry about that case here, because spill slot; // coloring happens later, and because we have special code to remove; // MVCs that turn out to be redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:753,redundant,redundant,753,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,1,['redundant'],['redundant']
Availability,// Look for operations that take the lower `Width=Size-ShiftImm` bits of; // `ShiftSrc` and insert them into the upper `Width` bits of `MaskSrc` via; // shifting and masking that we can replace with a BFI (encoded as a BFM).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp:136,Mask,MaskSrc,136,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,2,"['Mask', 'mask']","['MaskSrc', 'masking']"
Availability,"// Look for situation like this:; // %reg101 = MOV %reg100; // %reg102 = ...; // %reg103 = ADD %reg102, %reg101; // ... = %reg103 ...; // %reg100 = MOV %reg103; // If there is a reversed copy chain from reg101 to reg103, commute the ADD; // to eliminate an otherwise unavoidable copy.; // FIXME:; // We can extend the logic further: If an pair of operands in an insn has; // been merged, the insn could be regarded as a virtual copy, and the virtual; // copy could also be used to construct a copy chain.; // To more generally minimize register copies, ideally the logic of two addr; // instruction pass should be integrated with register allocation pass where; // interference graph is available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:687,avail,available,687,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,1,['avail'],['available']
Availability,// Look for stores of arguments to static allocas. Mark such arguments with a; // flag to ask the target to give us the memory location of that argument if; // available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:160,avail,available,160,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['avail'],['available']
Availability,"// Look for the Objective-C modifier flags, if any.; // We parse these here, even if they don't apply to; // the conversion specifier, and then emit an error; // later if the conversion specifier isn't '@'. This; // enables better recovery, and we don't know if; // these flags are applicable until later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp:152,error,error,152,interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp,2,"['error', 'recover']","['error', 'recovery']"
Availability,"// Look for the symbol in non-imported modules, but only if an error; // actually occurred.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:63,error,error,63,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,1,['error'],['error']
Availability,// Look in the list of free memory regions and use a block there if one; // is available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp:79,avail,available,79,interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp,1,['avail'],['available']
Availability,"// Look though an optional truncation. The source operand may not be the; // same type as the original 'and', but that is ok because we are masking; // off everything but the low bit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:140,mask,masking,140,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['masking']
Availability,"// Look through 8-byte initializer list 16 bytes at a time;; // If one of the two 8-byte halfs is non-zero non-undef, emit STGP.; // Otherwise, emit zeroes up to next available item.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64StackTagging.cpp:167,avail,available,167,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64StackTagging.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64StackTagging.cpp,1,['avail'],['available']
Availability,"// Look through argument promotions for our error message's reported type.; // This includes the integral and floating promotions, but excludes array; // and function pointer decay (seeing that an argument intended to be a; // string has type 'char [6]' is probably more confusing than 'char *') and; // certain bitfield promotions (bitfields can be 'demoted' to a lesser type).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:44,error,error,44,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['error'],['error']
Availability,// Look through the managed static to trigger construction of the managed; // static which registers our fatal error handler. This ensures it is only; // registered once.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:111,error,error,111,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,1,['error'],['error']
Availability,"// Look through the various header search paths to load any available module; // maps, searching for a module map that describes this module.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:60,avail,available,60,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,1,['avail'],['available']
Availability,"// Look up and classify the identifier. We don't perform any typo-correction; // after a scope specifier, because in general we can't recover from typos; // there (eg, after correcting 'A::template B<X>::C' [sic], we would need to; // jump back into scope specifier parsing).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:134,recover,recover,134,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp,1,['recover'],['recover']
Availability,"// Look up the directory for the file. When looking up something like; // sys/foo.h we'll discover all of the search directories that have a 'sys'; // subdirectory. This will let us avoid having to waste time on known-to-fail; // searches when we go to find sys/bar.h, because all the search directories; // without a 'sys' subdir will get a cached failure result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp:349,failure,failure,349,interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,1,['failure'],['failure']
Availability,"// Looking down X axis, -Z horz, Y vert",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLViewer.cxx:11,down,down,11,graf3d/gl/src/TGLViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLViewer.cxx,2,['down'],['down']
Availability,"// Looking down Y axis, -X horz, Z vert",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLViewer.cxx:11,down,down,11,graf3d/gl/src/TGLViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLViewer.cxx,2,['down'],['down']
Availability,"// Looking down Y axis, -Z horz, X vert",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLViewer.cxx:11,down,down,11,graf3d/gl/src/TGLViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLViewer.cxx,2,['down'],['down']
Availability,"// Looking down Z axis, X horz, Y vert",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLViewer.cxx:11,down,down,11,graf3d/gl/src/TGLViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLViewer.cxx,2,['down'],['down']
Availability,"// Looking for method with a type bound requires the correct context exists.; // We need to insert a method into the list if the context is different.; // If the method's declaration matches the list; // a> the method belongs to a different context: we need to insert it, in; // order to emit the availability message, we need to prioritize over; // availability among the methods with the same declaration.; // b> the method belongs to the same context: there is no need to insert a; // new entry.; // If the method's declaration does not match the list, we insert it to the; // end.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:297,avail,availability,297,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,2,['avail'],['availability']
Availability,"// Lookup and save the FileID for the through header. If it isn't found; // in the search path, it's a fatal error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:109,error,error,109,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,1,['error'],['error']
Availability,"// Lookup failure for imaginary constants isn't fatal, there's still the; // GNU extension producing _Complex types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:10,failure,failure,10,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['failure'],['failure']
Availability,// Lookup of an unqualified type name has failed in MSVC compatibility mode.; // Give Sema a chance to recover if we are in a template with dependent base; // classes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:103,recover,recover,103,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['recover'],['recover']
Availability,// Lookup the CUDA / HIP architecture string. Only report an error if we were; // expecting the triple to be only NVPTX / AMDGPU.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:61,error,error,61,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['error'],['error']
Availability,// Lookup the current thread local recovery object.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp:35,recover,recovery,35,interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp,3,['recover'],['recovery']
Availability,"// LoongArch specific constraints in GCC: config/loongarch/constraints.md; //; // 'f': A floating-point register (if available).; // 'k': A memory operand whose address is formed by a base register and; // (optionally scaled) index register.; // 'l': A signed 16-bit constant.; // 'm': A memory operand whose address is formed by a base register and; // offset that is suitable for use in instructions with the same; // addressing mode as st.w and ld.w.; // 'I': A signed 12-bit constant (for arithmetic instructions).; // 'J': Integer zero.; // 'K': An unsigned 12-bit constant (for logic instructions).; // ""ZB"": An address that is held in a general-purpose register. The offset is; // zero.; // ""ZC"": A memory operand whose address is formed by a base register and; // offset that is suitable for use in instructions with the same; // addressing mode as ll.w and sc.w.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:117,avail,available,117,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,1,['avail'],['available']
Availability,// Loongson Advanced SIMD Extension is available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TargetParser/LoongArchTargetParser.h:39,avail,available,39,interpreter/llvm-project/llvm/include/llvm/TargetParser/LoongArchTargetParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TargetParser/LoongArchTargetParser.h,1,['avail'],['available']
Availability,// Loongson Binary Translation Extension is available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TargetParser/LoongArchTargetParser.h:44,avail,available,44,interpreter/llvm-project/llvm/include/llvm/TargetParser/LoongArchTargetParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TargetParser/LoongArchTargetParser.h,1,['avail'],['available']
Availability,// Loongson SIMD Extension is available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TargetParser/LoongArchTargetParser.h:30,avail,available,30,interpreter/llvm-project/llvm/include/llvm/TargetParser/LoongArchTargetParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TargetParser/LoongArchTargetParser.h,1,['avail'],['available']
Availability,// Loongson Virtualization Extension is available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TargetParser/LoongArchTargetParser.h:40,avail,available,40,interpreter/llvm-project/llvm/include/llvm/TargetParser/LoongArchTargetParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TargetParser/LoongArchTargetParser.h,1,['avail'],['available']
Availability,"// Loop backwards over the list of primitives. The first non-pad primitive; // found is the selected one. However, we have to keep going down the; // list to see if there is maybe a pad overlaying the primitive. In that; // case look into the pad for a possible primitive. Once a pad has been; // found we can terminate the loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TPad.cxx:137,down,down,137,graf2d/gpad/src/TPad.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TPad.cxx,1,['down'],['down']
Availability,"// Loop going while iv is ""less"" with the iv value going down. Must wrap.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:57,down,down,57,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,1,['down'],['down']
Availability,"// Loop over PhysRegDef / PhysRegUse, killing any registers that are; // available at the end of the basic block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:73,avail,available,73,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,1,['avail'],['available']
Availability,"// Loop over all branches, filling and accumulating bytes written and error counts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:70,error,error,70,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['error'],['error']
Availability,"// Loop over entire data set, skipping masked entries",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataHist.cxx:39,mask,masked,39,roofit/roofitcore/src/RooDataHist.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataHist.cxx,2,['mask'],['masked']
Availability,"// Loop over errors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealMPFE.cxx:13,error,errors,13,roofit/roofitcore/src/RooRealMPFE.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealMPFE.cxx,1,['error'],['errors']
Availability,"// Loop over the shuffle mask, evaluating each element.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:25,mask,mask,25,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,1,['mask'],['mask']
Availability,"// Loop over the template parameters and arguments recursively.; // We go down the two lanes: the one of template parameters (decls) and the; // one of template arguments (QualTypes) in parallel. The former are a; // property of the template, independent of its instantiations.; // The latter are a property of the instance itself.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx:74,down,down,74,core/clingutils/src/TClingUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx,1,['down'],['down']
Availability,// Loop over the various components which exist and select the best GCC; // installation available. GCC installs are ranked by version number.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:89,avail,available,89,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,1,['avail'],['available']
Availability,"// Loop over those operands, corresponding to the normal arguments to the; // original function, and add those that are still alive.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:126,alive,alive,126,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,1,['alive'],['alive']
Availability,"// Loop passes are designed to run inside of a loop pass manager which means; // that any function analyses they require must be required by the first loop; // pass in the manager (so that it is computed before the loop pass manager; // runs) and preserved by all loop pasess in the manager. To make this; // reasonably robust, the set needed for most loop passes is maintained here.; // If your loop pass requires an analysis not listed here, you will need to; // carefully audit the loop pass manager nesting structure that results.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:320,robust,robust,320,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,1,['robust'],['robust']
Availability,"// Loop through each alias and emit code that handles each case. If there; // are two instructions without predicates, emit an error. If there is one,; // emit it last.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp:127,error,error,127,interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp,1,['error'],['error']
Availability,// Low byte shifted left to place of high byte: (Src & Mask) << ShiftAmt.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:55,Mask,Mask,55,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,1,['Mask'],['Mask']
Availability,// Low-level accessors; /// Mark that there are external lexical declarations that we need; /// to include in our lookup table (and that are not available as external; /// visible lookups). These extra lookup results will be found by walking; /// the lexical declarations of this context. This should be used only if; /// setHasExternalLexicalStorage() has been called on any decl context for; /// which this is the primary context.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h:145,avail,available,145,interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,1,['avail'],['available']
Availability,// LowZBits <= ShiftAmtC will fall into isBitfieldPositioningOp; // BitWidth != LowZBits + MaskLen doesn't match the pattern,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:91,Mask,MaskLen,91,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,1,['Mask'],['MaskLen']
Availability,"// Lower ATOMIC_LOAD_SUB into ATOMIC_LOAD_ADD if LAA and LAAG are; // available, or if the operand is constant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:70,avail,available,70,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['avail'],['available']
Availability,// Lower FP selects into a CMP/AND/ANDN/OR sequence when the necessary SSE ops; // are available or VBLENDV if AVX is available.; // Otherwise FP cmovs get lowered into a less efficient branch sequence later.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:87,avail,available,87,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['avail'],['available']
Availability,// Lower PSHUFB and VPERMILP normally but add a comment if we can find; // a constant shuffle mask. We won't be able to do this at the MC layer; // because the mask isn't an immediate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86MCInstLower.cpp:94,mask,mask,94,interpreter/llvm-project/llvm/lib/Target/X86/X86MCInstLower.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86MCInstLower.cpp,2,['mask'],['mask']
Availability,"// Lower VECTOR_SHUFFLE into ILVEV (if possible).; //; // ILVEV interleaves the even elements from each vector.; //; // It is possible to lower into ILVEV when the mask consists of two of the; // following forms interleaved:; // <0, 2, 4, ...>; // <n, n+2, n+4, ...>; // where n is the number of elements in the vector.; // For example:; // <0, 0, 2, 2, 4, 4, ...>; // <0, n, 2, n+2, 4, n+4, ...>; //; // When undef's appear in the mask they are treated as if they were whatever; // value is necessary in order to fit the above forms.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:164,mask,mask,164,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,2,['mask'],['mask']
Availability,"// Lower VECTOR_SHUFFLE into ILVL (if possible).; //; // ILVL interleaves consecutive elements from the left (highest-indexed) half; // of each vector.; //; // It is possible to lower into ILVL when the mask consists of two of the; // following forms interleaved:; // <x, x+1, x+2, ...>; // <n+x, n+x+1, n+x+2, ...>; // where n is the number of elements in the vector and x is half n.; // For example:; // <x, x, x+1, x+1, x+2, x+2, ...>; // <x, n+x, x+1, n+x+1, x+2, n+x+2, ...>; //; // When undef's appear in the mask they are treated as if they were whatever; // value is necessary in order to fit the above forms.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:203,mask,mask,203,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,2,['mask'],['mask']
Availability,"// Lower VECTOR_SHUFFLE into ILVOD (if possible).; //; // ILVOD interleaves the odd elements from each vector.; //; // It is possible to lower into ILVOD when the mask consists of two of the; // following forms interleaved:; // <1, 3, 5, ...>; // <n+1, n+3, n+5, ...>; // where n is the number of elements in the vector.; // For example:; // <1, 1, 3, 3, 5, 5, ...>; // <1, n+1, 3, n+3, 5, n+5, ...>; //; // When undef's appear in the mask they are treated as if they were whatever; // value is necessary in order to fit the above forms.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:163,mask,mask,163,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,2,['mask'],['mask']
Availability,"// Lower VECTOR_SHUFFLE into ILVR (if possible).; //; // ILVR interleaves consecutive elements from the right (lowest-indexed) half of; // each vector.; //; // It is possible to lower into ILVR when the mask consists of two of the; // following forms interleaved:; // <0, 1, 2, ...>; // <n, n+1, n+2, ...>; // where n is the number of elements in the vector.; // For example:; // <0, 0, 1, 1, 2, 2, ...>; // <0, n, 1, n+1, 2, n+2, ...>; //; // When undef's appear in the mask they are treated as if they were whatever; // value is necessary in order to fit the above forms.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:203,mask,mask,203,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,2,['mask'],['mask']
Availability,"// Lower VECTOR_SHUFFLE into PCKEV (if possible).; //; // PCKEV copies the even elements of each vector into the result vector.; //; // It is possible to lower into PCKEV when the mask consists of two of the; // following forms concatenated:; // <0, 2, 4, ...>; // <n, n+2, n+4, ...>; // where n is the number of elements in the vector.; // For example:; // <0, 2, 4, ..., 0, 2, 4, ...>; // <0, 2, 4, ..., n, n+2, n+4, ...>; //; // When undef's appear in the mask they are treated as if they were whatever; // value is necessary in order to fit the above forms.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:180,mask,mask,180,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,2,['mask'],['mask']
Availability,"// Lower VECTOR_SHUFFLE into PCKOD (if possible).; //; // PCKOD copies the odd elements of each vector into the result vector.; //; // It is possible to lower into PCKOD when the mask consists of two of the; // following forms concatenated:; // <1, 3, 5, ...>; // <n+1, n+3, n+5, ...>; // where n is the number of elements in the vector.; // For example:; // <1, 3, 5, ..., 1, 3, 5, ...>; // <1, 3, 5, ..., n+1, n+3, n+5, ...>; //; // When undef's appear in the mask they are treated as if they were whatever; // value is necessary in order to fit the above forms.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:179,mask,mask,179,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,2,['mask'],['mask']
Availability,"// Lower VECTOR_SHUFFLE into SHF (if possible).; //; // SHF splits the vector into blocks of four elements, then shuffles these; // elements according to a <4 x i2> constant (encoded as an integer immediate).; //; // It is therefore possible to lower into SHF when the mask takes the form:; // <a, b, c, d, a+4, b+4, c+4, d+4, a+8, b+8, c+8, d+8, ...>; // When undef's appear they are treated as if they were whatever value is; // necessary in order to fit the above forms.; //; // For example:; // %2 = shufflevector <8 x i16> %0, <8 x i16> undef,; // <8 x i32> <i32 3, i32 2, i32 1, i32 0,; // i32 7, i32 6, i32 5, i32 4>; // is lowered to:; // (SHF_H $w0, $w1, 27); // where the 27 comes from:; // 3 + (2 << 2) + (1 << 4) + (0 << 6)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:269,mask,mask,269,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,1,['mask'],['mask']
Availability,"// Lower a vector comparison of type CC between CmpOp0 and CmpOp1, producing; // an integer mask of type VT. If Chain is nonnull, we have a strict; // floating-point comparison. If in addition IsSignaling is true, we have; // a strict signaling floating-point comparison.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:92,mask,mask,92,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['mask'],['mask']
Availability,"// Lower constant mask BUILD_VECTORs via an integer vector type, in; // scalar integer chunks whose bit-width depends on the number of mask; // bits and XLEN.; // First, determine the most appropriate scalar integer type to use. This; // is at most XLenVT, but may be shrunk to a smaller vector element type; // according to the size of the final vector - use i8 chunks rather than; // XLenVT if we're producing a v8i1. This results in more consistent; // codegen across RV32 and RV64.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:18,mask,mask,18,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,2,['mask'],['mask']
Availability,"// Lower priority means schedule further down. For bottom-up scheduling, lower; // priority SUs are scheduled before higher priority SUs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:41,down,down,41,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,2,['down'],['down']
Availability,"// Lower splats of i1 types to SETCC. For each mask vector type, we have a; // legal equivalently-sized i8 type, so we can use that as a go-between.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:47,mask,mask,47,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['mask'],['mask']
Availability,"// Lower the number of redundant components when there's a mismatch; // between the first path, and the path under consideration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp:23,redundant,redundant,23,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,1,['redundant'],['redundant']
Availability,// Lower the promoted Float down to the integer value of same size and construct; // a STORE of the integer value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeFloatTypes.cpp:28,down,down,28,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeFloatTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeFloatTypes.cpp,1,['down'],['down']
Availability,// Lower the read_register intrinsic to ARM specific DAG nodes; // using the supplied metadata string to select the instruction node to use; // and the registers/masks to construct as operands for the node.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp:162,mask,masks,162,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,1,['mask'],['masks']
Availability,// Lower the write_register intrinsic to ARM specific DAG nodes; // using the supplied metadata string to select the instruction node to use; // and the registers/masks to use in the nodes,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp:163,mask,masks,163,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,1,['mask'],['masks']
Availability,"// Lower this manually. We can't reliably determine whether or not any; // given va_copy() is for a Win64 va_list from the calling convention; // alone, because it's legal to do this from a System V ABI function.; // With opaque pointer types, we won't have enough information in LLVM; // IR to determine this from the argument types, either. Best to do it; // now, while we have enough information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:33,reliab,reliably,33,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,1,['reliab'],['reliably']
Availability,"// Lower undefs (represented by -1 in mask) to {0..J}, which use a; // whole lane of vector input, to allow further reduction at VM. E.g.; // match an 8x16 byte shuffle to an equivalent cheaper 32x4 shuffle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:38,mask,mask,38,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,1,['mask'],['mask']
Availability,"// Lower v16i8/v32i8 as extension to v8i16/v16i16 vector pairs, multiply,; // logical shift down the upper half and pack back to i8.; // With SSE41 we can use sign/zero extend, but for pre-SSE41 we unpack; // and then ashr/lshr the upper bits down to the lower bits before multiply.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:92,down,down,92,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['down'],['down']
Availability,"// Lower vXi1 vector shuffles.; // There is no a dedicated instruction on AVX-512 that shuffles the masks.; // The only way to shuffle bits is to sign-extend the mask vector to SIMD; // vector, shuffle and then truncate it back.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:100,mask,masks,100,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['mask'],"['mask', 'masks']"
Availability,"// Lower vector extended loads using a shuffle. If SSSE3 is not available we; // may emit an illegal shuffle but the expansion is still better than scalar; // code. We generate sext/sext_invec for SEXTLOADs if it's available, otherwise; // we'll emit a shuffle and a arithmetic shift.; // FIXME: Is the expansion actually better than scalar code? It doesn't seem so.; // TODO: It is possible to support ZExt by zeroing the undef values during; // the shuffle phase or after the shuffle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:64,avail,available,64,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['avail'],['available']
Availability,"// LowerKCFI_CHECK emits -Value for indirect call checks, so we must also; // mask that. Note that -(Value + 1) == ~Value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp:78,mask,mask,78,interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp,1,['mask'],['mask']
Availability,// Lowering of DYNAMIC_STACKALLOC is unsupported.; // Custom lower to produce an error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:81,error,error,81,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,1,['error'],['error']
Availability,// M must be a valid mask for *this.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp:21,mask,mask,21,interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp,1,['mask'],['mask']
Availability,"// M.C. Value of ERROR ,temporary assignment",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/foam/src/TFoam.cxx:17,ERROR,ERROR,17,math/foam/src/TFoam.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/foam/src/TFoam.cxx,1,['ERROR'],['ERROR']
Availability,// MASK: zmmX {%kY},MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86InstComments.cpp:3,MASK,MASK,3,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86InstComments.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86InstComments.cpp,1,['MASK'],['MASK']
Availability,// MASKZ: zmmX {%kY} {z},MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86InstComments.cpp:3,MASK,MASKZ,3,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86InstComments.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86InstComments.cpp,1,['MASK'],['MASKZ']
Availability,"// MCAsmInfo isn't always present (e.g. in opt) so we can't initialize this; // directly from it, but we can try to make sure they're consistent when both; // available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp:159,avail,available,159,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp,1,['avail'],['available']
Availability,"// MCAssembler::evaluateFixup will emit an error for this case when it sees; // the %pcrel_hi, so don't duplicate it when also seeing the %pcrel_lo.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVAsmBackend.cpp:43,error,error,43,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVAsmBackend.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVAsmBackend.cpp,1,['error'],['error']
Availability,"// MCDecl might be null due to error in method or c-function prototype, etc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:31,error,error,31,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,1,['error'],['error']
Availability,"// MINImize [maxcalls] [tolerance]; // also SIMplex, MIGrad and FUMili",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumili.cxx:24,toler,tolerance,24,math/fumili/src/TFumili.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumili.cxx,1,['toler'],['tolerance']
Availability,"// MINos errors - not implemented",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumili.cxx:9,error,errors,9,math/fumili/src/TFumili.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumili.cxx,1,['error'],['errors']
Availability,"// MINos errors analysis not implemented",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumili.cxx:9,error,errors,9,math/fumili/src/TFumili.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumili.cxx,1,['error'],['errors']
Availability,// MIR printing is redundant with -filetype=null.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp:19,redundant,redundant,19,interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp,1,['redundant'],['redundant']
Availability,// MMA operations are not available pre-Power10.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp:26,avail,available,26,interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp,1,['avail'],['available']
Availability,"// MOVMSK(SHUFFLE(X,u)) -> MOVMSK(X) iff every element is referenced.; // Since we peek through a bitcast, we need to be careful if the base vector; // type has smaller elements than the MOVMSK type. In that case, even if; // all the elements are demanded by the shuffle mask, only the ""high""; // elements which have highbits that align with highbits in the MOVMSK vec; // elements are actually demanded. A simplification of spurious operations; // on the ""low"" elements take place during other simplifications.; //; // For example:; // MOVMSK64(BITCAST(SHUF32 X, (1,0,3,2))) even though all the elements are; // demanded, because we are swapping around the result can change.; //; // To address this, we check that we can scale the shuffle mask to MOVMSK; // element width (this will ensure ""high"" elements match). Its slightly overly; // conservative, but fine for an edge case fold.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:271,mask,mask,271,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['mask'],['mask']
Availability,// MSTORE; // HVX only has aligned masked stores.; // TODO: Fold negations of the mask into the store.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:35,mask,masked,35,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,2,['mask'],"['mask', 'masked']"
Availability,"// MSVC >= 19.15, < 19.20 need to see the definition of class Instruction to; // prevent compiler error C2139 about intrinsic type trait '__is_assignable'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/SourceMgr.h:98,error,error,98,interpreter/llvm-project/llvm/include/llvm/MCA/SourceMgr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/SourceMgr.h,1,['error'],['error']
Availability,// MSVC allows explicit template specialization at class scope:; // 2 CXXMethodDecls referring to the same function will be injected.; // We don't want a redeclaration error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:168,error,error,168,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['error'],['error']
Availability,"// MSVC and g++ won't examine the rest of declarators if '=' is; // encountered; they just conclude that we have a declaration.; // EDG parses the initializer completely, which is the proper behavior; // for this case.; //; // At present, Clang follows MSVC and g++, since the parser does not have; // the ability to parse an expression fully without recording the; // results of that parse.; // FIXME: Handle this case correctly.; //; // Also allow 'in' after an Objective-C declaration as in:; // for (int (^b)(void) in array). Ideally this should be done in the; // context of parsing for-init-statement of a foreach statement only. But,; // in any other context 'in' is invalid after a declaration and parser; // issues the error regardless of outcome of this decision.; // FIXME: Change if above assumption does not hold.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:728,error,error,728,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,1,['error'],['error']
Availability,"// MSVC treats in-class initialized static data members as definitions.; // By giving them non-strong linkage, out-of-line definitions won't; // cause link errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:156,error,errors,156,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['error'],['errors']
Availability,// MSVC2013 and before print 'file(4) : error'. MSVC2015 gets rid of the; // space and prints 'file(4): error'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp:40,error,error,40,interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp,2,['error'],['error']
Availability,"// MSVC: If previous token was pasted, this must be a recovery from an invalid; // paste operation. Ignore spaces before this token to mimic MSVC output.; // Required for generating valid UUID strings in some MS headers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:54,recover,recovery,54,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,1,['recover'],['recovery']
Availability,"// MT case, error coming from the TTreeProcessorMT",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.cxx:12,error,error,12,tree/dataframe/test/dataframe_datasetspec.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.cxx,1,['error'],['error']
Availability,"// MVE Masked loads use zero as the passthru value. Here we convert undef to; // zero too, and other values are lowered to a select.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:7,Mask,Masked,7,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['Mask'],['Masked']
Availability,"// MXCSR: mask all floating-point exceptions, sets rounding to nearest, clear; // all exceptions, sets DAZ and FTZ to 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:10,mask,mask,10,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// MachO large model always goes via a GOT, because we don't have the; // relocations available to do anything else..",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Subtarget.cpp:86,avail,available,86,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Subtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Subtarget.cpp,1,['avail'],['available']
Availability,"// Machine round-off error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoShape.h:21,error,error,21,geom/geom/inc/TGeoShape.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoShape.h,1,['error'],['error']
Availability,// Make __builtin_ms_va_list available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp:29,avail,available,29,interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp,2,['avail'],['available']
Availability,// Make a 32-bit mask w/ the referenced bits clear and all other bits set.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:17,mask,mask,17,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['mask'],['mask']
Availability,// Make a copy of the mask so it can be modified.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:22,mask,mask,22,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// Make a new Mask node, with a legal result VT.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:14,Mask,Mask,14,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,1,['Mask'],['Mask']
Availability,"// Make a stream refernce that will become a /dev/null log stream if; // Quiet is true, or normal output if Quiet is false. This can stop the; // errors and warnings from being displayed and producing too much output; // when they aren't desired.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-gsymutil/llvm-gsymutil.cpp:146,error,errors,146,interpreter/llvm-project/llvm/tools/llvm-gsymutil/llvm-gsymutil.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-gsymutil/llvm-gsymutil.cpp,1,['error'],['errors']
Availability,// Make a tag bit available to users of this class.; // FIXME: This is a horrible hack.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTVector.h:18,avail,available,18,interpreter/llvm-project/clang/include/clang/AST/ASTVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTVector.h,1,['avail'],['available']
Availability,// Make all operands of the GEP available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:32,avail,available,32,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,1,['avail'],['available']
Availability,"// Make googletest report the current bin index on failure",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/binning.cxx:51,failure,failure,51,hist/histv7/test/binning.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/binning.cxx,1,['failure'],['failure']
Availability,// Make largest subset of device functions available during host; // compilation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:43,avail,available,43,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,1,['avail'],['available']
Availability,"// Make list of parameter instances of cloneFunc in order of error matrix",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:61,error,error,61,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,2,['error'],['error']
Availability,"// Make node available to RecursiveRemove",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TList.cxx:13,avail,available,13,core/cont/src/TList.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TList.cxx,2,['avail'],['available']
Availability,"// Make our local copy of the tree, so we can safely loop through it.; // We need a custom deleter, because if we don't deregister the Tree from the directory; // of the original, it tears it down at destruction time!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooTreeDataStore.cxx:192,down,down,192,roofit/roofitcore/src/RooTreeDataStore.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooTreeDataStore.cxx,1,['down'],['down']
Availability,"// Make rootetcdir available to all the session via env",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/DaemonUtils.cxx:19,avail,available,19,net/rpdutils/src/DaemonUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/DaemonUtils.cxx,1,['avail'],['available']
Availability,// Make sure 64-bit features are available when CPUname is generic,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:33,avail,available,33,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,1,['avail'],['available']
Availability,"// Make sure Offset fits within the field available.; // For MSA instructions, this is a 10-bit signed immediate (scaled by; // element size), otherwise it is a 16-bit signed immediate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSERegisterInfo.cpp:42,avail,available,42,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSERegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSERegisterInfo.cpp,1,['avail'],['available']
Availability,// Make sure a fresh CFG snapshot is available before the pass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/StandardInstrumentations.cpp:37,avail,available,37,interpreter/llvm-project/llvm/lib/Passes/StandardInstrumentations.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/StandardInstrumentations.cpp,1,['avail'],['available']
Availability,"// Make sure it is not smaller then the cache, if the info is available and the size; // synchronization is required. But apply the cache-packet size synchronization only if there; // are enough left files to process and the files are all of similar sizes. Otherwise we risk; // to not exploit optimally all potentially active workers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizerAdaptive.cxx:62,avail,available,62,proof/proofplayer/src/TPacketizerAdaptive.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizerAdaptive.cxx,1,['avail'],['available']
Availability,// Make sure lexing errors have propagated to the parser.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/MCAsmParser.cpp:20,error,errors,20,interpreter/llvm-project/llvm/lib/MC/MCParser/MCAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/MCAsmParser.cpp,1,['error'],['errors']
Availability,"// Make sure none of the operands of this instruction do anything that; // might break if they're moved outside their current function.; // This includes MachineBasicBlock references, BlockAddressses,; // Constant pool indices and jump table indices.; //; // A quick note on MO_TargetIndex:; // This doesn't seem to be used in any of the architectures that the; // MachineOutliner supports, but it was still filtered out in all of them.; // There was one exception (RISC-V), but MO_TargetIndex also isn't used there.; // As such, this check is removed both here and in the target-specific; // implementations. Instead, we assert to make sure this doesn't; // catch anyone off-guard somewhere down the line.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:692,down,down,692,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,1,['down'],['down']
Availability,"// Make sure package is available on all slaves, even new ones",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:24,avail,available,24,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['avail'],['available']
Availability,// Make sure that if extra top down states are added in the future that this; // code is updated to handle it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:31,down,down,31,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,1,['down'],['down']
Availability,// Make sure that it's really an empty and not a failure of; // semantic analysis.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp:49,failure,failure,49,interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp,1,['failure'],['failure']
Availability,"// Make sure that no Phi input comes from an unreachable block. Otherwise,; // even the values that are not available in these blocks may come from them,; // and this leads to false-positive recurrence test.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:108,avail,available,108,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['avail'],['available']
Availability,"// Make sure that no error occurred",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:21,error,error,21,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,1,['error'],['error']
Availability,// Make sure that the SINT_TO_FP and SRL instructions are available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp:58,avail,available,58,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,1,['avail'],['available']
Availability,// Make sure that the SRA and SHL instructions are available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp:51,avail,available,51,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,1,['avail'],['available']
Availability,// Make sure that the file buffer stays alive for the duration of the; // weighted input vector's lifetime.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profdata/llvm-profdata.cpp:40,alive,alive,40,interpreter/llvm-project/llvm/tools/llvm-profdata/llvm-profdata.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profdata/llvm-profdata.cpp,1,['alive'],['alive']
Availability,// Make sure that the function is available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:34,avail,available,34,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,1,['avail'],['available']
Availability,"// Make sure that the operands are available at the branch.; // SrcReg2 is the register if the source operand is a register,; // 0 if the source operand is immediate, and the base register; // if the source operand is memory (index is not supported).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:35,avail,available,35,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,1,['avail'],['available']
Availability,"// Make sure that the relevant files are available",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:41,avail,available,41,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['avail'],['available']
Availability,// Make sure that the stored values is available everywhere in the loop in; // the next iteration.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:39,avail,available,39,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,1,['avail'],['available']
Availability,"// Make sure that the symbol is actually in a section here. If it isn't,; // emit an error and exit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64MachObjectWriter.cpp:85,error,error,85,interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64MachObjectWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64MachObjectWriter.cpp,1,['error'],['error']
Availability,"// Make sure that we don't make an ill-formed AST where the type of the; // Class is non-dependent and its attached base class specifier is an; // dependent type, which violates invariants in many clang code paths (e.g.; // constexpr evaluator). If this case happens (in errory-recovery mode), we; // explicitly mark the Class decl invalid. The diagnostic was already; // emitted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:271,error,errory-recovery,271,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['error'],['errory-recovery']
Availability,"// Make sure that we won't clobber any live ins to the sibling block by; // hoisting Dependency. For instance, we can't hoist INST to before the; // null check (even if it safe, and does not violate any dependencies in; // the non_null_block) if %rdx is live in to _null_block.; //; // test %rcx, %rcx; // je _null_block; // _non_null_block:; // %rdx = INST; // ...; //; // This restriction does not apply to the faulting load inst because in; // case the pointer loaded from is in the null page, the load will not; // semantically execute, and affect machine state. That is, if the load; // was loading into %rax and it faults, the value of %rax should stay the; // same as it would have been had the load not have executed and we'd have; // branched to NullSucc directly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:413,fault,faulting,413,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,2,['fault'],"['faulting', 'faults']"
Availability,"// Make sure the length as recorded in the table and the standard length; // for the opcode match. If they don't, continue from the end as claimed; // by the table. Similarly, continue from the claimed end in the event of; // a parsing error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFDebugLine.cpp:236,error,error,236,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFDebugLine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFDebugLine.cpp,1,['error'],['error']
Availability,"// Make sure the macro is in the Preprocessor. Not sure if not redundant; // because removeMacro looks for the macro anyway in the DenseMap Macros[]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclUnloader.cpp:63,redundant,redundant,63,interpreter/cling/lib/Interpreter/DeclUnloader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclUnloader.cpp,1,['redundant'],['redundant']
Availability,// Make sure the mask elements make sense.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:17,mask,mask,17,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,1,['mask'],['mask']
Availability,// Make sure the mask has the right size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:17,mask,mask,17,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,3,['mask'],['mask']
Availability,// Make sure the mask indices are in range.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:17,mask,mask,17,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,1,['mask'],['mask']
Availability,// Make sure the mask of OpVal is true mask or is same as Root's.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:17,mask,mask,17,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['mask'],['mask']
Availability,// Make sure the new mask can be represented by a combination of mask bits; // and non-demanded bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:21,mask,mask,21,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['mask'],['mask']
Availability,"// Make sure the shuffle mask selects the ""least significant bits"" by; // keeping elements from back of the src vector for big endian, and from the; // front for little endian.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:25,mask,mask,25,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,1,['mask'],['mask']
Availability,"// Make sure the unique query tag is available as TNamed object in the; // input list so that it can be used in TSelectors for monitoring",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofLite.cxx:37,avail,available,37,proof/proof/src/TProofLite.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofLite.cxx,1,['avail'],['available']
Availability,"// Make sure this is not a spill slot: spill slots cannot be aligned; // if there are variable-sized objects on the stack. They must be; // accessible via FP (which is not aligned), because SP is unknown,; // and AP may not be available at the location of the load/store.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp:227,avail,available,227,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp,1,['avail'],['available']
Availability,"// Make sure to attach to the process (and wait for the sigstop to be; // delivered and for the process to continue) before we write to the counter; // file descriptor. Attaching to the process before writing to the socket; // ensures that the subprocess at most has blocked on the read call. If we; // attach afterwards, the subprocess might exit before we get to the attach; // call due to effects like scheduler contention, introducing transient; // failures.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp:453,failure,failures,453,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp,1,['failure'],['failures']
Availability,// Make sure to pass down the right value for isAddressOfOperand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:21,down,down,21,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,1,['down'],['down']
Availability,// Make sure we are not parsing something; // that looks like a label or an expression but is not.; // This will improve error messages.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp:121,error,error,121,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp,1,['error'],['error']
Availability,"// Make sure we do not visit the same node twice.; // Otherwise, we'll visit the common ancestors as often as there; // are splits on the way down.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp:142,down,down,142,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp,1,['down'],['down']
Availability,// Make sure we don't have leftover partial state from an attempt where we; // had no available candidates and bailed out early.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:86,avail,available,86,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,1,['avail'],['available']
Availability,// Make sure we don't rely on some value being still alive in; // InterpStack memory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Context.cpp:53,alive,alive,53,interpreter/llvm-project/clang/lib/AST/Interp/Context.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Context.cpp,3,['alive'],['alive']
Availability,// Make sure we have a bitcast between mask registers and a scalar type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:39,mask,mask,39,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Make sure we print the summary and the current unit when LLVM errors out.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-isel-fuzzer/llvm-isel-fuzzer.cpp:65,error,errors,65,interpreter/llvm-project/llvm/tools/llvm-isel-fuzzer/llvm-isel-fuzzer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-isel-fuzzer/llvm-isel-fuzzer.cpp,2,['error'],['errors']
Availability,"// Make the SVE types available. Note that this deliberately doesn't; // depend on SveMode, since in principle it should be possible to turn; // SVE on and off within a translation unit. It should also be possible; // to compile the global declaration:; //; // __SVInt8_t *ptr;; //; // even without SVE.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp:22,avail,available,22,interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp,1,['avail'],['available']
Availability,"// Make the absolute stat error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/HistoToWorkspaceFactoryFast.cxx:26,error,error,26,roofit/histfactory/src/HistoToWorkspaceFactoryFast.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/HistoToWorkspaceFactoryFast.cxx,1,['error'],['error']
Availability,// Make the compile command echo its inputs for /showFilenames.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:28,echo,echo,28,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['echo'],['echo']
Availability,"// Make the enum values available in the defined namespace. This allows us to; // write something like Enum_X if we have a `using namespace <CppNamespace>`.; // At the same time we do not loose the strong type guarantees of the enum; // class, that is we cannot pass an unsigned as Directive without an explicit; // cast.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DirectiveEmitter.cpp:24,avail,available,24,interpreter/llvm-project/llvm/utils/TableGen/DirectiveEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DirectiveEmitter.cpp,1,['avail'],['available']
Availability,// Make the mask's bitwidth at least 8-bit and a power-of-2 to avoid; // unnecessary illegal types.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:12,mask,mask,12,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['mask'],['mask']
Availability,"// Make the ordinal number available in the selector",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:27,avail,available,27,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['avail'],['available']
Availability,// Make the selection of the recovery decl deterministic.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:29,recover,recovery,29,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['recover'],['recovery']
Availability,// Make the target register an available value for this block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:31,avail,available,31,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,1,['avail'],['available']
Availability,"// Make this tuple mutable to avoid casts that obfuscate const-correctness; // issues. Const-correctness of references is taken care of by `zippy` that; // defines const-non and const iterator types that will propagate down to; // `enumerator_result`'s `Refs`.; // Note that unlike the results of `zip*` functions, `enumerate`'s result are; // supposed to be modifiable even when defined as; // `const`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:219,down,down,219,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,1,['down'],['down']
Availability,// Make uses alive.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNRegPressure.cpp:13,alive,alive,13,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNRegPressure.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNRegPressure.cpp,1,['alive'],['alive']
Availability,"// Make weighted XY dataset with asymmetric errors stored The StoreError(); // argument is essential as it makes the dataset store the error in addition; // to the values of the observables. If errors on one or more observables; // are asymmetric, one can store the asymmetric error using the; // StoreAsymError() argument",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testTestStatistics.cxx:44,error,errors,44,roofit/roofitcore/test/testTestStatistics.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testTestStatistics.cxx,4,['error'],"['error', 'errors']"
Availability,"// MakeDescriptor() returns an RResult<RFieldDescriptor>; // -- here we check the error cases; // must set field id",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_descriptor.cxx:82,error,error,82,tree/ntuple/v7/test/ntuple_descriptor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_descriptor.cxx,1,['error'],['error']
Availability,"// Manifest zeroable element knowledge in the shuffle mask.; // NOTE: we don't have 'zeroable' sentinel value in generic DAG,; // this is a local invention, but it won't leak into DAG.; // FIXME: should we not manifest them, but just check when matching?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:54,mask,mask,54,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['mask']
Availability,"// Many URLs? Redirect output and print errors in case of global failure",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:40,error,errors,40,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,4,"['error', 'failure']","['errors', 'failure']"
Availability,"// Map auto error type to actual type",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsData.cxx:12,error,error,12,roofit/roofitcore/src/RooAbsData.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsData.cxx,1,['error'],['error']
Availability,// Map each SU to its summary of pressure changes. This array is updated for; // liveness during bottom-up scheduling. Top-down scheduling may proceed but; // has no affect on the pressure diffs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:123,down,down,123,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,1,['down'],['down']
Availability,// Map extensions to warnings or errors?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h:33,error,errors,33,interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,1,['error'],['errors']
Availability,// Map from every function name in the module to its debug info filename or; // empty string if no debug info is available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicBlockSectionsProfileReader.h:113,avail,available,113,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicBlockSectionsProfileReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicBlockSectionsProfileReader.h,1,['avail'],['available']
Availability,"// Map global ID of the definition down to the local ID used in this; // module file. If there is no such mapping, we'll find nothing here; // (or in any module it imports).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:35,down,down,35,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,1,['down'],['down']
Availability,// Map of values to the locations that store them for every value used by; // the variables that may have become available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:113,avail,available,113,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['avail'],['available']
Availability,// Map the word mask through the DWord mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:16,mask,mask,16,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['mask'],['mask']
Availability,"// Map to keep track of created compares, The key is the pair of operands for; // the compare, to allow detecting and re-using redundant compares.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:127,redundant,redundant,127,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,1,['redundant'],['redundant']
Availability,// Mapping from event to counter according to the table masks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp:56,mask,masks,56,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,1,['mask'],['masks']
Availability,"// Maps a Banked Register string to its mask value. The mask value returned is; // for use in the MRSbanked / MSRbanked instruction nodes as the Banked Register; // mask operand, which expresses which register is to be used, e.g. r8, and in; // which mode it is to be used, e.g. usr. Returns -1 to signify that the string; // was invalid.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp:40,mask,mask,40,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,3,['mask'],['mask']
Availability,// Maps processor resource state indices (returned by calls to; // `getResourceStateIndex(Mask)` to processor resource identifiers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:90,Mask,Mask,90,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,1,['Mask'],['Mask']
Availability,"// Maps seen instructions that can be mapped to a TDC, values are; // (TDC operand, TDC mask, worthy flag) triples.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp:88,mask,mask,88,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp,1,['mask'],['mask']
Availability,// Mark Reg alive through the block if this is a PHI incoming block,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeVGPRLiveRange.cpp:12,alive,alive,12,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeVGPRLiveRange.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeVGPRLiveRange.cpp,1,['alive'],['alive']
Availability,"// Mark all variable to store their errors in the dataset",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMCStudy.cxx:36,error,errors,36,roofit/roofitcore/src/RooMCStudy.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMCStudy.cxx,1,['error'],['errors']
Availability,// Mark it alive only in the block we are representing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:11,alive,alive,11,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,1,['alive'],['alive']
Availability,"// Mark li as unspillable if all live ranges are tiny and the interval; // is not live at any reg mask. If the interval is live at a reg mask; // spilling may be required. If li is live as use in statepoint instruction; // spilling may be required due to if we mark interval with use in statepoint; // as not spillable we are risky to end up with no register to allocate.; // At the same time STATEPOINT instruction is perfectly fine to have this; // operand on stack, so spilling such interval and folding its load from stack; // into instruction itself makes perfect sense.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp:98,mask,mask,98,interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp,2,['mask'],['mask']
Availability,// Mark module as available if the only reason it was unavailable; // was missing headers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:18,avail,available,18,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,1,['avail'],['available']
Availability,// Mark the error condition as handled and continue.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h:12,error,error,12,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h,1,['error'],['error']
Availability,"// Mark the original store as dead now that we've split it up and kill its; // slice. Note that we leave the original load in place unless this store; // was its only use. It may in turn be split up if it is an alloca load; // for some other alloca, but it may be a normal load. This may introduce; // redundant loads, but where those can be merged the rest of the optimizer; // should handle the merging, and this uncovers SSA splits which is more; // important. In practice, the original loads will almost always be fully; // split and removed eventually, and the splits will be merged by any; // trivial CSE, including instcombine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:302,redundant,redundant,302,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['redundant'],['redundant']
Availability,"// Mark the particle's status as dead and decrement; // the total alive particles",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyEvent.cxx:66,alive,alive,66,test/RootShower/MyEvent.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyEvent.cxx,1,['alive'],['alive']
Availability,// Mark the registration node. The backend needs to know which alloca it is so; // that it can recover the original frame pointer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86WinEHState.cpp:95,recover,recover,95,interpreter/llvm-project/llvm/lib/Target/X86/X86WinEHState.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86WinEHState.cpp,1,['recover'],['recover']
Availability,// Mark this point as the bottom of the stack if we don't have somewhere; // better. We generally expect frontend actions to be invoked with (nearly); // DesiredStackSpace available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:172,avail,available,172,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,1,['avail'],['available']
Availability,// Mark u available for cycle detection,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/GCOV.cpp:10,avail,available,10,interpreter/llvm-project/llvm/lib/ProfileData/GCOV.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/GCOV.cpp,1,['avail'],['available']
Availability,// Marking tracked symbols alive,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp:27,alive,alive,27,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp,1,['alive'],['alive']
Availability,// Mask,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,2,['Mask'],['Mask']
Availability,// Mask & z,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Mask'],['Mask']
Availability,"// Mask (column allocation); // The ExclusiveMask has a different meaning for input and output signatures.; // For an output signature, masked components of the output register are never; // written to.; // For an input signature, masked components of the input register are always; // read.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/DXContainer.h:3,Mask,Mask,3,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/DXContainer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/DXContainer.h,3,"['Mask', 'mask']","['Mask', 'masked']"
Availability,// Mask 10 bits,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MCTargetDesc/MSP430AsmBackend.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Target/MSP430/MCTargetDesc/MSP430AsmBackend.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MCTargetDesc/MSP430AsmBackend.cpp,1,['Mask'],['Mask']
Availability,// Mask <N x i1> -> sext to <N x FromTy> -> bitcast to <M x ToTy> ->; // -> trunc to <M x i1>.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,1,['Mask'],['Mask']
Availability,"// Mask = {ExtractIndex, undef, undef....}",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['Mask'],['Mask']
Availability,// Mask = ~(1 << (Size-1)),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeFloatTypes.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeFloatTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeFloatTypes.cpp,1,['Mask'],['Mask']
Availability,// Mask VTs are custom-expanded into a series of standard nodes,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['Mask'],['Mask']
Availability,// Mask all FP exceptions,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp,1,['Mask'],['Mask']
Availability,// Mask and turn the control bits into a shift for the lookup table.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Mask'],['Mask']
Availability,// Mask and ~Mask2 (or reverse) must be equivalent for the BFI pattern; // as is to match.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['Mask'],['Mask']
Availability,// Mask assignments for PFD.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,1,['Mask'],['Mask']
Availability,// Mask assignments for TDC,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZ.h,1,['Mask'],['Mask']
Availability,// Mask assignments for floating-point,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.h:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.h,1,['Mask'],['Mask']
Availability,// Mask assignments for floating-point.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchInstrInfo.h:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchInstrInfo.h,1,['Mask'],['Mask']
Availability,// Mask binary operators.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,1,['Mask'],['Mask']
Availability,// Mask constant magic can eliminate an 'xor' with unsigned compares.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['Mask'],['Mask']
Availability,// Mask each bitmap byte into the BitVector. Go in reverse so that the; // bitvector can just be shifted over by one byte on each iteration.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMapping.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMapping.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMapping.cpp,1,['Mask'],['Mask']
Availability,// Mask element has to be i1.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['Mask'],['Mask']
Availability,// Mask f16 arguments if this is a CMSE nonsecure entry.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['Mask'],['Mask']
Availability,// Mask for EF_MIPS_ARCH_ASE_xxx flags; // ARCH,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:3,Mask,Mask,3,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,1,['Mask'],['Mask']
Availability,"// Mask for V8F64: 0/1, 8/9, 2/3, 10/11, 4/5, ..; // Mask for V4F64; 0/1, 4/5, 2/3, 6/7..",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['Mask'],['Mask']
Availability,// Mask for applying EF_MIPS_ARCH_ variant,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:3,Mask,Mask,3,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,1,['Mask'],['Mask']
Availability,// Mask for architecture bits,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:3,Mask,Mask,3,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,2,['Mask'],['Mask']
Availability,// Mask for selecting EF_MIPS_ABI_ variant.; // MIPS machine variant,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:3,Mask,Mask,3,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,1,['Mask'],['Mask']
Availability,// Mask in demanded space does nothing.; // NOTE: We may have attributes associated with the return value of the; // llvm.ptrmask intrinsic that will be lost when we just return the; // operand. We should try to preserve them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,1,['Mask'],['Mask']
Availability,// Mask in previous bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h:3,Mask,Mask,3,interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h,1,['Mask'],['Mask']
Availability,"// Mask in the target value a byte at a time (we don't have an alignment; // guarantee for the target address, so this is safest).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h,1,['Mask'],['Mask']
Availability,// Mask in unused bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h:3,Mask,Mask,3,interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h,1,['Mask'],['Mask']
Availability,// Mask indicating which slot is unavailable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,1,['Mask'],['Mask']
Availability,// Mask is a bitmask where a '1' indicates the corresponding Mode bit has a; // known value,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIModeRegister.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIModeRegister.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIModeRegister.cpp,1,['Mask'],['Mask']
Availability,"// Mask is a vector <N x i1>, where each element corresponds to an; // element of FromTy. Remap it so that each element will correspond; // to an element of ToTy.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,1,['Mask'],['Mask']
Availability,"// Mask is constant false, so no instrumentation needed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,1,['Mask'],['Mask']
Availability,// Mask is longer than the source vectors. We can use concatenate vector to; // make the mask and vectors lengths match.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,2,"['Mask', 'mask']","['Mask', 'mask']"
Availability,// Mask is optional and therefore the last operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,1,['Mask'],['Mask']
Availability,"// Mask is optional and therefore the last, currently 2nd operand.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,1,['Mask'],['Mask']
Availability,// Mask is optional.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,1,['Mask'],['Mask']
Availability,// Mask is unknown,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,1,['Mask'],['Mask']
Availability,// Mask length is a multiple of the source vector length.; // Check if the shuffle is some kind of concatenation of the input; // vectors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,2,['Mask'],['Mask']
Availability,// Mask must be constant,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,1,['Mask'],['Mask']
Availability,"// Mask must be vector of i32, and must be the same kind of vector as the; // input vectors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,1,['Mask'],['Mask']
Availability,// Mask needs to be copied to V0.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,2,['Mask'],['Mask']
Availability,// Mask of ASEs used.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsABIFlagsSection.h:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsABIFlagsSection.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsABIFlagsSection.h,1,['Mask'],['Mask']
Availability,"// Mask of all sanitizers ever enabled by; // -fsanitize= flags (directly or via group; // expansion), some of which may be disabled; // later. Used to carefully prune; // unused-argument diagnostics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp:3,Mask,Mask,3,interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,1,['Mask'],['Mask']
Availability,// Mask of discriminators before this pass.; // TODO(xur): simplify this once we switch to ImprovedFSDiscriminator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRFSDiscriminator.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/CodeGen/MIRFSDiscriminator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRFSDiscriminator.cpp,1,['Mask'],['Mask']
Availability,// Mask of discriminators for bits specific to this pass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRFSDiscriminator.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/CodeGen/MIRFSDiscriminator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRFSDiscriminator.cpp,1,['Mask'],['Mask']
Availability,// Mask of discriminators including this pass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRFSDiscriminator.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/CodeGen/MIRFSDiscriminator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRFSDiscriminator.cpp,1,['Mask'],['Mask']
Availability,// Mask of predecessor is all-one so mask of block is too.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,2,"['Mask', 'mask']","['Mask', 'mask']"
Availability,// Mask of the index value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,1,['Mask'],['Mask']
Availability,// Mask of the slots or units that may execute the insn and; // the weight or priority that the insn requires to be assigned a slot.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.h:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.h,1,['Mask'],['Mask']
Availability,"// Mask off KSU, ERL, EXL",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,1,['Mask'],['Mask']
Availability,// Mask off all the processor-specific bits. This removes the SHF_EXCLUDE; // bit if set so that it doesn't also get printed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp,1,['Mask'],['Mask']
Availability,// Mask off any existing bits in the lower part of the upper value that; // we want to replace.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Endian.h:3,Mask,Mask,3,interpreter/llvm-project/llvm/include/llvm/Support/Endian.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Endian.h,1,['Mask'],['Mask']
Availability,// Mask off any existing bits in the upper part of the lower value that; // we want to replace.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Endian.h:3,Mask,Mask,3,interpreter/llvm-project/llvm/include/llvm/Support/Endian.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Endian.h,1,['Mask'],['Mask']
Availability,// Mask off previous bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h:3,Mask,Mask,3,interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h,2,['Mask'],['Mask']
Availability,// Mask off the high bits of each shuffle index.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp:3,Mask,Mask,3,interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,1,['Mask'],['Mask']
Availability,// Mask off the high bits of the immediate value; hardware ignores those.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,2,['Mask'],['Mask']
Availability,// Mask off the sign bit and the modulo bits (low-bits).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['Mask'],['Mask']
Availability,"// Mask off the unnecessary bits of the AND immediate; normally; // DAGCombine will do this, but that might not happen if; // targetShrinkDemandedConstant chooses a different immediate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,1,['Mask'],['Mask']
Availability,"// Mask off the upper bits in the new value that are not going to go into; // the lower value. This avoids a left shift of a negative value, which; // is undefined behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Endian.h:3,Mask,Mask,3,interpreter/llvm-project/llvm/include/llvm/Support/Endian.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Endian.h,1,['Mask'],['Mask']
Availability,// Mask off upper 16-bits of sign-extended constants.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Mask'],['Mask']
Availability,// Mask off upper bits after right shift in case of signed type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Endian.h:3,Mask,Mask,3,interpreter/llvm-project/llvm/include/llvm/Support/Endian.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Endian.h,2,['Mask'],['Mask']
Availability,// Mask off values that are undefined because the dmask doesn't cover them,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstCombineIntrinsic.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstCombineIntrinsic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstCombineIntrinsic.cpp,1,['Mask'],['Mask']
Availability,// Mask off with taint state.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp,1,['Mask'],['Mask']
Availability,// Mask off.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['Mask'],['Mask']
Availability,// Mask operand,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp,1,['Mask'],['Mask']
Availability,// Mask operation additionally required extend and truncate,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,1,['Mask'],['Mask']
Availability,// Mask operations use the LMUL from the mask type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,2,"['Mask', 'mask']","['Mask', 'mask']"
Availability,// Mask out all but lowest bit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,1,['Mask'],['Mask']
Availability,"// Mask out lower bits, add stackalignment once plus the 12 bytes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,1,['Mask'],['Mask']
Availability,"// Mask out the exponent part of the value.; //; // e.g, for f32 FractSignMaskVal = 0x807fffff",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,1,['Mask'],['Mask']
Availability,// Mask out the first hunk,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h,1,['Mask'],['Mask']
Availability,// Mask out the first hunk.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h,1,['Mask'],['Mask']
Availability,"// Mask out the high bit, which we know is set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,1,['Mask'],['Mask']
Availability,// Mask out the high bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:3,Mask,Mask,3,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,1,['Mask'],['Mask']
Availability,// Mask out the low bits for alignment purposes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['Mask'],['Mask']
Availability,"// Mask out the opcode.; // Now we've got the shifted immediate, shift by 2, sign extend and ret.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOARM.h:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOARM.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOARM.h,1,['Mask'],['Mask']
Availability,// Mask out the original value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:3,Mask,Mask,3,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['Mask'],['Mask']
Availability,// Mask out the page address and only use the lower 12 bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h,1,['Mask'],['Mask']
Availability,// Mask out the reserved registers,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp,1,['Mask'],['Mask']
Availability,// Mask position of this node.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.h:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.h,1,['Mask'],['Mask']
Availability,"// Mask reversal is only needed for non-all-one (null) masks, as reverse of; // a null all-one mask is a null mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,4,"['Mask', 'mask']","['Mask', 'mask', 'masks']"
Availability,// Mask sign extend has an instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,4,['Mask'],['Mask']
Availability,// Mask that defines which instruction types can be classified into this; // SchedGroup. The instruction types correspond to the mask from SCHED_BARRIER; // and SCHED_GROUP_BARRIER.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp,2,"['Mask', 'mask']","['Mask', 'mask']"
Availability,// Mask the bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/APINotes/Types.h:3,Mask,Mask,3,interpreter/llvm-project/clang/include/clang/APINotes/Types.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/APINotes/Types.h,1,['Mask'],['Mask']
Availability,// Mask the immediate for VALIGN.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,1,['Mask'],['Mask']
Availability,// Mask the offset in [47:0] of the descriptor,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,1,['Mask'],['Mask']
Availability,// Mask the shift amount to width of a vector.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:3,Mask,Mask,3,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,1,['Mask'],['Mask']
Availability,// Mask the source value as needed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:3,Mask,Mask,3,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['Mask'],['Mask']
Availability,"// Mask the value into the target address. We know instructions are; // 32-bit aligned, so we can do it all at once.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOARM.h:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOARM.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOARM.h,1,['Mask'],['Mask']
Availability,// Mask the value to 24 bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOARM.h:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOARM.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOARM.h,1,['Mask'],['Mask']
Availability,// Mask the value to the right type,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ISelLowering.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ISelLowering.cpp,1,['Mask'],['Mask']
Availability,// Mask the write if the original instruction does not write to; // the current Channel.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ExpandSpecialInstrs.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ExpandSpecialInstrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ExpandSpecialInstrs.cpp,1,['Mask'],['Mask']
Availability,// Mask to just the signficant bits and subtract from LowerDiv/UpperDiv.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,1,['Mask'],['Mask']
Availability,// Mask to size of LDMemType,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['Mask'],['Mask']
Availability,// Mask type only occupies one vector register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:3,Mask,Mask,3,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,1,['Mask'],['Mask']
Availability,// Mask vector extract/insert is expanded via e8.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,1,['Mask'],['Mask']
Availability,// Mask vectors support all subregister combinations and operations that; // extract half of vector.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Mask'],['Mask']
Availability,// Mask was extended from a boolean vector.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,1,['Mask'],['Mask']
Availability,// Mask with callee saved registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp,1,['Mask'],['Mask']
Availability,// Mask zero extend is a sext + shift.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,4,['Mask'],['Mask']
Availability,// Mask+1 is not a power of 2,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,1,['Mask'],['Mask']
Availability,// Mask+insert remaining bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Support/APInt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp,1,['Mask'],['Mask']
Availability,// Mask.size() does not need to be equal to the number of vector elements.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['Mask'],['Mask']
Availability,// Mask/Or the expected and new values into place in the loaded word.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,1,['Mask'],['Mask']
Availability,// Mask; // Update in place.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp:3,Mask,Mask,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,1,['Mask'],['Mask']
Availability,// MaskHighTemp and MaskLowTemp built in the vpunpckhbw and vpunpcklbw X86; // shuffle pattern.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:3,Mask,MaskHighTemp,3,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,2,['Mask'],"['MaskHighTemp', 'MaskLowTemp']"
Availability,// Masked compares sometimes use the same register as the corresponding 'and'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:3,Mask,Masked,3,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['Mask'],['Masked']
Availability,// Masked control flow nodes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.h:3,Mask,Masked,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.h,1,['Mask'],['Masked']
Availability,"// Masked gather and scatter - load and store operations for a vector of; // random addresses with additional mask operand that prevents memory; // accesses to the masked-off lanes.; //; // Val, OutChain = GATHER(InChain, PassThru, Mask, BasePtr, Index, Scale); // OutChain = SCATTER(InChain, Value, Mask, BasePtr, Index, Scale); //; // The Index operand can have more vector elements than the other operands; // due to type legalization. The extra elements are ignored.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:3,Mask,Masked,3,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,5,"['Mask', 'mask']","['Mask', 'Masked', 'mask', 'masked-off']"
Availability,"// Masked load and store - consecutive vector load and store operations; // with additional mask operand that prevents memory accesses to the; // masked-off lanes.; //; // Val, OutChain = MLOAD(BasePtr, Mask, PassThru); // OutChain = MSTORE(Value, BasePtr, Mask)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:3,Mask,Masked,3,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,5,"['Mask', 'mask']","['Mask', 'Masked', 'mask', 'masked-off']"
Availability,// Masked load/store takes a mask that may need splitting.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:3,Mask,Masked,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,2,"['Mask', 'mask']","['Masked', 'mask']"
Availability,"// Masked pseudos coming out of isel will have their mask operand in the form:; //; // $v0:vr = COPY %mask:vr; // %x:vr = Pseudo_MASK %a:vr, %b:br, $v0:vr; //; // Because $v0 isn't in SSA, keep track of it so we can check the mask operand; // on each pseudo.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp:3,Mask,Masked,3,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp,4,"['Mask', 'mask']","['Masked', 'mask']"
Availability,// Masked reduction cases.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/RISCVVEmitter.cpp:3,Mask,Masked,3,interpreter/llvm-project/clang/utils/TableGen/RISCVVEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/RISCVVEmitter.cpp,1,['Mask'],['Masked']
Availability,// Masked store has an initial operand for the value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:3,Mask,Masked,3,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,2,['Mask'],['Masked']
Availability,"// Masked stores have imprecise locations, but we can reason about them; // to some extent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:3,Mask,Masked,3,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,1,['Mask'],['Masked']
Availability,"// Masked version of above. Used for v2f64->v4f32.; // SRC, PASSTHRU, MASK",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h:3,Mask,Masked,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,2,"['MASK', 'Mask']","['MASK', 'Masked']"
Availability,"// Masked version of above.; // SRC, PASSTHRU, MASK",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h:3,Mask,Masked,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,2,"['MASK', 'Mask']","['MASK', 'Masked']"
Availability,"// Masked version of above.; // SRC, RND, PASSTHRU, MASK",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h:3,Mask,Masked,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,2,"['MASK', 'Mask']","['MASK', 'Masked']"
Availability,"// Masked version of the above. Used when less than a 128-bit result is; // produced since the mask only applies to the lower elements and can't; // be represented by a select.; // SRC, PASSTHRU, MASK",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h:3,Mask,Masked,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,3,"['MASK', 'Mask', 'mask']","['MASK', 'Masked', 'mask']"
Availability,"// Masked versions of above. Used for v2f64->v4f32.; // SRC, PASSTHRU, MASK",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h:3,Mask,Masked,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,2,"['MASK', 'Mask']","['MASK', 'Masked']"
Availability,"// MaskedLoadSDNode (Chain, ptr, offset, mask, passthru); // MaskedStoreSDNode (Chain, data, ptr, offset, mask); // Mask is a vector of i1 elements",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:3,Mask,MaskedLoadSDNode,3,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,5,"['Mask', 'mask']","['Mask', 'MaskedLoadSDNode', 'MaskedStoreSDNode', 'mask']"
Availability,"// Masking the negated extension of a boolean is just the zero-extended; // boolean:; // and (sub 0, zext(bool X)), 1 --> zext(bool X); // and (sub 0, sext(bool X)), 1 --> zext(bool X); //; // Note: the SimplifyDemandedBits fold below can make an information-losing; // transform, and then we have no way to find this better fold.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Mask,Masking,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['Mask'],['Masking']
Availability,// Masks are 4-nibble hex numbers. Values 0-7 in any nibble means that it takes; // an element from that value of the input vectors. A value of 8 means the; // entry is undefined.; // Mask manipulation functions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/PerfectShuffle/PerfectShuffle.cpp:3,Mask,Masks,3,interpreter/llvm-project/llvm/utils/PerfectShuffle/PerfectShuffle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/PerfectShuffle/PerfectShuffle.cpp,2,['Mask'],"['Mask', 'Masks']"
Availability,// Masks can only use a single register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Mask,Masks,3,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['Mask'],['Masks']
Availability,// Masks combining multiple flags,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPConstants.h:3,Mask,Masks,3,interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPConstants.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPConstants.h,1,['Mask'],['Masks']
Availability,"// Masks for authentication methods",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:3,Mask,Masks,3,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,1,['Mask'],['Masks']
Availability,"// Masks for initialization options",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/res/rpddefs.h:3,Mask,Masks,3,net/rpdutils/res/rpddefs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/res/rpddefs.h,1,['Mask'],['Masks']
Availability,// Masks for packing/unpacking the r_rsize field of relocations.; // The msb is used to indicate if the bits being relocated are signed or; // unsigned.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:3,Mask,Masks,3,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,1,['Mask'],['Masks']
Availability,// Masks for the ases word of an ABI flags structure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/MipsABIFlags.h:3,Mask,Masks,3,interpreter/llvm-project/llvm/include/llvm/Support/MipsABIFlags.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/MipsABIFlags.h,1,['Mask'],['Masks']
Availability,// Masks out the bits for the access model.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h:3,Mask,Masks,3,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h,1,['Mask'],['Masks']
Availability,// Masks out the exponent bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp:3,Mask,Masks,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,1,['Mask'],['Masks']
Availability,// Masks supported by oihf/xihf.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:3,Mask,Masks,3,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,1,['Mask'],['Masks']
Availability,// Masks supported by oilf/xilf.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:3,Mask,Masks,3,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,1,['Mask'],['Masks']
Availability,// Masks to encode and decode an AlignPackInfo.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:3,Mask,Masks,3,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['Mask'],['Masks']
Availability,// Masks to select leftmost bits for decoding parameter type information.; // Bit to use when vector info is not presented.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:3,Mask,Masks,3,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,1,['Mask'],['Masks']
Availability,"// Masks were constructed with assumption that we would find a chain of; // length 4. If not, then we need to 0 out the MSB bits (via perm mask of; // 0x0c) so they do not affect dot calculation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:3,Mask,Masks,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,2,"['Mask', 'mask']","['Masks', 'mask']"
Availability,// Masks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:3,Mask,Masks,3,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['Mask'],['Masks']
Availability,// Masks.; // TODO: check that KillingII's mask is a superset of the DeadII's mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:3,Mask,Masks,3,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,3,"['Mask', 'mask']","['Masks', 'mask']"
Availability,"// Match 1-input (unary) shuffle.; // shuffle (fneg/fabs X), Mask --> fneg/fabs (shuffle X, Mask)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:61,Mask,Mask,61,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,2,['Mask'],['Mask']
Availability,"// Match BNE DestReg, MaskReg.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp:22,Mask,MaskReg,22,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp,1,['Mask'],['MaskReg']
Availability,"// Match a base and an immediate (if Offset is not null) or an SGPR (if; // SOffset is not null) or an immediate+SGPR offset. If Imm32Only is; // true, match only 32-bit immediate offsets available on CI.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelDAGToDAG.cpp:188,avail,available,188,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelDAGToDAG.cpp,1,['avail'],['available']
Availability,"// Match a simple recurrence of the form: <start, ShiftOp, Step>, and then; // use information about the trip count to improve our available range. Note; // that the trip count independent cases are already handled by known bits.; // WARNING: The definition of recurrence used here is subtly different than; // the one used by AddRec (and thus most of this file). Step is allowed to; // be arbitrarily loop varying here, where AddRec allows only loop invariant; // and other addrecs in the same loop (for non-affine addrecs). The code; // below intentionally handles the case where step is not loop invariant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:131,avail,available,131,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['avail'],['available']
Availability,// Match a specific element. The mask should be defined at and match the; // specified index.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:33,mask,mask,33,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,1,['mask'],['mask']
Availability,// Match a splat shuffle mask of the insert index allowing undef elements.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:25,mask,mask,25,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['mask'],['mask']
Availability,// Match an extract element and get a shuffle mask equivalent.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:46,mask,mask,46,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['mask']
Availability,"// Match an immediate (if Offset is not null) or an SGPR (if SOffset is; // not null) offset. If Imm32Only is true, match only 32-bit immediate; // offsets available on CI.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelDAGToDAG.cpp:156,avail,available,156,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelDAGToDAG.cpp,1,['avail'],['available']
Availability,"// Match each half of the repeated mask, to determine if its just; // referencing one of the vectors, is zeroable or entirely undef.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:35,mask,mask,35,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// Match for a restricted set of patterns for cmparison of error codes.; // Note, the comparisons of type '0 == st' are transformed into SymIntExpr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:59,error,error,59,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,1,['error'],['error']
Availability,"// Match icmp(bitcast(vXi1 trunc(Y)),0) reduction patterns.; // Match icmp(bitcast(vXi1 trunc(Y)),-1) reduction patterns.; // Peek through truncation, mask the LSB and compare against zero/LSB.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:151,mask,mask,151,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Match masked merge pattern (X & ~M) op (Y & M); // Including degenerate case (X & ~M) op M,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:9,mask,masked,9,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['mask'],['masked']
Availability,"// Match shuffles of bitcasts, so long as the mask can be treated as the; // larger type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:46,mask,mask,46,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['mask']
Availability,"// Match the following IR pattern:; // %x.lowbits = and i8 %x, %lowbitmask; // %x.lowbits.are.zero = icmp eq i8 %x.lowbits, 0; // %x.biased = add i8 %x, %bias; // %x.biased.highbits = and i8 %x.biased, %highbitmask; // %x.roundedup = select i1 %x.lowbits.are.zero, i8 %x, i8 %x.biased.highbits; // Define:; // %alignment = add i8 %lowbitmask, 1; // Iff 1. an %alignment is a power-of-two (aka, %lowbitmask is a low bit mask); // and 2. %bias is equal to either %lowbitmask or %alignment,; // and 3. %highbitmask is equal to ~%lowbitmask (aka, to -%alignment); // then this pattern can be transformed into:; // %x.offset = add i8 %x, %lowbitmask; // %x.roundedup = and i8 %x.offset, %highbitmask",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:419,mask,mask,419,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,1,['mask'],['mask']
Availability,"// Match the following:; // select (X & (1 << i)) != 0 ? R ^ (Q << i) : R; // select (X & (1 << i)) == 0 ? R : R ^ (Q << i); // The condition may also check for equality with the masked value, i.e; // select (X & (1 << i)) == (1 << i) ? R ^ (Q << i) : R; // select (X & (1 << i)) != (1 << i) ? R : R ^ (Q << i);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:179,mask,masked,179,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,1,['mask'],['masked']
Availability,"// Match the following:; // select (X & 1) != 0 ? (R >> 1) ^ Q : (R >> 1); // select (X & 1) == 0 ? (R >> 1) : (R >> 1) ^ Q; // The condition may also check for equality with the masked value, i.e; // select (X & 1) == 1 ? (R >> 1) ^ Q : (R >> 1); // select (X & 1) != 1 ? (R >> 1) : (R >> 1) ^ Q",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:179,mask,masked,179,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,1,['mask'],['masked']
Availability,// Match those names to the widest floating point register type available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:64,avail,available,64,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,1,['avail'],['available']
Availability,"// Match:; // sreg = -1 or 0; // vcc = S_AND_B64 exec, sreg or S_ANDN2_B64 exec, sreg; // S_CBRANCH_VCC[N]Z; // =>; // S_CBRANCH_EXEC[N]Z; // We end up with this pattern sometimes after basic block placement.; // It happens while combining a block which assigns -1 or 0 to a saved mask; // and another block which consumes that saved mask and then a branch.; //; // While searching this also performs the following substitution:; // vcc = V_CMP; // vcc = S_AND exec, vcc; // S_CBRANCH_VCC[N]Z; // =>; // vcc = V_CMP; // S_CBRANCH_VCC[N]Z",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIPreEmitPeephole.cpp:281,mask,mask,281,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIPreEmitPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIPreEmitPeephole.cpp,2,['mask'],['mask']
Availability,"// MatchScopes - Scopes used when matching, if a match failure happens, this; // indicates where to continue checking.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp:55,failure,failure,55,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,1,['failure'],['failure']
Availability,// Matches memory operand. Returns true if error encountered.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/AsmParser/LanaiAsmParser.cpp:43,error,error,43,interpreter/llvm-project/llvm/lib/Target/Lanai/AsmParser/LanaiAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/AsmParser/LanaiAsmParser.cpp,1,['error'],['error']
Availability,"// Matches the semantics of the vfcnvt.rod function (Convert double-width; // float to single-width float, rounding towards odd). Takes a double-width; // float vector and produces a single-width float vector. Also has a mask and; // VL operand.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:221,mask,mask,221,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,1,['mask'],['mask']
Availability,"// Matches the semantics of the vid.v instruction, with a mask and VL; // operand.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:58,mask,mask,58,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,1,['mask'],['mask']
Availability,"// Matches the semantics of vfslide1up/vfslide1down. The first operand is; // passthru operand, the second is source vector, third is a scalar value; // whose type matches the element type of the vectors. The fourth and fifth; // operands are the mask and VL operands.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:247,mask,mask,247,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,1,['mask'],['mask']
Availability,"// Matches the semantics of vrgather.vx and vrgather.vv with extra operands; // for passthru and VL. Operands are (src, index, mask, passthru, vl).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:127,mask,mask,127,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,1,['mask'],['mask']
Availability,"// Matches the semantics of vslide1up/slide1down. The first operand is; // passthru operand, the second is source vector, third is the XLenVT scalar; // value. The fourth and fifth operands are the mask and VL operands.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:198,mask,mask,198,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,1,['mask'],['mask']
Availability,"// Matches the semantics of vslideup/vslidedown. The first operand is the; // pass-thru operand, the second is the source vector, the third is the XLenVT; // index (either constant or non-constant), the fourth is the mask, the fifth; // is the VL and the sixth is the policy.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:217,mask,mask,217,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,1,['mask'],['mask']
Availability,"// Matching attribute kind only. Except for Availability attributes,; // we are not getting into details of the attributes. For all practical purposes; // this is sufficient.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp:44,Avail,Availability,44,interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,1,['Avail'],['Availability']
Availability,// Materialize default mask and avl.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VVPISelLowering.cpp:23,mask,mask,23,interpreter/llvm-project/llvm/lib/Target/VE/VVPISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VVPISelLowering.cpp,1,['mask'],['mask']
Availability,"// Materialize the needed SSA value of the target. Note that we need the; // middle of the block as this block might at the bottom have an indirect; // branch back to itself. We can do this here because at this point, every; // predecessor of this block has an available value. This is basically just; // automating the construction of a PHI node for this target.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:261,avail,available,261,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,1,['avail'],['available']
Availability,"// Maximum error in the middle of the step.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveTrackPropagator.h:11,error,error,11,graf3d/eve/inc/TEveTrackPropagator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveTrackPropagator.h,2,['error'],['error']
Availability,// May be alive on some path.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackLifetime.h:10,alive,alive,10,interpreter/llvm-project/llvm/include/llvm/Analysis/StackLifetime.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackLifetime.h,1,['alive'],['alive']
Availability,// May no longer be available due to backtracking.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp:20,avail,available,20,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp,1,['avail'],['available']
Availability,"// Member data pointers are easy because there's a unique null; // value, so it just comes down to bitwise equality.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp:91,down,down,91,interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,1,['down'],['down']
Availability,"// Memoize the result of each visit so that we only compute once for; // the same input SCEV. This is to avoid redundant computations when; // a SCEV is referenced by multiple SCEVs. Without memoization, this; // visit algorithm would have exponential time complexity in the worst; // case, causing the compiler to hang on certain tests.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h:111,redundant,redundant,111,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,1,['redundant'],['redundant']
Availability,// Memory as copy space (potentially masked).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:37,mask,masked,37,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['masked']
Availability,// Merge all errors that happened while in this context.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Diagnostics.cpp:13,error,errors,13,interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Diagnostics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Diagnostics.cpp,1,['error'],['errors']
Availability,"// Merge an insertion into an existing shuffle:; // (insert_vector_elt (vector_shuffle X, Y, Mask),; // .(extract_vector_elt X, N), InsIndex); // --> (vector_shuffle X, Y, NewMask); // and variations where shuffle operands may be CONCAT_VECTORS.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:93,Mask,Mask,93,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['Mask'],['Mask']
Availability,"// Merge overload to error out in case no valid HIST::Merge method was detected",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx:21,error,error,21,tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,1,['error'],['error']
Availability,"// Merge the attributes of AdditionalNode into OriginalNode. If attributes; // with identical types are present, they are not duplicated but rather if; // their values are not consistent and error is thrown. In addition, the; // higher priority namespace is used for each attribute, EXCEPT in the case; // of merging two default namespaces and the lower priority namespace; // definition occurs closer than the higher priority one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp:191,error,error,191,interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,1,['error'],['error']
Availability,// Merge the shuffle masks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:21,mask,masks,21,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['masks']
Availability,"// Merge the sin and cos. For OpenCL 2.0, there may only be a generic pointer; // implementation. Prefer the private form if available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULibCalls.cpp:125,avail,available,125,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULibCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULibCalls.cpp,1,['avail'],['available']
Availability,// Merge the sub-lane mask into the matching repeated sub-lane mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:22,mask,mask,22,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['mask'],['mask']
Availability,// Merge this lane mask into the final repeat mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:19,mask,mask,19,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,4,['mask'],['mask']
Availability,// Merge this node's mask and our incoming mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:21,mask,mask,21,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['mask'],['mask']
Availability,"// Merge this shuffle operation's mask into our accumulated mask. Note that; // this shuffle's mask will be the first applied to the input, followed by; // the root mask to get us all the way to the root value arrangement. The; // reason for this order is that we are recursing up the operation chain.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:34,mask,mask,34,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,4,['mask'],['mask']
Availability,"// MergeICmps does not need the DominatorTree, but we update it if it's; // already available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:84,avail,available,84,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,1,['avail'],['available']
Availability,"// Method called via Callbacks->FileNotFound(Filename); // in Preprocessor::HandleIncludeDirective(), initially allowing to; // change the include path, and allowing us to compile code via ACLiC; // when specifying #include ""myfile.C+"", and suppressing the preprocessor; // error message:; // input_line_23:1:10: fatal error: 'myfile.C+' file not found",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx:274,error,error,274,core/metacling/src/TClingCallbacks.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx,2,['error'],['error']
Availability,"// Method to find both lower and upper limits using MINOS; // If cached values exist (limits have been already found) return them in that case; // check first if limit has been computed; // otherwise compute limit using MINOS; // in case of failure lower and upper will maintain previous value (will not be modified)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/LikelihoodInterval.cxx:241,failure,failure,241,roofit/roostats/src/LikelihoodInterval.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/LikelihoodInterval.cxx,1,['failure'],['failure']
Availability,// Methods to be Implemented in the derived classes; /** Stimates the root for the function.; \@param maxIter maximum number of iterations.; \@param absTol desired absolute error in the minimum position.; \@param absTol desired relative error in the minimum position.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IRootFinderMethod.h:173,error,error,173,math/mathcore/inc/Math/IRootFinderMethod.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IRootFinderMethod.h,2,['error'],['error']
Availability,"// Min2Minimize will exit with a different value if there is any; // error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genetic/test/GAMinTutorial.cxx:69,error,error,69,math/genetic/test/GAMinTutorial.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genetic/test/GAMinTutorial.cxx,1,['error'],['error']
Availability,"// MinGW specific. Remove default manifests (with language zero) if there are; // other manifests present, and report an error if there are more than one; // manifest with a non-zero language code.; // GCC has the concept of a default manifest resource object, which gets; // linked in implicitly if present. This default manifest has got language; // id zero, and should be dropped silently if there's another manifest present.; // If the user resources surprisignly had a manifest with language id zero,; // we should also ignore the duplicate default manifest.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/WindowsResource.cpp:121,error,error,121,interpreter/llvm-project/llvm/lib/Object/WindowsResource.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/WindowsResource.cpp,1,['error'],['error']
Availability,"// Minor canonicalization of the accumulated shuffle mask to make it easier; // to match below. All this does is detect masks with sequential pairs of; // elements, and shrink them to the half-width mask. It does this in a loop; // so it will reduce the size of the mask to the minimal width mask which; // performs an equivalent shuffle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:53,mask,mask,53,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,10,['mask'],"['mask', 'masks']"
Availability,"// Minos error is value + error + aopt * error where aopt is MnCross.Value(); // If value + error is over the limit, err must be truncated at limit",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/MinosError.h:9,error,error,9,math/minuit2/inc/Minuit2/MinosError.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/MinosError.h,4,['error'],['error']
Availability,"// Minos error is value - error - aopt * error where aopt is MnCross.Value(); // If value - error is below the limit, error must be truncated at limit",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/MinosError.h:9,error,error,9,math/minuit2/inc/Minuit2/MinosError.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/MinosError.h,5,['error'],['error']
Availability,// MispredictPenalty is the typical number of extra cycles the processor; // takes to recover from a branch misprediction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h:86,recover,recover,86,interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,1,['recover'],['recover']
Availability,"// Missing fBranchCount. let's attempts to recover.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:43,recover,recover,43,tree/tree/src/TBranchElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx,1,['recover'],['recover']
Availability,"// Mixed:; // (icmp eq (A & B), C) & (icmp eq (A & D), E); // We already know that B & C == C && D & E == E.; // If we can prove that (B & D) & (C ^ E) == 0, that is, the bits of; // C and E, which are shared by both the mask B and the mask D, don't; // contradict, then we can transform to; // -> (icmp eq (A & (B|D)), (C|E)); // Currently, we only handle the case of B, C, D, and E being constant.; // We can't simply use C and E because we might actually handle; // (icmp ne (A & B), B) & (icmp eq (A & D), D); // with B and D, having a single bit set.; // NotMixed:; // (icmp ne (A & B), C) & (icmp ne (A & D), E); // -> (icmp ne (A & (B & D)), (C & E)); // Check the intersection (B & D) for inequality.; // Assume that (B & D) == B || (B & D) == D, i.e B/D is a subset of D/B; // and (B & D) & (C ^ E) == 0, bits of C and E, which are shared by both the; // B and the D, don't contradict.; // Note that we can assume (~B & C) == 0 && (~D & E) == 0, previous; // operation should delete these icmps if it hadn't been met.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:221,mask,mask,221,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,2,['mask'],['mask']
Availability,// Mixing calling conventions here is very clearly an error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp:54,error,error,54,interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,1,['error'],['error']
Availability,"// Model the effect of changing the input state of the block MBB to; // AvailableInfo. We're looking for two issues here; one legality,; // one profitability.; // 1) If the block doesn't use some of the fields from VL or VTYPE, we; // may hit the end of the block with a different end state. We can; // not make this change without reflowing later blocks as well.; // 2) If we don't actually remove a transition, inserting a vsetvli; // into the predecessor block would be correct, but unprofitable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:72,Avail,AvailableInfo,72,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,1,['Avail'],['AvailableInfo']
Availability,// Model the effect of current instruction on AvailableSet to keep the set; // relevant at each point of BB.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:46,Avail,AvailableSet,46,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,1,['Avail'],['AvailableSet']
Availability,"// Model xor(and(x, C), C) as and(~x, C), if C is a low-bits mask.; // This is a variant of the check for xor with -1, and it handles; // the case where instcombine has trimmed non-demanded bits out; // of an xor with -1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:61,mask,mask,61,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['mask'],['mask']
Availability,// Modify the new Mask to take all zeros from the all-zero vector.; // Choose indices that are blend-friendly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:18,Mask,Mask,18,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Mask'],['Mask']
Availability,"// Module import found where it should not be, for instance, inside a; // namespace. Recover by importing the module.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:85,Recover,Recover,85,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp,1,['Recover'],['Recover']
Availability,// ModuleCache takes care of correctness and locks are only necessary for; // performance. Fallback to building the module in case of any lock; // related errors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:155,error,errors,155,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,1,['error'],['errors']
Availability,// More error recovery.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:8,error,error,8,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,2,"['error', 'recover']","['error', 'recovery']"
Availability,// More general: canonicalize 'equality with set bits mask' to; // 'equality with clear bits mask'.; // (X | MaskC) == C --> (X & ~MaskC) == C ^ MaskC; // (X | MaskC) != C --> (X & ~MaskC) != C ^ MaskC,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:54,mask,mask,54,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,8,"['Mask', 'mask']","['MaskC', 'mask']"
Availability,"// More than one near miss, so report a generic ""invalid instruction""; // error, followed by notes for each of the near-misses.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:74,error,error,74,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['error'],['error']
Availability,// More than one return type? Reduce it down to size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:40,down,down,40,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,1,['down'],['down']
Availability,"// Moreover, to realize this mapping, the register bank of each operand must; // match this mapping. In other words, we may need to locally reassign the; // register banks. Account for that repairing cost as well.; // In this context, local means in the surrounding of MI.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:190,repair,repairing,190,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,1,['repair'],['repairing']
Availability,"// Most of the ObjectFile interfaces return an Expected<T>, so make it easy; // to ignore errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-tli-checker/llvm-tli-checker.cpp:90,error,errors,90,interpreter/llvm-project/llvm/tools/llvm-tli-checker/llvm-tli-checker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-tli-checker/llvm-tli-checker.cpp,1,['error'],['errors']
Availability,// Most of these failures are due to extra restrictions in ARC;; // reflect that in the primary diagnostic when applicable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:17,failure,failures,17,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,1,['failure'],['failures']
Availability,"// Most parse failures other than when parsing extended opcodes are due to; // failures to read ULEBs. Bail out of parsing, since we don't know where to; // continue reading from as there is no stated length for such byte; // sequences. Print the final trailing new line if needed before doing so.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFDebugLine.cpp:14,failure,failures,14,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFDebugLine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFDebugLine.cpp,2,['failure'],['failures']
Availability,"// Mouse down on selected widget?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLManip.cxx:9,down,down,9,graf3d/gl/src/TGLManip.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLManip.cxx,1,['down'],['down']
Availability,// Move LDS uses from functions to kernels before promote alloca for accurate; // estimation of LDS available,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPromoteAlloca.cpp:100,avail,available,100,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPromoteAlloca.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPromoteAlloca.cpp,1,['avail'],['available']
Availability,// Move all dependants to the error state and disconnect from them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:30,error,error,30,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,1,['error'],['error']
Availability,"// Move down and repeat the layout if we exceeded the available; // line length and it is possible to increase the line length by; // moving past some obstacle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlLayout.cxx:8,down,down,8,gui/guihtml/src/TGHtmlLayout.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlLayout.cxx,2,"['avail', 'down']","['available', 'down']"
Availability,"// Move everything after this operand down.; //; // FIXME: we could just swap with the end of the list, then erase. However,; // clients might not expect this to happen. The code as it is thrashes the; // use/def lists, which is kinda lame.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:38,down,down,38,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,1,['down'],['down']
Availability,"// Move general register save area spill slots down, taking into account; // the size of the Floating-point register save area.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:47,down,down,47,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,2,['down'],['down']
Availability,"// Move one line down. Returns kTRUE if succeeded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/Tetris.cxx:17,down,down,17,test/Tetris.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/Tetris.cxx,1,['down'],['down']
Availability,// Move the copies connected to MI down as well.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:35,down,down,35,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,1,['down'],['down']
Availability,// Move the definition of Dest down to ExtMI.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:31,down,down,31,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['down'],['down']
Availability,"// Move the name variable to the right section. Place them in a COMDAT group; // if the associated function is a COMDAT. This will make sure that only one; // copy of counters of the COMDAT function will be emitted after linking. Keep; // in mind that this pass may run before the inliner, so we need to create a; // new comdat group for the counters and profiling data. If we use the comdat; // of the parent function, that will result in relocations against discarded; // sections.; //; // If the data variable is referenced by code, counters and data have to be; // in different comdats for COFF because the Visual C++ linker will report; // duplicate symbol errors if there are multiple external symbols with the; // same name marked IMAGE_COMDAT_SELECT_ASSOCIATIVE.; //; // For ELF, when not using COMDAT, put counters, data and values into a; // nodeduplicate COMDAT which is lowered to a zero-flag section group. This; // allows -z start-stop-gc to discard the entire group when the function is; // discarded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:662,error,errors,662,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,1,['error'],['errors']
Availability,// Move the stack iterator down by one.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp:27,down,down,27,interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp,1,['down'],['down']
Availability,// Move the symbol into the error state.; // Note that this may be redundant: The symbol might already have been; // moved to this state in response to the failure of a dependence.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:28,error,error,28,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,3,"['error', 'failure', 'redundant']","['error', 'failure', 'redundant']"
Availability,// Move the trailing 1 down one bit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:23,down,down,23,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['down'],['down']
Availability,// Move the upper/lower halves to the lower bits as we'll be extending to; // NextVT. Mask the lower result to zero if HiZ is true and add the results; // together.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:86,Mask,Mask,86,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Mask'],['Mask']
Availability,"// Move the vector predicate SubV to a vector register, and scale it; // down to match the representation (bytes per type element) that VecV; // uses. The scaling down will pick every 2nd or 4th (every Scale-th; // in general) element and put them at the front of the resulting; // vector. This subvector will then be inserted into the Q2V of VecV.; // To avoid having an operation that generates an illegal type (short; // vector), generate a full size vector.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:73,down,down,73,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,2,['down'],['down']
Availability,// Move this function aside and map down.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:36,down,down,36,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,1,['down'],['down']
Availability,"// Move unary shuffles with identical masks after a vector binop:; // VBinOp (shuffle A, Undef, Mask), (shuffle B, Undef, Mask)); // --> shuffle (VBinOp A, B), Undef, Mask; // This does not require type legality checks because we are creating the; // same types of operations that are in the original sequence. We do have to; // restrict ops like integer div that have immediate UB (eg, div-by-zero); // though. This code is adapted from the identical transform in instcombine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:38,mask,masks,38,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,4,"['Mask', 'mask']","['Mask', 'masks']"
Availability,"// Multiple successors mean we need to find the join point where control flow; // converges again. We use the findForwardJoinPoint helper function with; // information about the function and helper analyses, if available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp:211,avail,available,211,interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp,1,['avail'],['available']
Availability,"// Multiply, mask the lower 8bits of the lo/hi results and pack.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:13,mask,mask,13,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Munge the lsb/width into a bitfield mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:39,mask,mask,39,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['mask'],['mask']
Availability,// Must be alive on every path.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackLifetime.h:11,alive,alive,11,interpreter/llvm-project/llvm/include/llvm/Analysis/StackLifetime.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackLifetime.h,1,['alive'],['alive']
Availability,// Must be available in preheader.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:11,avail,available,11,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['avail'],['available']
Availability,"// Must provide:; //; // Function to write the value and tag as strings:; // static void output(const T &Value, void *ctx, llvm::raw_ostream &ScalarOut,; // llvm::raw_ostream &TagOut);; //; // Function to convert a string to a value. Returns the empty; // StringRef on success or an error string if string is malformed:; // static StringRef input(StringRef Scalar, StringRef Tag, void *ctxt, T; // &Value);; //; // Function to determine if the value should be quoted.; // static QuotingType mustQuote(const T &Value, StringRef Scalar);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h:283,error,error,283,interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h,1,['error'],['error']
Availability,"// Must provide:; //; // Function to write the value as a string:; // static void output(const T &Value, void *ctx, llvm::raw_ostream &Out);; //; // Function to convert a string to a value. Returns the empty; // StringRef on success or an error string if string is malformed:; // static StringRef input(StringRef Scalar, void *ctxt, T &Value);; //; // Optional:; // static StringRef inputTag(T &Val, std::string Tag); // static void outputTag(const T &Val, raw_ostream &Out)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h:239,error,error,239,interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h,1,['error'],['error']
Availability,"// Must provide:; //; // Function to write the value as a string:; // static void output(const T &value, void *ctxt, llvm::raw_ostream &out);; //; // Function to convert a string to a value. Returns the empty; // StringRef on success or an error string if string is malformed:; // static StringRef input(StringRef scalar, void *ctxt, T &value);; //; // Function to determine if the value should be quoted.; // static QuotingType mustQuote(StringRef);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h:240,error,error,240,interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h,1,['error'],['error']
Availability,// Must take a mask argument if one is required,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:15,mask,mask,15,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['mask'],['mask']
Availability,"// Mutexes to synchronize installing error handlers and calling error handlers.; // Do not use ManagedStatic, or that may allocate memory while attempting to; // report an OOM.; //; // This usage of std::mutex has to be conditionalized behind ifdefs because; // of this script:; // compiler-rt/lib/sanitizer_common/symbolizer/scripts/build_symbolizer.sh; // That script attempts to statically link the LLVM symbolizer library with the; // STL and hide all of its symbols with 'opt -internalize'. To reduce size, it; // cuts out the threading portions of the hermetic copy of libc++ that it; // builds. We can remove these ifdefs if that script goes away.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ErrorHandling.cpp:37,error,error,37,interpreter/llvm-project/llvm/lib/Support/ErrorHandling.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ErrorHandling.cpp,2,['error'],['error']
Availability,"// NB! Calling ScalarEvolution::getConstant is fine, but we should not try to; // construct arbitrary general SCEV expressions here. This function is called; // from deep in the call stack, and calling getSCEV (on a sext instruction,; // say) can end up caching a suboptimal value.; // FIXME: without the explicit `this` receiver below, MSVC errors out with; // C2352 and C2512 (otherwise it isn't needed).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:342,error,errors,342,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['error'],['errors']
Availability,"// NB! This *must* be reset before adding new AA results to the new; // AAResults object because in the legacy pass manager, each instance; // of these will refer to the *same* immutable analyses, registering and; // unregistering themselves with them. We need to carefully tear down the; // previous object first, in this case replacing it with an empty one, before; // registering new results.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:279,down,down,279,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,1,['down'],['down']
Availability,// NB. we only need to add a note in a non-error case.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:43,error,error,43,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,1,['error'],['error']
Availability,// NB: skip advanceBeforeNext() call. Since all defs will be marked; // early-clobber they will all stay alive at least to the end of the; // clause. Therefor we should not decrease pressure even if load; // pointer becomes dead and could otherwise be reused for destination.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFormMemoryClauses.cpp:105,alive,alive,105,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFormMemoryClauses.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFormMemoryClauses.cpp,1,['alive'],['alive']
Availability,"// NEC nld doesn't support relative lookup tables. It shows following; // errors. So, we disable it at the moment.; // /opt/nec/ve/bin/nld: src/CMakeFiles/cxxabi_shared.dir/cxa_demangle.cpp; // .o(.rodata+0x17b4): reloc against `.L.str.376': error 2; // /opt/nec/ve/bin/nld: final link failed: Nonrepresentable section on; // output",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VETargetTransformInfo.h:74,error,errors,74,interpreter/llvm-project/llvm/lib/Target/VE/VETargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VETargetTransformInfo.h,2,['error'],"['error', 'errors']"
Availability,"// NEON doesn't support masked loads/stores/gathers/scatters, but SVE does",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:24,mask,masked,24,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['mask'],['masked']
Availability,"// NOLINT(cert-err34-c) 'sscanf' used to convert a string to an; // integer value, but function will not report conversion; // errors; consider using 'strtol' instead",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:127,error,errors,127,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['error'],['errors']
Availability,"// NOLINT(cert-err34-c) 'sscanf' used to convert a string to; // an integer value, but function will not report conversion; // errors; consider using 'strtol' instead",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:127,error,errors,127,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['error'],['errors']
Availability,"// NOLINT(cert-err34-c) 'sscanf' used to convert a string; // to an integer value, but function will not report; // conversion errors; consider using 'strtol' instead",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:127,error,errors,127,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,3,['error'],['errors']
Availability,"// NOLINT(cert-err34-c) 'sscanf' used to convert a; // string to an integer value, but function will not; // report conversion errors; consider using 'strtol'; // instead",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:127,error,errors,127,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['error'],['errors']
Availability,"// NOLINT(cert-err34-c) 'sscanf' used to convert a; // string to an integer value, but function will not; // report conversion errors; consider using 'strtol'; // instead; /* Port is specified with a +, bind to IPv6 and IPv4, INADDR_ANY */; /* Add 1 to len for the + character we skipped before */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:127,error,errors,127,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['error'],['errors']
Availability,"// NOLINT: silence clang-tidy warnings; // In case where the TFile is still open at 'tear-down' time the order of operation will be; // call Close(""nodelete""); // then later call delete TFile; // which means that at this point we might still have object held and those; // might requires a 'valid' TFile object in their desctructor (for example,; // TTree call's GetReadCache which expects a non-null fCacheReadMap).; // So delete the objects (if any) now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:90,down,down,90,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,1,['down'],['down']
Availability,"// NOLINT: silence clang-tidy warnings; // ReadBuffer returns kTRUE in case of failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:79,failure,failure,79,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,4,['failure'],['failure']
Availability,"// NOTE -- these larger errors are likely the results of treating; // the vector in a ctor or assignment as foreign...; // NO -- I'm fouling up the value of x() !!!!!; // As we push to higher z with zero rho, some accuracy loss is expected",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/test/coordinates3D.cxx:24,error,errors,24,math/genvector/test/coordinates3D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/test/coordinates3D.cxx,1,['error'],['errors']
Availability,"// NOTE forcing (W,L) size available since M68020 only",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.cpp:27,avail,available,27,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.cpp,1,['avail'],['available']
Availability,// NOTE: Assuming that a pointer will never break down to more than one VT; // or one register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:50,down,down,50,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['down'],['down']
Availability,// NOTE: Finalizing nothing is currently a no-op. Should it be an error?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/SimpleExecutorMemoryManager.cpp:66,error,error,66,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/SimpleExecutorMemoryManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/SimpleExecutorMemoryManager.cpp,1,['error'],['error']
Availability,// NOTE: Mask is dropped.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:9,Mask,Mask,9,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,2,['Mask'],['Mask']
Availability,"// NOTE: We cannot throw non-fatal errors from warnIfNilExpr,; // because it's called multiple times from some callers, so it'd cause; // an unwanted state split if two or more non-fatal errors are thrown; // within the same checker callback. For now we don't want to, but; // it'll need to be fixed if we ever want to.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp:35,error,errors,35,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp,2,['error'],['errors']
Availability,"// NOTE: We detected a bug, but the checker under whose name we would emit the; // error could be disabled. Generally speaking, the MallocChecker family is an; // integral part of the Static Analyzer, and disabling any part of it should; // only be done under exceptional circumstances, such as frequent false; // positives. If this is the case, we can reasonably believe that there are; // serious faults in our understanding of the source code, and even if we; // don't emit an warning, we should terminate further analysis with a sink; // node.; // Nonlocs can't be freed, of course.; // Non-region locations (labels and fixed addresses) also shouldn't be freed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:83,error,error,83,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,2,"['error', 'fault']","['error', 'faults']"
Availability,"// NOTE: We use the watcher instance as a RAII object to discard the handles; // for the directory in case of an error. Hence, this is early allocated,; // with the state being written directly to the watcher.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/DirectoryWatcher/windows/DirectoryWatcher-windows.cpp:113,error,error,113,interpreter/llvm-project/clang/lib/DirectoryWatcher/windows/DirectoryWatcher-windows.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/DirectoryWatcher/windows/DirectoryWatcher-windows.cpp,1,['error'],['error']
Availability,"// NOTE: also in case of a throw, be sure to properly close down the connection!; // Otherwise, you may get zombies waiting for a reply.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitZMQ/test/test_ZMQ.cpp:60,down,down,60,roofit/roofitZMQ/test/test_ZMQ.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitZMQ/test/test_ZMQ.cpp,3,['down'],['down']
Availability,"// NOTE: if the column type is unknown we don't want to fail, as we might be reading an RNTuple; // created with a future version of ROOT. In this case we just skip the valid bit range check,; // as we have no idea what the valid range is.; // In general, reading the metadata of an unknown column is fine, it becomes an error only when; // we try to read the actual data contained in it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleDescriptor.cxx:321,error,error,321,tree/ntuple/v7/src/RNTupleDescriptor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleDescriptor.cxx,1,['error'],['error']
Availability,"// NOTE: minuit2 seems to distort the tolerance in a weird way, so that tol becomes 1000 times smaller than; // specified Also note that if fits are failing because of edm over max, it can be a good idea to activate the; // Offset option when building nll",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooFit.cxx:38,toler,tolerance,38,roofit/xroofit/src/xRooFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooFit.cxx,1,['toler'],['tolerance']
Availability,"// NOTE: the Limit is included! The lexer recovery only ever inserts a; // single token past the end of the FileID, specifically the ) when a; // macro-arg containing a comma should be guarded by parentheses.; //; // It is safe to include the Limit here because SourceManager allocates; // FileSize + 1 for each SLocEntry.; //; // See https://github.com/llvm/llvm-project/issues/60722.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:42,recover,recovery,42,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,1,['recover'],['recovery']
Availability,"// NOTE: we do not need a R__LOCKGUARD2 since we know the; // mutex is available since the TClass constructor will make; // it",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferFile.cxx:71,avail,available,71,io/io/src/TBufferFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferFile.cxx,1,['avail'],['available']
Availability,"// NOTE:; // In the following part of the function, where the segments are rearranged,; // the shuffle mask SM can be of any length that is a multiple of a vector; // (i.e. a multiple of 2*SegLen), and non-zero.; // The output segment map is computed, and it may have any even number of; // entries, but the rearrangement of input segments will be done based only; // on the first two (non-undef) entries in the segment map.; // For example, if the output map is 3, 1, 1, 3 (it can have at most two; // distinct entries!), the segments 1 and 3 of Va/Vb will be packaged into; // a single vector V = 3:1. The output mask will then be updated to use; // seg(0,V), seg(1,V), seg(1,V), seg(0,V).; //; // Picking the segments based on the output map is an optimization. For; // correctness it is only necessary that Seg0 and Seg1 are the two input; // segments that are used in the output.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:103,mask,mask,103,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,2,['mask'],['mask']
Availability,"// NSW guarantees that we are only shifting out sign bits from the high bits,; // so we can ASHR the compare constant without needing a mask and eliminate; // the shift.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:136,mask,mask,136,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['mask'],['mask']
Availability,"// NT loads can only be vector aligned, so if its less aligned than the; // minimum vector size (which we can split the vector down to), we might as; // well use a regular unaligned vector load.; // We don't have any NT loads pre-SSE41.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp:127,down,down,127,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,1,['down'],['down']
Availability,// NULL implies no distance available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:28,avail,available,28,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,1,['avail'],['available']
Availability,"// NUW guarantees that we are only shifting out zero bits from the high bits,; // so we can LSHR the compare constant without needing a mask and eliminate; // the shift.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:136,mask,mask,136,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['mask'],['mask']
Availability,// NaCl ARM assembly (inline or standalone) can be written with a set of macros; // for the various SFI requirements like register masking. The assembly tool; // inserts the file containing the macros as an input into all the assembly; // jobs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/NaCl.cpp:131,mask,masking,131,interpreter/llvm-project/clang/lib/Driver/ToolChains/NaCl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/NaCl.cpp,1,['mask'],['masking']
Availability,// NaCl sandboxing requires that indirect call instructions are masked.; // This means that function entry points should be bundle-aligned.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:64,mask,masked,64,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,1,['mask'],['masked']
Availability,"// Name mismatch. We need a redirect. First grab the actual entry we want; // to return.; //; // This redirection logic intentionally leaks the external name of a; // redirected file that uses 'use-external-name' in \a; // vfs::RedirectionFileSystem. This allows clang to report the external; // name to users (in diagnostics) and to tools that don't have access to; // the VFS (in debug info and dependency '.d' files).; //; // FIXME: This is pretty complex and has some very complicated interactions; // with the rest of clang. It's also inconsistent with how ""real""; // filesystems behave and confuses parts of clang expect to see the; // name-as-accessed on the \a FileEntryRef.; //; // A potential plan to remove this is as follows -; // - Update callers such as `HeaderSearch::findUsableModuleForHeader()`; // to explicitly use the `getNameAsRequested()` rather than just using; // `getName()`.; // - Add a `FileManager::getExternalPath` API for explicitly getting the; // remapped external filename when there is one available. Adopt it in; // callers like diagnostics/deps reporting instead of calling; // `getName()` directly.; // - Switch the meaning of `FileEntryRef::getName()` to get the requested; // name, not the external name. Once that sticks, revert callers that; // want the requested name back to calling `getName()`.; // - Update the VFS to always return the requested name. This could also; // return the external name, or just have an API to request it; // lazily. The latter has the benefit of making accesses of the; // external path easily tracked, but may also require extra work than; // just returning up front.; // - (Optionally) Add an API to VFS to get the external filename lazily; // and update `FileManager::getExternalPath()` to use it instead. This; // has the benefit of making such accesses easily tracked, though isn't; // necessarily required (and could cause extra work than just adding to; // eg. `vfs::Status` up front).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp:1024,avail,available,1024,interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,1,['avail'],['available']
Availability,// Name the codegen type after the typedef name; // if there is no tag type name available,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenTypes.cpp:81,avail,available,81,interpreter/llvm-project/clang/lib/CodeGen/CodeGenTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenTypes.cpp,1,['avail'],['available']
Availability,"// Name, Title, fClassName, fBranch; // stay the same.; // Downsize the buffer if needed.; // See if our current buffer size is significantly larger (>2x) than the historical average.; // If so, try decreasing it at this flush boundary to closer to the size from OptimizeBaskets; // (or this historical average).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:59,Down,Downsize,59,tree/tree/src/TBasket.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx,1,['Down'],['Downsize']
Availability,"// Names of subreg indexes.; // Pointer to array of lane masks, one per sub-reg index.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:57,mask,masks,57,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,1,['mask'],['masks']
Availability,// Narrow shuffle mask to v4x128.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:18,mask,mask,18,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Narrow the repeated mask to create 32-bit element permutes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:23,mask,mask,23,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Narrower shifts only mask to 5 bits in hardware.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:24,mask,mask,24,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,"// Narrowing logical shift right.; // Operands are (source, shift, passthru, mask, vl)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:77,mask,mask,77,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,1,['mask'],['mask']
Availability,"// NaryReassociate on GEPs creates redundant common expressions, so run; // EarlyCSE after it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp:35,redundant,redundant,35,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp,2,['redundant'],['redundant']
Availability,// Need a final PHI to reconverge to above the helper lane branch mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAtomicOptimizer.cpp:66,mask,mask,66,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAtomicOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAtomicOptimizer.cpp,1,['mask'],['mask']
Availability,// Need to go down the pointer/mempointer chain and add qualifiers; // as see them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:14,down,down,14,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['down'],['down']
Availability,// Need to reorder the reuses masks of the operands with smaller VF to; // be able to find the match between the graph nodes and scalar; // operands of the given node during vectorization/cost estimation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:30,mask,masks,30,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['mask'],['masks']
Availability,// NegatedPowerOf2 - shifted mask in the top bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:29,mask,mask,29,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,1,['mask'],['mask']
Availability,// Negative mask,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DecoderEmitter.cpp:12,mask,mask,12,interpreter/llvm-project/llvm/utils/TableGen/DecoderEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DecoderEmitter.cpp,1,['mask'],['mask']
Availability,// Neither OpenCL nor HLSL allow an address space qualifyer on a return; // type.; //; // OpenCL v1.1 s6.5: Using an address space qualifier in a function return; // type declaration will generate a compilation error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:211,error,error,211,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['error'],['error']
Availability,"// Neither holds, error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:18,error,error,18,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['error'],['error']
Availability,// Never recoverable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:9,recover,recoverable,9,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['recover'],['recoverable']
Availability,// New combined shuffle mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:24,mask,mask,24,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['mask']
Availability,// New line and EOF may follow only #else/#endif. It will be reported; // as an error for #ifdef/#define after the call to prepLexMacroName().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGLexer.cpp:80,error,error,80,interpreter/llvm-project/llvm/lib/TableGen/TGLexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGLexer.cpp,1,['error'],['error']
Availability,// New loop counter instructions are redundant in the loop preheader when; // code generation for workshare loop is finshed. That's why mark them as; // ready for deletion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:37,redundant,redundant,37,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,1,['redundant'],['redundant']
Availability,// New targets should always warn about availability.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:40,avail,availability,40,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,1,['avail'],['availability']
Availability,// Next available register was r5 but candidate was greater than 32-bits so it; // has to go on the stack. However we still consume r5,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/Hexagon.cpp:8,avail,available,8,interpreter/llvm-project/clang/lib/CodeGen/Targets/Hexagon.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/Hexagon.cpp,1,['avail'],['available']
Availability,"// Next token is error or asymmetric error, check if first char of token is a '('",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealVar.cxx:17,error,error,17,roofit/roofitcore/src/RooRealVar.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealVar.cxx,2,['error'],['error']
Availability,// Next we need to compute the number of bits available for the discriminant; // by taking the min of the bits available for each member. Much of this; // would be amazingly easier with good constexpr support.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h:46,avail,available,46,interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h,2,['avail'],['available']
Availability,"// Next, check for those instructions we can look through.; // Assuming the mask does not wrap around, then the higher-order bits are; // taken directly from the first operand.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:76,mask,mask,76,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,"// Next, update WaterList. Specifically, we need to add NewMBB as having; // available water after it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp:77,avail,available,77,interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp,3,['avail'],['available']
Availability,"// Next, update WaterList. Specifically, we need to add OrigMBB as having; // available water after it (but not if it's already there, which happens; // when splitting before a conditional branch that is followed by an; // unconditional branch - in that case we want to insert NewBB).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp:78,avail,available,78,interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp,3,['avail'],['available']
Availability,// No atomic libcalls are available for max/min/umax/umin.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:26,avail,available,26,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,1,['avail'],['available']
Availability,"// No authentication available for re-use",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:21,avail,available,21,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,1,['avail'],['available']
Availability,// No bits are available!,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/TemplateName.h:15,avail,available,15,interpreter/llvm-project/clang/include/clang/AST/TemplateName.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/TemplateName.h,2,['avail'],['available']
Availability,// No block was available,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:16,avail,available,16,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,1,['avail'],['available']
Availability,"// No compounds are available. It is not clear whether we should; // even process such extenders where the initializer cannot be; // a single instruction, but do it for now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:20,avail,available,20,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,1,['avail'],['available']
Availability,// No copy regs are available to pop high regs. Let's make use of a return; // register and the scratch register (IP/R12) to copy things around.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp:20,avail,available,20,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp,1,['avail'],['available']
Availability,// No error,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:6,error,error,6,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,2,['error'],['error']
Availability,// No error occurred.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:6,error,error,6,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['error'],['error']
Availability,"// No error, print the result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-symbolizer/llvm-symbolizer.cpp:6,error,error,6,interpreter/llvm-project/llvm/tools/llvm-symbolizer/llvm-symbolizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-symbolizer/llvm-symbolizer.cpp,1,['error'],['error']
Availability,// No errors for indirect modules. This may be a bit of a problem for modules; // with no source files.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:6,error,errors,6,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,1,['error'],['errors']
Availability,// No explicit info available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp:20,avail,available,20,interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp,1,['avail'],['available']
Availability,// No failure of the predicate was detected,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h:6,failure,failure,6,interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h,1,['failure'],['failure']
Availability,// No fixit; we can't recover as if there were a semicolon here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:22,recover,recover,22,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,1,['recover'],['recover']
Availability,"// No floating point type available, if we can't use the bit operations; // for masking/blending then decompose into 128-bit vectors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:26,avail,available,26,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,"['avail', 'mask']","['available', 'masking']"
Availability,// No further region at exit available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h:29,avail,available,29,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h,1,['avail'],['available']
Availability,// No guarantees that ResolveAndFixSingleFunctionTemplateSpecialization; // leaves Result unchanged on failure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:103,failure,failure,103,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['failure'],['failure']
Availability,"// No information is available for this EHPad from itself or any of its; // descendants. An unwind all the way out to a pad in the caller would; // need also to agree with the unwind dest of the parent funclet, so; // search up the chain to try to find a funclet with information. Put; // null entries in the memo map to avoid re-processing as we go up.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:21,avail,available,21,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,1,['avail'],['available']
Availability,// No line info available,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Debugging/PerfSupportPlugin.cpp:16,avail,available,16,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Debugging/PerfSupportPlugin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Debugging/PerfSupportPlugin.cpp,1,['avail'],['available']
Availability,// No need to accumulate more cost information.; // We need to still gather the repairing information though.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:80,repair,repairing,80,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,1,['repair'],['repairing']
Availability,"// No need to error out for dictionaries.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/imt/inc/ROOT/RTaskArena.hxx:14,error,error,14,core/imt/inc/ROOT/RTaskArena.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/imt/inc/ROOT/RTaskArena.hxx,2,['error'],['error']
Availability,// No other 'x86.avx523.mask.cmp.*'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:24,mask,mask,24,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,1,['mask'],['mask']
Availability,// No overload matched.; // We ignore the errors if any matcher succeeded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h:42,error,errors,42,interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h,1,['error'],['errors']
Availability,"// No parameter declaration available, i.e. variadic function argument.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp:28,avail,available,28,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp,1,['avail'],['available']
Availability,// No pending error should exist here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp:14,error,error,14,interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,2,['error'],['error']
Availability,// No registers are free and available!,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:29,avail,available,29,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,2,['avail'],['available']
Availability,// No removal fixit: can't recover from this.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:27,recover,recover,27,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,1,['recover'],['recover']
Availability,"// No scope means global scope and that uses the zero index.; //; // We also use zero index when the scope is a DISubprogram; // to suppress the emission of LF_STRING_ID for the function,; // which can trigger a link-time error with the linker in; // VS2019 version 16.11.2 or newer.; // Note, however, skipping the debug info emission for the DISubprogram; // is a temporary fix. The root issue here is that we need to figure out; // the proper way to encode a function nested in another function; // (as introduced by the Fortran 'contains' keyword) in CodeView.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:222,error,error,222,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,1,['error'],['error']
Availability,// No section is not an error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/XCOFFObjectFile.cpp:24,error,error,24,interpreter/llvm-project/llvm/lib/Object/XCOFFObjectFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/XCOFFObjectFile.cpp,1,['error'],['error']
Availability,"// No sequencing is specified between the true and false expression.; // However since exactly one of both is going to be evaluated we can; // consider them to be sequenced. This is needed to avoid warning on; // something like ""x ? y+= 1 : y += 2;"" in the case where we will visit; // both the true and false expressions because we can't evaluate x.; // This will still allow us to detect an expression like (pre C++17); // ""(x ? y += 1 : y += 2) = y"".; //; // We don't wrap the visitation of the true and false expression with; // SequencedSubexpression because we don't want to downgrade modifications; // as side effect in the true and false expressions after the visition; // is done. (for example in the expression ""(x ? y++ : y++) + y"" we should; // not warn between the two ""y++"", but we should warn between the ""y++""; // and the ""y"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:581,down,downgrade,581,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['down'],['downgrade']
Availability,"// No special random device available: use rand()",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/rsaaux.cxx:28,avail,available,28,net/auth/src/rsaaux.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/rsaaux.cxx,3,['avail'],['available']
Availability,"// No streamer info, give up.; // FIXME: We should have an error message here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:59,error,error,59,tree/tree/src/TBranchElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx,1,['error'],['error']
Availability,"// No such dataset (not an error)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofLite.cxx:27,error,error,27,proof/proof/src/TProofLite.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofLite.cxx,1,['error'],['error']
Availability,"// No such dataset: not an error, but don't send message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:27,error,error,27,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['error'],['error']
Availability,// No suitable PCH file could be found. Return an error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:50,error,error,50,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,1,['error'],['error']
Availability,"// No terminator: simply read the data we know is (or should; // be) available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TWebFile.cxx:69,avail,available,69,net/net/src/TWebFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TWebFile.cxx,1,['avail'],['available']
Availability,"// No token here, but not an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/davix/src/TDavixFile.cxx:29,error,error,29,net/davix/src/TDavixFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/davix/src/TDavixFile.cxx,1,['error'],['error']
Availability,// No upgrade necessary. A null field will be introduced to indicate; // that no parameter information is available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:106,avail,available,106,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,1,['avail'],['available']
Availability,"// No viable function; fall through to handling this as a; // built-in operator, which will produce an error message for us.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:103,error,error,103,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['error'],['error']
Availability,"// No viable function; try to create a built-in operation, which will; // produce an error. Then, show the non-viable candidates.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:85,error,error,85,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['error'],['error']
Availability,// No vlen param - no lanes masked-off by it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IntrinsicInst.cpp:28,mask,masked-off,28,interpreter/llvm-project/llvm/lib/IR/IntrinsicInst.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IntrinsicInst.cpp,1,['mask'],['masked-off']
Availability,"// No, it wasn't, skip special version handling.; //Error(""Destructor2"", ""Attempt to delete unregistered object of class '%s' at address %p!"", GetName(), p);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:52,Error,Error,52,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['Error'],['Error']
Availability,"// No, it wasn't, we cannot know what to do.; //Error(""DeleteArray"", ""Attempt to delete unregistered array object, element type '%s', at address %p!"", GetName(), p);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:48,Error,Error,48,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['Error'],['Error']
Availability,// No-op. This error has already been reported.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:15,error,error,15,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['error'],['error']
Availability,// Non-deduced auto types only get here for error cases.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:44,error,error,44,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,1,['error'],['error']
Availability,// Non-mask operands of both Ands should also be in same basic block,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:7,mask,mask,7,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['mask'],['mask']
Availability,// Non-vector type and we have a zext mask with SRL.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:38,mask,mask,38,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Non-vp version will have same Args/Tys except mask and vector length.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:49,mask,mask,49,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,1,['mask'],['mask']
Availability,// NonLazyBind goes via GOT unless we know it's available locally.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Subtarget.cpp:48,avail,available,48,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Subtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Subtarget.cpp,1,['avail'],['available']
Availability,"// None of the specific case has been detected, give generic error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:61,error,error,61,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['error'],['error']
Availability,// None of these cases should fall through with an invalid Result; // unless they've already reported an error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:105,error,error,105,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,1,['error'],['error']
Availability,"// Nope, check the relative tolerance...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/FileUtilities.cpp:28,toler,tolerance,28,interpreter/llvm-project/llvm/lib/Support/FileUtilities.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/FileUtilities.cpp,1,['toler'],['tolerance']
Availability,"// Normalise columns to avoid rounding errors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLBoundingBox.cxx:39,error,errors,39,graf3d/gl/src/TGLBoundingBox.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLBoundingBox.cxx,1,['error'],['errors']
Availability,"// Normalize each offset against the minimum observed offset, and compute; // the bitwise OR of each of the offsets. The number of trailing zeros; // in the mask gives us the log2 of the alignment of all offsets, which; // allows us to compress the bitset by only storing one bit per aligned; // address.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:157,mask,mask,157,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,1,['mask'],['mask']
Availability,// Normalize the mask so that the first non-negative index comes from; // the first operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:17,mask,mask,17,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,1,['mask'],['mask']
Availability,// Normalize the mask value depending on whether it's V1 or V2.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:17,mask,mask,17,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Normalize the shuffle vector since mask and vector length don't match.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:38,mask,mask,38,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['mask'],['mask']
Availability,"// Normally this function only searches for already instantiated declaration; // however we have to make an exclusion for local types used before; // definition as in the code:; //; // template<typename T> void f1() {; // void g1(struct x1);; // struct x1 {};; // }; //; // In this case instantiation of the type of 'g1' requires definition of; // 'x1', which is defined later. Error recovery may produce an enum used; // before definition. In these cases we need to instantiate relevant; // declarations here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:378,Error,Error,378,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,2,"['Error', 'recover']","['Error', 'recovery']"
Availability,"// Not ""standard"" per se, but available even with the -undef flag.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp:30,avail,available,30,interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp,1,['avail'],['available']
Availability,"// Not C++20 (yet), so no concepts available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp:35,avail,available,35,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,1,['avail'],['available']
Availability,"// Not a User of any mask: not really blending, this is a; // single-predecessor phi.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:21,mask,mask,21,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,1,['mask'],['mask']
Availability,// Not a redundant move: fix build on gcc-7.5,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithExecutorProcessControl/LLJITWithExecutorProcessControl.cpp:9,redundant,redundant,9,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithExecutorProcessControl/LLJITWithExecutorProcessControl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithExecutorProcessControl/LLJITWithExecutorProcessControl.cpp,2,['redundant'],['redundant']
Availability,"// Not a text macro; not usable in TextItem context. Since we haven't used; // the token, put it back for better error recovery.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/MasmParser.cpp:113,error,error,113,interpreter/llvm-project/llvm/lib/MC/MCParser/MasmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/MasmParser.cpp,2,"['error', 'recover']","['error', 'recovery']"
Availability,// Not all bits of the immediate are used so mask it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.cpp:45,mask,mask,45,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.cpp,1,['mask'],['mask']
Availability,"// Not all blocks have explicitly-specified return types; if the return type; // is not available, but the return value expression has 'void' type, assume; // Sema already checked it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ReturnUndefChecker.cpp:88,avail,available,88,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ReturnUndefChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ReturnUndefChecker.cpp,1,['avail'],['available']
Availability,"// Not all calling conventions have only stack MOVs between the stack; // adjust and the call.; // We want to tolerate other instructions, to cover more cases.; // In particular:; // a) PCrel calls, where we expect an additional COPY of the basereg.; // b) Passing frame-index addresses.; // c) Calling conventions that have inreg parameters. These generate; // both copies and movs into registers.; // To avoid creating lots of special cases, allow any instruction; // that does not write into memory, does not def or use the stack; // pointer, and does not def any register that was used by a preceding; // push.; // (Reading from memory is allowed, even if referenced through a; // frame index, since these will get adjusted properly in PEI); // The reason for the last condition is that the pushes can't replace; // the movs in place, because the order must be reversed.; // So if we have a MOV32mr that uses EDX, then an instruction that defs; // EDX, and then the call, after the transformation the push will use; // the modified version of EDX, and not the original one.; // Since we are still in SSA form at this point, we only need to; // make sure we don't clobber any *physical* registers that were; // used by an earlier mov that will become a push.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp:110,toler,tolerate,110,interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp,1,['toler'],['tolerate']
Availability,"// Not available in XPM 3.2 and earlier",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/rootx/src/rootxx.cxx:7,avail,available,7,rootx/src/rootxx.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/rootx/src/rootxx.cxx,1,['avail'],['available']
Availability,// Not enough free registers - continue the search.; // Allocating the available registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp:71,avail,available,71,interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp,1,['avail'],['available']
Availability,"// Not in worklist.; // Don't bother moving everything down, just null out the slot.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GISelWorkList.h:55,down,down,55,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GISelWorkList.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GISelWorkList.h,1,['down'],['down']
Availability,"// Not masking anything out for the LHS, move mask to RHS.; // and ({x}or X, Y), C --> {x}or X, (and Y, C)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:7,mask,masking,7,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,2,['mask'],"['mask', 'masking']"
Availability,"// Not masking anything out for the RHS, move mask to LHS.; // and ({x}or X, Y), C --> {x}or (and X, C), Y",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:7,mask,masking,7,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,2,['mask'],"['mask', 'masking']"
Availability,// Not possible to express a shuffle mask for a scalable vector for this; // case.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:37,mask,mask,37,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,9,['mask'],['mask']
Availability,// Not requiring MemorySSA and getting it only if available will split; // the loop pass pipeline when LoopRotate is being run first.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRotation.cpp:50,avail,available,50,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRotation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRotation.cpp,1,['avail'],['available']
Availability,// Not sure about the mask and value for now...,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:22,mask,mask,22,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['mask'],['mask']
Availability,// Not updating the record in OperandRefs will cause TableGen; // to fail with an error at the end of this function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp:82,error,error,82,interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp,1,['error'],['error']
Availability,"// Not using the error logger, as there routine is meant to be called; // during library initialization/loading.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TObject.cxx:17,error,error,17,core/base/src/TObject.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TObject.cxx,1,['error'],['error']
Availability,// Note down frame index.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:8,down,down,8,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['down'],['down']
Availability,"// Note on error handling:; // Creating message_t can throw, but only when memory ran out (errno ENOMEM),; // and that is something only the caller can fix, so we don't catch it here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitZMQ/res/RooFit_ZMQ/ZeroMQSvc.h:11,error,error,11,roofit/roofitZMQ/res/RooFit_ZMQ/ZeroMQSvc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitZMQ/res/RooFit_ZMQ/ZeroMQSvc.h,1,['error'],['error']
Availability,"// Note that RLWIMI can be commuted as a 32-bit instruction, but not as a; // 64-bit instruction (so we don't handle PPC::RLWIMI8 here), because; // changing the relative order of the mask operands might change what happens; // to the high-bits of the mask (and, thus, the result).; // Cannot commute if it has a non-zero rotate count.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:184,mask,mask,184,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,2,['mask'],['mask']
Availability,"// Note that any tokens that are tagged with MR_None have been passed as; // arguments to the macro that have not been expanded, for example:; // Given: #define ID(X) x; // When calling: ID(a, b); // 'b' will be part of the reconstructed token stream, but tagged MR_None.; // Given that erroring out in this case would be disruptive, we continue; // pushing the (unformatted) token.; // FIXME: This can lead to unfortunate formatting decisions - give the user; // a hint that their macro definition is broken.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/MacroCallReconstructor.cpp:287,error,erroring,287,interpreter/llvm-project/clang/lib/Format/MacroCallReconstructor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/MacroCallReconstructor.cpp,1,['error'],['erroring']
Availability,// Note that masked-merge variants using XOR or ADD expressions are; // normalized to OR by InstCombine so we only check for OR.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:13,mask,masked-merge,13,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['masked-merge']
Availability,"// Note that the code in FunctionLoweringInfo::ComputePHILiveOutRegInfo; // assumes that constant PHI operands will be zero extended, and failure to; // match that assumption will cause problems if we sign extend here but; // some user of a PHI is in a block for which we fall back to full SDAG; // instruction selection.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:138,failure,failure,138,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,1,['failure'],['failure']
Availability,"// Note that the order is relevant, more than one of the flag might be; // on at the same time and we want to use 'best' option available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/ThreadLocalStorage.h:128,avail,available,128,core/foundation/inc/ThreadLocalStorage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/ThreadLocalStorage.h,1,['avail'],['available']
Availability,// Note that this may return NULL if there was an error parsing or building; // one of the argument expressions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:50,error,error,50,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['error'],['error']
Availability,"// Note that we do NOT canonicalize the base class here, because; // ASTRecordLayout doesn't either. If that leads us down the wrong path,; // so be it; at least we won't crash.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp:118,down,down,118,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/MemRegion.cpp,1,['down'],['down']
Availability,"// Note that we don't force a hard error on the range check here, allowing; // template-generated or macro-generated dead code to potentially have out-of-; // range values. These need to code generate, but don't need to necessarily; // make any sense. We use a warning that defaults to an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:35,error,error,35,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,2,['error'],['error']
Availability,// Note that we have to do the merge right after processing function.; // This allows OutlineFS's profile to be used for annotation during; // top-down processing of functions' annotation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:147,down,down,147,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,1,['down'],['down']
Availability,"// Note that we have to do this with our own collection, because there are; // times where a constraint-expression check can cause us to need to evaluate; // other constriants that are unrelated, such as when evaluating a recovery; // expression, or when trying to determine the constexpr-ness of special; // members. Otherwise we could just use the; // Sema::InstantiatingTemplate::isAlreadyBeingInstantiated function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:222,recover,recovery,222,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,1,['recover'],['recovery']
Availability,// Note that we only check if a File was returned. If it was out-of-date; // we have complained but we will continue creating a FileID to recover; // gracefully.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:138,recover,recover,138,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['recover'],['recover']
Availability,// Note! I deliberately want it to fall thru so more errors are caught.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:53,error,errors,53,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,1,['error'],['errors']
Availability,"// Note, this is not really an error until the next bind but make no sense; // for a BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB to not be followed by another; // bind operation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/MachOObjectFile.cpp:31,error,error,31,interpreter/llvm-project/llvm/lib/Object/MachOObjectFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/MachOObjectFile.cpp,1,['error'],['error']
Availability,"// Note, we are at last resort and loading library based on a weak; // symbol is allowed. Otherwise, the JIT will issue an unresolved; // symbol error.; //; // There are other weak symbol kinds (marked as 'V') to denote; // typeinfo and vtables. It is unclear whether we should load such; // libraries or from which library we should resolve the symbol.; // We seem to not have a way to differentiate it from the symbol API.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp:145,error,error,145,interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp,3,['error'],['error']
Availability,"// Note: Addition is associative in two's complement even when in case of; // signed overflow.; //; // Error bits can only propagate into higher significant bits. As these are; // already regarded as undefined, there is no change.; //; // Theorem: Adding a constant to a polynomial does not change the error; // term.; //; // Proof:; //; // Since the addition is associative and commutes:; //; // (B + A + E*2^(n-e)) + C = B + (A + C) + E*2^(n-e); // [qed]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:103,Error,Error,103,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,2,"['Error', 'error']","['Error', 'error']"
Availability,"// Note: AsymptoticCalculator enforces not less than 1 on tolerance - should we do so too?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooFit.cxx:58,toler,tolerance,58,roofit/xroofit/src/xRooFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooFit.cxx,1,['toler'],['tolerance']
Availability,// Note: CyclesLeft can be a negative number. It is an error to; // make it an unsigned quantity because users of this write may; // specify a negative ReadAdvance.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/Instruction.cpp:55,error,error,55,interpreter/llvm-project/llvm/lib/MCA/Instruction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/Instruction.cpp,1,['error'],['error']
Availability,"// Note: In general, we do not create new shuffles in InstCombine because we; // do not know if a target can lower an arbitrary shuffle optimally. In this; // case, the shuffle uses the existing mask, so there is no additional risk.; // Select the variable vectors first, then perform the binop:; // shuffle (op X, C0), (op Y, C1), M --> op (shuffle X, Y, M), C'; // shuffle (op C0, X), (op C1, Y), M --> op C', (shuffle X, Y, M)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:195,mask,mask,195,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['mask'],['mask']
Availability,"// Note: IsUndef is sort of redundant. We could have determine it by; // checking that at all Ops are undef. Alternatively, we could have; // generate a build_vector of undefs and rely on another combine to; // clean that up. For now, given we already gather this information; // in tryCombineConcatVectors, just save compile time and issue the; // right thing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:28,redundant,redundant,28,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,1,['redundant'],['redundant']
Availability,"// Note: Multiplication distributes over the addition; //; // Theorem: Multiplication distributes over the addition; //; // Proof(1):; //; // (B+A)*C =-; // = (B + A) + (B + A) + .. {C Times}; // addition is associative and commutes, hence; // = B + B + .. {C Times} .. + A + A + .. {C times}; // = B*C + A*C; // (see (function add) for signed values and overflows); // [qed]; //; // Theorem: If C has c trailing zeros, errors bits in A or B are shifted out; // to the left.; //; // Proof(2):; //; // Let B' and A' be the n-Bit inputs with some unknown errors EA,; // EB at e leading bits. B' and A' can be written down as:; //; // B' = B + 2^(n-e)*EB; // A' = A + 2^(n-e)*EA; //; // Let C' be an input with c trailing zero bits. C' can be written as; //; // C' = C*2^c; //; // Therefore we can compute the result by using distributivity and; // commutativity.; //; // (B'*C' + A'*C') = [B + 2^(n-e)*EB] * C' + [A + 2^(n-e)*EA] * C' =; // = [B + 2^(n-e)*EB + A + 2^(n-e)*EA] * C' =; // = (B'+A') * C' =; // = [B + 2^(n-e)*EB + A + 2^(n-e)*EA] * C' =; // = [B + A + 2^(n-e)*EB + 2^(n-e)*EA] * C' =; // = (B + A) * C' + [2^(n-e)*EB + 2^(n-e)*EA)] * C' =; // = (B + A) * C' + [2^(n-e)*EB + 2^(n-e)*EA)] * C*2^c =; // = (B + A) * C' + C*(EB + EA)*2^(n-e)*2^c =; //; // Let EC be the final error with EC = C*(EB + EA); //; // = (B + A)*C' + EC*2^(n-e)*2^c =; // = (B + A)*C' + EC*2^(n-(e-c)); //; // Since EC is multiplied by 2^(n-(e-c)) the resulting error contains c; // less error bits than the input. c bits are shifted out to the left.; // [qed]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:420,error,errors,420,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,6,"['down', 'error']","['down', 'error', 'errors']"
Availability,"// Note: PyTorch doesn't store training history data unlike Keras. A user can append and save the loss, ; // accuracy, other metrics etc to a file for later use.; /*; * Store trained model to file (only if option 'SaveBestOnly' is NOT activated,; * because we do not want to override the best model checkpoint); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyTorch.cxx:299,checkpoint,checkpoint,299,tmva/pymva/src/MethodPyTorch.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyTorch.cxx,1,['checkpoint'],['checkpoint']
Availability,// Note: The SystemZLDCleanupPass will remove redundant computations; // of the module base offset. Count total number of local-dynamic; // accesses to trigger execution of that pass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:46,redundant,redundant,46,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['redundant'],['redundant']
Availability,"// Note: There are a lot more choices based on type with AVX-512, but; // there's really no advantage when the load isn't masked.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:122,mask,masked,122,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,1,['mask'],['masked']
Availability,"// Note: There are a lot more choices based on type with AVX-512, but; // there's really no advantage when the store isn't masked.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:123,mask,masked,123,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,1,['mask'],['masked']
Availability,"// Note: These functions are designed to be robust to NaNs",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/bvh/v2/vec.h:44,robust,robust,44,geom/geom/inc/bvh/v2/vec.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/bvh/v2/vec.h,1,['robust'],['robust']
Availability,"// Note: This functionality is used only when unsafe-fp-math is enabled, and; // on cores with reciprocal estimates (which are used when unsafe-fp-math is; // enabled for division), this functionality is redundant with the default; // combiner logic (once the division -> reciprocal/multiply transformation; // has taken place). As a result, this matters more for older cores than for; // newer ones.; // Combine multiple FDIVs with the same divisor into multiple FMULs by the; // reciprocal if there are two or more FDIVs (for embedded cores with only; // one FP pipeline) for three or more FDIVs (for generic OOO cores).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:204,redundant,redundant,204,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['redundant'],['redundant']
Availability,// Note: We call removeProdecessor later since we need to be able to get the; // PHI value for the default case in case we're using a bit mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:138,mask,mask,138,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['mask'],['mask']
Availability,"// Note: We don't speculate PHIs here, so we'll miss instruction chains kept; // alive only by ephemeral values.; // Walk the worklist using an index but without caching the size so we can; // append more entries as we process the worklist. This forms a queue without; // quadratic behavior by just leaving processed nodes at the head of the; // worklist forever.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CodeMetrics.cpp:81,alive,alive,81,interpreter/llvm-project/llvm/lib/Analysis/CodeMetrics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CodeMetrics.cpp,1,['alive'],['alive']
Availability,"// Note: We explicitly leave Matches unmodified if there isn't a clear best; // option, so we can potentially give the user a better error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:133,error,error,133,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['error'],['error']
Availability,"// Note: We tested to make sure the streamer info was available previously.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:54,avail,available,54,tree/tree/src/TBranchElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx,1,['avail'],['available']
Availability,"// Note: it is impossible to trigger this error currently, it is; // untested.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp:42,error,error,42,interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp,1,['error'],['error']
Availability,"// Note: minima where the covariance was made posdef are deemed 'valid' ...; // remove limits on pars before calculation - CURRENTLY HAS NO EFFECT, minuit still holds the state as; // transformed interesting note: error on pars before hesse can be significantly smaller than after hesse ...; // what is the pre-hesse error corresponding to? - corresponds to approximation of covariance matrix calculated; // with iterative method; /*auto parSettings = _minimizer.fitter()->Config().ParamsSettings();; for (auto &ss : _minimizer.fitter()->Config().ParamsSettings()) {; ss.RemoveLimits();; }. for(auto f : *floatPars) {; auto v = dynamic_cast<RooRealVar*>(f);; if(v->hasRange(nullptr)) v->setRange(""backup"",v->getMin(),v->getMax());; v->removeRange();; }*/; // std::cout << ""nIterations = "" << _minimizer.fitter()->GetMinimizer()->NIterations() << std::endl;; // std::cout << ""covQual before hesse = "" << _minimizer.fitter()->GetMinimizer()->CovMatrixStatus() <<; // std::endl;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooFit.cxx:214,error,error,214,roofit/xroofit/src/xRooFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooFit.cxx,2,['error'],['error']
Availability,// Note: only available for agg return types,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:14,avail,available,14,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,3,['avail'],['available']
Availability,// Note: the CleanupLocalDynamicTLSPass will remove redundant computations; // of Base.; // Build x@dtpoff.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:52,redundant,redundant,52,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['redundant'],['redundant']
Availability,// Note: there used to be some attempt at recovery here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:42,recover,recovery,42,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['recover'],['recovery']
Availability,"// Note: there used to be some attempt at recovery here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclExtractor.cpp:42,recover,recovery,42,interpreter/cling/lib/Interpreter/DeclExtractor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclExtractor.cpp,1,['recover'],['recovery']
Availability,// Note: this code assumes that lane masks on AMDGPU completely; // cover registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp:37,mask,masks,37,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,1,['mask'],['masks']
Availability,"// Note: this turns large loads into lock cmpxchg8b/16b.; // TODO: In 32-bit mode, use MOVLPS when SSE1 is available?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:107,avail,available,107,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avail'],['available']
Availability,"// Note: we can't do Hesse here. Without the error recovery, Minuit2; // would print errors that would cause the unit test to fail.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testNaNPacker.cxx:45,error,error,45,roofit/roofitcore/test/testNaNPacker.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testNaNPacker.cxx,3,"['error', 'recover']","['error', 'errors', 'recovery']"
Availability,"// Note: we can't use Hesse or Minos. Without the error recovery, Minuit2; // would print errors that would cause the unit test to fail.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testNaNPacker.cxx:50,error,error,50,roofit/roofitcore/test/testNaNPacker.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testNaNPacker.cxx,3,"['error', 'recover']","['error', 'errors', 'recovery']"
Availability,"// Note: we cannot expect exact equal results here in most cases when using; // event-based splitting (which is currently the default; THIS MAY CHANGE!).; // See LikelihoodJobTest, UnbinnedGaussian1DSelectedParameterValues for an; // example of where slight bit-wise differences can pop up in fits like this; // due to minor bit-wise errors in Kahan summation due to different split; // ups over the event range. We do expect pretty close results, though,; // because this fit only has 4 iterations and bit-wise differences should; // not add up too much.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/TestStatistics/testLikelihoodGradientJob.cxx:334,error,errors,334,roofit/roofitcore/test/TestStatistics/testLikelihoodGradientJob.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/TestStatistics/testLikelihoodGradientJob.cxx,1,['error'],['errors']
Availability,"// Note: we could also extend to i32 and use i32 med3 if i16 med3 is; // not available, but this is unlikely to be profitable as constants; // will often need to be materialized & extended, especially on; // pre-GFX10 where VOP3 instructions couldn't take literal operands.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:77,avail,available,77,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['avail'],['available']
Availability,"// Note: we could insert here a wait for all thread to be finished.; // this is questionable though as we need to balance between fixing a; // user error (the thread was let lose and the caller did not explicit wait); // and the risk that we can not terminate a failing process.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/thread/src/TThread.cxx:148,error,error,148,core/thread/src/TThread.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/thread/src/TThread.cxx,1,['error'],['error']
Availability,"// Note: when above ctor is called without std::moving components, you get a really obscure error. Pass as; // std::move(components)!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooFit/TestStatistics/RooSumL.h:92,error,error,92,roofit/roofitcore/inc/RooFit/TestStatistics/RooSumL.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooFit/TestStatistics/RooSumL.h,1,['error'],['error']
Availability,"// Nothing to do except setting the error code (if required) and sock to NULL",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TSocket.cxx:36,error,error,36,net/net/src/TSocket.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TSocket.cxx,2,['error'],['error']
Availability,// Nothing to do: a ReturnStmt with no value is fine recovery.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:53,recover,recovery,53,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,1,['recover'],['recovery']
Availability,// Nothing to repair,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp:14,repair,repair,14,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,1,['repair'],['repair']
Availability,// Nothing we can do if the used underlying object cannot be reliably; // determined.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:61,reliab,reliably,61,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,1,['reliab'],['reliably']
Availability,// Nothing we can do: Report an error and keep going with an invalid; // allocation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:32,error,error,32,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,1,['error'],['error']
Availability,// Notify Bootstrap->CV while holding the mutex because the mutex is; // also keeping Bootstrap->CV alive.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp:100,alive,alive,100,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp,1,['alive'],['alive']
Availability,"// Notify failure",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofLite.cxx:10,failure,failure,10,proof/proof/src/TProofLite.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofLite.cxx,3,['failure'],['failure']
Availability,"// Notify failure to client ...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:10,failure,failure,10,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,1,['failure'],['failure']
Availability,// Notify groups that RR.first is no longer available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/ResourceManager.cpp:44,avail,available,44,interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/ResourceManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/ResourceManager.cpp,1,['avail'],['available']
Availability,// Notify groups that RR.first is now available again.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/ResourceManager.cpp:38,avail,available,38,interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/ResourceManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/ResourceManager.cpp,1,['avail'],['available']
Availability,"// Notify only if verbosity is on: most likely the failure has already been notified",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:51,failure,failure,51,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['failure'],['failure']
Availability,// Now all required passes are available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:31,avail,available,31,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,1,['avail'],['available']
Availability,// Now check liveness info if available,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:30,avail,available,30,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,1,['avail'],['available']
Availability,"// Now construct opcode groups. Groups are used by the SubtargetEmitter when; // expanding the body of a STIPredicate function. In particular, each opcode; // group is expanded into a sequence of labels in a switch statement.; // It identifies opcodes for which different processors define same predicates; // and same opcode masks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenSchedule.cpp:326,mask,masks,326,interpreter/llvm-project/llvm/utils/TableGen/CodeGenSchedule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenSchedule.cpp,1,['mask'],['masks']
Availability,// Now construct the mask that will be used by the blended vrgather operation.; // Cconstruct the appropriate indices into each vector.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:21,mask,mask,21,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['mask'],['mask']
Availability,// Now construct the mask that will be used by the vselect operation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:21,mask,mask,21,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['mask'],['mask']
Availability,"// Now delete the objects still 'held' by the TFiles so that it; // is done before the tear down of the libraries.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:92,down,down,92,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,1,['down'],['down']
Availability,// Now duplicate the comparison mask we want across all other lanes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:32,mask,mask,32,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['mask'],['mask']
Availability,"// Now evaluate the expression whose value this variable should be set; // to, since the expression of a command-line variable definition should; // only use variables defined earlier on the command-line. If not, this; // is an error and we report it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:228,error,error,228,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,1,['error'],['error']
Availability,// Now extract the undef/constant bit data into the raw shuffle masks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ShuffleDecodeConstantPool.cpp:64,mask,masks,64,interpreter/llvm-project/llvm/lib/Target/X86/X86ShuffleDecodeConstantPool.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ShuffleDecodeConstantPool.cpp,1,['mask'],['masks']
Availability,"// Now finish up by truncating all the way down to the original result; // type. This should normally be something that ends up being legal directly,; // but in theory if a target has very wide vectors and an annoyingly; // restricted set of legal types, this split can chain to build things up.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:43,down,down,43,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,1,['down'],['down']
Availability,// Now handle enum constant availability diagnostics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:28,avail,availability,28,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['avail'],['availability']
Availability,// Now hoist the DWord down to the right half.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:23,down,down,23,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['down'],['down']
Availability,"// Now ifcvt'd block will look like this:; // BB:; // ...; // t, f = cmp; // if t op; // b BBf; //; // We cannot further ifcvt this block because the unconditional branch; // will have to be predicated on the new condition, that will not be; // available if cmp executes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:245,avail,available,245,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,1,['avail'],['available']
Availability,"// Now lookup all members of this group and record down their names and; // SIDs into the output file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/winnt/src/TWinNTSystem.cxx:51,down,down,51,core/winnt/src/TWinNTSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/winnt/src/TWinNTSystem.cxx,1,['down'],['down']
Availability,// Now make sure there are no remaining references to the sections that will; // be removed. Sometimes it is impossible to remove a reference so we emit; // an error here instead.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObject.cpp:160,error,error,160,interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObject.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObject.cpp,1,['error'],['error']
Availability,"// Now push the high registers; // There are no store instructions that can access high registers directly,; // so we have to move them to low registers, and push them.; // This might take multiple pushes, as it is possible for there to; // be fewer low registers available than high registers which need saving.; // Find the first register to save.; // Registers must be processed in reverse order so that in case we need to use; // multiple PUSH instructions, the order of the registers on the stack still; // matches the unwind info. They need to be swicthed back to ascending order; // before adding to the PUSH instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp:264,avail,available,264,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp,1,['avail'],['available']
Availability,"// Now read decorrelation matrix if available",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBase.cxx:36,avail,available,36,tmva/tmva/src/MethodBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBase.cxx,1,['avail'],['available']
Availability,// Now restrict the number of incoming blocks down to only those with; // VNumToSink.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp:46,down,down,46,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp,1,['down'],['down']
Availability,// Now return a new VSELECT using the mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:38,mask,mask,38,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// Now that all globals which are needed are in the AliveGlobals set, we loop; // through the program, deleting those which are not alive.; //; // The first pass is to drop initializers of global variables which are dead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:52,Alive,AliveGlobals,52,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,2,"['Alive', 'alive']","['AliveGlobals', 'alive']"
Availability,"// Now that all loop invariants have been removed from the loop, promote any; // memory references to scalars that we can.; // Don't sink stores from loops without dedicated block exits. Exits; // containing indirect branches are not transformed by loop simplify,; // make sure we catch that. An additional load may be generated in the; // preheader for SSA updater, so also avoid sinking when no preheader; // is available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:414,avail,available,414,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,1,['avail'],['available']
Availability,"// Now that all the header have been registered/compiled, let's; // make sure to 'reset' the TClass that have a class init in this module; // but already had their type information available (using information/header; // loaded from other modules or from class rules or from opening a TFile; // or from loading header in a way that did not provoke the loading of; // the library we just loaded).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:181,avail,available,181,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['avail'],['available']
Availability,"// Now that the element types match, get the shuffle mask and RHS of the; // shuffle to use, which depends on whether we're increasing or decreasing the; // size of the input.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:53,mask,mask,53,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,1,['mask'],['mask']
Availability,"// Now that the suspicious clone detector has checked for pattern errors,; // we also filter all clones who don't have matching patterns",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp:66,error,errors,66,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp,1,['error'],['errors']
Availability,"// Now that we have a profiled call graph, construct top-down order; // by building up SCC and reversing SCC order.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/CSPreInliner.cpp:57,down,down,57,interpreter/llvm-project/llvm/tools/llvm-profgen/CSPreInliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/CSPreInliner.cpp,1,['down'],['down']
Availability,"// Now that we have deleted the functions that are unnecessary for the; // program, try to remove instructions that are not necessary to cause the; // crash. To do this, we loop through all of the instructions in the; // remaining functions, deleting them (replacing any values produced with; // nulls), and then running ADCE and SimplifyCFG. If the transformed input; // still triggers failure, keep deleting until we cannot trigger failure; // anymore.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:387,failure,failure,387,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,2,['failure'],['failure']
Availability,"// Now that we have the predicate state available at the start of each block; // in the CFG, trace it through each block, hardening vulnerable instructions; // as we go.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:40,avail,available,40,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,1,['avail'],['available']
Availability,"// Now that we have two nodes and a new element, insert the perclated value; // into ourself by moving all the later values/children down, then inserting; // the new one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp:133,down,down,133,interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp,1,['down'],['down']
Availability,"// Now that we've visited every function, verify that we never asked to; // recover a frame index that wasn't escaped.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:76,recover,recover,76,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,1,['recover'],['recover']
Availability,// Now try assuming that any undefined bits between the first and; // last defined set bits are set. This increases the chances of; // using a non-wraparound mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:158,mask,mask,158,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['mask'],['mask']
Availability,// Now try the tail folding; // Invalidate interleave groups that require an epilogue if we can't mask; // the interleave-group.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:98,mask,mask,98,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['mask'],['mask']
Availability,"// Now use binding to return a usable class. Upcast: result is a base.; // Downcast: result is a derived.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/src/TClassPyz.cxx:75,Down,Downcast,75,bindings/pyroot/pythonizations/src/TClassPyz.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/src/TClassPyz.cxx,1,['Down'],['Downcast']
Availability,"// Now walk from the error node up the BFS path, always taking the; // predeccessor with the lowest number.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:21,error,error,21,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,1,['error'],['error']
Availability,"// Now walk through the parenthesized entry, until the number of open; // parentheses goes back down to 0 (the first '(' was parsed above).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:96,down,down,96,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,1,['down'],['down']
Availability,"// Now we are at the point where declarator parsing is finished.; //; // Try to catch keywords in place of the identifier in a declarator, and; // in particular the common case where:; // 1 identifier comes at the end of the declarator; // 2 if the identifier is dropped, the declarator is valid but anonymous; // (no identifier); // 3 declarator parsing succeeds, and then we have a trailing keyword,; // which is never valid in a param list (e.g. missing a ','); // And we can't handle this in ParseDeclarator because in general keywords; // may be allowed to follow the declarator. (And in some cases there'd be; // better recovery like inserting punctuation). ParseDeclarator is just; // treating this as an anonymous parameter, and fortunately at this point; // we've already almost done that.; //; // We care about case 1) where the declarator type should be known, and; // the identifier should be null.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:626,recover,recovery,626,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['recover'],['recovery']
Availability,// Now we can create our integer vector type. Note that it may be larger; // than the resulting mask type: v4i1 would use v1i8 as its integer type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:96,mask,mask,96,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['mask'],['mask']
Availability,"// Now we error out, first checking if we did not get a more specific; // error message from SearchBranchWithCompositeName. If not, we go with; // a generic message.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReaderValue.cxx:10,error,error,10,tree/treeplayer/src/TTreeReaderValue.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReaderValue.cxx,2,['error'],['error']
Availability,// Now we find the best candidate by searching for the one with the following; // properties in order:; //; // 1) An unswitching cost below the threshold; // 2) The smallest number of duplicated unswitch candidates (to avoid; // creating redundant subsequent unswitching); // 3) The smallest cost after unswitching.; //; // We prioritize reducing fanout of unswitch candidates provided the cost; // remains below the threshold because this has a multiplicative effect.; //; // This requires memoizing each dominator subtree to avoid redundant work.; //; // FIXME: Need to actually do the number of candidates part above.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:238,redundant,redundant,238,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,2,['redundant'],['redundant']
Availability,// Now we just need to check that EltSize & Mask == Width & Mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:44,Mask,Mask,44,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['Mask'],['Mask']
Availability,"// Now we know that each predecessor of this block has a value in; // AvailablePreds, sort them for efficient access as we're walking the preds.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:70,Avail,AvailablePreds,70,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['Avail'],['AvailablePreds']
Availability,"// Now we know we have Button 1 -> 3.; // Allow a single action/button down/up pairing - block others",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLEventHandler.cxx:71,down,down,71,graf3d/gl/src/TGLEventHandler.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLEventHandler.cxx,1,['down'],['down']
Availability,"// Now we know which is the closest matching scaleable font and the; // closest matching bitmapped font. If the scaleable font was a; // better match, try getting the scaleable font; however, if the; // scalable font was not actually available in the desired pointsize,; // fall back to the closest bitmapped font.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGFont.cxx:234,avail,available,234,gui/gui/src/TGFont.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGFont.cxx,1,['avail'],['available']
Availability,"// Now we look at mask elements 0,2,4,6,8,10,12,14. Pack the mask into a; // 32-bit space, only need 4-bit nibbles per element.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:18,mask,mask,18,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,2,['mask'],['mask']
Availability,"// Now we look at mask elements 0,4,8,12",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:18,mask,mask,18,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['mask'],['mask']
Availability,"// Now we look at mask elements 0,4,8,12, which are the beginning of words.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:18,mask,mask,18,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['mask'],['mask']
Availability,"// Now, both matches failed, and the long-form match failed on the mnemonic; // suffix token operand. The short-form match failure is probably more; // relevant: use it instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp:123,failure,failure,123,interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp,1,['failure'],['failure']
Availability,"// Now, mask the relevant bit in each element.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:8,mask,mask,8,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// Now, take care of required analyses that are not available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:52,avail,available,52,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,1,['avail'],['available']
Availability,"// Num chars to read; 0 for blocking, -1 for all available",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/TextInput.h:49,avail,available,49,core/textinput/src/textinput/TextInput.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/TextInput.h,1,['avail'],['available']
Availability,"// Number of available candidates - if 0, no need to continue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:13,avail,available,13,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,1,['avail'],['available']
Availability,// Number of bits in hash mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:26,mask,mask,26,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,1,['mask'],['mask']
Availability,"// Number of bits per code.; // NOTE: This shares the same name as the encoder, but has a different; // meaning here. Here this masks each code coming from the code stream.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:128,mask,masks,128,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['mask'],['masks']
Availability,// Number of entries that are available during this cycle.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Stages/MicroOpQueueStage.h:30,avail,available,30,interpreter/llvm-project/llvm/include/llvm/MCA/Stages/MicroOpQueueStage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Stages/MicroOpQueueStage.h,1,['avail'],['available']
Availability,"// Number of security levels and masks",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/inc/AuthConst.h:33,mask,masks,33,net/auth/inc/AuthConst.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/inc/AuthConst.h,1,['mask'],['masks']
Availability,"// Numeric substitution reads the value of a variable directly, not via; // GlobalNumericVariableTable. Therefore, we clear local variables by; // clearing their value which will lead to a numeric substitution failure. We; // also mark the variable for removal from GlobalNumericVariableTable since; // this is what defineCmdlineVariables checks to decide that no global; // variable has been defined.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:210,failure,failure,210,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,1,['failure'],['failure']
Availability,// OR/AND test for masks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h:19,mask,masks,19,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,1,['mask'],['masks']
Availability,"// ORI Rd, 0x0 is redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp:18,redundant,redundant,18,interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp,1,['redundant'],['redundant']
Availability,"// ORR is commutative, so canonicalize to the form 'or (and X, Mask0Imm),; // (and Y, Mask1Imm)' where Mask1Imm is the shifted mask masking off the; // bits to be inserted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:127,mask,mask,127,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,2,['mask'],"['mask', 'masking']"
Availability,"// Objective-C++ ARC: it is an error to have a non-trivial field of; // a union. However, system headers in Objective-C programs; // occasionally have Objective-C lifetime objects within unions,; // and rather than cause the program to fail, we make those; // members unavailable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:31,error,error,31,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['error'],['error']
Availability,// Objective-C++: Detect C++ keywords and try to prevent further errors by; // treating these keyword as valid member names.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:65,error,errors,65,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['error'],['errors']
Availability,// Objective-C++: Recover by treating this keyword as a valid identifier.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:18,Recover,Recover,18,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp,1,['Recover'],['Recover']
Availability,"// Ok, we have a graph, so we can propagate the invalidation down into it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:61,down,down,61,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,1,['down'],['down']
Availability,// Ok. CurrentVec is the left hand side.; // Update the mask accordingly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:56,mask,mask,56,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['mask']
Availability,// Ok. CurrentVec is the right hand side.; // Update the mask accordingly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:57,mask,mask,57,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['mask']
Availability,"// Okay! Burn it all down. This relies for correctness on the; // assumption that the retain is emitted as part of the return and; // that thereafter everything is used ""linearly"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:21,down,down,21,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,1,['down'],['down']
Availability,"// Okay, attempt to join these two intervals. On failure, this returns false.; // Otherwise, if one of the intervals being joined is a physreg, this method; // always canonicalizes DstInt to be it. The output ""SrcInt"" will not have; // been modified, so we can use this information below to update aliases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:49,failure,failure,49,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,1,['failure'],['failure']
Availability,"// Okay, badness! Report an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LLVMConventionsChecker.cpp:28,error,error,28,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LLVMConventionsChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LLVMConventionsChecker.cpp,1,['error'],['error']
Availability,"// Okay, great! Now we know that we extracted a loop and that loop; // extraction both didn't break the program, and didn't mask the problem.; // Replace the current program with the loop extracted version, and try to; // extract another loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:124,mask,mask,124,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,1,['mask'],['mask']
Availability,"// Okay, now that we have reduced the list of passes which are causing the; // failure, see if we can pin down which functions are being; // miscompiled... first build a list of all of the non-external functions in; // the program.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:79,failure,failure,79,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,2,"['down', 'failure']","['down', 'failure']"
Availability,"// Okay, the loaded value is available in at least one (and maybe all!); // predecessors. If the value is unavailable in more than one unique; // predecessor, we want to insert a merge block for those common predecessors.; // This ensures that we only have to insert one reload, thus not increasing; // code size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:29,avail,available,29,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['avail'],['available']
Availability,"// Okay, there was no semicolon and one was expected. If we see a; // declaration specifier, just assume it was missing and continue parsing.; // Otherwise things are very confused and we skip to recover.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:196,recover,recover,196,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['recover'],['recover']
Availability,"// Okay, this isn't something we can CSE at all. Check to see if it is; // something that could modify memory. If so, our available memory values; // cannot be used so bump the generation count.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:122,avail,available,122,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,1,['avail'],['available']
Availability,"// Okay, we can do this! Replace the 'St' store with a store of IVal that is; // shifted by ByteShift and truncated down to NumBytes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:116,down,down,116,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['down'],['down']
Availability,"// Okay, we decided that we can add ScaleReg+Scale to AddrMode. Check now; // to see if ScaleReg is actually X+C. If so, we can turn this into adding; // X*Scale + C*Scale to addr mode. If we found available IV increment, do not; // go any further: we can reuse it and cannot eliminate it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:198,avail,available,198,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['avail'],['available']
Availability,"// Okay, we found a ']' or '}' or ')', which we think should be balanced.; // Since the user wasn't looking for this token (if they were, it would; // already be handled), this isn't balanced. If there is a LHS token at a; // higher level, we will assume that this matches the unbalanced token; // and return it. Otherwise, this is a spurious RHS token, which we; // consume and pass on to downstream code to diagnose.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:390,down,downstream,390,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,1,['down'],['downstream']
Availability,"// Okay, we found a single predecessor that is available, but not scheduled.; // Since it is available, it must be in the priority queue. First remove it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:47,avail,available,47,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,4,['avail'],['available']
Availability,"// Okay, we have *some* definitions of the value. This means that the value; // is available in some of our (transitive) predecessors. Lets think about; // doing PRE of this load. This will involve inserting a new load into the; // predecessor when it's not available. We could do this in general, but; // prefer to not increase code size. As such, we only do this when we know; // that we only have to insert *one* load (which means we're basically moving; // the load, not inserting a new one).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:83,avail,available,83,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,2,['avail'],['available']
Availability,"// Okay, we have encountered an unavailable block.; // Mark speculatively available blocks reachable from UnavailableBB as; // unavailable as well. Paths are terminated when they reach blocks not in; // FullyAvailableBlocks or they are not marked as speculatively available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:74,avail,available,74,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,2,['avail'],['available']
Availability,"// Okay, we know that the sign bit in Mask is set. Use CLO to determine; // the number of identical bits in the top of the input value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp:38,Mask,Mask,38,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,1,['Mask'],['Mask']
Availability,"// Okay, we're at the right return statement, but do we have the return; // value available?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:82,avail,available,82,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,1,['avail'],['available']
Availability,"// Okay: this is some kind of implicit downcast of Objective-C; // interfaces, which is permitted. However, we're going to; // complain about it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:39,down,downcast,39,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['down'],['downcast']
Availability,"// Old initialization for ALICE.; // Left as an example.; /*; // Check if REVESYS exists, try fallback to $ALICE_ROOT/EVE.; if(gSystem->Getenv(""REVESYS"") == 0) {; if(gSystem->Getenv(""ALICE_ROOT"") != 0) {; Info(eh.Data(), ""setting REVESYS from ALICE_ROOT."");; gSystem->Setenv(""REVESYS"", Form(""%s/EVE"", gSystem->Getenv(""ALICE_ROOT"")));; } else {; Error(eh.Data(), ""REVESYS not defined, neither is ALICE_ROOT."");; gSystem->Exit(1);; }; }; if(gSystem->AccessPathName(gSystem->Getenv(""REVESYS"")) == kTRUE) {; Error(eh.Data(), ""REVESYS '%s' does not exist."", gSystem->Getenv(""REVESYS""));; gSystem->Exit(1);; }. TString macPath(gROOT->GetMacroPath());; macPath += Form("":%s/macros"", gSystem->Getenv(""REVESYS""));; gInterpreter->AddIncludePath(gSystem->Getenv(""REVESYS""));; if(gSystem->Getenv(""ALICE_ROOT"") != 0) {; macPath += Form("":%s/alice-macros"", gSystem->Getenv(""REVESYS""));; gInterpreter->AddIncludePath(Form(""%s/include"", gSystem->Getenv(""ALICE_ROOT"")));; gInterpreter->AddIncludePath(gSystem->Getenv(""ALICE_ROOT""));; }; gROOT->SetMacroPath(macPath);; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveUtil.cxx:345,Error,Error,345,graf3d/eve/src/TEveUtil.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveUtil.cxx,2,['Error'],['Error']
Availability,"// OldIdxIn and OldIdxVNI are now undef and can be overridden.; // We Slide [NewIdxIn, OldIdxIn) down one position.; // |- X0/NewIdxIn -| ... |- Xn-1 -||- Xn/OldIdxIn -||- OldIdxOut -|; // => |- undef/NexIdxIn -| |- X0 -| ... |- Xn-1 -| |- Xn/OldIdxOut -|",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:97,down,down,97,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,1,['down'],['down']
Availability,"// OldIdxVNI is a dead def that has been moved into the middle of; // another value in LR. That can happen when LR is a whole register,; // but the dead def is a write to a subreg that is dead at NewIdx.; // The dead def may have been moved across other values; // in LR, so move OldIdxOut up to NewIdxOut. Slide [NewIdxOut;OldIdxOut); // down one position.; // |- X0/NewIdxOut -| ... |- Xn-1 -| |- Xn/OldIdxOut -| |- next - |; // => |- X0/NewIdxOut -| |- X0 -| ... |- Xn-1 -| |- next -|",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:339,down,down,339,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,1,['down'],['down']
Availability,"// OldIdxVNI is a dead def. It may have been moved across other values; // in LR, so move OldIdxOut up to NewIdxOut. Slide [NewIdxOut;OldIdxOut); // down one position.; // |- X0/NewIdxOut -| ... |- Xn-1 -| |- Xn/OldIdxOut -| |- next - |; // => |- undef/NewIdxOut -| |- X0 -| ... |- Xn-1 -| |- next -|",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:149,down,down,149,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,1,['down'],['down']
Availability,// Omit redundant decls.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTraverse.h:8,redundant,redundant,8,interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTraverse.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTraverse.h,1,['redundant'],['redundant']
Availability,"// On AVX/AVX2 the type v8i1 is legalized to v8i16, which is an XMM sized; // register. In most cases we actually compare or select YMM-sized registers; // and mixing the two types creates horrible code. This method optimizes; // some of the transition sequences.; // Even with AVX-512 this is still useful for removing casts around logical; // operations on vXi1 mask types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:364,mask,mask,364,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// On AVX512BW targets we make use of the fact that VSELECT lowers; // to a masked blend which selects bytes based just on the sign bit; // extracted to a mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:76,mask,masked,76,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['mask'],"['mask', 'masked']"
Availability,"// On Android 14 and newer, there is a special linker_hwasan64 that; // allows to run HWASan binaries on non-HWASan system images. This; // is also available on HWASan system images, so we can just always; // use that instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp:148,avail,available,148,interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp,1,['avail'],['available']
Availability,"// On COFF, it's important to reduce the alignment down to 1 to prevent the; // linker from inserting padding before the start of the names section or; // between names entries.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:51,down,down,51,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,1,['down'],['down']
Availability,"// On CPUs supporting Thumb2, this will be relaxed to an ldr.w, otherwise we; // could have an error on our hands.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAsmBackend.cpp:95,error,error,95,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAsmBackend.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAsmBackend.cpp,1,['error'],['error']
Availability,"// On GFX908, in order to guarantee copying between AGPRs, we need a scratch; // VGPR available at all times.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp:86,avail,available,86,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp,1,['avail'],['available']
Availability,"// On GFX908, in order to guarantee copying between AGPRs, we need a scratch; // VGPR available at all times. For now, reserve highest available VGPR. After; // RA, shift it to the lowest available unused VGPR if the one exist.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.cpp:86,avail,available,86,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.cpp,3,['avail'],['available']
Availability,"// On P9 but not on P10, if the op is misaligned then it will cause a; // pipeline flush. Otherwise the VSX masked memops cost the same as unmasked; // ones.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:108,mask,masked,108,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,1,['mask'],['masked']
Availability,"// On POSIX systems, this will atomically replace the destination if; // it already exists. We try to emulate this on Windows, but this may; // fail with a permission denied error (for example, if the destination; // is currently opened by another process that does not give us the; // sharing permissions we need). Since the existing file should be; // semantically equivalent to the one we are trying to write, we give; // AddBuffer a copy of the bytes we wrote in that case. We do this; // instead of just using the existing file, because the pruner might; // delete the file before we get a chance to use it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Caching.cpp:174,error,error,174,interpreter/llvm-project/llvm/lib/Support/Caching.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Caching.cpp,1,['error'],['error']
Availability,// On SSE41 targets we need to replicate the shift mask in both; // bytes for PBLENDVB.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:51,mask,mask,51,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// On Thumb, offsets==2 mod 4 are rounded down by the hardware for; // purposes of the displacement computation; compensate for that here.; // For unknown alignments, getMaxDisp() constrains the range instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp:42,down,down,42,interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp,1,['down'],['down']
Availability,"// On Windows we can fail to open a cache file with a permission denied; // error. This generally means that another process has requested to delete; // the file while it is still open, but it could also mean that another; // process has opened the file without the sharing permissions we need.; // Since the file is probably being deleted we handle it in the same way as; // if the file did not exist at all.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Caching.cpp:76,error,error,76,interpreter/llvm-project/llvm/lib/Support/Caching.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Caching.cpp,1,['error'],['error']
Availability,"// On Windows, the code is interpreted as NTSTATUS. The two high bits; // represent the severity. Values starting with 0x80000000 are reserved for; // ""warnings""; values of 0xC0000000 and up are for ""errors"". In practice, both; // are interpreted as a non-continuable signal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp:200,error,errors,200,interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp,1,['error'],['errors']
Availability,"// On Windows, vectors are passed directly if registers are available, or; // indirectly if not. This avoids the need to align argument memory. Pass; // user-defined vector types larger than 512 bits indirectly for simplicity.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp:60,avail,available,60,interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,1,['avail'],['available']
Availability,"// On XOP we'll lower to PCMOV so accept one use. With AVX512, we can use; // VPTERNLOG. Otherwise only do this if either mask has multiple uses already.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:122,mask,mask,122,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// On a failed lookup we have to try to more things before issuing an error.; // The symbol might need to be loaded by ROOT's AutoLoading mechanism or; // it might be a ROOT special object.; //; // Try those first and if still failing issue the diagnostics.; //; // returns true when a declaration is found and no error should be emitted.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx:70,error,error,70,core/metacling/src/TClingCallbacks.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx,2,['error'],['error']
Availability,"// On error, keep the preexisting buffer and print a diagnostic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:6,error,error,6,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,1,['error'],['error']
Availability,"// On error, recover by dropping the exception specification.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:6,error,error,6,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,2,"['error', 'recover']","['error', 'recover']"
Availability,"// On failure to transform, TransformRequiresTypeParams returns an expression; // in the event that the transformation of the type params failed in some way.; // It is expected that this will result in a 'not satisfied' Requires clause; // when instantiating.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:6,failure,failure,6,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['failure'],['failure']
Availability,"// On failure, cleanup dead nodes we may have created.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:6,failure,failure,6,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['failure'],['failure']
Availability,"// On gfx908, we had initially reserved highest available VGPR for AGPR; // copy. Now since we are done with RA, check if there exist an unused VGPR; // which is lower than the eariler reserved VGPR before RA. If one exist,; // use it for AGPR copy instead of one reserved before RA.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp:48,avail,available,48,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,1,['avail'],['available']
Availability,"// On little endian subtargets, combine shuffles such as:; // vector_shuffle<16,1,17,3,18,5,19,7,20,9,21,11,22,13,23,15>, <zero>, %b; // into:; // vector_shuffle<16,0,17,1,18,2,19,3,20,4,21,5,22,6,23,7>, <zero>, %b; // because the latter can be matched to a single instruction merge.; // Furthermore, SCALAR_TO_VECTOR on little endian always involves a permute; // to put the value into element zero. Adjust the shuffle mask so that the; // vector can remain in permuted form (to prevent a swap prior to a shuffle).; // On big endian targets, this is still useful for SCALAR_TO_VECTOR; // nodes with elements smaller than doubleword because all the ways; // of getting scalar data into a vector register put the value in the; // rightmost element of the left half of the vector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:420,mask,mask,420,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['mask'],['mask']
Availability,"// On mingw, global dtors should not call exit().; // report_fatal_error() invokes exit(). We know report_fatal_error(); // might not write messages to stderr when any errors were detected; // on FD == 2.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/raw_ostream.cpp:168,error,errors,168,interpreter/llvm-project/llvm/lib/Support/raw_ostream.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/raw_ostream.cpp,1,['error'],['errors']
Availability,"// On overflow, NextPowerOf2 returns zero with the type uint64_t, so; // subtracting 1 gives us the mask with all bits set, like we want.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitmaskEnum.h:100,mask,mask,100,interpreter/llvm-project/llvm/include/llvm/ADT/BitmaskEnum.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitmaskEnum.h,1,['mask'],['mask']
Availability,// On some architectures (GFX9) movrel is not available and it's better; // to expand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:46,avail,available,46,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['avail'],['available']
Availability,"// On testing with the data from the 250202_181_RECO.root and doing ""just"" serializing; // the value 8 was the sweet spot of performance. With more slots, too much time is; // spent scanning the array of ""last"" seen and with less slots then the; // serialization induced by and/or the cost of executed `++fSubTypesReaders is slow; // down (noticeably) the streaming of branches with polymorphic containers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TIsAProxy.h:334,down,down,334,core/meta/inc/TIsAProxy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TIsAProxy.h,1,['down'],['down']
Availability,"// On the RHS of [A], if Pos is the result of operation on Pos' that won't; // affect Mask's demanded bits, just replace Pos with Pos'. These operations; // are redundant for the purpose of the equality.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:86,Mask,Mask,86,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,"['Mask', 'redundant']","['Mask', 'redundant']"
Availability,"// On v6m cores, there are very few registers available. We can easily end up; // spilling and reloading more registers in an unrolled loop. Look at the; // number of LCSSA phis as a rough measure of how many registers will need to; // be live out of the loop, reducing the default unroll count if more than 1; // value is needed. In the long run, all of this should be being learnt by a; // machine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:46,avail,available,46,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,1,['avail'],['available']
Availability,"// Once all the live-ins don't change on mlocJoin(), we've eliminated all; // redundant PHIs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:78,redundant,redundant,78,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['redundant'],['redundant']
Availability,"// Once the bits are split out into bytes of UTF8, this is a mask OR-ed; // into the first byte, depending on how many bytes follow.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:61,mask,mask,61,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,1,['mask'],['mask']
Availability,"// Once we've found all of the instructions to add to instcombine's worklist,; // add them in reverse order. This way instcombine will visit from the top; // of the function down. This jives well with the way that it adds all uses; // of instructions to the worklist after doing a transformation, thus avoiding; // some N^2 behavior in pathological cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:174,down,down,174,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['down'],['down']
Availability,"// Once you get one type error in a function, it will likely trigger more; // which are mostly not helpful.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/AsmParser/WebAssemblyAsmTypeCheck.cpp:25,error,error,25,interpreter/llvm-project/llvm/lib/Target/WebAssembly/AsmParser/WebAssemblyAsmTypeCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/AsmParser/WebAssemblyAsmTypeCheck.cpp,1,['error'],['error']
Availability,// One 'vn' per dst vector with an immediate mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:45,mask,mask,45,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,1,['mask'],['mask']
Availability,"// One bin down in ListBoxB (non empty bins)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/histviewer/histaction.cxx:11,down,down,11,test/histviewer/histaction.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/histviewer/histaction.cxx,1,['down'],['down']
Availability,"// One histo down in ListBoxA",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/histviewer/histaction.cxx:13,down,down,13,test/histviewer/histaction.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/histviewer/histaction.cxx,1,['down'],['down']
Availability,"// One near miss was found, report it as the sole error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:50,error,error,50,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['error'],['error']
Availability,"// One of the operands of the writelane is also the output operand.; // This creates the insertion of redundant delays. Hence, we have to; // ignore this operand.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInsertDelayAlu.cpp:102,redundant,redundant,102,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInsertDelayAlu.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInsertDelayAlu.cpp,1,['redundant'],['redundant']
Availability,// One of these two variables will be referenced by a symbol defined in; // llvm-config.h. We provide a link-time (or load time for DSO) failure when; // there is a mismatch in the build configuration of the API client and LLVM.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ABIBreak.cpp:137,failure,failure,137,interpreter/llvm-project/llvm/lib/Support/ABIBreak.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ABIBreak.cpp,1,['failure'],['failure']
Availability,"// One or more occurrences required; // Indicates that this option is fed anything that follows the last positional; // argument required by the application (it is an error if there are zero; // positional arguments, and a ConsumeAfter option is used).; // Thus, for example, all arguments to LLI are processed until a filename is; // found. Once a filename is found, all of the succeeding arguments are; // passed, unprocessed, to the ConsumeAfter option.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h:167,error,error,167,interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h,1,['error'],['error']
Availability,"// One source operand, fix the mask to print all elements in one span.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86MCInstLower.cpp:31,mask,mask,31,interpreter/llvm-project/llvm/lib/Target/X86/X86MCInstLower.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86MCInstLower.cpp,1,['mask'],['mask']
Availability,"// One wrinkle here is that GCC expands __LINE__ to location of the *end* of; // a macro expansion. This doesn't matter for object-like macros, but; // can matter for a function-like macro that expands to contain __LINE__.; // Skip down through expansion points until we find a file loc for the; // end of the expansion history.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:232,down,down,232,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,1,['down'],['down']
Availability,"// Only 64 bit mapping is available in fprb and will be marked as custom, i.e.; // will be split into two 32 bit registers in gprb.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.cpp:26,avail,available,26,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.cpp,1,['avail'],['available']
Availability,// Only a BDV available,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:14,avail,available,14,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,1,['avail'],['available']
Availability,"// Only accept truncates for now. We would really like a nice recursive; // predicate like SimplifyDemandedBits, but which goes downwards the use-def; // chain to see which bits of a value are actually demanded. If the; // original add had another add which was then immediately truncated, we; // could still do the transformation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:128,down,downwards,128,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['down'],['downwards']
Availability,"// Only allow based lvalue casts if they are lossless.; // FIXME: Allow a larger integer size than the pointer size, and allow; // narrowing back down to pointer width in subsequent integral casts.; // FIXME: Check integer type's active bits, not its type size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:146,down,down,146,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['down'],['down']
Availability,// Only allow legal mask types.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:20,mask,mask,20,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// Only available in clang's trunk:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/MetaProcessor/MetaSema.cpp:8,avail,available,8,interpreter/cling/lib/MetaProcessor/MetaSema.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/MetaProcessor/MetaSema.cpp,1,['avail'],['available']
Availability,// Only available on 64-bit for now.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:8,avail,available,8,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,1,['avail'],['available']
Availability,"// Only bits set in Mask must be negated, other bits may be arbitrary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:20,Mask,Mask,20,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['Mask'],['Mask']
Availability,// Only check for dependence if there are resources available to; // schedule this instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h:52,avail,available,52,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h,1,['avail'],['available']
Availability,// Only check mask register overlaps.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp:14,mask,mask,14,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,1,['mask'],['mask']
Availability,// Only commute if the entire NOT mask is a hidden shifted mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:34,mask,mask,34,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,4,['mask'],['mask']
Availability,// Only custom-lower extensions from mask types,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:37,mask,mask,37,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['mask'],['mask']
Availability,"// Only diagnose out-of-line method definitions. If they are; // in class definitions, then an error will be generated when; // processing the class bodies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:95,error,error,95,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['error'],['error']
Availability,// Only emit BTF when debuginfo available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAsmPrinter.cpp:32,avail,available,32,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAsmPrinter.cpp,1,['avail'],['available']
Availability,// Only emit a shuffle if the mask is legal.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp:30,mask,mask,30,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,1,['mask'],['mask']
Availability,// Only emit an error if the value of 'maskedFlags' is properly; // constrained;,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp:16,error,error,16,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnixAPIChecker.cpp,2,"['error', 'mask']","['error', 'maskedFlags']"
Availability,// Only emit if compact unwind isn't available,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCTargetOptions.h:37,avail,available,37,interpreter/llvm-project/llvm/include/llvm/MC/MCTargetOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCTargetOptions.h,1,['avail'],['available']
Availability,// Only emit one error on the first const found. All other consts will emit; // a note to the error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:17,error,error,17,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,2,['error'],['error']
Availability,// Only enabled preserved access index region when debuginfo; // is available as debuginfo is needed to preserve user-level; // access pattern.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:68,avail,available,68,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,1,['avail'],['available']
Availability,// Only errors may be unrecoverable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:8,error,errors,8,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,1,['error'],['errors']
Availability,// Only expect to custom-lower truncations to mask types,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:46,mask,mask,46,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['mask'],['mask']
Availability,"// Only fail with assert above, otherwise ignore the parsing error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-opt-fuzzer/llvm-opt-fuzzer.cpp:61,error,error,61,interpreter/llvm-project/llvm/tools/llvm-opt-fuzzer/llvm-opt-fuzzer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-opt-fuzzer/llvm-opt-fuzzer.cpp,1,['error'],['error']
Availability,// Only go down the dominator tree.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp:11,down,down,11,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,1,['down'],['down']
Availability,"// Only in -g mode...; // Check to make sure that there are no uses of this value that are still; // around when the value is destroyed. If there are, then we have a dangling; // reference and something is wrong. This code is here to print out where; // the value is still being referenced.; //; // Note that use_empty() cannot be called here, as it eventually downcasts; // 'this' to GlobalValue (derived class of Value), but GlobalValue has already; // been destructed, so accessing it is UB.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp:361,down,downcasts,361,interpreter/llvm-project/llvm/lib/IR/Value.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp,1,['down'],['downcasts']
Availability,// Only include names that correspond to user variables. FIXME: We should use; // debug info if available to get the name of the user variable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DiagnosticInfo.cpp:96,avail,available,96,interpreter/llvm-project/llvm/lib/IR/DiagnosticInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DiagnosticInfo.cpp,1,['avail'],['available']
Availability,// Only issue the fixit if we're prepared to recover.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:45,recover,recover,45,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['recover'],['recover']
Availability,"// Only keep an S_WAIT_LOADCNT_DSCNT if both counters actually need; // to be waited for. Otherwise, let the instruction be deleted so; // the appropriate single counter wait instruction can be inserted; // instead, when new S_WAIT_*CNT instructions are inserted by; // createNewWaitcnt(). As a side effect, resetting the wait counts will; // cause any redundant S_WAIT_LOADCNT or S_WAIT_DSCNT to be removed by; // the loop below that deals with single counter instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp:353,redundant,redundant,353,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,1,['redundant'],['redundant']
Availability,"// Only need to place items backwards in LE,; // the mask was properly calculated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:53,mask,mask,53,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['mask'],['mask']
Availability,"// Only perform optimization if after legalize, and if NEON is available. We; // also expected both operands to be BUILD_VECTORs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:63,avail,available,63,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['avail'],['available']
Availability,// Only perform the checks after legalize when the pattern is available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:62,avail,available,62,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['avail'],['available']
Availability,// Only perform this blend if we can perform it without loading a mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:66,mask,mask,66,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// Only print node name with total number of errors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:45,error,errors,45,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,1,['error'],['errors']
Availability,// Only regular address / data registers are allowed to be used; // in register masks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp:80,mask,masks,80,interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp,1,['mask'],['masks']
Availability,// Only scheduling top-down.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:23,down,down,23,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,1,['down'],['down']
Availability,// Only show VR icon if WebVR API available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:34,avail,available,34,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['avail'],['available']
Availability,// Only show hint the first time an error occurs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profdata/llvm-profdata.cpp:36,error,error,36,interpreter/llvm-project/llvm/tools/llvm-profdata/llvm-profdata.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profdata/llvm-profdata.cpp,1,['error'],['error']
Availability,// Only show the first time an error occurs in this file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profdata/llvm-profdata.cpp:31,error,error,31,interpreter/llvm-project/llvm/tools/llvm-profdata/llvm-profdata.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profdata/llvm-profdata.cpp,1,['error'],['error']
Availability,"// Only sink 'and' mask to cmp use block if it is masking a single bit, since; // this is likely to be fold the and/cmp/br into a single tbz instruction. It; // may be beneficial to sink in other cases, but we would have to check that; // the cmp would not get folded into the br to form a cbz for these to be; // beneficial.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:19,mask,mask,19,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,2,['mask'],"['mask', 'masking']"
Availability,// Only skip inner END_CF if outer ENDCF belongs to SI_IF.; // If that belongs to SI_ELSE then saved mask has an inverted value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerControlFlow.cpp:101,mask,mask,101,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerControlFlow.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerControlFlow.cpp,1,['mask'],['mask']
Availability,// Only support mregparm=4 to support old usage. Report error for all other; // cases.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:56,error,error,56,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['error'],['error']
Availability,"// Only test the conditional argument of cmpxchg instruction.; // The other argument can potentially be uninitialized, but we can not; // detect this situation reliably without possible false positives.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:160,reliab,reliably,160,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,1,['reliab'],['reliably']
Availability,"// Only the fit with error recovery should have status zero.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testNaNPacker.cxx:21,error,error,21,roofit/roofitcore/test/testNaNPacker.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testNaNPacker.cxx,4,"['error', 'recover']","['error', 'recovery']"
Availability,// Only try to recover from lookup into dependent bases in static methods or; // contexts where 'this' is available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:15,recover,recover,15,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,2,"['avail', 'recover']","['available', 'recover']"
Availability,// Only valid in error state. Reversed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/JSON.h:17,error,error,17,interpreter/llvm-project/llvm/include/llvm/Support/JSON.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/JSON.h,1,['error'],['error']
Availability,"// Only warn for ""inline"" when compiling for host, to cut down on noise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:58,down,down,58,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,1,['down'],['down']
Availability,"// Only warn if the current inline range is not within any of all; // of the parent ranges. If we have a DW_TAG_subpgram with multiple; // ranges we will emit a FunctionInfo for each range of that; // function that only emits information within the current range,; // so we only want to emit an error if the DWARF has issues, not; // when a range currently just isn't in the range we are currently; // parsing for.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/DwarfTransformer.cpp:295,error,error,295,interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/DwarfTransformer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/DwarfTransformer.cpp,1,['error'],['error']
Availability,"// Ooops an error in the code",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/periodic/XSReactionDlg.cxx:12,error,error,12,test/periodic/XSReactionDlg.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/periodic/XSReactionDlg.cxx,1,['error'],['error']
Availability,"// Op represents live lanes after kill,; // so exec mask needs to be factored in.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp:52,mask,mask,52,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,1,['mask'],['mask']
Availability,// Op's second operand must be a shifted mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:41,mask,mask,41,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,2,['mask'],['mask']
Availability,"// Op(shuffle(V1, Mask), C) -> shuffle(Op(V1, NewC), Mask); // Op(C, shuffle(V1, Mask)) -> shuffle(Op(NewC, V1), Mask)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:18,Mask,Mask,18,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,4,['Mask'],['Mask']
Availability,"// Op(shuffle(V1, Mask), shuffle(V2, Mask)) -> shuffle(Op(V1, V2), Mask)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:18,Mask,Mask,18,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,3,['Mask'],['Mask']
Availability,// Open the input file and return an appropriate error if needed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/GsymReader.cpp:49,error,error,49,interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/GsymReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/GsymReader.cpp,1,['error'],['error']
Availability,"// OpenCL V1.1 6.2.6.p1:; // If the operands are of more than one vector type, then an error shall; // occur. Implicit conversions between vector types are not permitted, per; // section 6.2.1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:87,error,error,87,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['error'],['error']
Availability,// OpenCL v1.2 s6.9.f - The library functions defined in; // the C99 standard headers are not available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:94,avail,available,94,interpreter/llvm-project/clang/lib/AST/Decl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp,1,['avail'],['available']
Availability,"// OpenCL v2.0 s6.13.9 - Address space qualifier functions.; // Performs semantic analysis for the to_global/local/private call.; // \param S Reference to the semantic analyzer.; // \param BuiltinID ID of the builtin function.; // \param Call A pointer to the builtin call.; // \return True if a semantic error has been found, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:305,error,error,305,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['error'],['error']
Availability,"// OpenCL v2.0 s6.6 - read_write can be used for image types to specify that; // an image object can be read and written. OpenCL v2.0 s6.13.6 - A kernel; // cannot read from and write to the same pipe object. Using the read_write; // (or __read_write) qualifier with the pipe qualifier is a compilation error.; // OpenCL v3.0 s6.8 - For OpenCL C 2.0, or with the; // __opencl_c_read_write_images feature, image objects specified as arguments; // to a kernel can additionally be declared to be read-write.; // C++ for OpenCL 1.0 inherits rule from OpenCL C v2.0.; // C++ for OpenCL 2021 inherits rule from OpenCL C v3.0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:303,error,error,303,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,1,['error'],['error']
Availability,"// OpenMP 5.1 [2.22, Nesting of Regions]; // A loop region that binds to a parallel region or a worksharing region; // may not be closely nested inside a worksharing, loop, task, taskloop,; // critical, ordered, atomic, or masked region.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:223,mask,masked,223,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['mask'],['masked']
Availability,"// OpenMP 5.1 [2.22, Nesting of Regions]; // A masked region may not be closely nested inside a worksharing, loop,; // atomic, task, or taskloop region.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:47,mask,masked,47,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['mask'],['masked']
Availability,"// OpenMP 5.1 [2.22, Nesting of Regions]; // A scope region may not be closely nested inside a worksharing, loop,; // task, taskloop, critical, ordered, atomic, or masked region.; // OpenMP 5.1 [2.22, Nesting of Regions]; // A barrier region may not be closely nested inside a worksharing, loop,; // task, taskloop, critical, ordered, atomic, or masked region.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:164,mask,masked,164,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,2,['mask'],['masked']
Availability,"// OpenMP [2.14.3.1, Restrictions]; // Only a single default clause may be specified on a parallel, task or; // teams directive.; // OpenMP [2.5, parallel Construct, Restrictions]; // At most one proc_bind clause can appear on the directive.; // OpenMP [5.0, Requires directive, Restrictions]; // At most one atomic_default_mem_order clause can appear; // on the directive; // OpenMP [5.1, error directive, Restrictions]; // At most one at clause can appear on the directive; // At most one severity clause can appear on the directive; // OpenMP 5.1, 2.11.7 loop Construct, Restrictions.; // At most one bind clause can appear on a loop directive.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:390,error,error,390,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,1,['error'],['error']
Availability,"// OpenMP [2.5, Restrictions]; // At most one num_threads clause can appear on the directive.; // OpenMP [2.8.1, simd construct, Restrictions]; // Only one safelen clause can appear on a simd directive.; // Only one simdlen clause can appear on a simd directive.; // Only one collapse clause can appear on a simd directive.; // OpenMP [2.11.1, task Construct, Restrictions]; // At most one if clause can appear on the directive.; // At most one final clause can appear on the directive.; // OpenMP [teams Construct, Restrictions]; // At most one num_teams clause can appear on the directive.; // At most one thread_limit clause can appear on the directive.; // OpenMP [2.9.1, task Construct, Restrictions]; // At most one priority clause can appear on the directive.; // OpenMP [2.9.2, taskloop Construct, Restrictions]; // At most one grainsize clause can appear on the directive.; // OpenMP [2.9.2, taskloop Construct, Restrictions]; // At most one num_tasks clause can appear on the directive.; // OpenMP [2.11.3, allocate Directive, Restrictions]; // At most one allocator clause can appear on the directive.; // OpenMP 5.0, 2.10.1 task Construct, Restrictions.; // At most one detach clause can appear on the directive.; // OpenMP 5.1, 2.3.6 dispatch Construct, Restrictions.; // At most one novariants clause can appear on a dispatch directive.; // At most one nocontext clause can appear on a dispatch directive.; // OpenMP [5.1, error directive, Restrictions]; // At most one message clause can appear on the directive",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:1437,error,error,1437,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,1,['error'],['error']
Availability,"// OpenMP directives parsed in this section are represented as a; // CapturedStatement with an associated statement. If a syntax error; // is detected during the parsing of the associated statement, the; // compiler must abort processing and close the CapturedStatement.; //; // Combined directives such as 'target parallel' have more than one; // nested CapturedStatements. This RAII ensures that we unwind out; // of all the nested CapturedStatements when an error is found.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:129,error,error,129,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,2,['error'],['error']
Availability,// OpenMP offloading supports C++ constructors and destructors but we do not; // always have 'atexit' available. Instead lower these to use the LLVM global; // destructors which we can handle directly in the runtime. Note that this is; // not strictly 1-to-1 with using `atexit` because we no longer tear down; // globals in reverse order of when they were constructed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp:102,avail,available,102,interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,2,"['avail', 'down']","['available', 'down']"
Availability,"// Operand 1 is a register operand in the R/M field.; // - In AVX512 there may be a mask operand here -; // Operand 2 is a register operand in the Reg/Opcode field.; // - In AVX, there is a register operand in the VEX.vvvv field here -; // Operand 3 (optional) is an immediate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/X86RecognizableInstr.cpp:84,mask,mask,84,interpreter/llvm-project/llvm/utils/TableGen/X86RecognizableInstr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/X86RecognizableInstr.cpp,1,['mask'],['mask']
Availability,"// Operand should start from # or should be integer, emit error otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp:58,error,error,58,interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp,1,['error'],['error']
Availability,// Operations below are different for between masks and other vectors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:46,mask,masks,46,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['mask'],['masks']
Availability,// OptBBClobberedRegs is used when optimizing away redundant copies/moves.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64RedundantCopyElimination.cpp:51,redundant,redundant,51,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64RedundantCopyElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64RedundantCopyElimination.cpp,1,['redundant'],['redundant']
Availability,"// Optimistically suppress uninitialized value bugs that result; // from system headers having a chance to initialize the value; // but failing to do so. It's too unlikely a system header's fault.; // It's much more likely a situation in which the function has a failure; // mode that the user decided not to check. If we want to hunt such; // omitted checks, we should provide an explicit function-specific note; // describing the precondition under which the function isn't supposed to; // initialize its out-parameter, and additionally check that such; // precondition can actually be fulfilled on the current path.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:190,fault,fault,190,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,2,"['failure', 'fault']","['failure', 'fault']"
Availability,"// Optimization experiments.; // The experiments can be used to evaluate potential optimizations that remove; // instrumentation (assess false negatives). Instead of completely removing; // some instrumentation, you set Exp to a non-zero value (mask of optimization; // experiments that want to remove instrumentation of this instruction).; // If Exp is non-zero, this pass will emit special calls into runtime; // (e.g. __asan_report_exp_load1 instead of __asan_report_load1). These calls; // make runtime terminate the program in a special way (with a different; // exit status). Then you run the new compiler on a buggy corpus, collect; // the special terminations (ideally, you don't see them at all -- no false; // negatives) and make the decision on the optimization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:245,mask,mask,245,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,1,['mask'],['mask']
Availability,// Optimization failures are always handled completely by this; // handler.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenAction.cpp:16,failure,failures,16,interpreter/llvm-project/clang/lib/CodeGen/CodeGenAction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenAction.cpp,1,['failure'],['failures']
Availability,"// Optimize (srl (and X, C2), C) ->; // (srli (slli X, (XLen-C3), (XLen-C3) + C); // Where C2 is a mask with C3 trailing ones.; // Taking into account that the C2 may have had lower bits unset by; // SimplifyDemandedBits. This avoids materializing the C2 immediate.; // This pattern occurs when type legalizing right shifts for types with; // less than XLen bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:99,mask,mask,99,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,// Optimize away GET_CCMASK (SELECT_CCMASK) if the CC masks are compatible,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:54,mask,masks,54,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['mask'],['masks']
Availability,// Optimize away the now-redundant range checks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:25,redundant,redundant,25,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,1,['redundant'],['redundant']
Availability,"// Optimize empty collections by referencing constants, when available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:61,avail,available,61,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['avail'],['available']
Availability,// Optimize if the transformation consists of one step only: Set mask to; // 0xffffffff (including some irrelevant invalid bits) so that it should; // merge with more entries later while compressing the table.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp:65,mask,mask,65,interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp,1,['mask'],['mask']
Availability,"// Optimize masked RVV pseudo instructions with a known all-ones mask to their; // corresponding ""unmasked"" pseudo versions. The mask we're interested in will; // take the form of a V0 physical register operand, with a glued; // register-setting instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:12,mask,masked,12,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,3,['mask'],"['mask', 'masked']"
Availability,"// Optimize vectors in AVX mode; // Sign extend v8i16 to v8i32 and; // v4i32 to v4i64; //; // Divide input vector into two parts; // for v4i32 the high shuffle mask will be {2, 3, -1, -1}; // use vpmovsx instruction to extend v4i32 -> v2i64; v8i16 -> v4i32; // concat the vectors to original VT",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:160,mask,mask,160,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// Optimize; // 1) (icmp eq/ne (and X, C0), (shift X, C1)); // or; // 2) (icmp eq/ne X, (rotate X, C1)); // If C0 is a mask or shifted mask and the shift amt (C1) isolates the; // remaining bits (i.e something like `(x64 & UINT32_MAX) == (x64 >> 32)`); // Then:; // If C1 is a power of 2, then the rotate and shift+and versions are; // equivilent, so we can interchange them depending on target preference.; // Otherwise, if we have the shift+and version we can interchange srl/shl; // which inturn affects the constant C0. We can use this to get better; // constants again determined by target preference.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:119,mask,mask,119,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['mask'],['mask']
Availability,"// Optimized with two rldicl's as follows:; // Add missing bits on left to the mask and check that the mask is a; // wrapped run of ones, i.e.; // Change pattern |0001111100000011111111|; // to |1111111100000011111111|.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:79,mask,mask,79,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,2,['mask'],['mask']
Availability,// Option starts to be available in this OpenCL version,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/OpenCLOptions.h:23,avail,available,23,interpreter/llvm-project/clang/include/clang/Basic/OpenCLOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/OpenCLOptions.h,1,['avail'],['available']
Availability,"// Optionally, we are shuffling the loaded vector element(s) into place.; // For the mask set everything but element 0 to undef to prevent poison from; // propagating from the extra loaded memory. This will also optionally; // shrink/grow the vector from the loaded size to the output size.; // We assume this operation has no cost in codegen if there was no offset.; // Note that we could use freeze to avoid poison problems, but then we might; // still need a shuffle to change the vector size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:85,mask,mask,85,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,1,['mask'],['mask']
Availability,"// Or should throw exception/print error ?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TFormLeafInfo.cxx:35,error,error,35,tree/treeplayer/src/TFormLeafInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TFormLeafInfo.cxx,1,['error'],['error']
Availability,"// Or we are looking for a shift of an and, with a mask operand",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp:51,mask,mask,51,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,"// OrOpd0 = AND Src, #Mask; // So BFM simplifies away one AND node from Src and doesn't simplify away; // nodes from Dst. If ORR with left-shifted operand also simplifies away; // one node (from Rd), ORR is better since it has higher throughput and; // smaller latency than BFM on many AArch64 processors (and for the rest; // ORR is at least as good as BFM).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:22,Mask,Mask,22,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,1,['Mask'],['Mask']
Availability,// Order by argument attributes.; // This is reliable because each side is already sorted internally.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/IntrinsicEmitter.cpp:45,reliab,reliable,45,interpreter/llvm-project/llvm/utils/TableGen/IntrinsicEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/IntrinsicEmitter.cpp,1,['reliab'],['reliable']
Availability,"// OrderOld == OrderNew, we need to iterate down from Old to see if it; // can reach New, if yes, New is dominated by Old.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeShrink.cpp:44,down,down,44,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeShrink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeShrink.cpp,1,['down'],['down']
Availability,"// Ordinary function, not a template specialization.; // Note: This might be ok, the body might be defined; // in a library, and all we have seen is the; // header file.; //::Error(""TClingCallFunc::make_wrapper"",; // ""Cannot make wrapper for a function which is ""; // ""declared but not defined!"");; // return 0;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallFunc.cxx:175,Error,Error,175,core/metacling/src/TClingCallFunc.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallFunc.cxx,1,['Error'],['Error']
Availability,"// Originally, the function will scan all the stack objects to check whether; // if there is any scalable vector object on the stack or not. However, it; // causes errors in the register allocator. In issue 53016, it returns false; // before RA because there is no RVV stack objects. After RA, it returns true; // because there are spilling slots for RVV values during RA. It will not; // reserve BP during register allocation and generate BP access in the PEI; // pass due to the inconsistent behavior of the function.; //; // The function is changed to use hasVInstructions() as the return value. It; // is not precise, but it can make the register allocation correct.; //; // FIXME: Find a better way to make the decision or revisit the solution in; // D103622.; //; // Refer to https://github.com/llvm/llvm-project/issues/53016.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:164,error,errors,164,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,1,['error'],['errors']
Availability,"// Other regions (mostly non-data) can't have a reliable C string length.; // For now, just ignore the change.; // FIXME: These are rare but not impossible. We should output some kind of; // warning for things like strcpy((char[]){'a', 0}, ""b"");",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:48,reliab,reliable,48,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,1,['reliab'],['reliable']
Availability,"// Other regions (mostly non-data) can't have a reliable C string length.; // In this case, an error is emitted and UndefinedVal is returned.; // The caller should always be prepared to handle this case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:48,reliab,reliable,48,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,2,"['error', 'reliab']","['error', 'reliable']"
Availability,"// Otherwise Calculate poisson errors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooTreeDataStore.cxx:31,error,errors,31,roofit/roofitcore/src/RooTreeDataStore.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooTreeDataStore.cxx,2,['error'],['errors']
Availability,"// Otherwise block in-mask is all-one, no need to AND.; // The condition is 'SrcMask && EdgeMask', which is equivalent to; // 'select i1 SrcMask, i1 EdgeMask, i1 false'.; // The select version does not introduce new UB if SrcMask is false and; // EdgeMask is poison. Using 'and' here introduces undefined behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:22,mask,mask,22,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['mask'],['mask']
Availability,// Otherwise emit an appropriate error message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp:33,error,error,33,interpreter/llvm-project/llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp,1,['error'],['error']
Availability,"// Otherwise form a 128-bit permutation. After accounting for undefs,; // convert the 64-bit shuffle mask selection values into 128-bit; // selection bits by dividing the indexes by 2 and shifting into positions; // defined by a vperm2*128 instruction's immediate control byte.; // The immediate permute control byte looks like this:; // [1:0] - select 128 bits from sources for low half of destination; // [2] - ignore; // [3] - zero low half of destination; // [5:4] - select 128 bits from sources for high half of destination; // [6] - ignore; // [7] - zero high half of destination",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:101,mask,mask,101,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Otherwise it's a non-recoverable error. Note it and quit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/raw_ostream.cpp:24,recover,recoverable,24,interpreter/llvm-project/llvm/lib/Support/raw_ostream.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/raw_ostream.cpp,2,"['error', 'recover']","['error', 'recoverable']"
Availability,"// Otherwise load an immediate into a GPR, cast to k-register, and use a; // masked move.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:77,mask,masked,77,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['masked']
Availability,// Otherwise mask the shift value to get proper semantics from 32-bit shift,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:13,mask,mask,13,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,1,['mask'],['mask']
Availability,// Otherwise recover by skipping to next semi or mandatory function body.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:13,recover,recover,13,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp,1,['recover'],['recover']
Availability,// Otherwise strip off redundant namespace qualifications from the new name.; // We use the fully qualified name of the namespace and remove that part; // from NewName if it has an identical prefix.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Lookup.cpp:23,redundant,redundant,23,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Lookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Lookup.cpp,1,['redundant'],['redundant']
Availability,"// Otherwise the pointer is smaller than the resultant integer, mask off; // the high bits so we are sure to get a proper truncation if the input is; // a constant expr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:64,mask,mask,64,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,1,['mask'],['mask']
Availability,"// Otherwise use; // vmslt{u}.vx vd, va, x, v0.t; vmxor.mm vd, vd, v0; // The result is mask undisturbed.; // We use the same instructions to emulate mask agnostic behavior, because; // the agnostic result can be either undisturbed or all 1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:88,mask,mask,88,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,2,['mask'],['mask']
Availability,"// Otherwise we can only distribute by constant shifting the mask, so; // ensure we have constants.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:61,mask,mask,61,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['mask'],['mask']
Availability,"// Otherwise we can't infer whether the value is sufficiently aligned.; // TODO: __builtin_is_aligned(__builtin_align_{down,up{(expr, N), N); // in cases where we can't fully evaluate the pointer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:119,down,down,119,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['down'],['down']
Availability,// Otherwise we either have an upwards exposed use vreg that we need to; // materialize or need to forward the downward def from predecessors.; // Check whether we have a single vreg def from all predecessors.; // Otherwise we need a phi.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp:111,down,downward,111,interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp,1,['down'],['downward']
Availability,// Otherwise we have a call. We need to handle transferring the predicate; // state into a call and recovering it after the call returns (unless this; // is a tail call).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:100,recover,recovering,100,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,1,['recover'],['recovering']
Availability,"// Otherwise we have to see if a casted version of the incoming pointer; // is available. If so, we can use it, otherwise we have to fail.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp:79,avail,available,79,interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,1,['avail'],['available']
Availability,// Otherwise we need BFI to be available and to have a locally hot callsite; // threshold.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:31,avail,available,31,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,1,['avail'],['available']
Availability,// Otherwise we need BFI to be available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:31,avail,available,31,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,1,['avail'],['available']
Availability,"// Otherwise, SETCC for the given comparison type must be completely; // illegal; expand it into a SELECT_CC.; // FIXME: This drops the mask/evl for VP_SETCC.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp:136,mask,mask,136,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,1,['mask'],['mask']
Availability,"// Otherwise, break down all the fields for comparison. Hopefully these; // little Constants are reused, while a big null struct might not be.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp:20,down,down,20,interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp,1,['down'],['down']
Availability,"// Otherwise, break this down into LIS + Disp.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:25,down,down,25,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['down'],['down']
Availability,"// Otherwise, break this down into an LIS + disp.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:25,down,down,25,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['down'],['down']
Availability,"// Otherwise, emit the error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:23,error,error,23,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,1,['error'],['error']
Availability,"// Otherwise, expand A towards B to produce a range of size MaxRange. We; // attempt to expand by the same amount in both directions if B strictly; // contains A.; // Expand downwards by up to half the available amount, then upwards as; // much as possible, then downwards as much as possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp:174,down,downwards,174,interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp,3,"['avail', 'down']","['available', 'downwards']"
Availability,"// Otherwise, if the instruction has no ""Length"" field, parse the; // token as a ""Register"". We don't have to worry about whether the; // instruction is invalid here, because the caller will take care of; // error reporting.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp:208,error,error,208,interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp,1,['error'],['error']
Availability,"// Otherwise, if we don't consume this token, we are going to emit an; // error anyway. Try to recover from various common problems. Check; // to see if this was a reference to a tag name without a tag specified.; // This is a common problem in C (saying 'foo' instead of 'struct foo').; //; // C++ doesn't need this, and isTagName doesn't take SS.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:74,error,error,74,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,2,"['error', 'recover']","['error', 'recover']"
Availability,"// Otherwise, it's an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:22,error,error,22,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,3,['error'],['error']
Availability,"// Otherwise, just remember that this value is available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:47,avail,available,47,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,1,['avail'],['available']
Availability,"// Otherwise, look for the closest available option to report to the user; // in the upcoming error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CommandLine.cpp:35,avail,available,35,interpreter/llvm-project/llvm/lib/Support/CommandLine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CommandLine.cpp,2,"['avail', 'error']","['available', 'error']"
Availability,"// Otherwise, need mask that meets the below requirement.; // (logic_shift (inv_logic_shift Mask, ShAmt), ShAmt) == Mask",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:19,mask,mask,19,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,3,"['Mask', 'mask']","['Mask', 'mask']"
Availability,"// Otherwise, pass it down.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:22,down,down,22,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,1,['down'],['down']
Availability,"// Otherwise, remember that the register will be available to; // save a pop-friendly register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp:49,avail,available,49,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp,1,['avail'],['available']
Availability,"// Otherwise, remove result files and print extra information about abnormal; // failures.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:81,failure,failures,81,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['failure'],['failures']
Availability,"// Otherwise, return an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:24,error,error,24,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,2,['error'],['error']
Availability,"// Otherwise, see if we have this add available somewhere.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp:38,avail,available,38,interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,1,['avail'],['available']
Availability,"// Otherwise, the action had no suggestion for us. Mark this as an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:67,error,error,67,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['error'],['error']
Availability,"// Otherwise, the block was previously analyzed with a different; // pointer. We can't represent the result of this case, so we just; // treat this as a phi translation failure.; // Make sure to clean up the Visited map before continuing on to; // PredTranslationFailure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:169,failure,failure,169,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['failure'],['failure']
Availability,"// Otherwise, the match failed, try to produce a decent error message.; // If we had multiple suffix matches, then identify this as an ambiguous; // match.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp:56,error,error,56,interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,1,['error'],['error']
Availability,"// Otherwise, the value is available in the v0.sub0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:27,avail,available,27,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,1,['avail'],['available']
Availability,"// Otherwise, this is an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGLexer.cpp:25,error,error,25,interpreter/llvm-project/llvm/lib/TableGen/TGLexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGLexer.cpp,1,['error'],['error']
Availability,"// Otherwise, this is an interior node. Send the request down the tree.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp:57,down,down,57,interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp,1,['down'],['down']
Availability,"// Otherwise, this is just a flat-out error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:38,error,error,38,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['error'],['error']
Availability,"// Otherwise, traverse down the tree. The selected subtree may be; // partially included in the range.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp:23,down,down,23,interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp,1,['down'],['down']
Availability,"// Otherwise, use generic code to load one byte and test the bit. Use all but; // the bottom three bits as the array index, and the bottom three bits to form; // a mask.; // Bit = BitBaseI8[BitPos >> 3] & (1 << (BitPos & 0x7)) != 0;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:164,mask,mask,164,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,1,['mask'],['mask']
Availability,"// Otherwise, we are done a tolerances are set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/FileUtilities.cpp:28,toler,tolerances,28,interpreter/llvm-project/llvm/lib/Support/FileUtilities.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/FileUtilities.cpp,1,['toler'],['tolerances']
Availability,"// Otherwise, we can use any block as long as it has a scratch register; // available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp:76,avail,available,76,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,1,['avail'],['available']
Availability,"// Otherwise, we do need a PHI: check to see if we already have one available; // in this block that produces the right value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:68,avail,available,68,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,1,['avail'],['available']
Availability,"// Otherwise, we found *something*, but didn't get a ')' in the right; // place. Emit an error then return what we have as the type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:89,error,error,89,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,1,['error'],['error']
Availability,"// Otherwise, we have an error case. If we don't want diagnostics, just; // return an error now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:25,error,error,25,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,2,['error'],['error']
Availability,"// Otherwise, we have no instructions to issue and we have instructions; // that will fault if we don't do this right. This is the case for; // processors without pipeline interlocks and other cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:86,fault,fault,86,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,2,['fault'],['fault']
Availability,"// Otherwise, we have something. Add it and let semantic analysis try; // to grok it and add the result to the ParamInfo we are building.; // Last chance to recover from a misplaced ellipsis in an attempted; // parameter pack declaration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:157,recover,recover,157,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['recover'],['recover']
Availability,"// Otherwise, we have the case where the location could either be; // null or not-null. Record the error node as an ""implicit"" null; // dereference.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp:99,error,error,99,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp,1,['error'],['error']
Availability,"// Otherwise, we have to be the only successor. We generally expect this; // to be true as conditional branches should have had a critical edge; // split already. We don't however need to worry about EH pad successors; // as they'll happily ignore the target and their hardening strategy is; // resilient to all ways in which they could be reached speculatively.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:295,resilien,resilient,295,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,1,['resilien'],['resilient']
Availability,"// Otherwise, we need to reduce the AvailableOut set by things which are no; // longer in our AvailableIn",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:36,Avail,AvailableOut,36,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,2,['Avail'],"['AvailableIn', 'AvailableOut']"
Availability,"// Otherwise, we need to search down through the CFG.; // For each of our successors, handle it directly if their is a phi, or; // place on the fixup worklist.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:32,down,down,32,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,1,['down'],['down']
Availability,"// Otherwise, we should look at all the successors and decide which one; // we should sink to. If we have reliable block frequency information; // (frequency != 0) available, give successors with smaller frequencies; // higher priority, otherwise prioritize smaller cycle depths.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:106,reliab,reliable,106,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,2,"['avail', 'reliab']","['available', 'reliable']"
Availability,"// Otherwise, we want to set the diagnostic mapping's ""no Werror"" bit, and; // potentially downgrade anything already mapped to be a warning.; // Get the diagnostics in this group.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp:91,down,downgrade,91,interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp,1,['down'],['downgrade']
Availability,"// Otherwise, we want to set the diagnostic mapping's ""no Wfatal-errors"" bit,; // and potentially downgrade anything already mapped to be a fatal error.; // Get the diagnostics in this group.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp:65,error,errors,65,interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp,3,"['down', 'error']","['downgrade', 'error', 'errors']"
Availability,"// Otherwise, we've got some expression that is more complex than just a; // single SCEVUnknown. But we don't want to have a SCEVPtrToIntExpr of an; // arbitrary expression, we want to have SCEVPtrToIntExpr of an SCEVUnknown; // only, and the expressions must otherwise be integer-typed.; // So sink the cast down to the SCEVUnknown's.; /// The SCEVPtrToIntSinkingRewriter takes a scalar evolution expression,; /// which computes a pointer-typed value, and rewrites the whole expression; /// tree so that *all* the computations are done on integers, and the only; /// pointer-typed operands in the expression are SCEVUnknown.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:309,down,down,309,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['down'],['down']
Availability,"// Our error handler depends on the Diagnostics object, which we're; // potentially about to delete. Uninstall the handler now so that any; // later errors use the default handling behavior instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp:7,error,error,7,interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp,4,['error'],"['error', 'errors']"
Availability,"// Our error recovery purges the cache of the FileEntry, but keeps; // the FileEntry's pointer so that if it was used by smb (like the; // SourceManager) it wouldn't be dangling. In that case we shouldn't; // print the FileName, because semantically it is not there.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ClangInternalState.cpp:7,error,error,7,interpreter/cling/lib/Interpreter/ClangInternalState.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ClangInternalState.cpp,2,"['error', 'recover']","['error', 'recovery']"
Availability,// Our vregsRequired should be identical to LiveVariables' AliveBlocks,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:59,Alive,AliveBlocks,59,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,1,['Alive'],['AliveBlocks']
Availability,"// Outlined helpers called by the EH runtime need to know the offset of the EH; // registration in order to recover the parent frame pointer. Now that we know; // we've code generated the parent, we can emit the label assignment that; // those helpers use to get the offset of the registration node.; // Compute the parent frame offset. The EHRegNodeFrameIndex will be invalid if; // after optimization all the invokes were eliminated. We still need to emit; // the parent frame offset label, but it should be garbage and should never be; // used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp:108,recover,recover,108,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,1,['recover'],['recover']
Availability,// Output elements are undefined if the element from both sources are.; // TODO: can strengthen via mask as well.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:100,mask,mask,100,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,1,['mask'],['mask']
Availability,"// Output name, if available...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp:19,avail,available,19,interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,1,['avail'],['available']
Availability,"// Output units DeDw is just the error for these cases:; // - linear output, with sum-of-squares error; // - sigmoid output, with binary cross-entropy; // - softmax output, with 1-of-c cross entropy",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mlp/src/TNeuron.cxx:33,error,error,33,math/mlp/src/TNeuron.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mlp/src/TNeuron.cxx,2,['error'],['error']
Availability,"// Outside C++11, do not interpret the tokens as an enum-base if they do; // not make sense as one. In C++11, it's an error if this happens.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:118,error,error,118,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['error'],['error']
Availability,// Over-wide bitfields are an error in C or when using the MSVC bitfield; // ABI.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:30,error,error,30,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['error'],['error']
Availability,"// Overflow is always an error, but underflow is only an error if; // we underflowed to zero (APFloat reports denormals as underflow).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:25,error,error,25,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,2,['error'],['error']
Availability,"// Overload resolution failed, try to recover.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:38,recover,recover,38,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['recover'],['recover']
Availability,"// Overload resolution fails, try to recover.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:37,recover,recover,37,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['recover'],['recover']
Availability,"// Override test value tolerance; // A larger tolerance is needed since the values in the Cousins paper are given with 1e-2 precision",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/test/stressRooStats_tests.h:23,toler,tolerance,23,roofit/roostats/test/stressRooStats_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/test/stressRooStats_tests.h,4,['toler'],['tolerance']
Availability,// Overriden by subclasses to handle the value passed into an argument. Should; // return true if there was an error processing the argument and the program; // should exit.; //,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h:111,error,error,111,interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h,1,['error'],['error']
Availability,// Overrides the selection strategy for the processor resource with the given; // mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h:82,mask,mask,82,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,1,['mask'],['mask']
Availability,// Overwrite our input TemplateArgumentLoc so that we can recover; // properly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:58,recover,recover,58,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['recover'],['recover']
Availability,"// P l o t a n d f i t a R o o D a t a H i s t w i t h i n t e r n a l e r r o r s; // ---------------------------------------------------------------------------------------------; // If histogram has custom error (i.e. its contents is does not originate from a Poisson process; // but e.g. is a sum of weighted events) you can data with symmetric 'sum-of-weights' error instead; // (same error bars as shown by ROOT)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h:209,error,error,209,roofit/roofitcore/test/stressRooFit_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h,3,['error'],['error']
Availability,"// P l o t a n d f i t a R o o D a t a H i s t; // ---------------------------------------------------; // Make plot of binned dataset showing Poisson error bars (RooFit default)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h:151,error,error,151,roofit/roofitcore/test/stressRooFit_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h,1,['error'],['error']
Availability,"// PB: these mutables signal a suboptimal design. A separate error handling; // object containing all this would clean up this class. It would allow const; // functions to be actually const (even though state still changes in the; // error handling object).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsMinimizerFcn.h:61,error,error,61,roofit/roofitcore/src/RooAbsMinimizerFcn.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsMinimizerFcn.h,2,['error'],['error']
Availability,// PBLENDVB is only available on SSE 4.1.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:20,avail,available,20,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avail'],['available']
Availability,"// PC-Relative instructions are not available pre-Power10,; // and these instructions also require prefixed instructions support.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp:36,avail,available,36,interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp,1,['avail'],['available']
Availability,"// PHMINPOSUW applies to UMIN(v8i16), for SMIN/SMAX/UMAX we must apply a mask; // to flip the value accordingly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:73,mask,mask,73,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// PPC always uses a direct mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:28,mask,mask,28,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['mask'],['mask']
Availability,"// PR35338; // TODO: assert(From != To && ""Redundant dbg value transfer"");; // TODO: assert(FromNode != ToNode && ""Intranode dbg value transfer"");",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:43,Redundant,Redundant,43,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['Redundant'],['Redundant']
Availability,"// PR9614. Avoid cases where the source code is lying to us. An available; // externally function should have an equivalent function somewhere else,; // but a function that calls itself through asm label/`__builtin_` trickery is; // clearly not equivalent to the real implementation.; // This happens in glibc's btowc and in some configure checks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp:64,avail,available,64,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,1,['avail'],['available']
Availability,"// PROOF session must available",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:22,avail,available,22,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['avail'],['available']
Availability,"// Package loading failure",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TPackMgr.cxx:19,failure,failure,19,proof/proof/src/TPackMgr.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TPackMgr.cxx,1,['failure'],['failure']
Availability,"// Packed field, see XR_* masks for details of packing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/XCOFFObjectFile.h:26,mask,masks,26,interpreter/llvm-project/llvm/include/llvm/Object/XCOFFObjectFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/XCOFFObjectFile.h,1,['mask'],['masks']
Availability,// Pad both vectors with undefs to make them the same length as the mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:68,mask,mask,68,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['mask'],['mask']
Availability,"// Pads the inverse direction according to T. Ize's ""Robust BVH ray traversal""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/bvh/v2/ray.h:53,Robust,Robust,53,geom/geom/inc/bvh/v2/ray.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/bvh/v2/ray.h,1,['Robust'],['Robust']
Availability,"// Page got larger, we may need to make space available",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorage.cxx:46,avail,available,46,tree/ntuple/v7/src/RPageStorage.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorage.cxx,1,['avail'],['available']
Availability,"// Paint the Errors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:13,Error,Errors,13,hist/histpainter/src/THistPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx,1,['Error'],['Errors']
Availability,// Paired vector memops are not available pre-Power10.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp:32,avail,available,32,interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp,1,['avail'],['available']
Availability,"// Parallel for-each, but with error handling.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Parallel.h:31,error,error,31,interpreter/llvm-project/llvm/include/llvm/Support/Parallel.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Parallel.h,1,['error'],['error']
Availability,"// Parallel zip not available, but pages are still vector-commited",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_storage.cxx:20,avail,available,20,tree/ntuple/v7/test/ntuple_storage.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_storage.cxx,1,['avail'],['available']
Availability,"// Parameter value and error accessors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooLinearVar.h:23,error,error,23,roofit/roofitcore/inc/RooLinearVar.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooLinearVar.h,3,['error'],['error']
Availability,"// Parameter value and error accessors; /// Set the current value of the object. Needs to be overridden by implementations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsRealLValue.h:23,error,error,23,roofit/roofitcore/inc/RooAbsRealLValue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsRealLValue.h,1,['error'],['error']
Availability,"// Params are unavailable in FunctionTypeLoc if the FunctionType is invalid.; // It would be better to pass in the param Type, which is usually available.; // But this case is rare, so just pretend we fell back to int as elsewhere.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:144,avail,available,144,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['avail'],['available']
Availability,// Parse -fsanitize-recover= arguments.; // FIXME: Report unrecoverable sanitizers incorrectly specified here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:20,recover,recover,20,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,1,['recover'],['recover']
Availability,// Parse Error!,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h:9,Error,Error,9,interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h,2,['Error'],['Error']
Availability,"// Parse VPT mask and encode it in the MCInst as an immediate with the same; // format as the it_mask. That is, from the second 'e|t' encode 'e' as 1 and; // 't' as 0 and finish with a 1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:13,mask,mask,13,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,1,['mask'],['mask']
Availability,// Parse a braced-init-list here for error recovery purposes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:37,error,error,37,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,2,"['error', 'recover']","['error', 'recovery']"
Availability,"// Parse a branch protection specification, which has the form; // standard | none | [bti,pac-ret[+b-key,+leaf,+pc]*]; // Returns true on success, with individual elements of the specification; // returned in `PBP`. Returns false in error, with `Err` containing; // an erroneous part of the spec.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/ARMTargetParserCommon.cpp:233,error,error,233,interpreter/llvm-project/llvm/lib/TargetParser/ARMTargetParserCommon.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/ARMTargetParserCommon.cpp,1,['error'],['error']
Availability,"// Parse an argument representing an offset. Return true on error.; // If the prefix is 0, the base is octal, if the prefix is 0x or 0X, the; // base is hexadecimal, otherwise the base is decimal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.h:60,error,error,60,interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.h,1,['error'],['error']
Availability,"// Parse an op-mask register mark ({%k<NUM>}), which is now to be; // expected",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp:15,mask,mask,15,interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,1,['mask'],['mask']
Availability,"// Parse decltype-specifier; // tok == kw_decltype is just error recovery, it can only happen when SS; // isn't empty",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:59,error,error,59,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,2,"['error', 'recover']","['error', 'recovery']"
Availability,// Parse error!,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h:9,error,error,9,interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h,1,['error'],['error']
Availability,"// Parse error, skip the rest of the macro line.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp:9,error,error,9,interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,2,['error'],['error']
Availability,// Parse lane mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:14,mask,mask,14,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,1,['mask'],['mask']
Availability,// Parse the attributes even if they are rejected to ensure that error; // recovery is graceful.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:65,error,error,65,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,2,"['error', 'recover']","['error', 'recovery']"
Availability,// Parse the contents of the namespace. This includes parsing recovery on; // any improperly nested namespaces.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:62,recover,recovery,62,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,1,['recover'],['recovery']
Availability,// Parse the static_assert declaration to improve error recovery.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:50,error,error,50,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,2,"['error', 'recover']","['error', 'recovery']"
Availability,// Parse the token stream and return the corresponding Definition object.; // Returns an empty definition object with a null-Name on error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/MacroExpander.cpp:133,error,error,133,interpreter/llvm-project/clang/lib/Format/MacroExpander.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/MacroExpander.cpp,1,['error'],['error']
Availability,"// Parse the unqualified-id. We allow parsing of both constructor and; // destructor names and allow the action module to diagnose any semantic; // errors.; //; // C++11 [class.qual]p2:; // [...] in a using-declaration that is a member-declaration, if the name; // specified after the nested-name-specifier is the same as the identifier; // or the simple-template-id's template-name in the last component of the; // nested-name-specifier, the name is [...] considered to name the; // constructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:148,error,errors,148,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,1,['error'],['errors']
Availability,"// Parse things like:; // warning(push, 1); // warning(pop); // warning(disable : 1 2 3 ; error : 4 5 6 ; suppress : 7 8 9)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:90,error,error,90,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,1,['error'],['error']
Availability,"// Parse v5 directory/file entry content descriptions.; // Returns the descriptors, or an error if we did not find a path or ran off; // the end of the prologue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFDebugLine.cpp:90,error,error,90,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFDebugLine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFDebugLine.cpp,1,['error'],['error']
Availability,"// Parse value as a C string first in order to print it in escaped form later.; // Then, parse it again to catch errors or to pretty print if Tag_CPU_arch.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ARMAttributeParser.cpp:113,error,errors,113,interpreter/llvm-project/llvm/lib/Support/ARMAttributeParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ARMAttributeParser.cpp,1,['error'],['errors']
Availability,"// ParseDirective returns true if there was an error or if the directive is; // not target-specific. Disambiguate the two cases by comparing position of; // the lexer before and after calling the method: if no tokens were consumed,; // there was no match, otherwise there was a failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/MCTargetAsmParser.cpp:47,error,error,47,interpreter/llvm-project/llvm/lib/MC/MCParser/MCTargetAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/MCTargetAsmParser.cpp,2,"['error', 'failure']","['error', 'failure']"
Availability,"// ParseExpressionList can sometimes succeed even when ThisDecl is not; // VarDecl. This is an error and it is reported in a call to; // Actions.ActOnInitializerError(). However, we call; // ProduceConstructorSignatureHelp only on VarDecls.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:95,error,error,95,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['error'],['error']
Availability,// ParseObjcopyOptions returns the config and sets the input arguments. If a; // help flag is set then ParseObjcopyOptions will print the help messege and; // exit. ErrorCallback is used to handle recoverable errors. An Error returned; // by the callback aborts the parsing and is then returned by this function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objcopy/ObjcopyOptions.h:165,Error,ErrorCallback,165,interpreter/llvm-project/llvm/tools/llvm-objcopy/ObjcopyOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objcopy/ObjcopyOptions.h,4,"['Error', 'error', 'recover']","['Error', 'ErrorCallback', 'errors', 'recoverable']"
Availability,// ParseStripOptions returns the config and sets the input arguments. If a; // help flag is set then ParseStripOptions will print the help messege and; // exit. ErrorCallback is used to handle recoverable errors. An Error returned; // by the callback aborts the parsing and is then returned by this function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objcopy/ObjcopyOptions.h:161,Error,ErrorCallback,161,interpreter/llvm-project/llvm/tools/llvm-objcopy/ObjcopyOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objcopy/ObjcopyOptions.h,4,"['Error', 'error', 'recover']","['Error', 'ErrorCallback', 'errors', 'recoverable']"
Availability,"// ParseTemplateArgValueList - Parse a template argument list with the syntax; // shown, filling in the Result vector. The open angle has been consumed.; // An empty argument list is allowed. Return false if okay, true if an; // error was detected.; //; // ArgValueList ::= '<' PostionalArgValueList [','] NamedArgValueList '>'; // PostionalArgValueList ::= [Value {',' Value}*]; // NamedArgValueList ::= [NameValue '=' Value {',' NameValue '=' Value}*]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp:229,error,error,229,interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,1,['error'],['error']
Availability,"// ParseUnqualifiedId might have parsed a scope specifier during error; // recovery. If it did so, enter that scope.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:65,error,error,65,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,2,"['error', 'recover']","['error', 'recovery']"
Availability,// Parses <start line>:<end line> input to a pair of line numbers.; // Returns true on error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp:87,error,error,87,interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp,1,['error'],['error']
Availability,"// Parses a single expected character \c c from \c State, skipping preceding; // whitespace. Error if the expected character isn't found.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp:93,Error,Error,93,interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp,1,['Error'],['Error']
Availability,"// Parses input for a stencil operator(single arg ops like AsValue, MemberOp or; // Id operator). Returns StencilType representing the operator on success and; // error if it fails to parse input for an operator.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp:163,error,error,163,interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp,1,['error'],['error']
Availability,"// Part of lineWidth still available",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlTable.cxx:27,avail,available,27,gui/guihtml/src/TGHtmlTable.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlTable.cxx,1,['avail'],['available']
Availability,"// Partial masks to use for EQ, GT, LT, UN comparisons, respectively.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp:11,mask,masks,11,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp,1,['mask'],['masks']
Availability,// Partially available enum constants should be present. Note that we; // suppress -Wunguarded-availability diagnostics for such uses.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:13,avail,available,13,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,2,['avail'],"['availability', 'available']"
Availability,"// Particle's status (CREATED,ALIVE,DEAD)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyParticle.h:30,ALIVE,ALIVE,30,test/RootShower/MyParticle.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyParticle.h,1,['ALIVE'],['ALIVE']
Availability,// Pass down -fobjc-weak or -fno-objc-weak if present.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:8,down,down,8,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['down'],['down']
Availability,// Pass down GlobalISel options.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp:8,down,down,8,interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp,1,['down'],['down']
Availability,// Pass down the TypeIndex 'TI' for the aggregate containing the field list.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewVisitor.cpp:8,down,down,8,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewVisitor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewVisitor.cpp,2,['down'],['down']
Availability,// Pass this down to addConstantValue as an unsigned bag of bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp:13,down,down,13,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp,1,['down'],['down']
Availability,"// Passing this to LookupFile forces header search to check whether the found; // file belongs to a module. Skipping that check could incorrectly mark; // modular header as textual, causing issues down the line.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:197,down,down,197,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,1,['down'],['down']
Availability,// Paths via a default initializer can only occur during error recovery; // (there's no other way that a default initializer can refer to a; // local). Don't produce a bogus warning on those cases.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:57,error,error,57,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,2,"['error', 'recover']","['error', 'recovery']"
Availability,"// Pattern : {zeros}{33-bit value}{ones}; // Shift right the Imm by (30 - LZ) bits to construct a negative 34 bit value,; // therefore we can take advantage of PLI's sign-extension semantics, and then; // mask them off after rotation.; //; // +--LZ--||-33-bit-||--TO--+ +-------------|--34-bit--+; // |00000001bbbbbbbbb1111111| -> |00000000000001bbbbbbbbb1|; // +------------------------+ +------------------------+; // 63 0 63 0; //; // +----sext-----|--34-bit--+ +clear-|-----------------+; // |11111111111111bbbbbbbbb1| -> |00000001bbbbbbbbb1111111|; // +------------------------+ +------------------------+; // 63 0 63 0",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:205,mask,mask,205,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,"// Pattern c. is non-canonical, and is expanded into pattern d. iff there; // is no extra use of the mask. Clearly, there was one since we are here.; // But at the same time, if we need to negate the shift amount,; // then we don't want the mask to stick around, else it's unprofitable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:101,mask,mask,101,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,2,['mask'],['mask']
Availability,"// Pattern match BSTRPICK.; // $dst = and $src, (2**len- 1) , if len > 12; // => BSTRPICK $dst, $src, msb, lsb; // where lsb = 0 and msb = len - 1; // If the mask is <= 0xfff, andi can be used instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:158,mask,mask,158,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,1,['mask'],['mask']
Availability,"// Pattern match CINS.; // $dst = and (shl $src , pos), mask; // => cins $dst, $src, pos, size; // mask is a shifted mask with consecutive 1's, pos = shift amount,; // size = population count.; // The second operand of the shift must be an immediate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:56,mask,mask,56,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,3,['mask'],['mask']
Availability,"// Pattern match EXT.; // $dst = and $src, (2**size - 1) , if size > 16; // => ext $dst, $src, pos, size , pos = 0; // If the mask is <= 0xffff, andi can be used instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:126,mask,mask,126,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,1,['mask'],['mask']
Availability,// Pattern match a special case:; /*; QUERY( (y | mask = y) =>; ((x | mask = y) <=> (x = y OR x = (y & ~mask))); );; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:50,mask,mask,50,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,3,['mask'],['mask']
Availability,"// Pattern: Or(And(MaskValue, A), And(Not(MaskValue), B)) ->; // bitselect(MaskValue, A, B) where Not(MaskValue) = Xor(MaskValue, -1)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:19,Mask,MaskValue,19,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,5,['Mask'],['MaskValue']
Availability,"// Patterns : {******}{31 zeros}{******}; // : {******}{31 ones}{******}; // If Imm contains 31 consecutive zeros/ones then the remaining bit count; // is 33. Rotate right the Imm to construct a int<33> value, we can use PLI; // for the int<33> value and then use RLDICL without a mask to rotate it back.; //; // +------|--ones--|------+ +---ones--||---33 bit--+; // |bbbbbb1111111111aaaaaa| -> |1111111111aaaaaabbbbbb|; // +----------------------+ +----------------------+; // 63 0 63 0",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:281,mask,mask,281,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,"// Patterns : {zeros}{ones}{33-bit value}{ones}; // {ones}{33-bit value}{ones}; // Similar to LI we can take advantage of PLI's sign-extension semantics to; // generate leading ones, and then use RLDICL to mask off the ones in left; // sides (if required) after rotation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:206,mask,mask,206,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,"// Patterns : {zeros}{ones}{33-bit value}{zeros}; // {zeros}{33-bit value}{zeros}; // {zeros}{ones}{33-bit value}; // {ones}{33-bit value}{zeros}; // We can take advantage of PLI's sign-extension semantics to generate leading; // ones, and then use RLDIC to mask off the ones on both sides after rotation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:258,mask,mask,258,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,// Peek the build ids to print a helpful error message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/RawMemProfReader.cpp:41,error,error,41,interpreter/llvm-project/llvm/lib/ProfileData/RawMemProfReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/RawMemProfReader.cpp,1,['error'],['error']
Availability,"// Peek through a bitcasted shuffle operand by scaling the mask. If the; // simulated shuffle can simplify, then this shuffle is unnecessary:; // shuf (bitcast X), undef, Mask --> bitcast X'; // TODO: This could be extended to allow length-changing shuffles.; // The transform might also be obsoleted if we allowed canonicalization; // of bitcasted shuffles.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:59,mask,mask,59,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,2,"['Mask', 'mask']","['Mask', 'mask']"
Availability,"// Peek through a mask/modulo operation.; // TODO: DAGCombine fails to do this as it just checks isTruncateFree, but; // we probably need a better IsDesirableToPromoteOp to handle this as well.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:18,mask,mask,18,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// Peek through mask: zext(and(shl(x,c1),c2))",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:16,mask,mask,16,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,// Peek through the shuffle masks to get the underlying source element.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:28,mask,masks,28,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['masks']
Availability,// Peek through vector widenings and set out of bounds mask indices to undef.; // TODO: Can resolveTargetShuffleInputsAndMask do some of this?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:55,mask,mask,55,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// Per HS3 standard, the hs3_version in the metadata is required. So we; // error out if it is missing. TODO: now we are only checking if the; // hs3_version tag exists, but in the future when the HS3 specification; // versions are actually frozen, we should also check if the hs3_version is; // one that RooFit can actually read.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/hs3/src/RooJSONFactoryWSTool.cxx:76,error,error,76,roofit/hs3/src/RooJSONFactoryWSTool.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/hs3/src/RooJSONFactoryWSTool.cxx,1,['error'],['error']
Availability,"// Per [temp.inst], default arguments in function declarations at local scope; // are instantiated along with the enclosing declaration. For example:; //; // template<typename T>; // void ft() {; // void f(int = []{ return T::value; }());; // }; // template void ft<int>(); // error: type 'int' cannot be used prior; // to '::' because it has no members; //; // The error is issued during instantiation of ft<int>() because substitution; // into the default argument fails; the default argument is instantiated even; // though it is never used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:277,error,error,277,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,2,['error'],['error']
Availability,"// Per [temp.inst], default arguments in member functions of local classes; // are instantiated along with the member function declaration. For example:; //; // template<typename T>; // void ft() {; // struct lc {; // int operator()(int p = []{ return T::value; }());; // };; // }; // template void ft<int>(); // error: type 'int' cannot be used prior; // to '::'because it has no members; //; // The error is issued during instantiation of ft<int>()::lc::operator(); // because substitution into the default argument fails; the default argument; // is instantiated even though it is never used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:313,error,error,313,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,2,['error'],['error']
Availability,"// Perform a general vector permute on vector operands 0 and 1.; // Each byte of operand 2 controls the corresponding byte of the result,; // in the same way as a byte-level VECTOR_SHUFFLE mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:189,mask,mask,189,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,1,['mask'],['mask']
Availability,"// Perform a system based diff between \p Before and \p After, using \p; // OldLineFormat, \p NewLineFormat, and \p UnchangedLineFormat to control the; // formatting of the output. Return an error message for any failures instead; // of the diff.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PrintPasses.h:191,error,error,191,interpreter/llvm-project/llvm/include/llvm/IR/PrintPasses.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PrintPasses.h,2,"['error', 'failure']","['error', 'failures']"
Availability,// Perform any debug-info maintenence required.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instruction.cpp:26,mainten,maintenence,26,interpreter/llvm-project/llvm/lib/IR/Instruction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instruction.cpp,1,['mainten'],['maintenence']
Availability,"// Perform chi2 fit to binned weighted dataset using sum-of-weights errors; //; // NB: Within the usual approximations of a chi2 fit, a chi2 fit to weighted; // data using sum-of-weights-squared errors does give correct error; // estimates",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h:68,error,errors,68,roofit/roofitcore/test/stressRooFit_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h,3,['error'],"['error', 'errors']"
Availability,"// Perform combines where ISD::OR is the root node.; //; // Performs the following transformations:; // - (or (and $a, $mask), (and $b, $inv_mask)) => (vselect $mask, $a, $b); // where $inv_mask is the bitwise inverse of $mask and the 'or' has a 128-bit; // vector type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:120,mask,mask,120,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,3,['mask'],['mask']
Availability,// Perform correct code generation around function calls and before returns.; // The below variables record the return/terminator instructions and the call; // instructions respectively; including which register is available as a; // temporary register just before the recorded instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp:215,avail,available,215,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp,1,['avail'],['available']
Availability,"// Perform legalization bottom up so we can DCE as we legalize.; // Traverse BB in RPOT and within each basic block, add insts top down,; // so when we pop_back_val in the legalization process, we traverse bottom-up.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp:131,down,down,131,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp,1,['down'],['down']
Availability,// Perform requested actions for the remaining masks/vectors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:47,mask,masks,47,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['mask'],['masks']
Availability,// Perform some checks to make sure the data sizes are consistent with the; // information available when the clause was created.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h:91,avail,available,91,interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,1,['avail'],['available']
Availability,"// Perform the full multiplication and downscale to get the same scale.; //; // Note that the right shifts here perform an implicit downwards rounding.; // This rounding could discard bits that would technically place the result; // outside the representable range. We interpret the spec as allowing us to; // perform the rounding step first, avoiding the overflow case that would; // arise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFixedPoint.cpp:39,down,downscale,39,interpreter/llvm-project/llvm/lib/Support/APFixedPoint.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFixedPoint.cpp,2,['down'],"['downscale', 'downwards']"
Availability,"// Perform the larger operation, then round down.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp:44,down,down,44,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,1,['down'],['down']
Availability,// Perform the transformation to calls with errno set by combination of errors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:72,error,errors,72,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,1,['error'],['errors']
Availability,// Perform the transformation to calls with errno set by range error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:63,error,error,63,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,1,['error'],['error']
Availability,// Performance might be harmed on HW that implements branching using exec mask; // where both sides of the branches are always executed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:74,mask,mask,74,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,1,['mask'],['mask']
Availability,"// Performs a semantic analysis on the call to built-in Pipe; // Query Functions.; // \param S Reference to the semantic analyzer.; // \param Call The call to the builtin function to be analyzed.; // \return True if a semantic error was found, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:227,error,error,227,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['error'],['error']
Availability,"// Performs a semantic analysis on the {work_group_/sub_group_; // /_}reserve_{read/write}_pipe; // \param S Reference to the semantic analyzer.; // \param Call The call to the builtin function to be analyzed.; // \return True if a semantic error was found, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:241,error,error,241,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['error'],['error']
Availability,"// Performs a semantic analysis on {work_group_/sub_group_; // /_}commit_{read/write}_pipe; // \param S Reference to the semantic analyzer.; // \param Call The call to the builtin function to be analyzed.; // \return True if a semantic error was found, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:236,error,error,236,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['error'],['error']
Availability,"// Performs semantic analysis for the read/write_pipe call.; // \param S Reference to the semantic analyzer.; // \param Call A pointer to the builtin call.; // \return True if a semantic error has been found, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:187,error,error,187,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['error'],['error']
Availability,// Performs the following for a >> b:; // unsigned r_high = a_high >> b;; // r_high = (32 - b <= 0) ? 0 : r_high;; //; // unsigned r_low = a_low >> b;; // r_low = (32 - b <= 0) ? r_high : r_low;; // r_low = (b == 0) ? r_low : r_low | (a_high << (32 - b));; // return (unsigned long long)r_high << 32 | r_low;; // Note: This takes advantage of Lanai's shift behavior to avoid needing to; // mask the shift amount.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:390,mask,mask,390,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,1,['mask'],['mask']
Availability,"// Perhaps getting the section of a reserved section index should be an error,; // but callers rely on this to return null.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/COFFObjectFile.cpp:72,error,error,72,interpreter/llvm-project/llvm/lib/Object/COFFObjectFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/COFFObjectFile.cpp,1,['error'],['error']
Availability,// Permit combining of mask vectors as BUILD_VECTOR never expands to scalar; // stores for those types.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:23,mask,mask,23,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['mask'],['mask']
Availability,// Phase 2 - Compute available VXRM using a forward walk.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp:21,avail,available,21,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp,1,['avail'],['available']
Availability,"// PhysReg is available, allocate it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp:14,avail,available,14,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,1,['avail'],['available']
Availability,"// PhysReg is available, but there may be a better choice.; // If we missed a simple hint, try to cheaply evict interference from the; // preferred register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:14,avail,available,14,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,1,['avail'],['available']
Availability,"// Pick a type to identify incoming block values as we construct SSA. We; // can't use anything more robust than an integer unfortunately, as SSAUpdater; // expects to zero-initialize the type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:101,robust,robust,101,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['robust'],['robust']
Availability,"// Pick upper or lower error bar depending on sign of external error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooXYChi2Var.cxx:23,error,error,23,roofit/roofitcore/src/RooXYChi2Var.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooXYChi2Var.cxx,2,['error'],['error']
Availability,// Picking from an undef operand. Let's adjust mask instead.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:47,mask,mask,47,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['mask']
Availability,"// PictureAttributes_t masks bits",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/gui/inc/GuiTypes.h:23,mask,masks,23,core/gui/inc/GuiTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/gui/inc/GuiTypes.h,1,['mask'],['masks']
Availability,"// Pin one of the tagged slots to offset 0 from the tagged base pointer.; // This would make its address available in a virtual register (IRG's def), as; // opposed to requiring an ADDG instruction to materialize. This effectively; // eliminates a vreg (by replacing it with direct uses of IRG, which is usually; // live almost everywhere anyway), and therefore needs to happen before; // regalloc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64StackTaggingPreRA.cpp:105,avail,available,105,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64StackTaggingPreRA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64StackTaggingPreRA.cpp,1,['avail'],['available']
Availability,// Pin the load to the highest slot available to it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:36,avail,available,36,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,1,['avail'],['available']
Availability,// Pin the store to the highest slot available to it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:37,avail,available,37,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,1,['avail'],['available']
Availability,// Place RHSReg is the passthru of the masked movss/sd operation and put; // LHS in the input. The mask input comes from the compare.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:39,mask,masked,39,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,2,['mask'],"['mask', 'masked']"
Availability,"// Placeholder type for type-dependent expressions whose type is; // completely unknown. No code should ever check a type against; // DependentTy and users should never see it; however, it is here to; // help diagnose failures to properly check for type-dependent; // expressions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:218,failure,failures,218,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['failure'],['failures']
Availability,"// Please note that error bars shown (Poisson or SumW2) are for visualization only, the are NOT used; // in a maximum likelihood fit; //; // A (binned) ML fit will ALWAYS assume the Poisson error interpretation of data (the mathematical definition; // of likelihood does not take any external definition of errors). Data with non-unit weights can only be; // correctly fitted with a chi^2 fit (see rf602_chi2fit.C); ////////////////////////////////////////////////; // I m p o r t i n g R O O T T T r e e s //; ////////////////////////////////////////////////; // I m p o r t T T r e e i n t o a R o o D a t a S e t; // -----------------------------------------------------------",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h:20,error,error,20,roofit/roofitcore/test/stressRooFit_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h,3,['error'],"['error', 'errors']"
Availability,"// Plot data using sum-of-weights-squared error rather than Poisson errors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h:42,error,error,42,roofit/roofitcore/test/stressRooFit_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h,2,['error'],"['error', 'errors']"
Availability,"// Plot likelihood in m0 in range that includes problematic values; // In this configuration no messages are printed for likelihood evaluation errors,; // but if an likelihood value evaluates with error, the corresponding value; // on the curve will be set to the value given in EvalErrorValue().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h:143,error,errors,143,roofit/roofitcore/test/stressRooFit_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h,2,['error'],"['error', 'errors']"
Availability,// Pointer to lane mask sequences; // for register units.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCRegisterInfo.h:19,mask,mask,19,interpreter/llvm-project/llvm/include/llvm/MC/MCRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCRegisterInfo.h,1,['mask'],['mask']
Availability,// Pointer... just echo it back.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:19,echo,echo,19,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,1,['echo'],['echo']
Availability,// Poison shuffle mask -> poison value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:18,mask,mask,18,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,1,['mask'],['mask']
Availability,"// Poisson errors are given by inverting: tau = 1 / (sigma*sigma)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/HistFactoryNavigation.cxx:11,error,errors,11,roofit/histfactory/src/HistFactoryNavigation.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/HistFactoryNavigation.cxx,1,['error'],['errors']
Availability,// Pop the block scope now but keep it alive to the end of this function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:39,alive,alive,39,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['alive'],['alive']
Availability,"// Pop the high registers first; // There are no store instructions that can access high registers directly,; // so we have to pop into low registers and them move to the high registers.; // This might take multiple pops, as it is possible for there to; // be fewer low registers available than high registers which need restoring.; // Find the first register to restore.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp:280,avail,available,280,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp,1,['avail'],['available']
Availability,// Populate the results with the currently available AAs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:43,avail,available,43,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,1,['avail'],['available']
Availability,// Position of the error in the input string.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp:19,error,error,19,interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp,1,['error'],['error']
Availability,"// Position==0 means we're not in an IT block at all. Position==1; // means we want the first state bit, which is always 0 (Then).; // Position==2 means we want the second state bit, stored at bit 3; // of Mask, and so on downwards. So (5 - Position) will shift the; // right bit down to bit 0, including the always-0 bit at bit 4 for; // the mandatory initial Then.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:206,Mask,Mask,206,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,3,"['Mask', 'down']","['Mask', 'down', 'downwards']"
Availability,// Positive mask,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DecoderEmitter.cpp:12,mask,mask,12,interpreter/llvm-project/llvm/utils/TableGen/DecoderEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DecoderEmitter.cpp,1,['mask'],['mask']
Availability,// Possibly due to previous error,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:28,error,error,28,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['error'],['error']
Availability,// Postpone error emission until we've collected attributes required to; // figure out whether it's a host or device variable and whether the; // error should be ignored.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:12,error,error,12,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,2,['error'],['error']
Availability,"// Pragma handling failed, and has been diagnosed. Slurp up the tokens; // until eof (really end of line) to prevent follow-on errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:127,error,errors,127,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,1,['error'],['errors']
Availability,"// Pragma read rule do not need to end in a semi colon; // if (tok.isNot(clang::tok::semi)) {; // Error(""Error: missing ; at end of rule"",tok, PP);; // return;; // }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/LinkdefReader.cxx:98,Error,Error,98,core/dictgen/src/LinkdefReader.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/LinkdefReader.cxx,2,['Error'],['Error']
Availability,// Pre-AVX512 - each maskmov load costs 2 + store costs ~8.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:21,mask,maskmov,21,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['mask'],['maskmov']
Availability,// Pre-mask the amount modulo using the wider vector.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:7,mask,mask,7,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Pre-populate the operand conversion kinds with the standard always; // available entries.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp:74,avail,available,74,interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp,1,['avail'],['available']
Availability,"// Pre-promote (i1 (truncate (srl X, Y))) on RV64 with Zbs without zero; // extending X. This is safe since we only need the LSB after the shift and; // shift amounts larger than 31 would produce poison. If we wait until; // type legalization, we'll create RISCVISD::SRLW and we can't recover it; // to use a BEXT instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:285,recover,recover,285,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['recover'],['recover']
Availability,"// Pre-promote (i32 (and (srl X, Y), 1)) on RV64 with Zbs without zero; // extending X. This is safe since we only need the LSB after the shift and; // shift amounts larger than 31 would produce poison. If we wait until; // type legalization, we'll create RISCVISD::SRLW and we can't recover it; // to use a BEXT instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:284,recover,recover,284,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['recover'],['recover']
Availability,"// Pre-promote (i32 (xor (shl -1, X), ~0)) on RV64 with Zbs so we can use; // (ADDI (BSET X0, X), -1). If we wait until/ type legalization, we'll create; // RISCVISD:::SLLW and we can't recover it to use a BSET instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:186,recover,recover,186,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['recover'],['recover']
Availability,"// Pre-regalloc, only forward if all subregisters agree (or there are no; // subregs at all). More analysis might recover some forwardable copies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:114,recover,recover,114,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,1,['recover'],['recover']
Availability,"// Predicated store requires some form of masking:; // 1) masked store HW instruction,; // 2) emulation via load-blend-store (only if safe and legal to do so,; // be aware on the race conditions), or; // 3) element-by-element predicate check and scalar store.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:42,mask,masking,42,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,2,['mask'],"['masked', 'masking']"
Availability,"// Prefer ""down"", since this will move the MUX farther away from the; // predicate definition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenMux.cpp:11,down,down,11,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenMux.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenMux.cpp,1,['down'],['down']
Availability,// Prefer NEON unless larger SVE registers are available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Subtarget.h:47,avail,available,47,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Subtarget.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Subtarget.h,1,['avail'],['available']
Availability,"// Prefer RISBGN if available, since it does not clobber CC.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:20,avail,available,20,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,3,['avail'],['available']
Availability,"// Prefer `-(x & 1)` over `(x << (bitwidth(x)-1)) a>> (bitwidth(x)-1)`; // as the pattern to splat the lowest bit.; // FIXME: iff X is already masked, we don't need the one-use check.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:143,mask,masked,143,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,1,['mask'],['masked']
Availability,"// Prefer a compatible vector conversion over a lax vector conversion; // For example:; //; // typedef float __v4sf __attribute__((__vector_size__(16)));; // void f(vector float);; // void f(vector signed int);; // int main() {; // __v4sf a;; // f(a);; // }; // Here, we'd like to choose f(vector float) and not; // report an ambiguous call error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:341,error,error,341,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['error'],['error']
Availability,// Prefer an expression error over a generic invalid argument message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:24,error,error,24,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,1,['error'],['error']
Availability,// Prefer available modules.; // FIXME: Considering whether the module is available rather than merely; // importable is non-hermetic and can result in surprising behavior for; // prebuilt modules. Consider only checking for importability here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:10,avail,available,10,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,2,['avail'],['available']
Availability,// Prefer first error encountered as later errors may be secondary effects of; // the initial problem.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h:16,error,error,16,interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h,2,['error'],"['error', 'errors']"
Availability,"// Prefer simplifying to the splat-shuffle, if possible. This is legal if; // every undef mask element in the splat-shuffle has a corresponding undef; // element in the user-shuffle's mask or if the composition of mask elements; // would result in undef.; // Examples for (shuffle (shuffle v, undef, SplatMask), undef, UserMask):; // * UserMask=[0,2,u,u], SplatMask=[2,u,2,u] -> [2,2,u,u]; // In this case it is not legal to simplify to the splat-shuffle because we; // may be exposing the users of the shuffle an undef element at index 1; // which was not there before the combine.; // * UserMask=[0,u,2,u], SplatMask=[2,u,2,u] -> [2,u,2,u]; // In this case the composition of masks yields SplatMask, so it's ok to; // simplify to the splat-shuffle.; // * UserMask=[3,u,2,u], SplatMask=[2,u,2,u] -> [u,u,2,u]; // In this case the composed mask includes all undef elements of SplatMask; // and in addition sets element zero to undef. It is safe to simplify to; // the splat-shuffle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:90,mask,mask,90,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,5,['mask'],"['mask', 'masks']"
Availability,// Prefer tail/mask agnostic since it can be relaxed to undisturbed later; // if needed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:15,mask,mask,15,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,1,['mask'],['mask']
Availability,"// Prefer to warn on write, but if not available, warn on capture.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp:39,avail,available,39,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAutoreleaseWriteChecker.cpp,1,['avail'],['available']
Availability,// Prefer uxtb mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:15,mask,mask,15,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['mask'],['mask']
Availability,// Prefer uxth mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:15,mask,mask,15,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['mask'],['mask']
Availability,// Prefixed instructions are not available pre-Power10.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp:33,avail,available,33,interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp,1,['avail'],['available']
Availability,// Prepare the shufflevector masks once and re-use them for all; // fragments.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp:29,mask,masks,29,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,1,['mask'],['masks']
Availability,// Prepares TopRPTracker for top down scheduling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp:33,down,down,33,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,1,['down'],['down']
Availability,"// PreservedCFGCheckerInstrumentation uses PreservedCFGCheckerAnalysis to check; // passes, that reported they kept CFG analyses up-to-date, did not actually; // change CFG. This check is done as follows. Before every functional pass in; // BeforeNonSkippedPassCallback a CFG snapshot (an instance of; // PreservedCFGCheckerInstrumentation::CFG) is requested from; // FunctionAnalysisManager as a result of PreservedCFGCheckerAnalysis. When the; // functional pass finishes and reports that CFGAnalyses or AllAnalyses are; // up-to-date then the cached result of PreservedCFGCheckerAnalysis (if; // available) is checked to be equal to a freshly created CFG snapshot.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/StandardInstrumentations.cpp:599,avail,available,599,interpreter/llvm-project/llvm/lib/Passes/StandardInstrumentations.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/StandardInstrumentations.cpp,1,['avail'],['available']
Availability,// Pretend that error point is a neighbour.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp:16,error,error,16,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp,1,['error'],['error']
Availability,"// Pretend that we exit the ""top-level"" include file.; // Note that in case of an error (e.g. control stack imbalance); // the routine will issue a fatal error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGLexer.cpp:82,error,error,82,interpreter/llvm-project/llvm/lib/TableGen/TGLexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGLexer.cpp,2,['error'],['error']
Availability,"// Prevent redundant declarations for control statements (e.g., for, if, while); // that have already been annotated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx:11,redundant,redundant,11,core/metacling/src/TClingCallbacks.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx,1,['redundant'],['redundant']
Availability,"// Prevent redundant register copies due to reads and writes of physical; // registers. The original motivation for this was the code generated; // between two calls, which are caused both the return value and the; // argument for the next call being in %r0.; // Example:; // 1: <call1>; // 2: %vreg = COPY %r0; // 3: <use of %vreg>; // 4: %r0 = ...; // 5: <call2>; // The scheduler would often swap 3 and 4, so an additional register is; // needed. This code inserts a Barrier dependence between 3 & 4 to prevent; // this.; // The code below checks for all the physical registers, not just R0/D0/V0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:11,redundant,redundant,11,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,1,['redundant'],['redundant']
Availability,"// Prevent the following #error: The C++ Standard Library forbids macroizing keywords.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx:26,error,error,26,core/dictgen/src/rootcling_impl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx,1,['error'],['error']
Availability,"// Prevent use of AH in a REX instruction by explicitly copying it to; // an ABCD_L register.; //; // The current assumption of the register allocator is that isel; // won't generate explicit references to the GR8_ABCD_H registers. If; // the allocator and/or the backend get enhanced to be more robust in; // that regard, this can be, and should be, removed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:296,robust,robust,296,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['robust'],['robust']
Availability,"// Previous failures to create 'pt' should not block the name",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_model.cxx:12,failure,failures,12,tree/ntuple/v7/test/ntuple_model.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_model.cxx,1,['failure'],['failures']
Availability,"// Print ""not found"" diagnostic, except that's implied if we already printed a; // pattern error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:91,error,error,91,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,1,['error'],['error']
Availability,"// Print 'x' for indexed form.; // FIXME: Currently for PowerPC memory operands are always loaded; // into a register, so we never get an update or indexed form.; // This is bad even for offset forms, since even if we know we; // have a value in -16(r1), we will generate a load into r<n>; // and then load from 0(r<n>). Until that issue is fixed,; // tolerate 'U' and 'X' but don't output anything.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:352,toler,tolerate,352,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,1,['toler'],['tolerate']
Availability,"// Print 64-bit register names if 64-bit integer registers are available.; // Otherwise, print 32-bit register names.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp:63,avail,available,63,interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp,1,['avail'],['available']
Availability,// Print EdgeWeights when BPI is available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFGPrinter.h:33,avail,available,33,interpreter/llvm-project/llvm/include/llvm/Analysis/CFGPrinter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFGPrinter.h,1,['avail'],['available']
Availability,// Print RawWeights when BFI is available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFGPrinter.h:32,avail,available,32,interpreter/llvm-project/llvm/include/llvm/Analysis/CFGPrinter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFGPrinter.h,1,['avail'],['available']
Availability,"// Print Stat Error (if necessary)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/Sample.cxx:14,Error,Error,14,roofit/histfactory/src/Sample.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/Sample.cxx,1,['Error'],['Error']
Availability,"// Print additional information, which can be useful even after a pattern; // error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:78,error,error,78,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,1,['error'],['error']
Availability,"// Print additional information, which can be useful even if there are errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:71,error,errors,71,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,1,['error'],['errors']
Availability,// Print an error and exit if we couldn't find the requested target.; // This generally occurs if we've forgotten to initialise the; // TargetRegistry or we have a bogus target triple.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp:12,error,error,12,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp,1,['error'],['error']
Availability,// Print an error message if unrecognized character.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.cpp:12,error,error,12,interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.cpp,1,['error'],['error']
Availability,"// Print any pattern errors, and record them to be added to Diags later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:21,error,errors,21,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,1,['error'],['errors']
Availability,// Print error messages.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp:9,error,error,9,interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,1,['error'],['error']
Availability,"// Print errors and add them to Diags. We report these errors after the match; // itself because we found them after the match. If we had found them before; // the match, we'd be in printNoMatch.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:9,error,errors,9,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,2,['error'],['errors']
Availability,"// Print extra information about abnormal failures, if possible.; //; // This is ad-hoc, but we don't want to be excessively noisy. If the result; // status was 1, assume the command failed normally. In particular, if it; // was the compiler then assume it gave a reasonable error code. Failures; // in other tools are less common, and they generally have worse; // diagnostics, so always print the diagnostic there.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:42,failure,failures,42,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,3,"['Failure', 'error', 'failure']","['Failures', 'error', 'failures']"
Availability,// Print in a deterministic order by sorting CallGraphNodes by name. We do; // this here to avoid slowing down the non-printing fast path.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraph.cpp:106,down,down,106,interpreter/llvm-project/llvm/lib/Analysis/CallGraph.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraph.cpp,1,['down'],['down']
Availability,// Print in bytes and use the mask() operator for pointers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:30,mask,mask,30,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,1,['mask'],['mask']
Availability,// Print mask operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ATTInstPrinter.cpp:9,mask,mask,9,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ATTInstPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ATTInstPrinter.cpp,4,['mask'],['mask']
Availability,"// Print node name and details of 'maxPerNode' errors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:47,error,errors,47,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,1,['error'],['errors']
Availability,"// Print out the IR after passes, similar to -print-after-all except that it; // only prints the IR after passes that change the IR. Those passes that do not; // make changes to the IR are reported as not making any changes. In addition,; // the initial IR is also reported. Other hidden options affect the output from; // this option. -filter-passes will limit the output to the named passes that; // actually change the IR and other passes are reported as filtered out. The; // specified passes will either be reported as making no changes (with no IR; // reported) or the changed IR will be reported. Also, the -filter-print-funcs; // and -print-module-scope options will do similar filtering based on function; // name, reporting changed IRs as functions(or modules if -print-module-scope is; // specified) for a particular function or indicating that the IR has been; // filtered out. The extra options can be combined, allowing only changed IRs; // for certain passes on certain functions to be reported in different formats,; // with the rest being reported as filtered out. The -print-before-changed; // option will print the IR as it was before each pass that changed it. The; // optional value of quiet will only report when the IR changes, suppressing all; // other messages, including the initial IR. The values ""diff"" and ""diff-quiet""; // will present the changes in a form similar to a patch, in either verbose or; // quiet mode, respectively. The lines that are removed and added are prefixed; // with '-' and '+', respectively. The -filter-print-funcs and -filter-passes; // can be used to filter the output. This reporter relies on the linux diff; // utility to do comparisons and insert the prefixes. For systems that do not; // have the necessary facilities, the error message will be shown in place of; // the expected output.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/PrintPasses.cpp:1782,error,error,1782,interpreter/llvm-project/llvm/lib/IR/PrintPasses.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/PrintPasses.cpp,1,['error'],['error']
Availability,"// Print the MINOS errors to the TableFile",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/MakeModelAndMeasurementsFast.cxx:19,error,errors,19,roofit/histfactory/src/MakeModelAndMeasurementsFast.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/MakeModelAndMeasurementsFast.cxx,1,['error'],['errors']
Availability,"// Print the error only if the branch name does not appear in the list of; // missing proxies that the user explicitly requested not to error about",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReaderValue.cxx:13,error,error,13,tree/treeplayer/src/TTreeReaderValue.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReaderValue.cxx,2,['error'],['error']
Availability,// Print the function name explicitly if we don't have a debug location (which; // makes the diagnostic less useful) or if we're going to emit a raw error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:149,error,error,149,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,3,['error'],['error']
Availability,// Print the lane mask in a short form (or not at all if all bits are set).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFRegisters.h:18,mask,mask,18,interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFRegisters.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFRegisters.h,1,['mask'],['mask']
Availability,"// Print the mnemonic for a condition-code mask (""ne"", ""lh"", etc.); // This forms part of the instruction name rather than the operand list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/MCTargetDesc/SystemZInstPrinter.h:43,mask,mask,43,interpreter/llvm-project/llvm/lib/Target/SystemZ/MCTargetDesc/SystemZInstPrinter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/MCTargetDesc/SystemZInstPrinter.h,1,['mask'],['mask']
Availability,"// Print the target node itself, with the error as a comment.; // Also used if we can't follow our path, e.g. it names a field that; // *should* exist but doesn't.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/JSON.cpp:42,error,error,42,interpreter/llvm-project/llvm/lib/Support/JSON.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/JSON.cpp,1,['error'],['error']
Availability,"// Print warnings if the requested ranges are not available for the observable",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsOptTestStatistic.cxx:50,avail,available,50,roofit/roofitcore/src/RooAbsOptTestStatistic.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsOptTestStatistic.cxx,1,['avail'],['available']
Availability,"// PrintValue recurses down the path, printing the ancestors of our target.; // Siblings of nodes along the path are printed with abbreviate(), and the; // target itself is printed with the somewhat richer abbreviateChildren().; // 'Recurse' is the lambda itself, to allow recursive calls.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/JSON.cpp:23,down,down,23,interpreter/llvm-project/llvm/lib/Support/JSON.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/JSON.cpp,1,['down'],['down']
Availability,"// Prior checks cover Mask with VOPC condition, but not on purpose",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNDPPCombine.cpp:22,Mask,Mask,22,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNDPPCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNDPPCombine.cpp,1,['Mask'],['Mask']
Availability,"// Prior to c++17, ""the failure argument shall be no stronger than the; // success argument"". This condition has been lifted and the only; // precondition is 31.7.2.18. Effectively treat this as a DR and skip; // language version checks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:24,failure,failure,24,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,1,['failure'],['failure']
Availability,// Prioritize by Sethi-Ulmann number and push CopyToReg nodes down.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:62,down,down,62,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,2,['down'],['down']
Availability,// Priority bit layout:; // 31 RS_Assign priority; // 30 Preference priority; // if (RegClassPriorityTrumpsGlobalness); // 29-25 AllocPriority; // 24 GlobalBit; // else; // 29 Global bit; // 28-24 AllocPriority; // 0-23 Size/Instr distance; // Clamp the size to fit with the priority masking scheme,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:284,mask,masking,284,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,1,['mask'],['masking']
Availability,"// Private modules named as FooPrivate, Foo.Private or similar are likely a; // user error; provide warnings, notes and fixits to direct users to use; // Foo_Private instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:85,error,error,85,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,1,['error'],['error']
Availability,// Probably an invalid store. If so we'll end up emitting a selection error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:70,error,error,70,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['error'],['error']
Availability,"// Probably we created a new file; // We have to remove it in case of errors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:70,error,errors,70,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,1,['error'],['errors']
Availability,// Process all masked registers. (Call clobbers).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:15,mask,masked,15,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,1,['mask'],['masked']
Availability,"// Process any error branch if existing",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooTreeDataStore.cxx:15,error,error,15,roofit/roofitcore/src/RooTreeDataStore.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooTreeDataStore.cxx,1,['error'],['error']
Availability,// Process any errors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:15,error,errors,15,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,1,['error'],['errors']
Availability,// Process commandline options and report errors,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-offload-bundler/ClangOffloadBundler.cpp:42,error,errors,42,interpreter/llvm-project/clang/tools/clang-offload-bundler/ClangOffloadBundler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-offload-bundler/ClangOffloadBundler.cpp,1,['error'],['errors']
Availability,"// Process echo statements",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooArgSet.cxx:11,echo,echo,11,roofit/roofitcore/src/RooArgSet.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooArgSet.cxx,1,['echo'],['echo']
Availability,"// Process map-type-modifiers, flag errors for duplicate modifiers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:36,error,errors,36,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['error'],['errors']
Availability,"// Process motion-modifiers, flag errors for duplicate modifiers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:34,error,errors,34,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,2,['error'],['errors']
Availability,// Process reg-masks (as clobbers).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp:15,mask,masks,15,interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp,1,['mask'],['masks']
Availability,// Process scheduling regions top-down so that scheduler states can be; // transferrred over scheduling boundaries.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:34,down,down,34,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,1,['down'],['down']
Availability,// Process split mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:17,mask,mask,17,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,1,['mask'],['mask']
Availability,// Process the attributes before looking at protocols to ensure that the; // availability attribute is attached to the category to provide availability; // checking for protocol uses.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:77,avail,availability,77,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,2,['avail'],['availability']
Availability,"// Processing steps done per block. E.g. emitting jump tables, stack; // protectors etc. Returns true if no errors, false if there was a problem; // that caused an abort.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/IRTranslator.h:108,error,errors,108,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/IRTranslator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/IRTranslator.h,1,['error'],['errors']
Availability,// Processor selection mask for EF_AMDGPU_MACH_* values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:23,mask,mask,23,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,1,['mask'],['mask']
Availability,// Processor selection mask for EF_CUDA_SM* values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:23,mask,mask,23,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,1,['mask'],['mask']
Availability,// Produce an error if no expected-* directives could be found in the; // source file(s) processed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp:14,error,error,14,interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp,1,['error'],['error']
Availability,"// Produces a human readable description of a CO-RE relocation.; // Such relocations are generated by BPF backend, and processed; // by libbpf's BPF program loader [1].; //; // Each relocation record has the following information:; // - Relocation kind;; // - BTF type ID;; // - Access string offset in string table.; //; // There are different kinds of relocations, these kinds could be split; // in three groups:; // - load-time information about types (size, existence),; // `BTFParser::symbolize()` output for such relocations uses the template:; //; // <relocation-kind> [<id>] <type-name>; //; // For example:; // - ""<type_exists> [7] struct foo""; // - ""<type_size> [7] struct foo""; //; // - load-time information about enums (literal existence, literal value),; // `BTFParser::symbolize()` output for such relocations uses the template:; //; // <relocation-kind> [<id>] <type-name>::<literal-name> = <original-value>; //; // For example:; // - ""<enumval_exists> [5] enum foo::U = 1""; // - ""<enumval_value> [5] enum foo::V = 2""; //; // - load-time information about fields (e.g. field offset),; // `BTFParser::symbolize()` output for such relocations uses the template:; //; // <relocation-kind> [<id>] \; // <type-name>::[N].<field-1-name>...<field-M-name> \; // (<access string>); //; // For example:; // - ""<byte_off> [8] struct bar::[7].v (7:1)""; // - ""<field_exists> [8] struct bar::v (0:1)""; //; // If relocation description is not valid output follows the following pattern:; //; // <relocation-kind> <type-id>::<unprocessedaccess-string> <<error-msg>>; //; // For example:; //; // - ""<type_sz> [42] '' <unknown type id: 42>""; // - ""<byte_off> [4] '0:' <field spec too short>""; //; // Additional examples could be found in unit tests, see; // llvm/unittests/DebugInfo/BTF/BTFParserTest.cpp.; //; // [1] https://www.kernel.org/doc/html/latest/bpf/libbpf/index.html",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/BTF/BTFParser.cpp:1554,error,error-msg,1554,interpreter/llvm-project/llvm/lib/DebugInfo/BTF/BTFParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/BTF/BTFParser.cpp,1,['error'],['error-msg']
Availability,"// Profile count is not available, we can use block frequency instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:24,avail,available,24,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,1,['avail'],['available']
Availability,"// Profile histogram is resized along axis such that x is in the axis range.; // The new axis limits are recomputed by doubling iteratively; // the current axis range until the specified value x is within the limits.; // The algorithm makes a copy of the histogram, then loops on all bins; // of the old histogram to fill the extended histogram.; // Takes into account errors (Sumw2) if any.; // The axis must be extendable before invoking this function.; // Ex: h->GetXaxis()->SetCanExtend(kTRUE)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfileHelper.h:369,error,errors,369,hist/hist/src/TProfileHelper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfileHelper.h,1,['error'],['errors']
Availability,// Profitability check: only deal with extractions from the first subvector; // unless the mask becomes an identity mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:91,mask,mask,91,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['mask'],['mask']
Availability,// Program is possibly broken by using more local mem than available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPromoteAlloca.cpp:59,avail,available,59,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPromoteAlloca.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPromoteAlloca.cpp,1,['avail'],['available']
Availability,"// Program to check a TGeo geometry; // The first time you run this program, the geometry files will be taken; // from http://root.cern/files; //; // How the program works; // If the file <geom_name>_ref.root does not exist, it is generated. The file; // contains a TTree with Npoints (default=100000) obtained with the following; // algorithm:; // -a point is generated with a uniform distribution x,y,z in the master volume; // -a direction theta, phi is generated uniformly in -2pi<phi<2pi and 0<theta<pi; // -gGeoManager finds the geometry path for the point; // -the number of boundaries (nbound), total length (length), safety distance; // from the starting point (safe) and number of radiation lengths (rad) from x,y,z; // is calculated to the exit of the detector. The total number of crossings, detector; // weight and total number of radiation lengths for all tracks are stored as user info in the tree.; //; // Using the file <geom_name>_ref.root (generated typically with a previous version; // of the TGeo classes), the Npoints in the Tree are used to perform the; // same operation with the new version.; // In case of a disagreement, an error message is reported.; //; // The ReadRef case is also used as a benchmark; // The ROOTMARKS reported are relative to a Linux/P IV 2.8 GHz gcc3.2.3 machine; // normalized at 800 ROOTMARKS when running with CINT.; //; // To run this script, do; // stressGeometry; // or stressGeometry *; // or stressGeometry alice; // or from the ROOT command line; // root > .L stressGeometry.cxx or .L stressGeometry.cxx+; // root > stressGeometry(exp_name); // where exp_name is the geometry file name without .root; // OR simply: stressGeometry(); to run tests for a set of geometries; //; // Authors: Rene Brun, Andrei Gheata, 22 march 2005",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressGeometry.cxx:1152,error,error,1152,test/stressGeometry.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressGeometry.cxx,1,['error'],['error']
Availability,"// Promote fp16 arithmetic if fp16 hardware isn't available or the; // user passed --nvptx-no-fp16-math. The flag is useful because,; // although sm_53+ GPUs have some sort of FP16 support in; // hardware, only sm_53 and sm_60 have full implementation. Others; // only have token amount of hardware and are likely to run faster; // by using fp32 units instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:50,avail,available,50,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,1,['avail'],['available']
Availability,// Promote the warning to an error if there are incompatible attributes or; // incompatible types together with readwrite/readonly incompatibility.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:29,error,error,29,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,1,['error'],['error']
Availability,// Promoting a mask type (v*i1) into a register of type i64/i32/i16/i8,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp:15,mask,mask,15,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,1,['mask'],['mask']
Availability,// Promotion requires extend/truncate for data and a shuffle for mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:65,mask,mask,65,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['mask'],['mask']
Availability,"// Propagate both errors and recovered types, which return ExprEmpty.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:18,error,errors,18,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,2,"['error', 'recover']","['errors', 'recovered']"
Availability,"// Propagate corrected errors to parameters objects",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/FitHelpers.cxx:23,error,errors,23,roofit/roofitcore/src/FitHelpers.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/FitHelpers.cxx,1,['error'],['errors']
Availability,"// Propagate dirty flag to all clients if this is a down->up transition",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx:52,down,down,52,roofit/roofitcore/src/RooAbsArg.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx,2,['down'],['down']
Availability,// Propagate down the 'related result type' bit from overridden methods.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:13,down,down,13,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['down'],['down']
Availability,"// Propagate down to the ultimate replacee. The intermediately loads; // could theoretically already have been deleted, so we don't want to; // dereference the Value*'s.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:13,down,down,13,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,1,['down'],['down']
Availability,"// Propagate live-out values down the dominator tree, inserting phi-defs; // when necessary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp:29,down,down,29,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp,1,['down'],['down']
Availability,"// Propagate values to eliminate redundant PHIs. At the same time, this; // produces the table of Block x Location => Value for the entry to each; // block.; // The kind of PHIs we can eliminate are, for example, where one path in a; // conditional spills and restores a register, and the register still has; // the same value once control flow joins, unbeknowns to the PHI placement; // code. Propagating values allows us to identify such un-necessary PHIs and; // remove them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:33,redundant,redundant,33,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['redundant'],['redundant']
Availability,// Propagating an undefined shuffle mask element to integer div/rem is not; // allowed because those opcodes can create immediate undefined behavior; // from an undefined element in an operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:36,mask,mask,36,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['mask'],['mask']
Availability,"// Protection: The user isn't allowed to export a style if the output; // file name isn't based on the ""Style_*.C"" mask, without spaces.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TStyleManager.cxx:115,mask,mask,115,gui/ged/src/TStyleManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TStyleManager.cxx,1,['mask'],['mask']
Availability,"// Protocol error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationRemote.cxx:12,error,error,12,net/net/src/TApplicationRemote.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationRemote.cxx,2,['error'],['error']
Availability,// Provide a dummy '0' value on output stream to elide further errors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:63,error,errors,63,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,1,['error'],['errors']
Availability,"// Provide an ExtWarn if the C++1z feature of using 'typename' here is used.; // Generate a meaningful error if the user forgot to put class before the; // identifier, comma, or greater. Provide a fixit if the identifier, comma,; // or greater appear immediately or after 'struct'. In the latter case,; // replace the keyword with 'class'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:103,error,error,103,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,1,['error'],['error']
Availability,"// Provide an instantiation context that suppresses errors:; // DeducedTemplateArgumentSubstitution! (ROOT-8422)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingMethodInfo.cxx:52,error,errors,52,core/metacling/src/TClingMethodInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingMethodInfo.cxx,1,['error'],['errors']
Availability,// Provide better error message about types missing a trait specialization,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h:18,error,error,18,interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h,2,['error'],['error']
Availability,"// Provide macros for all the calling convention keywords. Provide both; // single and double underscore prefixed variants. These are available on; // x64 as well as x86, even though they have no effect.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets.cpp:134,avail,available,134,interpreter/llvm-project/clang/lib/Basic/Targets.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets.cpp,1,['avail'],['available']
Availability,"// Provide the RTTI component if RTTIData is enabled. If the vftable would; // be available externally, we should not provide the RTTI componenent. It; // is currently impossible to get available externally vftables with either; // dllimport or extern template instantiations, but eventually we may add a; // flag to support additional devirtualization that needs this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp:82,avail,available,82,interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp,2,['avail'],['available']
Availability,"// Provided to resolve 'CreateIntCast(Ptr, Ptr, ""..."")', giving a; // compile time error, instead of converting the string to bool for the; // isSigned parameter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h:83,error,error,83,interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h,1,['error'],['error']
Availability,"// Provides Integrand and abs. error from MC run",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/foam/inc/TFoam.h:31,error,error,31,math/foam/inc/TFoam.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/foam/inc/TFoam.h,1,['error'],['error']
Availability,// Pull down to the prefix code.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:8,down,down,8,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['down'],['down']
Availability,// Pull in host-only functions that are only available when neither; // __CUDACC__ nor __CUDABE__ are defined.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:45,avail,available,45,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,1,['avail'],['available']
Availability,"// Purposely ignore all unsupported bits; TIOFeatures implementation already warned the user about the; // error of their ways; this is just a safety check.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:107,error,error,107,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['error'],['error']
Availability,// Push '};' onto the token stream to recover.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:38,recover,recover,38,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,1,['recover'],['recover']
Availability,// Push a clang.arc.use call to ensure ARC optimizer knows that the; // argument has to be alive.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:91,alive,alive,91,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,1,['alive'],['alive']
Availability,"// Push the integer typed Load instruction into the available; // value set, and fix it up later when the pointer typed PHI; // is synthesized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:52,avail,available,52,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,1,['avail'],['available']
Availability,// Push the register mask info.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FastISel.cpp:21,mask,mask,21,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FastISel.cpp,2,['mask'],['mask']
Availability,// Push this token back into the preprocessor and change our current token; // to ';' so that the rest of the code recovers as though there were an; // ';' after the definition.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:115,recover,recovers,115,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,2,['recover'],['recovers']
Availability,// Pushing the original feature string to give a sema error later on; // when they get checked.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp:54,error,error,54,interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp,1,['error'],['error']
Availability,// Put Cond in a virtual register to make it available from the new blocks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:45,avail,available,45,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,3,['avail'],['available']
Availability,"// Put a dummy C++ file on to ensure there's at least one compile job for the; // driver to construct. If the user specified some other argument that; // prevents compilation, e.g. -E or something like -version, we may still end; // up with no jobs but then this is the user's fault.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp:277,fault,fault,277,interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp,1,['fault'],['fault']
Availability,// Put all released SUs in the Available set.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:31,Avail,Available,31,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,1,['Avail'],['Available']
Availability,// Put the mask in correct place,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ISelLowering.cpp:11,mask,mask,11,interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ISelLowering.cpp,1,['mask'],['mask']
Availability,"// Put x last to minimize cache faulting",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooIntegralMorph.cxx:32,fault,faulting,32,roofit/roofit/src/RooIntegralMorph.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooIntegralMorph.cxx,1,['fault'],['faulting']
Availability,// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:16,error,error,16,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['error'],['error']
Availability,"// Queries available locally",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:11,avail,available,11,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['avail'],['available']
Availability,// Query ignorelisted entries if any bit in Mask matches the entry's section.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SanitizerSpecialCaseList.h:44,Mask,Mask,44,interpreter/llvm-project/clang/include/clang/Basic/SanitizerSpecialCaseList.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SanitizerSpecialCaseList.h,1,['Mask'],['Mask']
Availability,// Query push down for cases where the unsigned range is; // less than sufficient.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:14,down,down,14,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['down'],['down']
Availability,"// Quick exit; // Super-extra-high-degree PHI nodes are unlikely to ever be interesting,; // and slow us down a lot. Just mark them overdefined.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h:105,down,down,105,interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h,1,['down'],['down']
Availability,"// Quick exit; // Super-extra-high-degree PHI nodes are unlikely to ever be marked constant,; // and slow us down a lot. Just mark them overdefined.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:109,down,down,109,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,1,['down'],['down']
Availability,"// R = carry_bit ? ~0 : 0; /// X86 FP SETCC, implemented with CMP{cc}SS/CMP{cc}SD.; /// Operands are two FP values to compare; result is a mask of; /// 0s or 1s. Generally DTRT for C/C++ with NaNs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h:139,mask,mask,139,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,1,['mask'],['mask']
Availability,// R600::BRANCH* instructions are only available after isel and are not; // handled,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600InstrInfo.cpp:39,avail,available,39,interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600InstrInfo.cpp,1,['avail'],['available']
Availability,// RC is unset only on failure. Return immediately.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp:23,failure,failure,23,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp,2,['failure'],['failure']
Availability,"// RCP, RSQ - For f32, 1 ULP max error, no denormal handling.; // For f64, max error 2^29 ULP, handles denormals.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.h:33,error,error,33,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.h,2,['error'],['error']
Availability,"// ROOT's atexit functions require the interepreter to be available.; // Run them before shutting down.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:58,avail,available,58,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,2,"['avail', 'down']","['available', 'down']"
Availability,"// ROOT-10668: Asympt. correct errors don't work when title and name differ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooAbsPdf.cxx:31,error,errors,31,roofit/roofitcore/test/testRooAbsPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooAbsPdf.cxx,1,['error'],['errors']
Availability,"// ROOT-9628 We cover here the case when:; // - We deal with a TChain; // - The last file is opened; // - The TTree is not correctly loaded; // The system is robust against issues with TTrees associated to the chain; // when they are not at the end of it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReader.cxx:158,robust,robust,158,tree/treeplayer/src/TTreeReader.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReader.cxx,1,['robust'],['robust']
Availability,// RPC Errors,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/OrcError.h:7,Error,Errors,7,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/OrcError.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/OrcError.h,1,['Error'],['Errors']
Availability,"// R__HAS_VECCORE; //////////////////////////////////////////////////////////////////////////////; /// Re-initialize eval method; ///; /// This function is called by DoEval and DoEvalVector in case of a previous failure; /// or in case of reading from a file; ////////////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:212,failure,failure,212,hist/hist/src/TFormula.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx,1,['failure'],['failure']
Availability,"// Raises an error. If IsAlreadyRead = false (default), this complains about; // the token that couldn't be parsed. If the flag is on, this complains about; // the correctly read token that makes no sense (that is, the current parser; // state is beyond the erroneous token.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rc/ResourceScriptParser.h:13,error,error,13,interpreter/llvm-project/llvm/tools/llvm-rc/ResourceScriptParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rc/ResourceScriptParser.h,1,['error'],['error']
Availability,// Range of the item where the error occurred.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeGenError.h:31,error,error,31,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeGenError.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeGenError.h,1,['error'],['error']
Availability,"// Rather than pulling in std::max from algorithm everytime, use available ::max.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_complex_builtins.h:65,avail,available,65,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_complex_builtins.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_complex_builtins.h,1,['avail'],['available']
Availability,// Rather the truncating try to do the compare on vXi16 or vXi32.; // Shift the high down filling with sign bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:85,down,down,85,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['down'],['down']
Availability,"// Re-acquire the GIL before calling PyErr_Occurred() in case it has been; // released; note that the p2.2 code assumes that there are no callbacks in; // C++ to python (or at least none returning errors).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Utility.cxx:197,error,errors,197,bindings/pyroot/cppyy/CPyCppyy/src/Utility.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Utility.cxx,1,['error'],['errors']
Availability,"// Re-align the stack on 64-bit if the x86-interrupt calling convention is; // used and an error code was pushed, since the x86-64 ABI requires a 16-byte; // stack alignment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:91,error,error,91,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,1,['error'],['error']
Availability,"// Re-evaluate this RooAbsReal with the central parameters just to be; // extra-safe that a call to `getPropagatedError()` doesn't change any state.; // It should not be necessary because thanks to the dirty flag propagation; // the RooAbsReal is re-evaluated anyway the next time getVal() is called.; // Still there are imaginable corner cases where it would not be triggered,; // for example if the user changes the RooFit operation more after the error; // propagation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:450,error,error,450,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,2,['error'],['error']
Availability,// Reaching here means that parsing of the allegadly '{z}' mark yielded; // no errors.; // Query for the need of further parsing for a {%k<NUM>} mark,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp:79,error,errors,79,interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,1,['error'],['errors']
Availability,// Read .dynsym section header first if available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELF.h:40,avail,available,40,interpreter/llvm-project/llvm/include/llvm/Object/ELF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELF.h,1,['avail'],['available']
Availability,"// Read a class.rules file which contains one rule per line with comment; // starting with a #; // Returns the number of rules loaded.; // Returns -1 in case of error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:161,error,error,161,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['error'],['error']
Availability,"// Read a document from a binary msgpack blob, merging into anything already in; // the Document.; // The blob data must remain valid for the lifetime of this Document (because a; // string object in the document contains a StringRef into the original blob).; // If Multi, then this sets root to an array and adds top-level objects to it.; // If !Multi, then it only reads a single top-level object, even if there are; // more, and sets root to that.; // Returns false if failed due to illegal format or merge error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp:510,error,error,510,interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp,1,['error'],['error']
Availability,// Read an mask register from the opcode field of an instruction.; //; // @param insn - The instruction whose opcode field is to be read.; // @return - 0 on success; nonzero otherwise.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/Disassembler/X86Disassembler.cpp:11,mask,mask,11,interpreter/llvm-project/llvm/lib/Target/X86/Disassembler/X86Disassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/Disassembler/X86Disassembler.cpp,1,['mask'],['mask']
Availability,"// Read at least MinCount, and at most MaxCount integers separated by; // commas. The parser stops reading after fetching MaxCount integers; // or after an error occurs. Whenever the parser reads a comma, it; // expects an integer to follow.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rc/ResourceScriptParser.h:156,error,error,156,interpreter/llvm-project/llvm/tools/llvm-rc/ResourceScriptParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rc/ResourceScriptParser.h,1,['error'],['error']
Availability,"// Read the SDKSettings.json file for more information, like the SDK version; // that we can pass down to the compiler.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:98,down,down,98,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,1,['down'],['down']
Availability,"// Read the branch mask, target (if applicable), regmask (if applicable).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:19,mask,mask,19,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,1,['mask'],['mask']
Availability,// Read the first token after the arg list for down below.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:47,down,down,47,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,1,['down'],['down']
Availability,"// Read the next token to poison. While doing this, pretend that we are; // skipping while reading the identifier to poison.; // This avoids errors on code like:; // #pragma GCC poison X; // #pragma GCC poison X",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:141,error,errors,141,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,1,['error'],['errors']
Availability,"// Read the profile from ProfileFileName and assign the value to the; // instrumented BB and the edges. This function also updates ProgramMaxCount.; // Return true if the profile are successfully read, and false on errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:215,error,errors,215,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,1,['error'],['errors']
Availability,"// Read the profile variant flag from the header: "":FE"" means this is a FE; // generated profile. "":IR"" means this is an IR level profile. Other strings; // with a leading ':' will be reported an error format.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProfReader.cpp:196,error,error,196,interpreter/llvm-project/llvm/lib/ProfileData/InstrProfReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProfReader.cpp,1,['error'],['error']
Availability,"// ReadBuffer return kTRUE in case of failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TDirectoryFile.cxx:38,failure,failure,38,io/io/src/TDirectoryFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TDirectoryFile.cxx,2,['failure'],['failure']
Availability,"// ReadBuffer returns kTRUE in case of failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:39,failure,failure,39,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,1,['failure'],['failure']
Availability,"// ReadBuffer returns kTRUE in case of failure.; // Error(""GetCompressionFactor"",""%s failed to read the key header information at %lld (size=%d)."",; // GetName(),idcur,nwh);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:39,failure,failure,39,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,2,"['Error', 'failure']","['Error', 'failure']"
Availability,// Readjust mask for new input vector length.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:12,mask,mask,12,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,2,['mask'],['mask']
Availability,"// Reads and returns a single resource definition, or error message if any; // occurred.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rc/ResourceScriptParser.h:54,error,error,54,interpreter/llvm-project/llvm/tools/llvm-rc/ResourceScriptParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rc/ResourceScriptParser.h,1,['error'],['error']
Availability,// Really make sure we have at most 2 vectors used in the mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:58,mask,mask,58,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,1,['mask'],['mask']
Availability,"// Reassemble the low and high pieces reversed.; // NOTE: this Result is unmasked (because we do not need masks for; // shuffles). If in the future this has to change, we can use a SELECT_VL; // between Result and UNDEF using the mask originally passed to VP_REVERSE",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:106,mask,masks,106,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,2,['mask'],"['mask', 'masks']"
Availability,// Rebuild mask because Src may be from multiple EXTRACT_SUBVECTORs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:11,mask,mask,11,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['mask'],['mask']
Availability,"// Rebuild the ""equivalent"" type, which pushes __kindof down into; // the object type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:56,down,down,56,interpreter/llvm-project/clang/lib/AST/Type.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp,1,['down'],['down']
Availability,"// Rebuild the ""equivalent"" type, which pushes __kindof down into; // the object type.; // There is no need to apply kindof on an unqualified id type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:56,down,down,56,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,1,['down'],['down']
Availability,"// Rebuild the function type ""R"" without any parameters (in case any; // of the errors above fired) and with the conversion type as the; // return type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:80,error,errors,80,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['error'],['errors']
Availability,"// Rebuild the function type ""R"" without any type qualifiers (in; // case any of the errors above fired) and with ""void"" as the; // return type, since constructors don't have return types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:85,error,errors,85,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['error'],['errors']
Availability,"// Rebuild the function type ""R"" without any type qualifiers or; // parameters (in case any of the errors above fired) and with; // ""void"" as the return type, since destructors don't have return; // types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:99,error,errors,99,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['error'],['errors']
Availability,"// Recalculate the placement for Node, assuming that the locations of; // its children in Loc are valid.; // Return nullptr if there is no valid placement for Node (for example, it; // uses an index value that is not available at the location required; // to dominate all children, etc.).; // Find the nearest common dominator for:; // - all users, if the node is used, and; // - all children.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp:217,avail,available,217,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp,1,['avail'],['available']
Availability,// Recheck analysis passes to ensure that required analyses that; // are already checked are still available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:99,avail,available,99,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,1,['avail'],['available']
Availability,"// Reciprocal, < 1 ulp error.; //; // This reciprocal approximation converges to < 0.5 ulp error with one; // newton rhapson performed with two fused multiple adds (FMAs).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp:23,error,error,23,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,2,['error'],['error']
Availability,// Recognize the following pattern:; //; // AndVT = (and (sign_extend NarrowVT to AndVT) #bitmask); //; // where bitmask is a mask that clears the upper bits of AndVT. The; // number of bits in bitmask must be a power of two.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:126,mask,mask,126,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['mask']
Availability,"// Recomputes the Block Mask of Instr, a VPT or VPST instruction.; // This rebuilds the block mask of the instruction depending on the predicates; // of the instructions following it. This should only be used after the; // MVEVPTBlockInsertion pass has run, and should be used whenever a predicated; // instruction is added to/removed from the block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2InstrInfo.h:24,Mask,Mask,24,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2InstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2InstrInfo.h,2,"['Mask', 'mask']","['Mask', 'mask']"
Availability,"// Record if the value is defined in the same basic block.; //; // This information is crucial to know whether or not folding an; // operand is valid.; // Indeed, FastISel generates or reuses a virtual register for all; // operands of all instructions it selects. Obviously, the definition and; // its uses must use the same virtual register otherwise the produced; // code is incorrect.; // Before instruction selection, FunctionLoweringInfo::set sets the virtual; // registers for values that are alive across basic blocks. This ensures; // that the values are consistently set between across basic block, even; // if different instruction selection mechanisms are used (e.g., a mix of; // SDISel and FastISel).; // For values local to a basic block, the instruction selection process; // generates these virtual registers with whatever method is appropriate; // for its needs. In particular, FastISel and SDISel do not share the way; // local virtual registers are set.; // Therefore, this is impossible (or at least unsafe) to share values; // between basic blocks unless they use the same instruction selection; // method, which is not guarantee for X86.; // Moreover, things like hasOneUse could not be used accurately, if we; // allow to reference values across basic blocks whereas they are not; // alive across basic blocks initially.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:499,alive,alive,499,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,2,['alive'],['alive']
Availability,"// Record initial available workers",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizer.cxx:18,avail,available,18,proof/proofplayer/src/TPacketizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizer.cxx,1,['avail'],['available']
Availability,"// Record that a fatal error occurred only when we see a second; // non-note diagnostic. This allows notes to be attached to the; // fatal error, but suppresses any diagnostics that follow those; // notes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:23,error,error,23,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,2,['error'],['error']
Availability,// Record the available value to speed up subsequent uses of this; // SSAUpdater for the same value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h:14,avail,available,14,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h,1,['avail'],['available']
Availability,"// Record the failure's location if needed and return an empty correction. If; // this was an unqualified lookup and we believe the callback object did not; // filter out possible corrections, also cache the failure for the typo.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:14,failure,failure,14,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,2,['failure'],['failure']
Availability,"// Record the missed hint, we may be able to recover; // at the end if the surrounding allocation changed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:45,recover,recover,45,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,1,['recover'],['recover']
Availability,// Recover,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,1,['Recover'],['Recover']
Availability,"// Recover CFG block via reverse lookup.; // TODO: If we were to keep CFG element information as part of the CallEvent; // instead of doing this reverse lookup, we would be able to build the stack; // frame for non-expression-based calls, and also we wouldn't need the reverse; // lookup.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,1,['Recover'],['Recover']
Availability,// Recover as if it were an explicit specialization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,2,['Recover'],['Recover']
Availability,// Recover as if the tilde had been written before the identifier.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,1,['Recover'],['Recover']
Availability,// Recover as if the user wrote '::'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,1,['Recover'],['Recover']
Availability,// Recover by adding 'static'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['Recover'],['Recover']
Availability,// Recover by adding misplaced attributes to the attribute list; // of the class so they can be applied on the class later.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,1,['Recover'],['Recover']
Availability,// Recover by assuming we had the right type all along.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,2,['Recover'],['Recover']
Availability,"// Recover by creating a K&R-style function type, if possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,1,['Recover'],['Recover']
Availability,"// Recover by creating a compound statement with what we parsed so far,; // instead of dropping everything and returning StmtError().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,1,['Recover'],['Recover']
Availability,// Recover by discarding the default argument.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['Recover'],['Recover']
Availability,// Recover by dropping this type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['Recover'],['Recover']
Availability,// Recover by entering the module (Sema will diagnose).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp,1,['Recover'],['Recover']
Availability,// Recover by faking up an empty template argument list.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['Recover'],['Recover']
Availability,// Recover by falling back to int.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['Recover'],['Recover']
Availability,"// Recover by ignoring the 'typedef'. This was probably supposed to be; // the 'typename' keyword, which we should have already suggested adding; // if it's appropriate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,1,['Recover'],['Recover']
Availability,// Recover by ignoring the old declaration.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,2,['Recover'],['Recover']
Availability,// Recover by ignoring the partition name.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp,1,['Recover'],['Recover']
Availability,"// Recover by incorporating the other type chunks into the result type.; // Note, this does *not* change the name of the function. This is compatible; // with the GCC extension:; // struct S { &operator int(); } s;; // int &r = s.operator int(); // ok in GCC; // S::operator int&() {} // error in GCC, function name is 'operator int'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,2,"['Recover', 'error']","['Recover', 'error']"
Availability,// Recover by leaving immediately.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp,2,['Recover'],['Recover']
Availability,// Recover by leaving partition empty.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp,1,['Recover'],['Recover']
Availability,// Recover by making this an anonymous redefinition.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['Recover'],['Recover']
Availability,"// Recover by making this an anonymous redefinition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclExtractor.cpp:3,Recover,Recover,3,interpreter/cling/lib/Interpreter/DeclExtractor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclExtractor.cpp,1,['Recover'],['Recover']
Availability,"// Recover by marking the field invalid, unless we're in a SFINAE context.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['Recover'],['Recover']
Availability,// Recover by pretending this was an elaborated type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['Recover'],['Recover']
Availability,// Recover by removing the name,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['Recover'],['Recover']
Availability,// Recover by removing the storage specifier.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['Recover'],['Recover']
Availability,// Recover by setting the destructed type to the object type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,2,['Recover'],['Recover']
Availability,// Recover by setting the object type to the destructed type and the; // operator to '->'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['Recover'],['Recover']
Availability,// Recover by synthesizing a type using the location information that we; // already have.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['Recover'],['Recover']
Availability,// Recover by taking the template that we found in the object; // expression's type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['Recover'],['Recover']
Availability,// Recover by treating the 'typedef' as spurious.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,2,['Recover'],['Recover']
Availability,"// Recover from arrow accesses to records, e.g.:; // struct MyRecord foo;; // foo->bar; // This is actually well-formed in C++ if MyRecord has an; // overloaded operator->, but that should have been dealt with; // by now--or a diagnostic message already issued if a problem; // was encountered while looking for the overloaded operator->.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,1,['Recover'],['Recover']
Availability,"// Recover from dot accesses to pointers, e.g.:; // type *foo;; // foo.bar; // This is actually well-formed in two cases:; // - 'type' is an Objective C type; // - 'bar' is a pseudo-destructor name which happens to refer to; // the appropriate pointer type",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,1,['Recover'],['Recover']
Availability,// Recover from error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp,2,"['Recover', 'error']","['Recover', 'error']"
Availability,// Recover from errors reading the symbol table.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/COFFObjectFile.cpp:3,Recover,Recover,3,interpreter/llvm-project/llvm/lib/Object/COFFObjectFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/COFFObjectFile.cpp,2,"['Recover', 'error']","['Recover', 'errors']"
Availability,// Recover from misplaced ellipsis.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,3,['Recover'],['Recover']
Availability,// Recover from not-fully-formed macro invocation during code-completion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,1,['Recover'],['Recover']
Availability,// Recover from the common mistake of using 'set' instead of 'put'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['Recover'],['Recover']
Availability,"// Recover from type-hiding ambiguities by hiding the type. We'll; // do the lookup again when looking for an object, and we can; // diagnose the error then. If we don't do this, then the error; // about hiding the type will be immediately followed by an error; // that only makes sense if the identifier was treated like a type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,4,"['Recover', 'error']","['Recover', 'error']"
Availability,// Recover gracefully from an invalid redeclaration.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,2,['Recover'],['Recover']
Availability,// Recover location if it was changed in the above loop.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,1,['Recover'],['Recover']
Availability,// Recover location info for the operand if we know which was the problem.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp:3,Recover,Recover,3,interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,1,['Recover'],['Recover']
Availability,"// Recover old genreflex behaviour, i.e. do not print warnings due to glitches; // in the headers at runtime. This is not synonym of ignoring warnings as they; // will be printed at dictionary generation time.; // In order to do this we leverage the diagnostic pragmas and, since there is no; // way to express as a pragma the option ""-Wno-deprecated"" the; // _BACKWARD_BACKWARD_WARNING_H macro, used to avoid to go through; // backward/backward_warning.h.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/TModuleGenerator.cxx:3,Recover,Recover,3,core/dictgen/src/TModuleGenerator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/TModuleGenerator.cxx,1,['Recover'],['Recover']
Availability,// Recover parsing as a case statement.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,1,['Recover'],['Recover']
Availability,// Recover resources if we crash before exiting this function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,5,['Recover'],['Recover']
Availability,// Recover resources if we crash before exiting this method.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,19,['Recover'],['Recover']
Availability,"// Recover resources if we crash before exiting this method.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalParser.cpp:3,Recover,Recover,3,interpreter/cling/lib/Interpreter/IncrementalParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalParser.cpp,2,['Recover'],['Recover']
Availability,// Recover some path-sensitivity if a scalar value evaluated to; // UnknownVal.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,1,['Recover'],['Recover']
Availability,// Recover the QualType of an APSInt.; // TODO: Refactor to put elsewhere,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SMTConv.h:3,Recover,Recover,3,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SMTConv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SMTConv.h,1,['Recover'],['Recover']
Availability,// Recover the call stack,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.cpp:3,Recover,Recover,3,interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.cpp,1,['Recover'],['Recover']
Availability,// Recover the default target destination for each Switch statement; // reserved.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:3,Recover,Recover,3,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,1,['Recover'],['Recover']
Availability,// Recover the old value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/ProfileGenerator.cpp:3,Recover,Recover,3,interpreter/llvm-project/llvm/tools/llvm-profgen/ProfileGenerator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/ProfileGenerator.cpp,1,['Recover'],['Recover']
Availability,// Recover triple.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILWriterPass.cpp:3,Recover,Recover,3,interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILWriterPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILWriterPass.cpp,1,['Recover'],['Recover']
Availability,// Recover with 'int',MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['Recover'],['Recover']
Availability,// Recover with an 'int' type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['Recover'],['Recover']
Availability,"// Recovering from a bad clause is really difficult, so we just give up on; // error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:3,Recover,Recovering,3,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,2,"['Recover', 'error']","['Recovering', 'error']"
Availability,"// Recovery from invalid cases (e.g. D is an invalid Decl).; // We use the dependent type for the RecoveryExpr to prevent bogus follow-up; // diagnostics, as invalid decls use int as a fallback type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Recover,Recovery,3,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,2,['Recover'],"['Recovery', 'RecoveryExpr']"
Availability,"// RecoveryExpr is; // - always value-dependent, and therefore instantiation dependent; // - contains errors (ExprDependence::Error), by definition; // - type-dependent if we don't know the type (fallback to an opaque; // dependent type), or the type is known and dependent, or it has; // type-dependent subexpressions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:3,Recover,RecoveryExpr,3,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,3,"['Error', 'Recover', 'error']","['Error', 'RecoveryExpr', 'errors']"
Availability,"// Recursive function that attempts to find if a bool vector node was originally; // a vector/float/double that got truncated/extended/bitcast to/from a scalar; // integer. If so, replace the scalar ops with bool vector equivalents back down; // the chain.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:237,down,down,237,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['down'],['down']
Availability,"// Redefinition errors with modules are common with non modular mapped; // headers, example: a non-modular header H in module A that also gets; // included directly in a TU. Pointing twice to the same header/definition; // is confusing, try to get better diagnostics when modules is on.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:16,error,errors,16,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['error'],['errors']
Availability,"// Redundant def found: throw it away. Since the wedge of defs is being; // rebuilt, doing nothing is the same as deleting an entry.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:3,Redundant,Redundant,3,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,1,['Redundant'],['Redundant']
Availability,// Redundant switch so I don't have to repeat the code above; // for each case. There are more clever ways to avoid this; // extra switch and anyone can feel free to implement one of them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/MCA/AMDGPUCustomBehaviour.cpp:3,Redundant,Redundant,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/MCA/AMDGPUCustomBehaviour.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/MCA/AMDGPUCustomBehaviour.cpp,1,['Redundant'],['Redundant']
Availability,// RegId and MaskId are unchanged.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFRegisters.h:13,Mask,MaskId,13,interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFRegisters.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFRegisters.h,1,['Mask'],['MaskId']
Availability,"// Regardless masked or unmasked version, the number of operands is the; // same. For example, ""viota.m v0, v2"" is ""viota.m v0, v2, NoRegister""; // actually. We need to check the last operand to ensure whether it is; // masked or not.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:14,mask,masked,14,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,2,['mask'],['masked']
Availability,// Register a note to be produced if we encounter an error while; // declaring the special member.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:53,error,error,53,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['error'],['error']
Availability,"// Register debug object, return error message or null for success.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderGDB.cpp:33,error,error,33,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderGDB.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderGDB.cpp,1,['error'],['error']
Availability,"// Register dependencies, record whether any depenendency is in the error; // state.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:68,error,error,68,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,1,['error'],['error']
Availability,"// Register mask functions.; //; // Machine instructions may use a register mask operand to indicate that a; // large number of registers are clobbered by the instruction. This is; // typically used for calls.; //; // For compile time performance reasons, these clobbers are not recorded in; // the live intervals for individual physical registers. Instead,; // LiveIntervalAnalysis maintains a sorted list of instructions with; // register mask operands.; /// Returns a sorted array of slot indices of all instructions with; /// register mask operands.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:12,mask,mask,12,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,4,['mask'],['mask']
Availability,// Register mask i clobbers PhysReg before the LIU interference.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp:12,mask,mask,12,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp,1,['mask'],['mask']
Availability,// Register mask i-1 clobbers PhysReg after the LIU interference.; // Model the regmask clobber as a dead def.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp:12,mask,mask,12,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp,1,['mask'],['mask']
Availability,// Register masks attached to the current instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:12,mask,masks,12,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,1,['mask'],['masks']
Availability,// Register the destructor function calling __cxa_atexit if it is; // available. Otherwise fall back on calling atexit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp:70,avail,available,70,interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,1,['avail'],['available']
Availability,"// Rehash all the items into their new buckets. Luckily :) we already have; // the hash values available, so we don't have to rehash any strings.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/StringMap.cpp:95,avail,available,95,interpreter/llvm-project/llvm/lib/Support/StringMap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/StringMap.cpp,1,['avail'],['available']
Availability,// Reject trivial all-zero masks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:27,mask,masks,27,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,1,['mask'],['masks']
Availability,"// Relative tolerance for bin boundary comparison",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataHist.cxx:12,toler,tolerance,12,roofit/roofitcore/src/RooDataHist.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataHist.cxx,1,['toler'],['tolerance']
Availability,// Release the Builder when there is no error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ModuleBuilder.cpp:40,error,error,40,interpreter/llvm-project/clang/lib/CodeGen/ModuleBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ModuleBuilder.cpp,1,['error'],['error']
Availability,// Releases a slot from every buffered resource in mask `ConsumedBuffers`.; // ConsumedBuffers is a bitmask of previously acquired buffers (using method; // `reserveBuffers`). Units that are dispatch hazards (i.e. BufferSize=0) are; // not automatically unreserved by this method.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h:51,mask,mask,51,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,1,['mask'],['mask']
Availability,"// Relocation masks following the #lo(value), #hi(value), #ha(value),; // #higher(value), #highera(value), #highest(value), and #highesta(value); // macros defined in section 4.5.1. Relocation Types of the PPC-elf64abi; // document.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:14,mask,masks,14,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,1,['mask'],['masks']
Availability,// Rematerializable instructions should always be hoisted providing the; // register allocator can just pull them down again when needed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:114,down,down,114,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,1,['down'],['down']
Availability,"// Remember source that's copied to Def. Once it's clobbered, then; // it's no longer available for copy propagation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:86,avail,available,86,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,1,['avail'],['available']
Availability,// Remember that this phi makes the value alive in this block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:42,alive,alive,42,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,1,['alive'],['alive']
Availability,"// Remember the broadcast mask. If no better candidates are found, this Op; // and Mask will be used in the final shuffle.; // Zero splat can be used as identity too, since it might be used with; // mask <0, 1, 2, ...>, i.e. identity mask without extra reshuffling.; // E.g. if need to shuffle the vector with the mask <3, 1, 2, 0>, which is; // expensive, the analysis founds out, that the source vector is just a; // broadcast, this original mask can be transformed to identity mask <0,; // 1, 2, 3>.; // \code; // %0 = shuffle %v, poison, zeroinitalizer; // %res = shuffle %0, poison, <3, 1, 2, 0>; // \endcode; // may be transformed to; // \code; // %0 = shuffle %v, poison, zeroinitalizer; // %res = shuffle %0, poison, <0, 1, 2, 3>; // \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:26,mask,mask,26,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,7,"['Mask', 'mask']","['Mask', 'mask']"
Availability,"// Remember the identity or broadcast mask, if it is not a resizing; // shuffle. If no better candidates are found, this Op and Mask will be; // used in the final shuffle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:38,mask,mask,38,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,2,"['Mask', 'mask']","['Mask', 'mask']"
Availability,// Remember the repairing placement for all the operands.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:16,repair,repairing,16,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,1,['repair'],['repairing']
Availability,// Remember this state to assert later that a non-infinite register; // option was available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegAllocPBQP.h:83,avail,available,83,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegAllocPBQP.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegAllocPBQP.h,1,['avail'],['available']
Availability,// Remember which arguments are still alive.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:38,alive,alive,38,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,1,['alive'],['alive']
Availability,"// Remove PHI nodes that did not have any uses rewritten or add them to; // PHIsToRemove, so the caller can remove them after some additional cleanup.; // We need to redo the use_empty() check here, because even if the PHI node; // wasn't used when added to LocalPHIsToRemove, later added PHI nodes can be; // using it. This cleanup is not guaranteed to handle trees/cycles of PHI; // nodes that only are used by each other. Such situations has only been; // noticed when the input IR contains unreachable code, and leaving some extra; // redundant PHI nodes in such situations is considered a minor problem.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:539,redundant,redundant,539,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,1,['redundant'],['redundant']
Availability,// Remove Proxy Register pseudo instructions used to keep `callseq_end` alive.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp:72,alive,alive,72,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp,1,['alive'],['alive']
Availability,// Remove SU from Available set and update HazardRec.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:18,Avail,Available,18,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,1,['Avail'],['Available']
Availability,// Remove a masked store if base pointers and masks are equal.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:12,mask,masked,12,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['mask'],"['masked', 'masks']"
Availability,// Remove all bits that are set by this mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ExpandImm.cpp:40,mask,mask,40,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ExpandImm.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ExpandImm.cpp,1,['mask'],['mask']
Availability,"// Remove all interfaces this pass implements, for which it is also; // listed as the available implementation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:86,avail,available,86,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,1,['avail'],['available']
Availability,"// Remove an assume if it is followed by an identical assume.; // TODO: Do we need this? Unless there are conflicting assumptions, the; // computeKnownBits(IIOperand) below here eliminates redundant assumes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:189,redundant,redundant,189,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,1,['redundant'],['redundant']
Availability,// Remove an entry from the free list in Bucket[Idx] and return it.; // Return NULL if no entries are available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ArrayRecycler.h:102,avail,available,102,interpreter/llvm-project/llvm/include/llvm/Support/ArrayRecycler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ArrayRecycler.h,1,['avail'],['available']
Availability,// Remove any and instructions that are now redundant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:44,redundant,redundant,44,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['redundant'],['redundant']
Availability,"// Remove any errors set by GetBuffer(); note that if the argument was an array; // that failed to extract because of a type mismatch, the following will perform; // a (rather inefficient) copy. No warning is issued b/c e.g. numpy doesn't do; // so either.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx:14,error,errors,14,bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx,1,['error'],['errors']
Availability,"// Remove avail extern fns and globals definitions since we aren't compiling; // an object file for later LTO. For LTO we want to preserve these so they; // are eligible for inlining at link-time. Note if they are unreferenced they; // will be removed by GlobalDCE later, so this only impacts referenced; // available externally globals. Eventually they will be suppressed during; // codegen, but eliminating here enables more opportunity for GlobalDCE as it; // may make globals referenced by available external functions dead and saves; // running remaining passes on the eliminated functions. These should be; // preserved during prelinking for link-time inlining decisions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:10,avail,avail,10,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,3,['avail'],"['avail', 'available']"
Availability,// Remove avx512.mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:17,mask,mask,17,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,1,['mask'],['mask']
Availability,// Remove dbg.assigns linked to the alloca as these are now redundant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:60,redundant,redundant,60,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,3,['redundant'],['redundant']
Availability,// Remove dead registers or mask bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNRegPressure.cpp:28,mask,mask,28,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNRegPressure.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNRegPressure.cpp,1,['mask'],['mask']
Availability,"// Remove debug intrinsics which describe the value contained within the; // alloca. In addition to removing dbg.{declare,addr} which simply point to; // the alloca, remove dbg.value(<alloca>, ..., DW_OP_deref)'s as well, e.g.:; //; // ```; // define void @foo(i32 %0) {; // %a = alloca i32 ; Deleted.; // store i32 %0, i32* %a; // dbg.value(i32 %0, ""arg0"") ; Not deleted.; // dbg.value(i32* %a, ""arg0"", DW_OP_deref) ; Deleted.; // call void @trivially_inlinable_no_op(i32* %a); // ret void; // }; // ```; //; // This may not be required if we stop describing the contents of allocas; // using dbg.value(<alloca>, ..., DW_OP_deref), but we currently do this in; // the LowerDbgDeclare utility.; //; // If there is a dead store to `%a` in @trivially_inlinable_no_op, the; // ""arg0"" dbg.value may be stale after the call. However, failing to remove; // the DW_OP_deref dbg.value causes large gaps in location coverage.; //; // FIXME: the Assignment Tracking project has now likely made this; // redundant (and it's sometimes harmful).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:993,redundant,redundant,993,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['redundant'],['redundant']
Availability,"// Remove functions imported as available externally defs from comdats,; // as this is a declaration for the linker, and will be dropped eventually.; // It is illegal for comdats to contain declarations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:32,avail,available,32,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,1,['avail'],['available']
Availability,// Remove high part of known bit mask,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:33,mask,mask,33,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['mask'],['mask']
Availability,// Remove locks first to allow lock upgrading/downgrading.; // FIXME -- should only fully remove if the attribute refers to 'this'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:46,down,downgrading,46,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,1,['down'],['downgrading']
Availability,// Remove low part of known bits mask,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:33,mask,mask,33,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['mask'],['mask']
Availability,"// Remove pending etc decls in case of error; the asserts in StartModule(); // will rightfully be confused otherwise, as none of the decls were; // emitted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ModuleBuilder.cpp:39,error,error,39,interpreter/llvm-project/clang/lib/CodeGen/ModuleBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ModuleBuilder.cpp,1,['error'],['error']
Availability,"// Remove ranges of all clobbered registers. Register masks don't usually; // list SP as preserved. Assume that call instructions never clobber SP,; // because some backends (e.g., AArch64) never list SP in the regmask.; // While the debug info may be off for an instruction or two around; // callee-cleanup calls, transferring the DEBUG_VALUE across the call is; // still a better user experience.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:54,mask,masks,54,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,1,['mask'],['masks']
Availability,// Remove redundant Copy instructions unless TargetReg is modified.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRedundantCopyElimination.cpp:10,redundant,redundant,10,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRedundantCopyElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRedundantCopyElimination.cpp,1,['redundant'],['redundant']
Availability,// Remove redundant DBG_VALUEs first.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:10,redundant,redundant,10,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,1,['redundant'],['redundant']
Availability,// Remove redundant LEA instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86OptimizeLEAs.cpp:10,redundant,redundant,10,interpreter/llvm-project/llvm/lib/Target/X86/X86OptimizeLEAs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86OptimizeLEAs.cpp,1,['redundant'],['redundant']
Availability,// Remove redundant SI_END_CF instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerControlFlow.cpp:10,redundant,redundant,10,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerControlFlow.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerControlFlow.cpp,1,['redundant'],['redundant']
Availability,// Remove redundant address calculations. Do it only for -Os/-Oz since only; // a code size gain is expected from this part of the pass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86OptimizeLEAs.cpp:10,redundant,redundant,10,interpreter/llvm-project/llvm/lib/Target/X86/X86OptimizeLEAs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86OptimizeLEAs.cpp,1,['redundant'],['redundant']
Availability,// Remove redundant back-copies that are now known to be dominated by another; // def with the same value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:10,redundant,redundant,10,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,1,['redundant'],['redundant']
Availability,// Remove redundant call to the outlined function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:10,redundant,redundant,10,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,2,['redundant'],['redundant']
Availability,// Remove redundant case,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:10,redundant,redundant,10,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,1,['redundant'],['redundant']
Availability,// Remove redundant copy instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetMachine.cpp:10,redundant,redundant,10,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetMachine.cpp,1,['redundant'],['redundant']
Availability,// Remove redundant copy/move instructions unless KnownReg is modified.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64RedundantCopyElimination.cpp:10,redundant,redundant,10,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64RedundantCopyElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64RedundantCopyElimination.cpp,1,['redundant'],['redundant']
Availability,"// Remove redundant entries. As well as reducing memory consumption and; // avoiding waiting cycles later by burning some now, this has another; // important job. That is to work around some SelectionDAG quirks. See; // removeRedundantDbgLocsUsingForwardScan comments for more info on that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:10,redundant,redundant,10,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,1,['redundant'],['redundant']
Availability,// Remove redundant induction instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:10,redundant,redundant,10,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['redundant'],['redundant']
Availability,// Remove redundant insertions:; // (insert_vector_elt x (extract_vector_elt x idx) idx) -> x,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:10,redundant,redundant,10,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['redundant'],['redundant']
Availability,"// Remove redundant leading ""./"" pieces and consecutive separators.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/FileCollector.cpp:10,redundant,redundant,10,interpreter/llvm-project/llvm/lib/Support/FileCollector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/FileCollector.cpp,1,['redundant'],['redundant']
Availability,// Remove redundant physreg dead defs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp:10,redundant,redundant,10,interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,2,['redundant'],['redundant']
Availability,// Remove redundant spills or change them to dead instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:10,redundant,redundant,10,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,1,['redundant'],['redundant']
Availability,"// Remove spill-reload like copy chains. For example; // r0 = COPY r1; // r1 = COPY r2; // r2 = COPY r3; // r3 = COPY r4; // <def-use r4>; // r4 = COPY r3; // r3 = COPY r2; // r2 = COPY r1; // r1 = COPY r0; // will be folded into; // r0 = COPY r1; // r1 = COPY r4; // <def-use r4>; // r4 = COPY r1; // r1 = COPY r0; // TODO: Currently we don't track usage of r0 outside the chain, so we; // conservatively keep its value as it was before the rewrite.; //; // The algorithm is trying to keep; // property#1: No Def of spill COPY in the chain is used or defined until the; // paired reload COPY in the chain uses the Def.; //; // property#2: NO Source of COPY in the chain is used or defined until the next; // COPY in the chain defines the Source, except the innermost spill-reload; // pair.; //; // The algorithm is conducted by checking every COPY inside the MBB, assuming; // the COPY is a reload COPY, then try to find paired spill COPY by searching; // the COPY defines the Src of the reload COPY backward. If such pair is found,; // it either belongs to an existing chain or a new chain depends on; // last available COPY uses the Def of the reload COPY.; // Implementation notes, we use CopyTracker::findLastDefCopy(Reg, ...) to find; // out last COPY that defines Reg; we use CopyTracker::findLastUseCopy(Reg, ...); // to find out last COPY that uses Reg. When we are encountered with a Non-COPY; // instruction, we check registers in the operands of this instruction. If this; // Reg is defined by a COPY, we untrack this Reg via; // CopyTracker::clobberRegister(Reg, ...).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:1112,avail,available,1112,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,1,['avail'],['available']
Availability,// Remove the 'volatile' from the type to recover.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:42,recover,recover,42,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['recover'],['recover']
Availability,// Remove the leading 1 from the resource group mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/InstrBuilder.cpp:48,mask,mask,48,interpreter/llvm-project/llvm/lib/MCA/InstrBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/InstrBuilder.cpp,2,['mask'],['mask']
Availability,// Remove the old edge but remember the edge probability so we can calculate; // the correct weights on the new edges being added further down.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:138,down,down,138,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,1,['down'],['down']
Availability,"// Remove the packages already available",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressProof.cxx:31,avail,available,31,test/stressProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressProof.cxx,1,['avail'],['available']
Availability,// Remove the ref qualifier to recover.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:31,recover,recover,31,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['recover'],['recover']
Availability,// Remove the temporary files in \p FileName. Typically used in conjunction; // with prepareTempFiles. Return first error code (if any) and stop..,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PrintPasses.h:116,error,error,116,interpreter/llvm-project/llvm/include/llvm/IR/PrintPasses.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PrintPasses.h,1,['error'],['error']
Availability,// Remove unreachable blocks. It is not valuable to assign them a color and; // their existence can trick us into thinking values are alive when they are; // not.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:134,alive,alive,134,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,1,['alive'],['alive']
Availability,// Remove usable registers clobbered by this mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:45,mask,mask,45,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,1,['mask'],['mask']
Availability,// Reorder reuses mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:18,mask,mask,18,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['mask'],['mask']
Availability,// Reorder scalars and build final mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:35,mask,mask,35,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['mask'],['mask']
Availability,// Repair indexes after adding and removing instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SlotIndexes.cpp:3,Repair,Repair,3,interpreter/llvm-project/llvm/lib/CodeGen/SlotIndexes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SlotIndexes.cpp,1,['Repair'],['Repair']
Availability,"// Repairings for definitions happen after MI, uses happen before.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:3,Repair,Repairings,3,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,1,['Repair'],['Repairings']
Availability,// Repeated catch clause - drop the redundant copy.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:36,redundant,redundant,36,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['redundant'],['redundant']
Availability,// Repeatedly pack down to the target size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:19,down,down,19,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['down'],['down']
Availability,// Replace (mul & mask) --> zext (mul.with.overflow & short_mask),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:18,mask,mask,18,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['mask'],['mask']
Availability,// Replace (or supplement) instructions accessing live mask.; // This can only happen once all the live mask registers have been created; // and the execute state (WQM/StrictWWM/Exact) of instructions is known.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp:55,mask,mask,55,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,2,['mask'],['mask']
Availability,"// Replace @llvm.get.active.mask() with the ARM specific VCTP intrinic, and; // thus represent the effect of tail predication.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp:28,mask,mask,28,interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp,1,['mask'],['mask']
Availability,// Replace VSELECT with non-mask conditions with with BLENDV/VPTERNLOG.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:28,mask,mask,28,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,"// Replace a SCALAR_TO_VECTOR with a SCALAR_TO_VECTOR_PERMUTED except if; // the original is:; // (<n x Ty> (scalar_to_vector (Ty (extract_elt <n x Ty> %a, C)))); // In such a case, just change the shuffle mask to extract the element; // from the permuted index.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:206,mask,mask,206,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['mask'],['mask']
Availability,// Replace a masked intrinsic with an older unmasked intrinsic.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:13,mask,masked,13,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,1,['mask'],['masked']
Availability,// Replace predicated replicate recipe with a replicate recipe without a; // mask but in the replicate region.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:77,mask,mask,77,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,1,['mask'],['mask']
Availability,// Replace resource masks with valid resource processor IDs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/Stages/ExecuteStage.cpp:20,mask,masks,20,interpreter/llvm-project/llvm/lib/MCA/Stages/ExecuteStage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/Stages/ExecuteStage.cpp,2,['mask'],['masks']
Availability,// Replace target shuffle mask elements with known undef/zero sentinels.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:26,mask,mask,26,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Replace the constant with the zero extend mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:45,mask,mask,45,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Replace the expression with a corrected version and continue so we; // can find further errors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:91,error,errors,91,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['error'],['errors']
Availability,// Replace the original terminator with BranchOnCond. We have to invert the; // mask here because a true condition means jumping to the exit block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:80,mask,mask,80,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,1,['mask'],['mask']
Availability,"// Replace the shuffle mask element at the index of this extract+insert with; // that same index value.; // For example:; // inselt (shuf X, IdMask), (extelt X, IdxC), IdxC --> shuf X, IdMask'",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:23,mask,mask,23,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['mask'],['mask']
Availability,"// Replace the shuffle mask element at the index of this insert with a zero.; // For example:; // inselt (shuf (inselt undef, X, 0), _, <0,undef,0,undef>), X, 1; // --> shuf (inselt undef, X, 0), poison, <0,0,0,undef>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:23,mask,mask,23,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['mask'],['mask']
Availability,"// Replace the undef by the poison, in the mask it is replaced by; // non-poisoned scalar already.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:43,mask,mask,43,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['mask'],['mask']
Availability,"// Replace unary minus to avoid compilation error on Windows:; // ""unary minus operator applied to unsigned type, result still unsigned""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/MathExtras.h:44,error,error,44,interpreter/llvm-project/llvm/include/llvm/Support/MathExtras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/MathExtras.h,1,['error'],['error']
Availability,"// Replacement '::' -> ':' is not allowed, just issue respective error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:65,error,error,65,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,1,['error'],['error']
Availability,"// Replacements from \p Replaces must be conflict-free already, so we can; // simply consume the error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:97,error,error,97,interpreter/llvm-project/clang/lib/Format/Format.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp,1,['error'],['error']
Availability,// Replicate the behaviour from the lane mask generation loop above.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp:41,mask,mask,41,interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp,1,['mask'],['mask']
Availability,"// Replicate ties between the operands, which addOperand was not; // able to do reliably.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:80,reliab,reliably,80,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,1,['reliab'],['reliably']
Availability,// Report IP range only for blocks with Faulty inst,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp:40,Fault,Faulty,40,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,1,['Fault'],['Faulty']
Availability,// Report a fatal error if this file contained directives.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp:18,error,error,18,interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp,1,['error'],['error']
Availability,// Report an error for out of range values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:13,error,error,13,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,5,['error'],['error']
Availability,// Report an error if some definition overrides ifunc.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp:13,error,error,13,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,1,['error'],['error']
Availability,// Report an error if the field expression does not have signedness.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:13,error,error,13,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,1,['error'],['error']
Availability,// Report an error if there are any.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:13,error,error,13,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,1,['error'],['error']
Availability,// Report an error if there was an attempt to return FP values via XMM; // registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp:13,error,error,13,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,1,['error'],['error']
Availability,// Report an error if we have attempted to return a value via an XMM; // register and SSE was disabled.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp:13,error,error,13,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,1,['error'],['error']
Availability,// Report an error in case none of the invalidation methods are declared.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp:13,error,error,13,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,1,['error'],['error']
Availability,// Report an error in case none of the invalidation methods are implemented.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp:13,error,error,13,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,1,['error'],['error']
Availability,// Report an error that the config file could not be found.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:13,error,error,13,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['error'],['error']
Availability,"// Report an error the target doesn't support Mips32r2 or later.; // The epilogue relies on the use of the ""ehb"" to clear execution; // hazards. Pre R2 Mips relies on an implementation defined number; // of ""ssnop""s to clear the execution hazard. Support for ssnop hazard; // clearing is not provided so reject that configuration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:13,error,error,13,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,1,['error'],['error']
Availability,"// Report an error when seeing an entry that is too large for the; // current index type (unsigned short). When hitting this, the type; // of SignatureTable will need to be changed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp:13,error,error,13,interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp,1,['error'],['error']
Availability,"// Report an error, if preprocessor control stack for the current; // file is not empty.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGLexer.cpp:13,error,error,13,interpreter/llvm-project/llvm/lib/TableGen/TGLexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGLexer.cpp,1,['error'],['error']
Availability,"// Report an error, if we reach EOF with non-empty preprocessing control; // stack. This means there is no matching #endif for the previous; // #ifdef/#else.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGLexer.h:13,error,error,13,interpreter/llvm-project/llvm/lib/TableGen/TGLexer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGLexer.h,1,['error'],['error']
Availability,"// Report any errors if occur during the configuration proceedings",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TSimpleAnalysis.cxx:14,error,errors,14,tree/treeplayer/src/TSimpleAnalysis.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TSimpleAnalysis.cxx,1,['error'],['errors']
Availability,// Report as many errors as possible before aborting the compilation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp:18,error,errors,18,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp,1,['error'],['errors']
Availability,// Report deallocator mismatch. Remove the region from tracking - reporting a; // missing free error after this one is redundant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:95,error,error,95,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,2,"['error', 'redundant']","['error', 'redundant']"
Availability,// Report error at any name conflict.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:10,error,error,10,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['error'],['error']
Availability,"// Report error if a mapper is specified, but cannot be found.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:10,error,error,10,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['error'],['error']
Availability,// Report error if cmse entry function returns structure through first ptr arg.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:10,error,error,10,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['error'],['error']
Availability,"// Report error if there are non-trapping sanitizers that require; // c++abi-specific parts of UBSan runtime, and they are not provided by the; // toolchain. We don't have a good way to check the latter, so we just; // check if the toolchan supports vptr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp:10,error,error,10,interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,1,['error'],['error']
Availability,// Report error if user explicitly tries to disable recovery from; // always recoverable sanitizer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp:10,error,error,10,interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,3,"['error', 'recover']","['error', 'recoverable', 'recovery']"
Availability,// Report error if user explicitly tries to recover from unrecoverable; // sanitizer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp:10,error,error,10,interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,2,"['error', 'recover']","['error', 'recover']"
Availability,// Report error when multiple profiles have been specified for the same; // function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp:10,error,error,10,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp,2,['error'],['error']
Availability,// Report the ELF load error if YAML failed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp:23,error,error,23,interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/InstrumentationMap.cpp,1,['error'],['error']
Availability,"// Report this specific error to the caller instead of emitting a; // diagnostic, as requested.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:24,error,error,24,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['error'],['error']
Availability,"// Represents operands 2 to 5 of the ROTATE AND ... SELECTED BITS operation; // given by Opcode. The operands are: Input (R2), Start (I3), End (I4) and; // Rotate (I5). The combined operand value is effectively:; //; // (or (rotl Input, Rotate), ~Mask); //; // for RNSBG and:; //; // (and (rotl Input, Rotate), Mask); //; // otherwise. The output value has BitSize bits, although Input may be; // narrower (in which case the upper bits are don't care), or wider (in which; // case the result will be truncated as part of the operation).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:247,Mask,Mask,247,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,2,['Mask'],['Mask']
Availability,"// Request that that the given symbols be materialized. The bool element of; // each pair indicates whether the symbol must be initialized, or whether it; // is optional. If any required symbol is not found then the pushSymbols; // function will return an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/MachOPlatform.h:256,error,error,256,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/MachOPlatform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/MachOPlatform.h,1,['error'],['error']
Availability,// Required field for all ErrorInfo derivatives.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp:26,Error,ErrorInfo,26,interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp,1,['Error'],['ErrorInfo']
Availability,"// Requires SXTB/SXTH, available on v6 and up in both ARM and Thumb modes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:23,avail,available,23,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['avail'],['available']
Availability,"// Rerun the compiler, capturing any error messages to print them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:37,error,error,37,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,1,['error'],['error']
Availability,"// Res = (CMPB & Mask) | (~CMPB & Alt); // Which, as suggested here:; // https://graphics.stanford.edu/~seander/bithacks.html#MaskedMerge; // can be written as:; // Res = Alt ^ ((Alt ^ Mask) & CMPB); // useful because the (Alt ^ Mask) can be pre-computed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:17,Mask,Mask,17,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,4,['Mask'],"['Mask', 'MaskedMerge']"
Availability,// Res = Mask & CMPB,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:9,Mask,Mask,9,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['Mask'],['Mask']
Availability,// Reserve a processor resource. A reserved resource is not available for; // instruction issue until it is released.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h:60,avail,available,60,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,1,['avail'],['available']
Availability,// Reserve one bit per register for the masks described above.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:40,mask,masks,40,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['mask'],['masks']
Availability,// Reserve the maximal amount of bits so there is no need to mask out the; // remaining ones. We will not encode anything else in the pointer anyway.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:61,mask,mask,61,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['mask'],['mask']
Availability,"// Reserve this buffer now, and release it once pipeline resources; // consumed by the instruction become available again.; // We do this to simulate an in-order dispatch/issue of instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/ResourceManager.cpp:106,avail,available,106,interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/ResourceManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/ResourceManager.cpp,1,['avail'],['available']
Availability,// ReserveRegister[i] - Register #i is not available as a general purpose; // register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcSubtarget.h:43,avail,available,43,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcSubtarget.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcSubtarget.h,1,['avail'],['available']
Availability,// ReserveXRegisterForRA[i] - X#i is not available for register allocator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Subtarget.h:41,avail,available,41,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Subtarget.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Subtarget.h,1,['avail'],['available']
Availability,// ReserveXRegister[i] - X#i is not available as a general purpose register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Subtarget.h:36,avail,available,36,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Subtarget.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Subtarget.h,1,['avail'],['available']
Availability,// Reserved for control flow mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp:29,mask,mask,29,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp,1,['mask'],['mask']
Availability,// Reserved for memory access mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp:30,mask,mask,30,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp,1,['mask'],['mask']
Availability,"// Reserved; // The record count is the number of logical records. In principle, this value; // is available as OS.logicalRecords(). However, some tools rely on this field; // being zero.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/GOFFObjectWriter.cpp:99,avail,available,99,interpreter/llvm-project/llvm/lib/MC/GOFFObjectWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/GOFFObjectWriter.cpp,1,['avail'],['available']
Availability,"// Reserving space in sets once performs better than doing so continuously; // and pays easily for double look-ups (even in Dense with SparseUniverseMax; // tuned all the way down) and double iteration (the second one is over a; // SmallVector, which is a lot cheaper compared to DenseSet or BitVector).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:175,down,down,175,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,1,['down'],['down']
Availability,"// Reset check of the available method list",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/DaemonUtils.cxx:22,avail,available,22,net/rpdutils/src/DaemonUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/DaemonUtils.cxx,1,['avail'],['available']
Availability,"// Reset data for all summaries. Alive and DSO local will be set back from; // of data flow results below. Anything else will not be accessed; // by ThinLTO backend, so we can save on bitcode size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp:33,Alive,Alive,33,interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,1,['Alive'],['Alive']
Availability,"// Reset error and check that server connected",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/sql/mysql/src/TMySQLServer.cxx:9,error,error,9,sql/mysql/src/TMySQLServer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/sql/mysql/src/TMySQLServer.cxx,2,['error'],['error']
Availability,"// Reset error and check that statement exists",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/sql/mysql/src/TMySQLStatement.cxx:9,error,error,9,sql/mysql/src/TMySQLStatement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/sql/mysql/src/TMySQLStatement.cxx,3,['error'],['error']
Availability,"// Reset error, if given.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Regex.cpp:9,error,error,9,interpreter/llvm-project/llvm/lib/Support/Regex.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Regex.cpp,1,['error'],['error']
Availability,// Reset mask to identity.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:9,mask,mask,9,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['mask']
Availability,// Reset our undef status after accounting for the mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:51,mask,mask,51,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['mask'],['mask']
Availability,// Reset the bit in the mask so that the static variable may be; // reinitialized.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp:24,mask,mask,24,interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp,1,['mask'],['mask']
Availability,"// Reset the cloned model's error counters.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooGenContext.cxx:28,error,error,28,roofit/roofitcore/src/RooGenContext.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooGenContext.cxx,1,['error'],['error']
Availability,// Reset the current state of used frame indexes. After invocation of; // this function all frame indexes are available for allocation with; // the exception of slots reserved for landing pad processing (if any).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp:110,avail,available,110,interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp,1,['avail'],['available']
Availability,// Reset the current state to make all resources available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:49,avail,available,49,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,1,['avail'],['available']
Availability,// Reset the inner alloca insertion as it will be used for loading the values; // wrapped into pointers before passing them into the to-be-outlined region.; // Configure it to insert immediately after the fake use of zero address so; // that they are available in the generated body and so that the; // OpenMP-related values (thread ID and zero address pointers) remain leading; // in the argument list.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:251,avail,available,251,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,1,['avail'],['available']
Availability,// Reset the state to opened with no error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:37,error,error,37,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,1,['error'],['error']
Availability,// Reset token type in case we have already looked at it and then; // recovered from an error (e.g. failure to find the matching >).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:70,recover,recovered,70,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,3,"['error', 'failure', 'recover']","['error', 'failure', 'recovered']"
Availability,"// Reshuffle to get only unique values.; // If some of the scalars are duplicated in the vectorization; // tree entry, we do not vectorize them but instead generate a; // mask for the reuses. But if there are several users of the; // same entry, they may have different vectorization factors.; // This is especially important for PHI nodes. In this case, we; // need to adapt the resulting instruction for the user; // vectorization factor and have to reshuffle it again to take; // only unique elements of the vector. Without this code the; // function incorrectly returns reduced vector instruction with; // the same elements, not with the unique ones.; // block:; // %phi = phi <2 x > { .., %entry} {%shuffle, %block}; // %2 = shuffle <2 x > %phi, poison, <4 x > <1, 1, 0, 0>; // ... (use %2); // %shuffle = shuffle <2 x> %2, poison, <2 x> {2, 0}; // br %block",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:171,mask,mask,171,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['mask'],['mask']
Availability,// Resolve the target shuffle inputs and mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:41,mask,mask,41,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Resource at index 0 is the 'InvalidUnit'. Set an invalid mask for it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/Support.cpp:60,mask,mask,60,interpreter/llvm-project/llvm/lib/MCA/Support.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/Support.cpp,1,['mask'],['mask']
Availability,"// Resource leaks can result in multiple warning that describe the same kind; // of programming error:; // void f() {; // FILE *F = fopen(""a.txt"");; // if (rand()) // state split; // return; // warning; // } // warning; // While this isn't necessarily true (leaking the same stream could result; // from a different kinds of errors), the reduction in redundant reports; // makes this a worthwhile heuristic.; // FIXME: Add a checker option to turn this uniqueing feature off.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:96,error,error,96,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,3,"['error', 'redundant']","['error', 'errors', 'redundant']"
Availability,// Resove all the relocations we can.; // FIXME: Error out if there are unresolved relocations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rtdyld/llvm-rtdyld.cpp:49,Error,Error,49,interpreter/llvm-project/llvm/tools/llvm-rtdyld/llvm-rtdyld.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rtdyld/llvm-rtdyld.cpp,1,['Error'],['Error']
Availability,// Respect error limit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:11,error,error,11,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp,2,['error'],['error']
Availability,// Restore the EXEC mask,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp:20,mask,mask,20,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,1,['mask'],['mask']
Availability,// Restore the EXEC mask after the loop.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp:20,mask,mask,20,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,1,['mask'],['mask']
Availability,// Restore the mask for previous partially matched values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:15,mask,mask,15,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['mask'],['mask']
Availability,"// Restore unused scalars from mask, if some of the extractelements were not; // selected for shuffle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:31,mask,mask,31,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['mask'],['mask']
Availability,"// Restrict available domains to the ones in common with the operand.; // If there are no common domains, we must pay the cross-domain; // penalty for this operand.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp:12,avail,available,12,interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp,1,['avail'],['available']
Availability,// Restrict the mask to the extended operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:16,mask,mask,16,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,// Restrict to a single domain available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:31,avail,available,31,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,1,['avail'],['available']
Availability,// RetT might be an Error or Expected value. Set the checked flag now:; // we don't want the user to have to check the unused result if this; // operation fails.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/WrapperFunctionUtils.h:20,Error,Error,20,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/WrapperFunctionUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/WrapperFunctionUtils.h,1,['Error'],['Error']
Availability,"// Retrieve remote errors and feed into local error queue",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealMPFE.cxx:19,error,errors,19,roofit/roofitcore/src/RooRealMPFE.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealMPFE.cxx,2,['error'],"['error', 'errors']"
Availability,"// Retrieve the list of available query results",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressProof.cxx:24,avail,available,24,test/stressProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressProof.cxx,1,['avail'],['available']
Availability,"// Retry building the function declaration with the new previous; // declarations, and with errors suppressed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:92,error,errors,92,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['error'],['errors']
Availability,"// Return 0 on success, EOF on failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:31,failure,failure,31,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,1,['failure'],['failure']
Availability,// Return a mask for the offset bits of a non-stack-pointer based compressed; // load/store.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:12,mask,mask,12,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,1,['mask'],['mask']
Availability,// Return a mask of vector type MaskVT to replace InMask. Also adjust MaskVT; // to ToMaskVT if needed with vector extension or truncation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:12,mask,mask,12,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,3,"['Mask', 'mask']","['MaskVT', 'mask']"
Availability,// Return a mask with Count low bits set.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:12,mask,mask,12,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,2,['mask'],['mask']
Availability,"// Return a pointer to null if the function does not exist. This; // will eventually create a segmentation fault, but the line should; // never be executed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/src/TFitEditor.cxx:107,fault,fault,107,gui/fitpanel/src/TFitEditor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/src/TFitEditor.cxx,1,['fault'],['fault']
Availability,// Return a version of comparison CC mask CCMask in which the LT and GT; // actions are swapped.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h:37,mask,mask,37,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h,1,['mask'],['mask']
Availability,// Return an error if no fix was discovered.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:13,error,error,13,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,1,['error'],['error']
Availability,"// Return an i32 value that is 1 if the CC value produced by CCReg is; // in the mask CCMask and 0 otherwise. CC is known to have a value; // in CCValid, so other values can be ignored.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:81,mask,mask,81,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['mask'],['mask']
Availability,"// Return an std::optional<StringRef>:; // - std::nullopt indicates a verification failure, or that the flag was not; // present in Args.; // - Otherwise the returned value is that name of the feature to add; // to Features.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Hexagon.cpp:83,failure,failure,83,interpreter/llvm-project/clang/lib/Driver/ToolChains/Hexagon.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Hexagon.cpp,1,['failure'],['failure']
Availability,"// Return code of the command execution (available only; // after closing the pipe)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TProofServ.h:41,avail,available,41,proof/proof/inc/TProofServ.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TProofServ.h,1,['avail'],['available']
Availability,"// Return code of the command execution (available only; // after closing the pipe); ////////////////////////////////////////////////////////////////////////////////; /// Execute 'cmd' in a pipe and handle output messages from the related file",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:41,avail,available,41,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['avail'],['available']
Availability,"// Return default level for MINUIT error analysis",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsReal.h:35,error,error,35,roofit/roofitcore/inc/RooAbsReal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsReal.h,1,['error'],['error']
Availability,// Return early if we are unable to reliably foresee; // the future stack frame.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:36,reliab,reliably,36,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,1,['reliab'],['reliably']
Availability,// Return error if unable to create a split context location.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVReader.cpp:10,error,error,10,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVReader.cpp,1,['error'],['error']
Availability,"// Return error status - no boundary found",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinning.cxx:10,error,error,10,roofit/roofitcore/src/RooBinning.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinning.cxx,1,['error'],['error']
Availability,// Return here to prevent duplicate fuse failure report.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:41,failure,failure,41,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['failure'],['failure']
Availability,"// Return here to propagate the failure up to the build system",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx:32,failure,failure,32,core/dictgen/src/rootcling_impl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx,1,['failure'],['failure']
Availability,// Return if small section is not available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetObjectFile.cpp:34,avail,available,34,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetObjectFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetObjectFile.cpp,1,['avail'],['available']
Availability,// Return if the mask doesn't start at position 0.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:17,mask,mask,17,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,1,['mask'],['mask']
Availability,// Return if the shift amount and the first bit position of mask are not the; // same.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:60,mask,mask,60,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,1,['mask'],['mask']
Availability,// Return if the shifted mask does not start at bit 0 or the sum of its size; // and Pos exceeds the word's size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:25,mask,mask,25,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,2,['mask'],['mask']
Availability,// Return if the shifted mask does not start at bit 0 or the sum of its; // length and lsb exceeds the word's size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:25,mask,mask,25,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,1,['mask'],['mask']
Availability,"// Return kTRUE if box has zero diagonal - kFALSE otherwise; // TODO: Round errors - should have epsilon test",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLBoundingBox.h:76,error,errors,76,graf3d/gl/inc/TGLBoundingBox.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLBoundingBox.h,1,['error'],['errors']
Availability,"// Return lanemask of Reg's subregs that are live-through at [Begin, End] and; // are fully covered by Mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNRegPressure.cpp:103,Mask,Mask,103,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNRegPressure.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNRegPressure.cpp,1,['Mask'],['Mask']
Availability,"// Return on success.; // FIXME: Why not on error too?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:44,error,error,44,tree/tree/src/TBranchElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx,1,['error'],['error']
Availability,"// Return one of the followings:; // (1) `{0-31 value, false}` if FLI is available for Imm's type and FP value.; // (2) `{0-31 value, true}` if Imm is negative and FLI is available for its; // positive counterpart, which will be materialized from the first returned; // element. The second returned element indicated that there should be a FNEG; // followed.; // (3) `{-1, _}` if there is no way FLI can be used to materialize Imm.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:73,avail,available,73,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,2,['avail'],['available']
Availability,"// Return symmetric error on current bin calculated either from Poisson statistics or from SumOfWeights",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooDataHist.h:20,error,error,20,roofit/roofitcore/inc/RooDataHist.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooDataHist.h,1,['error'],['error']
Availability,// Return the Name based on \a EntryInfo using the next available Count.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h:56,avail,available,56,interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,1,['avail'],['available']
Availability,// Return the auxiliary BB information if available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:42,avail,available,42,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,2,['avail'],['available']
Availability,"// Return the empty string, because `std::nullopt` signifies some sort of; // failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCodeBuilders.cpp:78,failure,failure,78,interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCodeBuilders.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCodeBuilders.cpp,1,['failure'],['failure']
Availability,// Return the error code for the last check or shuffling of the bundle.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.h:14,error,error,14,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.h,1,['error'],['error']
Availability,"// Return the known const value for the Sym if available, or return Undef; // otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:47,avail,available,47,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,1,['avail'],['available']
Availability,// Return the legalization cost of that repairing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:40,repair,repairing,40,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,1,['repair'],['repairing']
Availability,"// Return the name, even if an error is thrown. This is so that we can; // continue to make some progress, even without the value having been; // initialized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp:31,error,error,31,interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,1,['error'],['error']
Availability,"// Return the non-redundant list of WriteProcRes used by the given sched class.; // The scheduling model for LLVM is such that each instruction has a certain; // number of uops which consume resources which are described by WriteProcRes; // entries. Each entry describe how many cycles are spent on a specific ProcRes; // kind.; // For example, an instruction might have 3 uOps, one dispatching on P0; // (ProcResIdx=1) and two on P06 (ProcResIdx = 7).; // Note that LLVM additionally denormalizes resource consumption to include; // usage of super resources by subresources. So in practice if there exists a; // P016 (ProcResIdx=10), then the cycles consumed by P0 are also consumed by; // P06 (ProcResIdx = 7) and P016 (ProcResIdx = 10), and the resources consumed; // by P06 are also consumed by P016. In the figure below, parenthesized cycles; // denote implied usage of superresources by subresources:; // P0 P06 P016; // uOp1 1 (1) (1); // uOp2 1 (1); // uOp3 1 (1); // =============================; // 1 3 3; // Eventually we end up with three entries for the WriteProcRes of the; // instruction:; // {ProcResIdx=1, Cycles=1} // P0; // {ProcResIdx=7, Cycles=3} // P06; // {ProcResIdx=10, Cycles=3} // P016; //; // Note that in this case, P016 does not contribute any cycles, so it would; // be removed by this function.; // FIXME: Merge this with the equivalent in llvm-mca.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SchedClassResolution.cpp:18,redundant,redundant,18,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SchedClassResolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SchedClassResolution.cpp,1,['redundant'],['redundant']
Availability,// Return the processor resource identifier associated to this Mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h:63,Mask,Mask,63,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,1,['Mask'],['Mask']
Availability,"// Return the query in Buf on failure",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/CIFactory.cpp:30,failure,failure,30,interpreter/cling/lib/Interpreter/CIFactory.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/CIFactory.cpp,1,['failure'],['failure']
Availability,"// Return the register state back to how it was before, leaving any; // unallocated registers available for other smaller types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CallingConvention.cpp:94,avail,available,94,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CallingConvention.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CallingConvention.cpp,1,['avail'],['available']
Availability,"// Return the same error code as if the program crashed, as mentioned in the; // section ""Exit Status for Commands"":; // https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xcu_chap02.html",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp:19,error,error,19,interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp,1,['error'],['error']
Availability,// Return the total number of allocation orders available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.h:48,avail,available,48,interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.h,1,['avail'],['available']
Availability,"// Return true if MI is a conditional or unconditional branch.; // When returning true, set Cond to the mask of condition-code; // values on which the instruction will branch, and set Target; // to the operand that contains the branch target. This target; // can be a register or a basic block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h:104,mask,mask,104,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h,1,['mask'],['mask']
Availability,// Return true if Op is an intrinsic node with chain that returns the CC value; // as its only (other) argument. Provide the associated SystemZISD opcode and; // the mask of valid CC values if so.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:166,mask,mask,166,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['mask'],['mask']
Availability,// Return true if Op is an intrinsic node without chain that returns the; // CC value as its final argument. Provide the associated SystemZISD; // opcode and the mask of valid CC values if so.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:162,mask,mask,162,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['mask'],['mask']
Availability,"// Return true if ROTATE AND ... SELECTED BITS can be used to select bits; // Mask of the R2 operand, given that only the low BitSize bits of Mask are; // significant. Set Start and End to the I3 and I4 operands if so.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h:78,Mask,Mask,78,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h,2,['Mask'],['Mask']
Availability,// Return true if V is a value that will always be available (IE can; // be placed anywhere) in the function. We don't do globals here; // because they are often worse to put in place.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:51,avail,available,51,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,1,['avail'],['available']
Availability,// Return true if any bits of (RxSBG.Input & Mask) are significant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:45,Mask,Mask,45,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,1,['Mask'],['Mask']
Availability,"// Return true if the inner loop \p Lp is uniform with regard to the outer loop; // \p OuterLp (i.e., if the outer loop is vectorized, all the vector lanes; // executing the inner loop will execute the same iterations). This check is; // very constrained for now but it will be relaxed in the future. \p Lp is; // considered uniform if it meets all the following conditions:; // 1) it has a canonical IV (starting from 0 and with stride 1),; // 2) its latch terminator is a conditional branch and,; // 3) its latch condition is a compare instruction whose operands are the; // canonical IV and an OuterLp invariant.; // This check doesn't take into account the uniformity of other conditions not; // related to the loop latch because they don't affect the loop uniformity.; //; // NOTE: We decided to keep all these checks and its associated documentation; // together so that we can easily have a picture of the current supported loop; // nests. However, some of the current checks don't depend on \p OuterLp and; // would be redundantly executed for each \p Lp if we invoked this function for; // different candidate outer loops. This is not the case for now because we; // don't currently have the infrastructure to evaluate multiple candidate outer; // loops and \p OuterLp will be a fixed parameter while we only support explicit; // outer loop vectorization. It's also very likely that these checks go away; // before introducing the aforementioned infrastructure. However, if this is not; // the case, we should move the \p OuterLp independent checks to a separate; // function that is only executed once for each \p Lp.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:1027,redundant,redundantly,1027,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,1,['redundant'],['redundantly']
Availability,"// Return true if the mask could describe a slide of Mask.size() - 1; // elements from concat_vector(V1, V2)[Base:] to [Offset:].",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:22,mask,mask,22,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,2,"['Mask', 'mask']","['Mask', 'mask']"
Availability,"// Return true if this is a bundled retainRV/claimRV call, which is always; // redundant with the attachedcall in the bundle, and is going to be erased; // at the end of this pass. This avoids undoing objc-arc-expand and; // replacing uses of the retainRV/claimRV call's argument with its result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:79,redundant,redundant,79,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,1,['redundant'],['redundant']
Availability,// Return true if we can get a new shuffle mask by checking the parameter mask; // array to test whether every two adjacent mask values are continuous and; // starting from an even number.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:43,mask,mask,43,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,3,['mask'],['mask']
Availability,// Return true if we can make sure mask of N is all-ones mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:35,mask,mask,35,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,2,['mask'],['mask']
Availability,"// Return true is there is a nearyby consecutive load to the one provided; // (regardless of alignment). We search up and down the chain, looking though; // token factors and other loads (but nothing else). As a result, a true result; // indicates that it is safe to create a new consecutive load adjacent to the; // load provided.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:122,down,down,122,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['down'],['down']
Availability,// Return true on error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h:18,error,error,18,interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h,13,['error'],['error']
Availability,"// Return true to make these hints the only regs available to; // RA. This may mean extra spilling but since the alternative is; // a jump sequence expansion of the LOCRMux, it is preferred.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZRegisterInfo.cpp:49,avail,available,49,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZRegisterInfo.cpp,1,['avail'],['available']
Availability,"// Return true when all operands of Instr are available at insertion point; // HoistPt. When limiting the number of hoisted expressions, one could hoist; // a load without hoisting its access function. So before hoisting any; // expression, make sure that all its operands are available at insert point.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:46,avail,available,46,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,2,['avail'],['available']
Availability,"// Return when error occurred in TCling, i.e. when setup file(s) are; // out of date",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:15,error,error,15,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,1,['error'],['error']
Availability,"// Return whether we allow using masked interleave-groups (for dealing with; // strided loads/stores that reside in predicated blocks, or for dealing; // with gaps).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:33,mask,masked,33,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['mask'],['masked']
Availability,"// Returns 0 for failure 1 for success",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:17,failure,failure,17,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['failure'],['failure']
Availability,"// Returns F.getComdat() if it exists.; // Otherwise creates a new comdat, sets F's comdat, and returns it.; // Returns nullptr on failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation.h:131,failure,failure,131,interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation.h,1,['failure'],['failure']
Availability,"// Returns MangledName's prefix before the first '@', or an error if; // MangledName contains no '@' or the prefix has length 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Demangle/MicrosoftDemangle.cpp:60,error,error,60,interpreter/llvm-project/llvm/lib/Demangle/MicrosoftDemangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Demangle/MicrosoftDemangle.cpp,1,['error'],['error']
Availability,"// Returns RS_BUFFER_AVAILABLE if buffered resources are not reserved, and if; // there are enough available slots in the buffers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h:99,avail,available,99,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,1,['avail'],['available']
Availability,// Returns a profile parsing error for the current line.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicBlockSectionsProfileReader.h:29,error,error,29,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicBlockSectionsProfileReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicBlockSectionsProfileReader.h,1,['error'],['error']
Availability,// Returns a zero mask if resources requested by Desc are all available during; // this cycle. It returns a non-zero mask value only if there are unavailable; // processor resources; each bit set in the mask represents a busy processor; // resource unit or a reserved processor resource group.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h:18,mask,mask,18,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,4,"['avail', 'mask']","['available', 'mask']"
Availability,// Returns an array of bit masks which can be used to map values in; // WaitEventType to corresponding counter values in InstCounterType.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp:27,mask,masks,27,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,1,['mask'],['masks']
Availability,// Returns an error if we cannot handle the memory references in this; // instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Mips/Target.cpp:14,error,error,14,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Mips/Target.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Mips/Target.cpp,1,['error'],['error']
Availability,// Returns an opaque value that represents this LocationSize. Cannot be; // reliably converted back into a LocationSize.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h:76,reliab,reliably,76,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h,1,['reliab'],['reliably']
Availability,"// Returns detailed output. The value returned by this function is updated after each call to Evaluate().; // The returned RooArgSet contains the following:; //; // - the minimum nll, fitstatus and convergence quality for each fit </li>; // - for all non-constant parameters their value, error and pull </li>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/MinNLLTestStat.h:288,error,error,288,roofit/roostats/inc/RooStats/MinNLLTestStat.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/MinNLLTestStat.h,1,['error'],['error']
Availability,// Returns false if an error is diagnosed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp:23,error,error,23,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/RISCV.cpp,1,['error'],['error']
Availability,// Returns false if there is error found or true otherwise.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp:29,error,error,29,interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp,1,['error'],['error']
Availability,"// Returns false on error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/Getline.cxx:20,error,error,20,core/textinput/src/Getline.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/Getline.cxx,4,['error'],['error']
Availability,"// Returns itself if not using Split DWARF, or if the unit is a skeleton unit; // - otherwise returns the split full unit's corresponding skeleton, if; // available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFUnit.h:155,avail,available,155,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFUnit.h,1,['avail'],['available']
Availability,"// Returns non-zero in case of failure",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TLeafElement.cxx:31,failure,failure,31,tree/tree/src/TLeafElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TLeafElement.cxx,1,['failure'],['failure']
Availability,"// Returns nullptr on failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:22,failure,failure,22,hist/hist/src/TFormula.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx,1,['failure'],['failure']
Availability,"// Returns the Root Asymptotic Mean Integrated Squared Error according to Silverman's rule of thumb with assumed Gaussian density",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:55,Error,Error,55,hist/hist/src/TKDE.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx,1,['Error'],['Error']
Availability,// Returns the SVETypeFlags for a given value and mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/SveEmitter.cpp:50,mask,mask,50,interpreter/llvm-project/clang/utils/TableGen/SveEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/SveEmitter.cpp,1,['mask'],['mask']
Availability,// Returns the class ID for the dynamic type of this ErrorInfoBase instance.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:53,Error,ErrorInfoBase,53,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,1,['Error'],['ErrorInfoBase']
Availability,// Returns the currently processed compilation unit if available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Execution.h:55,avail,available,55,interpreter/llvm-project/clang/include/clang/Tooling/Execution.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Execution.h,1,['avail'],['available']
Availability,"// Returns the index of the highest bit set. For resource masks, the position of; // the highest bit set can be used to construct a resource mask identifier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Support.h:58,mask,masks,58,interpreter/llvm-project/llvm/include/llvm/MCA/Support.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Support.h,2,['mask'],"['mask', 'masks']"
Availability,"// Returns the maximum number of bytes a load/store instruction can access at; // once. This is typically the size of the largest register available on the; // processor. Note that this only used as a hint to generate independant; // load/stores to/from memory, so the exact returned value does not really; // matter as long as it's large enough.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h:139,avail,available,139,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h,1,['avail'],['available']
Availability,// Returns the maximum number of slots available in the given; // subtarget's packets.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h:39,avail,available,39,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h,1,['avail'],['available']
Availability,// Returns the maximum number of user SGPRs that we have available to preload; // arguments.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerKernelArguments.cpp:57,avail,available,57,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerKernelArguments.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerKernelArguments.cpp,1,['avail'],['available']
Availability,"// Returns the optional, target-specific version mapping that maps from one; // target to another target.; //; // This mapping is constructed from an appropriate mapping in the SDKSettings,; // for instance, when building for Mac Catalyst, the mapping would contain the; // ""macOS_iOSMac"" mapping as it maps the macOS versions to the Mac Catalyst; // versions.; //; // This mapping does not exist when the target doesn't have an appropriate; // related version mapping, or when there was an error reading the mapping; // from the SDKSettings, or when it's missing in the SDKSettings.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/DarwinSDKInfo.h:491,error,error,491,interpreter/llvm-project/clang/include/clang/Basic/DarwinSDKInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/DarwinSDKInfo.h,1,['error'],['error']
Availability,"// Returns true for TPResult::True or; // TPResult::Error.; // FIXME: Add statistics about the number of ambiguous statements encountered; // and how they were resolved (number of declarations+number of expressions).; // Ok, we have a simple-type-specifier/typename-specifier followed by a '('.; // We need tentative parsing...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:52,Error,Error,52,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,1,['Error'],['Error']
Availability,"// Returns true for TPResult::True or; // TPResult::Error.; // FIXME: TryParseSimpleDeclaration doesn't look past the first initializer,; // and so gets some cases wrong. We can't carry on if we've already seen; // something which makes this statement invalid as a declaration in this case,; // since it can cause us to misparse valid code. Revisit this once; // TryParseInitDeclaratorList is fixed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:52,Error,Error,52,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,1,['Error'],['Error']
Availability,// Returns true if Extend can be folded into the index of a masked gathers/scatters; // on this target.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:60,mask,masked,60,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['mask'],['masked']
Availability,// Returns true if ISD::AND SDNode `N`'s masking of the shift amount operand's; // `ShAmtBits` bits is unneeded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelDAGToDAG.h:41,mask,masking,41,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelDAGToDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelDAGToDAG.h,1,['mask'],['masking']
Availability,// Returns true if TargetOpcode::G_AND MachineInstr `MI`'s masking of the; // shift amount operand's `ShAmtBits` bits is unneeded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstructionSelector.h:59,mask,masking,59,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstructionSelector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstructionSelector.h,1,['mask'],['masking']
Availability,// Returns true if all features are available that are required by Opcode.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h:36,avail,available,36,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h,1,['avail'],['available']
Availability,"// Returns true if it succeeds, false if an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeEmitterGen.cpp:44,error,error,44,interpreter/llvm-project/llvm/utils/TableGen/CodeEmitterGen.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeEmitterGen.cpp,1,['error'],['error']
Availability,// Returns true if the libObject code does not support the load command and its; // contents. The cmd value it is treated as an unknown load command but with; // an error message that says the cmd value is obsolete.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/MachOObjectFile.cpp:165,error,error,165,interpreter/llvm-project/llvm/lib/Object/MachOObjectFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/MachOObjectFile.cpp,1,['error'],['error']
Availability,"// Returns true if the mask matches consecutive bytes, and the first byte; // begins at a power of 2 byte offset from 0th byte",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:23,mask,mask,23,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['mask'],['mask']
Availability,// Returns true if this masked compare can be implemented legally with this; // type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:24,mask,masked,24,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['mask'],['masked']
Availability,// Returns true if we can assume the writer of the mask has zero extended it; // for us.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:51,mask,mask,51,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,"// Returns true if we should continue scanning for entries, false if this is the; // last (sentinel) entry). In case of a parsing error we also return false, as; // it's not possible to recover this entry list (but the other lists may still; // parse OK).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFAcceleratorTable.cpp:130,error,error,130,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFAcceleratorTable.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFAcceleratorTable.cpp,2,"['error', 'recover']","['error', 'recover']"
Availability,// Returns true on error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp:19,error,error,19,interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp,2,['error'],['error']
Availability,// Returns true to signify an error,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rc/ResourceScriptCppFilter.cpp:30,error,error,30,interpreter/llvm-project/llvm/tools/llvm-rc/ResourceScriptCppFilter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rc/ResourceScriptCppFilter.cpp,1,['error'],['error']
Availability,"// Reverse X asymmetric errors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:24,error,errors,24,hist/histpainter/src/TGraphPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx,1,['error'],['errors']
Availability,"// Reverse Y asymmetric errors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:24,error,errors,24,hist/histpainter/src/TGraphPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx,1,['error'],['errors']
Availability,"// Reverse offloading is not supported, so just execute on the host.; // FIXME: This fallback solution is incorrect since it ignores the; // OMP_TARGET_OFFLOAD environment variable. Instead it would be better to; // assert here and ensure SEMA emits an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:253,error,error,253,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,1,['error'],['error']
Availability,// Revert the errors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Diagnostics.cpp:14,error,errors,14,interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Diagnostics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Diagnostics.cpp,1,['error'],['errors']
Availability,"// Rewrite all instructions based on the collected cell information.; //; // Traverse the instructions in a post-order, so that rewriting an; // instruction can make changes ""downstream"" in terms of control-flow; // without affecting the rewriting process. (We should not change; // instructions that have not yet been visited by the rewriter.); // The reason for this is that the rewriter can introduce new vregs,; // and replace uses of old vregs (which had corresponding cells; // computed during propagation) with these new vregs (which at this; // point would not have any cells, and would appear to be ""top"").; // If an attempt was made to evaluate an instruction with a fresh; // ""top"" vreg, it would cause an error (abend) in the evaluator.; // Collect the post-order-traversal block ordering. The subsequent; // traversal/rewrite will update block successors, so it's safer; // if the visiting order it computed ahead of time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp:175,down,downstream,175,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,2,"['down', 'error']","['downstream', 'error']"
Availability,"// Rewrite the instructions in the cloned blocks to refer to the instructions; // in the cloned blocks. We have to do this as a second pass so that we have; // everything available. Also, we have inserted new instructions which may; // include assume intrinsics, so we update the assumption cache while; // processing this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:171,avail,available,171,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,1,['avail'],['available']
Availability,// Rewrite the method result type if available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:37,avail,available,37,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['avail'],['available']
Availability,// Right fill the mask of bits for the operands to demand the most; // significant bit and all those below it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:18,mask,mask,18,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,3,['mask'],['mask']
Availability,// RndScale - Round FP Values To Include A Given Number Of Fraction Bits.; // Also used by the legacy (V)ROUND intrinsics where we mask out the; // scaling part of the immediate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h:131,mask,mask,131,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,2,['mask'],['mask']
Availability,"// Roll back on error in initializers.; // T maybe pointing to freed memory after this call:; // Interpreter::unload; // IncrementalParser::deregisterTransaction; // TransactionPool::releaseTransaction",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalParser.cpp:16,error,error,16,interpreter/cling/lib/Interpreter/IncrementalParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalParser.cpp,1,['error'],['error']
Availability,"// RooAbsMinimizerFcn config; // RooAbsMinimizerFcn config that can only be set in constructor, 0 means no parallelization (default),; // -1 is parallelization with the number of workers controlled by RooFit::MultiProcess which; // defaults to the number of available processors, n means parallelization with n CPU's",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooMinimizer.h:258,avail,available,258,roofit/roofitcore/inc/RooMinimizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooMinimizer.h,1,['avail'],['available']
Availability,"// RooAbsRealLValue representation of an error of a RooRealVar",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooErrorVar.h:41,error,error,41,roofit/roofitcore/inc/RooErrorVar.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooErrorVar.h,1,['error'],['error']
Availability,"// Rotate and insert under mask operation.; // __rldimi(rs, is, shift, mask); // (rotl64(rs, shift) & mask) | (is & ~mask); // __rlwimi(rs, is, shift, mask); // (rotl(rs, shift) & mask) | (is & ~mask)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:27,mask,mask,27,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,7,['mask'],['mask']
Availability,"// Rotate and insert under mask operation.; // __rlwnm(rs, shift, mask); // rotl(rs, shift) & mask",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:27,mask,mask,27,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,3,['mask'],['mask']
Availability,// Rotate left by OnesOnLeft (so leading ones are now trailing ones) and clear; // on the left the bits that are already zeros in the mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:134,mask,mask,134,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,// Rotate the CR bit in the CR fields to be the least significant bit and; // then mask with 0x1 (MB = ME = 31).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:83,mask,mask,83,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['mask'],['mask']
Availability,// Rotate the mask in the same way as RxSBG.Input is rotated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:14,mask,mask,14,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,"// Round NTZ down to the next byte. If we have 11 trailing zeros, then; // we need all the bits down to bit 8. Likewise, round NLZ. If we; // have 14 leading zeros, round to 8.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:13,down,down,13,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,4,['down'],['down']
Availability,// Round down to the nearest page by getting rid of the least significant bits; // representing location in the page. Shift right to get rid of this info and; // then shift back left.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp:9,down,down,9,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp,1,['down'],['down']
Availability,// Round down to the stack alignment.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64MachineFunctionInfo.cpp:9,down,down,9,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64MachineFunctionInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64MachineFunctionInfo.cpp,3,['down'],['down']
Availability,// Round the value down to an f32.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:19,down,down,19,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['down'],['down']
Availability,"// Round.; // FIXME: this probably shouldn't use 'round half up'.; // Rounding down is just a truncation, except we also want to drop; // trailing zeros from the new result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp:79,down,down,79,interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,1,['down'],['down']
Availability,"// Rule out multiple version specs referring to the same platform.; // For example, we emit an error for:; // @available(macos 10.10, macos 10.11, *)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:95,error,error,95,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,2,"['avail', 'error']","['available', 'error']"
Availability,// Run a downwards post-order search for the trace end.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:9,down,downwards,9,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,1,['down'],['downwards']
Availability,"// Run all passes in the given pass list, bailing out immediately if any pass; // returns an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkGeneric.h:93,error,error,93,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkGeneric.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkGeneric.h,1,['error'],['error']
Availability,"// Run down jth column from top to diag, to form the elements of U.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TDecompLU.cxx:7,down,down,7,math/matrix/src/TDecompLU.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TDecompLU.cxx,1,['down'],['down']
Availability,"// Run down jth subdiag to form the residuals after the elimination of; // the first j-1 subdiags. These residuals divided by the appropriate; // diagonal term will become the multipliers in the elimination of the jth.; // subdiag. Find fIndex of largest scaled term in imax.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TDecompLU.cxx:7,down,down,7,math/matrix/src/TDecompLU.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TDecompLU.cxx,1,['down'],['down']
Availability,"// Run partial inlining pass to partially inline functions that have; // large bodies.; // FIXME: It isn't clear whether this is really the right place to run this; // in ThinLTO. Because there is another canonicalization and simplification; // phase that will run after the thin link, running this here ends up with; // less information than will be available later and it may grow functions in; // ways that aren't beneficial.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:351,avail,available,351,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,1,['avail'],['available']
Availability,"// Run the second parse, now on the generated arguments, and with the real; // invocation and diagnostics. The result is what we will end up using for the; // rest of compilation, so if Generate is not inverse of Parse, something down; // the line will break.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:230,down,down,230,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,1,['down'],['down']
Availability,"// SCC def is not a copy; // Insert a trivial select instead of creating a copy, because a copy from; // SCC would semantically mean just copying a single bit, but we may need; // the result to be a vector condition mask that needs preserving.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp:216,mask,mask,216,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,1,['mask'],['mask']
Availability,"// SEH is even less tolerant, there may not be any sort of exceptional; // funclet in the callee.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:20,toler,tolerant,20,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,1,['toler'],['tolerant']
Availability,"// SELECTION LOOP; // Check for error in the class layout before doing anything else.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx:32,error,error,32,core/dictgen/src/rootcling_impl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx,1,['error'],['error']
Availability,// SEXT/TRUNC cases where the mask doesn't match the destination size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:30,mask,mask,30,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// SHL or SRL: look upstream for AND mask operand,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:37,mask,mask,37,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['mask']
Availability,"// SIN_HW, COS_HW - f32 for SI, 1 ULP max error, valid from -100 pi to 100 pi.; // Denormals handled on some parts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.h:42,error,error,42,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.h,1,['error'],['error']
Availability,"// SQ is rounded down (i.e SQ * SQ <= D), so the roots may be inexact.; // When using the quadratic formula directly, the calculated low root; // may be greater than the exact one, since we would be subtracting SQ.; // To make sure that the calculated root is not greater than the exact; // one, subtract SQ+1 when calculating the low root (for inexact value; // of SQ).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp:17,down,down,17,interpreter/llvm-project/llvm/lib/Support/APInt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp,1,['down'],['down']
Availability,// SRAMECC selection mask for EF_AMDGPU_FEATURE_SRAMECC_* values.; //; // Only valid for ELFOSABI_AMDGPU_HSA and ELFABIVERSION_AMDGPU_HSA_V4.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:21,mask,mask,21,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,1,['mask'],['mask']
Availability,"// SSE42 string comparisons.; // These nodes produce 3 results, index, mask, and flags. X86ISelDAGToDAG; // will emit one or two instructions based on which results are used. If; // flags and index/mask this allows us to use a single instruction since; // we won't have to pick and opcode for flags. Instead we can rely on the; // DAG to CSE everything and decide at isel.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h:71,mask,mask,71,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,2,['mask'],['mask']
Availability,"// STD's maximum displacement is 63, so larger stores have to be split into a; // set of operations.; // For avrtiny chips, STD is not available at all so we always have to fall; // back to manual pointer adjustments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp:135,avail,available,135,interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp,1,['avail'],['available']
Availability,// SVE generates only a masked function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:24,mask,masked,24,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,1,['mask'],['masked']
Availability,"// Same as MakeWeakOnHeap, but create a shared_ptr that makes sure the object is definitely kept alive.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx:97,alive,alive,97,tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx,1,['alive'],['alive']
Availability,// Same as VADDLV[su] but with a v4i1 predicate mask,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:48,mask,mask,48,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,1,['mask'],['mask']
Availability,// Same as VADDLVp[su] but with a v4i1 predicate mask,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:49,mask,mask,49,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,1,['mask'],['mask']
Availability,// Same as VADDV[su] but with a v4i1 predicate mask,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:47,mask,mask,47,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,1,['mask'],['mask']
Availability,// Same as VMLALVA[su] with a v4i1 predicate mask,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:45,mask,mask,45,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,1,['mask'],['mask']
Availability,// Same as VMLALV[su] with a v4i1 predicate mask,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:44,mask,mask,44,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,1,['mask'],['mask']
Availability,// Same as VMLAV[su] with a v4i1 predicate mask,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:43,mask,mask,43,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,1,['mask'],['mask']
Availability,// Same as above but with the other clone. We do this for both clones as; // we don't know which clone is the one containing the unintended; // pattern error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:152,error,error,152,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,1,['error'],['error']
Availability,"// Same as above, but the shift amount may be extended after masking:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:61,mask,masking,61,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,1,['mask'],['masking']
Availability,"// Same as above, but using a const_succ_iterator from Src. This is faster; // when the iterator is already available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBranchProbabilityInfo.h:108,avail,available,108,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBranchProbabilityInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBranchProbabilityInfo.h,1,['avail'],['available']
Availability,"// Same as the pattern above with a select for the zero predicated lanes; // ExtA = sext/zext A; // ExtB = sext/zext B; // Mul = mul ExtA, ExtB; // N0 = select Mask, Mul, 0; // vecreduce.add N0",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:160,Mask,Mask,160,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['Mask'],['Mask']
Availability,"// Same overal idea as in the default eviction policy - we visit the values; // of AllocationOrder one at a time. If it's not legally available, we mask; // off the corresponding feature column (==do nothing because we already; // reset all the features to 0) Use Pos to capture the column we load; // features at - in AllocationOrder order.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:134,avail,available,134,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,2,"['avail', 'mask']","['available', 'mask']"
Availability,"// Same, but for sparse ops. Only available on sm_60+",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h:34,avail,available,34,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h,1,['avail'],['available']
Availability,"// Sandbox calls by aligning call and branch delay to the bundle end.; // For indirect calls, emit the mask before the call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:103,mask,mask,103,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,1,['mask'],['mask']
Availability,// Sandbox indirect branch or return instruction by inserting mask operation; // before it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:62,mask,mask,62,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,1,['mask'],['mask']
Availability,// Sandbox memory access or SP change. Insert mask operation before and/or; // after the instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:46,mask,mask,46,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,1,['mask'],['mask']
Availability,"// Sanity check if all the indices are NOT in range.; // If mask is `poison`, `Mask` may be a vector of -1s.; // If all of them are `poison`, OOB read will happen later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:60,mask,mask,60,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,2,"['Mask', 'mask']","['Mask', 'mask']"
Availability,"// Save Current in the first available slot, merging on collisions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Value.h:29,avail,available,29,interpreter/llvm-project/llvm/include/llvm/IR/Value.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Value.h,1,['avail'],['available']
Availability,"// Save live-ins to output vector. Ignore any that are still marked as being; // VPHIs with no location -- those are variables that we know the value of,; // but are not actually available in the register file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:179,avail,available,179,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['avail'],['available']
Availability,// Save the BB nodes on the path from the first BB node containing; // non-redundant spill to the Root node.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:75,redundant,redundant,75,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,1,['redundant'],['redundant']
Availability,// Save the EXEC mask,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp:17,mask,mask,17,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,2,['mask'],['mask']
Availability,// Save the EXEC mask before the loop.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp:17,mask,mask,17,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,1,['mask'],['mask']
Availability,"// Save the nominal and error hists; // for the building of constraint terms",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/HistoToWorkspaceFactoryFast.cxx:24,error,error,24,roofit/histfactory/src/HistoToWorkspaceFactoryFast.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/HistoToWorkspaceFactoryFast.cxx,1,['error'],['error']
Availability,// Save the so-called Initial-SP (i.e. the value of the stack pointer; // immediately after the prolog) into the PSPSlot so that funclets; // and the GC can recover it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:157,recover,recover,157,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,1,['recover'],['recover']
Availability,"// Say that we can handle the situation. Clang should try to recover",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx:61,recover,recover,61,core/metacling/src/TClingCallbacks.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx,2,['recover'],['recover']
Availability,"// Scalar integer divide and remainder are lowered to use operations that; // produce two results, to match the available instructions. This exposes; // the two-result form to trivial CSE, which is able to combine x/y and x%y; // into a single instruction.; //; // Scalar integer multiply-high is also lowered to use two-result; // operations, to match the available instructions. However, plain multiply; // (low) operations are left as Legal, as there are single-result; // instructions for this in x86. Using the two-result multiply instructions; // when both high and low results are needed must be arranged by dagcombine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:112,avail,available,112,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['avail'],['available']
Availability,// Scalarize masked gather for RV64 if EEW=64 indices aren't supported.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h:13,mask,masked,13,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h,1,['mask'],['masked']
Availability,// Scalarize masked scatter for RV64 if EEW=64 indices aren't supported.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h:13,mask,masked,13,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h,1,['mask'],['masked']
Availability,// Scalarize unsupported vector masked load,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:32,mask,masked,32,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,1,['mask'],['masked']
Availability,// Scale down Denominator to fit in a 32-bit integer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BranchProbability.cpp:9,down,down,9,interpreter/llvm-project/llvm/lib/Support/BranchProbability.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BranchProbability.cpp,1,['down'],['down']
Availability,"// Scale down below UINT32_MAX. Since Shift is larger than necessary, we; // can round here without concern about overflow.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:9,down,down,9,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,1,['down'],['down']
Availability,// Scale down loop exiting weight by trip count.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:9,down,down,9,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,1,['down'],['down']
Availability,// Scale down the integer value in the float to match the correct scaling; // factor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFixedPoint.cpp:9,down,down,9,interpreter/llvm-project/llvm/lib/Support/APFixedPoint.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFixedPoint.cpp,1,['down'],['down']
Availability,// Scale down the result.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:9,down,down,9,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,1,['down'],['down']
Availability,// Scale from granularity down to shadow size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:26,down,down,26,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,1,['down'],['down']
Availability,"// Scale the contents & errors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx:24,error,errors,24,hist/hist/src/THnBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx,1,['error'],['errors']
Availability,"// Scale the cost of the memory operation by the fraction of legalized; // instructions that will actually be used. We shouldn't account for the; // cost of dead instructions since they will be removed.; //; // E.g., An interleaved load of factor 8:; // %vec = load <16 x i64>, <16 x i64>* %ptr; // %v0 = shufflevector %vec, undef, <0, 8>; //; // If <16 x i64> is legalized to 8 v2i64 loads, only 2 of the loads will be; // used (those corresponding to elements [0:1] and [8:9] of the unlegalized; // type). The other loads are unused.; //; // TODO: Note that legalization can turn masked loads/stores into unmasked; // (legalized) loads/stores. This can be reflected in the cost.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:582,mask,masked,582,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,1,['mask'],['masked']
Availability,// Scale the leading zero count down based on the actual size of the value.; // Also scale it down based on the size of the shift.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:32,down,down,32,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,2,['down'],['down']
Availability,// Scale the max size down if the target can load more bytes than we need.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:22,down,down,22,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,1,['down'],['down']
Availability,// Scale the shuffle masks to the smaller scalar type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:21,mask,masks,21,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['masks']
Availability,// Scan down the stack and DFS across the call edges.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:8,down,down,8,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,2,['down'],['down']
Availability,// Scan down this block to see if there is another stack restore in the; // same block without an intervening call/alloca.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:8,down,down,8,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,1,['down'],['down']
Availability,// Scan down to find any glued succs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp:8,down,down,8,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,1,['down'],['down']
Availability,// Scan for MFMA long latency instructions and try to add a dependency; // of available SALU instructions to give them a chance to fill MFMA; // shadow. That is desirable to fill MFMA shadow with SALU instructions; // rather than VALU to prevent power consumption bursts and throttle.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp:78,avail,available,78,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp,1,['avail'],['available']
Availability,"// Scan over the PHI nodes in the loop header. Since they now have only two; // incoming values (the loop is canonicalized), we may have simplified the PHI; // down to 'X = phi [X, Y]', which should be replaced with 'Y'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:160,down,down,160,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,1,['down'],['down']
Availability,"// Scan through the block, looking for instructions that use constants moves; // into VPR that are the negative of one another. These are expected to be; // COPY's to VCCRRegClass, from a t2MOVi or t2MOVi16. The last seen constant; // mask is kept it or and VPNOT's of it are added or reused as we scan through; // the function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp:235,mask,mask,235,interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp,1,['mask'],['mask']
Availability,// Scan to see if we have this GEP available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp:35,avail,available,35,interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,1,['avail'],['available']
Availability,// Scatter instructions have a mask output not in the ISD node.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:31,mask,mask,31,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,// Schedule as many instructions in each cycle as possible. So don't make an; // instruction available unless it is ready in the current cycle.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:93,avail,available,93,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['avail'],['available']
Availability,// Schedule each sequence of instructions not interrupted by a label; // or anything else that effectively needs to shut down scheduling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:121,down,down,121,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,1,['down'],['down']
Availability,// Scheduling an instruction may have made pending instructions available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:64,avail,available,64,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['avail'],['available']
Availability,"// Scopes aren't available during instantiation. Fortunately, builtin; // functions cannot be template args so they cannot be formed through template; // instantiation. Therefore checking once during the parse is sufficient.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:17,avail,available,17,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['avail'],['available']
Availability,"// Scoreboard to track function unit usage. Scoreboard[0] is a; // mask of the FUs in use in the cycle currently being; // schedule. Scoreboard[1] is a mask for the next cycle. The; // Scoreboard is used as a circular buffer with the current cycle; // indicated by Head.; //; // Scoreboard always counts cycles in forward execution order. If used by a; // bottom-up scheduler, then the scoreboard cycles are the inverse of the; // scheduler's cycles.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h:67,mask,mask,67,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h,2,['mask'],['mask']
Availability,"// Search and combine pairs of equivalent instructions, like; // S_AND_B64 x, (S_AND_B64 x, y) => S_AND_B64 x, y; // S_OR_B64 x, (S_OR_B64 x, y) => S_OR_B64 x, y; // One of the operands is exec mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerControlFlow.cpp:194,mask,mask,194,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerControlFlow.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerControlFlow.cpp,1,['mask'],['mask']
Availability,"// Search down from the Phi to the LoopExitInstr, looking for instructions; // with a single user of the correct type for the reduction.; // Note that we check that the type of the operand is correct for each item in; // the chain, including the last (the loop exit value). This can come up from; // sub, which would otherwise be treated as an add reduction. MinMax also need; // to check for a pair of icmp/select, for which we use getNextInstruction and; // isCorrectOpcode functions to step the right number of instruction, and; // check the icmp/select pair.; // FIXME: We also do not attempt to look through Select's yet, which might; // be part of the reduction chain, or attempt to looks through And's to find a; // smaller bitwidth. Subs are also currently not allowed (which are usually; // treated as part of a add reduction) as they are expected to generally be; // more expensive than out-of-loop reductions, and need to be costed more; // carefully.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:10,down,down,10,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,1,['down'],['down']
Availability,"// Search for live-in variables. They are factored into the register pressure; // from the begining. Live-in variables used by every iteration should be; // considered as alive throughout the loop. For example, the variable `c` in; // following code. \code; // int c = ...;; // for (int i = 0; i < n; i++); // a[i] += b[i] + c;; // \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:171,alive,alive,171,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['alive'],['alive']
Availability,// Search for overridden methods and merge information down from them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:55,down,down,55,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['down'],['down']
Availability,// Search through any available variants for one we can use at this VF.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:22,avail,available,22,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['avail'],['available']
Availability,"// Search through the requirements, and see if any have a RecoveryExpr in it,; // which means this RequiresExpr ALSO needs to be invalid.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp:58,Recover,RecoveryExpr,58,interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp,1,['Recover'],['RecoveryExpr']
Availability,"// Search up and down at the same time, because we don't know if the new; // instruction is above or below the existing scheduling region.; // Ignore debug info (and other ""AssumeLike"" intrinsics) so that's not counted; // against the budget. Otherwise debug info could affect codegen.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:17,down,down,17,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['down'],['down']
Availability,"// Second pattern, reversed: right shift, then mask off trailing bits.; // FIXME: Handle other patterns of known/demanded bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:47,mask,mask,47,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['mask'],['mask']
Availability,"// Second pattern: left shift, then mask off leading bits.; // FIXME: Use demanded bits?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:36,mask,mask,36,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['mask'],['mask']
Availability,"// Second, search down the chain, starting from the top-level nodes recorded; // in the first phase. These top-level nodes are the nodes just above all; // loads and token factors. Starting with their uses, recursively look though; // all loads (just the chain uses) and token factors to find a consecutive; // load.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:18,down,down,18,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['down'],['down']
Availability,// Section headers are available but .dynsym header is not found.; // Return 0 as .dynsym does not exist.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELF.h:23,avail,available,23,interpreter/llvm-project/llvm/include/llvm/Object/ELF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELF.h,1,['avail'],['available']
Availability,// See TargetRegisterInfo::getCallPreservedMask for how to interpret the; // register mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64RegisterInfo.cpp:86,mask,mask,86,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64RegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64RegisterInfo.cpp,1,['mask'],['mask']
Availability,"// See createPGOFuncNameVar for more details. To avoid link errors, profile; // counters for function with available_externally linkage needs to be changed; // to linkonce linkage. On ELF based systems, this leads to weak symbols to be; // created. Without using comdat, duplicate entries won't be removed by the; // linker leading to increased data segement size and raw profile size. Even; // worse, since the referenced counter from profile per-function data object; // will be resolved to the common strong definition, the profile counts for; // available_externally functions will end up being duplicated in raw profile; // data. This can result in distorted profile as the counts of those dups; // will be accumulated by the profile merger.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProf.cpp:60,error,errors,60,interpreter/llvm-project/llvm/lib/ProfileData/InstrProf.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProf.cpp,1,['error'],['errors']
Availability,"// See https://sft.its.cern.ch/jira/browse/ROOT-8742; // and https://sft.its.cern.ch/jira/browse/ROOT-9253; // As of commit e21b4f1a3b, removing this lock lead to a failure; // in the test testSetAddress[Loop].; // As of commit 4f8b237849, removing this lock does not lead to; // a visible failure in test. This might be due to the underlying; // problem (missing lock or ?) being solved somewhere else or some; // other perturbation reducing the failure rate.; // Having the lock here is not too costly as InitializeOffsets is; // one called once in the lifetime of the TBranch.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:165,failure,failure,165,tree/tree/src/TBranchElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx,3,['failure'],['failure']
Availability,// See if a clear mask is legal instead of going via; // XformToShuffleWithZero which loses UNDEF mask elements.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:18,mask,mask,18,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['mask'],['mask']
Availability,// See if all arguments are shuffled with the same mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:51,mask,mask,51,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,1,['mask'],['mask']
Availability,"// See if any instructions in the block can be eliminated. If so, do it. If; // not, add them to AvailableValues.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:97,Avail,AvailableValues,97,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,1,['Avail'],['AvailableValues']
Availability,// See if it's worth creating a back reference.; // Only types longer than 1 character are considered; // and only 10 back references slots are available:,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp:144,avail,available,144,interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,1,['avail'],['available']
Availability,"// See if the instruction has an available value. If so, use it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:33,avail,available,33,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,1,['avail'],['available']
Availability,"// See if the shift amount is already masked (e.g. for rotation modulo),; // then we can zero-extend it by setting all the other mask elements to; // zero.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:38,mask,masked,38,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['mask'],"['mask', 'masked']"
Availability,// See if the shuffle mask matches the reference insertion mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:22,mask,mask,22,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['mask'],['mask']
Availability,"// See if the user is one of our successors that has only one; // predecessor, so that we don't have to split the critical edge.; // Another option where we can sink is a block that ends with a; // terminator that does not pass control to other block (such as; // return or unreachable or resume). In this case:; // - I dominates the User (by SSA form);; // - the User will be executed at most once.; // So sinking I down to User is always profitable or neutral.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:417,down,down,417,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['down'],['down']
Availability,// See if there are error mismatches.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp:20,error,error,20,interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp,1,['error'],['error']
Availability,// See if there are other bits in the bitfield's storage we'll need to load; // and mask together with source before storing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:84,mask,mask,84,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['mask'],['mask']
Availability,// See if this is an X & Mask that we can match to BEXTR/BZHI.; // Where Mask is one of the following patterns:; // a) x & (1 << nbits) - 1; // b) x & ~(-1 << nbits); // c) x & (-1 >> (32 - y)); // d) x << (32 - y) >> (32 - y); // e) (1 << nbits) - 1,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:25,Mask,Mask,25,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,2,['Mask'],['Mask']
Availability,// See if we can avoid a PACKSS by calling MOVMSK on the sources.; // For vXi16 cases we can use a v2Xi8 PMOVMSKB. We must mask out; // sign bits prior to the comparison with zero unless we know that; // the vXi16 splats the sign bit down to the lower i8 half.; // TODO: Handle all_of patterns.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:123,mask,mask,123,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,"['down', 'mask']","['down', 'mask']"
Availability,// See if we can choose a smaller ABI alignment in cases where it's an; // illegal vector type that will get broken down.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:116,down,down,116,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['down'],['down']
Availability,"// See if we can combine a single input shuffle with zeros to a bit-mask,; // which is much simpler than any shuffle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:68,mask,mask,68,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// See if we can further relax some instructions to cut down on the number of; // nop bytes required for code alignment. The actual win is in reducing; // instruction count, not number of bytes. Modern X86-64 can easily end up; // decode limited. It is often better to reduce the number of instructions; // (i.e. eliminate nops) even at the cost of increasing the size and; // complexity of others.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp:56,down,down,56,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp,1,['down'],['down']
Availability,"// See if we can mask off the upper elements using the existing source node.; // The shift uses the entire lower 64-bits of the amount vector, so no need to; // do this for vXi64 types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:17,mask,mask,17,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// See if we can peek through to a vector with a wider element type, if the; // signbits extend down to all the sub-elements as well.; // Calling MOVMSK with the wider type, avoiding the bitcast, helps expose; // potential SimplifyDemandedBits/Elts cases.; // If we looked through a truncate that discard bits, we can't do this; // transform.; // FIXME: We could do this transform for truncates that discarded bits by; // inserting an AND mask between the new MOVMSK and the CMP.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:96,down,down,96,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,"['down', 'mask']","['down', 'mask']"
Availability,"// See if we have a version of this value already available and dominating; // PredBB. If so, there is no need to insert a new instance of it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp:50,avail,available,50,interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,1,['avail'],['available']
Availability,// See if we only masking off bits we know are already zero due to; // alignment.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:18,mask,masking,18,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['mask'],['masking']
Availability,// See whether C can be implemented as a TEST UNDER MASK instruction.; // Update the arguments with the TM version if so.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:52,MASK,MASK,52,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['MASK'],['MASK']
Availability,// See whether the comparison argument contains a redundant AND; // and remove it if so. This sometimes happens due to the generic; // BRCOND expansion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:50,redundant,redundant,50,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['redundant'],['redundant']
Availability,"// See whether the shift vector is a splat represented as SHUFFLE_VECTOR,; // and the shift amount is directly available in a GPR.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:111,avail,available,111,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['avail'],['available']
Availability,// See whether the value we're splatting is directly available as a scalar.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:53,avail,available,53,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['avail'],['available']
Availability,// See which compare-style condition codes are available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:47,avail,available,47,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,1,['avail'],['available']
Availability,"// Select 'style' in the list of available styles.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TStyleManager.cxx:33,avail,available,33,gui/ged/src/TStyleManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TStyleManager.cxx,1,['avail'],['available']
Availability,"// Select 0xc for each lane used from source operand. Zero has 0xc mask; // set, 0xff have 0xff in the mask, actual lanes are in the 0-3 range.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:67,mask,mask,67,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,4,['mask'],['mask']
Availability,// Select between the current value and the previous incoming edge; // based on the incoming mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:93,mask,mask,93,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,1,['mask'],['mask']
Availability,"// Select format of the expression, i.e. (i) its explicit format, if any,; // otherwise (ii) its implicit format, if any, otherwise (iii) the default; // format (unsigned). Error out in case of conflicting implicit format; // without explicit format.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:173,Error,Error,173,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,1,['Error'],['Error']
Availability,// Selects between operand 0 and operand 1. Operand 2 is the; // mask of condition-code values for which operand 0 should be; // chosen over operand 1; it has the same form as BR_CCMASK.; // Operand 3 is the flag operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:65,mask,mask,65,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,1,['mask'],['mask']
Availability,// Self dependencies are ignored because they are redundant and; // uninteresting.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp:50,redundant,redundant,50,interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,1,['redundant'],['redundant']
Availability,"// Sema has done some convenient canonicalization here: if the; // access path involved any virtual steps, the conversion path will; // *start* with a step down to the correct virtual base subobject,; // and hence will not require any further steps.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:156,down,down,156,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,1,['down'],['down']
Availability,// Send out-of-band errors to any waiting threads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/SimpleRemoteEPCServer.cpp:20,error,errors,20,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/SimpleRemoteEPCServer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/SimpleRemoteEPCServer.cpp,1,['error'],['errors']
Availability,// Sequence with consecutive dbg.value instrs ended. Clear the map to; // restart identifying redundant instructions if case we find another; // dbg.value sequence.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:94,redundant,redundant,94,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,2,['redundant'],['redundant']
Availability,"// Serializing loads here may result in excessive register pressure, and; // TokenFactor places arbitrary choke points on the scheduler. SD scheduling; // could recover a bit by hoisting nodes upward in the chain by recognizing; // they are side-effect free or do not alias. The optimizer should really; // avoid this case by converting large object/array copies to llvm.memcpy; // (MaxParallelChains should always remain as failsafe).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:161,recover,recover,161,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['recover'],['recover']
Availability,// Set BBID for `-basic-block=sections=labels` and; // `-basic-block-sections=list` to allow robust mapping of profiles to basic; // blocks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:93,robust,robust,93,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,1,['robust'],['robust']
Availability,// Set IO unlocked variants as unavailable; // Set them as available per system below,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:59,avail,available,59,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,1,['avail'],['available']
Availability,"// Set X value and error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h:19,error,error,19,roofit/roofitcore/test/stressRooFit_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h,2,['error'],['error']
Availability,"// Set Y value and error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h:19,error,error,19,roofit/roofitcore/test/stressRooFit_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h,2,['error'],['error']
Availability,// Set a diagnostic handler that doesn't exit on the first error,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp:59,error,error,59,interpreter/llvm-project/llvm/tools/llc/llc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp,1,['error'],['error']
Availability,"// Set an error handler, so that any LLVM backend diagnostics go through our; // error handler.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp:10,error,error,10,interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp,6,['error'],['error']
Availability,"// Set availability flag",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx:7,avail,availability,7,net/auth/src/TAuthenticate.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx,1,['avail'],['availability']
Availability,"// Set button state down according to the parameter 'on'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGButton.cxx:20,down,down,20,gui/gui/src/TGButton.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGButton.cxx,1,['down'],['down']
Availability,"// Set custom X11 error handlers",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/x11/src/GX11Gui.cxx:18,error,error,18,graf2d/x11/src/GX11Gui.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/x11/src/GX11Gui.cxx,1,['error'],['error']
Availability,// Set error mode to not display any message boxes. The child process inherits; // this.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/KillTheDoctor/KillTheDoctor.cpp:7,error,error,7,interpreter/llvm-project/llvm/utils/KillTheDoctor/KillTheDoctor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/KillTheDoctor/KillTheDoctor.cpp,1,['error'],['error']
Availability,"// Set error of input RooRealVar to value",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooErrorVar.h:7,error,error,7,roofit/roofitcore/inc/RooErrorVar.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooErrorVar.h,1,['error'],['error']
Availability,"// Set function to be minimized. Flag an error since only support Gradient objective functions",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TLinearMinimizer.cxx:41,error,error,41,math/minuit/src/TLinearMinimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TLinearMinimizer.cxx,1,['error'],['error']
Availability,"// Set image if not yet done and available",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:33,avail,available,33,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['avail'],['available']
Availability,"// Set initial error too",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/HistFactoryImpl.cxx:15,error,error,15,roofit/histfactory/src/HistFactoryImpl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/HistFactoryImpl.cxx,1,['error'],['error']
Availability,// Set mask and the first source register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:7,mask,mask,7,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,1,['mask'],['mask']
Availability,// Set mask vector to all zeros or ones.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:7,mask,mask,7,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,1,['mask'],['mask']
Availability,// Set of available Analysis. This information is used while scheduling; // pass. If a pass requires an analysis which is not available then; // the required analysis pass is scheduled to run before the pass itself is; // scheduled to run.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManagers.h:10,avail,available,10,interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManagers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManagers.h,2,['avail'],['available']
Availability,// Set of features that are either architecture features or referenced; // by them (e.g.: FeatureNaN2008 implied by FeatureMips32r6).; // The full table can be found in MipsGenSubtargetInfo.inc (MipsFeatureKV[]).; // The reason we need this mask is explained in the selectArch function.; // FIXME: Ideally we would like TableGen to generate this information.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:241,mask,mask,241,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,1,['mask'],['mask']
Availability,// Set of processor resource units available on the target.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h:35,avail,available,35,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,1,['avail'],['available']
Availability,// Set of processor resource units that are available during this cycle.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h:44,avail,available,44,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,1,['avail'],['available']
Availability,"// Set of resources available on the subtarget.; //; // There is an instance of ResourceState for every resource declared by the; // target scheduling model.; //; // Elements of this vector are ordered by resource kind. In particular,; // resource units take precedence over resource groups.; //; // The index of a processor resource in this vector depends on the value of; // its mask (see the description of field ResourceState::ResourceMask). In; // particular, it is computed as the position of the most significant bit set; // (MSB) in the mask plus one (since we want to ignore the invalid resource; // descriptor at index zero).; //; // Example (little endian):; //; // Resource | Mask | MSB | Index; // ---------+---------+---------+-------; // A | 0b00001 | 0b00001 | 1; // | | |; // B | 0b00100 | 0b00100 | 3; // | | |; // C | 0b10010 | 0b10000 | 5; //; //; // The same index is also used to address elements within vector `Strategies`; // and vector `Resource2Groups`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h:20,avail,available,20,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,4,"['Mask', 'avail', 'mask']","['Mask', 'available', 'mask']"
Availability,"// Set of values available coming in, before the phi nodes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:17,avail,available,17,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,1,['avail'],['available']
Availability,// Set of values available going out,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:17,avail,available,17,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,1,['avail'],['available']
Availability,"// Set relative tolerance for errors to large value to only check for values",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooAbsPdf.cxx:16,toler,tolerance,16,roofit/roofitcore/test/testRooAbsPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooAbsPdf.cxx,2,"['error', 'toler']","['errors', 'tolerance']"
Availability,// Set standard error to be unbuffered and tied to outs() by default.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/raw_ostream.cpp:16,error,error,16,interpreter/llvm-project/llvm/lib/Support/raw_ostream.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/raw_ostream.cpp,1,['error'],['error']
Availability,// Set the <kill> flag on a use of Reg whose lane mask is contained in LM.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:50,mask,mask,50,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,1,['mask'],['mask']
Availability,"// Set the DebugLoc of the inserted PHI, if available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:44,avail,available,44,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,1,['avail'],['available']
Availability,"// Set the Error (No error, error1..5)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TH1Editor.cxx:11,Error,Error,11,gui/ged/src/TH1Editor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TH1Editor.cxx,2,"['Error', 'error']","['Error', 'error']"
Availability,"// Set the Mask lanes adjusted for the size of the input and output; // lanes. The Mask is always i8, so it will set OutputFactor lanes per; // output element, adjusted in their positions per input and output types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:11,Mask,Mask,11,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,2,['Mask'],['Mask']
Availability,// Set the availability based on attributes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp:11,avail,availability,11,interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp,1,['avail'],['availability']
Availability,"// Set the bits in `Bits`, which correspond to the value representations of; // the actual members of the record type `RTy`. Note that this function does; // not handle base classes, virtual tables, etc, since they cannot happen in; // CMSE function arguments or return. The bit mask corresponds to the target; // memory layout, i.e. it's endian dependent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:279,mask,mask,279,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,1,['mask'],['mask']
Availability,"// Set the cache size of the underlying TTree,; // See TTree::SetCacheSize.; // Returns 0 cache state ok (exists or not, as appropriate); // -1 on error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:147,error,error,147,tree/tree/src/TChain.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx,1,['error'],['error']
Availability,"// Set the condition code from a boolean value in operand 0.; // Operand 1 is a mask of all condition-code values that may result of this; // operation, operand 2 is a mask of condition-code values that may result; // if the boolean is true.; // Note that this operation is always optimized away, we will never; // generate any code for it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:80,mask,mask,80,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,2,['mask'],['mask']
Availability,"// Set the desired relative Error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/GaussLegendreIntegrator.cxx:28,Error,Error,28,math/mathcore/src/GaussLegendreIntegrator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/GaussLegendreIntegrator.cxx,1,['Error'],['Error']
Availability,// Set the error as fatal flag for this specifier.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Warnings.cpp:11,error,error,11,interpreter/llvm-project/clang/lib/Basic/Warnings.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Warnings.cpp,1,['error'],['error']
Availability,// Set the error for all nodes which have been created before we; // recognized the error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:11,error,error,11,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,2,['error'],['error']
Availability,"// Set the error for the mapped to Decl, which is in the ""to"" context.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:11,error,error,11,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['error'],['error']
Availability,// Set the first scratch register to the first available one.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:47,avail,available,47,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,1,['avail'],['available']
Availability,"// Set the parabolic error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsMinimizerFcn.cxx:21,error,error,21,roofit/roofitcore/src/RooAbsMinimizerFcn.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsMinimizerFcn.cxx,1,['error'],['error']
Availability,"// Set the point center and its errors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:32,error,errors,32,hist/hist/src/TGraphMultiErrors.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx,1,['error'],['errors']
Availability,"// Set the syslog entity (all the information is available now)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:49,avail,available,49,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['avail'],['available']
Availability,"// Set the top-down policy based on the state of the current top zone and; // the instructions outside the zone, including the bottom zone.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:15,down,down,15,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,3,['down'],['down']
Availability,// Set the vector length to only the number of elements we care about. This; // avoids sliding down elements we're going to discard straight away.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:95,down,down,95,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['down'],['down']
Availability,// Set the warning as error flag for this specifier.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Warnings.cpp:22,error,error,22,interpreter/llvm-project/clang/lib/Basic/Warnings.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Warnings.cpp,1,['error'],['error']
Availability,// Set unsupported atomic operations as Custom so; // we can emit better error messages than fatal error; // from selectiondag.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp:73,error,error,73,interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp,2,['error'],['error']
Availability,// Set up a copy of the stack pointer for loading and storing any; // arguments that may not fit in the registers available for argument; // passing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:114,avail,available,114,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['avail'],['available']
Availability,// Set up a copy of the stack pointer for use loading and storing any; // arguments that may not fit in the registers available for argument; // passing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:118,avail,available,118,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,2,['avail'],['available']
Availability,// Set up a crash recovery context.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp:18,recover,recovery,18,interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp,1,['recover'],['recovery']
Availability,// Set up the template argument deduction information for a failure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:60,failure,failure,60,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,1,['failure'],['failure']
Availability,"// Sets Obj unless any bytes in [addr, addr + size) fall outsize of m.; // Returns unexpected_eof if error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/COFFObjectFile.cpp:101,error,error,101,interpreter/llvm-project/llvm/lib/Object/COFFObjectFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/COFFObjectFile.cpp,1,['error'],['error']
Availability,"// Sets fValues and fSize/fCapacity to the given values. The capacity is specified in number of values.; // Once a buffer is adopted, an attempt to read more values then available throws an exception.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:170,avail,available,170,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,1,['avail'],['available']
Availability,// Sets val bits for specified mask in specified dst packed instance.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h:31,mask,mask,31,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,1,['mask'],['mask']
Availability,"// Setting the move constructor and assignment operator to = default might; // seem to work, but it causes linker errors when using it because; // TIterator::operator= is not implemented.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooLinkedListIter.h:114,error,errors,114,roofit/roofitcore/inc/RooLinkedListIter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooLinkedListIter.h,1,['error'],['errors']
Availability,// Setting the position to start of file never produces EOF error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:60,error,error,60,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,1,['error'],['error']
Availability,"// Setup failure",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:9,failure,failure,9,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,3,['failure'],['failure']
Availability,// Setup the mask for this input. The indexing is tricky as we have to; // handle the unpack stride.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:13,mask,mask,13,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// Setup width for SSAA, scaled down for picking and outline materials.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/eve7/lib/EveElementsRCore.js:32,down,down,32,ui5/eve7/lib/EveElementsRCore.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/eve7/lib/EveElementsRCore.js,1,['down'],['down']
Availability,// Several blend and other instructions with masks used the wrong number of; // bits.; // Added in 3.6,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:45,mask,masks,45,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,1,['mask'],['masks']
Availability,"// Shadow next two GPRs, if available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h:28,avail,available,28,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h,1,['avail'],['available']
Availability,// Shift all elts down one.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:18,down,down,18,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,1,['down'],['down']
Availability,"// Shift all elts down one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx:18,down,down,18,math/vecops/inc/ROOT/RVec.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx,1,['down'],['down']
Availability,// Shift all elts down.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:18,down,down,18,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,1,['down'],['down']
Availability,"// Shift all elts down.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx:18,down,down,18,math/vecops/inc/ROOT/RVec.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx,1,['down'],['down']
Availability,"// Shift and cast down to the base type.; // TODO: for complete types, this should be possible with a GEP.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:18,down,down,18,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,1,['down'],['down']
Availability,"// Shift down local Z to end of line",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLUtil.cxx:9,down,down,9,graf3d/gl/src/TGLUtil.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLUtil.cxx,1,['down'],['down']
Availability,// Shift down registers reserved for the scratch RSRC.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp:9,down,down,9,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,1,['down'],['down']
Availability,// Shift down.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:9,down,down,9,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['down'],['down']
Availability,"// Shift everything after the vbptr down, unless we're using an external; // layout.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:36,down,down,36,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,1,['down'],['down']
Availability,"// Shift into local system, looking down 'normal' vector, origin at center",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLUtil.cxx:36,down,down,36,graf3d/gl/src/TGLUtil.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLUtil.cxx,1,['down'],['down']
Availability,// Shift mask depending on type size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:9,mask,mask,9,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,// Shift the mask in place,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ISelLowering.cpp:13,mask,mask,13,interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ISelLowering.cpp,1,['mask'],['mask']
Availability,"// Shifts and add used to flip and mask off the low bit:; // add (ashr (shl i32 X, 31), 31), 1 --> and (not X), 1",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:35,mask,mask,35,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,1,['mask'],['mask']
Availability,// Shifts of mask registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h:13,mask,mask,13,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,1,['mask'],['mask']
Availability,// Short-cut if the mask is all-true.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:20,mask,mask,20,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,2,['mask'],['mask']
Availability,// Shorten the way if the mask is a vector of constants.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:26,mask,mask,26,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,3,['mask'],['mask']
Availability,"// Shorten the way if the mask is a vector of constants.; // Create a build_vector pattern, with loads/poisons as necessary and then; // shuffle blend with the pass through value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:26,mask,mask,26,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,1,['mask'],['mask']
Availability,// Show the error message and exit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp:12,error,error,12,interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp,1,['error'],['error']
Availability,"// Show the error plus the usage message, and exit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp:12,error,error,12,interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp,1,['error'],['error']
Availability,"// Show the error, but treat invalid register; // number as a normal one to continue parsing; // and catch other possible errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:12,error,error,12,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,2,['error'],"['error', 'errors']"
Availability,"// Show the failures",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressHistoFit.cxx:12,failure,failures,12,test/stressHistoFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressHistoFit.cxx,1,['failure'],['failures']
Availability,// Shrink down Vec so we're performing the slidedown on a smaller LMUL.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:10,down,down,10,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['down'],['down']
Availability,"// Shuffle cost is equal to the cost of extracting element from its argument; // plus the cost of inserting them onto the result vector.; // e.g. <4 x float> has a mask of <0,5,2,7> i.e we need to extract from; // index 0 of first vector, index 1 of second vector,index 2 of first; // vector and finally index 3 of second vector and insert them at index; // <0,1,2,3> of result vector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:164,mask,mask,164,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,1,['mask'],['mask']
Availability,// Shuffle mask poisons become poison constant result elements.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:11,mask,mask,11,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['mask'],['mask']
Availability,// Shuffle mask widening should not interfere with a broadcast opportunity; // by obfuscating the operands with bitcasts.; // TODO: Avoid lowering directly from this top-level function: make this; // a query (canLowerAsBroadcast) and defer lowering to the type-based calls.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:11,mask,mask,11,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Shuffle the constant bits according to the mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:46,mask,mask,46,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Shufflevector masks are constant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:17,mask,masks,17,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,1,['mask'],['masks']
Availability,// Shut down LLVM.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsAddObjectFile/OrcV2CBindingsAddObjectFile.c:8,down,down,8,interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsAddObjectFile/OrcV2CBindingsAddObjectFile.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsAddObjectFile/OrcV2CBindingsAddObjectFile.c,8,['down'],['down']
Availability,// Shut down services.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/SimpleRemoteEPCServer.cpp:8,down,down,8,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/SimpleRemoteEPCServer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/SimpleRemoteEPCServer.cpp,1,['down'],['down']
Availability,"// Shut down the worker assumig that it is not processing",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:8,down,down,8,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,3,['down'],['down']
Availability,"// Sigma's robust estimator",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:11,robust,robust,11,hist/hist/src/TKDE.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx,1,['robust'],['robust']
Availability,"// Sigma's robust estimator; //printf(""weight case - stat: m = %f, s= %f, sr = %f \n"",fMean, fSigma, midspread);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:11,robust,robust,11,hist/hist/src/TKDE.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx,1,['robust'],['robust']
Availability,// Sign bit set in i8 mask means zero element.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:22,mask,mask,22,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Sign bits must extend down to the lowest i16.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:25,down,down,25,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['down'],['down']
Availability,// SignBits may be out-of-sync with Known.countMinSignBits(). Mask out; // high bits of Known.Zero to avoid conflicts.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:62,Mask,Mask,62,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,1,['Mask'],['Mask']
Availability,"// Signal a fatal error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLookup.cpp:18,error,error,18,interpreter/cling/lib/Interpreter/DynamicLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLookup.cpp,1,['error'],['error']
Availability,"// Signal and Bg not separated; // get discriminator error direct from the foam",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodPDEFoam.cxx:53,error,error,53,tmva/tmva/src/MethodPDEFoam.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodPDEFoam.cxx,1,['error'],['error']
Availability,"// Signal displays that an error has occurred.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/TextInput.cpp:27,error,error,27,core/textinput/src/textinput/TextInput.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/TextInput.cpp,1,['error'],['error']
Availability,"// Signals from GeoManager.; // These are not available any more ... colors in list-tree not refreshed; // properly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveGeoNode.h:46,avail,available,46,graf3d/eve/inc/TEveGeoNode.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveGeoNode.h,1,['avail'],['available']
Availability,"// Signed 16 bit constant; // If this fails, the parent routine will give an error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:77,error,error,77,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,2,['error'],['error']
Availability,"// Silence deduplication error messages",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooAbsCollection.cxx:25,error,error,25,roofit/roofitcore/test/testRooAbsCollection.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooAbsCollection.cxx,2,['error'],['error']
Availability,"// Silence error to come next:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooAbsCollection.cxx:11,error,error,11,roofit/roofitcore/test/testRooAbsCollection.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooAbsCollection.cxx,1,['error'],['error']
Availability,"// Silence possible error message from TFile constructor if this is a tree name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TSimpleAnalysis.cxx:20,error,error,20,tree/treeplayer/src/TSimpleAnalysis.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TSimpleAnalysis.cxx,1,['error'],['error']
Availability,"// Silent error printout on first attempt",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx:10,error,error,10,proof/proofplayer/src/TProofPlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx,1,['error'],['error']
Availability,// Similar to CSRWR but with a write mask.; // Operand 0: A chain pointer.; // Operand 1: The new value to write.; // Operand 2: The write mask.; // Operand 3: The address of the required CSR.; // Result 0: The old value of the CSR.; // Result 1: The new chain pointer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.h:37,mask,mask,37,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.h,2,['mask'],['mask']
Availability,"// Similar to above, but the shift amount may be extended after masking,; // so return the extended value as the parameter for the intrinsic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:64,mask,masking,64,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['mask'],['masking']
Availability,"// Similar to above, only this time treat the step value as signed.; // This covers loops that count down.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:101,down,down,101,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['down'],['down']
Availability,// Similar to above: an unsigned overflow comparison may use offset + mask:; // ((Op1 + C) & C) u< Op1 --> Op1 != 0; // ((Op1 + C) & C) u>= Op1 --> Op1 == 0; // Op0 u> ((Op0 + C) & C) --> Op0 != 0; // Op0 u<= ((Op0 + C) & C) --> Op0 == 0,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:70,mask,mask,70,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['mask'],['mask']
Availability,"// Similar to above: if the mask matches the zext input width, then the; // 'and' can be eliminated, so we can truncate the other variable op:; // and (bo (zext X), Y), C --> zext (bo X, (trunc Y))",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:28,mask,mask,28,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['mask'],['mask']
Availability,"// Similarly, if we take the mask (eg 3,6,1,0) and take the cost with; // undef for each lane (eg u,6,1,0 or 3,u,1,0 etc), we can use a single; // lane insert to fixup the result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/PerfectShuffle/PerfectShuffle.cpp:29,mask,mask,29,interpreter/llvm-project/llvm/utils/PerfectShuffle/PerfectShuffle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/PerfectShuffle/PerfectShuffle.cpp,1,['mask'],['mask']
Availability,// Simple wrapper to add the name of a variable or (if no variable is; // available) a DeclarationName into a diagnostic.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:74,avail,available,74,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['avail'],['available']
Availability,// Simplify Mask based on demanded element.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:12,Mask,Mask,12,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Mask'],['Mask']
Availability,"// Simplify comparisons of related pointers using a powerful, recursive; // GEP-walk when we have target data available..",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:110,avail,available,110,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['avail'],['available']
Availability,"// Simplify conditional branches and switches with a constant operand. We try; // to prune these out when cloning, but if the simplification required; // looking through PHI nodes, those are only available after forming the full; // basic block. That may leave some here, and we still want to prune the dead; // code as early as possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:196,avail,available,196,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,1,['avail'],['available']
Availability,// Simplify mask if we have an undemanded element that is not undef.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:12,mask,mask,12,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// Simplify mask using undef elements from LHS/RHS.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:12,mask,mask,12,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['mask'],['mask']
Availability,// Simplify source operands based on shuffle mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:45,mask,mask,45,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['mask']
Availability,// Simplify source operands based on shuffle mask.; // TODO - merge this into combineX86ShufflesRecursively.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:45,mask,mask,45,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// Simplify the 1-into-3 and 3-into-1 cases with a single pshufd. For all; // such inputs we can swap two of the dwords across the half mark and end up; // with <=2 inputs to each half in each half. Once there, we can fall through; // to the generic code below. For example:; //; // Input: [a, b, c, d, e, f, g, h] -PSHUFD[0,2,1,3]-> [a, b, e, f, c, d, g, h]; // Mask: [0, 1, 2, 7, 4, 5, 6, 3] -----------------> [0, 1, 4, 7, 2, 3, 6, 5]; //; // However in some very rare cases we have a 1-into-3 or 3-into-1 on one half; // and an existing 2-into-2 on the other half. In this case we may have to; // pre-shuffle the 2-into-2 half to avoid turning it into a 3-into-1 or; // 1-into-3 which could cause us to cycle endlessly fixing each side in turn.; // Fortunately, we don't have to handle anything but a 2-into-2 pattern; // because any other situation (including a 3-into-1 or 1-into-3 in the other; // half than the one we target for fixing) will be fixed when we re-enter this; // path. We will also combine away any sequence of PSHUFD instructions that; // result into a single instruction. Here is an example of the tricky case:; //; // Input: [a, b, c, d, e, f, g, h] -PSHUFD[0,2,1,3]-> [a, b, e, f, c, d, g, h]; // Mask: [3, 7, 1, 0, 2, 7, 3, 5] -THIS-IS-BAD!!!!-> [5, 7, 1, 0, 4, 7, 5, 3]; //; // This now has a 1-into-3 in the high half! Instead, we do two shuffles:; //; // Input: [a, b, c, d, e, f, g, h] PSHUFHW[0,2,1,3]-> [a, b, c, d, e, g, f, h]; // Mask: [3, 7, 1, 0, 2, 7, 3, 5] -----------------> [3, 7, 1, 0, 2, 7, 3, 6]; //; // Input: [a, b, c, d, e, g, f, h] -PSHUFD[0,2,1,3]-> [a, b, e, g, c, d, f, h]; // Mask: [3, 7, 1, 0, 2, 7, 3, 6] -----------------> [5, 7, 1, 0, 4, 7, 5, 6]; //; // The result is fine to be handled by the generic logic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:363,Mask,Mask,363,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,4,['Mask'],['Mask']
Availability,// Simplify this down to something we can handle.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp:17,down,down,17,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp,4,['down'],['down']
Availability,// Simplify variable target shuffle masks based on the demanded elements.; // TODO: Handle DemandedBits in mask indices as well?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:36,mask,masks,36,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['mask'],"['mask', 'masks']"
Availability,// SimplifyDemandedBits may have optimized the mask so try restoring any; // bits that are known zero.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelDAGToDAG.cpp:47,mask,mask,47,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelDAGToDAG.cpp,3,['mask'],['mask']
Availability,"// Simply check addressIsReturn, as ret is always reliable, both for; // regular call and tail call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.h:50,reliab,reliable,50,interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.h,1,['reliab'],['reliable']
Availability,"// Simply consider every block pointed by seh frame block as parants.; // This adds some unnecessary keep-alive edges to unwind info blocks,; // (xdata) but these blocks are usually dead by default, so they wouldn't; // count for the fate of seh frame block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/SEHFrameSupport.h:106,alive,alive,106,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/SEHFrameSupport.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/SEHFrameSupport.h,1,['alive'],['alive']
Availability,"// Simulate the flow of defs through the CFG and recalculate AvailableIn/Out; // sets of each BB until it converges. If any def is proved to be an; // unrelocated pointer, it will be removed from all BBSs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:61,Avail,AvailableIn,61,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,1,['Avail'],['AvailableIn']
Availability,"// Since LI is implicitly moved downwards past the lifted instructions,; // none of them may modify its source.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:32,down,downwards,32,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,1,['down'],['downwards']
Availability,"// Since SPIR-V cannot represent constant expression, constant expressions; // in LLVM IR need to be lowered to instructions. For each function,; // the constant expressions used by instructions of the function are replaced; // by instructions placed in the entry block since it dominates all other BBs.; // Each constant expression only needs to be lowered once in each function; // and all uses of it by instructions in that function are replaced by; // one instruction.; // TODO: remove redundant instructions for common subexpression.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVRegularizer.cpp:490,redundant,redundant,490,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVRegularizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVRegularizer.cpp,1,['redundant'],['redundant']
Availability,"// Since TargetLowering::getRegForInlineAsmConstraint uses the name of the; // TableGen record rather than the AsmName to choose registers for InlineAsm; // constraints, plus we want to match those names to the widest floating point; // register type available, manually select floating point registers here.; //; // The second case is the ABI name of the register, so that frontends can also; // use the ABI names in register constraint lists.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelLowering.cpp:251,avail,available,251,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelLowering.cpp,2,['avail'],['available']
Availability,"// Since an immediate invocation is a full expression itself - it requires; // an additional ExprWithCleanups node, but it can participate to a bigger; // full expression which actually requires cleanups to be run after so; // create ExprWithCleanups without using MaybeCreateExprWithCleanups as it; // may discard cleanups for outer expression too early.; // Note that ExprWithCleanups created here must always have empty cleanup; // objects:; // - compound literals do not create cleanup objects in C++ and immediate; // invocations are C++-only.; // - blocks are not allowed inside constant expressions and compiler will; // issue an error if they appear there.; //; // Hence, in correct code any cleanup objects created inside current; // evaluation context must be outside the immediate invocation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:637,error,error,637,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['error'],['error']
Availability,"// Since mutable is not a viable storage class specifier in C, there is; // no reason to treat it as an extension. Instead, diagnose as an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:139,error,error,139,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['error'],['error']
Availability,"// Since none of C++'s keywords match [a-f]+, accepting just tok::l_brace,; // tok::r_brace, tok::minus, tok::identifier (think C000) and; // tok::numeric_constant (0000) should be enough. But the spelling of the; // uuid argument is checked later anyways, so there's no harm in accepting; // almost anything here.; // cl is very strict about whitespace in this form and errors out if any; // is present, so check the space flags on the tokens.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:371,error,errors,371,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,1,['error'],['errors']
Availability,"// Since our optimizations should never increase the number of operations, the; // new expression can usually be written reusing the existing binary operators; // from the original expression tree, without creating any new instructions,; // though the rewritten expression may have a completely different topology.; // We take care to not change anything if the new expression will be the same; // as the original. If more than trivial changes (like commuting operands); // were made then we are obliged to clear out any optional subclass data like; // nsw flags.; /// NodesToRewrite - Nodes from the original expression available for writing; /// the new expression into.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:621,avail,available,621,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,1,['avail'],['available']
Availability,"// Since the A15SDOptimizer pass can insert VDUP instructions, it can only be; // enabled when NEON is available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/A15SDOptimizer.cpp:103,avail,available,103,interpreter/llvm-project/llvm/lib/Target/ARM/A15SDOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/A15SDOptimizer.cpp,1,['avail'],['available']
Availability,"// Since the NBits is identical for all shifts, if the outermost and; // innermost shifts are identical, then outermost shifts are redundant.; // If we had truncation, do keep it though.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:131,redundant,redundant,131,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,1,['redundant'],['redundant']
Availability,"// Since the bitmap identifies the executed test vectors for an MC/DC; // DecisionRegion, all of the information is now available to process.; // This is where the bulk of the MC/DC progressing takes place.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMapping.cpp:120,avail,available,120,interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMapping.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMapping.cpp,1,['avail'],['available']
Availability,// Since the error can be related to the profile or the binary we do not; // pass whence. Instead additional context is provided where necessary in; // the error message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profdata/llvm-profdata.cpp:13,error,error,13,interpreter/llvm-project/llvm/tools/llvm-profdata/llvm-profdata.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profdata/llvm-profdata.cpp,2,['error'],['error']
Availability,"// Since the exception code is actually of NTSTATUS type, we use the; // Microsoft-recommended 0xE prefix, to signify that this is a user error.; // This value is a combination of the customer field (bit 29) and severity; // field (bits 30-31) in the NTSTATUS specification.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp:138,error,error,138,interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp,1,['error'],['error']
Availability,"// Since the mask is applied to Src1:Src2, Src1 bytes must be offset; // by sizeof(Src2) = 4",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:13,mask,mask,13,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['mask'],['mask']
Availability,// Since the max shift amount is a power of 2 we can subtract 1 to make a; // mask that covers the bits needed to represent all shift amounts.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelDAGToDAG.cpp:78,mask,mask,78,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelDAGToDAG.cpp,2,['mask'],['mask']
Availability,"// Since the user can not control the tolerance of this newly created matrix; // we put it to the smallest possible number",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TMatrixT.cxx:38,toler,tolerance,38,math/matrix/src/TMatrixT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TMatrixT.cxx,2,['toler'],['tolerance']
Availability,"// Since the user does not want this branch to be loaded anyway, we just; // skip it. This prevents us from warning the user that the method might; // be on a disabled branch. However, and more usefully, this allows the; // user to avoid error messages from branches that cannot be currently; // read without warnings/errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormula.cxx:238,error,error,238,tree/treeplayer/src/TTreeFormula.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormula.cxx,2,['error'],"['error', 'errors']"
Availability,"// Since there's no compile units available, walk the line tables and; // extract out any referenced paths.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp:34,avail,available,34,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp,1,['avail'],['available']
Availability,"// Since this is only reached for Thumb-2 targets, the BFC instruction; // should always be available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp:92,avail,available,92,interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp,1,['avail'],['available']
Availability,"// Since we clobber the destination of a copy, the semantic of Src's; // ""DefRegs"" to contain Def is no longer effectual. We will also need; // to remove the record from the copy maps that indicates Src defined; // Def. Failing to do so might cause the target to miss some; // opportunities to further eliminate redundant copy instructions.; // Consider the following sequence during the; // ForwardCopyPropagateBlock procedure:; // L1: r0 = COPY r9 <- TrackMI; // L2: r0 = COPY r8 <- TrackMI (Remove r9 defined r0 from tracker); // L3: use r0 <- Remove L2 from MaybeDeadCopies; // L4: early-clobber r9 <- Clobber r9 (L2 is still valid in tracker); // L5: r0 = COPY r8 <- Remove NopCopy",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:312,redundant,redundant,312,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,1,['redundant'],['redundant']
Availability,"// Since we had a phi translation failure, the cache for CacheKey won't; // include all of the entries that we need to immediately satisfy future; // queries. Mark this in NonLocalPointerDeps by setting the; // BBSkipFirstBlockPair pointer to null. This requires reuse of the; // cached value to do more work but not miss the phi trans failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:34,failure,failure,34,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,2,['failure'],['failure']
Availability,"// Since we have added the potential SchedGroups from bottom up, but; // traversed the DAG from top down, parse over the groups from last to; // first. If we fail to do this for the greedy algorithm, the solution will; // likely not be good in more complex cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp:100,down,down,100,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp,1,['down'],['down']
Availability,"// Since we know that this either implicit int (which is rare) or an; // error, do lookahead to try to do better recovery. This never applies; // within a type specifier. Outside of C++, we allow this even if the; // language doesn't ""officially"" support implicit int -- we support; // implicit int as an extension in some language modes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:73,error,error,73,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,2,"['error', 'recover']","['error', 'recovery']"
Availability,// Since we previously made sure that 2 registers are available; // we expect that a real register number will be returned.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp:54,avail,available,54,interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp,1,['avail'],['available']
Availability,"// Since we use RPO traversal, if we need to repair a definition; // this means this definition could be:; // 1. Used by PHIs (i.e., this VReg has been visited as part of the; // uses of a phi.), or; // 2. Part of a target specific instruction (i.e., the target applied; // some register class constraints when creating the instruction.); // If the constraints come for #2, the target said that another mapping; // is supported so we may just drop them. Indeed, if we do not change; // the number of registers holding that value, the uses will get fixed; // when we get to them.; // Uses in PHIs may have already been proceeded though.; // If the constraints come for #1, then, those are weak constraints and; // no actual uses may rely on them. However, the problem remains mainly; // the same as for #2. If the value stays in one register, we could; // just switch the register bank of the definition, but we would need to; // account for a repairing cost for each phi we silently change.; //; // In any case, if the value needs to be broken down into several; // registers, the repairing is not local anymore as we need to patch; // every uses to rebuild the value in just one register.; //; // To summarize:; // - If the value is in a physical register, we can do the split and; // fix locally.; // Otherwise if the value is in a virtual register:; // - If the value remains in one register, we do not have to split; // just switching the register bank would do, but we need to account; // in the repairing cost all the phi we changed.; // - If the value spans several registers, then we cannot do a local; // repairing.; // Check if this is a physical or virtual register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:45,repair,repair,45,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,6,"['down', 'repair']","['down', 'repair', 'repairing']"
Availability,"// Since we're not changing the ABI to make this a tail call, the memory; // operands are already available in the caller's incoming argument space.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:98,avail,available,98,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,2,['avail'],['available']
Availability,// Single-precision floating-point instructions are available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TargetParser/LoongArchTargetParser.h:52,avail,available,52,interpreter/llvm-project/llvm/include/llvm/TargetParser/LoongArchTargetParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TargetParser/LoongArchTargetParser.h,1,['avail'],['available']
Availability,// Sink down a layer of the type for the next iteration.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:8,down,down,8,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['down'],['down']
Availability,// Sink the `and` instruction only if the mask would fit into a modified; // immediate operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:42,mask,mask,42,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['mask'],['mask']
Availability,// Sink the error and return a nothing value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-tli-checker/llvm-tli-checker.cpp:12,error,error,12,interpreter/llvm-project/llvm/tools/llvm-tli-checker/llvm-tli-checker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-tli-checker/llvm-tli-checker.cpp,1,['error'],['error']
Availability,// Sink the instruction we'll need to harden as far as we can down; // the graph.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:62,down,down,62,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,1,['down'],['down']
Availability,// Size = 64 regardless of success or failure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Disassembler/AMDGPUDisassembler.cpp:38,failure,failure,38,interpreter/llvm-project/llvm/lib/Target/AMDGPU/Disassembler/AMDGPUDisassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Disassembler/AMDGPUDisassembler.cpp,1,['failure'],['failure']
Availability,"// Size information about scalable vectors is not available, so we cannot; // deduce whether indexing at n is undefined behaviour or not. Bail out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:50,avail,available,50,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,1,['avail'],['available']
Availability,"// Skip ANDing with exec if the break condition is already masked by exec; // because it is a V_CMP in the same basic block. (We know the break; // condition operand was an i1 in IR, so if it is a VALU instruction it must; // be one with a carry-out.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerControlFlow.cpp:59,mask,masked,59,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerControlFlow.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerControlFlow.cpp,1,['mask'],['masked']
Availability,"// Skip C-style comment.; // Note that we do not care about skipping the C++-style comments.; // If the line contains ""//"", it may not contain any processable; // preprocessing directive. Just return CurPtr pointing to; // the first '/' in this case. We also do not care about; // incorrect symbols after the first '/' - we are in lines-skipping; // mode, so incorrect code is allowed to some extent.; // Set TokStart to the beginning of the comment to enable proper; // diagnostic printing in case of error in SkipCComment().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGLexer.cpp:502,error,error,502,interpreter/llvm-project/llvm/lib/TableGen/TGLexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGLexer.cpp,1,['error'],['error']
Availability,// Skip Sub as we only match constant masks which will canonicalize to use; // add.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:38,mask,masks,38,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['mask'],['masks']
Availability,// Skip all the checks below if we have a type error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:47,error,error,47,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['error'],['error']
Availability,"// Skip analysis of inheriting constructors as top-level functions. These; // constructors don't even have a body written down in the code, so even if; // we find a bug, we won't be able to display it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp:122,down,down,122,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp,1,['down'],['down']
Availability,"// Skip any remaining white space; // while (cur<size && isspace(str[cur])) ++cur;; // Do not:; // Parse error on anything but a null terminator; // if (cur<size) return -1;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/ROOT/StringConv.hxx:105,error,error,105,core/base/inc/ROOT/StringConv.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/ROOT/StringConv.hxx,1,['error'],['error']
Availability,"// Skip any unused cells or cells that extend down thru; // subsequent rows",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlTable.cxx:46,down,down,46,gui/guihtml/src/TGHtmlTable.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlTable.cxx,1,['down'],['down']
Availability,"// Skip any whitespaces or comments after a preprocessing directive.; // The method returns true upon reaching either end of the line; // or end of the file. If there is a multiline C-style comment; // after the preprocessing directive, the method skips; // the comment, so the final CurPtr may point to one of the next lines.; // The method returns false, if an error occurred during skipping; // C- or C++-style comment, or a non-whitespace symbol appears; // after the preprocessing directive.; //; // The method maybe called both during lines-skipping and tokens; // processing. It actually verifies that only whitespaces or/and; // comments follow a preprocessing directive.; //; // After the execution of this mehod, CurPtr points either to new line; // symbol, buffer end or non-whitespace symbol following the preprocesing; // directive.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGLexer.h:363,error,error,363,interpreter/llvm-project/llvm/lib/TableGen/TGLexer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGLexer.h,1,['error'],['error']
Availability,"// Skip any whitespaces starting from CurPtr. The method is used; // only in the lines-skipping mode to find the first non-whitespace; // symbol after or at CurPtr. Allowed whitespaces are ' ', '\t', '\n'; // and '\r'. The method skips C-style comments as well, because; // it is used to find the beginning of the preprocessing directive.; // If we do not handle C-style comments the following code would; // result in incorrect detection of a preprocessing directive:; // /*; // #ifdef NAME; // */; // As long as we skip C-style comments, the following code is correctly; // recognized as a preprocessing directive:; // /* first line comment; // second line comment */ #ifdef NAME; //; // The method returns true upon reaching the first non-whitespace symbol; // or EOF, CurPtr is set to point to this symbol. The method returns false,; // if an error occurred during skipping of a C-style comment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGLexer.h:847,error,error,847,interpreter/llvm-project/llvm/lib/TableGen/TGLexer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGLexer.h,1,['error'],['error']
Availability,// Skip code until we get to #endif. This helps with recovery by not; // emitting an error when the #endif is reached.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:53,recover,recovery,53,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,2,"['error', 'recover']","['error', 'recovery']"
Availability,// Skip code until we get to #endif. This helps with recovery by; // not emitting an error when the #endif is reached.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:53,recover,recovery,53,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,2,"['error', 'recover']","['error', 'recovery']"
Availability,// Skip filling defaults if we're just querying what is availible.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:56,avail,availible,56,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['avail'],['availible']
Availability,// Skip globals that we can't lower and leave it for the backend to error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/XCore/XCoreLowerThreadLocal.cpp:68,error,error,68,interpreter/llvm-project/llvm/lib/Target/XCore/XCoreLowerThreadLocal.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/XCore/XCoreLowerThreadLocal.cpp,1,['error'],['error']
Availability,// Skip if mask of other elements don't equal our expected order.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:11,mask,mask,11,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['mask'],['mask']
Availability,// Skip if not the correct element or mask of other elements don't equal; // to our expected order.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:38,mask,mask,38,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['mask'],['mask']
Availability,// Skip mask operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp:8,mask,mask,8,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,3,['mask'],['mask']
Availability,// Skip mask operand.; // promote the vector operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp:8,mask,mask,8,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,1,['mask'],['mask']
Availability,// Skip mask-preserved regs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:8,mask,mask-preserved,8,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,1,['mask'],['mask-preserved']
Availability,"// Skip one register if the first unallocated register has an even register; // number and there are still argument registers available which have not been; // allocated yet. RegNum is actually an index into ArgRegs, which means we; // need to skip a register if RegNum is odd.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp:126,avail,available,126,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp,1,['avail'],['available']
Availability,// Skip over errors if we are only fixing warnings.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp:13,error,errors,13,interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp,1,['error'],['errors']
Availability,// Skip redundant include stacks altogether.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp:8,redundant,redundant,8,interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp,1,['redundant'],['redundant']
Availability,"// Skip reports within the 'std' namespace. Although these can sometimes be; // the user's fault, we currently don't report them very well, and; // Note that this will not help for any other data structure libraries, like; // TR1, Boost, or llvm/ADT.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:91,fault,fault,91,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,1,['fault'],['fault']
Availability,"// Skip retrieve the value if that template parameter has cuda device; // attribute, i.e. that value is not available at the host side.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:108,avail,available,108,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,1,['avail'],['available']
Availability,// Skip the archive and consume the error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TextAPI/BinaryReader/DylibReader.cpp:36,error,error,36,interpreter/llvm-project/llvm/lib/TextAPI/BinaryReader/DylibReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TextAPI/BinaryReader/DylibReader.cpp,1,['error'],['error']
Availability,// Skip the mask register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:12,mask,mask,12,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['mask'],['mask']
Availability,"// Skip the mask, and the Glue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:12,mask,mask,12,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,"// Skip the switch body.; // FIXME: This is not optimal recovery, but parsing the body is more; // dangerous due to the presence of case and default statements, which; // will have no place to connect back with the switch.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:56,recover,recovery,56,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,1,['recover'],['recovery']
Availability,// Skip this line table as it isn't valid. No need to create an error; // here because we validate this in the .debug_info verifier.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFVerifier.cpp:64,error,error,64,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFVerifier.cpp,1,['error'],['error']
Availability,// Skip token for error recovery.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:18,error,error,18,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,108,"['error', 'recover']","['error', 'recovery']"
Availability,// Slide this vector register down by the desired number of elements in order; // to place the desired subvector starting at element 0.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:30,down,down,30,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['down'],['down']
Availability,// Soft mask,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:8,mask,mask,8,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['mask'],['mask']
Availability,"// Solving an equation q(x) = 0 with coefficients in modular arithmetic; // is really solving a set of equations q(x) = kR for k = 0, 1, 2, ...,; // and R = 2^BitWidth.; // Since we're trying not only to find exact solutions, but also values; // that ""wrap around"", such a set will always have a solution, i.e. an x; // that satisfies at least one of the equations, or such that |q(x)|; // exceeds kR, while |q(x-1)| for the same k does not.; //; // We need to find a value k, such that Ax^2 + Bx + C = kR will have a; // positive solution n (in the above sense), and also such that the n; // will be the least among all solutions corresponding to k = 0, 1, ...; // (more precisely, the least element in the set; // { n(k) | k is such that a solution n(k) exists }).; //; // Consider the parabola (over real numbers) that corresponds to the; // quadratic equation. Since A > 0, the arms of the parabola will point; // up. Picking different values of k will shift it up and down by R.; //; // We want to shift the parabola in such a way as to reduce the problem; // of solving q(x) = kR to solving shifted_q(x) = 0.; // (The interesting solutions are the ceilings of the real number; // solutions.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp:973,down,down,973,interpreter/llvm-project/llvm/lib/Support/APInt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp,1,['down'],['down']
Availability,"// Some Thumb instructions have two operand forms that are not; // available as three operand, convert to two operand form if possible.; //; // FIXME: We would really like to be able to tablegen'erate this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:67,avail,available,67,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['avail'],['available']
Availability,"// Some arithmetic, load and store operations have specific instructions; // to cast up/down their types automatically at no extra cost.; // TODO: Get these tables to know at least what the related operations are.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:88,down,down,88,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,1,['down'],['down']
Availability,"// Some block ends, such as funclet returns, create masks. Put the mask on; // the last instruction of the block, because MBB slot index intervals are; // half-open.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:52,mask,masks,52,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,2,['mask'],"['mask', 'masks']"
Availability,"// Some block starts, such as EH funclets, create masks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:50,mask,masks,50,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,1,['mask'],['masks']
Availability,"// Some columns are still unknown, we need to understand if the error; // should be printed or if the user requested to explicitly disable it.; // Look for a possible overlap between the unknown columns and the; // columns we should ignore for the purpose of the following exception",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx:64,error,error,64,tree/dataframe/src/RDFInterfaceUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx,1,['error'],['error']
Availability,"// Some diagnostics need to vary with subtarget features, so they are handled; // here. For example, the DPR class has either 16 or 32 registers, depending; // on the FPU available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:171,avail,available,171,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['avail'],['available']
Availability,"// Some error occurred, if caller wants to examine diagnostics, pass it the; // ASTUnit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:8,error,error,8,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,1,['error'],['error']
Availability,"// Some events with evaluation errors. Return ""badness"" of errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/batchcompute/src/RooBatchCompute.cxx:31,error,errors,31,roofit/batchcompute/src/RooBatchCompute.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/batchcompute/src/RooBatchCompute.cxx,8,['error'],['errors']
Availability,"// Some mask scalar intrinsics rely on checking if only one bit is set; // and implement it in C code like this:; // A[0] = (U & 1) ? A[0] : W[0];; // This creates some redundant instructions that break pattern matching.; // fold (select (setcc (and (X, 1), 0, seteq), Y, Z)) -> select(and(X, 1),Z,Y)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:8,mask,mask,8,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,"['mask', 'redundant']","['mask', 'redundant']"
Availability,// Some targets erroneously report success after emitting an error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/MCTargetAsmParser.cpp:61,error,error,61,interpreter/llvm-project/llvm/lib/MC/MCParser/MCTargetAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/MCTargetAsmParser.cpp,1,['error'],['error']
Availability,"// Some versions of glibc and gcc use idioms (particularly in their malloc; // routines) that add a pointer-sized integer (known to be a pointer value); // to a null pointer in order to cast the value back to an integer or as; // part of a pointer alignment algorithm. This is undefined behavior, but; // we'd like to be able to compile programs that use it.; //; // Normally, we'd generate a GEP with a null-pointer base here in response; // to that code, but it's also UB to dereference a pointer created that; // way. Instead (as an acknowledged hack to tolerate the idiom) we will; // generate a direct cast of the integer value to a pointer.; //; // The idiom (p = nullptr + N) is not met if any of the following are true:; //; // The operation is subtraction.; // The index is not pointer-sized.; // The pointer type is not byte-sized.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp:557,toler,tolerate,557,interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,1,['toler'],['tolerate']
Availability,"// Some vregs can be deleted as redundant in the meantime. Mark those; // as DBG_VALUE $noreg. Additionally, some normal instructions are; // quickly deleted, leaving dangling references to vregs with no def.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:32,redundant,redundant,32,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,1,['redundant'],['redundant']
Availability,"// Some zexts will now have become redundant, along with their trunc; // operands, so remove them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:35,redundant,redundant,35,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,1,['redundant'],['redundant']
Availability,// Somebody probably forgot to close the template. Skip ahead and; // try to get out of the expression. This error is currently; // subsumed by whatever goes on in ParseTemplateParameter.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:109,error,error,109,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,1,['error'],['error']
Availability,"// Something went wrong parsing the brackets, in which case,; // ParseBracketDeclarator has emitted an error, and we don't need to emit; // one here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:103,error,error,103,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['error'],['error']
Availability,"// Sometimes it's necessary that we cast the function we want to call first; // to its explicit function type before calling it. This is supposed to prevent; // that we accidentially ending up in a function that is not the one we're; // supposed to call here (e.g. because the C++ function lookup decides to take; // another function that better fits).; // This method has some problems, e.g. when we call a function with default; // arguments and we don't provide all arguments, we would fail with this pattern.; // Same applies with member methods which seem to cause parse failures even when; // we supply the object parameter.; // Therefore we only use it in cases where we know it works and set this variable; // to true when we do.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallFunc.cxx:576,failure,failures,576,core/metacling/src/TClingCallFunc.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallFunc.cxx,1,['failure'],['failures']
Availability,"// Sometimes the VMSET is wrapped in a COPY_TO_REGCLASS, e.g. if the mask came; // from an extract_subvector or insert_subvector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:69,mask,mask,69,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,"// Sometimes, the calling code uses an empty RooArgSet to request evaluation; // without normalization set instead of following the `nullptr` convention.; // To remove this ambiguity which might not always be correctly handled in; // downstream code, we set `normalisationSet` to nullptr if it is an empty set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsReal.h:234,down,downstream,234,roofit/roofitcore/inc/RooAbsReal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsReal.h,1,['down'],['downstream']
Availability,"// Sometimes, the calling code uses an empty RooArgSet to request evaluation; // without normalization set instead of following the `nullptr` convention.; // To remove this ambiguity which might not always be correctly handled in; // downstream code, we set `normalisationSet` to nullptr if it is pointing; // to an empty set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsReal.h:234,down,downstream,234,roofit/roofitcore/inc/RooAbsReal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsReal.h,1,['down'],['downstream']
Availability,"// Sometimes, the socket from the previous test needs some time to close, so; // we introduce a latency here. A more robust and fast approach might be to; // do the following on the bind side:; // 1. first try another port, e.g. increase by one; // 2. if that doesn't work, do the latency and retry the original port; // The connect side then also needs to change, because it doesn't know which; // port the bind side will bind to. The connect side could try connecting to; // both options asynchronously, and then in a loop check both for signs of; // life. If one comes alive, transfer ownership of that pointer to the pointer; // you want to eventually use (`socket`) and that's it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitZMQ/test/test_ZMQ.cpp:117,robust,robust,117,roofit/roofitZMQ/test/test_ZMQ.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitZMQ/test/test_ZMQ.cpp,2,"['alive', 'robust']","['alive', 'robust']"
Availability,"// Sort OpcodeMappings elements based on their CPU and predicate masks.; // As a last resort, order elements by opcode identifier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenSchedule.cpp:65,mask,masks,65,interpreter/llvm-project/llvm/utils/TableGen/CodeGenSchedule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenSchedule.cpp,1,['mask'],['masks']
Availability,"// Sort by probability first, number of bits second, bit mask third.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp:57,mask,mask,57,interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp,1,['mask'],['mask']
Availability,"// Sort elements by mask popcount, so that we prioritize resource units over; // resource groups, and smaller groups over larger groups.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/InstrBuilder.cpp:20,mask,mask,20,interpreter/llvm-project/llvm/lib/MCA/InstrBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/InstrBuilder.cpp,1,['mask'],['mask']
Availability,// Sort the error paths from longest to shortest.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:12,error,error,12,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,1,['error'],['error']
Availability,"// Sort the indices using the provided comparison function; // We use std::stable_sort here because the libc++ implementation of std::sort; // is not standard-compliant until LLVM 14 which caused errors on the mac nodes; // of our CI, related issue: https://github.com/llvm/llvm-project/issues/21211",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:196,error,errors,196,hist/hist/src/TGraph.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx,1,['error'],['errors']
Availability,"// Sort the instructions by the number of available choices for scheduling,; // least to most. Use the number of critical resources as the tie breaker.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:42,avail,available,42,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['avail'],['available']
Availability,// Sort the nodes in Candidates in top-down order and save the nodes; // in Orders.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:39,down,down,39,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,1,['down'],['down']
Availability,// Sort the nodes in WorkSet in top-down order and save the nodes; // in Orders. Orders will be used for hoisting in runHoistSpills.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:36,down,down,36,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,1,['down'],['down']
Availability,// Source code for this particular line; // (in case if `Source` is not available),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DIContext.h:72,avail,available,72,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DIContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DIContext.h,1,['avail'],['available']
Availability,"// Source embedding is a vendor extension to DWARF v5. By now we have; // checked if a DWARF version was stated explicitly, and have otherwise; // fallen back to the target default, so if this is still not at least 5; // we emit an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:232,error,error,232,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['error'],['error']
Availability,// Source of copy is no longer available for propagation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:31,avail,available,31,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,1,['avail'],['available']
Availability,"// Space available (+1 for terminator)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/Stringio.cxx:9,avail,available,9,core/base/src/Stringio.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/Stringio.cxx,1,['avail'],['available']
Availability,// Space for two vector args and sixteen mask indices,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:41,mask,mask,41,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,1,['mask'],['mask']
Availability,"// Sparc uses FP-based references in general, even when ""hasFP"" is; // false. That function is rather a misnomer, because %fp is; // actually always available, unless isLeafProc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp:149,avail,available,149,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp,1,['avail'],['available']
Availability,"// Special case 1, all registers used by ISEL are the same one.; // The non-redundant isel 0, 0, 0, N would not satisfy these conditions; // as it would be ISEL %R0, %ZERO, %R0, %CRN.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp:76,redundant,redundant,76,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp,1,['redundant'],['redundant']
Availability,"// Special case for amdgcn.ballot:; // %Cond = i1 (and/or combination of i1 ISD::SETCCs); // %VCMP = i(WaveSize) AMDGPUISD::SETCC (ext %Cond), 0, setne/seteq; // =>; // Use i1 %Cond value instead of i(WaveSize) %VCMP.; // This is possible because divergent ISD::SETCC is selected as V_CMP and; // Cond becomes a i(WaveSize) full mask value.; // Note that ballot doesn't use SETEQ condition but its easy to support it; // here for completeness, so in this case Negate is set true on return.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelDAGToDAG.cpp:329,mask,mask,329,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,"// Special case for s_mul_u64. There is not a vector equivalent of; // s_mul_u64. Hence, we have to break down s_mul_u64 into 32-bit vector; // multiplications.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp:106,down,down,106,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,1,['down'],['down']
Availability,"// Special case i386/ppc ObjC data structures in magic sections:; // The issue is that the old ObjC object format did some strange; // contortions to avoid real linker symbols. For instance, the; // ObjC class data structure is allocated statically in the executable; // that defines that class. That data structures contains a pointer to; // its superclass. But instead of just initializing that part of the; // struct to the address of its superclass, and letting the static and; // dynamic linkers do the rest, the runtime works by having that field; // instead point to a C-string that is the name of the superclass.; // At runtime the objc initialization updates that pointer and sets; // it to point to the actual super class. As far as the linker; // knows it is just a pointer to a string. But then someone wanted the; // linker to issue errors at build time if the superclass was not found.; // So they figured out a way in mach-o object format to use an absolute; // symbols (.objc_class_name_Foo = 0) and a floating reference; // (.reference .objc_class_name_Bar) to cause the linker into erroring when; // a class was missing.; // The following synthesizes the implicit .objc_* symbols for the linker; // from the ObjC data structures generated by the front end.; // special case if this data blob is an ObjC class definition",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOModule.cpp:846,error,errors,846,interpreter/llvm-project/llvm/lib/LTO/LTOModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOModule.cpp,2,['error'],"['erroring', 'errors']"
Availability,// Special case the error message for the very common case where only; // a single subtarget feature is missing,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp:20,error,error,20,interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp,1,['error'],['error']
Availability,"// Special case the error message for the very common case where only; // a single subtarget feature is missing (neon, e.g.).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp:20,error,error,20,interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp,1,['error'],['error']
Availability,// Special case: check for initialization from scalar; // parameters. This is often a form of defensive; // programming. Non-scalars are still an error since; // because it more likely represents an actual algorithmic; // bug.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp:146,error,error,146,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp,1,['error'],['error']
Availability,"// Special cases for arrays:; // - if it's const, use __unsafe_unretained; // - otherwise, it's an error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:99,error,error,99,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,2,['error'],['error']
Availability,"// Special diagnostic for failure to convert an initializer list, since; // telling the user that it has type void is not useful.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:26,failure,failure,26,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['failure'],['failure']
Availability,// Special handling for `device={isa(...)}` as we accept anything here. It is; // up to the target to decide if the feature is available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPContext.cpp:127,avail,available,127,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPContext.cpp,1,['avail'],['available']
Availability,// Specialization functions of the form 'Error (const ErrT&)'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:41,Error,Error,41,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,1,['Error'],['Error']
Availability,"// Specialize based on number of operands.; // TODO emit VP intrinsics where MaskOp/VectorLenOp != null; // SDValue getNode(unsigned Opcode, const SDLoc &DL, EVT VT) { return; // DAG.getNode(Opcode, DL, VT); }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:77,Mask,MaskOp,77,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['Mask'],['MaskOp']
Availability,"// Specialized vector constructor to allow construction from containers; allowing; // such construction from initializer_list instead would possible, but can be; // error-prone. This use case is common enough for std::vector to implement it; // directly, except for arrays (which can be passed wholesale) and strings (which; // won't convert properly as they'll be seen as buffers)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Pythonize.cxx:165,error,error-prone,165,bindings/pyroot/cppyy/CPyCppyy/src/Pythonize.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Pythonize.cxx,1,['error'],['error-prone']
Availability,// Specific non-error diagnostics may be mapped to various levels from ignored; // to error. Errors can only be mapped to fatal.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:16,error,error,16,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,3,"['Error', 'error']","['Errors', 'error']"
Availability,"// Specifies whether a ModR/M byte is needed and (if so) which; // instruction each possible value of the ModR/M byte corresponds to. Once; // this information is known, we have narrowed down to a single instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/Disassembler/X86Disassembler.cpp:187,down,down,187,interpreter/llvm-project/llvm/lib/Target/X86/Disassembler/X86Disassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/Disassembler/X86Disassembler.cpp,1,['down'],['down']
Availability,// Spill the vector to the stack.; // In cases where the vector is illegal it will be broken down into parts; // and stored in parts - we should use the alignment for the smallest part.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:93,down,down,93,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,2,['down'],['down']
Availability,"// Splat from element 0, but replace absent elements with poison in the mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:72,mask,mask,72,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['mask'],['mask']
Availability,"// Splat from element 0. Any mask element that is undefined remains undefined.; // For example:; // shuf (inselt undef, X, 2), _, <2,2,undef>; // --> shuf (inselt undef, X, 0), poison, <0,0,undef>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:29,mask,mask,29,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['mask'],['mask']
Availability,// Split MBB and move the tail portion down to ContinueMBB.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:39,down,down,39,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,1,['down'],['down']
Availability,// Split Mask operand,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:9,Mask,Mask,9,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,6,['Mask'],['Mask']
Availability,// Split down to 128/256/512-bit vector.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:9,down,down,9,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['down'],['down']
Availability,// Split the existing mask into chunks of size LTNumElts. Track the source; // sub-vectors to ensure the result has at most 2 inputs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp:22,mask,mask,22,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,1,['mask'],['mask']
Availability,// Split the wide shuffle mask into halves. Any mask element that is accessing; // operand 1 is offset down to account for narrowing of the vectors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:26,mask,mask,26,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,3,"['down', 'mask']","['down', 'mask']"
Availability,// Split v64i1 vectors if we don't have v64i8 available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp:46,avail,available,46,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,2,['avail'],['available']
Availability,"// Splitting should only occur for PHIs or between terminators,; // because we only do local repairing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:93,repair,repairing,93,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,1,['repair'],['repairing']
Availability,// SpvScalConst should be created before SpvVecConst to avoid undefined ID; // error on validation.; // TODO: can moved below once sorting of types/consts/defs is implemented.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp:79,error,error,79,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp,1,['error'],['error']
Availability,// Squash the masks to point directly into VLoHalf.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:14,mask,masks,14,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['masks']
Availability,// Squelch the error in case this was not a SymbolicFile.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/ArchiveWriter.cpp:15,error,error,15,interpreter/llvm-project/llvm/lib/Object/ArchiveWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/ArchiveWriter.cpp,1,['error'],['error']
Availability,// Squelch the error in case we had a non-object file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/ArchiveWriter.cpp:15,error,error,15,interpreter/llvm-project/llvm/lib/Object/ArchiveWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/ArchiveWriter.cpp,1,['error'],['error']
Availability,// Sram-ecc is available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TargetParser/TargetParser.h:15,avail,available,15,interpreter/llvm-project/llvm/include/llvm/TargetParser/TargetParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TargetParser/TargetParser.h,1,['avail'],['available']
Availability,"// SrcReg(GR64) -> DestReg(MaskReg); // SrcReg(GR32) -> DestReg(MaskReg); // All KMASK RegClasses hold the same k registers, can be tested against; // anyone.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:27,Mask,MaskReg,27,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,2,['Mask'],['MaskReg']
Availability,"// SrcReg(MaskReg) -> DestReg(GR64); // SrcReg(MaskReg) -> DestReg(GR32); // All KMASK RegClasses hold the same k registers, can be tested against; // anyone.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:10,Mask,MaskReg,10,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,2,['Mask'],['MaskReg']
Availability,// StackIds is empty (we don't have debug info available in the index for; // these callsites),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:47,avail,available,47,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,1,['avail'],['available']
Availability,"// Standard scheduler algorithms will recompute the depth of the successor; // here as such:; // SuccSU->setDepthToAtLeast(SU->getDepth() + SuccEdge->getLatency());; //; // However, we lazily compute node depth instead. Note that; // ScheduleNodeTopDown has already updated the depth of this node which causes; // all descendents to be marked dirty. Setting the successor depth explicitly; // here would cause depth to be recomputed for all its ancestors. If the; // successor is not yet ready (because of a transitively redundant edge) then; // this causes depth computation to be quadratic in the size of the DAG.; // If all the node's predecessors are scheduled, this node is ready; // to be scheduled. Ignore the special ExitSU node.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:521,redundant,redundant,521,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,1,['redundant'],['redundant']
Availability,// Start a transaction at this point that we will rollback if the matching; // fails.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:50,rollback,rollback,50,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['rollback'],['rollback']
Availability,"// Start from 0, skip registers encoded in VEX_VVVV or a mask register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86BaseInfo.h:57,mask,mask,57,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86BaseInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86BaseInfo.h,1,['mask'],['mask']
Availability,"// Start from 1, skip any registers encoded in VEX_VVVV or I8IMM, or a; // mask register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86BaseInfo.h:75,mask,mask,75,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86BaseInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86BaseInfo.h,2,['mask'],['mask']
Availability,"// Start from top-level context-less function, traverse down the reverse; // context trie to find the best/longest match for given context, then; // retrieve the size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/ProfiledBinary.cpp:56,down,down,56,interpreter/llvm-project/llvm/tools/llvm-profgen/ProfiledBinary.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/ProfiledBinary.cpp,1,['down'],['down']
Availability,// Start the merging process by first handling the BranchBlock.; // Move any PHIs in SourceRegion.BranchBlock down to the branch-taken block,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp:110,down,down,110,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp,1,['down'],['down']
Availability,"// Starting with a code fragment like:; //; // test %rax, %rax; // jne LblNotNull; //; // LblNull:; // callq throw_NullPointerException; //; // LblNotNull:; // Inst0; // Inst1; // ...; // Def = Load (%rax + <offset>); // ...; //; //; // we want to end up with; //; // Def = FaultingLoad (%rax + <offset>), LblNull; // jmp LblNotNull ;; explicit or fallthrough; //; // LblNotNull:; // Inst0; // Inst1; // ...; //; // LblNull:; // callq throw_NullPointerException; //; //; // To see why this is legal, consider the two possibilities:; //; // 1. %rax is null: since we constrain <offset> to be less than PageSize, the; // load instruction dereferences the null page, causing a segmentation; // fault.; //; // 2. %rax is not null: in this case we know that the load cannot fault, as; // otherwise the load would've faulted in the original program too and the; // original program would've been undefined.; //; // This reasoning cannot be extended to justify hoisting through arbitrary; // control flow. For instance, in the example below (in pseudo-C); //; // if (ptr == null) { throw_npe(); unreachable; }; // if (some_cond) { return 42; }; // v = ptr->field; // LD; // ...; //; // we cannot (without code duplication) use the load marked ""LD"" to null check; // ptr -- clause (2) above does not apply in this case. In the above program; // the safety of ptr->field can be dependent on some_cond; and, for instance,; // ptr could be some non-null invalid reference that never gets loaded from; // because some_cond is always true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:274,Fault,FaultingLoad,274,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,4,"['Fault', 'fault']","['FaultingLoad', 'fault', 'faulted']"
Availability,"// Stash the value of the frame pointer relative to the base pointer for; // Win32 EH. This supports Win32 EH, which does the inverse of the above:; // it recovers the frame pointer from the base pointer rather than the; // other way around.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:155,recover,recovers,155,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,1,['recover'],['recovers']
Availability,"// Stat Error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/Systematics.cxx:8,Error,Error,8,roofit/histfactory/src/Systematics.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/Systematics.cxx,1,['Error'],['Error']
Availability,"// Stat Error Config",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/Systematics.cxx:8,Error,Error,8,roofit/histfactory/src/Systematics.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/Systematics.cxx,1,['Error'],['Error']
Availability,"// Stat failure",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressProof.cxx:8,failure,failure,8,test/stressProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressProof.cxx,2,['failure'],['failure']
Availability,"// State of SCC represents whether any lanes are live in mask,; // if SCC is 0 then no lanes will be alive anymore.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp:57,mask,mask,57,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,4,"['alive', 'mask']","['alive', 'mask']"
Availability,"// Statistical tests:; // No statistical tests possible for THnBase so far...; // if ( compareStats ); // differents += compareStatistics( h1, h2, debug, ERRORLIMIT);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressHistogram.cxx:154,ERROR,ERRORLIMIT,154,test/stressHistogram.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressHistogram.cxx,1,['ERROR'],['ERRORLIMIT']
Availability,"// Status kind is basically the main part of parameter's status.; // The kind represents our knowledge (so far) about a tracked parameter; // in the context of this analysis.; //; // Since we want to report on missing and extraneous calls, we need to; // track the fact whether paramater was called or not. This automatically; // decides two kinds: `NotCalled` and `Called`.; //; // One of the erroneous situations is the case when parameter is called only; // on some of the paths. We could've considered it `NotCalled`, but we want; // to report double call warnings even if these two calls are not guaranteed; // to happen in every execution. We also don't want to have it as `Called`; // because not calling tracked parameter on all of the paths is an error; // on its own. For these reasons, we need to have a separate kind,; // `MaybeCalled`, and change `Called` to `DefinitelyCalled` to avoid; // confusion.; //; // Two violations of calling parameter more than once and not calling it on; // every path are not, however, mutually exclusive. In situations where both; // violations take place, we prefer to report ONLY double call. It's always; // harder to pinpoint a bug that has arisen when a user neglects to take the; // right action (and therefore, no action is taken), than when a user takes; // the wrong action. And, in order to remember that we already reported; // a double call, we need another kind: `Reported`.; //; // Our analysis is intra-procedural and, while in the perfect world,; // developers only use tracked parameters to call them, in the real world,; // the picture might be different. Parameters can be stored in global; // variables or leaked into other functions that we know nothing about.; // We try to be lenient and trust users. Another kind `Escaped` reflects; // such situations. We don't know if it gets called there or not, but we; // should always think of `Escaped` as the best possible option.; //; // Some of the paths in the analyzed functions might end",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:756,error,error,756,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,1,['error'],['error']
Availability,"// Step 1: Create a shuffle mask that implements this insert operation. The; // vector that we are inserting into will be operand 0 of the shuffle, so; // those elements are just 'i'. The inserted subvector is in the first; // positions of operand 1 of the shuffle. Example:; // insert v4i32 V, (v2i16 X), 2 --> shuffle v8i16 V', X', {0,1,2,3,8,9,6,7}",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:28,mask,mask,28,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['mask']
Availability,// Step 2: Analyze the availability of the load,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:23,avail,availability,23,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['avail'],['availability']
Availability,"// Step 2: Replace the precondition from ""if (x == 0) goto loop-exit"" to; // ""if (NewCount == 0) loop-exit"". Without this change, the intrinsic; // function would be partial dead code, and downstream passes will drag; // it back from the precondition block to the preheader.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:189,down,downstream,189,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,1,['down'],['downstream']
Availability,"// Step 3: Eliminate fully redundancy.; //; // If all of the instructions we depend on produce a known value for this; // load, then it is fully redundant and we can use PHI insertion to compute; // its value. Insert PHIs and remove the fully redundant value now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:145,redundant,redundant,145,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,2,['redundant'],['redundant']
Availability,"// Step 3: Note that the population count is exactly the trip count of the; // loop in question, which enable us to convert the loop from noncountable; // loop into a countable one. The benefit is twofold:; //; // - If the loop only counts population, the entire loop becomes dead after; // the transformation. It is a lot easier to prove a countable loop dead; // than to prove a noncountable one. (In some C dialects, an infinite loop; // isn't dead even if it computes nothing useful. In general, DCE needs; // to prove a noncountable loop finite before safely delete it.); //; // - If the loop also performs something else, it remains alive.; // Since it is transformed to countable form, it can be aggressively; // optimized by some optimizations which are in general not applicable; // to a noncountable loop.; //; // After this step, this loop (conceptually) would look like following:; // newcnt = __builtin_ctpop(x);; // t = newcnt;; // if (x); // do { cnt++; x &= x-1; t--) } while (t > 0);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:639,alive,alive,639,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,1,['alive'],['alive']
Availability,"// Step through all machine locations, look at each predecessor and test; // whether we can eliminate redundant PHIs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:102,redundant,redundant,102,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['redundant'],['redundant']
Availability,// Step through the input mask by splitting into Scale-sized slices.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:26,mask,mask,26,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,1,['mask'],['mask']
Availability,"// Still progress the IT block, otherwise one wrong condition causes; // nasty cascading errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:89,error,errors,89,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['error'],['errors']
Availability,"// Still to do: Division for profiles; // The division methods for the profiles have to be changed to; // calculate the errors correctly.; // Test 10; // Copy Tests",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressHistogram.cxx:120,error,errors,120,test/stressHistogram.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressHistogram.cxx,1,['error'],['errors']
Availability,"// Stop completely in case of error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFileMerger.cxx:30,error,error,30,io/io/src/TFileMerger.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFileMerger.cxx,2,['error'],['error']
Availability,"// Stop if one of the previous runs had a failure to keep the terminal clean.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/test/testHistFactory.cxx:42,failure,failure,42,roofit/histfactory/test/testHistFactory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/test/testHistFactory.cxx,1,['failure'],['failure']
Availability,"// Stop iteration under various conditions; // * The condition R(i+1)<R(i) is no longer true (when then implicit regularization is too weak); // * If the current error estimate is > factor*errmin (factor = 1.1); // * We have reach the last step...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/RuleFitParams.cxx:162,error,error,162,tmva/tmva/src/RuleFitParams.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/RuleFitParams.cxx,1,['error'],['error']
Availability,"// Stop looking into what it takes to repair, this is already; // too expensive.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:38,repair,repair,38,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,1,['repair'],['repair']
Availability,"// Stop on read error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataSet.cxx:16,error,error,16,roofit/roofitcore/src/RooDataSet.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataSet.cxx,1,['error'],['error']
Availability,// Store a copy of the original live mask when required,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp:37,mask,mask,37,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,1,['mask'],['mask']
Availability,"// Store all the names that TargetLibraryInfo knows about; the bool indicates; // whether TLI has it marked as ""available"" for the target of interest.; // This is a vector to preserve the sorted order for better reporting.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-tli-checker/llvm-tli-checker.cpp:112,avail,available,112,interpreter/llvm-project/llvm/tools/llvm-tli-checker/llvm-tli-checker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-tli-checker/llvm-tli-checker.cpp,1,['avail'],['available']
Availability,// Store an available register for FPSCR clearing,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMExpandPseudoInsts.cpp:12,avail,available,12,interpreter/llvm-project/llvm/lib/Target/ARM/ARMExpandPseudoInsts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMExpandPseudoInsts.cpp,1,['avail'],['available']
Availability,// Store current mask in the IdentityMask so later we did not lost; // this info if IdentityOp is selected as the best candidate for the; // permutation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:17,mask,mask,17,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['mask'],['mask']
Availability,// Store name outside of loop to avoid redundant calls.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:39,redundant,redundant,39,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,1,['redundant'],['redundant']
Availability,"// Store the asymmetric error, if it is available",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsMinimizerFcn.cxx:24,error,error,24,roofit/roofitcore/src/RooAbsMinimizerFcn.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsMinimizerFcn.cxx,2,"['avail', 'error']","['available', 'error']"
Availability,// Store the vector to the stack.; // In cases where the vector is illegal it will be broken down into parts; // and stored in parts - we should use the alignment for the smallest part.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:93,down,down,93,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,1,['down'],['down']
Availability,"// Stores actually store the mask, not the order, need to invert.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:29,mask,mask,29,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,2,['mask'],['mask']
Availability,"// Stores per-language styles. A FormatStyle instance inside has an empty; // StyleSet. A FormatStyle instance returned by the Get method has its; // StyleSet set to a copy of the originating StyleSet, effectively keeping the; // internal representation of that StyleSet alive.; //; // The memory management and ownership reminds of a birds nest: chicks; // leaving the nest take photos of the nest with them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h:271,alive,alive,271,interpreter/llvm-project/clang/include/clang/Format/Format.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h,1,['alive'],['alive']
Availability,// Stores whether we're taking the address of these candidates. This helps us; // produce better error messages when dealing with the pass_object_size; // attribute on parameters.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h:97,error,error,97,interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h,1,['error'],['error']
Availability,// Straight shuffle of a single input vector. For everything from SSE2; // onward this has a single fast instruction with no scary immediates.; // We have to map the mask as it is actually a v4i32 shuffle instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:166,mask,mask,166,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// Strategy:; // We need to select two types of instruction, maximizing the available; // immediate range of each. The instructions we use will depend on whether; // DestReg and BaseReg are low, high or the stack pointer.; // * CopyOpc - DestReg = BaseReg + imm; // This will be emitted once if DestReg != BaseReg, and never if; // DestReg == BaseReg.; // * ExtraOpc - DestReg = DestReg + imm; // This will be emitted as many times as necessary to add the; // full immediate.; // If the immediate ranges of these instructions are not large enough to cover; // NumBytes with a reasonable number of instructions, we fall back to using a; // value loaded from a constant pool.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.cpp:76,avail,available,76,interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.cpp,1,['avail'],['available']
Availability,"// String and numeric substitution blocks. Pattern substitution blocks come; // in two forms: [[foo:.*]] and [[foo]]. The former matches .* (or some; // other regex) and assigns it to the string variable 'foo'. The latter; // substitutes foo's value. Numeric substitution blocks recognize the same; // form as string ones, but start with a '#' sign after the double; // brackets. They also accept a combined form which sets a numeric variable; // to the evaluation of an expression. Both string and numeric variable; // names must satisfy the regular expression ""[a-zA-Z_][0-9a-zA-Z_]*"" to be; // valid, as this helps catch some common errors. If there are extra '['s; // before the ""[["", treat them literally.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:636,error,errors,636,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,1,['error'],['errors']
Availability,// Strip away preceding '_'. Doing this here will effect all the checks; // down below.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp:76,down,down,76,interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,1,['down'],['down']
Availability,"// Strip out parameters with zero error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:34,error,error,34,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,3,['error'],['error']
Availability,"// Strip potential, somewhat redundant '/.' from the pathname ...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx:29,redundant,redundant,29,core/base/src/TSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx,1,['redundant'],['redundant']
Availability,// Strip the reference type (if any) and then the pointer type (if; // any) to get down to what might be a function type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:83,down,down,83,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['down'],['down']
Availability,"// Strong dependencies must be respected by the scheduler. Artificial; // dependencies may be removed only if they are redundant with another; // strong dependence.; //; // Weak dependencies may be violated by the scheduling strategy, but only if; // the strategy can prove it is correct to do so.; //; // Strong OrderKinds must occur before ""Weak"".; // Weak OrderKinds must occur after ""Weak"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:119,redundant,redundant,119,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,1,['redundant'],['redundant']
Availability,// Submodule information is only valid if we have a current module.; // FIXME: Should we error on these cases?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:89,error,error,89,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['error'],['error']
Availability,// Subrange lanemask should be disjunct to any previous subrange masks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:65,mask,masks,65,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,1,['mask'],['masks']
Availability,// Substitute and check for failure (e.g. use of undefined variable).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:28,failure,failure,28,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,1,['failure'],['failure']
Availability,"// Substitute into the default template argument, if available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:53,avail,available,53,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,1,['avail'],['available']
Availability,// Substitute into the qualifier; we can get a substitution failure here; // through evil use of alias templates.; // FIXME: Is CurContext correct for this? Should we go to the (instantiation; // of the) lexical context of the pattern?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:60,failure,failure,60,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,1,['failure'],['failure']
Availability,// Substitution failure,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderStmt.cpp:16,failure,failure,16,interpreter/llvm-project/clang/lib/Serialization/ASTReaderStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderStmt.cpp,1,['failure'],['failure']
Availability,// Substitution failures are handled in printNoMatch().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:16,failure,failures,16,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,1,['failure'],['failures']
Availability,// Subtract error margin and bias from register limits and avoid overflow.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp:12,error,error,12,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,1,['error'],['error']
Availability,"// Suggest the (potentially) correct interface name. Don't provide a; // code-modification hint or use the typo name for recovery, because; // this is just a warning. The program may actually be correct.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:121,recover,recovery,121,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['recover'],['recovery']
Availability,// Sum of the lengths of the nodes down the path to the current one.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/SuffixTree.cpp:35,down,down,35,interpreter/llvm-project/llvm/lib/Support/SuffixTree.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/SuffixTree.cpp,1,['down'],['down']
Availability,"// Supported type, mask of BasicType.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Support/RISCVVIntrinsicUtils.h:19,mask,mask,19,interpreter/llvm-project/clang/include/clang/Support/RISCVVIntrinsicUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Support/RISCVVIntrinsicUtils.h,2,['mask'],['mask']
Availability,"// Suppress ""2 errors generated"" or similar messages",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DumpTool/ClangSrcLocDump.cpp:15,error,errors,15,interpreter/llvm-project/clang/lib/Tooling/DumpTool/ClangSrcLocDump.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DumpTool/ClangSrcLocDump.cpp,1,['error'],['errors']
Availability,"// Suppress error dialogs to avoid hangs on build nodes.; // One can use an environment variable (Cling_GuiOnAssert) to enable; // the error dialogs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx:12,error,error,12,core/dictgen/src/rootcling_impl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx,4,['error'],['error']
Availability,"// Suppress error issued when the branch is missing from the tree",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TBranchProxy.h:12,error,error,12,tree/treeplayer/inc/TBranchProxy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TBranchProxy.h,1,['error'],['error']
Availability,// Suppress some verbosity if there's no error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:41,error,error,41,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,2,['error'],['error']
Availability,// Suppress the redundant tag keyword if we just printed one.; // We don't have to worry about ElaboratedTypes here because you can't; // refer to an anonymous type with one.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp:16,redundant,redundant,16,interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp,1,['redundant'],['redundant']
Availability,"// Swap is available at same time as mem, so grab values here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/unix/src/TUnixSystem.cxx:11,avail,available,11,core/unix/src/TUnixSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/unix/src/TUnixSystem.cxx,1,['avail'],['available']
Availability,// Swap the mask around.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:12,mask,mask,12,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['mask'],['mask']
Availability,"// Swap-and-pop for fast removal.; // 1) Update the adj index of the edge currently at back().; // 2) Move last Edge down to Idx.; // 3) pop_back(); // If Idx == size() - 1 then the setAdjEdgeIdx and swap are; // redundant, but both operations are cheap.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/PBQP/Graph.h:117,down,down,117,interpreter/llvm-project/llvm/include/llvm/CodeGen/PBQP/Graph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/PBQP/Graph.h,2,"['down', 'redundant']","['down', 'redundant']"
Availability,// Swift error really is a register that we model as memory -- instruction; // selection will perform mem-to-reg for us and spill/reload appropriately; // around calls that clobber it. There is no need to spill this; // value to the stack and doing so would not be allowed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp:9,error,error,9,interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp,1,['error'],['error']
Availability,"// Switch table case range are encoded into series of masks.; // Just use pointer type, it's guaranteed to fit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:54,mask,masks,54,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,2,['mask'],['masks']
Availability,"// Symbols that are marked DLLImport or DLLExport should not be; // internalized, as they are either externally visible or referencing; // external symbols. Symbols that have AvailableExternally or Appending; // linkage might be used by future passes and should be kept as is.; // These linkages are seen in Unified regular LTO, because the process; // of creating split LTO units introduces symbols with that linkage into; // one of the created modules. Normally, only the ThinLTO backend would; // compile this module, but Unified Regular LTO processes both; // modules created by the splitting process as regular LTO modules.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:175,Avail,AvailableExternally,175,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,1,['Avail'],['AvailableExternally']
Availability,// Symcov file content: set of covered Ids plus information about all available; // coverage points.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/sancov/sancov.cpp:70,avail,available,70,interpreter/llvm-project/llvm/tools/sancov/sancov.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/sancov/sancov.cpp,1,['avail'],['available']
Availability,"// Symmetric error, convert token do double",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealVar.cxx:13,error,error,13,roofit/roofitcore/src/RooRealVar.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealVar.cxx,1,['error'],['error']
Availability,// Syntax error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp:10,error,error,10,interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,1,['error'],['error']
Availability,// Synthesize a zero mask from the zeroable elements (includes undefs).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:21,mask,mask,21,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// T is a pointer... just echo it back.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:26,echo,echo,26,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,1,['echo'],['echo']
Availability,// T0 must match: (and T1 Mask),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:26,Mask,Mask,26,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,1,['Mask'],['Mask']
Availability,"// TFoam::GenerCel2; ////////////////////////////////////////////////////////////////////////////////; /// User method.; /// It generates randomly point/vector according to user-defined distribution.; /// Prior initialization with help of Initialize() is mandatory.; /// Generated MC point/vector is available using GetMCvect and the MC weight with GetMCwt.; /// MC point is generated with wt=1 or with variable weight, see OptRej switch.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/foam/src/TFoam.cxx:300,avail,available,300,math/foam/src/TFoam.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/foam/src/TFoam.cxx,1,['avail'],['available']
Availability,"// TMemberStreamer *pstreamer = aElement->GetStreamer();; // if (pstreamer == 0) {; // //printf(""ERROR, Streamer is null\n"");; // //aElement->ls();; // break;; // }; // //UInt_t start,count;; // //b.ReadVersion(&start, &count);; // //(*pstreamer)(b,ladd,0);; // //b.CheckByteCount(start,count,IsA());",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfo.cxx:97,ERROR,ERROR,97,io/io/src/TStreamerInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfo.cxx,1,['ERROR'],['ERROR']
Availability,"// TMemberStreamer *pstreamer = aElement->GetStreamer();; // if (pstreamer == 0) {; // //printf(""ERROR, Streamer is null\n"");; // //aElement->ls();; // break;; // }; //Int_t *counter = (Int_t*)(count);; //UInt_t start,count;; ///b.ReadVersion(&start, &count);; //(*pstreamer)(b,ladd,*counter);; //b.CheckByteCount(start,count,IsA());",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfo.cxx:97,ERROR,ERROR,97,io/io/src/TStreamerInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfo.cxx,1,['ERROR'],['ERROR']
Availability,// TODO Attribute may not be available on context restore,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:29,avail,available,29,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['avail'],['available']
Availability,// TODO Error check that the number of symbol table entries fits in 32-bits; // signed ...,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/XCOFFObjectWriter.cpp:8,Error,Error,8,interpreter/llvm-project/llvm/lib/MC/XCOFFObjectWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/XCOFFObjectWriter.cpp,1,['Error'],['Error']
Availability,// TODO Propagate Error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/ELFObjectFile.cpp:18,Error,Error,18,interpreter/llvm-project/llvm/lib/Object/ELFObjectFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/ELFObjectFile.cpp,1,['Error'],['Error']
Availability,// TODO Propagate the error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/COFFDumper.cpp:22,error,error,22,interpreter/llvm-project/llvm/tools/llvm-readobj/COFFDumper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/COFFDumper.cpp,1,['error'],['error']
Availability,// TODO commute the mask and try the opposite order of the halves.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:20,mask,mask,20,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,1,['mask'],['mask']
Availability,"// TODO it may be worth it to set ReplaceInTie to `true` as there is no real; // downside to the integer unpck, but if someone doesn't specify exact; // target we won't find it faster.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupInstTuning.cpp:81,down,downside,81,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupInstTuning.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupInstTuning.cpp,1,['down'],['downside']
Availability,// TODO maybe function should return error if (Count > 0),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Xtensa/MCTargetDesc/XtensaAsmBackend.cpp:37,error,error,37,interpreter/llvm-project/llvm/lib/Target/Xtensa/MCTargetDesc/XtensaAsmBackend.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Xtensa/MCTargetDesc/XtensaAsmBackend.cpp,1,['error'],['error']
Availability,// TODO should we turn this into 'and' if shift is 0? Or 'shl' if we; // are only masking bits that a shift already cleared?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:82,mask,masking,82,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,1,['mask'],['masking']
Availability,"// TODO(gparolini): more graceful error handling (skip the page?)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleMerger.cxx:34,error,error,34,tree/ntuple/v7/src/RNTupleMerger.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleMerger.cxx,1,['error'],['error']
Availability,// TODO(https://github.com/llvm/llvm-project/issues/63873) We would ideally; // return an error as well but that's going to require refactoring of error; // handling in DebuginfodServer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Debuginfod/HTTPServer.cpp:90,error,error,90,interpreter/llvm-project/llvm/lib/Debuginfod/HTTPServer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Debuginfod/HTTPServer.cpp,2,['error'],['error']
Availability,"// TODO(jblomer) use std::source_location once available",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/v7/inc/ROOT/RError.hxx:47,avail,available,47,core/foundation/v7/inc/ROOT/RError.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/v7/inc/ROOT/RError.hxx,1,['avail'],['available']
Availability,"// TODO(jblomer): failures should be exceptions",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_minifile.cxx:18,failure,failures,18,tree/ntuple/v7/test/ntuple_minifile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_minifile.cxx,1,['failure'],['failures']
Availability,"// TODO, Obvious Missing Transforms:; // * Single constant active lane -> store; // * Adjacent vector addresses -> masked.store; // * Narrow store width by halfs excluding zero/undef lanes; // * Vector incrementing address -> vector masked store",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:115,mask,masked,115,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,2,['mask'],['masked']
Availability,"// TODO, Obvious Missing Transforms:; // * Single constant active lane load -> load; // * Dereferenceable address & few lanes -> scalarize speculative load/selects; // * Adjacent vector addresses -> masked.load; // * Narrow width by halfs excluding zero/undef lanes; // * Vector incrementing address -> vector masked load",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:199,mask,masked,199,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,2,['mask'],['masked']
Availability,"// TODO: ""LargestSize"" is an approximation for ""largest type that; // you can express in C"". It seems to be the case that int128 is; // supported on all 64-bit platforms, otherwise only up to 64-bit; // integers are supported. If we get this wrong, then we'll try to; // call a sized libcall that doesn't actually exist. There should; // really be some more reliable way in LLVM of determining integer; // sizes which are valid in the target's C ABI...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:358,reliab,reliable,358,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,1,['reliab'],['reliable']
Availability,// TODO: Actually report errors helpfully.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELFObjectFile.h:25,error,errors,25,interpreter/llvm-project/llvm/include/llvm/Object/ELFObjectFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELFObjectFile.h,27,['error'],['errors']
Availability,// TODO: Add error checking from ClangOffloadBundler.cpp,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/OffloadBundler.h:13,error,error,13,interpreter/llvm-project/clang/include/clang/Driver/OffloadBundler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/OffloadBundler.h,4,['error'],['error']
Availability,// TODO: Add memprof specific errors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProfReader.cpp:30,error,errors,30,interpreter/llvm-project/llvm/lib/ProfileData/InstrProfReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProfReader.cpp,1,['error'],['errors']
Availability,// TODO: Add move constructor and operator= when a testable situation arises.; /// Returns a single error that contains messages for all stored Errors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h:100,error,error,100,interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h,2,"['Error', 'error']","['Errors', 'error']"
Availability,"// TODO: Add std::float16 tests once available (from C++23)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_types.cxx:37,avail,available,37,tree/ntuple/v7/test/ntuple_types.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_types.cxx,1,['avail'],['available']
Availability,// TODO: Add support for reversed masked interleaved access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:34,mask,masked,34,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['mask'],['masked']
Availability,// TODO: Add type info about the overload error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Diagnostics.cpp:42,error,error,42,interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Diagnostics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Diagnostics.cpp,1,['error'],['error']
Availability,"// TODO: After performing the sink-and-fold, the original instruction is; // deleted. Its value is still available (in a hard register), so if there; // are debug instructions which refer to the (now deleted) virtual; // register they could be updated to refer to the hard register, in; // principle. However, it's not clear how to do that, moreover in some; // cases the debug instructions may need to be replicated proportionally; // to the number of the COPY instructions replaced and in some extreme; // cases we can end up with quadratic increase in the number of debug; // instructions.; // Sink a copy of the instruction, replacing a COPY instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:105,avail,available,105,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,1,['avail'],['available']
Availability,// TODO: Align down to dword alignment and extract bits for extending loads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCallLowering.cpp:15,down,down,15,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCallLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCallLowering.cpp,1,['down'],['down']
Availability,"// TODO: Allow shuffles that contain undefs in the mask?; // That is legal, but it reduces undef knowledge.; // TODO: Allow arbitrary shuffles by shuffling after binop?; // That might be legal, but we have to deal with poison.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:51,mask,mask,51,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['mask'],['mask']
Availability,// TODO: Be more tolerant to undefs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:17,toler,tolerant,17,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,3,['toler'],['tolerant']
Availability,"// TODO: Before we split the mask, try perfect shuffle on concatenated; // operands.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:29,mask,mask,29,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,1,['mask'],['mask']
Availability,"// TODO: Can we push this as common down to TGeoShape?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoCone.cxx:36,down,down,36,geom/geom/src/TGeoCone.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoCone.cxx,1,['down'],['down']
Availability,"// TODO: Change to std::float16_t in-memory type once available (from C++23).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.cxx:54,avail,available,54,tree/ntuple/v7/src/RColumnElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.cxx,1,['avail'],['available']
Availability,"// TODO: Check error options and invert if needed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/FitUtil.h:15,error,error,15,math/mathcore/inc/Fit/FitUtil.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/FitUtil.h,1,['error'],['error']
Availability,"// TODO: Commuting the 1st operand of FMA*_Int requires some additional; // analysis. The commute optimization is legal only if all users of FMA*_Int; // use only the lowest element of the FMA*_Int instruction. Such analysis are; // not implemented yet. So, just return 0 in that case.; // When such analysis are available this place will be the right place for; // calling it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:313,avail,available,313,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['avail'],['available']
Availability,// TODO: Consider propagating weight down the domination line as well.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:37,down,down,37,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,1,['down'],['down']
Availability,"// TODO: Cost model for emulated masked load/store is completely; // broken. This hack guides the cost model to use an artificially; // high enough value to practically disable vectorization with such; // operations, except where previously deployed legality hack allowed; // using very low cost values. This is to avoid regressions coming simply; // from moving ""masked load/store"" check from legality to cost model.; // Masked Load/Gather emulation was previously never allowed.; // Limited number of Masked Store/Scatter emulation was allowed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:33,mask,masked,33,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,4,"['Mask', 'mask']","['Masked', 'masked']"
Availability,"// TODO: Could inject an invalid typedef decl in an enclosing scope to; // avoid rippling error messages on subsequent uses of the same type,; // could be useful if #include was forgotten.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:90,error,error,90,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['error'],['error']
Availability,// TODO: Deprecate V0 once V1 is fully integrated downstream.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp:50,down,downstream,50,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp,1,['down'],['downstream']
Availability,"// TODO: Determine a good default value.; //; // In the LLVM-TS and SPEC2006, 32 seems to not induce compile time overheads; // (when run with the first 5 abstract attributes). The results also indicate; // that we never reach 32 iterations but always find a fixpoint sooner.; //; // This will become more evolved once we perform two interleaved fixpoint; // iterations: bottom-up and top-down.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:389,down,down,389,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,1,['down'],['down']
Availability,// TODO: Disallow overlapping masks to avoid copy paste errors,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:30,mask,masks,30,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,2,"['error', 'mask']","['errors', 'masks']"
Availability,// TODO: Emit an error here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:17,error,error,17,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,5,['error'],['error']
Availability,// TODO: Emit error for hsa,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:14,error,error,14,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,1,['error'],['error']
Availability,// TODO: Exose the attribute set to the ACS repair callback,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:44,repair,repair,44,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,1,['repair'],['repair']
Availability,// TODO: Expanding load with constant mask may be optimized as well.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:38,mask,mask,38,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// TODO: Extract AvailableAttrs from AttributeSetNode and store them here.; // This will allow an efficient implementation of addAttribute and; // removeAttribute for enum attrs.; /// Private implementation pointer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Attributes.h:17,Avail,AvailableAttrs,17,interpreter/llvm-project/llvm/include/llvm/IR/Attributes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Attributes.h,1,['Avail'],['AvailableAttrs']
Availability,"// TODO: For now, just look for an earlier available version of this value; // within the same block. Theoretically, we could do memdep-style non-local; // analysis too, but that would want caching. A better approach would be to; // use the technique that EarlyCSE uses.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:43,avail,available,43,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,1,['avail'],['available']
Availability,// TODO: Handle MaskSize != Op.getValueType().getVectorNumElements()?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:16,Mask,MaskSize,16,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Mask'],['MaskSize']
Availability,"// TODO: Handle extensions, shifted masks etc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:36,mask,masks,36,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['mask'],['masks']
Availability,// TODO: Handle v4f64 permutes with different low/high lane masks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:60,mask,masks,60,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['masks']
Availability,"// TODO: How should we treat memory that we fail to deinitialize?; // We're currently bailing out and treating it as ""burned"" -- should we; // require that a failure to deinitialize still reset the memory so that; // we can reclaim it?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MapperJITLinkMemoryManager.cpp:158,failure,failure,158,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MapperJITLinkMemoryManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MapperJITLinkMemoryManager.cpp,1,['failure'],['failure']
Availability,"// TODO: If operand didn't match, sub in a dummy one and run target; // predicate, so that we can avoid reporting near-misses that are invalid?; // TODO: Many operand types dont have SuperClasses set, so we report; // redundant ones.; // TODO: Some operands are superclasses of registers (e.g.; // MCK_RegShiftedImm), we don't have any way to represent that currently.; // TODO: This is not all ARM-specific, can some of it be factored out?; // Record some information about near-misses that we have already seen, so; // that we can avoid reporting redundant ones. For example, if there are; // variants of an instruction that take 8- and 16-bit immediates, we want; // to only report the widest one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:218,redundant,redundant,218,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,2,['redundant'],['redundant']
Availability,"// TODO: If the x86 backend knew how to convert a bool vector mask back to an; // XMM register mask efficiently, we could transform all x86 masked intrinsics; // to LLVM masked intrinsics and remove the x86 masked intrinsic defs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:62,mask,mask,62,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,10,['mask'],"['mask', 'masked']"
Availability,// TODO: Increment all MaskOpIdxs in tablegen by num of explicit defs?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp:23,Mask,MaskOpIdxs,23,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp,1,['Mask'],['MaskOpIdxs']
Availability,// TODO: Infer lower AVL from mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VVPISelLowering.cpp:30,mask,mask,30,interpreter/llvm-project/llvm/lib/Target/VE/VVPISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VVPISelLowering.cpp,2,['mask'],['mask']
Availability,"// TODO: Initialise the available extensions, extended instruction sets; // based on the environment settings.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVSubtarget.h:24,avail,available,24,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVSubtarget.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVSubtarget.h,1,['avail'],['available']
Availability,"// TODO: Instead of recording the AllowedExit, it would be good to; // record the complementary set: NotAllowedExit. These include (but may; // not be limited to):; // 1. Reduction phis as they represent the one-before-last value, which; // is not available when vectorized; // 2. Induction phis and increment when SCEV predicates cannot be used; // outside the loop - see addInductionPhi; // 3. Non-Phis with outside uses when SCEV predicates cannot be used; // outside the loop - see call to hasOutsideLoopUser in the non-phi; // handling below; // 4. FixedOrderRecurrence phis that can possibly be handled by; // extraction.; // By recording these, we can then reason about ways to vectorize each; // of these NotAllowedExit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:248,avail,available,248,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,1,['avail'],['available']
Availability,"// TODO: Is this actually reliable? Maybe improving our MemRegion; // hierarchy to provide typed regions for all non-void pointers would be; // better. For instance, we cannot extend this towards LocAsInteger; // operations, where result type of the expression is integer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:26,reliab,reliable,26,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,1,['reliab'],['reliable']
Availability,"// TODO: It may be possible to actually avoid the copy.; // If we repair something where the source is defined by a copy; // and the source of that copy is on the right bank, we can reuse; // it for free.; // E.g.,; // RegToRepair<BankA> = copy AlternativeSrc<BankB>; // = op RegToRepair<BankA>; // We can simply propagate AlternativeSrc instead of copying RegToRepair; // into a new virtual register.; // We would also need to propagate this information in the; // repairing placement.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:66,repair,repair,66,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,2,['repair'],"['repair', 'repairing']"
Availability,"// TODO: Looking at the user(s) to determine if this insert is a; // fold-to-shuffle opportunity does not match the usual instcombine; // constraints. We should decide if the transform is worthy based only; // on this instruction and its operands, but that may not work currently.; //; // Here, we are trying to avoid creating shuffles before reaching; // the end of a chain of extract-insert pairs. This is complicated because; // we do not generally form arbitrary shuffle masks in instcombine; // (because those may codegen poorly), but collectShuffleElements() does; // exactly that.; //; // The rules for determining what is an acceptable target-independent; // shuffle mask are fuzzy because they evolve based on the backend's; // capabilities and real-world impact.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:475,mask,masks,475,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,2,['mask'],"['mask', 'masks']"
Availability,"// TODO: Make this interface user-friendly.; // The interface here is bad, and we'll want to change this in the future. We; // probably will want to build out these mask vectors as vectors of bools and; // have this utility object convert them to the bit masks. I don't want to; // over-engineer this API now since we don't know what the data coming in to; // feed it will look like, so I kept it extremely simple for the immediate use; // case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/DXContainerPSVInfo.h:165,mask,mask,165,interpreter/llvm-project/llvm/include/llvm/MC/DXContainerPSVInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/DXContainerPSVInfo.h,2,['mask'],"['mask', 'masks']"
Availability,// TODO: Make this return something (an AggregateError?) that gives more; // individual control over each error and which might be of interest.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.cpp:106,error,error,106,interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.cpp,1,['error'],['error']
Availability,"// TODO: Manually commit rather than using non-trivial destructor,; // allowing to replace report_fatal_errors with a return Error.; // Make sure the stream is closed before committing it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Caching.cpp:125,Error,Error,125,interpreter/llvm-project/llvm/lib/Support/Caching.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Caching.cpp,1,['Error'],['Error']
Availability,// TODO: Mask high bits with 'and'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:9,Mask,Mask,9,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,1,['Mask'],['Mask']
Availability,"// TODO: Model for NF > 2; // We'll need to enhance getShuffleCost to model shuffles that are just; // inserts and extracts into subvectors, since they won't have the full cost; // of a vrgather.; // An interleaved store for 3 vectors of 4 lanes will look like; // %11 = shufflevector <4 x i32> %4, <4 x i32> %6, <8 x i32> <0...7>; // %12 = shufflevector <4 x i32> %9, <4 x i32> poison, <8 x i32> <0...3>; // %13 = shufflevector <8 x i32> %11, <8 x i32> %12, <12 x i32> <0...11>; // %interleaved.vec = shufflevector %13, poison, <12 x i32> <interleave mask>; // store <12 x i32> %interleaved.vec, ptr %10, align 4",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:552,mask,mask,552,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,1,['mask'],['mask']
Availability,"// TODO: Needs support for masked loads/stores of ""scalar"" vectors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:27,mask,masked,27,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,1,['mask'],['masked']
Availability,"// TODO: Pick a high register, and shift down, similar to a kernel.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.cpp:41,down,down,41,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.cpp,1,['down'],['down']
Availability,// TODO: Predicate these with `options.hasBitScan() ? Legal : Expand`; // when the HasBitScan predicate is available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARC/ARCISelLowering.cpp:107,avail,available,107,interpreter/llvm-project/llvm/lib/Target/ARC/ARCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARC/ARCISelLowering.cpp,1,['avail'],['available']
Availability,"// TODO: Previously, this error was ignored and we treated it as if; // shuffling hid the bug. This should really either be consumeError if; // that behaviour was sensible, or we should propagate the error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h:26,error,error,26,interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h,2,['error'],['error']
Availability,"// TODO: Push down to TGeoShape?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoXtru.cxx:14,down,down,14,geom/geom/src/TGeoXtru.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoXtru.cxx,1,['down'],['down']
Availability,"// TODO: Push down to TGeoShape?? But would have to do raw sizes set first..; // can rest of TGeoShape be deferred until after",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoTorus.cxx:14,down,down,14,geom/geom/src/TGeoTorus.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoTorus.cxx,1,['down'],['down']
Availability,"// TODO: Push down to TGeoShape?? Would have to do raw sizes set first..; // can rest of TGeoShape be deferred until after this?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoPcon.cxx:14,down,down,14,geom/geom/src/TGeoPcon.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoPcon.cxx,2,['down'],['down']
Availability,// TODO: Read from backend annotations if available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:42,avail,available,42,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,1,['avail'],['available']
Availability,"// TODO: Remember the distinct subprogram we created for a given linkage name,; // so that we can continue to unique whenever possible. Map <newly created; // node, old linkage name> to the first (possibly distinct) mdsubprogram; // created for that combination. This is not strictly needed for correctness,; // but can cut down on the number of MDNodes and let us diff cleanly with the; // output of -gline-tables-only.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:324,down,down,324,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,1,['down'],['down']
Availability,"// TODO: Remove fully-redundant expressions.; // Get instruction from the Map, assume that all the Instructions; // with same VNs have same rank (this is an approximation).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:22,redundant,redundant,22,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,1,['redundant'],['redundant']
Availability,// TODO: Remove the RISC-V special case when R_RISCV_SET_ULEB128 linker; // support becomes more widely available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChain.cpp:104,avail,available,104,interpreter/llvm-project/clang/lib/Driver/ToolChain.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChain.cpp,1,['avail'],['available']
Availability,"// TODO: Remove/replace the extract cost check? If the elements are available; // as scalars, then there may be no extract cost. Should we ask if; // inserting a scalar back into a vector is cheap instead?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:68,avail,available,68,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['avail'],['available']
Availability,"// TODO: Replace by RVec<T>::insert as soon as available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RTensorUtils.hxx:47,avail,available,47,tmva/tmva/inc/TMVA/RTensorUtils.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RTensorUtils.hxx,1,['avail'],['available']
Availability,// TODO: Report an error if the same register is used more than once.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:19,error,error,19,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,2,['error'],['error']
Availability,// TODO: Report an error on duplicate metadata nodes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:19,error,error,19,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,1,['error'],['error']
Availability,// TODO: Report an error when both name and ir block are specified.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:19,error,error,19,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,1,['error'],['error']
Availability,// TODO: Report an error when multiple same attributes are specified.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:19,error,error,19,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,1,['error'],['error']
Availability,// TODO: Report an error when using a duplicate bit target flag.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:19,error,error,19,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,1,['error'],['error']
Availability,// TODO: Report error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp:16,error,error,16,interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp,6,['error'],['error']
Availability,// TODO: Report the error message properly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELFObjectFile.h:20,error,error,20,interpreter/llvm-project/llvm/include/llvm/Object/ELFObjectFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELFObjectFile.h,3,['error'],['error']
Availability,"// TODO: See if we can do a better error than just ""invalid ..."".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AsmParser/AVRAsmParser.cpp:35,error,error,35,interpreter/llvm-project/llvm/lib/Target/AVR/AsmParser/AVRAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AsmParser/AVRAsmParser.cpp,1,['error'],['error']
Availability,"// TODO: SelectionDAG has several alternative expansions to port which may; // be more reasonble depending on the available instructions. If a target; // has sitofp, does not have CTLZ, or can efficiently use f64 as an; // intermediate type, this is probably worse.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:114,avail,available,114,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,1,['avail'],['available']
Availability,// TODO: Serialize the various register masks.; // Frame information,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRYamlMapping.h:40,mask,masks,40,interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRYamlMapping.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRYamlMapping.h,1,['mask'],['masks']
Availability,"// TODO: Should really introduce control flow and use a block for the >; // MaxExp, < MinExp cases; // First, handle exponents Exp > MaxExp and scale down.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp:150,down,down,150,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,1,['down'],['down']
Availability,// TODO: Should this be available as a constant utility function? It is; // similar to getBinOpAbsorber().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/InstCombine/InstCombiner.h:24,avail,available,24,interpreter/llvm-project/llvm/include/llvm/Transforms/InstCombine/InstCombiner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/InstCombine/InstCombiner.h,1,['avail'],['available']
Availability,// TODO: Should this be some kind of interrupted error?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:49,error,error,49,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,1,['error'],['error']
Availability,// TODO: Should this error be handled (maybe in a high verbosity mode); // before falling back to .dwo files?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFContext.cpp:21,error,error,21,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFContext.cpp,1,['error'],['error']
Availability,// TODO: Should we always create i64 masks? Or only folded immediates?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:37,mask,masks,37,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['masks']
Availability,// TODO: Should we consider the mask when looking for a stride?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp:32,mask,mask,32,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp,1,['mask'],['mask']
Availability,"// TODO: Should we distinguish this with an ""interrupted error""?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:57,error,error,57,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,1,['error'],['error']
Availability,// TODO: Should we try to mask with N1 as well?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:26,mask,mask,26,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['mask']
Availability,// TODO: Shouldn't we thread the error up instead of exiting?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:33,error,error,33,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,1,['error'],['error']
Availability,// TODO: Take the demanded mask of the result into account.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:27,mask,mask,27,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,1,['mask'],['mask']
Availability,// TODO: Test this error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELFObjectFile.h:19,error,error,19,interpreter/llvm-project/llvm/include/llvm/Object/ELFObjectFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELFObjectFile.h,22,['error'],['error']
Availability,"// TODO: The following is not robust and should be revisited e.g. by making CPPOverloads; // that have only CPPClassMethods be true Python classmethods? Note that the original; // implementation wasn't 100% correct either (e.g. static size() mapped to len()).; //; // As-is, if no suitable `self` is given (normal case), but the type of the first argument; // matches the enclosing scope of the class method and it isn't needed for the call, then; // assume that the method was (incorrectly) bound and so drop that instance from args.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPClassMethod.cxx:30,robust,robust,30,bindings/pyroot/cppyy/CPyCppyy/src/CPPClassMethod.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPClassMethod.cxx,1,['robust'],['robust']
Availability,"// TODO: The simple type check probably belongs in the default hook; // implementation and/or target-specific overrides (because; // non-simple types likely require masking when legalized), but; // that restriction may conflict with other transforms.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:165,mask,masking,165,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['masking']
Availability,// TODO: The transform may be a win even if the mask is not legal.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:48,mask,mask,48,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['mask']
Availability,"// TODO: This does not match if there are undef elements in the shuffle mask.; // Should we ignore undefs in the shuffle mask instead? The trade-off is; // removing an instruction (a shuffle), but losing the knowledge that some; // vector lanes are not needed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:72,mask,mask,72,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['mask'],['mask']
Availability,"// TODO: This only saves the first non-fatal error from InstrProfReader, and; // then added to WriterContext::Errors. However, this is not extensible, if; // we have more non-fatal errors from InstrProfReader in the future. How; // should this interact with different -failure-mode?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profdata/llvm-profdata.cpp:45,error,error,45,interpreter/llvm-project/llvm/tools/llvm-profdata/llvm-profdata.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profdata/llvm-profdata.cpp,4,"['Error', 'error', 'failure']","['Errors', 'error', 'errors', 'failure-mode']"
Availability,// TODO: This redundantly records nodes with both glues and chains.; // Record the node and remember it in our chained nodes list.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherGen.cpp:14,redundant,redundantly,14,interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherGen.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherGen.cpp,1,['redundant'],['redundantly']
Availability,"// TODO: This restriction matches the check in visitInsertElementInst() and; // prevents an infinite loop caused by not turning the extract/insert pair; // into a shuffle. We really should not need either check, but we're lacking; // folds for shufflevectors because we're afraid to generate shuffle masks; // that the backend can't handle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:300,mask,masks,300,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['mask'],['masks']
Availability,// TODO: This should propagate the error instead of exiting.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:35,error,error,35,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,3,['error'],['error']
Availability,"// TODO: Tolerate tail call for now, as we may see tail call from libraries.; // This is only for intra function branches, excluding tail calls.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.cpp:9,Toler,Tolerate,9,interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.cpp,1,['Toler'],['Tolerate']
Availability,"// TODO: Ugly - should use quaternions to avoid compound rounding errors and; // triple multiplication",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLUtil.cxx:66,error,errors,66,graf3d/gl/src/TGLUtil.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLUtil.cxx,1,['error'],['errors']
Availability,"// TODO: Update the outliner to capture whether the outlined function; // needs these extra attributes.; // Functions marked with the swifttailcc and tailcc calling conventions; // require special handling when outlining musttail functions. The; // calling convention must be passed down to the outlined function as; // well. Further, there is special handling for musttail calls as well,; // requiring a return call directly after. For now, the outliner does not; // support this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/IROutliner.h:283,down,down,283,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/IROutliner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/IROutliner.h,1,['down'],['down']
Availability,// TODO: Use MOVLPS when SSE1 is available?; // Delegate to generic TypeLegalization. Situations we can really handle; // should have already been dealt with by AtomicExpandPass.cpp.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:33,avail,available,33,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avail'],['available']
Availability,"// TODO: Use custom target PseudoSourceValue.; // TODO: We should use the value from the IR intrinsic call, but it might not; // be available and how do we get it?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:132,avail,available,132,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['avail'],['available']
Availability,"// TODO: We can do better for PHI nodes. In cases like this:; // ptr = phi(relocated_pointer, not_relocated_pointer); // statepoint(ptr); // We will return that stack slot for ptr is unknown. And later we might; // assign different stack slots for ptr and relocated_pointer. This limits; // llvm's ability to remove redundant stores.; // Unfortunately it's hard to accomplish in current infrastructure.; // We use this function to eliminate spill store completely, while; // in example we still need to emit store, but instead of any location; // we need to use special ""preferred"" location.; // TODO: handle simple updates. If a value is modified and the original; // value is no longer live, it would be nice to put the modified value in the; // same slot. This allows folding of the memory accesses for some; // instructions types (like an increment).; // statepoint (i); // i1 = i+1; // statepoint (i1); // However we need to be careful for cases like this:; // statepoint(i); // i1 = i+1; // statepoint(i, i1); // Here we want to reserve spill slot for 'i', but not for 'i+1'. If we just; // put handling of simple modifications in this function like it's done; // for bitcasts we might end up reserving i's slot for 'i+1' because order in; // which we visit values is unspecified.; // Don't know any information about this instruction",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp:316,redundant,redundant,316,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp,1,['redundant'],['redundant']
Availability,// TODO: We could be better here. If LI is not alive in landing pad; // we could hoist spill after LIP.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:47,alive,alive,47,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,1,['alive'],['alive']
Availability,// TODO: We could emit code to handle the initialization somewhere.; // We ignore the initializer for now and legalize it to allow selection.; // The initializer will anyway get errored out during assembly emission.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp:178,error,errored,178,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,2,['error'],['errored']
Availability,"// TODO: We could remove the mutex and condition variable and use; // std::atomic::wait() instead, but that isn't available until C++20",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BalancedPartitioning.cpp:114,avail,available,114,interpreter/llvm-project/llvm/lib/Support/BalancedPartitioning.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BalancedPartitioning.cpp,1,['avail'],['available']
Availability,// TODO: We could use different error codes for each/some to be more; // explicit about the syntax error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Parser.cpp:32,error,error,32,interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Parser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Parser.cpp,2,['error'],['error']
Availability,"// TODO: We could use following steps to handle a quiet compare with; // signaling encodings.; // 1. Get ordered masks from a quiet ISD::SETO; // 2. Use the masks to mask potential unordered elements in operand A, B; // 3. Get the compare results of masked A, B; // 4. Calculating final result using the mask and result from 3; // But currently, we just fall back to scalar operations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:113,mask,masks,113,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,5,['mask'],"['mask', 'masked', 'masks']"
Availability,"// TODO: We currently implement an algorithm whose time complexity is linear in; // the number of existing candidates. However, we could do better by using; // ScopedHashTable. Specifically, while traversing the dominator tree, we could; // maintain all the candidates that dominate the basic block being traversed in; // a ScopedHashTable. This hash table is indexed by the base and the stride of; // a candidate. Therefore, finding the immediate basis of a candidate boils down; // to one hash-table look up.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:475,down,down,475,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,1,['down'],['down']
Availability,// TODO: We might want to propagate the precise error message here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/ValueList.cpp:48,error,error,48,interpreter/llvm-project/llvm/lib/Bitcode/Reader/ValueList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/ValueList.cpp,1,['error'],['error']
Availability,// TODO: We restrict this to unmasked loads currently in consideration of; // the complexity of hanlding all falses masks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:116,mask,masks,116,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['mask'],['masks']
Availability,// TODO: We should avoid using host float here. It would be better to; // check the float bit values which is what a few other places do.; // We've had bot failures before due to weird NaN support on mips hosts.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp:156,failure,failures,156,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp,1,['failure'],['failures']
Availability,"// TODO: Would be nicer to use a lock upgrade strategy a-la TVirtualRWMutex; // but that is unfortunately not usable outside the already available ROOT mutexes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFUtils.cxx:137,avail,available,137,tree/dataframe/src/RDFUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFUtils.cxx,1,['avail'],['available']
Availability,"// TODO: add error handling tests that trigger the RooNaNPacker error handling paths (see testNaNPacker for example; // setups). In particular a fit of a simultaneous or constrained likelihood to trigger the RooSumL path which has; // additional handling of the packed NaNs that isn't tested now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/TestStatistics/testLikelihoodGradientJob.cxx:13,error,error,13,roofit/roofitcore/test/TestStatistics/testLikelihoodGradientJob.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/TestStatistics/testLikelihoodGradientJob.cxx,2,['error'],['error']
Availability,// TODO: check for other requires clauses.; // The requires directive takes effect only when a target region is; // present in the compilation unit. Otherwise it is ignored and not; // passed to the runtime. This avoids the runtime from throwing an error; // for mismatching requires clauses across compilation units that don't; // contain at least 1 target region.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:249,error,error,249,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,1,['error'],['error']
Availability,// TODO: check whether CurReg is already masked by EXEC,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerI1Copies.cpp:41,mask,masked,41,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerI1Copies.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerI1Copies.cpp,1,['mask'],['masked']
Availability,// TODO: convert this to utilise the IRBuilder Config rather than; // a passed down argument.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:79,down,down,79,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,1,['down'],['down']
Availability,"// TODO: covers the PyException throw case, which does not seem to work on Windows, so; // instead leaves the error be",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPMethod.cxx:110,error,error,110,bindings/pyroot/cppyy/CPyCppyy/src/CPPMethod.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPMethod.cxx,1,['error'],['error']
Availability,"// TODO: data members should have a unique identifier, just like methods,; // so that reflection information can be recovered post-initialization",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPDataMember.h:116,recover,recovered,116,bindings/pyroot/cppyy/CPyCppyy/src/CPPDataMember.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPDataMember.h,1,['recover'],['recovered']
Availability,"// TODO: detail the error handling",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Pythonize.cxx:20,error,error,20,bindings/pyroot/cppyy/CPyCppyy/src/Pythonize.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Pythonize.cxx,1,['error'],['error']
Availability,// TODO: extend the masked interleaved-group support to reversed access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:20,mask,masked,20,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['mask'],['masked']
Availability,// TODO: generate a error for unknown load commands by default. But still; // need work out an approach to allow or not allow unknown values like this; // as an option for some uses like lldb.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/MachOObjectFile.cpp:20,error,error,20,interpreter/llvm-project/llvm/lib/Object/MachOObjectFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/MachOObjectFile.cpp,1,['error'],['error']
Availability,// TODO: handle failure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/ARMEHABIPrinter.h:16,failure,failure,16,interpreter/llvm-project/llvm/tools/llvm-readobj/ARMEHABIPrinter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/ARMEHABIPrinter.h,4,['failure'],['failure']
Availability,// TODO: handle non-reduction outside users when tail is folded by masking.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:67,mask,masking,67,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,1,['mask'],['masking']
Availability,"// TODO: https://github.com/root-project/root/pull/12328 meenemen!; /// Fit a simple linear function, that starts in the negative. Triggers RooNaNPacker error handling.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/TestStatistics/testLikelihoodGradientJob.cxx:153,error,error,153,roofit/roofitcore/test/TestStatistics/testLikelihoodGradientJob.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/TestStatistics/testLikelihoodGradientJob.cxx,1,['error'],['error']
Availability,"// TODO: if we have a error getting the name then it would be nice to print; // the index of which archive member this is and or its offset in the; // archive instead of ""???"" as the name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp:22,error,error,22,interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp,2,['error'],['error']
Availability,"// TODO: it appears to provide compiler with some sort of a hint. We do not; // know what exactly it is supposed to do. However, CUDA headers suggest that; // just passing through __ptr should not affect correctness. They do so on; // pre-sm80 GPUs where this builtin is not available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h:275,avail,available,275,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h,1,['avail'],['available']
Availability,"// TODO: it would be great to have a fixit here, since this is; // such an obvious error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:83,error,error,83,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,1,['error'],['error']
Availability,// TODO: kASAN for liteos ??; // TODO: Support TSAN and HWASAN and update mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/OHOS.cpp:74,mask,mask,74,interpreter/llvm-project/clang/lib/Driver/ToolChains/OHOS.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/OHOS.cpp,1,['mask'],['mask']
Availability,"// TODO: move ParsingClassDefinition here.; // TODO: move TentativeParsingAction here.; /// A RAII object used to temporarily suppress access-like; /// checking. Access-like checks are those associated with; /// controlling the use of a declaration, like C++ access control; /// errors and deprecation warnings. They are contextually; /// dependent, in that they can only be resolved with full; /// information about what's being declared. They are also; /// suppressed in certain contexts, like the template arguments of; /// an explicit instantiation. However, those suppression contexts; /// cannot necessarily be fully determined in advance; for; /// example, something starting like this:; /// template <> class std::vector<A::PrivateType>; /// might be the entirety of an explicit instantiation:; /// template <> class std::vector<A::PrivateType>;; /// or just an elaborated type specifier:; /// template <> class std::vector<A::PrivateType> make_vector<>();; /// Therefore this class collects all the diagnostics and permits; /// them to be re-delayed in a new context.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/RAIIObjectsForParser.h:279,error,errors,279,interpreter/llvm-project/clang/include/clang/Parse/RAIIObjectsForParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/RAIIObjectsForParser.h,1,['error'],['errors']
Availability,// TODO: print pass descriptions when they are available,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilder.cpp:47,avail,available,47,interpreter/llvm-project/llvm/lib/Passes/PassBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilder.cpp,1,['avail'],['available']
Availability,"// TODO: propagate errors from here",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodPDERS.cxx:19,error,errors,19,tmva/tmva/src/MethodPDERS.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodPDERS.cxx,1,['error'],['errors']
Availability,"// TODO: propagate this error to caller w/o use of Python C-API; /*; PyErr_Format(PyExc_RuntimeError, ""could not resolve %s::%s(%s)"",; const_cast<TClassRef&>(klass).GetClassName(),; wrap.fName, callString.c_str()); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx:24,error,error,24,bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,1,['error'],['error']
Availability,// TODO: recover from mistakenly-qualified operator declarations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:9,recover,recover,9,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,1,['recover'],['recover']
Availability,"// TODO: replace with a more reliable lookup",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/Messenger.cxx:29,reliab,reliable,29,roofit/multiprocess/src/Messenger.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/Messenger.cxx,1,['reliab'],['reliable']
Availability,// TODO: report the error up the stack.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/XCOFFObjectFile.cpp:20,error,error,20,interpreter/llvm-project/llvm/lib/Object/XCOFFObjectFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/XCOFFObjectFile.cpp,7,['error'],['error']
Availability,"// TODO: report this error, but really only once.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp:21,error,error,21,interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp,1,['error'],['error']
Availability,// TODO: should we even warn on struct/class mismatches for this? Seems; // like it's likely to produce a lot of spurious errors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:122,error,errors,122,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,1,['error'],['errors']
Availability,"// TODO: signal some type of error (or should that be upstream?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx:29,error,error,29,bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,1,['error'],['error']
Availability,// TODO: simplify this once the macro is available in all OS levels.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/Host.cpp:41,avail,available,41,interpreter/llvm-project/llvm/lib/TargetParser/Host.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/Host.cpp,1,['avail'],['available']
Availability,// TODO: test this error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/ELFDump.cpp:19,error,error,19,interpreter/llvm-project/llvm/tools/llvm-objdump/ELFDump.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/ELFDump.cpp,1,['error'],['error']
Availability,"// TODO: the following is dreadfully slow and dead-locks on Apache: revisit; // raising exceptions through callbacks by using magic returns; // if (result && Utility::PyErr_Occurred_WithGIL()) {; // // can happen in the case of a CINT error: trigger exception processing; // Py_DECREF(result);; // result = 0;; // } else if (!result && PyErr_Occurred())",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPMethod.cxx:235,error,error,235,bindings/pyroot/cppyy/CPyCppyy/src/CPPMethod.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPMethod.cxx,1,['error'],['error']
Availability,// TODO: this error is untested.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELF.h:14,error,error,14,interpreter/llvm-project/llvm/include/llvm/Object/ELF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELF.h,2,['error'],['error']
Availability,// TODO: this implementation is now likely redundant with; // DefaultABIInfo::EmitVAArg.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/PPC.cpp:43,redundant,redundant,43,interpreter/llvm-project/clang/lib/CodeGen/Targets/PPC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/PPC.cpp,1,['redundant'],['redundant']
Availability,// TODO: unify the error message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/IFSHandler.cpp:19,error,error,19,interpreter/llvm-project/llvm/lib/InterfaceStub/IFSHandler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/IFSHandler.cpp,1,['error'],['error']
Availability,// TODO: update to use; // https://graphics.stanford.edu/~seander/bithacks.html#MaskedMerge in order; // to merge bits from two values without requiring PMV.Inv_Mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:80,Mask,MaskedMerge,80,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,1,['Mask'],['MaskedMerge']
Availability,// TODO: use a fast content hash when available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenAction.cpp:38,avail,available,38,interpreter/llvm-project/clang/lib/CodeGen/CodeGenAction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenAction.cpp,1,['avail'],['available']
Availability,// TODO: use input range if available,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:28,avail,available,28,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,2,['avail'],['available']
Availability,"// TODO: would a masked load be faster?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/adler32_cf.c:17,mask,masked,17,builtins/zlib/adler32_cf.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/adler32_cf.c,1,['mask'],['masked']
Availability,"// TODO:; // Implement similar hooks that can be used at other points during; // disassembly. Something along the following lines:; // - onBeforeInstructionDecode(); // - onAfterInstructionDecode(); // - onSymbolEnd(); // It should help move much of the target specific code from llvm-objdump to; // respective target disassemblers.; /// Suggest a distance to skip in a buffer of data to find the next; /// place to look for the start of an instruction. For example, if; /// all instructions have a fixed alignment, this might advance to; /// the next multiple of that alignment.; ///; /// If not overridden, the default is 1.; ///; /// \param Address - The address, in the memory space of region, of the; /// starting point (typically the first byte of something; /// that did not decode as a valid instruction at all).; /// \param Bytes - A reference to the actual bytes at Address. May be; /// needed in order to determine the width of an; /// unrecognized instruction (e.g. in Thumb this is a simple; /// consistent criterion that doesn't require knowing the; /// specific instruction). The caller can pass as much data; /// as they have available, and the function is required to; /// make a reasonable default choice if not enough data is; /// available to make a better one.; /// \return - A number of bytes to skip. Must always be greater than; /// zero. May be greater than the size of Bytes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCDisassembler/MCDisassembler.h:1142,avail,available,1142,interpreter/llvm-project/llvm/include/llvm/MC/MCDisassembler/MCDisassembler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCDisassembler/MCDisassembler.h,2,['avail'],['available']
Availability,"// TRACE(HtmlTrace_GetLine,; // (""GetLine page=%d left=%d right=%d available=%d used=%d\n"",; // fPageWidth, fLeft, fRight, lineWidth, actualWidth));",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlLayout.cxx:67,avail,available,67,gui/guihtml/src/TGHtmlLayout.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlLayout.cxx,1,['avail'],['available']
Availability,"// TROOT sets the error ignore level handler, the system error message handler, and the error abort handler on; // construction such that the ""Root.ErrorIgnoreLevel"" environment variable is used for the ignore level; // and gSystem is used to generate a stack trace on abort.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/TError.h:18,error,error,18,core/foundation/inc/TError.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/TError.h,4,"['Error', 'error']","['ErrorIgnoreLevel', 'error']"
Availability,"// TSystem::GetLibraries() assumes that an empty GetLinkedLibraries(); // means failure to extract the linked libraries. Signal ""we did; // manage, but it's empty"" by returning a single space.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/unix/src/TUnixSystem.cxx:80,failure,failure,80,core/unix/src/TUnixSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/unix/src/TUnixSystem.cxx,1,['failure'],['failure']
Availability,"// TTI call to check if target would like to expand memcmp. Also, get the; // available load sizes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:78,avail,available,78,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,1,['avail'],['available']
Availability,"// TTree is not always available (for example in rootcling), so we need; // to grab it silently.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:23,avail,available,23,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['avail'],['available']
Availability,// TUMA or TUMU: Currently we always emit tumu policy regardless of tuma.; // It's fine because vmerge does not care mask policy.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:117,mask,mask,117,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['mask'],['mask']
Availability,"// TVirtualCollectionProxy *proxy = cl->GetCollectionProxy();; // if (proxy && ( proxy->GetProperties() & TVirtualCollectionProxy::kIsEmulated ) ) {; // Error(""InspectMembers"",""The TClass for %s has an emulated proxy but we are looking at a compiled version of the collection!\n"",; // cl->GetName());; // }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:153,Error,Error,153,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['Error'],['Error']
Availability,"// TVirtualFItter is not available in all case (e.g. when running with ROOT IMT)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressHistoFit.cxx:25,avail,available,25,test/stressHistoFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressHistoFit.cxx,1,['avail'],['available']
Availability,"// Tagged globals have non-zero upper bits, which makes direct references; // require a 64-bit immediate. With the small/medium code models this causes; // relocation errors, so we go through the GOT instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86Subtarget.cpp:167,error,errors,167,interpreter/llvm-project/llvm/lib/Target/X86/X86Subtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86Subtarget.cpp,1,['error'],['errors']
Availability,"// Tail is allowed to have many predecessors, but we can't handle PHIs yet.; //; // FIXME: Real PHIs could be if-converted as long as the CmpBB values are; // defined before The CmpBB cmp clobbers the flags. Alternatively, it should; // always be safe to sink the ccmp down to immediately before the CmpBB; // terminators.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ConditionalCompares.cpp:269,down,down,269,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ConditionalCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ConditionalCompares.cpp,1,['down'],['down']
Availability,// Tailor the diagnostics for the common case where a readwrite; // property is declared both in the @interface and the continuation.; // This is a common error where the user often intended the original; // declaration to be readonly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:155,error,error,155,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,1,['error'],['error']
Availability,"// Take 512-bit type, unless we are avoiding 512-bit types and have the; // 256-bit operation available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:94,avail,available,94,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['avail'],['available']
Availability,"// Take a list of < nominal, absolError > TH1* pairs; // and construct a single histogram representing the; // total fractional error as:; // UncertInQuad(bin i) = Sum: absolUncert*absolUncert; // Total(bin i) = Sum: Value; //; // TotalFracError(bin i) = Sqrt( UncertInQuad(i) ) / TotalBin(i)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/HistoToWorkspaceFactoryFast.cxx:128,error,error,128,roofit/histfactory/src/HistoToWorkspaceFactoryFast.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/HistoToWorkspaceFactoryFast.cxx,1,['error'],['error']
Availability,"// Take a nominal TH1* and create; // a TH1 representing the binwise; // errors (taken from the nominal TH1)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/HistoToWorkspaceFactoryFast.cxx:73,error,errors,73,roofit/histfactory/src/HistoToWorkspaceFactoryFast.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/HistoToWorkspaceFactoryFast.cxx,1,['error'],['errors']
Availability,// Take a note of analysis required and made available by this pass.; // Remove the analysis not preserved by this pass,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:45,avail,available,45,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,1,['avail'],['available']
Availability,// Take advantage of the optimized sequence for vec_all_eq when vcmpequd is; // not available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/altivec.h:84,avail,available,84,interpreter/llvm-project/clang/lib/Headers/altivec.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/altivec.h,1,['avail'],['available']
Availability,// Take an expression returning llvm::Error and forward the error if it exists.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rc/ResourceFileWriter.cpp:38,Error,Error,38,interpreter/llvm-project/llvm/tools/llvm-rc/ResourceFileWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rc/ResourceFileWriter.cpp,4,"['Error', 'error']","['Error', 'error']"
Availability,// Take an expression returning llvm::Expected<T> and assign it to Var or; // forward the error out of the function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rc/ResourceScriptParser.cpp:90,error,error,90,interpreter/llvm-project/llvm/tools/llvm-rc/ResourceScriptParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rc/ResourceScriptParser.cpp,1,['error'],['error']
Availability,"// Take the exact integer log2 of the value. If DoFold is true, create the; // actual instructions, otherwise return a non-null dummy value. Return nullptr; // on failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:163,failure,failure,163,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,1,['failure'],['failure']
Availability,// Take the ptr operand after all casts and geps 0. This way we can search; // cast graph down only.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:90,down,down,90,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['down'],['down']
Availability,"// Takes 4 arguments. The first is a null terminated string containing; // a source file name. The second is an unsigned LEB128 number; // representing the directory index of the directory in which the file; // was found. The third is an unsigned LEB128 number representing the; // time of last modification of the file. The fourth is an unsigned; // LEB128 number representing the length in bytes of the file. The time; // and length fields may contain LEB128(0) if the information is not; // available.; //; // The directory index represents an entry in the include_directories; // section of the statement program prologue. The index is LEB128(0); // if the file was found in the current directory of the compilation,; // LEB128(1) if it was found in the first directory in the; // include_directories section, and so on. The directory index is; // ignored for file names that represent full path names.; //; // The files are numbered, starting at 1, in the order in which they; // appear; the names in the prologue come before names defined by; // the DW_LNE_define_file instruction. These numbers are used in the; // the file register of the state machine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFDebugLine.cpp:494,avail,available,494,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFDebugLine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFDebugLine.cpp,1,['avail'],['available']
Availability,"// Tampering with the type of a VarDecl here is a bit of a hack, but we need; // to ensure that the variable is 'const' so that we can error on; // modification, which can otherwise over-release.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:135,error,error,135,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,1,['error'],['error']
Availability,// Target features that are read-only and should not be disabled/enabled; // by command line options. Such features are for emitting predefined; // macros or checking availability of builtin functions and can be omitted; // in function attributes in IR.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h:167,avail,availability,167,interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,1,['avail'],['availability']
Availability,"// Target specific information in their own namespaces.; // (ARM/AArch64/X86 are declared in ARM/AArch64/X86TargetParser.h); // These should be generated from TableGen because the information is already; // there, and there is where new information about targets will be added.; // FIXME: To TableGen this we need to make some table generated files available; // even if the back-end is not compiled with LLVM, plus we need to create a new; // back-end to TableGen to create these clean tables.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TargetParser/TargetParser.h:349,avail,available,349,interpreter/llvm-project/llvm/include/llvm/TargetParser/TargetParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TargetParser/TargetParser.h,1,['avail'],['available']
Availability,// Target specific intrinsic became redundant,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:36,redundant,redundant,36,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,2,['redundant'],['redundant']
Availability,"// Target type does derive from source type. Now we're serious. If an error; // appears now, it's not ignored.; // This may not be entirely in line with the standard. Take for example:; // struct A {};; // struct B : virtual A {; // B(A&);; // };; //; // void f(); // {; // (void)static_cast<const B&>(*((A*)0));; // }; // As far as the standard is concerned, p5 does not apply (A is virtual), so; // p2 should be used instead - ""const B& t(*((A*)0));"" is perfectly valid.; // However, both GCC and Comeau reject this example, and accepting it would; // mean more complex code if we're to preserve the nice error message.; // FIXME: Being 100% compliant here would be nice to have.; // Must preserve cv, as always, unless we're in C-style mode.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:70,error,error,70,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,2,['error'],['error']
Availability,"// TargetLowering has info on library calls that CodeGen expects to be; // available, both from the C runtime and compiler-rt.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/UpdateCompilerUsed.cpp:75,avail,available,75,interpreter/llvm-project/llvm/lib/LTO/UpdateCompilerUsed.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/UpdateCompilerUsed.cpp,1,['avail'],['available']
Availability,"// TargetSelect.h moved to a different directory between LLVM 2.9 and 3.0,; // and if the old one gets included then MCAsmInfo will be NULL and; // we'll crash later.; // Provide the user with a useful error message about what's wrong.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp:202,error,error,202,interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp,1,['error'],['error']
Availability,"// TaskGroup has a relatively high overhead, so we want to reduce; // the number of spawn() calls. We'll create up to 1024 tasks here.; // (Note that 1024 is an arbitrary number. This code probably needs; // improving to take the number of available cores into account.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Parallel.h:240,avail,available,240,interpreter/llvm-project/llvm/include/llvm/Support/Parallel.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Parallel.h,1,['avail'],['available']
Availability,"// Teach SmallPtrSet that PointerUnion is ""basically a pointer"", that has; // # low bits available = min(PT1bits,PT2bits)-1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h:89,avail,available,89,interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h,1,['avail'],['available']
Availability,"// Tell TMapFile::operator delete which memory address to detach; // The detaching must be done after the whole object has been tear down; // (including base classes).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TMapFile.cxx:133,down,down,133,io/io/src/TMapFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TMapFile.cxx,1,['down'],['down']
Availability,// Tell the callee to try to recover.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:29,recover,recover,29,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['recover'],['recover']
Availability,// Tell the callee whether to try to recover.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:37,recover,recover,37,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['recover'],['recover']
Availability,"// Tell the interpreter that this library is available; all libraries can be; // used to resolve symbols.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:45,avail,available,45,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['avail'],['available']
Availability,// Template parameters are always an error here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:37,error,error,37,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,1,['error'],['error']
Availability,"// Temporarily redundant, see comment on lock early in the function.; // R__LOCKGUARD(gROOTMutex);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TDirectoryFile.cxx:15,redundant,redundant,15,io/io/src/TDirectoryFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TDirectoryFile.cxx,1,['redundant'],['redundant']
Availability,// Temporary sched=list-ilp flags until the heuristics are robust.; // Some options are also available under sched=list-hybrid.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:59,robust,robust,59,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,2,"['avail', 'robust']","['available', 'robust']"
Availability,// Tentatively consider this block as speculatively available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:52,avail,available,52,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['avail'],['available']
Availability,// Test Data Class.; //; // Operand 0: the value to test; // Operand 1: the bit mask,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:80,mask,mask,80,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,1,['mask'],['mask']
Availability,"// Test a conditional fit with batch mode; //; // In a conditional fit, it happens that the value normalization integrals can; // be different for every event because a pdf is conditional on another; // observable. That's why the integral also has to be evaluated with the batch; // interface in general.; //; // This test checks if the results of a conditional fit are the same for batch; // and scalar mode. It also verifies that for non-conditional fits, the batch; // mode recognizes that the integral only needs to be evaluated once. This is; // checked by hijacking the FastEvaluations log. If a RooRealIntegral is; // evaluated in batch mode and data size is greater than one, the batch mode; // will inform that a batched evaluation function is missing.; //; // This test is disabled if the legacy backend is not available, because then; // we don't have any reference to compare to.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooAbsPdf.cxx:821,avail,available,821,roofit/roofitcore/test/testRooAbsPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooAbsPdf.cxx,1,['avail'],['available']
Availability,// Test for -fno-rtti + explicit -fsanitizer=vptr before expanding groups; // so we don't error out if -fno-rtti and -fsanitize=undefined were; // passed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp:90,error,error,90,interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,1,['error'],['error']
Availability,// Test for shuffle mask legality over both commutations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:20,mask,mask,20,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['mask']
Availability,// Test for the Microsoft extension of /##/ turning into // here on the; // error path.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:76,error,error,76,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,1,['error'],['error']
Availability,"// Test if a bit is clear/set using a shifted-one mask:; // zext (icmp eq (and X, (1 << ShAmt)), 0) --> and (lshr (not X), ShAmt), 1; // zext (icmp ne (and X, (1 << ShAmt)), 0) --> and (lshr X, ShAmt), 1",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:50,mask,mask,50,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,1,['mask'],['mask']
Availability,"// Test if we can pack floats into NaNs, and recover them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testNaNPacker.cxx:45,recover,recover,45,roofit/roofitcore/test/testNaNPacker.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testNaNPacker.cxx,1,['recover'],['recover']
Availability,"// Test scalar arguments for conversion. B has been validated earlier to be a; // negative power of two and thus is guaranteed to have one or more contiguous; // ones starting from the MSB followed by zero or more contiguous zeros. D has; // been validated earlier to be a shifted set of one or more contiguous ones.; // In order to match, B leading ones and D leading zeros should be equal. The; // predicate that B be a negative power of 2 prevents the condition of there; // ever being zero leading ones. Thus 0 == 0 cannot occur. The predicate that; // D always be a shifted mask prevents the condition of D equaling 0. This; // prevents matching the condition where B contains the maximum number of; // leading one bits (-1) and D contains the maximum number of leading zero; // bits (0).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:579,mask,mask,579,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['mask'],['mask']
Availability,"// Test shape against each plane in frustum - returning overlap result; // This method can result in kFALSE positives, where shape lies outside; // frustum, but not outside a single plane of it. In this case the shape; // will be regarded incorrectly as intersecting (kPartial); // TODO: Improve this - have a reliable test (separating axes).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLCamera.cxx:310,reliab,reliable,310,graf3d/gl/src/TGLCamera.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLCamera.cxx,1,['reliab'],['reliable']
Availability,"// Test syst down:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/test/testHistFactory.cxx:13,down,down,13,roofit/histfactory/test/testHistFactory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/test/testHistFactory.cxx,1,['down'],['down']
Availability,"// Test that splitting a RooDataSet by index category does preserve the sum of; // weights squared and weight errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooDataHist.cxx:110,error,errors,110,roofit/roofitcore/test/testRooDataHist.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooDataHist.cxx,1,['error'],['errors']
Availability,"// Test that splitting a RooDataSet by index category does preserve the weight; // errors. Covers GitHub issue #12453.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooDataSet.cxx:83,error,errors,83,roofit/roofitcore/test/testRooDataSet.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooDataSet.cxx,1,['error'],['errors']
Availability,"// Test that we error out gracefully in case the output file specified for a Snapshot cannot be opened",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx:16,error,error,16,tree/dataframe/test/dataframe_snapshot.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx,2,['error'],['error']
Availability,"// Test the `Offset(""bin"")` feature of RooAbsPdf::createNLL. Doing the; // bin-by-bin offset is equivalent to calculating the likelihood ratio with the; // NLL of a template histogram that is based of the dataset, so we use this; // relation to do a cross check: if we create a template pdf from the fit data; // and fit this template to the data with the `Offset(""bin"")` option, the; // resulting NLL should always be zero (within some numerical errors).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testTestStatistics.cxx:447,error,errors,447,roofit/roofitcore/test/testTestStatistics.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testTestStatistics.cxx,1,['error'],['errors']
Availability,// Test the shuffle mask to see if it splices the inserted scalar into the; // operand 1 vector of the shuffle.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:20,mask,mask,20,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['mask'],['mask']
Availability,// Test under mask. The first operand is ANDed with the second operand; // and the condition codes are set on the result. The third operand is; // a boolean that is true if the condition codes need to distinguish; // between CCMASK_TM_MIXED_MSB_0 and CCMASK_TM_MIXED_MSB_1 (which the; // register forms do but the memory forms don't).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:14,mask,mask,14,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,1,['mask'],['mask']
Availability,"// Tests the merge method with different binned 3D Profile; // This tests fails! Segmentation Fault!!It should not!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressHistogram.cxx:94,Fault,Fault,94,test/stressHistogram.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressHistogram.cxx,1,['Fault'],['Fault']
Availability,"// Tests the merge with some equal labels method for 1D Histograms; // number of labels used = number of bins; // This test uses SetBinCOntent instead of Fill and ResetStats after to; // test th ebug in TH1::Merge reported in ROOT-9336; // since we do not set bin errors; // make sure we have not stored Sumw2 otherwise all bin errors; // will be zero. This needs to be done before constructing the histograms",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressHistogram.cxx:264,error,errors,264,test/stressHistogram.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressHistogram.cxx,2,['error'],['errors']
Availability,"// TetrisPiece skeleton shape (up to 10 different shapes available)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/Tetris.h:57,avail,available,57,test/Tetris.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/Tetris.h,1,['avail'],['available']
Availability,"// Text alignment is down",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/graf/src/TGaxis.cxx:21,down,down,21,graf2d/graf/src/TGaxis.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/graf/src/TGaxis.cxx,1,['down'],['down']
Availability,"// Textures in CUDA-8 and older are not supported by clang.There's no; // convenient way to intercept texture use in these versions, so we can't; // produce a meaningful error. The source code that attempts to use textures; // will continue to fail as it does now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:170,error,error,170,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,1,['error'],['error']
Availability,"// The ""CVTTP2SI"" instruction conveniently sets the sign bit if; // and only if the value was out of range. So we can use that; // as our indicator that we rather use ""Big"" instead of ""Small"".; //; // Use ""Small"" if ""IsOverflown"" has all bits cleared; // and ""0x80000000 | Big"" if all bits in ""IsOverflown"" are set.; // AVX1 can't use the signsplat masking for 256-bit vectors - we have to; // use the slightly slower blendv select instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:349,mask,masking,349,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['masking']
Availability,"// The ""avx"" feature changes how vectors >128 in size are passed. ""avx512f""; // additionally changes how vectors >256 in size are passed. Like GCC, we; // warn when a function is called with an argument where this will change.; // Unlike GCC, we also error when it is an obvious ABI mismatch, that is,; // the caller and callee features are mismatched.; // Unfortunately, we cannot do this diagnostic in SEMA, since the callee can; // change its ABI with attribute-target after this call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp:251,error,error,251,interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,1,['error'],['error']
Availability,"// The ""csync"" operand is not encoded into the ""tsb"" instruction (as this is; // the only available operand), but LLVM expects the instruction to have one; // operand, so we need to add the csync when decoding.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:90,avail,available,90,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,1,['avail'],['available']
Availability,"// The ""it"" instruction has the condition mask on the end of the mnemonic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:42,mask,mask,42,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['mask'],['mask']
Availability,"// The ""lookup"" functions doesn't report errors as accurately as the ""decode""; // function as it is meant to be fast. For more accurage errors we could call; // ""decode"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/FunctionInfo.cpp:41,error,errors,41,interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/FunctionInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/FunctionInfo.cpp,2,['error'],['errors']
Availability,// The 'and' mask must be composed of power-of-2 constants.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:13,mask,mask,13,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// The 'unavailable' availability cannot be combined with any other; // availability changes. Make sure that hasn't happened.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:21,avail,availability,21,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,2,['avail'],['availability']
Availability,"// The '||err' is to grab an error coming from AnalyzeFunction",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:29,error,error,29,hist/hist/src/TFormula_v5.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx,1,['error'],['error']
Availability,"// The -2 error condition typically only happens when; // GetHead() failed because not implemented, in the first call to; // ReadBuffer() in Init(), it is not checked in ReadBuffers10().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TWebFile.cxx:10,error,error,10,net/net/src/TWebFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TWebFile.cxx,1,['error'],['error']
Availability,// The .bind here is in order to compose the error message more accurately.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp:45,error,error,45,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp,2,['error'],['error']
Availability,// The .bind here is in order to compose the error message more accurately.; // Also avoid intptr_t and uintptr_t because they were specifically created; // for storing pointers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp:45,error,error,45,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp,1,['error'],['error']
Availability,"// The .n qualifier is always discarded as that is what the tables; // and matcher expect. In ARM mode the .w qualifier has no effect,; // so discard it to avoid errors that can be caused by the matcher.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:162,error,errors,162,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['error'],['errors']
Availability,// The 15 first bits of `Value::SubclassData` are available for subclasses of; // `Instruction` to use.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instruction.h:50,avail,available,50,interpreter/llvm-project/llvm/include/llvm/IR/Instruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instruction.h,1,['avail'],['available']
Availability,"// The 4-byte load must be aligned, while a char or short may be; // anywhere in the word. Hence all this nasty bookkeeping code.; // add ptr1, ptrA, ptrB [copy if ptrA==0]; // rlwinm shift1, ptr1, 3, 27, 28 [3, 27, 27]; // xori shift, shift1, 24 [16]; // rlwinm ptr, ptr1, 0, 0, 29; // slw incr2, incr, shift; // li mask2, 255 [li mask3, 0; ori mask2, mask3, 65535]; // slw mask, mask2, shift; // loopMBB:; // lwarx tmpDest, ptr; // add tmp, tmpDest, incr2; // andc tmp2, tmpDest, mask; // and tmp3, tmp, mask; // or tmp4, tmp3, tmp2; // stwcx. tmp4, ptr; // bne- loopMBB; // fallthrough --> exitMBB; // srw SrwDest, tmpDest, shift; // rlwinm SrwDest, SrwDest, 0, 24 [16], 31",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:375,mask,mask,375,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,3,['mask'],['mask']
Availability,"// The 4-byte load must be aligned, while a char or short may be; // anywhere in the word. Hence all this nasty bookkeeping code.; // add ptr1, ptrA, ptrB [copy if ptrA==0]; // rlwinm shift1, ptr1, 3, 27, 28 [3, 27, 27]; // xori shift, shift1, 24 [16]; // rlwinm ptr, ptr1, 0, 0, 29; // slw newval2, newval, shift; // slw oldval2, oldval,shift; // li mask2, 255 [li mask3, 0; ori mask2, mask3, 65535]; // slw mask, mask2, shift; // and newval3, newval2, mask; // and oldval3, oldval2, mask; // loop1MBB:; // lwarx tmpDest, ptr; // and tmp, tmpDest, mask; // cmpw tmp, oldval3; // bne- exitBB; // loop2MBB:; // andc tmp2, tmpDest, mask; // or tmp4, tmp2, newval3; // stwcx. tmp4, ptr; // bne- loop1MBB; // b exitBB; // exitBB:; // srw dest, tmpDest, shift",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:409,mask,mask,409,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,5,['mask'],['mask']
Availability,// The ABI dictates there should be one stack slot available to the callee; // on function entry (for saving lr).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/XCore/XCoreISelLowering.cpp:51,avail,available,51,interpreter/llvm-project/llvm/lib/Target/XCore/XCoreISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/XCore/XCoreISelLowering.cpp,1,['avail'],['available']
Availability,"// The AMDGPUOpenMPToolChain only supports sanitizers in the sense that it; // allows sanitizer arguments on the command line if they are supported by the; // host toolchain. The AMDGPUOpenMPToolChain will actually ignore any command; // line arguments for any of these ""supported"" sanitizers. That means that no; // sanitization of device code is actually supported at this time.; //; // This behavior is necessary because the host and device toolchains; // invocations often share the command line, so the device toolchain must; // tolerate flags meant only for the host toolchain.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/AMDGPUOpenMP.cpp:534,toler,tolerate,534,interpreter/llvm-project/clang/lib/Driver/ToolChains/AMDGPUOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/AMDGPUOpenMP.cpp,1,['toler'],['tolerate']
Availability,"// The AND mask might not be a constant, and we need to make sure that; // if we're going to fold the masking with the insert, all bits not; // know to be zero in the mask are known to be one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:11,mask,mask,11,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,3,['mask'],"['mask', 'masking']"
Availability,"// The ARMv7-M architecture stores an additional 2-bit mask value in; // MSR bits {11-10}. The mask is used only with apsr, iapsr, eapsr and; // xpsr, it has to be 0b10 in other cases. Bit mask{1} indicates if; // the NZCVQ bits should be moved by the instruction. Bit mask{0}; // indicates the move for the GE{3:0} bits, the mask{0} bit can be set; // only if the processor includes the DSP extension.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:55,mask,mask,55,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,5,['mask'],['mask']
Availability,"// The ASTReader didn't diagnose the error, so conservatively report it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:37,error,error,37,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,1,['error'],['error']
Availability,// The BTFTagAttributedType is available for C only.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:31,avail,available,31,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['avail'],['available']
Availability,"// The BasicTTIImpl version only deals with CCH==TTI::CastContextHint::Normal,; // but we also want to include the TTI::CastContextHint::Masked case too.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp:137,Mask,Masked,137,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,1,['Mask'],['Masked']
Availability,"// The CC users in CCUsers are testing the result of a comparison of some; // value X against zero and we know that any CC value produced by MI would; // also reflect the value of X. ConvOpc may be used to pass the transfomed; // opcode MI will have if this succeeds. Try to adjust CCUsers so that they; // test the result of MI directly, returning true on success. Leave; // everything unchanged on failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:400,failure,failure,400,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,1,['failure'],['failure']
Availability,"// The CudaToolChain only supports sanitizers in the sense that it allows; // sanitizer arguments on the command line if they are supported by the host; // toolchain. The CudaToolChain will actually ignore any command line; // arguments for any of these ""supported"" sanitizers. That means that no; // sanitization of device code is actually supported at this time.; //; // This behavior is necessary because the host and device toolchains; // invocations often share the command line, so the device toolchain must; // tolerate flags meant only for the host toolchain.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp:518,toler,tolerate,518,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp,1,['toler'],['tolerate']
Availability,"// The Error message already issued. However if we reach here; // we need to make sure that we do not use fTree.; //; // Force a reload of the tree next time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:7,Error,Error,7,tree/tree/src/TChain.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx,1,['Error'],['Error']
Availability,// The FrontendAction::BeginSourceFile () method loads the AST so that much; // of the information is already available and modules should have been; // loaded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendActions.cpp:110,avail,available,110,interpreter/llvm-project/clang/lib/Frontend/FrontendActions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendActions.cpp,1,['avail'],['available']
Availability,"// The GNU assembler has aliases of ldrd and strd with the second register; // omitted. We don't have a way to do that in tablegen, so fix it up here.; //; // We have to be careful to not emit an invalid Rt2 here, because the rest of; // the assembly parser could then generate confusing diagnostics refering to; // it. If we do find anything that prevents us from doing the transformation we; // bail out, and let the assembly parser report an error on the instruction as; // it is written.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:445,error,error,445,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['error'],['error']
Availability,// The GNU headers like to define 'toupper' and 'tolower' redundantly. This is; // necessary to prevent it from doing that and remapping our implementation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/ctype.h:58,redundant,redundantly,58,interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/ctype.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/ctype.h,1,['redundant'],['redundantly']
Availability,"// The Gaps mask is invariant and created outside the loop, therefore the; // cost of creating it is not accounted for here. However if we have both; // a MaskForGaps and some other mask that guards the execution of the; // memory access, we need to account for the cost of And-ing the two masks; // inside the loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:12,mask,mask,12,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,8,"['Mask', 'mask']","['MaskForGaps', 'mask', 'masks']"
Availability,"// The HIPAMDToolChain only supports sanitizers in the sense that it allows; // sanitizer arguments on the command line if they are supported by the host; // toolchain. The HIPAMDToolChain will actually ignore any command line; // arguments for any of these ""supported"" sanitizers. That means that no; // sanitization of device code is actually supported at this time.; //; // This behavior is necessary because the host and device toolchains; // invocations often share the command line, so the device toolchain must; // tolerate flags meant only for the host toolchain.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPAMD.cpp:522,toler,tolerate,522,interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPAMD.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPAMD.cpp,1,['toler'],['tolerate']
Availability,"// The HIPSPVToolChain only supports sanitizers in the sense that it allows; // sanitizer arguments on the command line if they are supported by the host; // toolchain. The HIPSPVToolChain will actually ignore any command line; // arguments for any of these ""supported"" sanitizers. That means that no; // sanitization of device code is actually supported at this time.; //; // This behavior is necessary because the host and device toolchains; // invocations often share the command line, so the device toolchain must; // tolerate flags meant only for the host toolchain.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPSPV.cpp:522,toler,tolerate,522,interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPSPV.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPSPV.cpp,1,['toler'],['tolerate']
Availability,"// The Initialize() function is called twice in CUDA mode. The first time; // the host interpreter is initialized and the second time the device; // interpreter is initialized. Without this if statement, a redefinition; // error would occur because process(), declare(), and parse() are designed; // to process the code in the host and device interpreter when called by the; // host interpreter instance. This means that first the Initialize(); // function of the host interpreter is called and the initialization code is; // processed in the host and device interpreter. It then calls the; // Initialize() function of the device interpreter and throws an error; // because the code was already processed in the host Initialize() function.; //; // declare() is only used to generate a valid Transaction object",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Interpreter.cpp:223,error,error,223,interpreter/cling/lib/Interpreter/Interpreter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Interpreter.cpp,2,['error'],['error']
Availability,"// The KnownZero mask must be a shifted mask (e.g., 1110..011, 11100..00).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:17,mask,mask,17,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,2,['mask'],['mask']
Availability,"// The LLVM shufflevector instruction does not require the shuffle mask; // length to match the operand vector length, but ISD::VECTOR_SHUFFLE does; // have that requirement. When translating to ISD::VECTOR_SHUFFLE, if the; // operands do not match the mask length, they are extended by concatenating; // them with undef vectors. That is probably the right thing for other; // targets, but for NEON it is better to concatenate two double-register; // size vector operands into a single quad-register size vector. Do that; // transformation here:; // shuffle(concat(v1, undef), concat(v2, undef)) ->; // shuffle(concat(v1, v2), undef)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:67,mask,mask,67,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,2,['mask'],['mask']
Availability,// The LastUseMask is queried from the liveness information of instruction; // which may be further down the schedule. Some lanes may actually not be; // last uses for the current position.; // FIXME: allow the caller to pass in the list of vreg uses that remain; // to be bottom-scheduled to avoid searching uses at each query.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp:100,down,down,100,interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,1,['down'],['down']
Availability,"// The LiveIn value is available at block entry, begin tracking and record; // the transfer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:23,avail,available,23,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['avail'],['available']
Availability,"// The MCU psABI allows passing parameters in-reg even if there are; // earlier parameters that are passed on the stack. Also,; // it does not allow passing >8-byte structs in-register,; // even if there are 3 free registers available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp:225,avail,available,225,interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,1,['avail'],['available']
Availability,"// The ML advisor will typically have a sparse input to the evaluator, because; // various phys regs won't be available. It's easier (maintenance-wise) to; // bulk-reset the state of the evaluator each time we are about to use it; // again.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:110,avail,available,110,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,2,"['avail', 'mainten']","['available', 'maintenance-wise']"
Availability,// The MSVC personality cannot tolerate catches getting inlined into; // cleanup funclets.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:31,toler,tolerate,31,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,1,['toler'],['tolerate']
Availability,// The Mask,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp:7,Mask,Mask,7,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,2,['Mask'],['Mask']
Availability,"// The Mask shuffling cost is extract all the elements of the Mask; // and insert each of them Factor times into the wide vector:; //; // E.g. an interleaved group with factor 3:; // %mask = icmp ult <8 x i32> %vec1, %vec2; // %interleaved.mask = shufflevector <8 x i1> %mask, <8 x i1> undef,; // <24 x i32> <0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7>; // The cost is estimated as extract all mask elements from the <8xi1> mask; // vector and insert them factor times into the <24xi1> shuffled mask; // vector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:7,Mask,Mask,7,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,8,"['Mask', 'mask']","['Mask', 'mask']"
Availability,// The Mask. Update in place.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp:7,Mask,Mask,7,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,1,['Mask'],['Mask']
Availability,"// The Microsoft #import directive takes a type library and generates header; // files from it, and includes those. This is beyond the scope of what clang; // does, so we ignore it and error out. However, #import can optionally have; // trailing attributes that span multiple lines. We're going to eat those; // so we can continue processing from there.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:185,error,error,185,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,1,['error'],['error']
Availability,// The NSA encoding does not contain enough operands for the; // combination of base opcode / dimension. Should this be an error?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Disassembler/AMDGPUDisassembler.cpp:123,error,error,123,interpreter/llvm-project/llvm/lib/Target/AMDGPU/Disassembler/AMDGPUDisassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Disassembler/AMDGPUDisassembler.cpp,1,['error'],['error']
Availability,"// The Op itself may be of different VT, so we need to scale the mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:65,mask,mask,65,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// The PD variants uses bit 1 to select per-lane element index, so; // shift down to convert to generic shuffle mask index.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:77,down,down,77,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,2,"['down', 'mask']","['down', 'mask']"
Availability,// The PSHUFB mask:,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:14,mask,mask,14,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// The ParseOpenACCCacheVarList function manages to recover from failures,; // so we can always consume the close.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:52,recover,recover,52,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,2,"['failure', 'recover']","['failures', 'recover']"
Availability,"// The RHS is not a nested logical operation. Don't push the terminator; // down further, but instead visit RHS and construct the respective; // pieces of the CFG, and link up the RHSBlock with the terminator; // we have been provided.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:76,down,down,76,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,1,['down'],['down']
Availability,// The RHS of the AND should be a mask with as many bits as SubVec.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:34,mask,mask,34,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// The RegScavenger represents registers available *after* the MI; // instruction pointed to by RS.getCurrentPosition().; // We need to have a register that is available *before* the MI is executed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp:41,avail,available,41,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp,2,['avail'],['available']
Availability,"// The RequestMap stores MPI requests which are identified by their memory; // region. Requests are used in MPI to complete nonblocking operations with wait; // operations. A custom map implementation is used, in order to make it; // available in an arbitrary amount of translation units.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPITypes.h:234,avail,available,234,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPITypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPITypes.h,1,['avail'],['available']
Availability,"// The Roo2DKeys options available are:; // a = select an adaptive bandwidth [default]; // n = select a normal bandwidth; // m = mirror kernel contributions at edges [fold gaussians back into the x,y plane]; // d = print debug statements [useful for development only; default is off]; // v = print verbose debug statements [useful for development only; default is off]; // vv = print ludicrously verbose debug statements [useful for development only; default is off]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/inc/Roo2DKeysPdf.h:25,avail,available,25,roofit/roofit/inc/Roo2DKeysPdf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/inc/Roo2DKeysPdf.h,1,['avail'],['available']
Availability,"// The SHUFFLE_VECTOR mask is almost exactly what we want for vperm, except; // that it is in input element units, not in bytes. Convert now.; // For little endian, the order of the input vectors is reversed, and; // the permutation mask is complemented with respect to 31. This is; // necessary to produce proper semantics with the big-endian-based vperm; // instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:22,mask,mask,22,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,2,['mask'],['mask']
Availability,"// The STL GenerateInitInstance are not unique and hence are declared static; // (not accessible outside the dictionary and not linker error for duplicate)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/RtypesImp.h:135,error,error,135,core/base/inc/RtypesImp.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/RtypesImp.h,1,['error'],['error']
Availability,"// The Shuffle result is as follow:; // 0*a[0]0*a[1]...0*a[n] , n >=0 where a[] elements in a ascending order.; // Each Zeroable's element correspond to a particular Mask's element.; // As described in computeZeroableShuffleElements function.; //; // The function looks for a sub-mask that the nonzero elements are in; // increasing order. If such sub-mask exist. The function returns true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:166,Mask,Mask,166,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,3,"['Mask', 'mask']","['Mask', 'mask']"
Availability,// The StoreSwiftAsyncContext clobbers X16 and X17. Make sure they are; // available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp:75,avail,available,75,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,1,['avail'],['available']
Availability,"// The TROOT destructor re-installed the minimal error handler",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/test/TErrorTests.cxx:49,error,error,49,core/base/test/TErrorTests.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/test/TErrorTests.cxx,1,['error'],['error']
Availability,"// The TfrI does not access memory, but DefI could. Check if it's safe; // to move DefI down to TfrI.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:88,down,down,88,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,1,['down'],['down']
Availability,"// The Tree Index in the friend has a pair majorname,minorname; // not available in the parent Tree T.; // if the friend Tree has less entries than the parent, this is an error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TChainIndex.cxx:71,avail,available,71,tree/treeplayer/src/TChainIndex.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TChainIndex.cxx,4,"['avail', 'error']","['available', 'error']"
Availability,"// The TypeSourceInfo that this function returns will not be a null type.; // If there is an error, this function will fill in a dummy type as fallback.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:93,error,error,93,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,1,['error'],['error']
Availability,// The WrappedAction can be nullptr if we issued an error in the ctor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp:52,error,error,52,interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp,1,['error'],['error']
Availability,// The XPACLRI instruction assembles to a hint-space instruction before; // Armv8.3-A therefore this instruction can be safely used for any pre; // Armv8.3-A architectures. On Armv8.3-A and onwards XPACI is available so use; // that instead.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:207,avail,available,207,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['avail'],['available']
Availability,"// The _256 variants are a bit trickier since the mask bits always index; // into the corresponding 128 half. In order to convert to a generic; // shuffle, we have to make that explicit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:50,mask,mask,50,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,1,['mask'],['mask']
Availability,// The __bf16 type is generally available so long as we have any fp registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp:32,avail,available,32,interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp,1,['avail'],['available']
Availability,"// The `llvm.experimental.patchpoint.*` intrinsic.; // Operands: input chain, [glue], reg-mask, <id>, <numShadowBytes>, callee,; // <numArgs>, cc, ...; // Outputs: [rv], output chain, glue",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:90,mask,mask,90,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,1,['mask'],['mask']
Availability,// The access of the path down to this record.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:26,down,down,26,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,1,['down'],['down']
Availability,"// The access offset from the base of the head of chain is also; // calculated here as all debuginfo types are available.; // Get type name and calculate the first index.; // We only want to get type name from typedef, structure or union.; // If user wants a relocation like; // int *p; ... __builtin_preserve_access_index(&p[4]) ...; // or; // int a[10][20]; ... __builtin_preserve_access_index(&a[2][3]) ...; // we will skip them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:111,avail,available,111,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,1,['avail'],['available']
Availability,"// The active lane intrinsic has this form:; //; // @llvm.get.active.lane.mask(IV, TC); //; // Here we perform checks that this intrinsic behaves as expected,; // which means:; //; // 1) Check that the TripCount (TC) belongs to this loop (originally).; // 2) The element count (TC) needs to be sufficiently large that the decrement; // of element counter doesn't overflow, which means that we need to prove:; // ceil(ElementCount / VectorWidth) >= TripCount; // by rounding up ElementCount up:; // ((ElementCount + (VectorWidth - 1)) / VectorWidth; // and evaluate if expression isKnownNonNegative:; // (((ElementCount + (VectorWidth - 1)) / VectorWidth) - TripCount; // 3) The IV must be an induction phi with an increment equal to the; // vector width.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp:74,mask,mask,74,interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp,1,['mask'],['mask']
Availability,"// The add method returns an Error instance which simulates program exit; // code through overloading boolean operator, thus false here indicates; // success.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/DefinitionBlockSeparator.cpp:29,Error,Error,29,interpreter/llvm-project/clang/lib/Format/DefinitionBlockSeparator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/DefinitionBlockSeparator.cpp,1,['Error'],['Error']
Availability,"// The address passed to operator() will be the address of the start of the; // object. Overload this routine, if your derived class can optimize; // the handling of the onfileClass (rather than storing and restoring from the; // fOnFileClass member.; // Note we can not name this routine 'operator' has it would be slightly; // backward incompatible and lead to the following warning/error from the; // compiler in the derived class overloading the other operator():; // include/TClassStreamer.h:51: error: ‘virtual void TClassStreamer::operator()(TBuffer&, void*, const TClass*)’ was hidden; // include/TCollectionProxyFactory.h:180: error: by ‘virtual void TCollectionClassStreamer::operator()(TBuffer&, void*)’; // cc1plus: warnings being treated as errors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TClassStreamer.h:385,error,error,385,core/meta/inc/TClassStreamer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TClassStreamer.h,4,['error'],"['error', 'errors']"
Availability,"// The algorithm first computes the set L of global variables that are; // trivially live. Then it walks the initialization of these variables to; // compute the globals used to initialize them, which effectively builds a; // directed graph where nodes are global variables, and an edge from A to B; // means B is used to initialize A. Finally, it propagates the liveness; // information through the graph starting from the nodes in L. Nodes note; // marked as alive are discarded.; // Remove empty functions from the global ctors list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:461,alive,alive,461,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,1,['alive'],['alive']
Availability,"// The algorithm for updating NRVO candidate is as follows:; // 1. All previous candidates become invalid because a new NRVO candidate is; // obtained. Therefore, we need to clear return slots for other; // variables defined before the current return statement in the current; // scope and in outer scopes.; // 2. Store the new candidate if its return slot is available. Otherwise,; // there is no NRVO candidate so far.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Scope.cpp:360,avail,available,360,interpreter/llvm-project/clang/lib/Sema/Scope.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Scope.cpp,1,['avail'],['available']
Availability,// The alignment is stored as a 16-bit raw value from bits 31--16. We shift; // the bits above 31 down by 11 bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:98,down,down,98,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,1,['down'],['down']
Availability,// The alive bits of the input are the reversed alive bits of; // the output.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp:7,alive,alive,7,interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,2,['alive'],['alive']
Availability,// The alive bits of the input are the swapped alive bits of; // the output.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp:7,alive,alive,7,interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,2,['alive'],['alive']
Availability,"// The always_inline attribute doesn't reliably apply to a coroutine,; // because the coroutine will be split into pieces and some pieces; // might be called indirectly, as in a virtual call. Even the ramp; // function cannot be inlined at -O0, due to pipeline ordering; // problems (see https://llvm.org/PR53413). Tell the user about it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:39,reliab,reliably,39,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,1,['reliab'],['reliably']
Availability,// The amount of shift we're trying to fit into the addressing mode is taken; // from the shifted mask index (number of trailing zeros of the mask).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:98,mask,mask,98,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,4,['mask'],['mask']
Availability,"// The assumption is that if the Runner could not be constructed, we emit-ed; // error, and we shouldn't be asking for it here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:81,error,error,81,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,2,['error'],['error']
Availability,"// The attribute was allowed to have arguments, but none were provided; // even though the attribute parsed successfully. This is an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:133,error,error,133,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,1,['error'],['error']
Availability,"// The basic idea here is that we're expanding a cmpxchg of a; // smaller memory size up to a word-sized cmpxchg. To do this, we; // need to add a retry-loop for strong cmpxchg, so that; // modifications to other parts of the word don't cause a spurious; // failure.; // This generates code like the following:; // [[Setup mask values PMV.*]]; // %NewVal_Shifted = shl i32 %NewVal, %PMV.ShiftAmt; // %Cmp_Shifted = shl i32 %Cmp, %PMV.ShiftAmt; // %InitLoaded = load i32* %addr; // %InitLoaded_MaskOut = and i32 %InitLoaded, %PMV.Inv_Mask; // br partword.cmpxchg.loop; // partword.cmpxchg.loop:; // %Loaded_MaskOut = phi i32 [ %InitLoaded_MaskOut, %entry ],; // [ %OldVal_MaskOut, %partword.cmpxchg.failure ]; // %FullWord_NewVal = or i32 %Loaded_MaskOut, %NewVal_Shifted; // %FullWord_Cmp = or i32 %Loaded_MaskOut, %Cmp_Shifted; // %NewCI = cmpxchg i32* %PMV.AlignedAddr, i32 %FullWord_Cmp,; // i32 %FullWord_NewVal success_ordering failure_ordering; // %OldVal = extractvalue { i32, i1 } %NewCI, 0; // %Success = extractvalue { i32, i1 } %NewCI, 1; // br i1 %Success, label %partword.cmpxchg.end,; // label %partword.cmpxchg.failure; // partword.cmpxchg.failure:; // %OldVal_MaskOut = and i32 %OldVal, %PMV.Inv_Mask; // %ShouldContinue = icmp ne i32 %Loaded_MaskOut, %OldVal_MaskOut; // br i1 %ShouldContinue, label %partword.cmpxchg.loop,; // label %partword.cmpxchg.end; // partword.cmpxchg.end:; // %tmp1 = lshr i32 %OldVal, %PMV.ShiftAmt; // %FinalOldVal = trunc i32 %tmp1 to i8; // %tmp2 = insertvalue { i8, i1 } undef, i8 %FinalOldVal, 0; // %Res = insertvalue { i8, i1 } %25, i1 %Success, 1",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:258,failure,failure,258,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,5,"['failure', 'mask']","['failure', 'mask']"
Availability,// The below are shared state we want to have available when eliminating any; // calls in the function. There values should be populated by; // createTailRecurseLoopHeader the first time we find a call we can eliminate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:46,avail,available,46,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,1,['avail'],['available']
Availability,// The bit is not set; this must be an error!,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DecoderEmitter.cpp:39,error,error,39,interpreter/llvm-project/llvm/utils/TableGen/DecoderEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DecoderEmitter.cpp,1,['error'],['error']
Availability,// The bit mask contains all register classes that are projected into B; // by Idx. Find a class that is also a sub-class of A.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp:11,mask,mask,11,interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp,1,['mask'],['mask']
Availability,// The bitcast is from narrow elements to wide elements. The shuffle mask; // must choose consecutive elements to allow casting first.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:69,mask,mask,69,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,1,['mask'],['mask']
Availability,// The bitcast is from wide to narrow/equal elements. The shuffle mask can; // always be expanded to the equivalent form choosing narrower elements.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:66,mask,mask,66,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,1,['mask'],['mask']
Availability,// The block literal may be assigned to a const variable. Chasing down; // to get the block literal.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenCLRuntime.cpp:66,down,down,66,interpreter/llvm-project/clang/lib/CodeGen/CGOpenCLRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenCLRuntime.cpp,1,['down'],['down']
Availability,// The block that explicitly generates a break-point exception on failure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64PointerAuth.cpp:66,failure,failure,66,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64PointerAuth.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64PointerAuth.cpp,1,['failure'],['failure']
Availability,"// The block throughput is also limited by the amount of hardware parallelism.; // The number of available resource units affects the resource pressure; // distribution, as well as how many blocks can be executed every cycle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/Support.cpp:97,avail,available,97,interpreter/llvm-project/llvm/lib/MCA/Support.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/Support.cpp,1,['avail'],['available']
Availability,// The boolean operations on these vector types use an instruction that; // results in a mask of '-1' for the 'truth' value. Ensure that we negate 1; // to -1 to make sure that we produce the correct value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:89,mask,mask,89,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['mask'],['mask']
Availability,"// The boolean result conforms to getBooleanContents. Fall through.; // If setcc returns 0/-1, all bits are sign bits.; // We know that we have an integer-based boolean since these operations; // are only available for integer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:205,avail,available,205,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['avail'],['available']
Availability,"// The boolean result conforms to getBooleanContents.; // If we know the result of a setcc has the top bits zero, use this info.; // We know that we have an integer-based boolean since these operations; // are only available for integer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:215,avail,available,215,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,2,['avail'],['available']
Availability,"// The buffered version still follows OpenCL printf standards for; // printf return value, i.e 0 on success, -1 on failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp:115,failure,failure,115,interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp,1,['failure'],['failure']
Availability,// The build_vector allows the scalar element to be larger than the vector; // element type. We need to mask it to use as a condition unless we know; // the upper bits are zero.; // FIXME: Use computeKnownBits instead of checking specific opcode?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:104,mask,mask,104,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// The byte offset is relative to the start of the string table.; // A byte offset value of 0 is a null or zero-length symbol; // name. A byte offset in the range 1 to 3 (inclusive) points into the length; // field; as a soft-error recovery mechanism, we treat such cases as having an; // offset of 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/XCOFFObjectFile.cpp:226,error,error,226,interpreter/llvm-project/llvm/lib/Object/XCOFFObjectFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/XCOFFObjectFile.cpp,2,"['error', 'recover']","['error', 'recovery']"
Availability,"// The caller should guarantee that we have at least 1 byte available, so; // we just assert instead of revalidate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFDebugRnglists.cpp:60,avail,available,60,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFDebugRnglists.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFDebugRnglists.cpp,1,['avail'],['available']
Availability,// The caller wants to handle out-of-date failures.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:42,failure,failures,42,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,1,['failure'],['failures']
Availability,"// The callgraph-scc needs to be visited in top-down order for propagation.; // The scc iterator returns the scc in bottom-up order, so reverse the SCCs; // and call propagateFromSCC.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/SyntheticCountsUtils.cpp:48,down,down,48,interpreter/llvm-project/llvm/lib/Analysis/SyntheticCountsUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/SyntheticCountsUtils.cpp,1,['down'],['down']
Availability,// The check to see if the argIndex is valid will come later.; // We set the bit here because we may exit early from this; // function if we encounter some other error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:162,error,error,162,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,2,['error'],['error']
Availability,"// The checker knows that an out-of-line object is deallocated if it is; // passed as an argument to one of these functions. If this object is; // additionally an argument of a MIG routine, the checker keeps track of that; // information and issues a warning when an error is returned from the; // respective routine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp:267,error,error,267,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,1,['error'],['error']
Availability,"// The class has dictionary, has gone through some initialization and is now being requested; // to be filled by a TProtoClass.; // This can be due to:; // (a) A duplicate dictionary for a class (with or without a rootpcm associated with); // (b) The TClass was created before the registration of the rootpcm ** and ** it was; // attempted to be used before this registration; // This is technically an error; // but we either already warned that there is a 2nd dictionary for the class (in TClassTable::Add); // or this is the same (but now emptied) TProtoClass instance as before.; // We return false, since we are doing no actual change to the TClass instance and thus; // if a caller was hoping for 'improvement' in the state of the TClass instance, it did not; // happen.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TProtoClass.cxx:403,error,error,403,core/meta/src/TProtoClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TProtoClass.cxx,1,['error'],['error']
Availability,"// The code below is somewhat fragile because we are essentially trying to; // report to the user what happened by inferring what the diagnostic engine; // did. Eventually it might make more sense to have the diagnostic engine; // include some ""why"" information in the diagnostic.; // If this is a warning which has been mapped to an error by the user (as; // inferred by checking whether the default mapping is to an error) then; // flag it as such. Note that diagnostics could also have been mapped by a; // pragma, but we don't currently have a way to distinguish this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticPrinter.cpp:334,error,error,334,interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticPrinter.cpp,2,['error'],['error']
Availability,"// The code-generator is currently not able to handle scalable vectors; // of <vscale x 1 x eltty> yet, so return an invalid cost to avoid selecting; // it. This change will be removed when code-generation for these types is; // sufficiently reliable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp:242,reliab,reliable,242,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,4,['reliab'],['reliable']
Availability,"// The colors on the surface can represent the content or the errors.; // if (fSumw2.fN) t[i] = gCurrentHist->GetBinError(icx, iyt + iya);; // else t[i] = f[i * 3 + 3];",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx:62,error,errors,62,hist/histpainter/src/TPainter3dAlgorithms.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx,1,['error'],['errors']
Availability,"// The condition we need is now:; //; // (NegC - NegOp1) & Mask == (EltSize - Pos) & Mask; //; // If NegOp1 == Pos then we need:; //; // EltSize & Mask == NegC & Mask; //; // (because ""x & Mask"" is a truncation and distributes through subtraction).; //; // We also need to account for a potential truncation of NegOp1 if the amount; // has already been legalized to a shift amount type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:59,Mask,Mask,59,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,5,['Mask'],['Mask']
Availability,// The contents of SP and thread pointer register do not require masking.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:65,mask,masking,65,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,1,['mask'],['masking']
Availability,// The contract with the ML side is that CandidatePos is mask == 1 (i.e.; // Regs[CandidatePos].second),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:57,mask,mask,57,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,1,['mask'],['mask']
Availability,"// The correct behavior here is to add the offset into the TBAA; // struct node offset. The base type, however may not have defined; // a type at this additional offset, resulting in errors. Since; // this method is only used within a given load/store access; // the offset provided is only used to subdivide the previous load; // maintaining the validity of the previous TBAA.; //; // This, however, should be revisited in the future.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:183,error,errors,183,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,1,['error'],['errors']
Availability,"// The cost of convert from or to mask vector is different from other; // cases. We could not use PowDiff to calculate it.; // For mask vector to fp, we should use the following instructions:; // vmv.v.i v8, 0; // vmerge.vim v8, v8, -1, v0; // vfcvt.f.x.v v8, v8; // And for fp vector to mask, we use:; // vfncvt.rtz.x.f.w v9, v8; // vand.vi v8, v9, 1; // vmsne.vi v0, v8, 0",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:34,mask,mask,34,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,3,['mask'],['mask']
Availability,"// The ctor in this case is guaranteed to be a copy ctor, otherwise we hit a; // compile time error.; //; // -ArrayInitLoopExpr <-- we're here; // |-OpaqueValueExpr; // | `-DeclRefExpr <-- match this; // `-CXXConstructExpr; // `-ImplicitCastExpr; // `-ArraySubscriptExpr; // |-ImplicitCastExpr; // | `-OpaqueValueExpr; // | `-DeclRefExpr; // `-ArrayInitIndexExpr; //; // The resulting expression might look like the one below in an implicit; // copy/move ctor.; //; // ArrayInitLoopExpr <-- we're here; // |-OpaqueValueExpr; // | `-MemberExpr <-- match this; // | (`-CXXStaticCastExpr) <-- move ctor only; // | `-DeclRefExpr; // `-CXXConstructExpr; // `-ArraySubscriptExpr; // |-ImplicitCastExpr; // | `-OpaqueValueExpr; // | `-MemberExpr; // | `-DeclRefExpr; // `-ArrayInitIndexExpr; //; // The resulting expression for a multidimensional array.; // ArrayInitLoopExpr <-- we're here; // |-OpaqueValueExpr; // | `-DeclRefExpr <-- match this; // `-ArrayInitLoopExpr; // |-OpaqueValueExpr; // | `-ArraySubscriptExpr; // | |-ImplicitCastExpr; // | | `-OpaqueValueExpr; // | | `-DeclRefExpr; // | `-ArrayInitIndexExpr; // `-CXXConstructExpr <-- extract this; // ` ...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:94,error,error,94,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,1,['error'],['error']
Availability,"// The current TTree is already available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReader.cxx:32,avail,available,32,tree/treeplayer/src/TTreeReader.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReader.cxx,1,['avail'],['available']
Availability,// The current compilation unit may not have DIEs and it will not be; // able to find the associated abbrev table. We consume the error and; // assign 0 to the debug_abbrev_offset in such circumstances.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjectYAML/DWARFEmitter.cpp:130,error,error,130,interpreter/llvm-project/llvm/lib/ObjectYAML/DWARFEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjectYAML/DWARFEmitter.cpp,1,['error'],['error']
Availability,"// The current implementation of long branch pass requires a scratch; // register ($at) to be available before branch instructions. Tail merging; // can break this requirement, so disable it when long branch pass is; // enabled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp:94,avail,available,94,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp,1,['avail'],['available']
Availability,"// The current working directory, without symlinks resolved. (echo $PWD).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/VirtualFileSystem.cpp:62,echo,echo,62,interpreter/llvm-project/llvm/lib/Support/VirtualFileSystem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/VirtualFileSystem.cpp,1,['echo'],['echo']
Availability,// The data sections option is on by default on AIX. We only need to error; // out when -fno-data-sections is specified explicitly to turn off data; // sections.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp:69,error,error,69,interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp,1,['error'],['error']
Availability,"// The dataset need to be kept alive because the datamap points to their content",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BatchModeDataHelpers.cxx:31,alive,alive,31,roofit/roofitcore/src/BatchModeDataHelpers.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BatchModeDataHelpers.cxx,1,['alive'],['alive']
Availability,"// The declaration can have multiple availability attributes, we are looking; // at one of them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:37,avail,availability,37,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,1,['avail'],['availability']
Availability,"// The declaration won't be seen outside of the statement, so we don't; // have to wrap the uses of any declared variables in if (@available).; // Therefore we can avoid setting Scope here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:131,avail,available,131,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,1,['avail'],['available']
Availability,"// The deduction failure is diagnosed and marked, try to recover.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:17,failure,failure,17,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,2,"['failure', 'recover']","['failure', 'recover']"
Availability,// The def of statepoint instruction is a gc relocation and it should be alive; // in landing pad. So we cannot split interval after statepoint instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:73,alive,alive,73,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,1,['alive'],['alive']
Availability,"// The default error level for MINUIT error analysis for a chi^2 is 1.0",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooChi2Var.h:15,error,error,15,roofit/roofitcore/src/RooChi2Var.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooChi2Var.h,4,['error'],['error']
Availability,// The default handling is broken and doesn't handle illegal SGPR->VGPR copies; // properly.; //; // TODO: There are additional exec masking dependencies to analyze.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp:133,mask,masking,133,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,1,['mask'],['masking']
Availability,// The default mask clobbers everything. All targets should override.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:15,mask,mask,15,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,1,['mask'],['mask']
Availability,"// The default value (0) means all available threads should be used,; // taking the affinity mask into account. If set, this value only represents; // a suggested high bound, the runtime might choose a lower value (not; // higher).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Threading.h:35,avail,available,35,interpreter/llvm-project/llvm/include/llvm/Support/Threading.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Threading.h,2,"['avail', 'mask']","['available', 'mask']"
Availability,"// The destructor will close the TFitEditor and terminate the; // application. Unfortunately, the application must be run from; // main, otherwise, the test will make a segmentation fault while; // trying to retrieve the TFitEditor singleton. If the user wants; // to play a bit with the fitpanel once the tests have finised,; // then they should comment this method.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/test/UnitTesting.cxx:182,fault,fault,182,gui/fitpanel/test/UnitTesting.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/test/UnitTesting.cxx,1,['fault'],['fault']
Availability,"// The different predicates and matchers created during; // addInstructionMatcher use the RuleMatcher M to set up their; // instruction ID (InsnVarID) that are going to be used when; // M is going to be emitted.; // However, the code doing the emission still relies on the IDs; // returned during that process by the RuleMatcher when issuing; // the recordInsn opcodes.; // Because of that:; // 1. The order in which we created the predicates; // and such must be the same as the order in which we emit them,; // and; // 2. We need to reset the generation of the IDs in M somewhere between; // addInstructionMatcher and emit; //; // FIXME: Long term, we don't want to have to rely on this implicit; // naming being the same. One possible solution would be to have; // explicit operator for operation capture and reference those.; // The plus side is that it would expose opportunities to share; // the capture accross rules. The downside is that it would; // introduce a dependency between predicates (captures must happen; // before their first use.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelEmitter.cpp:929,down,downside,929,interpreter/llvm-project/llvm/utils/TableGen/GlobalISelEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelEmitter.cpp,1,['down'],['downside']
Availability,// The distance is too large - still may be profitable to use masked; // loads/gathers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:62,mask,masked,62,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['mask'],['masked']
Availability,"// The early exit in the original loop means that when performing vector; // loads we are potentially reading ahead of the early exit. So we could; // fault if crossing a page boundary. Therefore, we create runtime memory; // checks based on the minimum page size as follows:; // 1. Calculate the addresses of the first memory accesses in the loop,; // i.e. LhsStart and RhsStart.; // 2. Get the last accessed addresses in the loop, i.e. LhsEnd and RhsEnd.; // 3. Determine which pages correspond to all the memory accesses, i.e; // LhsStartPage, LhsEndPage, RhsStartPage, RhsEndPage.; // 4. If LhsStartPage == LhsEndPage and RhsStartPage == RhsEndPage, then; // we know we won't cross any page boundaries in the loop so we can; // enter the vector loop! Otherwise we fall back on the scalar loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoopIdiomTransform.cpp:151,fault,fault,151,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoopIdiomTransform.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoopIdiomTransform.cpp,1,['fault'],['fault']
Availability,"// The ellipsis was put in the wrong place. Recover, and explain to; // the user what they should have done.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:44,Recover,Recover,44,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['Recover'],['Recover']
Availability,// The enum could be incomplete if we're parsing its definition or; // recovering from an error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:71,recover,recovering,71,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,2,"['error', 'recover']","['error', 'recovering']"
Availability,// The error function is set here because the context is the first object; // created by the backend,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Z3Solver.cpp:7,error,error,7,interpreter/llvm-project/llvm/lib/Support/Z3Solver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Z3Solver.cpp,1,['error'],['error']
Availability,// The error is unknown but may be FEOF.; // Continue analysis with the FEOF error state.; // Report warning because the other possible error states.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:7,error,error,7,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,3,['error'],['error']
Availability,"// The error message is in the output file, let's print it out from there.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:7,error,error,7,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,1,['error'],['error']
Availability,// The error messages must match.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp:7,error,error,7,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp,1,['error'],['error']
Availability,"// The evaluation of this constraint resulted in us trying to re-evaluate it; // recursively. This isn't really possible, except we try to form a; // RecoveryExpr as a part of the evaluation. If this is the case, just; // return the 'cached' version (which will have the same result), and save; // ourselves the extra-insert. If it ever becomes possible to legitimately; // recursively check a constraint, we should skip checking the 'inner' one; // above, and replace the cached version with this one, as it would be more; // specific.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:150,Recover,RecoveryExpr,150,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,1,['Recover'],['RecoveryExpr']
Availability,"// The existing property is more likely to be associated with a; // derived node, so use it as the error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangASTPropertiesEmitter.cpp:99,error,error,99,interpreter/llvm-project/clang/utils/TableGen/ClangASTPropertiesEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangASTPropertiesEmitter.cpp,1,['error'],['error']
Availability,"// The exit code of the process on windows is not meaningful as a; // signal, so simply pass in -1 as the signal into the error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp:122,error,error,122,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp,1,['error'],['error']
Availability,// The explicit zeroing is redundant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:27,redundant,redundant,27,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['redundant'],['redundant']
Availability,"// The extra condition (fElement is not a TStreamerSTL) is to handle the case where fBranch is a; // TBranchElement and fElement is a TStreamerSTL. Without the extra condition we get an error; // message, although the vector (i.e. the TBranchElement) is accessible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TBranchProxy.cxx:186,error,error,186,tree/treeplayer/src/TBranchProxy.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TBranchProxy.cxx,1,['error'],['error']
Availability,// The extracted elements must start at a valid index and all mask; // elements must be in the lower half.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:62,mask,mask,62,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// The failure was something other than an missing exception; // specification; return an error, except in MS mode where this is a warning.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:7,failure,failure,7,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,2,"['error', 'failure']","['error', 'failure']"
Availability,// The feature mask will be placed after the function size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp:15,mask,mask,15,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp,1,['mask'],['mask']
Availability,"// The field that the column belongs to has to be already available. For fields with multiple columns,; // the columns need to be added in order of the column index",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx:58,avail,available,58,tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,1,['avail'],['available']
Availability,"// The file ""FileName"" was created by this utility in the previous steps; // (i.e. it is already known that it should pass the isObject check).; // If the createBinary() function does not return an error, the isObject; // check should also be successful.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfutil/llvm-dwarfutil.cpp:198,error,error,198,interpreter/llvm-project/llvm/tools/llvm-dwarfutil/llvm-dwarfutil.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfutil/llvm-dwarfutil.cpp,1,['error'],['error']
Availability,"// The final check is to ensure that any masked out high bits of X are; // already known to be zero. Otherwise, the mask has a semantic impact; // other than masking out a couple of low bits. Unfortunately, because of; // the mask, zero extensions will be removed from operands in some cases.; // This code works extra hard to look through extensions because we can; // replace them with zero extensions cheaply if necessary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:41,mask,masked,41,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,4,['mask'],"['mask', 'masked', 'masking']"
Availability,"// The final parameters of alpha_syst2 and alpha_syst4 are very close to the; // pre-fit value zero. For the fit to converge reliably, the pre-fit values; // are set away from the minimum.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/test/testHistFactory.cxx:125,reliab,reliably,125,roofit/histfactory/test/testHistFactory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/test/testHistFactory.cxx,1,['reliab'],['reliably']
Availability,"// The first *NumUsedElements* elements of ConvertOp are converted to the; // same number of output elements. The rest of the output is copied from; // CopyOp, or (if not available) filled with zeroes.; // Combine shadow for elements of ConvertOp that are used in this operation,; // and insert a check.; // FIXME: consider propagating shadow of ConvertOp, at least in the case of; // int->any conversion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:171,avail,available,171,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,1,['avail'],['available']
Availability,"// The first argument to a thunk is the called function, stored in x9.; // For exit thunks, we pass the called function down to the emulator;; // for entry/guest exit thunks, we just call the Arm64 function directly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Arm64ECCallLowering.cpp:120,down,down,120,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Arm64ECCallLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Arm64ECCallLowering.cpp,1,['down'],['down']
Availability,"// The first available",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:13,avail,available,13,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['avail'],['available']
Availability,"// The first declaration of an unnamed namespace, creates an implicit; // UsingDirectiveDecl that makes the names available in the parent DC (see; // `Sema::ActOnStartNamespaceDef()`).; // If we are reverting such first declaration, make sure we reset the; // anonymous namespace for the parent DeclContext so that the; // implicit UsingDirectiveDecl is created again when parsing the next; // anonymous namespace.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclUnloader.cpp:114,avail,available,114,interpreter/cling/lib/Interpreter/DeclUnloader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclUnloader.cpp,1,['avail'],['available']
Availability,"// The first mask is a permutation of a single register. Since we have >2; // input registers to shuffle, we merge the masks for 2 first registers; // and generate a shuffle of 2 registers rather than the reordering of the; // first register and then shuffle with the second register. Next,; // generate the shuffles of the resulting register + the remaining; // registers from the list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:13,mask,mask,13,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,2,['mask'],"['mask', 'masks']"
Availability,"// The first operand is the address, followed by the stored values, followed; // by an optional mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:96,mask,mask,96,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,1,['mask'],['mask']
Availability,// The first operand must be an AND and the second operand of the AND must be; // a shifted mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:92,mask,mask,92,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,1,['mask'],['mask']
Availability,// The first part of the mask must choose elements from exactly 1 source op.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:25,mask,mask,25,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,1,['mask'],['mask']
Availability,// The first-choice implementation: use `widen` when it is available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/DataflowAnalysis.h:59,avail,available,59,interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/DataflowAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/DataflowAnalysis.h,1,['avail'],['available']
Availability,// The flags permitted for apsr are the same flags that are allowed in; // M class registers. We get the flag value and then shift the flags into; // the correct place to combine with the mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp:188,mask,mask,188,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,"// The following case may be scalarized depending on the VF.; // The flag shows whether we can use a usual Call for vectorized; // version of the instruction.; // If we've found a variant at a previous VF, then stop looking. A; // vectorized variant of a function expects input in a certain shape; // -- basically the number of input registers, the number of lanes; // per register, and whether there's a mask required.; // We store a pointer to the variant in the VPWidenCallRecipe, so; // once we have an appropriate variant it's only valid for that VF.; // This will force a different vplan to be generated for each VF that; // finds a valid variant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:405,mask,mask,405,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['mask'],['mask']
Availability,"// The following class implements a function executor that executes the; // benchmark code within a subprocess rather than within the main llvm-exegesis; // process. This allows for much more control over the execution context of the; // snippet, particularly with regard to memory. This class performs all the; // necessary functions to create the subprocess, execute the snippet in the; // subprocess, and report results/handle errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp:430,error,errors,430,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp,1,['error'],['errors']
Availability,// The following code creates memset intrinsics out of thin air. Don't do; // this if the corresponding libfunc is not available.; // TODO: We should really distinguish between libcall availability and; // our ability to introduce intrinsics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:119,avail,available,119,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,2,['avail'],"['availability', 'available']"
Availability,"// The following code is ""failure""; we can't produce a sane translation; // for the given block. It assumes that we haven't modified any of; // our datastructures while processing the current block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:26,failure,failure,26,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['failure'],['failure']
Availability,"// The following function is not memory safe, because it takes ownership of var; // without moving it. It is not publicly available in the memory safe; // interfaces mode.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCollectionProxy.h:122,avail,available,122,roofit/roofitcore/inc/RooCollectionProxy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCollectionProxy.h,1,['avail'],['available']
Availability,// The following functions are available on at least FreeBSD:; // http://svn.freebsd.org/base/head/lib/libc/string/fls.c; // http://svn.freebsd.org/base/head/lib/libc/string/flsl.c; // http://svn.freebsd.org/base/head/lib/libc/string/flsll.c,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:31,avail,available,31,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,1,['avail'],['available']
Availability,"// The following functions are only available on GNU/Linux (using glibc).; // Linux variants without glibc (eg: bionic, musl) may have some subset.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:36,avail,available,36,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,1,['avail'],['available']
Availability,// The following line is equivalent to `(Size + Value - 1) / Value * Value`.; // The division followed by a multiplication can be thought of as a right; // shift followed by a left shift which zeros out the extra bits produced in; // the bump; `~(Value - 1)` is a mask where all those bits being zeroed out; // are just zero.; // Most compilers can generate this code but the pattern may be missed when; // multiple functions gets inlined.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Alignment.h:264,mask,mask,264,interpreter/llvm-project/llvm/include/llvm/Support/Alignment.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Alignment.h,1,['mask'],['mask']
Availability,"// The following loop iterates over all instructions in the basic block,; // and performs 2 operations:; // 1. Insert a CSDB at this location if needed.; // 2. Expand the SpeculationSafeValuePseudo if the current instruction is; // one.; //; // The insertion of the CSDB is done as late as possible (i.e. just before; // the use of a masked register), in the hope that that will reduce the; // total number of CSDBs in a block when there are multiple masked registers; // in the block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp:334,mask,masked,334,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp,2,['mask'],['masked']
Availability,// The following methods are only meaningful on targets that support; // S_WAITCNT.; /// \returns Vmcnt bit mask for given isa \p Version.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.h:108,mask,mask,108,interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.h,1,['mask'],['mask']
Availability,"// The following methods are only meaningful on targets that support; // S_WAIT_*CNT, introduced with gfx12.; /// \returns Loadcnt bit mask for given isa \p Version.; /// Returns 0 for versions that do not support LOADcnt",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.h:135,mask,mask,135,interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.h,1,['mask'],['mask']
Availability,"// The following section will collect all input filenames into a vector,; // including those listed within an indirect file.; // If any file can not be accessed, it will error out, unless skip_errors is true",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/main/src/hadd.cxx:170,error,error,170,main/src/hadd.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/main/src/hadd.cxx,1,['error'],['error']
Availability,"// The framework currently does not propagate the objects created in; // the two branches of a `ConditionalOperator` because there is no way; // to reconcile their storage locations, which are different. We; // therefore claim that the `ConditionalOperator` is the expression; // that originally constructs the object.; // Ultimately, this will be fixed by propagating locations down from; // the result object, rather than up from the original constructor as; // we do now (see also the FIXME in the documentation for; // `getResultObjectLocation()`).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp:379,down,down,379,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp,1,['down'],['down']
Availability,"// The full section header information might be not available here, so; // fill the space with zeroes as a placeholder.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjectYAML/ELFEmitter.cpp:52,avail,available,52,interpreter/llvm-project/llvm/lib/ObjectYAML/ELFEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjectYAML/ELFEmitter.cpp,1,['avail'],['available']
Availability,// The function label could have already been emitted if two symbols end up; // conflicting due to asm renaming. Detect this and emit an error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:137,error,error,137,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,1,['error'],['error']
Availability,"// The function pass manager would run all the function passes for a; // function, so we assume the last context belongs to this function. If; // this invariant ever changes, we can implement at that time switching; // contexts. At this point, it'd be an error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:255,error,error,255,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,2,['error'],['error']
Availability,"// The gMainDict is borrowed, i.e. we are not calling Py_INCREF(gMainDict).; // Like this, we avoid unexpectedly affecting how long __main__ is kept; // alive. The gMainDict is only used in Exec(), ExecScript(), and Eval(),; // which should not be called after __main__ is garbage collected anyway.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/API.cxx:153,alive,alive,153,bindings/pyroot/cppyy/CPyCppyy/src/API.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/API.cxx,2,['alive'],['alive']
Availability,"// The goal of this pass is to enable more efficient code generation for; // operations on narrow types (i.e. types with < 32-bits) and this is a; // motivating IR code example:; //; // define hidden i32 @cmp(i8 zeroext) {; // %2 = add i8 %0, -49; // %3 = icmp ult i8 %2, 3; // ..; // }; //; // The issue here is that i8 is type-legalized to i32 because i8 is not a; // legal type. Thus, arithmetic is done in integer-precision, but then the; // byte value is masked out as follows:; //; // t19: i32 = add t4, Constant:i32<-49>; // t24: i32 = and t19, Constant:i32<255>; //; // Consequently, we generate code like this:; //; // subs r0, #49; // uxtb r1, r0; // cmp r1, #3; //; // This shows that masking out the byte value results in generation of; // the UXTB instruction. This is not optimal as r0 already contains the byte; // value we need, and so instead we can just generate:; //; // sub.w r1, r0, #49; // cmp r1, #3; //; // We achieve this by type promoting the IR to i32 like so for this example:; //; // define i32 @cmp(i8 zeroext %c) {; // %0 = zext i8 %c to i32; // %c.off = add i32 %0, -49; // %1 = icmp ult i32 %c.off, 3; // ..; // }; //; // For this to be valid and legal, we need to prove that the i32 add is; // producing the same value as the i8 addition, and that e.g. no overflow; // happens.; //; // A brief sketch of the algorithm and some terminology.; // We pattern match interesting IR patterns:; // - which have ""sources"": instructions producing narrow values (i8, i16), and; // - they have ""sinks"": instructions consuming these narrow values.; //; // We collect all instruction connecting sources and sinks in a worklist, so; // that we can mutate these instruction and perform type promotion when it is; // legal to do so.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:460,mask,masked,460,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,2,['mask'],"['masked', 'masking']"
Availability,"// The gro variable has to outlive coroutine frame and coroutine promise, but,; // it can only be initialized after coroutine promise was created, thus, we; // split its emission in two parts. EmitGroAlloca emits an alloca and sets up; // cleanups. Later when coroutine promise is available we initialize the gro; // and sets the flag that the cleanup is now active.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp:281,avail,available,281,interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp,1,['avail'],['available']
Availability,"// The hazard sequence is three instructions:; // 1. VALU reads SGPR as mask; // 2. SALU writes SGPR; // 3. SALU reads SGPR; // The hazard can expire if the distance between 2 and 3 is sufficient.; // In practice this happens <10% of the time, hence this always assumes; // the hazard exists if 1 and 2 are present to avoid searching.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp:72,mask,mask,72,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,1,['mask'],['mask']
Availability,// The hi masked load has zero storage size. We therefore simply set it to; // the low masked load and rely on subsequent removal from the chain.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:10,mask,masked,10,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,2,['mask'],['masked']
Availability,// The hi masked store has zero storage size.; // Only the lo masked store is needed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:10,mask,masked,10,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,2,['mask'],['masked']
Availability,"// The idea here is the same as in the 32-bit version, but with additional; // complications from the fact that Repl32 might be true. Because we; // aggressively convert bit groups to Repl32 form (which, for small; // rotation factors, involves no other change), and then coalesce, it might; // be the case that a single 64-bit masking operation could handle both; // some Repl32 groups and some non-Repl32 groups. If converting to Repl32; // form allowed coalescing, then we must use a 32-bit rotaton in order to; // completely capture the new combined bit group.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:328,mask,masking,328,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['mask'],['masking']
Availability,"// The idea here is to check whether this is equivalent to:; // (c1 & m) | (x & ~m); // where m is a run-of-ones mask. The logic here is that, for each bit in; // c1 and c2:; // - if both are 1, then the output will be 1.; // - if both are 0, then the output will be 0.; // - if the bit in c1 is 0, and the bit in c2 is 1, then the output will; // come from x.; // - if the bit in c1 is 1, and the bit in c2 is 0, then the output will; // be 0.; // If that last condition is never the case, then we can form m from the; // bits that are the same between c1 and c2.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:113,mask,mask,113,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,"// The idea of the RooGenProdProj is that we divide two integral objects each; // created with this makeIntegral() function to get the normalized integral of; // a product. Therefore, we don't need to normalize the numerater and; // denominator integrals themselves. Doing the normalization would be; // expensive and it would cancel out anyway. However, if we don't specify an; // explicit normalization integral in createIntegral(), the last-used; // normalization set might be used to normalize the pdf, resulting in; // redundant computations.; //; // For this reason, the normalization set of the integrated pdfs is fixed to; // an empty set in this case. Note that in RooFit, a nullptr normalization; // set and an empty normalization set is not equivalent. The former implies; // taking the last-used normalization set, and the latter means explicitly no; // normalization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooGenProdProj.cxx:524,redundant,redundant,524,roofit/roofitcore/src/RooGenProdProj.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooGenProdProj.cxx,1,['redundant'],['redundant']
Availability,// The immediate encodes the type of constant as well as the value.; // Mask in that this is an i8 splat.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:72,Mask,Mask,72,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['Mask'],['Mask']
Availability,// The immediate is a mask of the low bits iff imm & (imm+1) == 0,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:22,mask,mask,22,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,2,['mask'],['mask']
Availability,// The immediate permute control byte looks like this:; // [3:0] - zero mask for each 32-bit lane; // [5:4] - select one 32-bit destination lane; // [7:6] - select one 32-bit source lane,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:72,mask,mask,72,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,1,['mask'],['mask']
Availability,// The inMips16Mode() test is not permanent.; // Some instructions are marked as pseudo right now which; // would make the test fail for the wrong reason but; // that will be fixed soon. We need this here because we are; // removing another test for this situation downstream in the; // callchain.; //,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:265,down,downstream,265,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,1,['down'],['downstream']
Availability,"// The index of an EXT is the first element if it is not UNDEF.; // Watch out for the beginning UNDEFs. The EXT index should be the expected; // value of the first element. E.g.; // <-1, -1, 3, ...> is treated as <1, 2, 3, ...>.; // <-1, -1, 0, 1, ...> is treated as <2*NumElts-2, 2*NumElts-1, 0, 1, ...>.; // ExpectedElt is the last mask index plus 1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:334,mask,mask,334,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,2,['mask'],['mask']
Availability,// The indices of the commutable operands are 1 and 2 (or 2 and 3; // when masked).; // Assign them to the returned operand indices here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:75,mask,masked,75,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['mask'],['masked']
Availability,"// The initialization would have succeeded with this fixit. Since the fixit; // is on the error, we need to build a valid AST in this case, so this isn't; // handled in the Failed() branch above.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:90,error,error,90,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['error'],['error']
Availability,"// The input vector is used as the shuffle mask that index elements into the; // LUT. After counting low and high nibbles, add the vector to obtain the; // final pop count per i8 element.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:43,mask,mask,43,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// The input vector this mask element indexes into.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:25,mask,mask,25,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,2,['mask'],['mask']
Availability,"// The instance typically gets created by some Job. Once all Jobs are gone, the; // JM will get destroyed. In this case, the job_objects map should have; // been emptied.; // The second case is when the program ends, at which time the static instance; // is destroyed. Jobs may still be present, for instance, the Job subclass; // RooFit::TestStatistics::LikelihoodGradientJob, will have; // been put into RooMinimizer::_theFitter->fObjFunction, as the gradient; // member. Because _theFitter is also a global static member, we cannot; // guarantee destruction order, and so the JobManager may be destroyed before; // all Jobs are destroyed. We cannot therefore make sure that the first; // condition is met. However, the Job objects stuck in _theFitter are not; // meant to be run again, because the program is ending anyway. So also in this; // case, we can safely shut down.; // There used to be an assert statement that checked whether the job_objects; // map was empty at destruction time, but that neglected the second possibility; // and led to assertion failures, which left the Messenger and ProcessManager; // objects intact, leading to the forked processes and their ZeroMQ resources; // to remain after exiting the main/master/parent process.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/JobManager.cxx:872,down,down,872,roofit/multiprocess/src/JobManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/JobManager.cxx,2,"['down', 'failure']","['down', 'failures']"
Availability,// The instruction encoding is not valid because one (and only one) parsed; // operand is not of the correct type. OperandError is the error code; // relating to the operand class expected by the encoding. OperandClass is; // the type of the expected operand. Opcode is the opcode of the encoding.; // OperandIndex is the index into the parsed operand list.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCTargetAsmParser.h:135,error,error,135,interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCTargetAsmParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCTargetAsmParser.h,1,['error'],['error']
Availability,// The instruction encoding is not valid because the target-specific; // predicate function returned an error code. FailureCode is the; // target-specific error code returned by the predicate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCTargetAsmParser.h:104,error,error,104,interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCTargetAsmParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCTargetAsmParser.h,3,"['Failure', 'error']","['FailureCode', 'error']"
Availability,// The instruction has a register mask operand which means that it clobbers; // a large set of registers. Treat clobbered registers the same way as; // defined registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:34,mask,mask,34,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,1,['mask'],['mask']
Availability,"// The instruction referenced does not exist. This normally indicates an; // error in the program, where you try and validate a graph that was created; // in a different FileAnalysis object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h:77,error,error,77,interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h,1,['error'],['error']
Availability,"// The interfering node may no longer be available due to backtracking.; // Furthermore, it may have been made available again, in which case it is; // now already in the AvailableQueue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:41,avail,available,41,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,3,"['Avail', 'avail']","['AvailableQueue', 'available']"
Availability,"// The interleave cost is extract elements from sub vectors, and; // insert them into the wide vector.; //; // E.g. An interleaved store of factor 3 with 2 members at indices 0,1:; // (using VF=4):; // %v0_v1 = shuffle %v0, %v1, <0,4,undef,1,5,undef,2,6,undef,3,7,undef>; // %gaps.mask = <true, true, false, true, true, false,; // true, true, false, true, true, false>; // call llvm.masked.store <12 x i32> %v0_v1, <12 x i32>* %ptr,; // i32 Align, <12 x i1> %gaps.mask; // The cost is estimated as extract all elements (of actual members,; // excluding gaps) from both <4 x i32> vectors and insert into the <12 x; // i32> vector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:281,mask,mask,281,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,3,['mask'],"['mask', 'masked']"
Availability,"// The irsymtab::build function may be unable to create a symbol table if the; // module is malformed (e.g. it contains an invalid alias). Writing a symbol; // table is not required for correctness, but we still want to be able to; // write malformed modules to bitcode files, so swallow the error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:292,error,error,292,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,1,['error'],['error']
Availability,// The isScheduleHigh flag allows nodes with wraparound dependencies that; // cannot easily be modeled as edges with latencies to be scheduled as; // soon as possible in a top-down schedule.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:176,down,down,176,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,2,['down'],['down']
Availability,// The item is a mask type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OSLog.h:17,mask,mask,17,interpreter/llvm-project/clang/include/clang/AST/OSLog.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OSLog.h,1,['mask'],['mask']
Availability,// The iteration count is required to recover location values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:38,recover,recover,38,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,1,['recover'],['recover']
Availability,"// The kept copy is eligible for auto-hiding (hidden visibility) if all; // copies were (i.e. they were all linkonce_odr global unnamed addr).; // If any copy is not (e.g. it was originally weak_odr), then the symbol; // must remain externally available (e.g. a weak_odr from an explicitly; // instantiated template). Additionally, if it is in the; // GUIDPreservedSymbols set, that means that it is visibile outside; // the summary (e.g. in a native object or a bitcode file without; // summary), and in that case we cannot hide it as it isn't possible to; // check all copies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:244,avail,available,244,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,1,['avail'],['available']
Availability,// The lane mask is simply the union of all sub-indices.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp:12,mask,mask,12,interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp,1,['mask'],['mask']
Availability,// The last operand of a masked instruction may be glued.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:25,mask,masked,25,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,1,['mask'],['masked']
Availability,"// The left edge of space available for drawing",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlTable.cxx:26,avail,available,26,gui/guihtml/src/TGHtmlTable.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlTable.cxx,1,['avail'],['available']
Availability,"// The legal cases are:; // VADDV u/s 8/16/32; // VADDLV u/s 32; // Codegen currently cannot always handle larger than legal vectors very; // well, especially for predicated reductions where the mask needs to be; // split, so restrict to 128bit or smaller input types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:195,mask,mask,195,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,1,['mask'],['mask']
Availability,"// The legal cases are:; // VMLAV u/s 8/16/32; // VMLALV u/s 16/32; // Codegen currently cannot always handle larger than legal vectors very; // well, especially for predicated reductions where the mask needs to be; // split, so restrict to 128bit or smaller input types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:198,mask,mask,198,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,1,['mask'],['mask']
Availability,"// The list of available load sizes (in bytes), sorted in decreasing order.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:15,avail,available,15,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['avail'],['available']
Availability,"// The list of friends needs to be accessed via GetTree()->GetListOfFriends(); // (and not directly GetListOfFriends()), otherwise when `main` is a TChain we; // might not recover the list correctly (see #6993 for the TTreeReader issue; // and #6741 for a more complete discussion/explanation).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TFriendProxy.cxx:172,recover,recover,172,tree/treeplayer/src/TFriendProxy.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TFriendProxy.cxx,1,['recover'],['recover']
Availability,"// The list of friends needs to be accessed via GetTree()->GetListOfFriends(); // (and not via GetListOfFriends() directly), otherwise when `t` is a TChain we; // might not recover the list correctly (https://github.com/root-project/root/issues/6741).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx:173,recover,recover,173,tree/dataframe/src/RLoopManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx,1,['recover'],['recover']
Availability,"// The literal token may have come from an invalid source location (e.g. due; // to a PCH error), in which case the token length will be 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:90,error,error,90,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,1,['error'],['error']
Availability,"// The llvm.amdgcn.module.lds instance is implicitly used by all kernels; // that might call a function which accesses a field within it. This is; // presently approximated to 'all kernels' if there are any such functions; // in the module. This implicit use is redefined as an explicit use here so; // that later passes, specifically PromoteAlloca, account for the required; // memory without any knowledge of this transform.; // An operand bundle on llvm.donothing works because the call instruction; // survives until after the last pass that needs to account for LDS. It is; // better than inline asm as the latter survives until the end of codegen. A; // totally robust solution would be a function with the same semantics as; // llvm.donothing that takes a pointer to the instance and is lowered to a; // no-op after LDS is allocated, but that is not presently necessary.; // This intrinsic is eliminated shortly before instruction selection. It; // does not suffice to indicate to ISel that a given global which is not; // immediately used by the kernel must still be allocated by it. An; // equivalent target specific intrinsic which lasts until immediately after; // codegen would suffice for that, but one would still need to ensure that; // the variables are allocated in the anticpated order.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp:668,robust,robust,668,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,1,['robust'],['robust']
Availability,"// The location context of the init method called on the leaked object, if; // available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp:79,avail,available,79,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp,1,['avail'],['available']
Availability,// The location has a recovery expression.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:22,recover,recovery,22,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,1,['recover'],['recovery']
Availability,// The loop above returns nullptr on Error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Demangle/MicrosoftDemangle.cpp:37,Error,Error,37,interpreter/llvm-project/llvm/lib/Demangle/MicrosoftDemangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Demangle/MicrosoftDemangle.cpp,1,['Error'],['Error']
Availability,"// The low bits of the (potentially translated) extracted element map to; // the source vector. The high bits map to zero. We will use a zero vector; // as the 2nd source operand of the shuffle, so use the 1st element of; // that vector (mask value is number-of-elements) for the high bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:238,mask,mask,238,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['mask']
Availability,"// The low-order byte of __offset_flags contains flags, as given by the; // masks from the enumeration __offset_flags_masks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp:76,mask,masks,76,interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,1,['mask'],['masks']
Availability,"// The macros below use ::Error, so let's ensure it is included",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:26,Error,Error,26,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['Error'],['Error']
Availability,"// The main ""exit"" point from the token parsing to preprocessor.; //; // The method is called for CurPtr, when prepIsDirective() returns; // true. The first parameter matches the result of prepIsDirective(),; // denoting the actual preprocessor directive to be processed.; //; // If the preprocessing directive disables the tokens processing, e.g.:; // #ifdef NAME // NAME is undefined; // then lexPreprocessor() enters the lines-skipping mode.; // In this mode, it does not parse any tokens, because the code under; // the #ifdef may not even be a correct tablegen code. The preprocessor; // looks for lines containing other preprocessing directives, which; // may be prepended with whitespaces and C-style comments. If the line; // does not contain a preprocessing directive, it is skipped completely.; // Otherwise, the preprocessing directive is processed by recursively; // calling lexPreprocessor(). The processing of the encountered; // preprocessing directives includes updating preprocessing control stack; // and adding new macros into DefinedMacros set.; //; // The second parameter controls whether lexPreprocessor() is called from; // LexToken() (true) or recursively from lexPreprocessor() (false).; //; // If ReturnNextLiveToken is true, the method returns the next; // LEX token following the current directive or following the end; // of the disabled preprocessing region corresponding to this directive.; // If ReturnNextLiveToken is false, the method returns the first parameter,; // unless there were errors encountered in the disabled preprocessing; // region - in this case, it returns tgtok::Error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGLexer.h:1521,error,errors,1521,interpreter/llvm-project/llvm/lib/TableGen/TGLexer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGLexer.h,2,"['Error', 'error']","['Error', 'errors']"
Availability,// The mapping of the registers may be available via the; // register class constraints.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp:39,avail,available,39,interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp,1,['avail'],['available']
Availability,// The mask 255 means that put the 32:63 bits of NewFPSCRReg to the 32:63; // bits of FPSCR.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:7,mask,mask,7,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['mask'],['mask']
Availability,"// The mask Value, if we're looking at a masked load/store.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation/AddressSanitizerCommon.h:7,mask,mask,7,interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation/AddressSanitizerCommon.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation/AddressSanitizerCommon.h,2,['mask'],"['mask', 'masked']"
Availability,// The mask constants are automatically splatted for vector types.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:7,mask,mask,7,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// The mask element does not index into any input vector.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:7,mask,mask,7,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,1,['mask'],['mask']
Availability,"// The mask element is ""undef"" or indexes off the end of the input.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:7,mask,mask,7,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,1,['mask'],['mask']
Availability,// The mask element. This indexes into the input.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:7,mask,mask,7,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,2,['mask'],['mask']
Availability,// The mask is a mask of the low bits iff imm & (imm+1) == 0.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:7,mask,mask,7,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,2,['mask'],['mask']
Availability,// The mask is constant or extended from a bool vector. Convert this x86; // intrinsic to the LLVM intrinsic to allow target-independent optimizations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:7,mask,mask,7,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,2,['mask'],['mask']
Availability,// The mask is owned and cleaned up by the Machine Function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp:7,mask,mask,7,interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp,1,['mask'],['mask']
Availability,"// The mask is present and the provenance of all the values is a smaller type,; // lets see if the mask is superfluous.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:7,mask,mask,7,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,2,['mask'],['mask']
Availability,// The mask itself may be truncated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:7,mask,mask,7,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,"// The mask may not be larger than the in-memory type, as it might cover sign; // extended bits",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:7,mask,mask,7,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,1,['mask'],['mask']
Availability,// The mask must be computed in a type twice as wide to ensure; // that no bits are lost if the sum-of-shifts is wider than the base type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:7,mask,mask,7,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,1,['mask'],['mask']
Availability,// The mask of CC values for which the original condition is true.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:7,mask,mask,7,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['mask'],['mask']
Availability,// The mask of CC values that Opcode can produce.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:7,mask,mask,7,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['mask'],['mask']
Availability,// The mask of the VSELECT should have integer elements.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:7,mask,mask,7,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,1,['mask'],['mask']
Availability,"// The mask operand contains the special register (R Bit) in bit 4, whether; // the register is spsr (R bit is 1) or one of cpsr/apsr (R bit is 0), and; // bits 3-0 contains the fields to be accessed in the special register, set by; // the flags provided with the register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp:7,mask,mask,7,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,// The mask should be widened as well,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:7,mask,mask,7,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,4,['mask'],['mask']
Availability,// The mask should be widened as well.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:7,mask,mask,7,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,2,['mask'],['mask']
Availability,"// The mask used for the transform is expected to be post-shift, but we; // found the shift first so just apply the shift to the mask before passing; // it down.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:7,mask,mask,7,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,3,"['down', 'mask']","['down', 'mask']"
Availability,// The mask value chooses which source operand we need to look at next.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:7,mask,mask,7,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['mask'],['mask']
Availability,"// The mask value may be a vector constant that has undefined elements. But it; // may not be safe to propagate those undefs into the new compare, so replace; // those elements by copying an existing, defined, and safe scalar constant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:7,mask,mask,7,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['mask'],['mask']
Availability,// The mask value needs to shift right 16 if we're emitting andis.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:7,mask,mask,7,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['mask'],['mask']
Availability,"// The mask variants have different operand list. Scan from the third; // operand to avoid emitting incorrect warning.; // VFMULCPHZrr Dest, Src1, Src2; // VFMULCPHZrrk Dest, Dest, Mask, Src1, Src2; // VFMULCPHZrrkz Dest, Mask, Src1, Src2",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp:7,mask,mask,7,interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,3,"['Mask', 'mask']","['Mask', 'mask']"
Availability,// The masked part of *this must have the same number of bits; // as the source.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp:7,mask,masked,7,interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp,1,['mask'],['masked']
Availability,"// The maximum distance from the stack pointer is at lower address of; // the object -- which is given by offset. For down growing stack; // the offset is negative, so we negate the offset to get the distance.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:118,down,down,118,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,2,['down'],['down']
Availability,"// The memory for Mask is owned by the SelectionDAG's OperandAllocator, and; // is freed when the SelectionDAG object is destroyed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:18,Mask,Mask,18,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,1,['Mask'],['Mask']
Availability,"// The merge result of a non-PIC object and a PIC object can only be reliably; // used as a non-PIC object, so use the Min merge behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Module.cpp:69,reliab,reliably,69,interpreter/llvm-project/llvm/lib/IR/Module.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Module.cpp,1,['reliab'],['reliably']
Availability,"// The methods getAsArchive, getAsObjectFile, getAsIRObject of the class; // ObjectForArch return an Error in case of the type mismatch. We need to; // check each in turn to see what kind of slice this is, so ignore errors; // produced along the way.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObjcopy.cpp:101,Error,Error,101,interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObjcopy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObjcopy.cpp,2,"['Error', 'error']","['Error', 'errors']"
Availability,"// The mkdir failed __and__ we can not write to the target directory,; // let make sure the error message will be about the target directory",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx:92,error,error,92,core/base/src/TSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx,1,['error'],['error']
Availability,// The model can only accept a specified number of opcodes and will error it if; // fed an opcode it hasn't seen before. This constant sets the current cutoff.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:68,error,error,68,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,1,['error'],['error']
Availability,// The model learns to pick one of the mask == 1 interferences. This is the; // name of the output tensor. The contract with the model is that the output; // will be guaranteed to be to a mask == 1 position. Using a macro here to; // avoid 'not used' warnings (and keep cond compilation to a minimum),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:39,mask,mask,39,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,2,['mask'],['mask']
Availability,// The modifier is 'u' but the operand is not an LASX register; Report an; // unknown operand error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchAsmPrinter.cpp:94,error,error,94,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchAsmPrinter.cpp,1,['error'],['error']
Availability,// The modifier is 'w' but the operand is not an LSX register; Report an; // unknown operand error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchAsmPrinter.cpp:93,error,error,93,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchAsmPrinter.cpp,1,['error'],['error']
Availability,"// The modifyPassConfig callback gives us a chance to inspect the; // MaterializationResponsibility and target triple for the object being; // linked, then add any JITLink passes that we would like to run on the; // link graph. A pass is just a function object that is callable as; // Error(jitlink::LinkGraph&). In this case we will add two passes; // defined as lambdas that call the printLinkerGraph method on our; // plugin: One to run before the linker applies fixups and another to; // run afterwards.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithObjectLinkingLayerPlugin/LLJITWithObjectLinkingLayerPlugin.cpp:285,Error,Error,285,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithObjectLinkingLayerPlugin/LLJITWithObjectLinkingLayerPlugin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithObjectLinkingLayerPlugin/LLJITWithObjectLinkingLayerPlugin.cpp,1,['Error'],['Error']
Availability,"// The module is available unless it's missing a requirement; relevant; // requirements will be (re-)added by SUBMODULE_REQUIRES records.; // Missing headers that were present when the module was built do not; // make it unavailable -- if we got this far, this must be an explicitly; // imported module file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:17,avail,available,17,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['avail'],['available']
Availability,// The most likely error is that the ';' was forgotten.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:19,error,error,19,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['error'],['error']
Availability,// The most nested region for each start location is the one with the; // correct count. We avoid creating redundant regions by stopping once; // we've seen this region.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CoverageMappingGen.cpp:107,redundant,redundant,107,interpreter/llvm-project/clang/lib/CodeGen/CoverageMappingGen.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CoverageMappingGen.cpp,1,['redundant'],['redundant']
Availability,"// The most reliable way to print unicode in a Windows console is with; // WriteConsoleW. To use that, first transcode from UTF-8 to UTF-16. This; // assumes that LLVM programs always print valid UTF-8 to the console. The data; // might not be UTF-8 for two major reasons:; // 1. The program is printing binary (-filetype=obj -o -), in which case it; // would have been gibberish anyway.; // 2. The program is printing text in a semi-ascii compatible codepage like; // shift-jis or cp1252.; //; // Most LLVM programs don't produce non-ascii text unless they are quoting; // user source input. A well-behaved LLVM program should either validate that; // the input is UTF-8 or transcode from the local codepage to UTF-8 before; // quoting it. If they don't, this may mess up the encoding, but this is still; // probably the best compromise we can make.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/raw_ostream.cpp:12,reliab,reliable,12,interpreter/llvm-project/llvm/lib/Support/raw_ostream.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/raw_ostream.cpp,1,['reliab'],['reliable']
Availability,"// The name already exists, but is not a function or has the wrong; // prototype. Make place for the new one by renaming the old version.; // Either this old version will be removed later on or the module is; // invalid and we'll get an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Function.cpp:237,error,error,237,interpreter/llvm-project/llvm/lib/IR/Function.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Function.cpp,1,['error'],['error']
Availability,"// The negated frame size is in ScratchReg, and the SPReg has been; // decremented by the frame size: SPReg = old SPReg + ScratchReg.; // Since FPOffset, PBPOffset, etc. are relative to the beginning of; // the stack frame (i.e. the old SP), ideally, we would put the old; // SP into a register and use it as the base for the stores. The; // problem is that the only available register may be ScratchReg,; // which could be R0, and R0 cannot be used as a base address.; // First, set ScratchReg to the old SP. This may need to be modified; // later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:367,avail,available,367,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,1,['avail'],['available']
Availability,// The new masked load has an undef pass-through operand. The select uses the; // original pass-through operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:11,mask,masked,11,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['masked']
Availability,// The new type requires more storage; make it available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp:47,avail,available,47,interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,1,['avail'],['available']
Availability,"// The next (second or third) argument can be a std::align_val_t, which; // is an enum whose underlying type is std::size_t.; // FIXME: Use the right type as the parameter type. Note that in a call; // to operator delete(size_t, ...), we may not have it available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprCXX.cpp:254,avail,available,254,interpreter/llvm-project/clang/lib/CodeGen/CGExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprCXX.cpp,1,['avail'],['available']
Availability,"// The next available unique sourcelocation offset. Skip the system sloc 0; // and any offset that may actually exist in the virtual file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalParser.h:12,avail,available,12,interpreter/cling/lib/Interpreter/IncrementalParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalParser.h,1,['avail'],['available']
Availability,"// The next error refers specifically to the situation where the branch identified by fBranchName; // is not present and that is not expected. An example is when traversing a chain of files, the branch; // is missing from the file that we are switching into.; // Conversely, there are situations where the missing branch is indeed expected. A notable example is when; // the TTree contains a split object, the branch referring to the whole object type will actually be elided; // and will not be found by `TTree::GetBranch`, only the data members will be present as sub branches.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TBranchProxy.cxx:12,error,error,12,tree/treeplayer/src/TBranchProxy.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TBranchProxy.cxx,1,['error'],['error']
Availability,"// The next line triggered an error due to a previous faulty implementation; // that was not connecting the cloned varied action to the correct upstream; // varied filters. In particular, this lambda should be run after the `Filter`; // above, which checks that the number of jets that passes the `jet_pt_mask`; // is at least 4.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cloning.cxx:30,error,error,30,tree/dataframe/test/dataframe_cloning.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cloning.cxx,2,"['error', 'fault']","['error', 'faulty']"
Availability,"// The next parameter should have the same adjustment as the; // last thing we pushed, but we post-incremented indexAdjustment; // on every push. Also, if we push nothing, the adjustment should; // go down by one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:201,down,down,201,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['down'],['down']
Availability,// The non-fatal error node should be the same for all reports.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ExprInspectionChecker.cpp:17,error,error,17,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ExprInspectionChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ExprInspectionChecker.cpp,1,['error'],['error']
Availability,// The number of bits available are the min of the pointer types minus the; // bits needed for the discriminator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h:22,avail,available,22,interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h,1,['avail'],['available']
Availability,"// The number of bits in a SVE register is architecturally defined; // to be a multiple of this value. If <M x t> has this number of bits,; // a <n x M x t> vector can be stored in a SVE register without any; // redundant bits. If <M x t> has this number of bits divided by P,; // a <n x M x t> vector is stored in a SVE register by placing index i; // in index i*P of a <n x (M*P) x t> vector. The other elements of the; // <n x (M*P) x t> vector (such as index 1) are undefined.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/Utils/AArch64BaseInfo.h:212,redundant,redundant,212,interpreter/llvm-project/llvm/lib/Target/AArch64/Utils/AArch64BaseInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/Utils/AArch64BaseInfo.h,1,['redundant'],['redundant']
Availability,// The number of bits in the fixup mask,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRAsmBackend.cpp:35,mask,mask,35,interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRAsmBackend.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRAsmBackend.cpp,1,['mask'],['mask']
Availability,// The number of bits in the result bitfield will be the number of; // trailing zeros plus the number of set bits in the mask minus the; // number of bits we shift off,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:121,mask,mask,121,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,"// The number of elements can be have an arbitrary integer type;; // essentially, we need to multiply it by a constant factor, add a; // cookie size, and verify that the result is representable as a; // size_t. That's just a gloss, though, and it's wrong in one; // important way: if the count is negative, it's an error even if; // the cookie size would bring the total size >= 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprCXX.cpp:315,error,error,315,interpreter/llvm-project/clang/lib/CodeGen/CGExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprCXX.cpp,1,['error'],['error']
Availability,// The number of elements in the mask must be at least 2.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:33,mask,mask,33,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,1,['mask'],['mask']
Availability,"// The number of outstanding events for this type, T, can be calculated; // as (UB - LB). If the current Count is greater than or equal to the number; // of outstanding events, then the wait for this counter is redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp:211,redundant,redundant,211,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,1,['redundant'],['redundant']
Availability,// The number of possible 1s in the mask determines the number of LSBs of; // operand 0 used. Undemanded bits from the mask don't matter so filter; // them before counting.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:36,mask,mask,36,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['mask'],['mask']
Availability,// The number of times we didn't find an entry for a block in a map and; // optimistically inserted an entry marking block as speculatively available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:140,avail,available,140,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['avail'],['available']
Availability,"// The old ""Root.ZipMode"" had a discrepancy between documentation vs actual meaning.; // Also, a value with the meaning ""default"" wasn't available. To solved this,; // ""Root.ZipMode"" was replaced by ""Root.CompressionAlgorithm"". Warn about usage of; // the old value, if it's set to 0, but silently translate the setting to; // ""Root.CompressionAlgorithm"" for values > 1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:137,avail,available,137,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,1,['avail'],['available']
Availability,// The old masking instruction must go away.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:11,mask,masking,11,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,1,['mask'],['masking']
Availability,"// The only comments we decode are shuffles, so give up if we were unable to; // decode a shuffle mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86InstComments.cpp:98,mask,mask,98,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86InstComments.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86InstComments.cpp,1,['mask'],['mask']
Availability,"// The only loops we can vectorize without a scalar epilogue, are loops with; // a bottom-test and a single exiting block. We'd have to handle the fact; // that not every instruction executes on the last iteration. This will; // require a lane mask which varies through the vector loop body. (TODO)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:244,mask,mask,244,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['mask'],['mask']
Availability,"// The only other kind of parameter we support is type parameters, which; // must precede the integer parameters. This is therefore an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:135,error,error,135,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,1,['error'],['error']
Availability,"// The only parse failure in this case should be if the end was reached.; // In that case, throw away the error, as the main Cursor's error will; // be sufficient.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFDebugLine.cpp:18,failure,failure,18,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFDebugLine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFDebugLine.cpp,3,"['error', 'failure']","['error', 'failure']"
Availability,"// The only possibility for an illegal operand is the mask, since result type; // legalization would have handled this node already otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:54,mask,mask,54,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,1,['mask'],['mask']
Availability,// The only way that there can be a non-zero range available is if; // the instruction using ED will be converted to an indexed memory; // instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:51,avail,available,51,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,1,['avail'],['available']
Availability,// The opcode mask selects between the two opcodes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:14,mask,mask,14,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,2,['mask'],['mask']
Availability,// The operand to BFI is already a mask suitable for removing the bits it; // sets.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:35,mask,mask,35,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['mask'],['mask']
Availability,// The operand with index = 1 is used as a source for those elements for; // which the corresponding bit in the k-mask is set to 0.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:114,mask,mask,114,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['mask'],['mask']
Availability,"// The operands for FMA3 instructions without rounding fall into two forms:; // dest, src1, src2, src3; // dest, src1, mask, src2, src3; // Where src3 is either a register or 5 memory address operands. So to find; // dest and src1 we can index from the front. To find src2 and src3 we can; // index from the end by taking into account memory vs register form when; // finding src2.; // The operands for FMA4 instructions:; // dest, src1, src2, src3; // Where src2 OR src3 are either a register or 5 memory address operands. So; // to find dest and src1 we can index from the front, src2 (reg/mem) follows; // and then src3 (reg) will be at the end.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86InstComments.cpp:119,mask,mask,119,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86InstComments.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86InstComments.cpp,1,['mask'],['mask']
Availability,// The optimized Reg is not alive through Flow blocks anymore.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeVGPRLiveRange.cpp:28,alive,alive,28,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeVGPRLiveRange.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeVGPRLiveRange.cpp,1,['alive'],['alive']
Availability,"// The order the tests is not entirely arbitrary. There is one conversion; // that can be handled in two different ways. Given:; // struct A {};; // struct B : public A {; // B(); B(const A&);; // };; // const A &a = B();; // the cast static_cast<const B&>(a) could be seen as either a static; // reference downcast, or an explicit invocation of the user-defined; // conversion using B's conversion constructor.; // DR 427 specifies that the downcast is to be applied here.; // C++ 5.2.9p4: Any expression can be explicitly converted to type ""cv void"".; // Done outside this function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:307,down,downcast,307,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,2,['down'],['downcast']
Availability,"// The original ""masking"" instruction must not have been`ashr`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:17,mask,masking,17,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,1,['mask'],['masking']
Availability,// The original input. Not modified during parsing; only for reference in; // error reporting.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp:78,error,error,78,interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Parsing.cpp,1,['error'],['error']
Availability,// The other arithmetic ops need to be masked into place.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:39,mask,masked,39,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,1,['mask'],['masked']
Availability,"// The outer latch has more than one predecessors, i.e., the inner; // exit and the inner header.; // PHI nodes in the inner latch are lcssa phis where the incoming values; // are defined further inside the loopnest. Check if those phis are used; // in the original inner latch. If that is the case then bail out since; // those incoming values may not be available at the new outer latch.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:356,avail,available,356,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,1,['avail'],['available']
Availability,"// The output array branch `bname` has dynamic size stored in leaf `sizeLeafName`, but that leaf has not been; // added to the output tree yet. However, the size leaf has to be available for the creation of the array; // branch to be successful. So we create the size leaf here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx:177,avail,available,177,tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,1,['avail'],['available']
Availability,"// The pack halfword instruction works better for masks that fit it,; // so use that when it's available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:50,mask,masks,50,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,4,"['avail', 'mask']","['available', 'masks']"
Availability,"// The pass may have restructured the call graph and refined the; // current SCC and/or RefSCC. We need to update our current SCC and; // RefSCC pointers to follow these. Also, when the current SCC is; // refined, re-run the SCC pass over the newly refined SCC in order; // to observe the most precise SCC model available. This inherently; // cannot cycle excessively as it only happens when we split SCCs; // apart, at most converging on a DAG of single nodes.; // FIXME: If we ever start having RefSCC passes, we'll want to; // iterate there too.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:312,avail,available,312,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,1,['avail'],['available']
Availability,// The pass-through vector for an x86 masked load is a zero vector.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:38,mask,masked,38,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,1,['mask'],['masked']
Availability,// The pattern was found. Create a masked compare that replaces all of the; // shift and logic ops.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:35,mask,masked,35,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,1,['mask'],['masked']
Availability,// The preceding values are available since PGO_HASH_V2.; // Keep this last. It's for the static assert that follows.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenPGO.cpp:28,avail,available,28,interpreter/llvm-project/clang/lib/CodeGen/CodeGenPGO.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenPGO.cpp,1,['avail'],['available']
Availability,// The preceding values are available with PGO_HASH_V1.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenPGO.cpp:28,avail,available,28,interpreter/llvm-project/clang/lib/CodeGen/CodeGenPGO.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenPGO.cpp,1,['avail'],['available']
Availability,"// The predicate register is not defined in the last few instructions.; // Check if the conversion to MUX is possible (either ""up"", i.e. at the; // place of the earlier partial definition, or ""down"", where the later; // definition is located). Examine all defs and uses between these two; // definitions.; // SR1, SR2 - source registers from the first and the second definition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenMux.cpp:193,down,down,193,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenMux.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenMux.cpp,1,['down'],['down']
Availability,// The presence of a null character is likely an error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:49,error,error,49,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['error'],['error']
Availability,"// The pressure differences are computed bottom-up, so the comparison for; // an increase is positive in the bottom direction, but negative in the; // top-down direction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:155,down,down,155,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,1,['down'],['down']
Availability,"// The previous implementation allowed a '.' in the exponent.; // That information was ignored (by sscanf), we now make it an error; // hasDot = kFALSE;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:126,error,error,126,hist/hist/src/TFormula_v5.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx,1,['error'],['error']
Availability,// The primary scratch register is available for holding the TLS offset.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:35,avail,available,35,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,1,['avail'],['available']
Availability,// The prior checkSize call may have failed. This isn't a hard error; // because we were just trying to sniff out bigobj.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/COFFObjectFile.cpp:63,error,error,63,interpreter/llvm-project/llvm/lib/Object/COFFObjectFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/COFFObjectFile.cpp,1,['error'],['error']
Availability,"// The priority is directly proportional to how restricted the insn is based; // on its flexibility to run on the available slots. So, the fewer slots it; // may run on, the higher its priority.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:114,avail,available,114,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,1,['avail'],['available']
Availability,// The processing of the data loaded by the aligned loads; // needs to be inserted after the data is available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:101,avail,available,101,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,1,['avail'],['available']
Availability,"// The profile summary metadata may be attached either by the frontend or by; // any backend passes (IR level instrumentation, for example). This method; // checks if the Summary is null and if so checks if the summary metadata is now; // available in the module and parses it to get the Summary object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ProfileSummaryInfo.cpp:239,avail,available,239,interpreter/llvm-project/llvm/lib/Analysis/ProfileSummaryInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ProfileSummaryInfo.cpp,1,['avail'],['available']
Availability,// The proof that shiftAmt LSBs are zero for at least one summand is only; // possible for the constant number.; //; // If this can be proven add shiftAmt to the error counter; // `ErrorMSBs`. Otherwise set all bits as undefined.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:162,error,error,162,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,2,"['Error', 'error']","['ErrorMSBs', 'error']"
Availability,"// The properties are stated in ""positive"" form; i.e. a pass could require; // that the property hold, but not that it does not hold.; // Property descriptions:; // IsSSA: True when the machine function is in SSA form and virtual registers; // have a single def.; // NoPHIs: The machine function does not contain any PHI instruction.; // TracksLiveness: True when tracking register liveness accurately.; // While this property is set, register liveness information in basic block; // live-in lists and machine instruction operands (e.g. implicit defs) is; // accurate, kill flags are conservatively accurate (kill flag correctly; // indicates the last use of a register, an operand without kill flag may or; // may not be the last use of a register). This means it can be used to; // change the code in ways that affect the values in registers, for example; // by the register scavenger.; // When this property is cleared at a very late time, liveness is no longer; // reliable.; // NoVRegs: The machine function does not use any virtual registers.; // Legalized: In GlobalISel: the MachineLegalizer ran and all pre-isel generic; // instructions have been legalized; i.e., all instructions are now one of:; // - generic and always legal (e.g., COPY); // - target-specific; // - legal pre-isel generic instructions.; // RegBankSelected: In GlobalISel: the RegBankSelect pass ran and all generic; // virtual registers have been assigned to a register bank.; // Selected: In GlobalISel: the InstructionSelect pass ran and all pre-isel; // generic instructions have been eliminated; i.e., all instructions are now; // target-specific or non-pre-isel generic instructions (e.g., COPY).; // Since only pre-isel generic instructions can have generic virtual register; // operands, this also means that all generic virtual registers have been; // constrained to virtual registers (assigned to register classes) and that; // all sizes attached to them have been eliminated.; // TiedOpsRewritten: The twoaddress",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:969,reliab,reliable,969,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,1,['reliab'],['reliable']
Availability,// The property has no setter and no getter! This can happen if the type is; // invalid. Error have already been reported.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp:89,Error,Error,89,interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,1,['Error'],['Error']
Availability,"// The purpose of this class is to provide a common facility to traverse; // the function top-down or bottom-up via the dominator tree, and keep; // track of the available registers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:94,down,down,94,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,2,"['avail', 'down']","['available', 'down']"
Availability,"// The range casts are not used in this file, but if you want to work with; // RooFit collections you also want to have static_range_cast and; // dynamic_range_cast available without including RangeCast.h every time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsCollection.h:165,avail,available,165,roofit/roofitcore/inc/RooAbsCollection.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsCollection.h,1,['avail'],['available']
Availability,// The reallocated symbol should stay alive for as long as the new symbol.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:38,alive,alive,38,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,1,['alive'],['alive']
Availability,"// The register which is not null checked should be part of the Displacement; // calculation, otherwise we do not know whether the Displacement is made up; // by some symbolic values.; // This matters because we do not want to incorrectly assume that load from; // falls in the zeroth faulting page in the ""sane offset check"" below.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:285,fault,faulting,285,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,1,['fault'],['faulting']
Availability,"// The registerModuleReference() condition effectively skips; // over fully resolved skeleton units. This second pass of; // registerModuleReferences doesn't do any new work, but it; // will collect top-level errors, which are suppressed. Module; // warnings were already displayed in the first iteration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp:209,error,errors,209,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp,1,['error'],['errors']
Availability,"// The regular method converting a 64-bit integer to float roughly consists of; // 2 steps: normalization and rounding. In fact, after normalization, the; // conversion from a 64-bit integer to a float is essentially the same as the; // one from a 32-bit integer. The only difference is that it has more; // trailing bits to be rounded. To leverage the native 32-bit conversion, a; // 64-bit integer could be preprocessed and fit into a 32-bit integer then; // converted into the correct float number. The basic steps for the unsigned; // conversion are illustrated in the following pseudo code:; //; // f32 uitofp(i64 u) {; // i32 hi, lo = split(u);; // // Only count the leading zeros in hi as we have native support of the; // // conversion from i32 to f32. If hi is all 0s, the conversion is; // // reduced to a 32-bit one automatically.; // i32 shamt = clz(hi); // Return 32 if hi is all 0s.; // u <<= shamt;; // hi, lo = split(u);; // hi |= (lo != 0) ? 1 : 0; // Adjust rounding bit in hi based on lo.; // // convert it as a 32-bit integer and scale the result back.; // return uitofp(hi) * 2^(32 - shamt);; // }; //; // The signed one follows the same principle but uses 'ffbh_i32' to count its; // sign bits instead. If 'ffbh_i32' is not available, its absolute value is; // converted instead followed by negation based its sign bit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp:1246,avail,available,1246,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,1,['avail'],['available']
Availability,"// The remaining cases are:; // External GOT: lw $tmp, %got(symbol)($gp); // >addiu $tmp, $tmp, offset; // >addiu $rd, $tmp, $rs; // Local GOT: lw $tmp, %got(symbol+offset)($gp); // addiu $tmp, $tmp, %lo(symbol+offset)($gp); // >addiu $rd, $tmp, $rs; // The addiu's marked with a '>' may be omitted if they are redundant. If; // this happens then the last instruction must use $rd as the result; // register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:311,redundant,redundant,311,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,1,['redundant'],['redundant']
Availability,"// The remaining cases are:; // Small offset: ld $tmp, %got_disp(symbol)($gp); // >daddiu $tmp, $tmp, offset; // >daddu $rd, $tmp, $rs; // The daddiu's marked with a '>' may be omitted if they are redundant. If; // this happens then the last instruction must use $rd as the result; // register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:197,redundant,redundant,197,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,1,['redundant'],['redundant']
Availability,// The remaining code needs Add to be available. Early returns if not so.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:38,avail,available,38,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['avail'],['available']
Availability,// The result has as many leading zeros as the number of zeroes in the mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:71,mask,mask,71,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// The result may not be usable in case of previous compilation errors.; // In this case evaluation of the expression may result in crash so just; // don't do anything further with the result.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:64,error,errors,64,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['error'],['errors']
Availability,// The result of VP reductions depends on the mask and evl.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp:46,mask,mask,46,interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,1,['mask'],['mask']
Availability,"// The result of V_ICMP/V_FCMP assembly instructions (which this; // intrinsic exposes) is one bit per thread, masked with the EXEC; // register (which contains the bitmask of live threads). So a; // comparison that always returns true is the same as a read of the; // EXEC register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstCombineIntrinsic.cpp:111,mask,masked,111,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstCombineIntrinsic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstCombineIntrinsic.cpp,1,['mask'],['masked']
Availability,"// The result of the bottom bits of an integer multiply can be; // inferred by looking at the bottom bits of both operands and; // multiplying them together.; // We can infer at least the minimum number of known trailing bits; // of both operands. Depending on number of trailing zeros, we can; // infer more bits, because (a*b) <=> ((a/m) * (b/n)) * (m*n) assuming; // a and b are divisible by m and n respectively.; // We then calculate how many of those bits are inferrable and set; // the output. For example, the i8 mul:; // a = XXXX1100 (12); // b = XXXX1110 (14); // We know the bottom 3 bits are zero since the first can be divided by; // 4 and the second by 2, thus having ((12/4) * (14/2)) * (2*4).; // Applying the multiplication to the trimmed arguments gets:; // XX11 (3); // X111 (7); // -------; // XX11; // XX11; // XX11; // XX11; // -------; // XXXXX01; // Which allows us to infer the 2 LSBs. Since we're multiplying the result; // by 8, the bottom 3 bits will be 0, so we can infer a total of 5 bits.; // The proof for this can be described as:; // Pre: (C1 >= 0) && (C1 < (1 << C5)) && (C2 >= 0) && (C2 < (1 << C6)) &&; // (C7 == (1 << (umin(countTrailingZeros(C1), C5) +; // umin(countTrailingZeros(C2), C6) +; // umin(C5 - umin(countTrailingZeros(C1), C5),; // C6 - umin(countTrailingZeros(C2), C6)))) - 1); // %aa = shl i8 %a, C5; // %bb = shl i8 %b, C6; // %aaa = or i8 %aa, C1; // %bbb = or i8 %bb, C2; // %mul = mul i8 %aaa, %bbb; // %mask = and i8 %mul, C7; // =>; // %mask = i8 ((C1*C2)&C7); // Where C5, C6 describe the known bits of %a, %b; // C1, C2 describe the known bottom bits of %a, %b.; // C7 describes the mask of the known bits of the result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/KnownBits.cpp:1461,mask,mask,1461,interpreter/llvm-project/llvm/lib/Support/KnownBits.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/KnownBits.cpp,3,['mask'],['mask']
Availability,// The result will have at least as many trailing zeros as the non-mask; // operand since bits can only map to the same or higher bit position.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:67,mask,mask,67,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['mask'],['mask']
Availability,"// The right formula for StdDev error depends on 4th momentum (see Kendall-Stuart Vol 1 pag 243); // formula valid for only gaussian distribution ( 4-th momentum = 3 * sigma^4 )",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:32,error,error,32,hist/hist/src/TH1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx,1,['error'],['error']
Availability,// The rotation mask for the second instruction must be MaskStart.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:16,mask,mask,16,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,4,"['Mask', 'mask']","['MaskStart', 'mask']"
Availability,"// The rotations don't match, so we can't match this mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:53,mask,mask,53,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,2,['mask'],['mask']
Availability,"// The scalarization cost should be a lot higher. We use the number of vector; // elements plus the scalarization overhead. If masking is required then a lot; // of little blocks will be needed and potentially a scalarized p0 mask,; // greatly increasing the cost.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:127,mask,masking,127,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,2,['mask'],"['mask', 'masking']"
Availability,"// The setcc produces an i8 of 0/1, so extend that to the result width and; // negate to get the final 0/-1 mask value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:108,mask,mask,108,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// The shared library does not exist: don't error unless the user; // explicitly passes --link-shared.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:44,error,error,44,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,1,['error'],['error']
Availability,"// The shift amount may be masked with negation:; // (shl ShVal, (X & (Width - 1))) | (lshr ShVal, ((-X) & (Width - 1)))",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:27,mask,masked,27,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['mask'],['masked']
Availability,"// The shift amount may be masked with negation:; // (shl ShVal0, (X & (Width - 1))) | (lshr ShVal1, ((-X) & (Width - 1)))",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:27,mask,masked,27,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,1,['mask'],['masked']
Availability,// The shift masks must have the same position and size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:13,mask,masks,13,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,1,['mask'],['masks']
Availability,"// The shuffle mask is poison except for 1 lane that is being translated; // to the new element index. Example for OldIndex == 2 and NewIndex == 0:; // ShufMask = { 2, poison, poison, poison }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:15,mask,mask,15,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,1,['mask'],['mask']
Availability,// The shuffle mask must be equal to (i * 2^N) % M.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:15,mask,mask,15,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,// The shuffle mask requires a byte vector.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ShuffleDecodeConstantPool.cpp:15,mask,mask,15,interpreter/llvm-project/llvm/lib/Target/X86/X86ShuffleDecodeConstantPool.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ShuffleDecodeConstantPool.cpp,2,['mask'],['mask']
Availability,// The shuffle mask requires elements the same size as the target.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ShuffleDecodeConstantPool.cpp:15,mask,mask,15,interpreter/llvm-project/llvm/lib/Target/X86/X86ShuffleDecodeConstantPool.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ShuffleDecodeConstantPool.cpp,2,['mask'],['mask']
Availability,"// The shuffle mask specifies which elements of the src1/src2 fill in the; // destination, with a few sentinel values. Loop through and print them; // out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86InstComments.cpp:15,mask,mask,15,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86InstComments.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86InstComments.cpp,1,['mask'],['mask']
Availability,// The shuffle may be more fine-grained than we want. Widen elements first.; // FIXME: should we do this before manifesting zeroable shuffle mask indices?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:141,mask,mask,141,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['mask']
Availability,// The signal will be thrown once the signal mask is restored.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp:45,mask,mask,45,interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp,1,['mask'],['mask']
Availability,"// The situation:; // RT = DefI; // ...; // RD = TfrI ..., RT; // If the register-in-the-middle (RT) is used or redefined between; // DefI and TfrI, we may not be able proceed with this transformation.; // We can ignore a def that will not execute together with TfrI, and a; // use that will. If there is such a use (that does execute together with; // TfrI), we will not be able to move DefI down. If there is a use that; // executed if TfrI's condition is false, then RT must be available; // unconditionally (cannot be predicated).; // Essentially, we need to be able to rename RT to RD in this segment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:393,down,down,393,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,2,"['avail', 'down']","['available', 'down']"
Availability,"// The size cost of duplication is the instruction size of the duplicated block.; // So we should scale the threshold accordingly. But the instruction size is not; // available on all targets, so we use the number of instructions instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:167,avail,available,167,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,1,['avail'],['available']
Availability,"// The size is not directly available for physical registers.; // Instead, we need to access a register class that contains Reg and; // get the size of that register class.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp:28,avail,available,28,interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp,1,['avail'],['available']
Availability,"// The size is not directly available for physical registers.; // Instead, we need to access a register class that contains Reg and; // get the size of that register class.; // Because this is expensive, we'll cache the register class by calling",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp:28,avail,available,28,interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp,1,['avail'],['available']
Availability,"// The size of a dbg.value's value operand should match the size of the; // variable it corresponds to.; //; // TODO: This, along with a check for non-null value operands, should be; // promoted to verifier failures.; // For now, don't try to interpret anything more complicated than an empty; // DIExpression. Eventually we should try to handle OP_deref and fragments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp:207,failure,failures,207,interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp,1,['failure'],['failures']
Availability,"// The slice colors need to be streamed becuse at EveElement contruction time, streamed caloData; // is not available. Maybe this is not necessary if EveElements have EveManager globaly available",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveCalo.cxx:108,avail,available,108,graf3d/eve7/src/REveCalo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveCalo.cxx,2,['avail'],['available']
Availability,// The smallest type we can slide is i8.; // TODO: We can extract index 0 from a mask vector without a slide.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:81,mask,mask,81,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['mask'],['mask']
Availability,"// The splat value may be something like ""0x00FFFFFF"", which means 0 for; // the first vector value and FF for the rest, repeating. We need a mask; // that will apply equally to all members of the vector, so AND all the; // lanes of the constant together.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:142,mask,mask,142,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['mask']
Availability,"// The stack size is MAX_DEPTH + 1 because we do lazy merging. For example,; // with 7 chunks, we have 3 entries in the stack. Adding an 8th chunk; // requires a 4th entry, rather than merging everything down to 1, because we; // don't know whether more input is coming. This is different from how the; // reference implementation does things.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/blake3.h:204,down,down,204,interpreter/llvm-project/llvm/include/llvm-c/blake3.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/blake3.h,1,['down'],['down']
Availability,// The standard behaviour in the backend for these cases is to split the; // extend up into two parts:; // 1. Perform an extending load or masked load up to the legal type.; // 2. Extend the loaded data to the final type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp:139,mask,masked,139,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,1,['mask'],['masked']
Availability,"// The stars all align, our next step is to produce the mask for the shuffle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:56,mask,mask,56,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,2,['mask'],['mask']
Availability,"// The state of RVV BUILD_VECTOR and VECTOR_SHUFFLE lowering is that very few; // of either is (currently) supported. This can get us into an infinite loop; // where we try to lower a BUILD_VECTOR as a VECTOR_SHUFFLE as a BUILD_VECTOR; // as a ..., etc.; // Until either (or both) of these can reliably lower any node, reporting that; // we don't want to expand BUILD_VECTORs via VECTOR_SHUFFLEs at least breaks; // the infinite loop. Note that this lowers BUILD_VECTOR through the stack,; // which is not desirable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:294,reliab,reliably,294,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['reliab'],['reliably']
Availability,"// The string table does not own strings added to it, some of which are; // owned by the modules; keep them alive until we write the string table.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cat/llvm-cat.cpp:108,alive,alive,108,interpreter/llvm-project/llvm/tools/llvm-cat/llvm-cat.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cat/llvm-cat.cpp,1,['alive'],['alive']
Availability,"// The substition can fail, in which case there would have been compilation; // error printed on the screen.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx:80,error,error,80,core/clingutils/src/TClingUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx,2,['error'],['error']
Availability,"// The symbol might be defined in the ROOT class AutoLoading map so we have to; // try to autoload it first and do secondary lookup to try to find it.; //; // returns true when a declaration is found and no error should be emitted.; // If FileEntry, this is a reacting on a #include and Name is the included; // filename.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx:207,error,error,207,core/metacling/src/TClingCallbacks.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx,1,['error'],['error']
Availability,"// The tag does not match; failure",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:27,failure,failure,27,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,1,['failure'],['failure']
Availability,"// The tag is not there or incomplete; failure",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:39,failure,failure,39,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,1,['failure'],['failure']
Availability,"// The tag name clashes with something else in the target scope,; // issue an error and recover by making this tag be anonymous.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:78,error,error,78,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,2,"['error', 'recover']","['error', 'recover']"
Availability,"// The tag name clashes with something else in the target scope,; // issue an error and recover by making this tag be anonymous.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclExtractor.cpp:78,error,error,78,interpreter/cling/lib/Interpreter/DeclExtractor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclExtractor.cpp,2,"['error', 'recover']","['error', 'recover']"
Availability,// The target provides a guard check function. There is no need to; // generate error handling code or to split current basic block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp:80,error,error,80,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,1,['error'],['error']
Availability,"// The target region is an outlined function launched by the runtime; // via calls to __tgt_target_kernel().; //; // Note that on the host and CPU targets, the runtime implementation of; // these calls simply call the outlined function without forking threads.; // The outlined functions themselves have runtime calls to; // __kmpc_fork_teams() and __kmpc_fork() for this purpose, codegen'd by; // the compiler in emitTeamsCall() and emitParallelCall().; //; // In contrast, on the NVPTX target, the implementation of; // __tgt_target_teams() launches a GPU kernel with the requested number; // of teams and threads so no additional calls to the runtime are required.; // Check the error code and execute the host version if required.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:682,error,error,682,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,1,['error'],['error']
Availability,// The target supports vector selects with a vector; // mask (ex: x86 blends).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:56,mask,mask,56,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['mask'],['mask']
Availability,// The template-name in the simple-template-id refers to; // something other than a type template. Give an appropriate; // error message and skip to the ';'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:123,error,error,123,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,1,['error'],['error']
Availability,// The tied operands have been eliminated or shifted further down; // the block to ease elimination. Continue processing with 'nmi'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:61,down,down,61,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,1,['down'],['down']
Availability,"// The tolerance below is high because matrix inversion leads to large errors.; // The comparisons below eventually fail with any value less than ~10000 ulps.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/test/testSMatrix.cxx:7,toler,tolerance,7,math/smatrix/test/testSMatrix.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/test/testSMatrix.cxx,8,"['error', 'toler']","['errors', 'tolerance']"
Availability,"// The tolerance parameter is necessary because not all backends give; // exaclty the same results: when using AD, the final result is slightly; // different.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooMinimizer.cxx:7,toler,tolerance,7,roofit/roofitcore/test/testRooMinimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooMinimizer.cxx,1,['toler'],['tolerance']
Availability,// The top of the worklist may *also* be the same SCC we just ran over; // (and invalidated for). Keep track of that last SCC we processed due; // to SCC update to avoid redundant processing when an SCC is both just; // updated itself and at the top of the worklist.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:170,redundant,redundant,170,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,1,['redundant'],['redundant']
Availability,// The total number of physical registers that are available in this; // register file for register renaming purpouses. A value of zero for this; // field means: this register file has an unbounded number of physical; // registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/RegisterFile.h:51,avail,available,51,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/RegisterFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/RegisterFile.h,1,['avail'],['available']
Availability,"// The tracked type should be the sub or super class of the static destination; // type. When an (implicit) upcast or a downcast happens according to static; // types, and there is no subtyping relationship between the tracked and the; // static destination types, it indicates an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:120,down,downcast,120,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,2,"['down', 'error']","['downcast', 'error']"
Availability,"// The transform_reduce algorithm requires that the initial value be copyable.; // Error objects are uncopyable. We only need to copy initial success values,; // so work around this mismatch via the C API. The C API represents success; // values with a null pointer. The joinErrors discards null values and joins; // multiple errors into an ErrorList.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Parallel.h:83,Error,Error,83,interpreter/llvm-project/llvm/include/llvm/Support/Parallel.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Parallel.h,3,"['Error', 'error']","['Error', 'ErrorList', 'errors']"
Availability,"// The transformation performed here aims to widen a widenable condition; // above the loop such that all analyzeable exit leading to deopt are dead.; // It assumes that the latch is the dominant exit for profitability and that; // exits branching to deoptimizing blocks are rarely taken. It relies on the; // semantics of widenable expressions for legality. (i.e. being able to fall; // down the widenable path spuriously allows us to ignore exit order,; // unanalyzeable exits, side effects, exceptional exits, and other challenges; // which restrict the applicability of the non-WC based version of this; // transform in IndVarSimplify.); //; // NOTE ON POISON/UNDEF - We're hoisting an expression above guards which may; // imply flags on the expression being hoisted and inserting new uses (flags; // are only correct for current uses). The result is that we may be; // inserting a branch on the value which can be either poison or undef. In; // this case, the branch can legally go either way; we just need to avoid; // introducing UB. This is achieved through the use of the freeze; // instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:388,down,down,388,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,1,['down'],['down']
Availability,"// The truncation error in the r4 approximation itself is O(h^3).; // However, for safety, we estimate the error from r4-r2, which is; // O(h). By scaling h we will minimise this estimated error, not; // the actual truncation error in r4.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/RichardsonDerivator.cxx:18,error,error,18,math/mathcore/src/RichardsonDerivator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/RichardsonDerivator.cxx,4,['error'],['error']
Availability,"// The type is not known to the interpreter, but we don't want to error out; // here, rather if/when this column is used in jitted code, so we inject a broken but telling type name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:66,error,error,66,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,1,['error'],['error']
Availability,"// The type is not known to the interpreter.; // We must not error out here, but if/when this column is used in jitted code",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:61,error,error,61,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,3,['error'],['error']
Availability,"// The type of this expr depends on a template parameter, or an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h:64,error,error,64,interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h,1,['error'],['error']
Availability,"// The types didn't match, but we know we got a null pointer; complain,; // then recover as if the types were correct.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:81,recover,recover,81,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['recover'],['recover']
Availability,// The updating instructions will need a mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:41,mask,mask,41,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,1,['mask'],['mask']
Availability,// The use of `@available` in the enclosing context should be analyzed to; // warn when it's used inappropriately (i.e. not if(@available)).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:16,avail,available,16,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,2,['avail'],['available']
Availability,"// The user explicitly passed -fno-rtti with -fsanitize=vptr, but; // the vptr sanitizer requires RTTI, so this is a user error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp:122,error,error,122,interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,1,['error'],['error']
Availability,"// The user wrote a constructor initializer on a function that is; // not a C++ constructor. Ignore the error for now, because we may; // have more member initializers coming; we'll diagnose it just; // once in ActOnMemInitializers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:104,error,error,104,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['error'],['error']
Availability,"// The value V returned from this function is used differently depending; // on whether MemInst is a load or a store. If it's a load, we will replace; // MemInst with V, if it's a store, we will check if V is the same as the; // available value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:229,avail,available,229,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,1,['avail'],['available']
Availability,"// The value and the mask need to be constants so we can verify this is; // actually a bitfield set. If the mask is 0xffff, we can do better; // via a movt instruction, so don't use BFI in that case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:21,mask,mask,21,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,2,['mask'],['mask']
Availability,"// The value is free of any CFG dependencies.; // Do as if it lives in the entry block.; //; // We do this to make sure all the values falling on this path are; // seen through the same anchor point. The rationale is these values; // can be combined together to from a sub expression free of any CFG; // dependencies so we want them to stay together.; // We could be cleverer and postpone the anchor down to the first; // anchored value, but that's likely complicated to get right.; // E.g., we wouldn't want to do that if that means being stuck in a; // loop.; //; // For instance, we wouldn't want to change:; // res = arg1 op arg2 op arg3 op ... op loop_val1 op loop_val2 ...; // into; // res = loop_val1 op arg1 op arg2 op arg3 op ... op loop_val2 ...; // Because all the sub expressions with arg2..N would be stuck between; // two loop dependent values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:400,down,down,400,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,1,['down'],['down']
Availability,"// The value of this expr depends on a template parameter, or an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h:65,error,error,65,interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h,1,['error'],['error']
Availability,"// The value to insert has all zeros already, so stick it into the masked; // wide element.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:67,mask,masked,67,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,1,['mask'],['masked']
Availability,"// The variable operand must be all zeros in the top bits to allow using the; // new, negative constant as the mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:111,mask,mask,111,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,"// The vctp will be removed, so either the entire block will be dead or; // the block mask of the vp(s)t will need to be recomputed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:86,mask,mask,86,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,1,['mask'],['mask']
Availability,// The vector mask is one bit per component and 4 components per vector.; // We can compute the number of dwords required by rounding up to the next; // multiple of 8.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/DXContainer.cpp:14,mask,mask,14,interpreter/llvm-project/llvm/lib/Object/DXContainer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/DXContainer.cpp,1,['mask'],['mask']
Availability,// The vector policy operand may be present for masked intrinsics,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:48,mask,masked,48,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,1,['mask'],['masked']
Availability,// The vector will save all the available registers for allocation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp:32,avail,available,32,interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallingConv.cpp,1,['avail'],['available']
Availability,"// The version number of the RooVectorDataStore::RealFullVector was increased; // in the 6.30 development cycle. The RealFullVector is used to store columns; // with errors, both symmetric and asymmetric.; //; // The reference file was created with the following code with ROOT 6.26.10:; //; // ```c++; // using namespace RooFit;; //; // RooRealVar x{""x"", ""x"", 0, 10};; // RooRealVar y{""y"", ""y"", 0, 10};; //; // RooDataSet data{""data"", ""data"", {x, y}, StoreError(x), StoreAsymError(y)};; //; // x.setVal(5.0);; // x.setError(2.0);; // y.setVal(9.0);; // y.setAsymError(-4.0, 3.0);; //; // data.add({x, y});; //; // x.setVal(7.0);; // x.setError(3.0);; // y.setVal(4.0);; // y.setAsymError(-2.0, 1.0);; //; // data.add({x, y});; //; // std::unique_ptr<TFile> file{TFile::Open(""dataSet_with_errors_6_26_10.root"", ""RECREATE"")};; //; // file->WriteObject(&data, data.GetName());; // ```",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooDataSet.cxx:166,error,errors,166,roofit/roofitcore/test/testRooDataSet.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooDataSet.cxx,1,['error'],['errors']
Availability,// The vmerge instruction must have an all 1s mask since we're going to keep; // the mask from the True instruction.; // FIXME: Support mask agnostic True instruction which would have an; // undef merge operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:46,mask,mask,46,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,3,['mask'],['mask']
Availability,// The width of the extracted field is the minimum of the original bits; // that remain after the shifts and the number of contiguous 1s in the mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenExtract.cpp:144,mask,mask,144,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenExtract.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenExtract.cpp,1,['mask'],['mask']
Availability,// The zero mask may override the previous insert operation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:12,mask,mask,12,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,1,['mask'],['mask']
Availability,// Then go ahead and use the builder do actually do the inserts. We insert; // immediately before the previous instruction under the assumption that all; // arguments will be available here. We can't insert afterwards since we may; // be replacing a terminator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:175,avail,available,175,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,1,['avail'],['available']
Availability,"// Then, the alive input bits are determined from the alive carry bits:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp:13,alive,alive,13,interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,2,['alive'],['alive']
Availability,"// There are DPMarkers there now -- they fell down from ""I"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp:46,down,down,46,interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp,1,['down'],['down']
Availability,"// There are a couple of different kinds of errors we could get here.; // First, we re-format the SMDiagnostic in terms of a clang diagnostic.; // Strip ""error: "" off the start of the message string.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenAction.cpp:44,error,errors,44,interpreter/llvm-project/clang/lib/CodeGen/CodeGenAction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenAction.cpp,2,['error'],"['error', 'errors']"
Availability,// There are five cases here.; // - There's no scope specifier and we're in a local class. Only look; // for functions declared in the immediately-enclosing block scope.; // We recover from invalid scope qualifiers as if they just weren't there.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:177,recover,recover,177,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['recover'],['recover']
Availability,"// There are multiple offsets at play in this function, so let's break it; // down. Starting with how variables may be stored in allocas:; //; // 1 Simplest case: variable is alloca sized and starts at offset 0.; // 2 Variable is larger than the alloca: the alloca holds just a part of it.; // 3 Variable is smaller than the alloca: the alloca may hold multiple; // variables.; //; // Imagine we have a store to the entire alloca. In case (3) the store; // affects bits outside of the bounds of each variable. In case (2), where; // the alloca holds the Xth bit to the Yth bit of a variable, the; // zero-offset store doesn't represent an assignment at offset zero to the; // variable. It is an assignment to offset X.; //; // # Example 1; // Obviously, not all stores are alloca-sized and have zero offset. Imagine; // the lower 32 bits of this store are dead and are going to be DSEd:; //; // store i64 %v, ptr %dest, !DIAssignID !1; // dbg.assign(..., !DIExpression(fragment, 128, 32), !1, %dest,; // !DIExpression(DW_OP_plus_uconst, 4)); //; // Goal: Given our dead bits at offset:0 size:32 for the store, determine the; // part of the variable, which fits in the fragment expressed by the; // dbg.assign, that has been killed, if any.; //; // calculateFragmentIntersect(..., SliceOffsetInBits=0,; // SliceSizeInBits=32, Dest=%dest, Assign=dbg.assign); //; // Drawing the store (s) in memory followed by the shortened version ($),; // then the dbg.assign (d), with the fragment information on a seperate scale; // underneath:; //; // Memory; // offset; // from; // dest 0 63; // | |; // s[######] - Original stores 64 bits to Dest.; // $----[##] - DSE says the lower 32 bits are dead, to be removed.; // d [##] - Assign's address-modifying expression adds 4 bytes to; // dest.; // Variable | |; // Fragment 128|; // Offsets 159; //; // The answer is achieved in a few steps:; // 1. Add the fragment offset to the store offset:; // SliceOffsetInBits:0 + VarFrag.OffsetInBits:128 = 128; //; // 2. Su",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:78,down,down,78,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,1,['down'],['down']
Availability,// There are no generalized cross-lane shuffle operations available on i16; // element types.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:58,avail,available,58,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avail'],['available']
Availability,// There are no generalized cross-lane shuffle operations available on i8; // element types.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:58,avail,available,58,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avail'],['available']
Availability,"// There are some cases where the user may set up a pointer in the (default); // constructor but not mark this pointer as transient. Sometime the value; // of this pointer is the address of one of the object with just created; // and the following delete would result in the deletion (possibly of the; // top level object we are goint to return!).; // Eventhough this is a user error, we could prevent the crash by simply; // adding:; // && !CheckObject(start[j],cl); // However this can increase the read time significantly (10% in the case; // of one TLine pointer in the test/Track and run ./Event 200 0 0 20 30000; //; // If ReadObjectAny returned the same value as we previous had, this means; // that when writing this object (start[j] had already been written and; // is indeed pointing to the same object as the object the user set up; // in the default constructor).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferFile.cxx:378,error,error,378,io/io/src/TBufferFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferFile.cxx,2,['error'],['error']
Availability,// There are some invariants which are not checked by the verifier in favor; // of having them checked by the parser. They may be considered as bugs in the; // verifier and should be fixed there. However until all of those are covered; // we want to check for them explicitly. Otherwise we will add incorrect input; // to the corpus and this is going to confuse the fuzzer which will start; // exploration of the bitcode reader error handling code.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-opt-fuzzer/llvm-opt-fuzzer.cpp:428,error,error,428,interpreter/llvm-project/llvm/tools/llvm-opt-fuzzer/llvm-opt-fuzzer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-opt-fuzzer/llvm-opt-fuzzer.cpp,1,['error'],['error']
Availability,"// There are special ways we can lower some single-element blends. However, we; // have custom ways we can lower more complex single-element blends below that; // we defer to if both this and BLENDPS fail to match, so restrict this to; // when the V2 input is targeting element 0 of the mask -- that is the fast; // case here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:287,mask,mask,287,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// There are three possible options here:; // 1. Available operator<< to convert through an ostringstream; // 2. Cling's pretty printing; // 3. Generic printing as done in op_repr; //; // Additionally, there may be a mapped __str__ from the C++ type defining `operator char*`; // or `operator const char*`. Results are memoized for performance reasons.; // 0. Protect against trying to print a typed nullptr object through an insertion operator",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPInstance.cxx:49,Avail,Available,49,bindings/pyroot/cppyy/CPyCppyy/src/CPPInstance.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPInstance.cxx,1,['Avail'],['Available']
Availability,"// There are two CPUID leafs which information associated with the pconfig; // instruction:; // EAX=0x7, ECX=0x0 indicates the availability of the instruction (via the 18th; // bit of EDX), while the EAX=0x1b leaf returns information on the; // availability of specific pconfig leafs.; // The target feature here only refers to the the first of these two.; // Users might need to check for the availability of specific pconfig; // leaves using cpuid, since that information is ignored while; // detecting features using the ""-march=native"" flag.; // For more info, see X86 ISA docs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/Host.cpp:127,avail,availability,127,interpreter/llvm-project/llvm/lib/TargetParser/Host.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/Host.cpp,3,['avail'],['availability']
Availability,"// There are two cases to handle here. 1) scoped lookup could have failed,; // in which case we should look for an ivar. 2) scoped lookup could have; // found a decl, but that decl is outside the current instance method (i.e.; // a global variable). In these two cases, we do a lookup for an ivar with; // this name, if the lookup sucedes, we replace it our current decl.; // If we're in a class method, we don't normally want to look for; // ivars. But if we don't find anything else, and there's an; // ivar, that's an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:521,error,error,521,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['error'],['error']
Availability,"// There are two difference cases requiring to reverse input vectors.; // For example, for vector <4 x i32> we have the following cases,; // Case 1: shufflevector(<4 x i32>,<4 x i32>,<-1, -1, -1, 0>); // Case 2: shufflevector(<4 x i32>,<4 x i32>,<-1, -1, 7, 0>); // For both cases, we finally use mask <5, 6, 7, 0>, which requires; // to reverse two input vectors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:297,mask,mask,297,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,2,['mask'],['mask']
Availability,"// There are unresolved typos in Init, just drop them.; // FIXME: improve the recovery strategy to preserve the Init.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:78,recover,recovery,78,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['recover'],['recovery']
Availability,// There can be only 1 non-negative mask element value if this is a splat.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:36,mask,mask,36,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,1,['mask'],['mask']
Availability,// There could be leftover tokens (e.g. because of an error).; // Skip through until we reach the 'end of default argument' token.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:54,error,error,54,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,1,['error'],['error']
Availability,// There could be leftover tokens (e.g. because of an error).; // Skip through until we reach the 'end of directive' token.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:54,error,error,54,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['error'],['error']
Availability,// There could be leftover tokens (e.g. because of an error).; // Skip through until we reach the original token position.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:54,error,error,54,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,1,['error'],['error']
Availability,// There is a SUBS feeding this condition. Is it fed by a mask we can; // use?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:58,mask,mask,58,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['mask'],['mask']
Availability,"// There is a chance that begin or end is invalid here, for example if; // specific compile error is reported.; // It is possible that the FileID's do not match, if one comes from an; // included file. In this case we can not produce a meaningful source range.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp:92,error,error,92,interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp,1,['error'],['error']
Availability,"// There is a scalar version available, but unlike the vector version which; // has a separate operand for the offset and width, the scalar version packs; // the width and offset into a single operand. Try to move to the scalar; // version if the offsets are constant, so that we can try to keep extended; // loads of kernel arguments in SGPRs.; // TODO: Technically we could try to pattern match scalar bitshifts of; // dynamic values, but it's probably not useful.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelDAGToDAG.cpp:29,avail,available,29,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelDAGToDAG.cpp,1,['avail'],['available']
Availability,"// There is at least one non-deoptimizing exit.; //; // Note, that BasicBlock::getPostdominatingDeoptimizeCall is not exact,; // as it can conservatively return false for deoptimizing exits with; // complex enough control flow down to deoptimize call.; //; // That means here we can report success for a case where; // all exits are deoptimizing but one of them has complex enough; // control flow (e.g. with loops).; //; // That should be a very rare case and false positives for this function; // have compile-time effect only.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:227,down,down,227,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,1,['down'],['down']
Availability,// There is little performance gain if we pend the recalculation under; // Lazy UpdateStrategy so we recalculate available trees immediately.; // Prevent forceFlushDeletedBB() from erasing DomTree or PostDomTree nodes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:113,avail,available,113,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,1,['avail'],['available']
Availability,"// There is no Multiply method to tests. And the errors are wrongly; // calculated in the TProfile::Division method, so there is no; // point to make the tests. Once the method is fixed, the tests; // will be finished.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressHistogram.cxx:49,error,errors,49,test/stressHistogram.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressHistogram.cxx,1,['error'],['errors']
Availability,"// There is no dictionary at all and we do not have; // the services of a collection proxy available, so; // use the streamer info to approximate calling a; // constructor (basically we just make sure that the; // pointer data members are null, unless they are marked; // as preallocated with the ""->"" comment, in which case; // we default-construct an object to point at).; // ???BUG??? ???WHY???; // Do not register any TObject's that we create; // as a result of creating this object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:91,avail,available,91,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,3,['avail'],['available']
Availability,"// There is no dictionary at all and we do not have; // the services of a collection proxy available, so; // use the streamer info to approximate calling a; // constructor (basically we just make sure that the; // pointer data members are null, unless they are marked; // as preallocated with the ""->"" comment, in which case; // we default-construct an object to point at).; // Do not register any TObject's that we create; // as a result of creating this object.; // FIXME: Why do we do this?; // FIXME: Partial Answer: Is this because we may never actually deregister them???",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:91,avail,available,91,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['avail'],['available']
Availability,"// There is no dictionary at all and we do not have; // the services of a collection proxy available, so; // use the streamer info to approximate calling a; // destructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:91,avail,available,91,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['avail'],['available']
Availability,"// There is no dictionary at all and we do not have; // the services of a collection proxy available, so; // use the streamer info to approximate calling the; // array destructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:91,avail,available,91,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['avail'],['available']
Availability,"// There is no dominating use, check if we can find a closest non-dominating; // use that lies between any other potentially available use and Load.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:125,avail,available,125,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['avail'],['available']
Availability,"// There is nothing to repair, but we may actually lie on; // the repairing cost because of the PHIs already proceeded; // as already stated.; // Though the code will be correct.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:23,repair,repair,23,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,2,['repair'],"['repair', 'repairing']"
Availability,"// There is nothing we can do here unless the mask is removing some bits.; // Also, the addressing mode can only represent shifts of 1, 2, or 3 bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:46,mask,mask,46,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,2,['mask'],['mask']
Availability,"// There is only one libcall for compare an exchange, because there is no; // optimisation benefit possible from a libcall version of a weak compare; // and exchange.; // bool __atomic_compare_exchange(size_t size, void *mem, void *expected,; // void *desired, int success, int failure); // bool __atomic_compare_exchange_N(T *mem, T *expected, T desired,; // int success, int failure)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:278,failure,failure,278,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,2,['failure'],['failure']
Availability,// There may be no interface context due to error in declaration; // of the interface (which has been reported). Recover gracefully.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:44,error,error,44,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,2,"['Recover', 'error']","['Recover', 'error']"
Availability,// There may have been an error that did not prevent us from constructing a; // declaration. Mark the declaration invalid and return with a substitution; // failure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:26,error,error,26,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,2,"['error', 'failure']","['error', 'failure']"
Availability,// There must be only one instance of a given register bank alive; // for the whole compilation.; // The RegisterBankInfo is supposed to enforce that.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBank.cpp:60,alive,alive,60,interpreter/llvm-project/llvm/lib/CodeGen/RegisterBank.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBank.cpp,1,['alive'],['alive']
Availability,// There should not be a success error. Jump to unreachable directly.; // Add this case to make the compiler stop complaining.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CrossTU/CrossTranslationUnit.cpp:33,error,error,33,interpreter/llvm-project/clang/lib/CrossTU/CrossTranslationUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CrossTU/CrossTranslationUnit.cpp,1,['error'],['error']
Availability,"// There was an error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:16,error,error,16,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['error'],['error']
Availability,// There was an error closing the brackets,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:16,error,error,16,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,1,['error'],['error']
Availability,// There was an error with the constraints comparison. Exit the loop; // and don't consider this function eligible.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:16,error,error,16,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['error'],['error']
Availability,"// There was an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx:16,error,error,16,core/dictgen/src/rootcling_impl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx,1,['error'],['error']
Availability,"// There was either a syntax error or we found $Alt",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormula.cxx:29,error,error,29,tree/treeplayer/src/TTreeFormula.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormula.cxx,1,['error'],['error']
Availability,"// There's an existing insertelement with constant insertion index, so we; // don't need to check the legality/profitability of a replacement operation; // that differs at most in the constant value. The target should be able to; // lower any of those in a similar way. If not, legalization will expand this; // to a scalar-to-vector plus shuffle.; //; // Note that the shuffle may move the scalar from the position that the insert; // element used. Therefore, our new insert element occurs at the shuffle's; // mask index value, not the insert's index value.; // shuffle (insertelt v1, x, C), v2, mask --> insertelt v2, x, C'",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:512,mask,mask,512,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['mask'],['mask']
Availability,// There's not much we can with errors here,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp:32,error,errors,32,interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp,1,['error'],['errors']
Availability,"// There's nothing to suggest in here as we parsed a full expression.; // Instead fail and propagate the error since caller might have something; // the suggest, e.g. signature help in function call. Note that this is; // performed before pushing the \p Expr, so that signature help can report; // current argument correctly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:105,error,error,105,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,2,['error'],['error']
Availability,// These are known in the LLVM project: 'Error()',MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ReturnValueChecker.cpp:41,Error,Error,41,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ReturnValueChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ReturnValueChecker.cpp,1,['Error'],['Error']
Availability,"// These aren't available as attributes, but maybe we should still; // render them somehow? (Clang doesn't render them, but that's an issue; // for template names too - since then the DWARF names of templates; // instantiated with function types with these calling conventions won't; // have distinct names - so we'd need to fix that too)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFTypePrinter.cpp:16,avail,available,16,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFTypePrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFTypePrinter.cpp,1,['avail'],['available']
Availability,// These bits are known to be zero but the AssertZext may be from a value; // that already has some constant zero bits (i.e. from a masking and).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:132,mask,masking,132,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['mask'],['masking']
Availability,"// These bytes sort of have a hidden message, but it's not in; // little-endian this time, and it's a little redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h:109,redundant,redundant,109,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,1,['redundant'],['redundant']
Availability,// These enums are used as an index to ErrorMessages array.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:39,Error,ErrorMessages,39,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,1,['Error'],['ErrorMessages']
Availability,"// These files need to be available everywhere, cache and sandbox",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:26,avail,available,26,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['avail'],['available']
Availability,// These flags allow to change the shadow mapping.; // The shadow mapping looks like; // Shadow = ((Mem & mask) >> scale) + offset,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:106,mask,mask,106,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,1,['mask'],['mask']
Availability,// These functions are for converting Expected/Error values to; // ErrorOr/std::error_code for compatibility with legacy clients. FIXME:; // Remove these functions once no longer needed by the C and libLTO APIs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h:47,Error,Error,47,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,2,['Error'],"['Error', 'ErrorOr']"
Availability,// These functions aren't available in either MSVC or MinGW environments.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:26,avail,available,26,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,1,['avail'],['available']
Availability,"// These functions change the specified standard stream (stdin or stdout) mode; // based on the Flags. They return errc::success if the specified stream was; // changed. Otherwise, a platform dependent error is returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Program.h:202,error,error,202,interpreter/llvm-project/llvm/include/llvm/Support/Program.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Program.h,1,['error'],['error']
Availability,// These functions change the specified standard stream (stdin or stdout) to; // binary mode. They return errc::success if the specified stream; // was changed. Otherwise a platform dependent error is returned.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Program.h:192,error,error,192,interpreter/llvm-project/llvm/include/llvm/Support/Program.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Program.h,1,['error'],['error']
Availability,// These have been substituted from template parameters; // and appear as literals in the static assert error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:104,error,error,104,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['error'],['error']
Availability,"// These helpers are split into an *Impl function and a macro to check for and propagate fatal failures to the caller.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_evolution.cxx:95,failure,failures,95,tree/ntuple/v7/test/ntuple_evolution.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_evolution.cxx,1,['failure'],['failures']
Availability,// These implicitly read VCC as mask source.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp:32,mask,mask,32,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,1,['mask'],['mask']
Availability,"// These instructions cause shader I/O that may cause hardware lockups; // when executed with an empty EXEC mask.; //; // Note: exp with VM = DONE = 0 is automatically skipped by hardware when; // EXEC = 0, but checking for that case here seems not worth it; // given the typical code patterns.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp:108,mask,mask,108,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,1,['mask'],['mask']
Availability,// These libcalls are not available in 32-bit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:26,avail,available,26,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,5,['avail'],['available']
Availability,"// These maps are usually stored once per checker, so let's make sure; // we don't do redundant copies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallDescription.h:86,redundant,redundant,86,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallDescription.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallDescription.h,1,['redundant'],['redundant']
Availability,"// These mask are globally available to manipulate the option to Accept",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TServerSocket.h:9,mask,mask,9,net/net/inc/TServerSocket.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TServerSocket.h,2,"['avail', 'mask']","['available', 'mask']"
Availability,// These may contextually need to be broken down.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:44,down,down,44,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,1,['down'],['down']
Availability,"// These must not be moved across calls or instructions that may change; // floating-point exception masks or read floating-point exception flags.; // In addition, they cannot be optimized out even if unused.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:101,mask,masks,101,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['mask'],['masks']
Availability,// These must not be moved across calls or instructions that may change; // floating-point exception masks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:101,mask,masks,101,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['mask'],['masks']
Availability,"// These nodes match the semantics of the corresponding RVV vector reduction; // instructions. They produce a vector result which is the reduction; // performed over the second vector operand plus the first element of the; // third vector operand. The first operand is the pass-thru operand. The; // second operand is an unconstrained vector type, and the result, first, and; // third operand's types are expected to be the corresponding full-width; // LMUL=1 type for the second operand:; // nxv8i8 = vecreduce_add nxv8i8, nxv32i8, nxv8i8; // nxv2i32 = vecreduce_add nxv2i32, nxv8i32, nxv2i32; // The different in types does introduce extra vsetvli instructions but; // similarly it reduces the number of registers consumed per reduction.; // Also has a mask and VL operand.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:755,mask,mask,755,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,1,['mask'],['mask']
Availability,"// These restrictions can modify the slot masks in the instructions; // in the Packet member, but they can also detect constraint failures; // which are fatal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:42,mask,masks,42,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,2,"['failure', 'mask']","['failures', 'masks']"
Availability,// These restrictions can modify the slot masks in the instructions; // in the Packet member. They should run unconditionally and their; // order does not matter.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:42,mask,masks,42,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,1,['mask'],['masks']
Availability,"// These setters are not available -- need proper AND/OR mode.; // out << t << ""SetMinPt("" << fMinPt << "");\n"";; // out << t << ""SetMaxPt("" << fMaxPt << "");\n"";; // out << t << ""SetLimPt("" << fLimPt << "");\n"";; // out << t << ""SetMinP("" << fMinP << "");\n"";; // out << t << ""SetMaxP("" << fMaxP << "");\n"";; // out << t << ""SetLimP("" << fLimP << "");\n"";",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveTrack.cxx:25,avail,available,25,graf3d/eve/src/TEveTrack.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveTrack.cxx,2,['avail'],['available']
Availability,"// These tests are disabled if the legacy backend is not available, because; // then we don't have any reference to compare to.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testSumW2Error.cxx:57,avail,available,57,roofit/roofitcore/test/testSumW2Error.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testSumW2Error.cxx,1,['avail'],['available']
Availability,"// These two are somewhat redundant given the caller; // (ABIInfo::isHomogeneousAggregate) checks the bases and fields, but that; // caller doesn't consider empty bases/fields to be non-homogenous, but it; // looks like Microsoft's AArch64 ABI does care about these empty types &; // anything containing/derived from one is non-homogeneous.; // Instead we could add another CXXABI entry point to query this property and; // have ABIInfo::isHomogeneousAggregate use that property.; // I don't think any other of the features listed above could be true of a; // base/field while not true of the outer struct. For example, if you have a; // base/field that has an non-trivial copy assignment/dtor/default ctor, then; // the outer struct's corresponding operation must be non-trivial.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp:26,redundant,redundant,26,interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp,1,['redundant'],['redundant']
Availability,"// These two cases will in practice only be reached when using fold; // expressions with || and &&, since otherwise the || and && will have been; // broken down into atomic constraints during satisfaction checking.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:156,down,down,156,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,1,['down'],['down']
Availability,"// These two lines would make the test fail because of two reasons:; // - An assertion failure ""Assertion failed: (detail::isPresent(Val) && ""dyn_cast on a non-existent value""), function dyn_cast, file Casting.h, line 662.""; // - An error ""Error in <TInterpreter::RefreshClassInfo>: Should not need to update the classInfo a non type decl: Detail""; // This is why there is no check performed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/test/TClingTests.cxx:87,failure,failure,87,core/metacling/test/TClingTests.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/test/TClingTests.cxx,3,"['Error', 'error', 'failure']","['Error', 'error', 'failure']"
Availability,// These two values allow checking two kinds of errors:; // - actual overflows caused by a source that doesn't fit in the destination; // - potential overflows caused by a bound that could exceed the destination,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:48,error,errors,48,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,1,['error'],['errors']
Availability,"// These types can be variably-modified. All these modifications; // preserve structure except as noted by comments.; // TODO: if we ever care about optimizing VLAs, there are no-op; // optimizations available here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:200,avail,available,200,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['avail'],['available']
Availability,"// These types can show up in private ivars in system headers, so; // we need this to not be an error in those cases. Instead we; // want to delay.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:96,error,error,96,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,1,['error'],['error']
Availability,"// These uses are both partially available at Load were it not for; // the clobber, but neither lies strictly after the other.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:33,avail,available,33,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['avail'],['available']
Availability,"// These variables are used for the following forms:; // Addr: (OuterDisp); // RegMask: RegMask (as register mask); // Reg: %OuterReg; // RegIndirect: (%OuterReg); // RegPostIncrement: (%OuterReg)+; // RegPreDecrement: -(%OuterReg); // RegIndirectDisplacement: OuterDisp(%OuterReg); // RegIndirectDisplacementIndex:; // OuterDisp(%OuterReg, %InnerReg.Size * Scale, InnerDisp)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp:109,mask,mask,109,interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp,1,['mask'],['mask']
Availability,// These vec_malloc/free routines are only available on AIX.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:43,avail,available,43,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,1,['avail'],['available']
Availability,// Things that are available after the instruction are killed by it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:19,avail,available,19,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,1,['avail'],['available']
Availability,"// This ASTTransformer adds an inline attribute to any CUDA __device__ kernel; // that does not have the attribute. Inlining solves a problem caused by; // incremental compilation of PTX code. In a normal compiler, all definitions; // of __global__ and __device__ kernels are in the same translation unit. In; // the incremental compiler, each kernel has its own translation unit. In case; // a __global__ kernel uses a __device__ function, this design caused an error.; // Instead of generating the PTX code of the __device__ kernel in the same file; // as the __global__ kernel, there is only an external declaration of the; // __device__ function. However, PTX does not support an external declaration of; // functions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeviceKernelInliner.h:463,error,error,463,interpreter/cling/lib/Interpreter/DeviceKernelInliner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeviceKernelInliner.h,1,['error'],['error']
Availability,"// This DBG_VALUE would re-order assignments. If we can't copy-propagate; // it, it can't be recovered. Set it undef.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:93,recover,recovered,93,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,1,['recover'],['recovered']
Availability,"// This Error is unchecked, even if the source error was checked.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:8,Error,Error,8,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,2,"['Error', 'error']","['Error', 'error']"
Availability,"// This Query generates a sequence of basic blocks which follows the order of; // execution.; // A handful of BB with higher block frequencies are taken, then path to entry; // and end BB are discovered by traversing up & down the CFG.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/SpeculateAnalyses.h:222,down,down,222,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/SpeculateAnalyses.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/SpeculateAnalyses.h,1,['down'],['down']
Availability,// This SU is not in AvailableQueue right now.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp:21,Avail,AvailableQueue,21,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp,2,['Avail'],['AvailableQueue']
Availability,// This accounts for any modification of the EXEC mask within the block and; // can be optimized out pre-RA when not required.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerControlFlow.cpp:50,mask,mask,50,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerControlFlow.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerControlFlow.cpp,1,['mask'],['mask']
Availability,"// This algorithm deals with arbitrary rounding mode used by sdivrem.; // We want to check whether the non-integer part of the mathematical value; // is negative or not. If the non-integer part is negative, we need to round; // down from Quo; otherwise, if it's positive or 0, we return Quo, as it's; // already rounded down.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp:228,down,down,228,interpreter/llvm-project/llvm/lib/Support/APInt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp,2,['down'],['down']
Availability,"// This algorithm works by first collecting a set of candidate nodes that have; // an out-degree of one (in terms of def-use edges), and then ignoring those; // whose targets have an in-degree more than one. Each node in the resulting; // set can then be merged with its corresponding target and put back into the; // worklist until no further merge candidates are available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp:365,avail,available,365,interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,1,['avail'],['available']
Availability,"// This analysis aims to remove redundant DBG_VALUEs by going backward; // in the basic block and removing all but the last DBG_VALUE for any; // given variable in a set of consecutive DBG_VALUE instructions.; // For example:; // (1) DBG_VALUE $edi, !""var1"", ...; // (2) DBG_VALUE $esi, !""var2"", ...; // (3) DBG_VALUE $edi, !""var1"", ...; // ...; // in this case, we can remove (1).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp:32,redundant,redundant,32,interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,1,['redundant'],['redundant']
Availability,"// This analysis aims to remove redundant DBG_VALUEs by going forward; // in the basic block by considering the first DBG_VALUE as a valid; // until its first (location) operand is not clobbered/modified.; // For example:; // (1) DBG_VALUE $edi, !""var1"", ...; // (2) <block of code that does affect $edi>; // (3) DBG_VALUE $edi, !""var1"", ...; // ...; // in this case, we can remove (3).; // TODO: Support DBG_VALUE_LIST and other debug instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp:32,redundant,redundant,32,interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,1,['redundant'],['redundant']
Availability,"// This are the Functions that are needed to mangle the name of the; // vector functions generated by the compiler, according to the rules; // defined in the ""Vector Function ABI specifications for AArch64"",; // available at; // https://developer.arm.com/products/software-development-tools/hpc/arm-compiler-for-hpc/vector-function-abi.; /// Maps To Vector (MTV), as defined in 4.1.1 of the AAVFABI (2021Q1).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:212,avail,available,212,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,1,['avail'],['available']
Availability,// This avoids essentially the same error being reported multiple times.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp:36,error,error,36,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp,1,['error'],['error']
Availability,"// This behavior is present in the Float8ExMyFN* types (Float8E4M3FN,; // Float8E5M2FNUZ, Float8E4M3FNUZ, and Float8E4M3B11FNUZ). There is no; // representation for Inf, and operations that would ordinarily produce Inf; // produce NaN instead.; // The details of the NaN representation(s) in this form are determined by the; // `fltNanEncoding` enum. We treat all NaNs as quiet, as the available; // encodings do not distinguish between signalling and quiet NaN.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp:386,avail,available,386,interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,1,['avail'],['available']
Availability,// This block control legalization of v32i1/v64i1 which are available with; // AVX512BW..,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:60,avail,available,60,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avail'],['available']
Availability,// This block controls legalization of the mask vector sizes that are; // available with AVX512. 512-bit vectors are in a separate block controlled; // by useAVX512Regs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:43,mask,mask,43,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,"['avail', 'mask']","['available', 'mask']"
Availability,"// This block declares the variable (uninitialized), and is reachable; // from a block that initializes the variable. We can't guarantee to; // give an earlier location for the diagnostic (and it appears that; // this code is intended to be reachable) so give a diagnostic here; // and go no further down this path.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp:300,down,down,300,interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp,1,['down'],['down']
Availability,"// This can also print error messages, so we need to do it outside the lock",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TErrorDefaultHandler.cxx:23,error,error,23,core/base/src/TErrorDefaultHandler.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TErrorDefaultHandler.cxx,1,['error'],['error']
Availability,// This can be called from the ArchiveMemberHeader constructor when the; // archive header is truncated to produce an error message with the name.; // Make sure the name field is not truncated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/Archive.cpp:118,error,error,118,interpreter/llvm-project/llvm/lib/Object/Archive.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/Archive.cpp,1,['error'],['error']
Availability,// This can cause a redundant sltiu to be generated.; // FIXME: try and eliminate this in a future patch.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:20,redundant,redundant,20,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,1,['redundant'],['redundant']
Availability,"// This can create a %noreg operand in rare cases when the sub-register; // index is no longer available. That means the user value is in a; // non-existent sub-register, and %noreg is exactly what we want.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:95,avail,available,95,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,1,['avail'],['available']
Availability,// This can only happen along a recovery path.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:32,recover,recovery,32,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['recover'],['recovery']
Availability,"// This candidate has constraint that we were unable to evaluate because; // it referenced an expression that contained an error. Rather than fall; // back onto a potentially unintended candidate (made worse by; // subsuming constraints), treat this as 'no viable candidate'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:123,error,error,123,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['error'],['error']
Availability,// This check is redundant except for look ahead. This function is; // called for lookahead by isProfitableToTailDup when BB hasn't been; // placed yet.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:17,redundant,redundant,17,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,1,['redundant'],['redundant']
Availability,// This check is redundant with one in visitLocalVariable().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:17,redundant,redundant,17,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,1,['redundant'],['redundant']
Availability,// This checks against logic errors in the MCJIT implementation.; // This function should never be called with either a Module that MCJIT; // does not own or a Module that has already been loaded and/or finalized.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h:29,error,errors,29,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h,1,['error'],['errors']
Availability,"// This checks against logic errors in the MCJIT implementation.; // This function should never be called with either a Module that MCJIT; // does not own, a Module that has not been loaded or a Module that has; // already been finalized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h:29,error,errors,29,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h,1,['error'],['errors']
Availability,// This class clean up the erroneous/redundant code around the given ranges in; // file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:37,redundant,redundant,37,interpreter/llvm-project/clang/lib/Format/Format.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp,1,['redundant'],['redundant']
Availability,// This class is used to build up a contiguous binary blob while keeping; // track of an offset in the output (which notionally begins at; // `InitialOffset`).; // The blob might be limited to an arbitrary size. All attempts to write data; // are ignored and the error condition is remembered once the limit is reached.; // Such an approach allows us to simplify the code by delaying error reporting; // and doing it at a convenient time.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjectYAML/ELFEmitter.cpp:263,error,error,263,interpreter/llvm-project/llvm/lib/ObjectYAML/ELFEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjectYAML/ELFEmitter.cpp,2,['error'],['error']
Availability,// This clobbers G1 which we always know is available here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp:44,avail,available,44,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp,1,['avail'],['available']
Availability,"// This code intentionally doesn't call the ErrorHandler callback, because; // llvm_unreachable is intended to be used to indicate ""impossible""; // situations, and not legitimate runtime errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ErrorHandling.cpp:44,Error,ErrorHandler,44,interpreter/llvm-project/llvm/lib/Support/ErrorHandling.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ErrorHandling.cpp,2,"['Error', 'error']","['ErrorHandler', 'errors']"
Availability,"// This code is analoguous to that in CheckDerivedToBaseConversion, except; // that it builds the paths in reverse order.; // To sum up: record all paths to the base and build a nice string from; // them. Use it to spice up the error message.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:228,error,error,228,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,1,['error'],['error']
Availability,// This codegen pass is only available on x86 and AArch64 ELF targets.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:29,avail,available,29,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['avail'],['available']
Availability,"// This combine may end up running before ptrtoint/inttoptr combines; // manage to eliminate redundant conversions, so try to look through them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:93,redundant,redundant,93,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,1,['redundant'],['redundant']
Availability,"// This combine tries to find build_vector's which have every source element; // extracted using G_EXTRACT_VECTOR_ELT. This can happen when transforms like; // the masked load scalarization is run late in the pipeline. There's already; // a combine for a similar pattern starting from the extract, but that; // doesn't attempt to do it if there are multiple uses of the build_vector,; // which in this case is true. Starting the combine from the build_vector; // feels more natural than trying to find sibling nodes of extracts.; // E.g.; // %vec(<4 x s32>) = G_BUILD_VECTOR %s1(s32), %s2, %s3, %s4; // %ext1 = G_EXTRACT_VECTOR_ELT %vec, 0; // %ext2 = G_EXTRACT_VECTOR_ELT %vec, 1; // %ext3 = G_EXTRACT_VECTOR_ELT %vec, 2; // %ext4 = G_EXTRACT_VECTOR_ELT %vec, 3; // ==>; // replace ext{1,2,3,4} with %s{1,2,3,4}",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:164,mask,masked,164,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,1,['mask'],['masked']
Availability,// This combo units bits are not available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DFAPacketizerEmitter.cpp:33,avail,available,33,interpreter/llvm-project/llvm/utils/TableGen/DFAPacketizerEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DFAPacketizerEmitter.cpp,1,['avail'],['available']
Availability,"// This counter in the sequential case collects errors coming also from; // different files (suppose to have a program reading f1.root, f2.root ...); // In the mt case, it is made atomic: it safely collects errors from; // different files processed simultaneously.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:48,error,errors,48,tree/tree/src/TBranch.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx,2,['error'],['errors']
Availability,"// This creates comdat sections with the given symbol name, but unless; // AsmPrinter::GetCPISymbol actually makes the symbol global, the symbol; // will be created with a null storage class, which makes GNU binutils; // error out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:221,error,error,221,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,1,['error'],['error']
Availability,"// This definition is compiled in case nothing else is,; // in order to quiet down some fussy librarians",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TRefCnt.cxx:78,down,down,78,core/base/src/TRefCnt.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TRefCnt.cxx,1,['down'],['down']
Availability,"// This deletes all the ephemeral handlers that AsmPrinter added, while; // keeping all the user-added handlers alive until the AsmPrinter is; // destroyed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:112,alive,alive,112,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,1,['alive'],['alive']
Availability,"// This directive should only occur in the predefines buffer. If not, emit an; // error and reject it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:82,error,error,82,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,1,['error'],['error']
Availability,// This doesn't use 'isIntegralType' despite the error message mentioning; // integral type because isIntegralType would also allow enum types in C.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:49,error,error,49,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['error'],['error']
Availability,"// This dummy is needed for plotOn to recognize the ""SliceCatMany"" command.; // It is not used directly, but the ""SliceCat"" commands are nested in it.; // Removing this dummy definition results in ""ERROR: unrecognized command: SliceCatMany"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:198,ERROR,ERROR,198,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,2,['ERROR'],['ERROR']
Availability,"// This element is from left hand side vector operand.; //; // If LHS is going to be replaced (case 1, 2, or 4), calculate the; // new mask value for the element.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:135,mask,mask,135,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['mask'],['mask']
Availability,"// This element is from right hand side vector operand; //; // If the value selected is a poison value, explicitly specify it; // with a -1 mask value. (case 1)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:140,mask,mask,140,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['mask'],['mask']
Availability,// This enum maps OpenCL version(s) into value. These values are used as; // a mask to indicate in which OpenCL version(s) extension is a core or; // optional core feature.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/OpenCLOptions.h:79,mask,mask,79,interpreter/llvm-project/clang/include/clang/Basic/OpenCLOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/OpenCLOptions.h,1,['mask'],['mask']
Availability,"// This error message is repeated several times in the code. We write it once.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:8,error,error,8,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['error'],['error']
Availability,// This error was already reported by the tokenizer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Parser.cpp:8,error,error,8,interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Parser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Parser.cpp,1,['error'],['error']
Availability,// This evaluation context exists to ensure that there's always at least one; // valid evaluation context available. It is never removed from the; // evaluation stack.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:106,avail,available,106,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp,1,['avail'],['available']
Availability,// This explicit instantiation declaration is redundant (that's okay).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:46,redundant,redundant,46,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['redundant'],['redundant']
Availability,"// This expr depends in any way on; // - a template parameter, it implies that the resolution of this expr may; // cause instantiation to fail; // - or an error (often in a non-template context); //; // Note that C++ standard doesn't define the instantiation-dependent term,; // we follow the formal definition coming from the Itanium C++ ABI, and; // extend it to errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h:155,error,error,155,interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h,2,['error'],"['error', 'errors']"
Availability,"// This file is used by Code Analysis to maintain SuppressMessage; // attributes that are applied to this project. Project-level; // suppressions either have no target or are given a specific target; // and scoped to a namespace, type, member, etc.; //; // To add a suppression to this file, right-click the message in the; // Error List, point to ""Suppress Message(s)"", and click ""In Project; // Suppression File"". You do not need to add suppressions to this; // file manually.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/GlobalSuppressions.cs:327,Error,Error,327,interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/GlobalSuppressions.cs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/GlobalSuppressions.cs,1,['Error'],['Error']
Availability,"// This fixes the following rootcling error when generating the dictionary:; // error G34C21FBE: static_assert expression is not an integral constant expression; // FIXME: check if the error is fixed when upgrading llvm/clang ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveVector.h:38,error,error,38,graf3d/eve/inc/TEveVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveVector.h,3,['error'],['error']
Availability,"// This flags allows or disallows DSE to optimize MemorySSA during its; // traversal. Note that DSE optimizing MemorySSA may impact other passes; // downstream of the DSE invocation and can lead to issues not being; // reproducible in isolation (i.e. when MemorySSA is built from scratch). In; // those cases, the flag can be used to check if DSE's MemorySSA optimizations; // impact follow-up passes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:149,down,downstream,149,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,1,['down'],['downstream']
Availability,"// This full expression is not instantiation dependent or the variable; // can not be used in a constant expression - which means; // this variable must be odr-used here, so diagnose a; // capture violation early, if the variable is un-captureable.; // This is purely for diagnosing errors early. Otherwise, this; // error would get diagnosed when the lambda becomes capture ready.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:283,error,errors,283,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,2,['error'],"['error', 'errors']"
Availability,"// This function calculates the register usage by measuring the highest number; // of values that are alive at a single location. Obviously, this is a very; // rough estimation. We scan the loop in a topological order in order and; // assign a number to each instruction. We use RPO to ensure that defs are; // met before their users. We assume that each instruction that has in-loop; // users starts an interval. We record every time that an in-loop value is; // used, so we have a list of the first and last occurrences of each; // instruction. Next, we transpose this data structure into a multi map that; // holds the list of intervals that *end* at a specific location. This multi; // map allows us to perform a linear search. We scan the instructions linearly; // and record each time that a new interval starts, by placing it in a set.; // If we find this value in the multi-map then we remove it from the set.; // The max register usage is the maximum size of the set.; // We also search for instructions that are defined outside the loop, but are; // used inside the loop. We need this number separately from the max-interval; // usage number because when we unroll, loop-invariant values do not take; // more register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:102,alive,alive,102,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['alive'],['alive']
Availability,"// This function can be called for the same register with different; // lane masks. If the def in this instruction was for the whole; // register, we can get here more than once. Avoid adding multiple; // implicit uses (or adding an implicit use when an explicit one is; // present).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:77,mask,masks,77,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,1,['mask'],['masks']
Availability,"// This function can be performance-critical, so we rely on the power-of-2; // knowledge that we have about the mask sizes to replace div/rem ops with; // bit-masks and shifts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:112,mask,mask,112,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['mask'],"['mask', 'masks']"
Availability,"// This function does a whole lot of voodoo to determine if the tests are; // equivalent without and with a mask. Essentially what happens is that given a; // DAG resembling:; //; // +-------------+ +-------------+ +-------------+ +-------------+; // | Input | | AddConstant | | CompConstant| | CC |; // +-------------+ +-------------+ +-------------+ +-------------+; // | | | |; // V V | +----------+; // +-------------+ +----+ | |; // | ADD | |0xff| | |; // +-------------+ +----+ | |; // | | | |; // V V | |; // +-------------+ | |; // | AND | | |; // +-------------+ | |; // | | |; // +-----+ | |; // | | |; // V V V; // +-------------+; // | CMP |; // +-------------+; //; // The AND node may be safely removed for some combinations of inputs. In; // particular we need to take into account the extension type of the Input,; // the exact values of AddConstant, CompConstant, and CC, along with the nominal; // width of the input (this can work for any width inputs, the above graph is; // specific to 8 bits.; //; // The specific equations were worked out by generating output tables for each; // AArch64CC value in terms of and AddConstant (w1), CompConstant(w2). The; // problem was simplified by working with 4 bit inputs, which means we only; // needed to reason about 24 distinct bit patterns: 8 patterns unique to zero; // extension (8,15), 8 patterns unique to sign extensions (-8,-1), and 8; // patterns present in both extensions (0,7). For every distinct set of; // AddConstant and CompConstants bit patterns we can consider the masked and; // unmasked versions to be equivalent if the result of this function is true for; // all 16 distinct bit patterns of for the current extension type of Input (w0).; //; // sub w8, w0, w1; // and w10, w8, #0x0f; // cmp w8, w2; // cset w9, AArch64CC; // cmp w10, w2; // cset w11, AArch64CC; // cmp w9, w11; // cset w0, eq; // ret; //; // Since the above function shows when the outputs are equivalent it defines; // when it is safe to remove the A",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:108,mask,mask,108,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['mask'],['mask']
Availability,// This function does not affect the stream state.; // Still we add success and failure state with the appropriate return value.; // StdLibraryFunctionsChecker can change these states (set the 'errno' state).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:80,failure,failure,80,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,2,['failure'],['failure']
Availability,"// This function indicates whether the emergency spillslot should be placed; // close to the beginning of the stackframe (closer to FP) or the end; // (closer to SP).; //; // The beginning works most reliably if we have a frame pointer.; // In the presence of any non-constant space between FP and locals,; // (e.g. in case of stack realignment or a scalable SVE area), it is; // better to use SP or BP.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64RegisterInfo.cpp:200,reliab,reliably,200,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64RegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64RegisterInfo.cpp,1,['reliab'],['reliably']
Availability,"// This function is basically a switch over the CFI failure kind, which is; // extracted from CFICheckFailData (1st function argument). Each case is either; // llvm.trap or a call to one of the two runtime handlers, based on; // -fsanitize-trap and -fsanitize-recover settings. Default case (invalid; // failure kind) traps, but this should really never happen. CFICheckFailData; // can be nullptr if the calling module has -fsanitize-trap behavior for this; // check kind; in this case __cfi_check_fail traps as well.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:52,failure,failure,52,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,3,"['failure', 'recover']","['failure', 'recover']"
Availability,"// This function is called by a client after using the low-level API to add; // live-out and live-in blocks. The unique value optimization is not; // available, SplitEditor::transferValues handles that case directly anyway.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp:150,avail,available,150,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp,1,['avail'],['available']
Availability,"// This function is called from scalarize-masked-mem-intrin, which runs; // in pre-isel. Use ST directly instead of calling isHVXVectorType.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.cpp:42,mask,masked-mem-intrin,42,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.cpp,2,['mask'],['masked-mem-intrin']
Availability,"// This function is copied and adapted from NamedDecl::printQualifiedName(); // By matching each part individually we optimize in a couple of ways:; // - We can exit early on the first failure.; // - We can skip inline/anonymous namespaces without another pass.; // - We print one name at a time, reducing the chance of overflowing the; // inlined space of the SmallString.; // First, match the name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchersInternal.cpp:185,failure,failure,185,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchersInternal.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchersInternal.cpp,1,['failure'],['failure']
Availability,// This function is strictly redundant to; // LLVMCountParamTypes(LLVMGlobalGetValueType(FnRef)),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Core.cpp:29,redundant,redundant,29,interpreter/llvm-project/llvm/lib/IR/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Core.cpp,1,['redundant'],['redundant']
Availability,"// This function looks for a reasonably-exact match, so we consider; // incompatible pointer conversions to be a failure here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:113,failure,failure,113,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['failure'],['failure']
Availability,"// This function maintains a map for the pairs <TOC Save Instr, Keep>; // Each time a new TOC save is encountered, it checks if any of the existing; // ones are dominated by the new one. If so, it marks the existing one as; // redundant by setting it's entry in the map as false. It then adds the new; // instruction to the map with either true or false depending on if any; // existing instructions dominated the new one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:227,redundant,redundant,227,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,1,['redundant'],['redundant']
Availability,"// This function may be called twice, once for ModuleSummaryIndexAnalysis and; // the other when writing the IR symbol table. If parsing inline assembly has; // caused errors in the first run, suppress the second run.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/ModuleSymbolTable.cpp:168,error,errors,168,interpreter/llvm-project/llvm/lib/Object/ModuleSymbolTable.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/ModuleSymbolTable.cpp,1,['error'],['errors']
Availability,"// This function only makes sense for postdominators.; // We define roots to be some set of CFG nodes where (reverse) DFS walks have; // to start in order to visit all the CFG nodes (including the; // reverse-unreachable ones).; // When the search for non-trivial roots is done it may happen that some of; // the non-trivial roots are reverse-reachable from other non-trivial roots,; // which makes them redundant. This function removes them from the set of; // input roots.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTreeConstruction.h:404,redundant,redundant,404,interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTreeConstruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTreeConstruction.h,1,['redundant'],['redundant']
Availability,"// This function removes any redundant load immediates. It has two level; // loops - The outer loop finds the load immediates BBI that could be used; // to replace following redundancy. The inner loop scans instructions that; // after BBI to find redundancy and update kill/dead flags accordingly. If; // AfterBBI is the same as BBI, it is redundant, otherwise any instructions; // that modify the def register of BBI would break the scanning.; // DeadOrKillToUnset is a pointer to the previous operand that had the; // kill/dead flag set. It keeps track of the def register of BBI, the use; // registers of AfterBBIs and the def registers of AfterBBIs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:29,redundant,redundant,29,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,2,['redundant'],['redundant']
Availability,"// This function removes redundant pairs of accumulator prime/unprime; // instructions. In some situations, it's possible the compiler inserts an; // accumulator prime instruction followed by an unprime instruction (e.g.; // when we store an accumulator after restoring it from a spill). If the; // accumulator is not used between the two, they can be removed. This; // function removes these redundant pairs from basic blocks.; // The algorithm is quite straightforward - every time we encounter a prime; // instruction, the primed register is added to a candidate set. Any use; // other than a prime removes the candidate from the set and any de-prime; // of a current candidate marks both the prime and de-prime for removal.; // This way we ensure we only remove prime/de-prime *pairs* with no; // intervening uses.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:25,redundant,redundant,25,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,2,['redundant'],['redundant']
Availability,"// This function tries to collect a bunch of potentially interesting; // nodes to improve the chains of, all at once. This might seem; // redundant, as this function gets called when visiting every store; // node, so why not let the work be done on each store as it's visited?; //; // I believe this is mainly important because mergeConsecutiveStores; // is unable to deal with merging stores of different sizes, so unless; // we improve the chains of all the potential candidates up-front; // before running mergeConsecutiveStores, it might only see some of; // the nodes that will eventually be candidates, and then not be able; // to go from a partially-merged state to the desired final; // fully-merged state.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:138,redundant,redundant,138,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['redundant'],['redundant']
Availability,// This function will iterate over the input map containing a pair of TOC save; // instruction and a flag. The flag will be set to false if the TOC save is; // proven redundant. This function will erase from the basic block all the TOC; // saves marked as redundant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:167,redundant,redundant,167,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,2,['redundant'],['redundant']
Availability,"// This functions ensures that the standard file descriptors (input, output,; // and error) are properly mapped to a file descriptor before we use any of; // them. This should only be called by standalone programs, library; // components should not call this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Process.h:85,error,error,85,interpreter/llvm-project/llvm/include/llvm/Support/Process.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Process.h,1,['error'],['error']
Availability,// This gets the raw name from the ArMemHdr->Name field and checks that it is; // valid for the kind of archive. If it is not valid it returns an Error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/Archive.cpp:146,Error,Error,146,interpreter/llvm-project/llvm/lib/Object/Archive.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/Archive.cpp,1,['Error'],['Error']
Availability,"// This has slightly sub-optimal regalloc when the source vector is killed by; // the read. The register allocator does not understand that the kill is; // per-workitem, so is kept alive for the whole loop so we end up not re-using a; // subregister from it, using 1 more VGPR than necessary. This was saved when; // this was expanded after register allocation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:181,alive,alive,181,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['alive'],['alive']
Availability,"// This header defines __muldc3, __mulsc3, __divdc3, and __divsc3. These are; // libgcc functions that clang assumes are available when compiling c99 complex; // operations. (These implementations come from libc++, and have been modified; // to work with CUDA and OpenMP target offloading [in C and C++ mode].)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_complex_builtins.h:121,avail,available,121,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_complex_builtins.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_complex_builtins.h,1,['avail'],['available']
Availability,// This hook gets to expand COPY instructions before they become; // copyPhysReg() calls. Look for VMOVS instructions that can legally be; // widened to VMOVD. We prefer the VMOVD when possible because it may be; // changed into a VORR that can go down the NEON pipeline.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:248,down,down,248,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['down'],['down']
Availability,"// This implements the loading of unaligned vectors as described in; // the venerable Apple Velocity Engine overview. Specifically:; // https://developer.apple.com/hardwaredrivers/ve/alignment.html; // https://developer.apple.com/hardwaredrivers/ve/code_optimization.html; //; // The general idea is to expand a sequence of one or more unaligned; // loads into an alignment-based permutation-control instruction (lvsl; // or lvsr), a series of regular vector loads (which always truncate; // their input address to an aligned address), and a series of; // permutations. The results of these permutations are the requested; // loaded values. The trick is that the last ""extra"" load is not taken; // from the address you might suspect (sizeof(vector) bytes after the; // last requested load), but rather sizeof(vector) - 1 bytes after the; // last requested vector. The point of this is to avoid a page fault if; // the base address happened to be aligned. This works because if the; // base address is aligned, then adding less than a full vector length; // will cause the last vector in the sequence to be (re)loaded.; // Otherwise, the next vector will be fetched as you might suspect was; // necessary.; // We might be able to reuse the permutation generation from; // a different base address offset from this one by an aligned amount.; // The INTRINSIC_WO_CHAIN DAG combine will attempt to perform this; // optimization later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:901,fault,fault,901,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['fault'],['fault']
Availability,// This information is not available while emitting .debug_loc entries.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:27,avail,available,27,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,1,['avail'],['available']
Availability,// This instruction is not supported.; // Clear any other pending errors because they are no longer relevant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp:66,error,errors,66,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp,1,['error'],['errors']
Availability,// This instruction shouldn't be added to AvailableSet.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:42,Avail,AvailableSet,42,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,1,['Avail'],['AvailableSet']
Availability,// This is SETCC with the full mask result which is used for a compare with a; // result bit per item in the wavefront.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.h:31,mask,mask,31,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.h,1,['mask'],['mask']
Availability,"// This is a call with a register mask operand.; // Mask clobbers are always dead, so add defs for the non-dead defines.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:34,mask,mask,34,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,2,"['Mask', 'mask']","['Mask', 'mask']"
Availability,"// This is a callback that can be passed to a number of functions.; // It can be used to ignore non-critical errors (warnings), which is; // useful for dumpers, like llvm-readobj.; // It accepts a warning message string and returns a success; // when the warning should be ignored or an error otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELF.h:109,error,errors,109,interpreter/llvm-project/llvm/include/llvm/Object/ELF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELF.h,2,['error'],"['error', 'errors']"
Availability,"// This is a common code block for Python 3. We prefer using objects to; // automatize memory management and not introduce even more preprocessor; // branching for deletion at the end of the method.; //; // FUTURE IMPROVEMENT ONCE OLD PYTHON VERSIONS ARE NOT SUPPORTED BY CPPYY:; // Right now we use C++ objects to automatize memory management. One could use; // RAAI and the Python memory allocation API (PEP 445) once some old Python; // version is deprecated in CPPYY. That new feature is available since version; // 3.4 and the preprocessor branching to also support that would be so; // complicated to make the code unreadable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/API.cxx:492,avail,available,492,bindings/pyroot/cppyy/CPyCppyy/src/API.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/API.cxx,1,['avail'],['available']
Availability,"// This is a gcc extension compatibility comparison.; // In a SFINAE context, we treat this as a hard error to maintain; // conformance with the C++ standard.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:102,error,error,102,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['error'],['error']
Availability,"// This is a lambda call operator that is being instantiated as a default; // initializer. DC must point to the enclosing class type, so we can recover; // the 'this' type from it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:144,recover,recover,144,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['recover'],['recover']
Availability,"// This is a non-MSVC compiler, probably mingw gcc or clang without; // -fms-extensions. Use vectored exception handling (VEH).; //; // On Windows, we can make use of vectored exception handling to catch most; // crashing situations. Note that this does mean we will be alerted of; // exceptions *before* structured exception handling has the opportunity to; // catch it. Unfortunately, this causes problems in practice with other code; // running on threads with LLVM crash recovery contexts, so we would like to; // eventually move away from VEH.; //; // Vectored works on a per-thread basis, which is an advantage over; // SetUnhandledExceptionFilter. SetUnhandledExceptionFilter also doesn't have; // any native support for chaining exception handlers, but VEH allows more than; // one.; //; // The vectored exception handler functionality was added in Windows; // XP, so if support for older versions of Windows is required,; // it will have to be added.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp:475,recover,recovery,475,interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp,1,['recover'],['recovery']
Availability,"// This is a non-owning pointer to an actual container.; // The memory is fully managed by the factory and is alive as long as the; // factory itself is alive.; // It is a pointer as opposed to a reference, so we can easily reassign; // RangeSet objects.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/RangedConstraintManager.h:110,alive,alive,110,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/RangedConstraintManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/RangedConstraintManager.h,2,['alive'],['alive']
Availability,"// This is a non-standard eliminator. The normal way to eliminate is; // to walk the dominator tree in order, keeping track of available; // values, and eliminating them. However, this is mildly; // pointless. It requires doing lookups on every instruction,; // regardless of whether we will ever eliminate it. For; // instructions part of most singleton congruence classes, we know we; // will never eliminate them.; // Instead, this eliminator looks at the congruence classes directly, sorts; // them into a DFS ordering of the dominator tree, and then we just; // perform elimination straight on the sets by walking the congruence; // class member uses in order, and eliminate the ones dominated by the; // last member. This is worst case O(E log E) where E = number of; // instructions in a single congruence class. In theory, this is all; // instructions. In practice, it is much faster, as most instructions are; // either in singleton congruence classes or can't possibly be eliminated; // anyway (if there are no overlapping DFS ranges in class).; // When we find something not dominated, it becomes the new leader; // for elimination purposes.; // TODO: If we wanted to be faster, We could remove any members with no; // overlapping ranges while sorting, as we will never eliminate anything; // with those members, as they don't dominate anything else in our set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:127,avail,available,127,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,1,['avail'],['available']
Availability,"// This is a point in time - we determined including these pairs of; // consecutive instructions (in the IR layout available at inline time) as; // features improves the model performance. We want to move away from manual; // feature selection.; // The array is given in opcode pairs rather than labels because 1) labels; // weren't readily available, and 2) the successions were hand - extracted.; //; // This array must be sorted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineSizeEstimatorAnalysis.cpp:115,avail,available,115,interpreter/llvm-project/llvm/lib/Analysis/InlineSizeEstimatorAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineSizeEstimatorAnalysis.cpp,2,['avail'],['available']
Availability,"// This is a redundant AND, it should get cleaned up elsewhere.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:13,redundant,redundant,13,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['redundant'],['redundant']
Availability,"// This is a reference to a no longer supported constant expression.; // Pretend that the constant was deleted, which will replace metadata; // references with undef.; // TODO: This is a rather indirect check. It would be more elegant to use; // a separate ErrorInfo for constant materialization failure and thread; // the error reporting through getValueFwdRef().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:257,Error,ErrorInfo,257,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,3,"['Error', 'error', 'failure']","['ErrorInfo', 'error', 'failure']"
Availability,// This is a reload for a sib-reg copy. Drop spills downstream.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:52,down,downstream,52,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,1,['down'],['downstream']
Availability,"// This is a shuffle of 2 widening shuffles. We can shuffle the narrow source; // operands directly by adjusting the shuffle mask to account for the narrower; // types:; // shuf (widen X), (widen Y), Mask --> shuf X, Y, Mask'",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:125,mask,mask,125,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,3,"['Mask', 'mask']","['Mask', 'mask']"
Availability,// This is a sibcall. The memory operands are available in caller's; // own caller's stack.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:46,avail,available,46,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,2,['avail'],['available']
Availability,"// This is a transient data member, so it is probably fine to not have; // access to its content. However let's no mark it as definitively setup,; // since another class might use this class for a persistent data member and; // in this case we really want the error message.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:260,error,error,260,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['error'],['error']
Availability,"// This is a variable shift, so we can't shift the demand mask by a known; // amount. But if we are not demanding high bits, then we are not; // demanding those bits from the pre-shifted operand either.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:58,mask,mask,58,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,2,['mask'],['mask']
Availability,"// This is a weird case, because we need to break down the mapping based on; // the register bank of a different operand.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp:50,down,down,50,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,1,['down'],['down']
Availability,"// This is actually not really any error, we probably received something; // like ""abs(some_val)"", let ROOT::v5::TFormula decompose it first.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormula.cxx:35,error,error,35,tree/treeplayer/src/TTreeFormula.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormula.cxx,1,['error'],['error']
Availability,// This is almost certainly an invalid type name. Let Sema emit a diagnostic; // and attempt to recover.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:96,recover,recover,96,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['recover'],['recover']
Availability,"// This is an i64 value that lives in two scalar registers. We have to; // insert this in a convoluted way. First we build vXi64 splat containing; // the two values that we assemble using some bit math. Next we'll use; // vid.v and vmseq to build a mask with bit 0 set. Then we'll use that mask; // to merge element 0 from our splat into the source vector.; // FIXME: This is probably not the best way to do this, but it is; // consistent with INSERT_VECTOR_ELT lowering so it is a good starting; // point.; // sw lo, (a0); // sw hi, 4(a0); // vlse vX, (a0); //; // vid.v vVid; // vmseq.vx mMask, vVid, 0; // vmerge.vvm vDest, vSrc, vVal, mMask",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:249,mask,mask,249,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,2,['mask'],['mask']
Availability,"// This is an immediate, so we should not parse a register. Do a precheck; // for '%' to supercede intra-register parse errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp:120,error,errors,120,interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,1,['error'],['errors']
Availability,// This is an impossible to repair cost.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:28,repair,repair,28,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,1,['repair'],['repair']
Availability,// This is an input error,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:20,error,error,20,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,1,['error'],['error']
Availability,// This is an internal ID used for debugging logical elements. It is used; // for cases where an unique offset within the binary input file is not; // available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/LogicalView/Core/LVObject.h:151,avail,available,151,interpreter/llvm-project/llvm/include/llvm/DebugInfo/LogicalView/Core/LVObject.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/LogicalView/Core/LVObject.h,1,['avail'],['available']
Availability,"// This is called in error return path, no need to maintain CallStack.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:21,error,error,21,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,1,['error'],['error']
Availability,"// This is definitely an error in C++98. It's probably meant to; // be forbidden in C++0x, too, but the specification is just; // poorly written.; //; // The problem is with declarations like the following:; // template <T> friend A<T>::foo;; // where deciding whether a class C is a friend or not now hinges; // on whether there exists an instantiation of A that causes; // 'foo' to equal C. There are restrictions on class-heads; // (which we declare (by fiat) elaborated friend declarations to; // be) that makes this tractable.; //; // FIXME: handle ""template <> friend class A<T>;"", which; // is possibly well-formed? Who even knows?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:25,error,error,25,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['error'],['error']
Availability,"// This is dubious and is added to be compatible with gcc. In gcc, it is; // also allowed assigning a protocol-qualified 'id' type to a LHS object; // when protocol in qualified LHS is in list of protocols in the rhs 'id'; // object. This IMO, should be a bug.; // FIXME: Treat this as an extension, and flag this as an error when GCC; // extensions are not enabled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:320,error,error,320,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,1,['error'],['error']
Availability,// This is effectively the intersection of isTrivialType and; // isStandardLayoutType. We implement it directly to avoid redundant; // conversions from a type to a CXXRecordDecl.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:121,redundant,redundant,121,interpreter/llvm-project/clang/lib/AST/Type.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp,1,['redundant'],['redundant']
Availability,"// This is how the math works out:; //; // %rsp grows (i.e. gets lower) left to right. Each box below is; // one word (eight bytes). Obj0 is the stack slot we're trying to; // get to.; //; // ----------------------------------; // | BP | Obj0 | Obj1 | ... | ObjN |; // ----------------------------------; // ^ ^ ^ ^; // A B C E; //; // A is the incoming stack pointer.; // (B - A) is the local area offset (-8 for x86-64) [1]; // (C - A) is the Offset returned by MFI.getObjectOffset for Obj0 [2]; //; // |(E - B)| is the StackSize (absolute value, positive). For a; // stack that grown down, this works out to be (B - E). [3]; //; // E is also the value of %rsp after stack has been set up, and we; // want (C - E) -- the value we can add to %rsp to get to Obj0. Now; // (C - E) == (C - A) - (B - A) + (B - E); // { Using [1], [2] and [3] above }; // == getObjectOffset - LocalAreaOffset + StackSize",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:587,down,down,587,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,1,['down'],['down']
Availability,"// This is ill-formed, but provide the context that we would have; // declared the function in, if we were permitted to, for error recovery.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:125,error,error,125,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,2,"['error', 'recover']","['error', 'recovery']"
Availability,"// This is intentionally placed after the narrowing transforms for; // efficiency (transform directly to the narrow logic op if possible).; // If the mask is only needed on one incoming arm, push the 'and' op up.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:150,mask,mask,150,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['mask'],['mask']
Availability,"// This is likely to be an internal error, if treeReadEntry was not in range; // (or intentionally -2 for TChain::GetEntries) then something happened; // that is very odd/surprising.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:36,error,error,36,tree/tree/src/TChain.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx,1,['error'],['error']
Availability,// This is not a mask we can handle,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:17,mask,mask,17,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,// This is not a situation that we should recover from.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:42,recover,recover,42,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['recover'],['recover']
Availability,"// This is not an error in C++17 onwards, unless the noexceptness doesn't; // match, but in that case we have a full-on type mismatch, not just a; // type sugar mismatch.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:18,error,error,18,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,1,['error'],['error']
Availability,// This is not crashing on bad input: we should only reach this if the; // internal compiler logic is faulty; see getFormForIdxParent.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp:102,fault,faulty,102,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,1,['fault'],['faulty']
Availability,// This is only available for VP SDNodes,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.cpp:16,avail,available,16,interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.cpp,2,['avail'],['available']
Availability,"// This is only used for testing the function import pass via opt, where we; // don't have prevailing information from the LTO context available, so just; // conservatively assume everything is prevailing (which is fine for the very; // limited use of prevailing checking in this pass).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:135,avail,available,135,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,1,['avail'],['available']
Availability,"// This is problematic if the user calls the await_suspend standalone. But on; // the on hand, it is not incorrect semantically since inlining is not part; // of the standard. On the other hand, it is relatively rare to call; // the await_suspend function standalone.; //; // And given we've already had the long-term plan, the current workaround; // looks relatively tolerant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:368,toler,tolerant,368,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,1,['toler'],['tolerant']
Availability,// This is recovered from gcc output.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/PPC.cpp:11,recover,recovered,11,interpreter/llvm-project/clang/lib/CodeGen/Targets/PPC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/PPC.cpp,3,['recover'],['recovered']
Availability,"// This is the ""size or nmemb is zero"" case.; // Just return 0, do nothing more (not clear the error flags).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:95,error,error,95,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,1,['error'],['error']
Availability,// This is the block mask. We OR all incoming edges.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:21,mask,mask,21,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['mask'],['mask']
Availability,"// This is the case that we are selecting to S_CBRANCH_VCCNZ. We have not; // analyzed what generates the vcc value, so we do not know whether vcc; // bits for disabled lanes are 0. Thus we need to mask out bits for; // disabled lanes.; //; // For the case that we select S_CBRANCH_SCC1 and it gets; // changed to S_CBRANCH_VCCNZ in SIFixSGPRCopies, SIFixSGPRCopies calls; // SIInstrInfo::moveToVALU which inserts the S_AND).; //; // We could add an analysis of what generates the vcc value here and omit; // the S_AND when is unnecessary. But it would be better to add a separate; // pass after SIFixSGPRCopies to do the unnecessary S_AND removal, so it; // catches both cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelDAGToDAG.cpp:198,mask,mask,198,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelDAGToDAG.cpp,1,['mask'],['mask']
Availability,"// This is the point where 'as' creates actual symbols for indirect symbols; // (in the following two passes). It would be easier for us to do this sooner; // when we see the attribute, but that makes getting the order in the symbol; // table much more complicated than it is worth.; //; // FIXME: Revisit this when the dust settles.; // Report errors for use of .indirect_symbol not in a symbol pointer section; // or stub section.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp:345,error,errors,345,interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp,1,['error'],['errors']
Availability,// This is the second register being specified - expand the Reg operand; // into a mask first.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp:83,mask,mask,83,interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp,1,['mask'],['mask']
Availability,// This is the simple case where we are the outermost finally. All we; // have to do here is make sure we escape this and recover it in the; // outlined handler.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:122,recover,recover,122,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,1,['recover'],['recover']
Availability,"// This is to describe the memory location of the; // length of a Fortran deferred length string, so; // lock it down as such.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp:113,down,down,113,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp,1,['down'],['down']
Availability,"// This is to describe the memory location of the; // string, so lock it down as such.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp:73,down,down,73,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp,1,['down'],['down']
Availability,"// This is to terminate properly remote proofd in case of failure",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TRootAuth.cxx:58,failure,failure,58,net/auth/src/TRootAuth.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TRootAuth.cxx,1,['failure'],['failure']
Availability,"// This is used in debug builds only for now because some downstream users; // may hit this assert in their subsequent merges.; // There are still places in the analyzer where equal bitwidth Locs; // are compared, and need to be found and corrected. Recent previous fixes have; // addressed the known problems of making NULLs with specific bitwidths; // for Loc comparisons along with deprecation of APIs for the same purpose.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:58,down,downstream,58,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,1,['down'],['downstream']
Availability,"// This is used to handle spills for 128/256-bit registers when we have AVX512,; // but not VLX. If it uses an extended register we need to use an instruction; // that loads the lower 128/256-bit, but is available with only AVX512F.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:204,avail,available,204,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['avail'],['available']
Availability,"// This is used to handle spills for 128/256-bit registers when we have AVX512,; // but not VLX. If it uses an extended register we need to use an instruction; // that stores the lower 128/256-bit, but is available with only AVX512F.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:205,avail,available,205,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['avail'],['available']
Availability,"// This is well-defined for any case except where offset is strictly; // greater than the current length. If offset is equal to the current; // length, we can still grow. If offset is beyond the current length, we; // would have to decide how to deal with the intermediate uninitialized; // bytes. So we punt on that case for simplicity and just say it's an; // error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryByteStream.h:362,error,error,362,interpreter/llvm-project/llvm/include/llvm/Support/BinaryByteStream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryByteStream.h,1,['error'],['error']
Availability,"// This isn't a great error message, but this should never occur in real; // code anyway -- you'd have to create a buffer longer than a size_t can; // represent, which is sort of a contradiction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:22,error,error,22,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,1,['error'],['error']
Availability,"// This isn't an availability checking 'if', we can just continue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:17,avail,availability,17,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,1,['avail'],['availability']
Availability,"// This isn't available for ArrayType, but is for the ArrayTypeLoc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/RecursiveASTVisitor.h:14,avail,available,14,interpreter/llvm-project/clang/include/clang/AST/RecursiveASTVisitor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/RecursiveASTVisitor.h,1,['avail'],['available']
Availability,"// This isn't ideal, but it's better than reporting an empty string as; // the error in this case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h:79,error,error,79,interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h,1,['error'],['error']
Availability,"// This isn't particularly efficient, but is only for error-recovery.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/JSON.cpp:54,error,error-recovery,54,interpreter/llvm-project/llvm/lib/Support/JSON.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/JSON.cpp,1,['error'],['error-recovery']
Availability,"// This isn't strictly true. If the user were to provide exactly the same; // matchers as the original operand then we could allow it. However, it's; // simpler to not permit the redundant specification.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelEmitter.cpp:179,redundant,redundant,179,interpreter/llvm-project/llvm/utils/TableGen/GlobalISelEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelEmitter.cpp,1,['redundant'],['redundant']
Availability,// This likely will be a condition code mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp:40,mask,mask,40,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,1,['mask'],['mask']
Availability,"// This load needs splitting into power of 2 sized loads.; //; // Our strategy here is to generate anyextending loads for the smaller; // types up to next power-2 result type, and then combine the two larger; // result values together, before truncating back down to the non-pow-2; // type.; // E.g. v1 = i24 load =>; // v2 = i32 zextload (2 byte); // v3 = i32 load (1 byte); // v4 = i32 shl v3, 16; // v5 = i32 or v4, v2; // v1 = i24 trunc v5; // By doing this we generate the correct truncate which should get; // combined away as an artifact with a matching extend.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:259,down,down,259,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,1,['down'],['down']
Availability,// This loop iterates the AvailableIn/Out sets until it converges.; // The AvailableIn and AvailableOut sets decrease as we iterate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:26,Avail,AvailableIn,26,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,3,['Avail'],"['AvailableIn', 'AvailableOut']"
Availability,// This loop scans instructions after BBI to see if there is any; // redundant load immediate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:69,redundant,redundant,69,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,1,['redundant'],['redundant']
Availability,"// This macro makes available a variable D, the passed-in decl.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/RecursiveASTVisitor.h:20,avail,available,20,interpreter/llvm-project/clang/include/clang/AST/RecursiveASTVisitor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/RecursiveASTVisitor.h,1,['avail'],['available']
Availability,// This matches patterns corresponding to tests of the signbit as well as:; // (trunc X) u< C --> (X & -C) == 0 (are all masked-high-bits clear?); // (trunc X) u> C --> (X & ~C) != 0 (are any masked-high-bits set?),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:121,mask,masked-high-bits,121,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,2,['mask'],['masked-high-bits']
Availability,// This may be the module cache directory.; // Only cache stat failures on files that are not expected to change during; // the build.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp:63,failure,failures,63,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp,1,['failure'],['failures']
Availability,"// This may have been the file, return with error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/KillTheDoctor/KillTheDoctor.cpp:44,error,error,44,interpreter/llvm-project/llvm/utils/KillTheDoctor/KillTheDoctor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/KillTheDoctor/KillTheDoctor.cpp,1,['error'],['error']
Availability,"// This method acts upon CFG elements for logical operators && and ||; // and attaches the value (true or false) to them as expressions.; // It doesn't produce any state splits.; // If we made it that far, we're past the point when we modeled the short; // circuit. It means that we should have precise knowledge about whether; // we've short-circuited. If we did, we already know the value we need to; // bind. If we didn't, the value of the RHS (casted to the boolean type); // is the answer.; // Currently this method tries to figure out whether we've short-circuited; // by looking at the ExplodedGraph. This method is imperfect because there; // could inevitably have been merges that would have resulted in multiple; // potential path traversal histories. We bail out when we fail.; // Due to this ambiguity, a more reliable solution would have been to; // track the short circuit operation history path-sensitively until; // we evaluate the respective logical operator.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:822,reliab,reliable,822,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,1,['reliab'],['reliable']
Availability,"// This method takes the specified list of LLVM input files, attempts to load; // them, either as assembly or bitcode, then link them together. It returns; // true on failure (if, for example, an input bitcode file could not be; // parsed), and false on success.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp:167,failure,failure,167,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp,1,['failure'],['failure']
Availability,"// This method tries to handle some special cases for the vselect mask; // and if needed adjusting the mask vector type to match that of the VSELECT.; // Without it, many cases end up with scalarization of the SETCC, with many; // unnecessary instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:66,mask,mask,66,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,2,['mask'],['mask']
Availability,"// This might be worth an error message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TMemberInspector.cxx:26,error,error,26,core/base/src/TMemberInspector.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TMemberInspector.cxx,1,['error'],['error']
Availability,"// This might get called recursively, or a billion of times. Do not generate; // useless output; unresolvedSymbol() is always handed out with an error; // message - that's enough.; //cling::errs() << ""IncrementalExecutor: calling unresolved symbol, ""; // ""see previous error message!\n"";; // throw exception instead?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalExecutor.cpp:145,error,error,145,interpreter/cling/lib/Interpreter/IncrementalExecutor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalExecutor.cpp,2,['error'],['error']
Availability,// This must be a syntax error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp:25,error,error,25,interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp,1,['error'],['error']
Availability,"// This needs to be a build vector of booleans.; // TODO: Checking for the i1 type matches the IR definition for the mask,; // but the mask check could be loosened to i8 or other types. That might; // also require checking more than 'allOnesValue'; eg, the x86 HW; // instructions only require that the MSB is set for each mask element.; // The ISD::MSTORE comments/definition do not specify how the mask operand; // is formatted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:117,mask,mask,117,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,4,['mask'],['mask']
Availability,"// This numbering assigns one state number to each catchpad and cleanuppad.; // It also computes two tree-like relations over states:; // 1) Each state has a ""HandlerParentState"", which is the state of the next; // outer handler enclosing this state's handler (same as nearest ancestor; // per the ParentPad linkage on EH pads, but skipping over catchswitches).; // 2) Each state has a ""TryParentState"", which:; // a) for a catchpad that's not the last handler on its catchswitch, is; // the state of the next catchpad on that catchswitch; // b) for all other pads, is the state of the pad whose try region is the; // next outer try region enclosing this state's try region. The ""try; // regions are not present as such in the IR, but will be inferred; // based on the placement of invokes and pads which reach each other; // by exceptional exits; // Catchswitches do not get their own states, but each gets mapped to the; // state of its first catchpad.; // Step one: walk down from outermost to innermost funclets, assigning each; // catchpad and cleanuppad a state number. Add an entry to the; // ClrEHUnwindMap for each state, recording its HandlerParentState and; // handler attributes. Record the TryParentState as well for each catchpad; // that's not the last on its catchswitch, but initialize all other entries'; // TryParentStates to a sentinel -1 value that the next pass will update.; // Seed a worklist with pads that have no parent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:974,down,down,974,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,1,['down'],['down']
Availability,"// This numerical error condition should never occur:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:18,error,error,18,hist/hist/src/TH1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx,3,['error'],['error']
Availability,"// This only gets called during static destruction, in which case the; // PassRegistry will have already been destroyed by llvm_shutdown(). So; // attempting to remove the registration listener is an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Pass.cpp:200,error,error,200,interpreter/llvm-project/llvm/lib/IR/Pass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Pass.cpp,1,['error'],['error']
Availability,"// This only gets set when Neon instructions are actually available, unlike; // the VFP define, hence the soft float and arch check. This is subtly; // different from gcc, we follow the intent which was that it should be set; // when Neon instructions are actually available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp:58,avail,available,58,interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp,2,['avail'],['available']
Availability,"// This only looks at shuffles with elements that are; // a) truncated by a constant AND mask extracted from a mask vector, or; // b) extracted directly from a mask vector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:89,mask,mask,89,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,3,['mask'],['mask']
Availability,"// This operand encodes a mask of contiguous zeros between a specified MSB; // and LSB. To decode it, we create the mask of all bits MSB-and-lower,; // the mask of all bits LSB-and-lower, and then xor them to create; // the mask of that's all ones on [msb, lsb]. Finally we not it to; // create the final mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:26,mask,mask,26,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,5,['mask'],['mask']
Availability,"// This operation also isn't safe with AND, OR, XOR when the boolean type is; // 0/1 and the select operands aren't also booleans, as we need an all-ones; // vector constant to mask with.; // FIXME: Sign extend 1 to all ones if that's legal on the target.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp:177,mask,mask,177,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,1,['mask'],['mask']
Availability,// This option shows static (relative) call counts.; // FIXME:; // Need to show real counts when profile data is available,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallPrinter.cpp:113,avail,available,113,interpreter/llvm-project/llvm/lib/Analysis/CallPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallPrinter.cpp,1,['avail'],['available']
Availability,"// This overload is chosen when the callable passed to Define or DefineSlot returns void.; // It simply fires a compile-time error. This is preferable to a static_assert in the main `Define` overload because; // this way compilation of `Define` has no way to continue after throwing the error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:125,error,error,125,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,2,['error'],['error']
Availability,"// This promotion is not profitable, rollback to the previous state, and; // save the current extension in ProfitablyMovedExts as the latest; // speculative promotion turned out to be unprofitable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:37,rollback,rollback,37,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['rollback'],['rollback']
Availability,// This realignment carries over to the available bytes below. Our own; // callers will guarantee the space is free by giving an aligned value to; // CALLSEQ_START.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:40,avail,available,40,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['avail'],['available']
Availability,// This register class doesn't allocate k0 for masked vector operation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:47,mask,masked,47,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['masked']
Availability,// This rejects kInvalidStreamIndex with an error as well.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/PDBFile.cpp:44,error,error,44,interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/PDBFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/PDBFile.cpp,1,['error'],['error']
Availability,// This required for .td selection patterns to work or we'd end up with RegClass; // checks being redundant as all the classes would be mapped to the same bank.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVRegisterBankInfo.cpp:98,redundant,redundant,98,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVRegisterBankInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVRegisterBankInfo.cpp,1,['redundant'],['redundant']
Availability,// This returns false if this function recognizes the directive; // regardless of whether it is successfully handles or reports an; // error. Otherwise it returns true to give the generic parser a; // chance at recognizing it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:135,error,error,135,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,1,['error'],['error']
Availability,// This should be guaranteed to add RequiredPass to the passmanager given; // that we checked for an available analysis above.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:101,avail,available,101,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,1,['avail'],['available']
Availability,"// This should be pulled down",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/test/testHistFactory.cxx:25,down,down,25,roofit/histfactory/test/testHistFactory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/test/testHistFactory.cxx,1,['down'],['down']
Availability,// This should never return an error as `processNewSymbol` wouldn't have been; // called if getFlags() returned an error before.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:31,error,error,31,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,2,['error'],['error']
Availability,"// This should not need a cast (ie. BindCppObjectNoCast), but performing the cast; // here means callbacks receive down-casted object when passed by-ptr, which is; // needed for object identity. The latter case is assumed to be more common than; // conversion of (global) objects.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx:115,down,down-casted,115,bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx,1,['down'],['down-casted']
Availability,// This should only occur in the error case; // since the optID has been replaced by a more granular; // floating point option.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:33,error,error,33,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['error'],['error']
Availability,"// This should really always be an i1, but sometimes it's already; // an i8, and it's awkward to track those cases down.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:115,down,down,115,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['down'],['down']
Availability,"// This should return a register mask that is the same as that returned by; // getCallPreservedMask but that additionally preserves the register used for; // the first i32 argument (which must also be the register used to return a; // single i32 return value); //; // In case that the calling convention does not use the same register for; // both or otherwise does not want to enable this optimization, the function; // should return NULL",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseRegisterInfo.cpp:33,mask,mask,33,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseRegisterInfo.cpp,1,['mask'],['mask']
Availability,"// This should return a register mask that is the same as that returned by; // getCallPreservedMask but that additionally preserves the register used for; // the first i64 argument (which must also be the register used to return a; // single i64 return value); //; // In case that the calling convention does not use the same register for; // both, the function should return NULL (does not currently apply)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64RegisterInfo.cpp:33,mask,mask,33,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64RegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64RegisterInfo.cpp,1,['mask'],['mask']
Availability,// This shuffle index refers to the inner shuffle N0. Lookup the inner; // shuffle mask to identify which vector is actually referenced.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:83,mask,mask,83,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['mask'],['mask']
Availability,"// This situation can occur:; //; // ,------.; // | |; // | v; // | t2 = phi ... t1 ...; // | |; // | v; // | t1 = ...; // | ... = ... t1 ...; // | |; // `------'; //; // where there is a use in a PHI node that's a predecessor to the defining; // block. We don't want to mark all predecessors as having the value ""alive""; // in this case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:314,alive,alive,314,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,1,['alive'],['alive']
Availability,// This specialization ensures that 'AdjustedParam<V<T>&>' or; // 'AdjustedParam<V<T>&&>' does not trigger a compile-time error when 'T' is; // an incomplete type and V a templated type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FunctionExtras.h:122,error,error,122,interpreter/llvm-project/llvm/include/llvm/ADT/FunctionExtras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FunctionExtras.h,1,['error'],['error']
Availability,// This storage is shared between disparate class hierarchies to hold an; // enumeration specific to the class hierarchy in use.; // LSBaseSDNode => enum ISD::MemIndexedMode; // VPLoadStoreBaseSDNode => enum ISD::MemIndexedMode; // MaskedLoadStoreBaseSDNode => enum ISD::MemIndexedMode; // VPGatherScatterSDNode => enum ISD::MemIndexType; // MaskedGatherScatterSDNode => enum ISD::MemIndexType,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:232,Mask,MaskedLoadStoreBaseSDNode,232,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,2,['Mask'],"['MaskedGatherScatterSDNode', 'MaskedLoadStoreBaseSDNode']"
Availability,"// This struct is for use by ActOnMemberAccess to allow; // BuildMemberReferenceExpr to be able to reinvoke ActOnMemberAccess after; // changing the access operator from a '.' to a '->' (to see if that is the; // change needed to fix an error about an unknown member, e.g. when the class; // defines a custom operator->).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:237,error,error,237,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['error'],['error']
Availability,"// This symbol is used in testcases, but we're not reflecting process; // symbols so we'll need to make it available some other way.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:107,avail,available,107,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,1,['avail'],['available']
Availability,// This syscall signals a driver assertion failure in x86 NT kernels.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:43,failure,failure,43,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,1,['failure'],['failure']
Availability,// This table describes sign- and zero-extend instructions which can be; // folded into a preceding load. All of these extends have an immediate; // (sometimes a mask and sometimes a shift) that's applied after; // extension.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp:162,mask,mask,162,interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp,1,['mask'],['mask']
Availability,"// This table shows the VPT instruction variants, i.e. the different; // mask field encodings, see also B5.6. Predication/conditional execution in; // the ArmARM.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.h:73,mask,mask,73,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.h,1,['mask'],['mask']
Availability,"// This target-overriden function exists to maintain current behaviour for; // e.g.; // dahi $3, $3, 0x5678; // as tested in test/MC/Mips/mips64r6/valid.s.; // FIXME: Should this test actually fail with an error? If so, then remove; // this overloaded method.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:206,error,error,206,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,1,['error'],['error']
Availability,"// This template-id is terminated by a token that starts with a '>'.; // Outside C++11 and Objective-C, this is now error recovery.; //; // C++11 allows this when the token is '>>', and in CUDA + C++11 mode, we; // extend that treatment to also apply to the '>>>' token.; //; // Objective-C allows this in its type parameter / argument lists.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:116,error,error,116,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,2,"['error', 'recover']","['error', 'recovery']"
Availability,"// This test has been disabled in favor of the pub-sub connection check in the Messenger ctor, which is more robust",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/test/test_Messenger.cxx:109,robust,robust,109,roofit/multiprocess/test/test_Messenger.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/test/test_Messenger.cxx,1,['robust'],['robust']
Availability,"// This tests that at least one bit in the bitset is available.; // When we are down to one bitset, we'll have to expand the field.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/test/TBasket.cxx:53,avail,available,53,tree/tree/test/TBasket.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/test/TBasket.cxx,2,"['avail', 'down']","['available', 'down']"
Availability,"// This tests the analytical integration of RooParamHistFunc; // after the RooParamHistFunc has been cloned.; // The test was inspired by this error reported on the forum:; // https://root-forum.cern.ch/t/barlow-beeston-in-subrange/43909/5",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/testRooParamHistFunc.cxx:143,error,error,143,roofit/roofit/test/testRooParamHistFunc.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/testRooParamHistFunc.cxx,1,['error'],['error']
Availability,"// This time, the stored carry in sum is again negative because it still has to be added. This is; // in contrast to the case above where the floating point sum already yielded a higher Sum value,; // but in fact should be corrected downwards by the Carry term (which was hence positive in; // SmallestLargeEnoughCarry).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/testKahan.cxx:233,down,downwards,233,math/mathcore/test/testKahan.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/testKahan.cxx,1,['down'],['downwards']
Availability,"// This transform does not have the speculative execution constraint as; // below because the shuffle is a concatenation. The new binops are; // operating on exactly the same elements as the existing binop.; // TODO: We could ease the mask requirement to allow different undef lanes,; // but that requires an analysis of the binop-with-undef output value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:235,mask,mask,235,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['mask'],['mask']
Availability,"// This transformation has a high risk of corrupting the dominator tree, and; // the below steps to rebuild loop structures will result in hard to debug; // errors in that case so verify that the dominator tree is sane first.; // FIXME: Remove this when the bugs stop showing up and rely on existing; // verification steps.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:157,error,errors,157,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,1,['error'],['errors']
Availability,"// This type index is invalid. Remap this to ""not translated by cvpack"",; // and return failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/TypeStreamMerger.cpp:88,failure,failure,88,interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/TypeStreamMerger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/TypeStreamMerger.cpp,1,['failure'],['failure']
Availability,"// This value is used to determine if a register class is a high pressure set.; // We compute the maximum number of registers needed and divided by the total; // available. Then, we compare the result to this value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:162,avail,available,162,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,1,['avail'],['available']
Availability,"// This vector contains the coordinate errors; // in the same way as fCoords.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/BinData.h:39,error,errors,39,math/mathcore/inc/Fit/BinData.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/BinData.h,1,['error'],['errors']
Availability,"// This vector contains the data error.; // Either only fDataError or fDataErrorHigh and fDataErrorLow are used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/BinData.h:33,error,error,33,math/mathcore/inc/Fit/BinData.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/BinData.h,1,['error'],['error']
Availability,"// This version of error() prints the archive name and member name, for example:; // ""libx.a(foo.o)"" after the ToolName before the error message. It sets; // HadError but returns allowing the code to move on to other archive members.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp:19,error,error,19,interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp,4,['error'],['error']
Availability,"// This version of error() prints the file name and which architecture slice it // is from, for example: ""foo.o (for architecture i386)"" after the ToolName; // before the error message. It sets HadError but returns allowing the code to; // move on to other architecture slices.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-size/llvm-size.cpp:19,error,error,19,interpreter/llvm-project/llvm/tools/llvm-size/llvm-size.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-size/llvm-size.cpp,2,['error'],['error']
Availability,"// This version of error() prints the file name and which architecture slice it; // is from, for example: ""foo.o (for architecture i386)"" after the ToolName; // before the error message. It sets HadError but returns allowing the code to; // move on to other architecture slices.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp:19,error,error,19,interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp,2,['error'],['error']
Availability,"// This virtual method overrides other virtual methods, so it does; // not add any new slots into the set of overriders. Instead, we; // replace entries in the set of overriders with the new; // overrider. To do so, we dig down to the original virtual; // functions using data recursion and update all of the methods it; // overrides.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:223,down,down,223,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,1,['down'],['down']
Availability,"// This warning might be triggered while holding the ROOT lock, while; // some other thread is holding the GIL and waiting for the ROOT lock.; // That will trigger a deadlock.; // So if ROOT is in MT mode, use ROOT's error handler that doesn't take; // the GIL.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/src/RPyROOTApplication.cxx:217,error,error,217,bindings/pyroot/pythonizations/src/RPyROOTApplication.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/src/RPyROOTApplication.cxx,1,['error'],['error']
Availability,"// This will be 0 for sibcalls, potentially nonzero for tail calls produced; // by -tailcallopt. For sibcalls, the memory operands for the call are; // already available in the caller's incoming argument space.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64CallLowering.cpp:160,avail,available,160,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64CallLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64CallLowering.cpp,2,['avail'],['available']
Availability,// This will generate an error message,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:25,error,error,25,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,4,['error'],['error']
Availability,"// This will only catch ExceptionX but not RException. In case rv mistakenly throws an exception,; // we would notice the test failure by a crash of the unit test.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/v7/test/base_exception.cxx:127,failure,failure,127,core/foundation/v7/test/base_exception.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/v7/test/base_exception.cxx,1,['failure'],['failure']
Availability,"// This would be the logical way to do things, but floating point errors.; // return Math.round( value / this._step ) * this._step;; // Using inverse step solves a lot of them, but not all; // const inverseStep = 1 / this._step;; // return Math.round( value * inverseStep ) / inverseStep;; // Not happy about this, but haven't seen it break.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:66,error,errors,66,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['error'],['errors']
Availability,"// Throughout the calculation, we use Kahan's algorithm for summing to; // prevent loss of precision - this is a factor four more expensive than; // straight addition, but since evaluating the PDF is usually much more; // expensive than that, we tolerate the additional cost...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNLLVar.cxx:246,toler,tolerate,246,roofit/roofitcore/src/RooNLLVar.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNLLVar.cxx,3,['toler'],['tolerate']
Availability,"// Throw error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RReader.hxx:9,error,error,9,tmva/tmva/inc/TMVA/RReader.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RReader.hxx,1,['error'],['error']
Availability,// Throw error if not a valid IR object file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/llvm-libtool-darwin.cpp:9,error,error,9,interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/llvm-libtool-darwin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/llvm-libtool-darwin.cpp,1,['error'],['error']
Availability,// Throw error if not a valid object file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/llvm-libtool-darwin.cpp:9,error,error,9,interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/llvm-libtool-darwin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/llvm-libtool-darwin.cpp,1,['error'],['error']
Availability,// Throw error if not in Mach-O format.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/llvm-libtool-darwin.cpp:9,error,error,9,interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/llvm-libtool-darwin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/llvm-libtool-darwin.cpp,1,['error'],['error']
Availability,// Throw errors for invalid RPaths.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObjcopy.cpp:9,error,errors,9,interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObjcopy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObjcopy.cpp,1,['error'],['errors']
Availability,"// Throwing ExceptionX will destruct rv along the way. Since rv carries an error state, it would normally; // throw an exception itself. In this test, we verify that rv surpresses throwing an exception if another; // exception is currently active.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/v7/test/base_exception.cxx:75,error,error,75,core/foundation/v7/test/base_exception.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/v7/test/base_exception.cxx,1,['error'],['error']
Availability,"// Thumb1 has very limited immediate modes, so turning an ""and"" into a; // shift can save multiple instructions.; //; // If we have (x & C1), and C1 is an appropriate mask, we can transform it; // into ""((x << n) >> n)"". But that isn't necessarily profitable on its; // own. If it's the operand to an unsigned comparison with an immediate,; // we can eliminate one of the shifts: we transform; // ""((x << n) >> n) == C2"" to ""(x << n) == (C2 << n)"".; //; // We avoid transforming cases which aren't profitable due to encoding; // details:; //; // 1. C2 fits into the immediate field of a cmp, and the transformed version; // would not; in that case, we're essentially trading one immediate load for; // another.; // 2. C1 is 255 or 65535, so we can use uxtb or uxth.; // 3. C2 is zero; we have other code for this special case.; //; // FIXME: Figure out profitability for Thumb2; we usually can't save an; // instruction, since the AND is always one instruction anyway, but we could; // use narrow instructions in some cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:167,mask,mask,167,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['mask'],['mask']
Availability,"// Tighten the stat. errors of the model, and kick bin 0, so the gammas have to adapt",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/test/testHistFactory.cxx:21,error,errors,21,roofit/histfactory/test/testHistFactory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/test/testHistFactory.cxx,1,['error'],['errors']
Availability,"// To avoid inserting redundant assumptions, we should check for assumptions; // already in the caller. To do this, we might need a DT of the caller.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:22,redundant,redundant,22,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,1,['redundant'],['redundant']
Availability,"// To avoid overflow down, we need to make sure that MIN + Magnitude <= LHS.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:21,down,down,21,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['down'],['down']
Availability,"// To avoid to rebuild the particle list from multiple threads, we check if at; // the moment of invoked ReadPDGTableImpl, the list was initialized. If it was not, and now it is, another; // thread filled it. Doing so again would result in an error.; // However, if the particle list was not initialized when ReadPDGTableImpl was invoked and it is still empty,; // we fill it.; // With the protection described above, ReadPDGTable can be invoked multiple times, for example once; // automatically by the system lazily and a second time by the user to complement the information; // already in memory with a second input file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/montecarlo/eg/src/TDatabasePDG.cxx:243,error,error,243,montecarlo/eg/src/TDatabasePDG.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/montecarlo/eg/src/TDatabasePDG.cxx,1,['error'],['error']
Availability,// To bring the Physical VGPRs in the highest range allocated for CSR SGPR; // spilling into the lowest available range.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.h:104,avail,available,104,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.h,1,['avail'],['available']
Availability,"// To calculate scalar take the regular cost, without mask",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:54,mask,mask,54,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['mask'],['mask']
Availability,"// To make ROOT::RangeDynCast available under the dynamic_range_cast.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsCollection.h:30,avail,available,30,roofit/roofitcore/inc/RooAbsCollection.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsCollection.h,1,['avail'],['available']
Availability,"// To make ROOT::RangeStaticCast available under the name static_range_cast.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsCollection.h:33,avail,available,33,roofit/roofitcore/inc/RooAbsCollection.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsCollection.h,1,['avail'],['available']
Availability,// To make the algorithms available for C and C++ in CUDA and OpenMP we select; // different but equivalent function versions. TODO: For OpenMP we currently; // select the native builtins as the overload support for templates is lacking.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_complex_builtins.h:26,avail,available,26,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_complex_builtins.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_complex_builtins.h,1,['avail'],['available']
Availability,"// To make this helper be more convenient for error reporting purposes we; // drop the error. But really it should never be triggered. Before this point,; // our code should have called 'sections()' and reported a proper error on; // failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELF.h:46,error,error,46,interpreter/llvm-project/llvm/include/llvm/Object/ELF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELF.h,4,"['error', 'failure']","['error', 'failure']"
Availability,"// To match the canonical windows frame layout, reverse the list of; // callee saved registers to get them laid out by PrologEpilogInserter; // in the right order. (PrologEpilogInserter allocates stack objects top; // down. Windows canonical prologs store higher numbered registers at; // the top, thus have the CSI array start from the highest registers.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp:218,down,down,218,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,1,['down'],['down']
Availability,"// To preserve binary compatibility, the generic Itanium ABI has; // permanently locked the definition of POD to the rules of C++ TR1,; // and that trickles down to derived ABIs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetCXXABI.h:157,down,down,157,interpreter/llvm-project/clang/include/clang/Basic/TargetCXXABI.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetCXXABI.h,1,['down'],['down']
Availability,"// To print stack traces when caching errors are detected",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:38,error,errors,38,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,1,['error'],['errors']
Availability,"// To produce final result we need to blend 2 vectors: 'SetCC' and; // 'MaskedIsZero'. If the divisor for channel was *NOT* INT_MIN, we pick; // from 'Fold', else pick from 'MaskedIsZero'. Since 'DivisorIsIntMin' is; // constant-folded, select can get lowered to a shuffle with constant mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:72,Mask,MaskedIsZero,72,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,3,"['Mask', 'mask']","['MaskedIsZero', 'mask']"
Availability,// To save/restore EXEC MASK around WWM spills and copies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.h:24,MASK,MASK,24,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.h,1,['MASK'],['MASK']
Availability,"// To set up a tail-predicated loop, we need to know the total number of; // elements processed by that loop. Thus, we need to determine the element; // size and:; // 1) it should be uniform for all operations in the vector loop, so we; // e.g. don't want any widening/narrowing operations.; // 2) it should be smaller than i64s because we don't have vector operations; // that work on i64s.; // 3) we don't want elements to be reversed or shuffled, to make sure the; // tail-predication masks/predicates the right lanes.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:488,mask,masks,488,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,1,['mask'],['masks']
Availability,"// To start, set the number of redundant path components to the maximum; // possible value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp:31,redundant,redundant,31,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,1,['redundant'],['redundant']
Availability,"// To use the condition operand as a bitwise mask, it must have elements that; // are the same size as the select elements. Ie, the condition operand must; // have already been promoted from the IR select condition type <N x i1>.; // Don't check if the types themselves are equal because that excludes; // vector floating-point selects.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:45,mask,mask,45,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['mask'],['mask']
Availability,"// To zero extend, just mask off everything except for the first bit (in the; // i1 case).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:24,mask,mask,24,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['mask'],['mask']
Availability,// ToDo: add support for error operands to MCInst.h; // return MCOperand::createError(V);,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Disassembler/AMDGPUDisassembler.cpp:25,error,error,25,interpreter/llvm-project/llvm/lib/Target/AMDGPU/Disassembler/AMDGPUDisassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Disassembler/AMDGPUDisassembler.cpp,1,['error'],['error']
Availability,"// ToDo: case 248: 1/(2*PI) - is allowed only on VI; // ImmWidth 0 is a default case where operand should not allow immediates.; // Imm value is still decoded into 32 bit immediate operand, inst printer will; // use it to print verbose error message.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Disassembler/AMDGPUDisassembler.cpp:236,error,error,236,interpreter/llvm-project/llvm/lib/Target/AMDGPU/Disassembler/AMDGPUDisassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Disassembler/AMDGPUDisassembler.cpp,1,['error'],['error']
Availability,// ToDo: unclear if s[100:104] is available on VI. Can we use VCC as SGPR in; // this bundle?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Disassembler/AMDGPUDisassembler.cpp:34,avail,available,34,interpreter/llvm-project/llvm/lib/Target/AMDGPU/Disassembler/AMDGPUDisassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Disassembler/AMDGPUDisassembler.cpp,1,['avail'],['available']
Availability,// ToDo: unclear if s[88:104] is available on VI. Can we use VCC as SGPR in; // this bundle?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Disassembler/AMDGPUDisassembler.cpp:33,avail,available,33,interpreter/llvm-project/llvm/lib/Target/AMDGPU/Disassembler/AMDGPUDisassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Disassembler/AMDGPUDisassembler.cpp,1,['avail'],['available']
Availability,// ToDo: unclear if s[96:104] is available on VI. Can we use VCC as SGPR in; // this bundle?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Disassembler/AMDGPUDisassembler.cpp:33,avail,available,33,interpreter/llvm-project/llvm/lib/Target/AMDGPU/Disassembler/AMDGPUDisassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Disassembler/AMDGPUDisassembler.cpp,1,['avail'],['available']
Availability,// Todo(1): In many cases it may be provable that SI is less than; // ShiftBits in which case this mask is unnecessary; // Todo(2): In the fairly idiomatic case of P[X / sizeof_bits(X)] OP 1; // << (X % sizeof_bits(X)) we can drop the shift mask and AGEN in; // favor of just a raw BT{S|R|C}.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:99,mask,mask,99,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['mask'],['mask']
Availability,"// TokenFactor operands are considered zero latency, and some schedulers; // (e.g. Top-Down list) may rely on the fact that operand latency is nonzero; // whenever node latency is nonzero.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp:87,Down,Down,87,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,1,['Down'],['Down']
Availability,// TokenQueue can be empty if there was an error getting the next token.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp:43,error,error,43,interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp,1,['error'],['error']
Availability,"// Tokenize Input.; // In case no error occurred, the return value contains; // tokens in order they were in the input file.; // In case of any error, the return value contains; // a textual representation of error.; //; // Tokens returned by this function hold only references to the parts; // of the Input. Memory buffer containing Input cannot be freed,; // modified or reallocated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rc/ResourceScriptToken.h:34,error,error,34,interpreter/llvm-project/llvm/tools/llvm-rc/ResourceScriptToken.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rc/ResourceScriptToken.h,3,['error'],['error']
Availability,// Tokens following an error in an ill-formed constant expression will; // remain in the token stream and must be removed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:23,error,error,23,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,2,['error'],['error']
Availability,// Tolerate empty base classes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:3,Toler,Tolerate,3,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['Toler'],['Tolerate']
Availability,// Tolerate printf's declared void.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:3,Toler,Tolerate,3,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,1,['Toler'],['Tolerate']
Availability,"// Tolerate signedness of int changing, as tags do not differentiate between; // them anyway.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocumentYAML.cpp:3,Toler,Tolerate,3,interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocumentYAML.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocumentYAML.cpp,1,['Toler'],['Tolerate']
Availability,// Tolerate zero-length; assume length is correct and soldier on.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFDebugLine.cpp:3,Toler,Tolerate,3,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFDebugLine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFDebugLine.cpp,1,['Toler'],['Tolerate']
Availability,// Top down: release successors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGVLIW.cpp:7,down,down,7,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGVLIW.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGVLIW.cpp,1,['down'],['down']
Availability,// Top-down walk of the dominator tree,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:7,down,down,7,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,2,['down'],['down']
Availability,"// Total horizontal space available for drawing",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlTable.cxx:26,avail,available,26,gui/guihtml/src/TGHtmlTable.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlTable.cxx,1,['avail'],['available']
Availability,"// Trace the arguments of an incomplete Phi node to see if they have the same; // canonical definition. If so, mark the Phi node as redundant.; // getCanonicalVal() will recursively call simplifyIncompletePhi().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp:132,redundant,redundant,132,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp,1,['redundant'],['redundant']
Availability,"// Track cycles contributed by resources that are in a ""Super"" relationship.; // This is required if we want to correctly match the behavior of method; // SubtargetEmitter::ExpandProcResource() in Tablegen. When computing the set; // of ""consumed"" processor resources and resource cycles, the logic in; // ExpandProcResource() doesn't update the number of resource cycles; // contributed by a ""Super"" resource to a group.; // We need to take this into account when we find that a processor resource is; // part of a group, and it is also used as the ""Super"" of other resources.; // This map stores the number of cycles contributed by sub-resources that are; // part of a ""Super"" resource. The key value is the ""Super"" resource mask ID.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/InstrBuilder.cpp:727,mask,mask,727,interpreter/llvm-project/llvm/lib/MCA/InstrBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/InstrBuilder.cpp,1,['mask'],['mask']
Availability,"// Track the index->register mapping because AllocationOrder doesn't do that; // and we'd have to scan it.; // Also track their mask, to write asserts/debug.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:128,mask,mask,128,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,1,['mask'],['mask']
Availability,"// Track the next DPValue to clone. If we have a sequence where an; // instruction is hoisted instead of being cloned:; // DPValue blah; // %foo = add i32 0, 0; // DPValue xyzzy; // %bar = call i32 @foobar(); // where %foo is hoisted, then the DPValue ""blah"" will be seen twice, once; // attached to %foo, then when %foo his hoisted it will ""fall down"" onto the; // function call:; // DPValue blah; // DPValue xyzzy; // %bar = call i32 @foobar(); // causing it to appear attached to the call too.; //; // To avoid this, cloneDebugInfoFrom takes an optional ""start cloning from; // here"" position to account for this behaviour. We point it at any DPValues; // on the next instruction, here labelled xyzzy, before we hoist %foo.; // Later, we only only clone DPValues from that position (xyzzy) onwards,; // which avoids cloning DPValue ""blah"" multiple times.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:347,down,down,347,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,1,['down'],['down']
Availability,// Track the operand that kill Reg. We would unset the kill flag of; // the operand if there is a following redundant load immediate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:108,redundant,redundant,108,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,1,['redundant'],['redundant']
Availability,"// Track the set of registers defined in the original block so we don't; // accidentally add the original block to AliveBlocks. AliveBlocks only; // includes blocks which are live through, which excludes live outs and; // local defs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerControlFlow.cpp:115,Alive,AliveBlocks,115,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerControlFlow.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerControlFlow.cpp,2,['Alive'],['AliveBlocks']
Availability,"// Track whether we hit an error; in particular, in the multi-threaded case,; // we can't exit() early because the rest of the threads wouldn't have had a; // change to be join-ed, and that would result in a ""terminate called without; // an active exception"". Altogether, this results in nondeterministic; // behavior. Instead, we don't exit in the multi-threaded case, but we make; // sure to report the error and then at the end (after joining cleanly); // exit(1).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto2/llvm-lto2.cpp:27,error,error,27,interpreter/llvm-project/llvm/tools/llvm-lto2/llvm-lto2.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto2/llvm-lto2.cpp,2,['error'],['error']
Availability,// Track zero-sized subobjects here where it's already available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:55,avail,available,55,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,1,['avail'],['available']
Availability,// Tracking of currently alive registers to determine VGPR Usage.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp:25,alive,alive,25,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,1,['alive'],['alive']
Availability,// Traditional behaviour seems to special case this particular value. It's; // not clear why other masks are handled differently.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:99,mask,masks,99,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,1,['mask'],['masks']
Availability,"// Transcribe the ""ios"" availability check to ""maccatalyst"" when compiling; // for ""maccatalyst"" if ""maccatalyst"" is not specified.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:24,avail,availability,24,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['avail'],['availability']
Availability,// Transfer aliveBlocks from Reg to NewReg,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeVGPRLiveRange.cpp:12,alive,aliveBlocks,12,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeVGPRLiveRange.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeVGPRLiveRange.cpp,1,['alive'],['aliveBlocks']
Availability,// Transfer successor information and move PHIs down to the; // branch-taken block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp:48,down,down,48,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp,1,['down'],['down']
Availability,"// Transform ""(X >> SHIFT) & (MASK << C1)"" to; // ""((X >> (SHIFT + C1)) & (MASK)) << C1"". Everything before the SHL will be; // matched to a BEXTR later. Returns false if the simplification is performed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:30,MASK,MASK,30,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,2,['MASK'],['MASK']
Availability,"// Transform ""icmp eq (trunc (lshr(X, cst1)), cst"" to; // ""icmp (and X, mask), cst""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:72,mask,mask,72,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['mask'],['mask']
Availability,// Transform lanemask to a mask in the joined live interval.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:27,mask,mask,27,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,1,['mask'],['mask']
Availability,// Transform lanemasks from the LHS to masks in the coalesced register and; // create initial subranges if necessary.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:39,mask,masks,39,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,1,['mask'],['masks']
