quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Usability,"d commands are executed in reverse order. const char * GetName() const; Returns the command name. Default name is ""ClassName::RedoName(args)""; If list of merged commands is not empty the name is; ""ClassName::RedoName(args):cname1:cname2 ..."". const char * GetTitle() const; Returns command description.; By default, ""ClassName::RedoName(args)_ClassName::UndoName(args)"". const char * GetRedoName() const; Returns the name of redo command. const char * GetUndoName() const; Returns the name of undo command. Long_t * GetRedoArgs() const; Returns a pointer to array of redo arguments. Long_t * GetUndoArgs() const; Returns a pointer to array of undo arguments. Int_t GetNRargs() const; Returns a number of redo arguments. Int_t GetNUargs() const; Returns a number of undo arguments. void * GetObject() const; Returns an object for which undo redo acions are applied. Int_t GetStatus() const; Returns a number of sequential undo or redo operations. Bool_t IsMacro() const; Returns kTRUE if neither redo nor undo action specified. Bool_t IsUndoing() const; Undo action is in progress. Bool_t IsRedoing() const; Redo action is in progress. Bool_t IsExecuting() const; Returns kTRUE if command execution is in progress. void SetName(const char* name); Sets name of the command. void SetTitle(const char* title); Sets description of the command. void ls(Option_t* option = """") const; ls this command and merged commands. void PrintCollectionHeader(Option_t* option) const; Print collection header. TQConnection * GetRedo() const; { return fRedo; }. TQConnection * GetUndo() const; { return fUndo; }. void Add(TObject* obj, Option_t* opt). » Author: Valeriy Onuchin 04/27/2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TQCommand.h 39365 2011-05-24 19:53:19Z pcanal $ » Last generated: 2011-11-03 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TQCommand.html:24075,Undo,Undo,24075,root/html532/TQCommand.html,https://root.cern,https://root.cern/root/html532/TQCommand.html,1,['Undo'],['Undo']
Usability,"d controlled by the user or admin who can also force saving in all cases; parameter PROOF_SavePartialResults or RC env ProofPlayer.SavePartialResults . However, if 'force' is kTRUE, fSavePartialResults and fSaveResultsPerPacket are ignored. Return -1 in case of problems, 0 otherwise. ; Implements TVirtualProofPlayer.; Definition at line 780 of file TProofPlayer.cxx. ◆ SetCurrentQuery(). void TProofPlayer::SetCurrentQuery ; (; TQueryResult * ; q). overridevirtual . Set current query and save previous value. ; Implements TVirtualProofPlayer.; Definition at line 451 of file TProofPlayer.cxx. ◆ SetDispatchTimer(). void TProofPlayer::SetDispatchTimer ; (; Bool_t ; on = kTRUE). overridevirtual . Enable/disable the timer to dispatch pening events while processing. ; Implements TVirtualProofPlayer.; Definition at line 309 of file TProofPlayer.cxx. ◆ SetDrawFeedbackOption(). void TProofPlayer::SetDrawFeedbackOption ; (; TDrawFeedback * ; f, . Option_t * ; opt . ). overridevirtual . Set draw feedback option. ; Implements TVirtualProofPlayer.; Definition at line 741 of file TProofPlayer.cxx. ◆ SetExitStatus(). void TProofPlayer::SetExitStatus ; (; EExitStatus ; st). inlineoverridevirtual . Implements TVirtualProofPlayer.; Definition at line 204 of file TProofPlayer.h. ◆ SetInitTime(). void TProofPlayer::SetInitTime ; (; ). inlineoverridevirtual . Implements TVirtualProofPlayer.; Reimplemented in TProofPlayerRemote.; Definition at line 213 of file TProofPlayer.h. ◆ SetMaxDrawQueries(). void TProofPlayer::SetMaxDrawQueries ; (; Int_t ; max). inlineoverridevirtual . Implements TVirtualProofPlayer.; Definition at line 168 of file TProofPlayer.h. ◆ SetMerging(). void TProofPlayer::SetMerging ; (; Bool_t ; = kTRUE). inlineoverridevirtual . Implements TVirtualProofPlayer.; Reimplemented in TProofPlayerRemote.; Definition at line 215 of file TProofPlayer.h. ◆ SetOutputFilePath(). void TProofPlayer::SetOutputFilePath ; (; const char * ; fp). inlineoverridevirtual . Implements TVirtualP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayer.html:40382,feedback,feedback,40382,doc/master/classTProofPlayer.html,https://root.cern,https://root.cern/doc/master/classTProofPlayer.html,1,['feedback'],['feedback']
Usability,"d drawing optimizations. . The top left cell in a table has coordinates (0,0) . A TObjArray is used internally to ensure little overhead and fast ; acces to cells. . If the data source has more rows than the default 50 rows of cells in; memory, buttons at the bottom of the table can be used to load the; next or previous chunk of data. At the top of the table, a frame is visible that shows the coordinates; of the top left cell currently in memmory in row,column. The amount of; rows and columns is also shown in rows x columns. These values can be; edited to move to a different area of the data source or to resize the; table. Tab will switch between the enties, return will move to the; currently entered range and resize the table if needed. Clicking the; goto button has the same effect. A TGTable is created by first creating an appropriate ; TVirtualTableInterface from the data that needs visualization and ; then creating the TGTable using this interface. . A simple macro to use a TGTable with a TGSimpleTableInterface:. Picture; Source. {; // Create an array to hold a bunch of numbers; Int_t i = 0, j = 0;; UInt_t nrows = 6, ncolumns = 5;; Double_t** data = new Double_t*[nrows];; for (i = 0; i < nrows; i++) {; data[i] = new Double_t[ncolumns];; for (j = 0; j < ncolumns; j++) {; data[i][j] = 10 * i + j;; }; }. // Create a main frame to contain the table; TGMainFrame* mainframe = new TGMainFrame(0, 400, 200);; mainframe->SetCleanup(kDeepCleanup) ;. // Create an interface; TGSimpleTableInterface *iface = new TGSimpleTableInterface(data, 6, 5); . // Create the table; TGTable *table = new TGTable(mainframe, 999, iface); . // Add the table to the main frame; mainframe->AddFrame(table, new TGLayoutHints(kLHintsExpandX | kLHintsExpandY));. //Update data; data[5][1] = 3.01; ; //update the table view; table->Update(); . // Layout and map the main frame; mainframe->SetWindowName(""Tree Table Test"") ;; mainframe->MapSubwindows() ;; mainframe->Layout();; mainframe->Resize() ;; mainfr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGTable.html:1497,simpl,simple,1497,root/html528/TGTable.html,https://root.cern,https://root.cern/root/html528/TGTable.html,8,['simpl'],['simple']
Usability,"d from the abstract; Monte Carlo application class, and provide functions like; ConstructGeometry(), BeginEvent(), FinishEvent(), ... .; The concrete Monte Carlo (Geant3, Geant4) is selected at run time -; when processing a ROOT macro where the concrete Monte Carlo is instantiated. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualMC(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidBuildPhysics(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCurrentBoundaryNormal(Double_t& x, Double_t& y, Double_t& z) const; virtual Int_tCurrentEvent() const; virtual Int_tCurrentMaterial(Float_t& a, Float_t& z, Float_t& dens, Float_t& radl, Float_t& absl) const; virtual Int_tCurrentMedium() const; virtual Int_tCurrentVolID(Int_t& copyNo) const; virtual const char*CurrentVolName() const; virtual Int_tCurrentVolOffID(Int_t off, Int_t& copyNo) const; virtual const char*CurrentVolOffName(Int_t off) const; virtual const char*CurrentVolPath(); virtual Bool_tDefineIon(const char* name, Int_t Z, Int_t A, Int_t Q, Double_t excEnergy, Double_t mass = 0.); virtual voidDefineOpSurface(const char* name, EMCOpSurfaceModel model, EMCOpSurfaceType surfaceType, EMCOpSurfaceFinish surfaceFinish, Double_t sigmaAlpha); virtual Bool_tDefineParticle(Int_t pdg, const char* name, TMCParticleType mcType, Double_t mass, Double_t charge, Double_t lifetime); virtual Bool_tDefineParticle(Int_t pdg, const char* name, TMCParticleType mcType, Double_t mass, Double_t charge, Double_t lifetime, const TString& pType, D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TVirtualMC.html:1275,Clear,Clear,1275,root/html532/TVirtualMC.html,https://root.cern,https://root.cern/root/html532/TVirtualMC.html,4,['Clear'],['Clear']
Usability,"d give access to the content of TTree object.; This is intended to be used as part of a generate Selector class; which will hold the directory and its associate. Function Members (Methods); public:. ~TBranchProxyDirector(); voidAttach(ROOT::TBranchProxy* p); voidAttach(ROOT::TFriendProxy* f); TH1F*CreateHistogram(const char* options); Long64_tGetReadEntry() const; TTree*GetTree() const; voidSetReadEntry(Long64_t entry); TTree*SetTree(TTree* newtree); ROOT::TBranchProxyDirectorTBranchProxyDirector(TTree* tree, Long64_t i); ROOT::TBranchProxyDirectorTBranchProxyDirector(TTree* tree, Int_t i). private:. ROOT::TBranchProxyDirector&operator=(const ROOT::TBranchProxyDirector&); ROOT::TBranchProxyDirectorTBranchProxyDirector(const ROOT::TBranchProxyDirector&). Data Members; private:. list<ROOT::TBranchProxy*>fDirected; Long64_tfEntryEntry currently being read.; list<ROOT::TFriendProxy*>fFriends; TTree*fTreeTTree we are currently looking at. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchProxyDirector(TTree* tree, Long64_t i); Simple constructor. TBranchProxyDirector(TTree* tree, Int_t i); cint has a problem casting int to long long; Simple constructor. void Attach(TBranchProxy* p). void Attach(TFriendProxy* p). TH1F* CreateHistogram(const char* options); Create a temporary 1D histogram. void SetReadEntry(Long64_t entry). TTree* SetTree(TTree* newtree). TBranchProxyDirector(const ROOT::TBranchProxyDirector& ); {;}. TBranchProxyDirector& operator=(const ROOT::TBranchProxyDirector& ); {return *this;}. Long64_t GetReadEntry() const; { return fEntry; }. TTree* GetTree() const; void Print();. { return fTree; }. » Author: Philippe Canal 13/05/2003 » Copyright (C) 1995-2004, Rene Brun, Fons Rademakers and al. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 13:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__TBranchProxyDirector.html:1527,Simpl,Simple,1527,root/html602/ROOT__TBranchProxyDirector.html,https://root.cern,https://root.cern/root/html602/ROOT__TBranchProxyDirector.html,2,['Simpl'],['Simple']
Usability,"d give access to the content of TTree object.; This is intended to be used as part of a generate Selector class; which will hold the directory and its associate. Function Members (Methods); public:. ~TBranchProxyDirector(); voidAttach(ROOT::TBranchProxy* p); voidAttach(ROOT::TFriendProxy* f); TH1F*CreateHistogram(const char* options); Long64_tGetReadEntry() const; TTree*GetTree() const; voidSetReadEntry(Long64_t entry); TTree*SetTree(TTree* newtree); ROOT::TBranchProxyDirectorTBranchProxyDirector(TTree* tree, Long64_t i); ROOT::TBranchProxyDirectorTBranchProxyDirector(TTree* tree, Int_t i). private:. ROOT::TBranchProxyDirector&operator=(const ROOT::TBranchProxyDirector&); ROOT::TBranchProxyDirectorTBranchProxyDirector(const ROOT::TBranchProxyDirector&). Data Members; private:. list<ROOT::TBranchProxy*>fDirected; Long64_tfEntryEntry currently being read.; list<ROOT::TFriendProxy*>fFriends; TTree*fTreeTTree we are currently looking at. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchProxyDirector(TTree* tree, Long64_t i); Simple constructor. TBranchProxyDirector(TTree* tree, Int_t i); cint has a problem casting int to long long; Simple constructor. void Attach(TBranchProxy* p). void Attach(TFriendProxy* p). TH1F* CreateHistogram(const char* options); Create a temporary 1D histogram. void SetReadEntry(Long64_t entry). TTree* SetTree(TTree* newtree). TBranchProxyDirector(const ROOT::TBranchProxyDirector& ); {;}. TBranchProxyDirector& operator=(const ROOT::TBranchProxyDirector& ); {return *this;}. Long64_t GetReadEntry() const; { return fEntry; }. TTree* GetTree() const; void Print();. { return fTree; }. » Author: Philippe Canal 13/05/2003 » Copyright (C) 1995-2004, Rene Brun, Fons Rademakers and al. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 15:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__TBranchProxyDirector.html:1527,Simpl,Simple,1527,root/html604/ROOT__TBranchProxyDirector.html,https://root.cern,https://root.cern/root/html604/ROOT__TBranchProxyDirector.html,2,['Simpl'],['Simple']
Usability,"d in 'url' on remote 'port' as 'user'. url: [[proto][p][auth]://]host[/?options]. where proto = ""sockd"", ""rootd"", ""proofd""; indicates the type of remote server; if missing ""sockd"" is assumed (""sockd"" indicates; any remote server session using TServerSocket); [p] = for parallel sockets (forced internally for; rootd); [auth] = ""up"", ""s"", ""k"", ""g"", ""h"", ""ug"" to force UsrPwd,; SRP, Krb5, Globus, SSH or UidGid authentication; [options] = ""m"" or ""s"", when proto=proofd indicates whether; we are master or slave (used internally by TSlave). An already opened connection can be used by passing its socket; in opensock. If 'err' is defined, '*err' on return from a failed call contains an error; code (see NetErrors.h). Example:. TSocket::CreateAuthSocket(""qwerty"",""rootdps://machine.fq.dn"",5051). creates an authenticated socket to a rootd server running; on remote machine machine.fq.dn on port 5051; ""parallel""; sockets are forced internally because rootd expects; parallel sockets; however a simple socket will be created; in this case because the size is 0 (the default);; authentication will attempt protocol SRP first. TSocket::CreateAuthSocket(""qwerty"",""pk://machine.fq.dn:5052"",3). creates an authenticated parallel socket of size 3 to a sockd; server running on remote machine machine.fq.dn on port 5052;; authentication will attempt protocol Kerberos first. NB: may hang if the remote server is not of the correct type;; at present TSocket has no way to find out the type of the; remote server automatically. Returns pointer to an authenticated socket or 0 if creation or; authentication is unsuccessful. Int_t GetClientProtocol(); Static method returning supported client protocol. void NetError(const char* where, Int_t error); Print error string depending on error code. ULong64_t GetSocketBytesSent(); Get total number of bytes sent via all sockets. ULong64_t GetSocketBytesRecv(); Get total number of bytes received via all sockets. Int_t GetCompressionAlgorithm() const. Int_t GetCompressi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSocket.html:23869,simpl,simple,23869,root/html530/TSocket.html,https://root.cern,https://root.cern/root/html530/TSocket.html,9,['simpl'],['simple']
Usability,"d in grayscale, and re-paint it if necessary.Definition TCanvas.cxx:2576; TCanvas::SetTitlevoid SetTitle(const char *title="""") overrideSet canvas title.Definition TCanvas.cxx:2155; TCanvas::fChUInt_t fChHeight of the canvas along Y (pixels)Definition TCanvas.h:44; TCanvas::GetDISPLAYconst char * GetDISPLAY() constDefinition TCanvas.h:132; TCanvas::fContextMenuTContextMenu * fContextMenu! Context menu pointerDefinition TCanvas.h:58; TCanvas::GetCanvasIDInt_t GetCanvasID() const overrideDefinition TCanvas.h:157; TCanvas::fCattTAttCanvas fCattCanvas attributes.Definition TCanvas.h:31; TCanvas::SetNamevoid SetName(const char *name="""") overrideSet canvas name.Definition TCanvas.cxx:2047; TCanvas::GetWindowWidthUInt_t GetWindowWidth() constDefinition TCanvas.h:161; TCanvas::fRetainedBool_t fRetainedRetain structure flag.Definition TCanvas.h:61; TCanvas::DisconnectWidgetvoid DisconnectWidget()Used by friend class TCanvasImp.Definition TCanvas.cxx:2558; TCanvas::FeedbackModevoid FeedbackMode(Bool_t set)Turn rubberband feedback mode on or off.Definition TCanvas.cxx:1128; TCanvas::GetYsizeUserSize_t GetYsizeUser() constDefinition TCanvas.h:154; TCanvas::GetSelectedYInt_t GetSelectedY() constDefinition TCanvas.h:144; TCanvas::lsvoid ls(Option_t *option="""") const overrideList all pads.Definition TCanvas.cxx:1504; TCanvas::RaiseWindowvoid RaiseWindow()Raise canvas window.Definition TCanvas.cxx:1744; TCanvas::Buildvoid Build()Build a canvas. Called by all constructors.Definition TCanvas.cxx:587; TCanvas::SaveAllstatic Bool_t SaveAll(const std::vector< TPad * > &={}, const char *filename="""", Option_t *option="""")Save provided pads/canvases into the image file(s) Filename can include printf argument for image num...Definition TCanvas.cxx:2654; TCanvas::GetSelectedXInt_t GetSelectedX() constDefinition TCanvas.h:143; TCanvas::fWindowTopYInt_t fWindowTopYTop Y position of window (in pixels)Definition TCanvas.h:40; TCanvas::Paintvoid Paint(Option_t *option="""") overridePaint canvas.Defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCanvas_8h_source.html:25478,feedback,feedback,25478,doc/master/TCanvas_8h_source.html,https://root.cern,https://root.cern/doc/master/TCanvas_8h_source.html,1,['feedback'],['feedback']
Usability,"d number of color levels (256). Color in; every level is calculated by adding the increments of the r, g, b; components to the previous level. Using this function one can change the; color increments between two neighboring color levels. The function does; not apply dor the Simple Display Modes Group. The default values are:; (1,1,1). * * *. ca(color_algorithm) allows to choose the Color Algorithm.; To define the colors one can employ one of the following color algorithms; (RGB, CMY, CIE, YIQ, HVS models). When the level of a component reaches; the limit value one can choose either smooth transition (by decreasing; the limit value) or a sharp modulo transition (continuing with 0 value).; This makes possible to realize various visual effects. One can choose from; the following set of the algorithms:. 0 = RGB Smooth; 1 = RGB Modulo; 2 = CMY Smooth; 3 = CMY Modulo; 4 = CIE Smooth; 5 = CIE Modulo; 6 = YIQ Smooth; 7 = YIQ Modulo; 8 = HVS Smooth; 9 = HVS Modulo. This function does not apply on Simple display modes group. Default; value is 0. Example:. h2->Draw(""SPEC c1(4) dm(0,1) a(30,30,0)"");. choose CMY Modulo to paint the ""h2"" histogram. * * *. lp(x,y,z) set the light position.; In Light and LightHeight display modes groups the color palette is; calculated according to the fictive light source position in 3-d space.; Using this function one can change the position of the source and thus; to achieve various graphical effects. This function does not apply for; Simple and Height display modes groups. Default is:; lp(1000,1000,100). * * *. s(shading,shadow) allows to set the shading.; The picture's surface is composed of triangles. If desired the edges of; the neighboring triangles can be smoothed (shaded). If desired the; display of the shadow can be painted as well. The function does not apply; for Simple display modes group. The possible values for shading are:. 0 = Not Shaded; 1 = Shaded. The possible values for shadow are:. 0 = Shadows are not painted; 1 = Shadows are",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSpectrum2Painter.html:41202,Simpl,Simple,41202,root/html532/TSpectrum2Painter.html,https://root.cern,https://root.cern/root/html532/TSpectrum2Painter.html,4,['Simpl'],['Simple']
Usability,"d of being spread across the file. However it might; decrease the performance when reading more branches (or the full; entry). When using SortBasketsByEntry the baskets with the lowest; starting entry are written first. (i.e. the baskets are; sorted on the index/number of the first entry they contain).; This means that on the file the baskets will be in the order; in which they will be needed when reading the whole tree; sequentially. For examples of CloneTree, see tutorials:. -- copytree. A macro to copy a subset of a TTree to a new TTree. The input file has been generated by the program in $ROOTSYS/test/Event; with: Event 1000 1 1 1. -- copytree2. A macro to copy a subset of a TTree to a new TTree. One branch of the new Tree is written to a separate file. The input file has been generated by the program in $ROOTSYS/test/Event; with: Event 1000 1 1 1. void CopyAddresses(TTree* , Bool_t undo = kFALSE); Set branch addresses of passed tree equal to ours.; If undo is true, reset the branch address instead of copying them.; This insures 'separation' of a cloned tree from its original. Long64_t CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); Copy nentries from given tree to this tree.; This routines assumes that the branches that intended to be copied are; already connected. The typical case is that this tree was created using; tree->CloneTree(0). By default copy all entries. Returns number of bytes copied to this tree. If 'option' contains the word 'fast' and nentries is -1, the cloning will be; done without unzipping or unstreaming the baskets (i.e., a direct copy of the; raw bytes on disk). When 'fast' is specified, 'option' can also contains a sorting order for the; baskets in the output file. There are currently 3 supported sorting order:; SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. See TTree::CloneTree for a detailed explanation of the semantics of these 3 options. If the tree or any of the underlying tree of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:58225,undo,undo,58225,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,4,['undo'],['undo']
Usability,"d of inheritence, etc. But also, notice that you have to run an Init function. Why? That is specifically what the constructor is for. Why does everything in ROOT know how to draw itself? Why does everything in ROOT have 100 methods, for ""quick access"" to other objects that do the actual work of those methods? These are questions that should be asked. But most of all, if you aren't going to fix these problems, why bother migrating at all? You fail to treat this migration as what it actually is. You are migrating to a new language, not a new version of a language. ROOT isn't written in C++. It's written in CINT. I am just frustrated to see this happen, because I know this community can do better. Maybe I'll make a draft of some smaller changes that need to be made and submit them to the mailing list. But honestly, I'm not very hopeful about this migration. Submitted by Anonymous (not verified) on Thu, 07/23/2015 - 21:50 Permalink . Re: Why? . Hi Matt!; Thanks for your feedback; I'll tried to reply to each of your comments one by one. I do not disagree with all of your comments, but I might have explanations for some of them :-) Sometimes you seem to misinterpret ""backward compatibility"" (which means ""what used to work will continue to work"") with ""no change"" - but that might just have been your motivation to take the time for writing your feedback, so I don't complain :-) Given the relevance of your comments I decided to reply in a separate blog post.; Cheers, Axel. Submitted by Anonymous (not verified) on Thu, 07/23/2015 - 21:50 Permalink . Thank you for the very nice . Thank you for the very nice explanation of CINT vs cling issue. I did not know that Reflex relies on CINT. The proposed upgrade to cling sounds very promising indeed. By the way, we will also need to consider backward compatibility as experiments will still need to read data already recorded in 2010/2011. Submitted by Anonymous (not verified) on Thu, 07/23/2015 - 21:50 Permalink . Re: Backward Compatib",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html:12463,feedback,feedback,12463,d/blog/do-we-need-yet-another-custom-c-interpreter.html,https://root.cern,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html,1,['feedback'],['feedback']
Usability,"d on expression templates to achieve an high level optimization. Physics Vectors: classes for describing vectors in 2, 3 and 4 dimensions (relativistic vectors) and their rotation and transformation algorithms. Two package exist in ROOT:. Physics: library with the TVector3 and TLorentzVector classes.; GenVector: new library providing generic class templates for modeling the vectors. Unuran: package with universal algorithms for generating non-uniform pseudo-random numbers, from a large classes of continuous or discrete distributions in one or multi-dimensions. ; Foam: multi-dimensional general purpose Monte Carlo event generator (and integrator). It generates randomly points (vectors) according to an arbitrary probability distribution in n dimensions.; FFTW: library with implementation of the fast Fourier transform (FFT) using the FFTW package. It requires a previous installation of (FFTW).; MLP: library with the neural network class, TMultiLayerPerceptron based on the NN algorithm from the mlpfit package.; Quadp: optimization library with linear and quadratic programming methods. It is based on the Matrix package.; Statistic classes for computing limits and confidence levels.; More detailed is provided here. Some of these classes are currently provided by libPhysics. Further information is available at the following links:. ROOT Mathematical Library Web page; ROOT Math doxygen class documentation; The Math chapter in the user guide; The Linear Algebra chapter in the user guide; The Physics Vector chapter in the user guide; Inventory of Math functions and algorithms. Last modified: Thu Mar 5 16:03:07 CET 2009 . ; MATH Modules; FFTW; FOAM; FUMILI; GENVECTOR; MATHCORE; MATHMORE; MATRIX; MINUIT; MINUIT2; MLP; PHYSICS; QUADP; SMATRIX; SPLOT; UNURAN. » Last changed: 2009-12-14 18:22 » Last generated: 2009-12-14 18:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/MATH_Index.html:4353,guid,guide,4353,root/html526/MATH_Index.html,https://root.cern,https://root.cern/root/html526/MATH_Index.html,3,['guid'],['guide']
Usability,"d retaining/discarding the physical placements as required. The viewer may decide to force the client to rebuild (republish) the scene (via a TPad repaint at present), and thus collect these objects if the internal viewer state changes. It does this presently by forcing a repaint on the attached TPad object - hence the reason for putting all publishing to the viewer in the attached pad objects Paint() method. We will likely remove this requirement in the future, indicating the rebuild request via a normal ROOT signal, which the client can detect. Physical IDs; TVirtualViewer3D provides for two methods of object addition:virtual Int_t AddObject(const TBuffer3D & buffer, Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID, const TBuffer3D & buffer, Bool_t * addChildren = 0); TBuffer3DGeneric 3D primitive description class.Definition TBuffer3D.h:18; TVirtualViewer3D::AddObjectvirtual Int_t AddObject(const TBuffer3D &buffer, Bool_t *addChildren=nullptr)=0; bool; unsigned int; If you use the first (simple) case a viewer using logical/physical pairs will generate IDs for each physical object internally. In the second you can specify a unique identifier from the client, which allows the viewer to be more efficient. It can now cache both logical and physical objects, and only discard physical objects no longer of interest as part of scene rebuilds. Child Objects; In many geometries there is a rigid containment hierarchy, and so if the viewer is not interested in a certain object due to limits/size then it will also not be interest in any of the contained branch of descendents. Both AddObject() methods have an addChildren parameter. The viewer will complete this (if passed) indicating if children (contained within the one just sent) are worth adding. Recycling TBuffer3D; Once add AddObject() has been called, the contents are copied to the viewer internally. You are free to destroy this object, or recycle it for the next object if suitable. ; Definition at lin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualViewer3D.html:10693,simpl,simple,10693,doc/master/classTVirtualViewer3D.html,https://root.cern,https://root.cern/doc/master/classTVirtualViewer3D.html,1,['simpl'],['simple']
Usability,"d slots communication mechanism. ;  ; file  guitest_playback.C;  This macro plays a recorded ROOT session showing how to perform various interactive GUI operations with the guitest.C macro While replaying the session, several temporary macros (guitest0xx.C) macros will be saved. ;  ; file  guiWithCLING.C;  A simple example of entering CLING commands and having the CLING output in a ROOT GUI application window. ;  ; file  iconAsXPMData.C;  A simple example of creating icon image from XPM data, included into the code. ;  ; file  listBox.C;  This macro gives an example of how to create a list box and how to set and use its multiple selection feature. ;  ; file  mditest.C;  GUI MDI features. ;  ; file  ntupleTableTest.C;  This TableTest class is a simple example of how to use a TGTable with a TTreeTableInterface. ;  ; file  numberEntry.C;  This macro gives an example of how to create a number entry and how to update a label according to the changed value of this number entry. ;  ; file  simpleTableTest.C;  This TableTest class is a simple example of how to use a TGSimpleTable that creates and owns it's own TGSimpleTableInterface. ;  ; file  Slider3Demo.C;  Simple macro showing capabilities of triple slider. ;  ; file  splitbuttonTest.C;  A simple example that shows the usage of a TGSplitButton. ;  ; file  splitterHorizontal.C;  This macro gives an example of how to create a horizontal splitter. ;  ; file  splitterVertical.C;  This macro gives an example of how to create a vertical splitter. ;  ; file  staffTableTest.C;  This TableTest class is a simple example of how to use a TGTable with a TTreeTableInterface. ;  ; file  statusBar.C;  This macro gives an example of how to create a status bar related to an embedded canvas that shows the info of the selected object, exactly as the status bar of any canvas window. ;  ; file  textEntries.C;  This macro gives an example of how to set/change text entry attributes. ;  ; file  textviewostream.C;  This macro gives an example of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__gui.html:2848,simpl,simpleTableTest,2848,doc/master/group__tutorial__gui.html,https://root.cern,https://root.cern/doc/master/group__tutorial__gui.html,1,['simpl'],['simpleTableTest']
Usability,"d to add the function. unsigned int Dim() const. return the number of sunctions set in the class.; The number must be equal to the dimension of the functions. { return fFunctions.size(); }. void Clear(); clear list of functions. const double * X() const; return the root X values solving the system. const double * FVal() const; return the function values f(X) solving the system; i.e. they must be close to zero at the solution. const double * Dx() const; return the last step size. bool Solve(const double* x, int maxIter = 0, double absTol = 0, double relTol = 0). Find the root starting from the point X;; Use the number of iteration and tolerance if given otherwise use; default parameter values which can be defined by; the static method SetDefault... int Iterations() const; Return number of iterations. int Status() const; Return the status of last root finding. { return fStatus; }. const char * Name() const; Return the algorithm name. void SetPrintLevel(int level). set print level; level = 0 quiet (no messages print); = 1 print only the result; = 3 max debug. Print result at each iteration. { fPrintLevel = level; }. int PrintLevel() const; return the print level. { return fPrintLevel; }. void SetDefaultTolerance(double abstol, double reltol = 0); -- static methods to set configurations; set tolerance (absolute and relative); relative tolerance is only use to verify the convergence; do it is a minor parameter. void SetDefaultMaxIterations(int maxiter); set maximum number of iterations. void PrintState(ostream& os = std::cout); print iteration state. std::pair<bool,int> GetType(const char* name); return type given a name. void ClearFunctions(); clear list of functions. » Author: L. Moneta 03/2011 » Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/mathmore:$Id$ » Last generated: 2015-06-30 14:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__GSLMultiRootFinder.html:7594,clear,clear,7594,root/html602/ROOT__Math__GSLMultiRootFinder.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__GSLMultiRootFinder.html,3,"['Clear', 'clear']","['ClearFunctions', 'clear']"
Usability,"d to add the function. unsigned int Dim() const. return the number of sunctions set in the class.; The number must be equal to the dimension of the functions. { return fFunctions.size(); }. void Clear(); clear list of functions. const double * X() const; return the root X values solving the system. const double * FVal() const; return the function values f(X) solving the system; i.e. they must be close to zero at the solution. const double * Dx() const; return the last step size. bool Solve(const double* x, int maxIter = 0, double absTol = 0, double relTol = 0). Find the root starting from the point X;; Use the number of iteration and tolerance if given otherwise use; default parameter values which can be defined by; the static method SetDefault... int Iterations() const; Return number of iterations. int Status() const; Return the status of last root finding. { return fStatus; }. const char * Name() const; Return the algorithm name. void SetPrintLevel(int level). set print level; level = 0 quiet (no messages print); = 1 print only the result; = 3 max debug. Print result at each iteration. { fPrintLevel = level; }. int PrintLevel() const; return the print level. { return fPrintLevel; }. void SetDefaultTolerance(double abstol, double reltol = 0); -- static methods to set configurations; set tolerance (absolute and relative); relative tolerance is only use to verify the convergence; do it is a minor parameter. void SetDefaultMaxIterations(int maxiter); set maximum number of iterations. void PrintState(ostream& os = std::cout); print iteration state. std::pair<bool,int> GetType(const char* name); return type given a name. void ClearFunctions(); clear list of functions. » Author: L. Moneta 03/2011 » Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/mathmore:$Id$ » Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__GSLMultiRootFinder.html:7346,clear,clear,7346,root/html534/ROOT__Math__GSLMultiRootFinder.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMultiRootFinder.html,3,"['Clear', 'clear']","['ClearFunctions', 'clear']"
Usability,"d to add the function. unsigned int Dim() const. return the number of sunctions set in the class.; The number must be equal to the dimension of the functions. { return fFunctions.size(); }. void Clear(); clear list of functions. const double * X() const; return the root X values solving the system. const double * FVal() const; return the function values f(X) solving the system; i.e. they must be close to zero at the solution. const double * Dx() const; return the last step size. bool Solve(const double* x, int maxIter = 0, double absTol = 0, double relTol = 0). Find the root starting from the point X;; Use the number of iteration and tolerance if given otherwise use; default parameter values which can be defined by; the static method SetDefault... int Iterations() const; Return number of iterations. int Status() const; Return the status of last root finding. { return fStatus; }. const char * Name() const; Return the algorithm name. void SetPrintLevel(int level). set print level; level = 0 quiet (no messages print); = 1 print only the result; = 3 max debug. Print result at each iteration. { fPrintLevel = level; }. int PrintLevel() const; return the print level. { return fPrintLevel; }. void SetDefaultTolerance(double abstol, double reltol = 0); -- static methods to set configurations; set tolerance (absolute and relative); relative tolerance is only use to verify the convergence; do it is a minor parameter. void SetDefaultMaxIterations(int maxiter); set maximum number of iterations. void PrintState(ostream& os = std::cout); print iteration state. std::pair<bool,int> GetType(const char* name); return type given a name. void ClearFunctions(); clear list of functions. » Author: L. Moneta 03/2011 » Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/mathmore:$Id$ » Last generated: 2015-09-08 17:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__GSLMultiRootFinder.html:7594,clear,clear,7594,root/html604/ROOT__Math__GSLMultiRootFinder.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__GSLMultiRootFinder.html,3,"['Clear', 'clear']","['ClearFunctions', 'clear']"
Usability,"d user data.; Float_t*fVerts[3*fNVerts]; TEveElement*TEveElement::fVizModel! Element used as model from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveTriangleSet(Int_t nv, Int_t nt, Bool_t norms = kFALSE, Bool_t cols = kFALSE); Constructor. ~TEveTriangleSet(); Destructor. void GenerateTriangleNormals(); Generate triangle normals via cross product of triangle edges. void GenerateRandomColors(); Assign random colors to all triangles. void GenerateZNormalColors(Float_t fac = 20, Int_t min = -20, Int_t max = 20, Bool_t interp = kFALSE, Bool_t wrap = kFALSE); Generate triangle colors by the z-component of the normal.; Current palette is taken from gStyle. void ComputeBBox(); Compute bounding box.; Virtual from TAttBBox. void Paint(Option_t* option = """"); Paint this object. Only direct rendering is supported. TEveTriangleSet* ReadTrivialFile(const char* file); Read a simple ascii input file describing vertices and triangles. TEveTriangleSet(const TEveTriangleSet& ). TEveTriangleSet& operator=(const TEveTriangleSet& ). Bool_t CanEditMainTransparency() const; { return kTRUE; }. Int_t GetNVerts() const; { return fNVerts; }. Int_t GetNTrings() const; { return fNTrings; }. Float_t* Vertex(Int_t i); { return &(fVerts[3*i]); }. Int_t* Triangle(Int_t i); { return &(fTrings[3*i]); }. Float_t* TriangleNormal(Int_t i); { return &(fTringNorms[3*i]); }. UChar_t* TriangleColor(Int_t i); { return &(fTringCols[3*i]); }. void SetVertex(Int_t i, Float_t x, Float_t y, Float_t z); { Float_t* v = Vertex(i); v[0] = x; v[1] = y; v[2] = z; }. void SetTriangle(Int_t i, Int_t v0, Int_t v1, Int_t v2); { Int_t* t = Triangle(i); t[0] = v0; t[1] = v1; t[2] = v2; }. void SetTriangleColor(Int_t i, UChar_t r, UChar_t g, UChar_t b, UChar_t a = 255); { UChar_t* c = TriangleColor(i); c[0] = r; c[1] = g; c[2] = b; c[3] = a; }. void SetTransparency(Char_t tr); { SetMainTransparency(tr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveTriangleSet.html:21560,simpl,simple,21560,root/html528/TEveTriangleSet.html,https://root.cern,https://root.cern/root/html528/TEveTriangleSet.html,6,['simpl'],['simple']
Usability,"d varying on the type of FCN function passesd and on the objects used for the parameters. More...;  ; class  MPIProcess;  ; class  MPITerminate;  ; class  NegativeG2LineSearch;  In case that one of the components of the second derivative g2 calculated by the numerical Gradient calculator is negative, a 1dim line search in the direction of that component is done in order to find a better position where g2 is again positive. More...;  ; class  Numerical2PGradientCalculator;  class performing the numerical gradient calculation More...;  ; class  NumericalDerivator;  ; class  ParametricFunction;  Function which has parameters. More...;  ; class  PrefixStack;  ; class  ScanBuilder;  Performs a minimization using the simplex method of Nelder and Mead (ref. More...;  ; class  ScanMinimizer;  Class implementing the required methods for a minimization using SCAN API is provided in the upper ROOT::Minuit2::ModularFunctionMinimizer class. More...;  ; class  SimplexBuilder;  Performs a minimization using the simplex method of Nelder and Mead (ref. More...;  ; class  SimplexMinimizer;  Class implementing the required methods for a minimization using Simplex. More...;  ; class  SimplexParameters;  class describing the simplex set of points (f(x), x ) which evolve during the minimization iteration process. More...;  ; class  SimplexSeedGenerator;  generate Simplex starting point (state) More...;  ; class  SinParameterTransformation;  class for the transformation for double-limited parameter Using a sin function one goes from a double-limited parameter range to an unlimited one More...;  ; class  SqrtLowParameterTransformation;  Transformation from external to internal Parameter based on sqrt(1 + x**2) More...;  ; class  SqrtUpParameterTransformation;  Transformation from external to internal Parameter based on sqrt(1 + x**2) More...;  ; class  StackAllocator;  StackAllocator controls the memory allocation/deallocation of Minuit. More...;  ; class  StackAllocatorHolder;  ; class  S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Minuit2.html:11519,simpl,simplex,11519,doc/master/namespaceROOT_1_1Minuit2.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Minuit2.html,2,['simpl'],['simplex']
Usability,"d we want the Z size to match the one of each container:; 275 ; 276~~~ {.cpp}; 277 TGeoVolume *container1 = gGeoManager->MakeBox(""C1"", imed, 10,10,30);; 278 TGeoVolume *container2 = gGeoManager->MakeBox(""C2"", imed, 10,10,20);; 279 TGeoVolume *pvol = gGeoManager->MakeBox(""PVOL"", jmed, 3,3,-1);; 280 container1->AddNode(pvol, 1);; 281 container2->AddNode(pvol, 1);; 282~~~; 283 ; 284 Note that the third parameter of PVOL is negative, which does not make sense; 285as half-length on Z. This is interpreted as: when positioned, create a box; 286replacing all invalid parameters with the corresponding dimensions of the; 287container. This is also internally handled by the TGeoVolumeMulti class, which; 288does not need to be instantiated by users.; 289 ; 290### Dividing volumes; 291 ; 292 Volumes can be divided according a pattern. The most simple division can; 293be done along one axis, that can be: X, Y, Z, Phi, Rxy or Rxyz. Let's take; 294the most simple case: we would like to divide a box in N equal slices along X; 295coordinate, representing a new volume family. Supposing we already have created; 296the initial box, this can be done like:; 297 ; 298~~~ {.cpp}; 299 TGeoVolume *slicex = box->Divide(""SLICEX"", 1, N);; 300~~~; 301 ; 302where SLICE is the name of the new family representing all slices and 1 is the; 303slicing axis. The meaning of the axis index is the following: for all volumes; 304having shapes like box, trd1, trd2, trap, gtra or para - 1,2,3 means X,Y,Z; for; 305tube, tubs, cone, cons - 1 means Rxy, 2 means phi and 3 means Z; for pcon and; 306pgon - 2 means phi and 3 means Z; for spheres 1 means R and 2 means phi.; 307 In fact, the division operation has the same effect as positioning volumes; 308in a given order inside the divided container - the advantage being that the; 309navigation in such a structure is much faster. When a volume is divided, a; 310volume family corresponding to the slices is created. In case all slices can; 311be represented by a single ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoVolume_8cxx_source.html:14823,simpl,simple,14823,doc/master/TGeoVolume_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html,1,['simpl'],['simple']
Usability,"d with entries. The caller has to make sure that the data that gets filled into an ntuple is not modified for the time of the Fill() call. The fill call serializes the C++ object into the column format and writes data into the corresponding column page buffers. Writing of the buffers to storage is deferred and can be triggered by FlushCluster() or by destructing the writer. On I/O errors, an exception is thrown. ; Definition at line 60 of file RNTupleWriter.hxx. Public Member Functions;  RNTupleWriter (const RNTupleWriter &)=delete;  ;  ~RNTupleWriter ();  ; void CommitCluster (bool commitClusterGroup=false);  Ensure that the data from the so far seen Fill calls has been written to storage. ;  ; std::unique_ptr< REntry > CreateEntry ();  ; std::unique_ptr< RNTupleModel::RUpdater > CreateModelUpdater ();  Get a RNTupleModel::RUpdater that provides limited support for incremental updates to the underlying model, e.g. ;  ; void EnableMetrics ();  ; std::size_t Fill ();  The simplest user interface if the default entry that comes with the ntuple model is used. ;  ; std::size_t Fill (REntry &entry);  Multiple entries can have been instantiated from the ntuple model. ;  ; void FillNoFlush (REntry &entry, RNTupleFillStatus &status);  Fill an entry into this ntuple, but don't commit the cluster. ;  ; void FlushCluster ();  Flush so far filled entries to storage. ;  ; void FlushColumns ();  Flush column data, preparing for CommitCluster or to reduce memory usage. ;  ; NTupleSize_t GetLastCommitted () const;  Return the entry number that was last committed in a cluster. ;  ; NTupleSize_t GetLastCommittedClusterGroup () const;  Return the entry number that was last committed in a cluster group. ;  ; NTupleSize_t GetLastFlushed () const;  Return the entry number that was last flushed in a cluster. ;  ; const Detail::RNTupleMetrics & GetMetrics () const;  ; const RNTupleModel & GetModel () const;  ; NTupleSize_t GetNEntries () const;  Return the number of entries filled so far. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleWriter.html:1510,simpl,simplest,1510,doc/master/classROOT_1_1Experimental_1_1RNTupleWriter.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleWriter.html,1,['simpl'],['simplest']
Usability,"d() - itTarget ) < Int_t(cls+1) ) {; 1425 itTarget = testingEventVector->end();; 1426 testingEventVector->insert( itTarget, itEvent, itEventEnd ); // fill in the rest without mixing; 1427 break;; 1428 }else{; 1429 itTarget += cls+1;; 1430 testingEventVector->insert( itTarget, (*itEvent) ); // fill event; 1431 }; 1432 }; 1433 }; 1434 }else{; 1435 for( UInt_t cls = 0; cls < dsi.GetNClasses(); ++cls ){; 1436 trainingEventVector->insert( trainingEventVector->end(), tmpEventVector[Types::kTraining].at(cls).begin(), tmpEventVector[Types::kTraining].at(cls).end() );; 1437 testingEventVector->insert ( testingEventVector->end(), tmpEventVector[Types::kTesting].at(cls).begin(), tmpEventVector[Types::kTesting].at(cls).end() );; 1438 }; 1439 }; 1440 // delete the tmpEventVector (but not the events therein); 1441 tmpEventVector[Types::kTraining].clear();; 1442 tmpEventVector[Types::kTesting].clear();; 1443 ; 1444 tmpEventVector[Types::kMaxTreeType].clear();; 1445 ; 1446 if (mixMode == ""RANDOM"") {; 1447 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""shuffling events""<<Endl;; 1448 ; 1449 std::shuffle(trainingEventVector->begin(), trainingEventVector->end(), rndm);; 1450 std::shuffle(testingEventVector->begin(), testingEventVector->end(), rndm);; 1451 }; 1452 ; 1453 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""trainingEventVector "" << trainingEventVector->size() << Endl;; 1454 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""testingEventVector "" << testingEventVector->size() << Endl;; 1455 ; 1456 // create dataset; 1457 DataSet* ds = new DataSet(dsi);; 1458 ; 1459 // Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << ""Create internal training tree"" << Endl;; 1460 ds->SetEventCollection(trainingEventVector, Types::kTraining );; 1461 // Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << ""Create internal testing tree"" << Endl;; 1462 ds->SetEventCollection(testingEventVector, Types::kTesting );; 1463 ; 1464 ; 1465 if (ds->GetNTrainingEv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataSetFactory_8cxx_source.html:65676,clear,clear,65676,doc/master/DataSetFactory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html,1,['clear'],['clear']
Usability,"d(const RooAbsArg& var, Bool_t silent = kFALSE); virtual Bool_tadd(const RooAbsCollection& list, Bool_t silent = kFALSE); virtual Bool_tadd(const RooAbsArg& var, Bool_t valueServer, Bool_t shapeServer, Bool_t silent); virtual RooAbsArg*addClone(const RooAbsArg& var, Bool_t silent = kFALSE); virtual voidaddClone(const RooAbsCollection& list, Bool_t silent = kFALSE); virtual Bool_taddOwned(RooAbsArg& var, Bool_t silent = kFALSE); virtual Bool_taddOwned(const RooAbsCollection& list, Bool_t silent = kFALSE); Bool_tRooAbsCollection::allInRange(const char* rangeSpec) const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsCollection::assignFast(const RooAbsCollection& other, Bool_t setValDirty = kTRUE); RooAbsCollection&RooAbsCollection::assignValueOnly(const RooAbsCollection& other, Bool_t oneSafe = kFALSE); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooArgSet::cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*RooArgSet::clone(const char* newname) const; virtual TObject*RooAbsCollection::Clone(const char* newname = 0) const; virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tRooAbsCollection::contains(const RooAbsArg& var) const; Bool_tRooAbsCollection::containsInstance(const RooAbsArg& var) const; stringRooAbsCollection::contentsString() const; virtual voidTObject::Copy(TObject& object) const; virtual TObject*RooArgSet::create(const char* newname) const; TIterator*RooAbsCollection::createIterator(Bool_t dir = kIterForward) const; virtual Int_tRooAbsCollection::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::Dra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooSetProxy.html:2173,Clear,Clear,2173,root/html532/RooSetProxy.html,https://root.cern,https://root.cern/root/html532/RooSetProxy.html,4,['Clear'],['Clear']
Usability,"d(const char* method) const; static voidAddClass(TClass* cl); voidAddImplFile(const char* filename, int line); voidAddInstance(Bool_t heap = kFALSE); static Bool_tAddRule(const char* rule); voidAdoptMemberStreamer(const char* name, TMemberStreamer* strm); voidAdoptReferenceProxy(TVirtualRefProxy* proxy); voidAdoptSchemaRules(ROOT::TSchemaRuleSet* rules); voidAdoptStreamer(TClassStreamer* strm); virtual voidTObject::AppendPad(Option_t* option = """"); static Int_tAutoBrowse(TObject* obj, TBrowser* browser); virtual voidBrowse(TBrowser* b); Int_tBrowse(void* obj, TBrowser* b) const; voidBuildEmulatedRealData(const char* name, Long_t offset, TClass* cl); voidBuildRealData(void* pointer = 0, Bool_t isTransient = kFALSE); voidCalculateStreamerOffset() const; Bool_tCallShowMembers(void* obj, TMemberInspector& insp, Int_t isATObject = -1) const; Bool_tCanIgnoreTObjectStreamer(); Bool_tCanSplit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; voidCopyCollectionProxy(const TVirtualCollectionProxy&); voidTDictionary::CreateAttributeMap(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteArray(void* ary, Bool_t dtorOnly = kFALSE); voidDestructor(void* obj, Bool_t dtorOnly = kFALSE); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDump() const; voidDump(void* obj) const; void*DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; char*EscapeChars(const char* text) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TClass.html:2266,Clear,Clear,2266,root/html534/TClass.html,https://root.cern,https://root.cern/root/html534/TClass.html,1,['Clear'],['Clear']
Usability,"d*fObjectobject to which undo/redo actions applied; TQConnection*fRedodo/redo action; Long_t*fRedoArgsredo values; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; Int_tfState-1 undoing on, 1 redoing on, 0 nothing in progress; Int_tfStatusfStatus++ after Redo(), fStatus-- after Undo(); TStringfTitlecommand description; TQConnection*fUndoundo action; Long_t*fUndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TCollection::(anonymous)TCollection::kIsOwner. Class Charts. Inheritance Chart:. TObject. ←; TCollection. ←; TSeqCollection. ←; TList. TQObject. ←; TQCommand. ←. TQUndoManager. Function documentation; void Init(const char* cl, void* object, const char* redo, const char* undo); common protected method used in several constructors. TQCommand(const char* cl = 0, void* object = 0, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. clname - class name.; 2. obj - an object; 3. redo - method or function to do/redo operation; 4. undo - method or function to undo operation. Comments:; - if either clname or obj is NULL that means that redo/undo is function; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(""TPad"", gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case undo parameter; can be omitted. Example:; TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. obj - an object; 2. redo - method or function to do/redo operation; 3. undo - method or function to undo operation. Comments:; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(gPad, ""SetEditable(=kTRU",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQCommand.html:18862,undo,undo,18862,root/html602/TQCommand.html,https://root.cern,https://root.cern/root/html602/TQCommand.html,4,['undo'],['undo']
Usability,"d, Int_t x, Int_t y, Int_t& fx, Int_t& fy); virtual voidTGFrame::UnmapWindow(); virtual voidTObject::UseCurrentStyle(); Bool_tTGWidget::WantFocus() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidTGFrame::DoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; virtual voidInitListBox(); voidTObject::MakeZombie(); voidSetContainer(TGFrame* f); Int_tTGWidget::SetFlags(Int_t flags); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE). private:. TGListBox(const TGListBox&); TGListBoxoperator=(const TGListBox&). Data Members; public:. enum TGFrame::[unnamed] { kDeleteWindowCalled; };; enum TGWindow::EEditMode { kEditEnable; kEditDisable; kEditDisableEvents; kEditDisableGrab; kEditDisableLayout; kEditDisableResize; kEditDisableHeight; kEditDisableWidth; kEditDisableBtnEnable; kEditDisableKeyEnable; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; k",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGListBox.html:17369,Clear,ClearFlags,17369,root/html532/TGListBox.html,https://root.cern,https://root.cern/root/html532/TGListBox.html,2,['Clear'],['ClearFlags']
Usability,"d, MnMinos, MnContours).; 2 Introduction: M basic concepts; [sec:intro]; 2.1 The organization of M; The M package acts on a multiparameter objective function which is called — for historical reasons — the \(\mbox{FCN}\) function (see [howto:fcn]). This function is usually a chisquared or a log–likelihood, but it could also be a mathematical function. The \(\mbox{FCN}\) function needs to be written in for which M defines the pure abstract base class FCNBase as interface. The user must define and implement the \(\mbox{FCN}\) function in a derived class from FCNBase. Sometimes this is done by an intermediate program such as HippoDraw@bib-HippoDraw, in which case M is being used under the control of such an intermediate program1. The value of the \(\mbox{FCN}\) function will in general depend on one or more variable parameters whose meaning is defined by the user (or by the intermediate program), but whose trial values are determined by M .; To take a simple example, suppose the problem is to fit a polynomial through a set of data points. Then the user would write a \(\mbox{FCN}\) which calculates the \(\chi^2\) between a polynomial and the data; the variable parameters of \(\mbox{FCN}\) would be the coefficients of the polynomials. Using objects for minimization from M , the user would request M to minimize the \(\mbox{FCN}\) with respect to the parameters, that is, find those values of the coefficients which give the lowest value of chisquare.; The user must therefore supply, in addition to the function to be analyzed, via a set or sequence of M applications the instructions which analysis is wanted. The instructions are coded in in the calling program (main.cpp), which allows looping, conditional execution, and all the other possibilities of , but not interactivity, since it must be compiled before execution.; 2.2 Design aspects of M in; What M is:. platform independent; written in an object-oriented way using standard; independent of any external package. The mainta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:8123,simpl,simple,8123,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,4,['simpl'],['simple']
Usability,"d. ; when the cutTube keyword is found, this function is called, and the dimensions required are taken and stored, these are then bound and converted to type TGeoCtub and stored in fsolmap map using the name as its key. ; Definition at line 3037 of file TGDMLParse.cxx. ◆ DeclFileName(). static const char * TGDMLParse::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 226 of file TGDMLParse.h. ◆ DefineConstants(). void TGDMLParse::DefineConstants ; (; ). private . Define constant expressions used. ; Definition at line 494 of file TGDMLParse.cxx. ◆ ElCone(). XMLNodePointer_t TGDMLParse::ElCone ; (; TXMLEngine * ; gdml, . XMLNodePointer_t ; node, . XMLAttrPointer_t ; attr . ). private . In the solids section of the GDML file, an elliptical cone may be declared. ; Unfortunately, the elliptical cone is not supported under ROOT so, when the elcone keyword is found, this function is called to convert it to a simple box with similar dimensions, and the dimensions required are taken and stored, these are then bound and converted to type TGeoBBox and stored in fsolmap map using the name as its key. ; Definition at line 2707 of file TGDMLParse.cxx. ◆ EleProcess(). XMLNodePointer_t TGDMLParse::EleProcess ; (; TXMLEngine * ; gdml, . XMLNodePointer_t ; node, . XMLNodePointer_t ; parentn, . Bool_t ; hasIsotopes, . Bool_t ; hasIsotopesExtended . ). private . When the element keyword is found, this function is called, and the name and values of the element are converted into type TGeoElement and stored in felemap map using the name as its key. ; Definition at line 1086 of file TGDMLParse.cxx. ◆ Ellipsoid(). XMLNodePointer_t TGDMLParse::Ellipsoid ; (; TXMLEngine * ; gdml, . XMLNodePointer_t ; node, . XMLAttrPointer_t ; attr . ). private . In the solids section of the GDML file, an ellipsoid may be declared. ; Unfortunately, the ellipsoid is not supported under ROOT so, when the ellipsoid keyword is found, this function is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGDMLParse.html:30501,simpl,simple,30501,doc/master/classTGDMLParse.html,https://root.cern,https://root.cern/doc/master/classTGDMLParse.html,1,['simpl'],['simple']
Usability,"d. <one line to give the library's name and a brief idea of what it does>; Copyright (C) <year> <name of author>. This library is free software; you can redistribute it and/or; modify it under the terms of the GNU Lesser General Public; License as published by the Free Software Foundation; either; version 2.1 of the License, or (at your option) any later version. This library is distributed in the hope that it will be useful,; but WITHOUT ANY WARRANTY; without even the implied warranty of; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU; Lesser General Public License for more details. You should have received a copy of the GNU Lesser General Public; License along with this library; if not, write to the Free Software; Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA. Also add information on how to contact you by electronic and paper mail. You should also get your employer (if you work as a programmer) or your; school, if any, to sign a ""copyright disclaimer"" for the library, if; necessary. Here is a sample; alter the names:. Yoyodyne, Inc., hereby disclaims all copyright interest in the; library `Frob' (a library for tweaking knobs) written by James Random Hacker. <signature of Ty Coon> 1 April 1990; Ty Coon, President of Vice. That's all there is to it!. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/license.html:28840,guid,guidelines,28840,d/license.html,https://root.cern,https://root.cern/d/license.html,1,['guid'],['guidelines']
Usability,"d. In particular, a helix describes the trajectory of a charged particle in magnetic; field. In such case, the helix is right-handed for negative particle charge.; To define a helix, one must define:; - the curvature - positive defined; - the Z step made after one full turn of the helix; - the particle charge sign; - the initial particle position and direction (force normalization to unit); - the magnetic field direction. A helix provides:; - propagation to a given Z position (in global frame); Double_t *point = TGeoHelix::PropagateToZ(Double_t z);; - propagation to an arbitrary plane, returning also the new point; - propagation in a geometry until the next crossed surface; - computation of the total track length along a helix. Function Members (Methods); public:. virtual~TGeoHelix(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; Double_tComputeSafeStep(Double_t epsil = 9.9999999999999995E-7) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoHelix.html:1649,Clear,Clear,1649,root/html602/TGeoHelix.html,https://root.cern,https://root.cern/root/html602/TGeoHelix.html,2,['Clear'],['Clear']
Usability,"d.; The object falls outside some ‘interest’ limits of the viewer camera.; The object is too small to be worth drawing. In all these cases TBuffer3D::AddObject() returns kNone, as it does for successful addition, indicating it does not require further information about this object. Hence you should not try to make any assumptions about what the viewer did with the object. The viewer may decide to force the client to rebuild (republish) the scene, obtaining a different collection of objects, if the internal viewer state changes .e.g. significant camera move. It does this presently by forcing a repaint on the attached TPad object - hence you should attach you master geometry object to the pad (via TObject::Draw()), and perform the publishing to the viewer in response to TObject::Paint().; 9.13.4.9 Physical IDs; TVirtualViewer3D provides for two methods of object addition:; virtual Int_t AddObject(const TBuffer3D &buffer,; Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID,; const TBuffer3D & buffer,; Bool_t *addChildren = 0); If you use the first (simple) case a viewer using logical/physical pairs will generate sequential IDs for each physical object internally. Scene rebuilds will require destruction and recreation of all physical objects. For the second you can specify an identifier from the client side, which must be unique and stable - i.e. the IDs of a published object is consistent, regardless of changes in termination of contained child geometry branches. In this case the viewer can safely cache the physical objects across scene rebuilds, discarding those no longer of interest.; 9.13.4.10 Child Objects; In many geometries there is a rigid containment hierarchy, and so if the viewer is not interested in a certain object due to limits/size then it will also not be interest in any of the contained branch of siblings. Both TBuffer3D::AddObject() methods have an addChildren return parameter. The viewer will complete this (if passed) indicating if ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:416688,simpl,simple,416688,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"d::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetConfidenceLevel(Double_t cl); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetInterpolationOption(RooStats::HypoTestInverterResult::InterpolOption_t opt); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetTestSize(Double_t size); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); RooStats::SimpleIntervalRooStats::SimpleInterval::SimpleInterval(const char* name = 0); RooStats::SimpleIntervalRooStats::SimpleInterval::SimpleInterval(const RooStats::SimpleInterval&); RooStats::SimpleIntervalRooStats::SimpleInterval::SimpleInterval(const char* name, const RooRealVar& var, Double_t lower, Double_t upper, Double_t cl); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Double_tUpperLimit(); Double_tUpperLimitEstimatedError(); voidUseCLs(bool on = true); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__HypoTestInverterResult.html:6682,Simpl,SimpleIntervalRooStats,6682,root/html532/RooStats__HypoTestInverterResult.html,https://root.cern,https://root.cern/root/html532/RooStats__HypoTestInverterResult.html,10,['Simpl'],"['SimpleInterval', 'SimpleIntervalRooStats']"
Usability,"d::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; std::string createLabel () const;  Compile a string with all the labels of the serving categories, such as {1Jet;1Lepton;2Tag}. ;  ; value_type evaluate () const override;  Calculate the current value. ;  ; void recomputeShape () override;  Inspect all the subcategories, and enumerate and name their states. ;  ;  Protected Member Functions inherited from RooAbsCategory; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach the category index and label as branches to the given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  Attach the category index and label to as branches to the given vector store. ;  ; void clearTypes ();  Delete all currently defined states. ;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValueDirty=true) override;  Copy the cached value from given source and raise dirty flag. ;  ; virtual const std::map< std::string, RooAbsCategory::value_type >::value_type & defineState (const std::string &label);  Define a new state with given label. ;  ; virtual const std::map< std::string, RooAbsCategory::value_type >::value_type & defineState (const std::string &label, value_type index);  Define new state with given name and index number. ;  ; void defineStateUnchecked (const std::string &label, value_type index);  Internal version of defineState() that does not check if type already exists. ;  ; void fillTreeBranch (TTree &t) override;  Fill tree branches associated with current object with current value. ;  ; bool isValid () const override;  WVE (08/21/01) Probably obsolete now. ;  ; value_type nextAvailableStateIndex () const;  ; RooCatType * retrieveLegacyState (value_ty",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMultiCategory.html:35670,clear,clearTypes,35670,doc/master/classRooMultiCategory.html,https://root.cern,https://root.cern/doc/master/classRooMultiCategory.html,1,['clear'],['clearTypes']
Usability,"d; The array dimension is the number of bins in the histograms; including underflow and overflow (fNCells); the last value integral[fNCells] is set to the number of entries of; the histogram. void Copy(TObject& hnew) const; -*-*-*-*-*Copy this histogram structure to newth1*-*-*-*-*-*-*-*-*-*-*-*. Note that this function does not copy the list of associated functions.; Use TObject::Clone to make a full copy of an histogram. void DirectoryAutoAdd(TDirectory* ); Perform the automatic addition of the histogram to the given directory. Note this function is called in place when the semantic requires; this object to be added to a directory (I.e. when being read from; a TKey or being Cloned). Int_t DistancetoPrimitive(Int_t px, Int_t py); -*-*-*-*-*-*-*-*-*Compute distance from point px,py to a line*-*-*-*-*-*. Compute the closest distance of approach from point px,py to elements; of an histogram.; The distance is computed in pixels units. Algorithm:; Currently, this simple model computes the distance from the mouse; to the histogram contour only. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. void Divide(TF1* f1, Double_t c1 = 1); Performs the operation: this = this/(c1*f1); if errors are defined (see TH1::Sumw2), errors are also recalculated. Only bins inside the function range are recomputed.; IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Divide. void Divide(const TH1* h1); -*-*-*-*-*-*-*-*-*Divide this histogram by h1*-*-*-*-*-*-*-*-*-*-*-*-*. this = this/h1; if errors are defined (see TH1::Sumw2), errors are also recalculated.; Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; if not already set.; The resulting errors are calculated assuming uncorrelated histograms.; See the other TH1::Divide that gives the possibility to optionally; compute binomial errors. IMPORTANT NOTE: If yo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TH1.html:58807,simpl,simple,58807,root/html532/TH1.html,https://root.cern,https://root.cern/root/html532/TH1.html,2,['simpl'],['simple']
Usability,"d<(useForTraining-availableTraining) ||; 1284 availableUndefined<(useForTesting -availableTesting ) ||; 1285 availableUndefined<(useForTraining+useForTesting-availableTraining-availableTesting ) ){; 1286 Log() << kFATAL << Form(""Dataset[%s] : "",dsi.GetName())<< ""More events requested than available!"" << Endl;; 1287 }; 1288 ; 1289 // select the events; 1290 if (useForTraining>availableTraining){; 1291 eventVectorTraining.insert( eventVectorTraining.end() , eventVectorUndefined.begin(), eventVectorUndefined.begin()+ useForTraining- availableTraining );; 1292 eventVectorUndefined.erase( eventVectorUndefined.begin(), eventVectorUndefined.begin() + useForTraining- availableTraining);; 1293 }; 1294 if (useForTesting>availableTesting){; 1295 eventVectorTesting.insert( eventVectorTesting.end() , eventVectorUndefined.begin(), eventVectorUndefined.begin()+ useForTesting- availableTesting );; 1296 }; 1297 }; 1298 eventVectorUndefined.clear();; 1299 ; 1300 // finally shorten the event vectors to the requested size by removing random events; 1301 if (splitMode.Contains( ""RANDOM"" )){; 1302 UInt_t sizeTraining = eventVectorTraining.size();; 1303 if( sizeTraining > UInt_t(requestedTraining) ){; 1304 std::vector<UInt_t> indicesTraining( sizeTraining );; 1305 // make indices; 1306 std::generate( indicesTraining.begin(), indicesTraining.end(), TMVA::Increment<UInt_t>(0) );; 1307 // shuffle indices; 1308 std::shuffle(indicesTraining.begin(), indicesTraining.end(), rndm);; 1309 // erase indices of not needed events; 1310 indicesTraining.erase( indicesTraining.begin()+sizeTraining-UInt_t(requestedTraining), indicesTraining.end() );; 1311 // delete all events with the given indices; 1312 for( std::vector<UInt_t>::iterator it = indicesTraining.begin(), itEnd = indicesTraining.end(); it != itEnd; ++it ){; 1313 delete eventVectorTraining.at( (*it) ); // delete event; 1314 eventVectorTraining.at( (*it) ) = NULL; // set pointer to NULL; 1315 }; 1316 // now remove and erase all events with point",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataSetFactory_8cxx_source.html:57227,clear,clear,57227,doc/master/DataSetFactory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html,1,['clear'],['clear']
Usability,"dAddBinContent(Int_t bin); virtual voidAddBinContent(Int_t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDirectoryStatus(); voidTArrayF::Adopt(Int_t n, Float_t* array); virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Option_t* option = """") const; virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Double_t& advalue) const; virtual voidTObject::AppendPad(Option_t* option = """"); Float_tTArrayF::At(Int_t i) const; virtual voidTH1::Browse(TBrowser* b); virtual Int_tTH1::BufferEmpty(Int_t action = 0); virtual Bool_tTH1::CanExtendAllAxes() const; virtual Double_tTH1::Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTH1::ClearUnderflowAndOverflow(); virtual TObject*TH1::Clone(const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(Bool_t onlyPositive = false); virtual voidCopy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTH1::Divide(const TH1* h1); virtual Bool_tTH1::Divide(TF1* f1, Double_t c1 = 1); virtual Bool_tTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*TH1::DrawCopy(Option_t* option = """", const char*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH1F.html:1750,Clear,Clear,1750,root/html602/TH1F.html,https://root.cern,https://root.cern/root/html602/TH1F.html,2,['Clear'],['Clear']
Usability,"dAddBinContent(Int_t bin); virtual voidAddBinContent(Int_t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDirectoryStatus(); voidTArrayF::Adopt(Int_t n, Float_t* array); virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Option_t* option = """") const; virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Double_t& advalue) const; virtual voidTObject::AppendPad(Option_t* option = """"); Float_tTArrayF::At(Int_t i) const; virtual voidTH1::Browse(TBrowser* b); virtual Int_tTH2::BufferEmpty(Int_t action = 0); virtual Bool_tTH1::CanExtendAllAxes() const; virtual Double_tTH1::Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTH1::ClearUnderflowAndOverflow(); virtual TObject*TH1::Clone(const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(Bool_t onlyPositive = false); virtual voidCopy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTH1::Divide(const TH1* h1); virtual Bool_tTH1::Divide(TF1* f1, Double_t c1 = 1); virtual Bool_tTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*TH1::DrawCopy(Option_t* option = """", const char*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH2F.html:1731,Clear,Clear,1731,root/html602/TH2F.html,https://root.cern,https://root.cern/root/html602/TH2F.html,2,['Clear'],['Clear']
Usability,"dAddBinContent(Int_t bin); virtual voidAddBinContent(Int_t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDirectoryStatus(); voidTArrayF::Adopt(Int_t n, Float_t* array); virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Option_t* option = """") const; virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Double_t& advalue) const; virtual voidTObject::AppendPad(Option_t* option = """"); Float_tTArrayF::At(Int_t i) const; virtual voidTH1::Browse(TBrowser* b); virtual Int_tTH3::BufferEmpty(Int_t action = 0); virtual Bool_tTH1::CanExtendAllAxes() const; virtual Double_tTH1::Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTH1::ClearUnderflowAndOverflow(); virtual TObject*TH1::Clone(const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(Bool_t onlyPositive = false); virtual voidCopy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTH1::Divide(const TH1* h1); virtual Bool_tTH1::Divide(TF1* f1, Double_t c1 = 1); virtual Bool_tTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*TH1::DrawCopy(Option_t* option = """", const char*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH3F.html:1731,Clear,Clear,1731,root/html602/TH3F.html,https://root.cern,https://root.cern/root/html602/TH3F.html,2,['Clear'],['Clear']
Usability,"dAddBinContent(Int_t bin); virtual voidAddBinContent(Int_t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDirectoryStatus(); voidTArrayS::Adopt(Int_t n, Short_t* array); virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Option_t* option = """") const; virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Double_t& advalue) const; virtual voidTObject::AppendPad(Option_t* option = """"); Short_tTArrayS::At(Int_t i) const; virtual voidTH1::Browse(TBrowser* b); virtual Int_tTH1::BufferEmpty(Int_t action = 0); virtual Bool_tTH1::CanExtendAllAxes() const; virtual Double_tTH1::Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTH1::ClearUnderflowAndOverflow(); virtual TObject*TH1::Clone(const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(Bool_t onlyPositive = false); virtual voidCopy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTH1::Divide(const TH1* h1); virtual Bool_tTH1::Divide(TF1* f1, Double_t c1 = 1); virtual Bool_tTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*TH1::DrawCopy(Option_t* option = """", const char*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH1S.html:1751,Clear,Clear,1751,root/html602/TH1S.html,https://root.cern,https://root.cern/root/html602/TH1S.html,2,['Clear'],['Clear']
Usability,"dAddBinContent(Int_t bin); virtual voidAddBinContent(Int_t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDirectoryStatus(); voidTArrayS::Adopt(Int_t n, Short_t* array); virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Option_t* option = """") const; virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Double_t& advalue) const; virtual voidTObject::AppendPad(Option_t* option = """"); Short_tTArrayS::At(Int_t i) const; virtual voidTH1::Browse(TBrowser* b); virtual Int_tTH2::BufferEmpty(Int_t action = 0); virtual Bool_tTH1::CanExtendAllAxes() const; virtual Double_tTH1::Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTH1::ClearUnderflowAndOverflow(); virtual TObject*TH1::Clone(const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(Bool_t onlyPositive = false); virtual voidCopy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTH1::Divide(const TH1* h1); virtual Bool_tTH1::Divide(TF1* f1, Double_t c1 = 1); virtual Bool_tTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*TH1::DrawCopy(Option_t* option = """", const char*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH2S.html:1738,Clear,Clear,1738,root/html602/TH2S.html,https://root.cern,https://root.cern/root/html602/TH2S.html,2,['Clear'],['Clear']
Usability,"dAddBinContent(Int_t bin); virtual voidAddBinContent(Int_t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDirectoryStatus(); voidTArrayS::Adopt(Int_t n, Short_t* array); virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Option_t* option = """") const; virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Double_t& advalue) const; virtual voidTObject::AppendPad(Option_t* option = """"); Short_tTArrayS::At(Int_t i) const; virtual voidTH1::Browse(TBrowser* b); virtual Int_tTH3::BufferEmpty(Int_t action = 0); virtual Bool_tTH1::CanExtendAllAxes() const; virtual Double_tTH1::Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTH1::ClearUnderflowAndOverflow(); virtual TObject*TH1::Clone(const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(Bool_t onlyPositive = false); virtual voidCopy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTH1::Divide(const TH1* h1); virtual Bool_tTH1::Divide(TF1* f1, Double_t c1 = 1); virtual Bool_tTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*TH1::DrawCopy(Option_t* option = """", const char*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH3S.html:1738,Clear,Clear,1738,root/html602/TH3S.html,https://root.cern,https://root.cern/root/html602/TH3S.html,2,['Clear'],['Clear']
Usability,"dAdjustPosition(TGListTreeItem* item); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGContainer::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); voidCheckAllChildren(TGListTreeItem* item, Bool_t state); virtual voidChecked(TObject* obj, Bool_t check)SIGNAL ; voidCheckItem(TGListTreeItem* item, Bool_t check = kTRUE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); voidClearHighlighted(); virtual voidTGContainer::ClearViewPort(); virtual voidClicked(TGListTreeItem* entry, Int_t btn)SIGNAL ; virtual voidClicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y)SIGNAL ; virtual voidClicked(TGListTreeItem* entry, Int_t btn, UInt_t mask, Int_t x, Int_t y)SIGNAL ; virtual TObject*TObject::Clone(const char* newname = """") const; voidCloseItem(TGListTreeItem* item); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGListTree.html:2687,Clear,ClearViewPort,2687,root/html532/TGListTree.html,https://root.cern,https://root.cern/root/html532/TGListTree.html,4,['Clear'],['ClearViewPort']
Usability,"dAfter(const TObject* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidTObjArray::AddAt(TObject* obj, Int_t idx); virtual voidTObjArray::AddAtAndExpand(TObject* obj, Int_t idx); virtual Int_tTObjArray::AddAtFree(TObject* obj); virtual voidTObjArray::AddBefore(const TObject* before, TObject* obj); virtual voidTObjArray::AddFirst(TObject* obj); virtual voidTObjArray::AddLast(TObject* obj); voidTCollection::AddVector(TObject* obj1); virtual TObject*TObjArray::After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*TObjArray::At(Int_t i) const; virtual TObject*TObjArray::Before(const TObject* obj) const; virtual Int_tTObjArray::BinarySearch(TObject* obj, Int_t upto = kMaxInt); virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObjArray::Clear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; virtual voidTObjArray::Compress(); Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObjArray::Delete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__TSchemaMatch.html:1473,Clear,Clear,1473,root/html532/ROOT__TSchemaMatch.html,https://root.cern,https://root.cern/root/html532/ROOT__TSchemaMatch.html,1,['Clear'],['Clear']
Usability,"dByFignore()""; in addition, the number of strings which were not ""ExcludedByFignore()"" is returned in ""nGoodStrings"". ; Definition at line 685 of file TTabCom.cxx. ◆ AppendListOfFilesInDirectory(). void TTabCom::AppendListOfFilesInDirectory ; (; const char ; dirName[], . TSeqCollection * ; pList . ). static . [static utility function]///////////////////////////// ; adds a TObjString to ""*pList"" for each entry found in the system directory ""dirName""; directories that do not exist are silently ignored. ; Definition at line 750 of file TTabCom.cxx. ◆ Class(). static TClass * TTabCom::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TTabCom::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TTabCom::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 226 of file TTabCom.h. ◆ ClearAll(). void TTabCom::ClearAll ; (; ). clears all lists except for user names and system include files. ; Definition at line 319 of file TTabCom.cxx. ◆ ClearClasses(). void TTabCom::ClearClasses ; (; ). Clear classes and namespace collections. ; Definition at line 218 of file TTabCom.cxx. ◆ ClearCppDirectives(). void TTabCom::ClearCppDirectives ; (; ). Forget all Cpp directives seen so far. ; Definition at line 230 of file TTabCom.cxx. ◆ ClearEnvVars(). void TTabCom::ClearEnvVars ; (; ). Forget all environment variables seen so far. ; Definition at line 242 of file TTabCom.cxx. ◆ ClearFiles(). void TTabCom::ClearFiles ; (; ). Close all files. ; Definition at line 254 of file TTabCom.cxx. ◆ ClearGlobalFunctions(). void TTabCom::ClearGlobalFunctions ; (; ). Forget all global functions seen so far. ; Not needed anymore. Use gROOT->GetListOfGlobalFunctions() ; Definition at line 267 of file TTabCom.cxx. ◆ ClearGlobals(). void TTabCom::ClearGlobals ; (; ). Forget all global variables seen so far. ; With teh new implamentation the list is gROOT->GetListOfGlobal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTabCom.html:9276,clear,clears,9276,doc/master/classTTabCom.html,https://root.cern,https://root.cern/doc/master/classTTabCom.html,1,['clear'],['clears']
Usability,"dDL.h:153; TMVA::MethodDL::ParseRecurrentLayervoid ParseRecurrentLayer(ERecurrentLayerType type, DNN::TDeepNet< Architecture_t, Layer_t > &deepNet, std::vector< DNN::TDeepNet< Architecture_t, Layer_t > > &nets, TString layerString, TString delim)Pases the layer string and creates the appropriate rnn layer.Definition MethodDL.cxx:931; TMVA::MethodDL::fTrainingSettingsstd::vector< TTrainingSettings > fTrainingSettingsThe vector defining each training strategy.Definition MethodDL.h:204; TMVA::MethodDL::GetInputWidthsize_t GetInputWidth() constDefinition MethodDL.h:257; TMVA::MethodDL::SetInputShapevoid SetInputShape(std::vector< size_t > inputShape)Definition MethodDL.h:289; TMVA::MethodDL::GetLossFunctionDNN::ELossFunction GetLossFunction() constDefinition MethodDL.h:270; TMVA::MethodDL::fBatchLayoutStringTString fBatchLayoutStringThe string defining the layout of the batch.Definition MethodDL.h:193; TMVA::MethodDL::HasAnalysisTypeBool_t HasAnalysisType(Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets)Check the type of analysis the deep learning network can do.Definition MethodDL.cxx:1091; TMVA::MethodDL::ParseConvLayervoid ParseConvLayer(DNN::TDeepNet< Architecture_t, Layer_t > &deepNet, std::vector< DNN::TDeepNet< Architecture_t, Layer_t > > &nets, TString layerString, TString delim)Pases the layer string and creates the appropriate convolutional layer.Definition MethodDL.cxx:669; TMVA::MethodDL::ParseReshapeLayervoid ParseReshapeLayer(DNN::TDeepNet< Architecture_t, Layer_t > &deepNet, std::vector< DNN::TDeepNet< Architecture_t, Layer_t > > &nets, TString layerString, TString delim)Pases the layer string and creates the appropriate reshape layer.Definition MethodDL.cxx:829; TMVA::MethodDL::GetRegressionValuesvirtual const std::vector< Float_t > & GetRegressionValues(); TMVA::MethodDL::fTrainingStrategyStringTString fTrainingStrategyStringThe string defining the training strategy.Definition MethodDL.h:196; TMVA::MethodDL::CreateRankingconst Rankin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:109536,learn,learning,109536,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['learn'],['learning']
Usability,"dEnvVar(const char* name, const char* value); voidTProof::AddFeedback(const char* name); Int_tTProof::AddIncludePath(const char* incpath, Bool_t onClient = kFALSE, TList* wrks = 0); voidTProof::AddInput(TObject* obj); voidTProof::AddInputData(TObject* obj, Bool_t push = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); Int_tTProof::Archive(Int_t query, const char* url); Int_tTProof::Archive(const char* queryref, const char* url = 0); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTProof::Browse(TBrowser* b); voidTProof::cd(Int_t id = -1); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; Int_tTProof::CleanupSession(const char* sessiontag); virtual voidTNamed::Clear(Option_t* option = """"); virtual voidClearCache(const char* file = 0); voidTProof::ClearData(UInt_t what = kUnregistered, const char* dsname = 0); virtual voidClearDataSetCache(const char* dataset = 0); voidTProof::ClearFeedback(); voidTProof::ClearInput(); voidTProof::ClearInputData(TObject* obj = 0); voidTProof::ClearInputData(const char* name); Int_tTProof::ClearPackage(const char* package); Int_tTProof::ClearPackages(); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTProof::Close(Option_t* option = """"); voidTProof::CloseProgressDialog()SIGNAL ; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofLite.html:2032,Clear,ClearData,2032,root/html532/TProofLite.html,https://root.cern,https://root.cern/root/html532/TProofLite.html,1,['Clear'],['ClearData']
Usability,"dNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tfOneTime! used in the learning phase ; Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch!Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.; TTreeCache::EPrefillTypefPrefillTypeWhether a prefilling is enabled (and if applicable which type); Int_tTFileCacheRead::fReadCallsNumber of read calls for this cache; Bool_tfReadDirectionSet! read direction established; Bool_tfReverseRead! reading in reverse mode ; Long64_t*TFileCacheRead::fSeek[fNseek] Position on file of buffers to be prefetched; Int_t*TFileCacheRead::fSeekIndex[fNseek] sorted index table of fSeek; Int_t*TFileCacheRead::fSeekLen[fNseek] Length of buffers to be prefetched; Int_t*TFileCacheRead::fSeekPos[fNseek] Position of sorted blocks in fBuffer; Int_tTFileCacheRead::fSeekSizeAllocated size of fSeek; Long64_t*TFileCacheRead::fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*TFileCacheRead::fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted); TTree*fTree! pointer to the current Tree; static Int_tfgLearnEntriesnumber of entries used for learning mode. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeCache(); Default Constructor. TTreeCache(TTree* tree, Int_t buffersize = 0); Constructor. ~TTreeCache(); destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subgbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); Add a branch to the list of branches to be s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:21092,learn,learning,21092,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,2,['learn'],['learning']
Usability,"dObjectUtils;  ; namespace  TypeTraits;  ROOT type_traits extensions. ;  ; namespace  v5;  ; namespace  VecOps;  . Classes; struct  RCompressionSetting;  The global settings depend on a global variable named R__ZipMode which can be modified by a global function named R__SetZipMode. More...;  ; class  RDataFrame;  ROOT's RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV's and other data formats. More...;  ; class  ROpaqueTaskArena;  ; class  TExecutor;  This class defines an interface to execute the same task multiple times in parallel, possibly with different arguments every time. More...;  ; class  TGenericClassInfo;  ; class  TIOFeatures;  TIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TTree. More...;  ; class  TModuleGenerator;  ; class  TNumSlots;  Defines the number of threads in some of ROOT's interfaces. More...;  ; class  TProcessExecutor;  This class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time. More...;  ; class  TReadLockGuard;  ; class  TReentrantRWLock;  ; class  TRWMutexImp;  ; class  TRWSpinLock;  ; class  TRWSpinLockReadGuard;  ; class  TRWSpinLockWriteGuard;  ; class  TSchemaRule;  ; class  TSeq;  A pseudo container class which is a generator of indices. More...;  ; class  TSequentialExecutor;  ; class  TSpinMutex;  A spin mutex class which respects the STL interface for mutexes. More...;  ; class  TThreadedObject;  A wrapper to make object instances thread private, lazily. More...;  ; class  TThreadExecutor;  This class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time. More...;  ; class  TTreeProcessorMP;  This class provides an interface to process a TTree dataset in parallel with multi-process technology. More...;  ; class  TTreeProcessorMT;  A class to process the entries of a TTree in parallel. More...;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v622/namespaceROOT.html:2173,simpl,simple,2173,doc/v622/namespaceROOT.html,https://root.cern,https://root.cern/doc/v622/namespaceROOT.html,1,['simpl'],['simple']
Usability,"dPdf::setAllExtendable ; (; bool ; allExtendable). inlineprivate . Definition at line 151 of file RooAddPdf.h. ◆ setCacheAndTrackHints(). void RooAddPdf::setCacheAndTrackHints ; (; RooArgSet & ; trackNodes). overridevirtual . Label OK'ed components of a RooAddPdf with cache-and-track. ; Reimplemented from RooAbsArg.; Definition at line 938 of file RooAddPdf.cxx. ◆ setRecursiveFraction(). void RooAddPdf::setRecursiveFraction ; (; bool ; recursiveFraction). inlineprivate . Definition at line 150 of file RooAddPdf.h. ◆ Streamer(). void RooAddPdf::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsPdf. ◆ StreamerNVirtual(). void RooAddPdf::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 153 of file RooAddPdf.h. ◆ translate(). void RooAddPdf::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 548 of file RooAddPdf.cxx. ◆ updateCoefficients(). void RooAddPdf::updateCoefficients ; (; AddCacheElem & ; cache, . const RooArgSet * ; nset, . bool ; syncCoefValues = true . ); const. protected . Update the coefficient values in the given cache element: calculate new remainder fraction, normalize fractions obtained from extended ML terms to unity, and multiply the various range and dimensional corrections needed in the curre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAddPdf.html:94712,simpl,simple,94712,doc/v632/classRooAddPdf.html,https://root.cern,https://root.cern/doc/v632/classRooAddPdf.html,2,['simpl'],['simple']
Usability,"dRatioTestStatSimpleLikelihoodRatioTestStat(); RooStats::SimpleLikelihoodRatioTestStatSimpleLikelihoodRatioTestStat(const RooStats::SimpleLikelihoodRatioTestStat&); RooStats::SimpleLikelihoodRatioTestStatSimpleLikelihoodRatioTestStat(RooAbsPdf& nullPdf, RooAbsPdf& altPdf); RooStats::SimpleLikelihoodRatioTestStatSimpleLikelihoodRatioTestStat(RooAbsPdf& nullPdf, RooAbsPdf& altPdf, const RooArgSet& nullParameters, const RooArgSet& altParameters); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; private:. RooArgSet*fAltParameters; RooAbsPdf*fAltPdf; RooArgSetfConditionalObs; RooArgSet*fDetailedOutput!; boolfDetailedOutputEnabled; boolfFirstEval; RooAbsReal*fNllAlt! transient copy of the alt NLL; RooAbsReal*fNllNull! transient copy of the null NLL; RooArgSet*fNullParameters; RooAbsPdf*fNullPdf; Bool_tfReuseNll; static Bool_tfgAlwaysReuseNll. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SimpleLikelihoodRatioTestStat(). SimpleLikelihoodRatioTestStat(RooAbsPdf& nullPdf, RooAbsPdf& altPdf). SimpleLikelihoodRatioTestStat(RooAbsPdf& nullPdf, RooAbsPdf& altPdf, const RooArgSet& nullParameters, const RooArgSet& altParameters). virtual ~SimpleLikelihoodRatioTestStat(). void SetAlwaysReuseNLL(Bool_t flag). void SetReuseNLL(Bool_t flag); { fReuseNll = flag ; }. void SetNullParameters(const RooArgSet& nullParameters). void SetAltParameters(const RooArgSet& altParameters). bool ParamsAreEqual(). void SetConditionalObservables(const RooArgSet& set); set the conditional observables which will be used when creating the NLL; so the pdf's will not be normalized on the conditional observables when computing the NLL. {fConditionalObs.removeAll(); fConditionalObs.add(set);}. Double_t Evaluate(RooAbsData& data, RooArgSet& nullPOI). void EnableDetailedOutput(bool e = true); { fDetailedOutputEnabled = e; fDetailedOutput = NULL; }. const RooArgSet* GetDetailedOutput(void); { return fDetailedOutp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__SimpleLikelihoodRatioTestStat.html:2319,Simpl,SimpleLikelihoodRatioTestStat,2319,root/html534/RooStats__SimpleLikelihoodRatioTestStat.html,https://root.cern,https://root.cern/root/html534/RooStats__SimpleLikelihoodRatioTestStat.html,1,['Simpl'],['SimpleLikelihoodRatioTestStat']
Usability,"dRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Int_tcalculateBandWidth(Int_t kernel = -999); Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/Roo2DKeysPdf.html:2968,clear,clearValueDirty,2968,root/html534/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html534/Roo2DKeysPdf.html,6,['clear'],['clearValueDirty']
Usability,"dSelectionColorBitsTEveElement::kCSCBApplyMainColorToAllChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainColorToMatchingChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainTransparencyToAllChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainTransparencyToMatchingChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBImplySelectAllChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBTakeAnyParentAsMaster; static TEveElement::EDestructTEveElement::kNone; static TEveElement::EDestructTEveElement::kStandard. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveScene(const char* n = ""TEveScene"", const char* t = """"); Constructor. TEveScene(TGLScenePad* gl_scene, const char* n = ""TEveScene"", const char* t = """"); Constructor. ~TEveScene(); Destructor. void CollectSceneParents(TEveElement::List_t& scenes); Virtual from TEveElement; here we simply append this scene to; the list. void Repaint(Bool_t dropLogicals = kFALSE); Repaint the scene. void RetransHierarchically(); Entry point for hierarchical transformation update.; Calls the recursive variant on all children. void RetransHierarchicallyRecurse(TEveElement* el, const TEveTrans& tp); Set transformation matrix for physical shape of element el in; the GL-scene and recursively descend into children (if enabled). void SetName(const char* n); Set scene's name. void Paint(Option_t* option = """"); Paint the scene. Iterate over children and calls PadPaint(). void DestroyElementRenderers(TEveElement* element); Remove element from the scene.; It is not an error if the element is not found in the scene. void DestroyElementRenderers(TObject* rnrObj); Remove element represented by object rnrObj from the scene.; It is not an error if the element is not found in the scene. const TGPicture* GetListTreeIcon(Bool_t open = kFALSE); Return icon for scene. TEveSce",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveScene.html:21606,simpl,simply,21606,root/html602/TEveScene.html,https://root.cern,https://root.cern/root/html602/TEveScene.html,4,['simpl'],['simply']
Usability,"dServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); Bool_taddThreshold(Double_t upperLimit, const char* catName, Int_t catIdx = -99999); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooThresholdCategory.html:2092,Clear,Clear,2092,root/html532/RooThresholdCategory.html,https://root.cern,https://root.cern/root/html532/RooThresholdCategory.html,1,['Clear'],['Clear']
Usability,"dTArrayC::AddAt(Char_t c, Int_t i); virtual voidAddBinContent(Int_t bin); virtual voidAddBinContent(Int_t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDirectoryStatus(); voidTArrayC::Adopt(Int_t n, Char_t* array); virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Option_t* option = """") const; virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Double_t& advalue) const; virtual voidTObject::AppendPad(Option_t* option = """"); Char_tTArrayC::At(Int_t i) const; virtual voidTH1::Browse(TBrowser* b); virtual Int_tTH1::BufferEmpty(Int_t action = 0); virtual Double_tTH1::Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(Bool_t onlyPositive = false); virtual voidCopy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTH1::Divide(const TH1* h1); virtual Bool_tTH1::Divide(TF1* f1, Double_t c1 = 1); virtual Bool_tTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH1C.html:1976,Clear,Clear,1976,root/html534/TH1C.html,https://root.cern,https://root.cern/root/html534/TH1C.html,1,['Clear'],['Clear']
Usability,"dTArrayC::AddAt(Char_t c, Int_t i); virtual voidAddBinContent(Int_t bin); virtual voidAddBinContent(Int_t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDirectoryStatus(); voidTArrayC::Adopt(Int_t n, Char_t* array); virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Option_t* option = """") const; virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Double_t& advalue) const; virtual voidTObject::AppendPad(Option_t* option = """"); Char_tTArrayC::At(Int_t i) const; virtual voidTH1::Browse(TBrowser* b); virtual Int_tTH2::BufferEmpty(Int_t action = 0); virtual Double_tTH1::Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(Bool_t onlyPositive = false); virtual voidCopy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTH1::Divide(const TH1* h1); virtual Bool_tTH1::Divide(TF1* f1, Double_t c1 = 1); virtual Bool_tTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH2C.html:2318,Clear,Clear,2318,root/html534/TH2C.html,https://root.cern,https://root.cern/root/html534/TH2C.html,1,['Clear'],['Clear']
Usability,"dTArrayC::AddAt(Char_t c, Int_t i); virtual voidAddBinContent(Int_t bin); virtual voidAddBinContent(Int_t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDirectoryStatus(); voidTArrayC::Adopt(Int_t n, Char_t* array); virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Option_t* option = """") const; virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Double_t& advalue) const; virtual voidTObject::AppendPad(Option_t* option = """"); Char_tTArrayC::At(Int_t i) const; virtual voidTH1::Browse(TBrowser* b); virtual Int_tTH3::BufferEmpty(Int_t action = 0); virtual Double_tTH1::Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(Bool_t onlyPositive = false); virtual voidCopy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTH1::Divide(const TH1* h1); virtual Bool_tTH1::Divide(TF1* f1, Double_t c1 = 1); virtual Bool_tTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH3C.html:2188,Clear,Clear,2188,root/html534/TH3C.html,https://root.cern,https://root.cern/root/html534/TH3C.html,1,['Clear'],['Clear']
Usability,"dTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()SIGNAL ; virtual voidTGWindow::DestroySubwindows(); virtual voidTGWindow::DestroyWindow(); Bool_tTQObject::Disconnect(const char",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TFitParametersDialog.html:1653,Clear,Clear,1653,root/html532/TFitParametersDialog.html,https://root.cern,https://root.cern/root/html532/TFitParametersDialog.html,40,['Clear'],['Clear']
Usability,"dTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTGMainFrame::CloseWindow()SIGNAL ; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()SIGNAL ; virtual voidTGWindow::DestroySubwindows(); virtual voidTGWindow::DestroyWindow(); Bool_tTQObject::D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TAdvancedGraphicsDialog.html:1693,Clear,Clear,1693,root/html532/TAdvancedGraphicsDialog.html,https://root.cern,https://root.cern/root/html532/TAdvancedGraphicsDialog.html,44,['Clear'],['Clear']
Usability,"dTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual voidColorSelected(Pixel_t)SIGNAL ; virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()SIGNAL ; virtual voidTGWindow::DestroySubwindows(); virtual voidTGWindow::DestroyWindow(); Bool_tTQObject::Disco",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGColorDialog.html:2219,Clear,Clear,2219,root/html532/TGColorDialog.html,https://root.cern,https://root.cern/root/html532/TGColorDialog.html,1,['Clear'],['Clear']
Usability,"dTObject::AbstractMethod(const char* method) const; virtual Bool_tAcceptModel(TObject*); virtual voidTGFrame::Activate(Bool_t); virtual voidActivateBaseClassEditors(TClass* cl); virtual voidAddExtraTab(TGedFrame::TGedSubFrame* sf); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual TGVerticalFrame*CreateEditorTabSubFrame(const char* name); virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()SIGNAL ; virtual voidTGWindow::DestroySubwindows(); virtual voidTGWindow::DestroyWindow(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGedFrame.html:1546,Clear,Clear,1546,root/html532/TGedFrame.html,https://root.cern,https://root.cern/root/html532/TGedFrame.html,4,['Clear'],['Clear']
Usability,"dTObject::MakeZombie(). private:. doubleCalculateEstimatedError(double target, bool lower = true, double xmin = 1, double xmax = 0); intFindClosestPointIndex(double target, int mode = 0, double xtarget = 0); doubleGetExpectedLimit(double nsig, bool lower, const char* opt = """") const; doubleGetGraphX(const TGraph& g, double y0, bool lowSearch = true) const; doubleGetGraphX(const TGraph& g, double y0, bool lowSearch, double& xmin, double& xmax) const; RooStats::SamplingDistribution*GetLimitDistribution(bool lower) const. Data Members; public:. enum InterpolOption_t { kLinear; kSpline; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. Double_tRooStats::SimpleInterval::fConfidenceLevelconfidence level; Double_tRooStats::SimpleInterval::fLowerLimitlower interval limit; RooArgSetRooStats::SimpleInterval::fParametersset containing the parameter of interest; Double_tRooStats::SimpleInterval::fUpperLimitupper interval limit. protected:. doublefCLsCleanupThreshold; TListfExpPValueslist of expected sampling distribution for each point; boolfFittedLowerLimit; boolfFittedUpperLimit; RooStats::HypoTestInverterResult::InterpolOption_tfInterpolOptioninterpolatation option (linear or spline); boolfInterpolateLowerLimit; boolfInterpolateUpperLimit; boolfIsTwoSidedtwo sided scan (look for lower/upper limit) ; doublefLowerLimitError; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; doublefUpperLimitError; boolfUseCLs; vector<double>fXValues; TListfYObjectslist of HypoTestResult for each point; static doublefgAsymptoticMaxSigmamax sigma value used to scan asymptotic expected p values . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; HypoTestInverterResult(const char* name = 0); default constructor. HypoTestI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HypoTestInverterResult.html:9023,Simpl,SimpleInterval,9023,root/html534/RooStats__HypoTestInverterResult.html,https://root.cern,https://root.cern/root/html534/RooStats__HypoTestInverterResult.html,4,['Simpl'],['SimpleInterval']
Usability,"d_t id, TClass* cl); voidAddImplFile(const char* filename, int line); voidAddInstance(Bool_t heap = kFALSE); static Bool_tAddRule(const char* rule); voidAdoptMemberStreamer(const char* name, TMemberStreamer* strm); voidAdoptReferenceProxy(TVirtualRefProxy* proxy); voidAdoptSchemaRules(ROOT::TSchemaRuleSet* rules); voidAdoptStreamer(TClassStreamer* strm); virtual voidTObject::AppendPad(Option_t* option = """"); static Int_tAutoBrowse(TObject* obj, TBrowser* browser); virtual voidBrowse(TBrowser* b); Int_tBrowse(void* obj, TBrowser* b) const; voidBuildEmulatedRealData(const char* name, Long_t offset, TClass* cl); voidBuildRealData(void* pointer = 0, Bool_t isTransient = kFALSE); voidCalculateStreamerOffset() const; Bool_tCallShowMembers(const void* obj, TMemberInspector& insp, Bool_t isTransient = kFALSE) const; Bool_tCanIgnoreTObjectStreamer(); Bool_tCanSplit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; Long_tClassProperty() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; voidCopyCollectionProxy(const TVirtualCollectionProxy&); voidTDictionary::CreateAttributeMap(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteArray(void* ary, Bool_t dtorOnly = kFALSE); voidDestructor(void* obj, Bool_t dtorOnly = kFALSE); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDump() const; voidDump(const void* obj, Bool_t noAddr = kFALSE) const; void*DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); const void*DynamicCast(const TClass* base, const void* obj, Bool_t up = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; char*EscapeChars(const char* t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:1973,Clear,Clear,1973,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,2,['Clear'],['Clear']
Usability,"data members; class charts. ROOT; » HIST; » HIST; » THnT<float>. class THnT<float>: public THn. Helper struct to hold one dimension's bin range for THnBinIter. Function Members (Methods); public:. virtual~THnT<float>(); voidTObject::AbstractMethod(const char* method) const; voidTHnBase::Add(const THnBase* h, Double_t c = 1.); voidTHnBase::Add(const TH1* hist, Double_t c = 1.); voidTHn::AddBinContent(const Int_t* idx, Double_t v = 1.); virtual voidTHn::AddBinContent(Long64_t bin, Double_t v = 1.); virtual voidTHn::AddBinError2(Long64_t bin, Double_t e2); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTHnBase::Browse(TBrowser* b); voidTHnBase::CalculateErrors(Bool_t calc = kTRUE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THn*THn::CreateHn(const char* name, const char* title, const TH1* h1); static THn*THn::CreateHn(const char* name, const char* title, const THnBase* hn); virtual ROOT::THnBaseBinIter*THn::CreateIter(Bool_t respectAxisRange) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THnT_float_.html:992,Clear,Clear,992,root/html602/THnT_float_.html,https://root.cern,https://root.cern/root/html602/THnT_float_.html,2,['Clear'],['Clear']
Usability,"data members; class charts. ROOT; » HIST; » HIST; » THnT<short>. class THnT<short>: public THn. Helper struct to hold one dimension's bin range for THnBinIter. Function Members (Methods); public:. virtual~THnT<short>(); voidTObject::AbstractMethod(const char* method) const; voidTHnBase::Add(const THnBase* h, Double_t c = 1.); voidTHnBase::Add(const TH1* hist, Double_t c = 1.); voidTHn::AddBinContent(const Int_t* idx, Double_t v = 1.); virtual voidTHn::AddBinContent(Long64_t bin, Double_t v = 1.); virtual voidTHn::AddBinError2(Long64_t bin, Double_t e2); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTHnBase::Browse(TBrowser* b); voidTHnBase::CalculateErrors(Bool_t calc = kTRUE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THn*THn::CreateHn(const char* name, const char* title, const TH1* h1); static THn*THn::CreateHn(const char* name, const char* title, const THnBase* hn); virtual ROOT::THnBaseBinIter*THn::CreateIter(Bool_t respectAxisRange) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THnT_short_.html:992,Clear,Clear,992,root/html602/THnT_short_.html,https://root.cern,https://root.cern/root/html602/THnT_short_.html,2,['Clear'],['Clear']
Usability,"dataloader, TString options);  ;  ~CrossValidation ();  ; void Evaluate ();  Does training, test set evaluation and performance evaluation of using cross-evalution. ;  ; Factory & GetFactory ();  ; UInt_t GetNumFolds ();  ; const std::vector< CrossValidationResult > & GetResults () const;  ; TString GetSplitExpr ();  ; void InitOptions ();  ; virtual TClass * IsA () const;  ; void ParseOptions ();  Method to parse the internal option string. ;  ; void SetNumFolds (UInt_t i);  ; void SetSplitExpr (TString splitExpr);  ; virtual void Streamer (TBuffer &);  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TMVA::Envelope;  ~Envelope ();  Default destructor. ;  ; virtual void BookMethod (TString methodname, TString methodtitle, TString options="""");  Method to book the machine learning method to perform the algorithm. ;  ; virtual void BookMethod (Types::EMVA method, TString methodtitle, TString options="""");  Method to book the machine learning method to perform the algorithm. ;  ; DataLoader * GetDataLoader ();  Method to get the pointer to TMVA::DataLoader object. ;  ; TFile * GetFile ();  Method to get the pointer to TFile object. ;  ; std::vector< OptionMap > & GetMethods ();  Method get the Booked methods in a option map object. ;  ; Bool_t HasMethod (TString methodname, TString methodtitle);  function to check methods booked ;  ; Bool_t IsModelPersistence ();  Method to see if the algorithm model is saved in xml or serialized files. ;  ; Bool_t IsSilentFile ();  Method to see if a file is available to save results. ;  ; Bool_t IsVerbose ();  Method to see if the algorithm should print extra information. ;  ; void SetDataLoader (DataLoader *dalaloader);  Method to set the pointer to TMVA::DataLoader object. ;  ; void SetFile (TFile *file);  Method to set the pointer to TFile object, with a writable file. ;  ; void SetModelPersistence (Bool_t status=kTRUE);  Method enable m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1CrossValidation.html:2361,learn,learning,2361,doc/master/classTMVA_1_1CrossValidation.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1CrossValidation.html,1,['learn'],['learning']
Usability,"ddBinContent(Int_t bin); virtual voidAddBinContent(Int_t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDirectoryStatus(); voidTArrayD::Adopt(Int_t n, Double_t* array); virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Option_t* option = """") const; virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Double_t& advalue) const; virtual voidTObject::AppendPad(Option_t* option = """"); Double_tTArrayD::At(Int_t i) const; virtual voidTH1::Browse(TBrowser* b); virtual Int_tTH1::BufferEmpty(Int_t action = 0); virtual Bool_tTH1::CanExtendAllAxes() const; virtual Double_tTH1::Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTH1::ClearUnderflowAndOverflow(); virtual TObject*TH1::Clone(const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(Bool_t onlyPositive = false); virtual voidCopy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTH1::Divide(const TH1* h1); virtual Bool_tTH1::Divide(TF1* f1, Double_t c1 = 1); virtual Bool_tTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*TH1::DrawCopy(Option_t* option = """", const char*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH1D.html:1755,Clear,Clear,1755,root/html602/TH1D.html,https://root.cern,https://root.cern/root/html602/TH1D.html,2,['Clear'],['Clear']
Usability,"ddBinContent(Int_t bin); virtual voidAddBinContent(Int_t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDirectoryStatus(); voidTArrayD::Adopt(Int_t n, Double_t* array); virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Option_t* option = """") const; virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Double_t& advalue) const; virtual voidTObject::AppendPad(Option_t* option = """"); Double_tTArrayD::At(Int_t i) const; virtual voidTH1::Browse(TBrowser* b); virtual Int_tTH2::BufferEmpty(Int_t action = 0); virtual Bool_tTH1::CanExtendAllAxes() const; virtual Double_tTH1::Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTH1::ClearUnderflowAndOverflow(); virtual TObject*TH1::Clone(const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(Bool_t onlyPositive = false); virtual voidCopy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTH1::Divide(const TH1* h1); virtual Bool_tTH1::Divide(TF1* f1, Double_t c1 = 1); virtual Bool_tTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*TH1::DrawCopy(Option_t* option = """", const char*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH2D.html:1736,Clear,Clear,1736,root/html602/TH2D.html,https://root.cern,https://root.cern/root/html602/TH2D.html,2,['Clear'],['Clear']
Usability,"ddBinContent(Int_t bin); virtual voidAddBinContent(Int_t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDirectoryStatus(); voidTArrayD::Adopt(Int_t n, Double_t* array); virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Option_t* option = """") const; virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Double_t& advalue) const; virtual voidTObject::AppendPad(Option_t* option = """"); Double_tTArrayD::At(Int_t i) const; virtual voidTH1::Browse(TBrowser* b); virtual Int_tTH3::BufferEmpty(Int_t action = 0); virtual Bool_tTH1::CanExtendAllAxes() const; virtual Double_tTH1::Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTH1::ClearUnderflowAndOverflow(); virtual TObject*TH1::Clone(const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(Bool_t onlyPositive = false); virtual voidCopy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTH1::Divide(const TH1* h1); virtual Bool_tTH1::Divide(TF1* f1, Double_t c1 = 1); virtual Bool_tTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*TH1::DrawCopy(Option_t* option = """", const char*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH3D.html:1736,Clear,Clear,1736,root/html602/TH3D.html,https://root.cern,https://root.cern/root/html602/TH3D.html,2,['Clear'],['Clear']
Usability,"ddBinContent(Int_t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDirectoryStatus(); virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Option_t* option = """") const; virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Double_t& advalue) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTH1::Browse(TBrowser* b); virtual Int_tTH2::BufferEmpty(Int_t action = 0); virtual Bool_tTH1::CanExtendAllAxes() const; voidChangePartition(Int_t n, Int_t m); virtual Double_tTH1::Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidClearBinContents(); virtual voidTH1::ClearUnderflowAndOverflow(); virtual TObject*Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(Bool_t onlyPositive = false); virtual voidTH2::Copy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTH1::Divide(const TH1* h1); virtual Bool_tTH1::Divide(TF1* f1, Double_t c1 = 1); virtual Bool_tTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*TH1::DrawCopy(Option_t* option = """", const char* name_postfix = ""_copy"") const; virtual TH1*TH1::DrawNor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH2Poly.html:6729,Clear,ClearUnderflowAndOverflow,6729,root/html602/TH2Poly.html,https://root.cern,https://root.cern/root/html602/TH2Poly.html,2,['Clear'],['ClearUnderflowAndOverflow']
Usability,"ddFolder. void ls(Option_t* option = """") const; List folder contents; If option contains ""dump"", the Dump function of contained objects is called.; If option contains ""print"", the Print function of contained objects is called.; By default the ls function of contained objects is called.; Indentation is used to identify the folder tree. The if option contains a <regexp> it be used to match the name of the objects. Int_t Occurence(const TObject* obj) const; Return occurence number of object in the list of objects of this folder.; The function returns the number of objects with the same name as object; found in the list of objects in this folder before object itself.; If only one object is found, return 0. void RecursiveRemove(TObject* obj); Recursively remove object from a folder. void Remove(TObject* obj); Remove object from this folder. obj must be a TObject or a TFolder. void SaveAs(const char* filename = """", Option_t* option = """") const; Save all objects in this folder in filename.; Each object in this folder will have a key in the file where the name of; the key will be the name of the object. void SetOwner(Bool_t owner = kTRUE); Set ownership.; If the folder is declared owner, when the folder is deleted, all; the objects added via TFolder::Add are deleted via TObject::Delete,; otherwise TObject::Clear is called. NOTE that folder ownership can be set:; - via TFolder::SetOwner; - or via TCollection::SetOwner on the collection specified to TFolder::AddFolder. void operator=(const TFolder& ). void Copy(TObject& ) const; { MayNotUse(""Copy(TObject &)""); }. TCollection * GetListOfFolders() const; { return fFolders; }. Bool_t IsFolder() const; { return kTRUE; }. » Author: Rene Brun 02/09/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-13 19:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFolder.html:12789,Clear,Clear,12789,root/html534/TFolder.html,https://root.cern,https://root.cern/root/html534/TFolder.html,1,['Clear'],['Clear']
Usability,"ddFolder. void ls(Option_t* option = """") const; List folder contents; If option contains ""dump"", the Dump function of contained objects is called.; If option contains ""print"", the Print function of contained objects is called.; By default the ls function of contained objects is called.; Indentation is used to identify the folder tree. The if option contains a <regexp> it be used to match the name of the objects. Int_t Occurence(const TObject* obj) const; Return occurence number of object in the list of objects of this folder.; The function returns the number of objects with the same name as object; found in the list of objects in this folder before object itself.; If only one object is found, return 0. void RecursiveRemove(TObject* obj); Recursively remove object from a folder. void Remove(TObject* obj); Remove object from this folder. obj must be a TObject or a TFolder. void SaveAs(const char* filename = """", Option_t* option = """") const; Save all objects in this folder in filename.; Each object in this folder will have a key in the file where the name of; the key will be the name of the object. void SetOwner(Bool_t owner = kTRUE); Set ownership.; If the folder is declared owner, when the folder is deleted, all; the objects added via TFolder::Add are deleted via TObject::Delete,; otherwise TObject::Clear is called. NOTE that folder ownership can be set:; - via TFolder::SetOwner; - or via TCollection::SetOwner on the collection specified to TFolder::AddFolder. void operator=(const TFolder& ). void Copy(TObject& ) const; { MayNotUse(""Copy(TObject &)""); }. TCollection * GetListOfFolders() const; { return fFolders; }. Bool_t IsFolder() const; { return kTRUE; }. » Author: Rene Brun 02/09/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 15:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TFolder.html:13250,Clear,Clear,13250,root/html604/TFolder.html,https://root.cern,https://root.cern/root/html604/TFolder.html,1,['Clear'],['Clear']
Usability,"ddFolder. void ls(Option_t* option = """") const; List folder contents; If option contains ""dump"", the Dump function of contained objects is called.; If option contains ""print"", the Print function of contained objects is called.; By default the ls function of contained objects is called.; Indentation is used to identify the folder tree. The if option contains a <regexp> it be used to match the name of the objects. Int_t Occurence(const TObject* obj) const; Return occurence number of object in the list of objects of this folder.; The function returns the number of objects with the same name as object; found in the list of objects in this folder before object itself.; If only one object is found, return 0. void RecursiveRemove(TObject* obj); Recursively remove object from a folder. void Remove(TObject* obj); Remove object from this folder. obj must be a TObject or a TFolder. void SaveAs(const char* filename = """", Option_t* option = """") const; Save all objects in this folder in filename.; Each object in this folder will have a key in the file where the name of; the key will be the name of the object. void SetOwner(Bool_t owner = kTRUE); Set ownership.; If the folder is declared owner, when the folder is deleted, all; the objects added via TFolder::Add are deleted via TObject::Delete,; otherwise TObject::Clear is called. NOTE that folder ownership can be set:; - via TFolder::SetOwner; - or via TCollection::SetOwner on the collection specified to TFolder::AddFolder. void operator=(const TFolder& ). void Copy(TObject& ) const; { MayNotUse(""Copy(TObject &)""); }. TCollection * GetListOfFolders() const; { return fFolders; }. Bool_t IsFolder() const; { return kTRUE; }. » Author: Rene Brun 02/09/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-30 14:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFolder.html:13250,Clear,Clear,13250,root/html602/TFolder.html,https://root.cern,https://root.cern/root/html602/TFolder.html,1,['Clear'],['Clear']
Usability,"ddingacolumnofstl); 51- [Add a column holding an object](\ref addingacolumnofobjs); 52- [Add a column holding a TObjectArray](\ref addingacolumnofobjs); 53- [Fill the tree](\ref fillthetree); 54- [Add a column to an already existing Tree](\ref addcoltoexistingtree); 55- [An Example](\ref fullexample); 56 ; 57\anchor creatingattree; 58## Construct a TTree; 59 ; 60~~~ {.cpp}; 61 TTree tree(name, title); 62~~~; 63Creates a Tree with name and title.; 64 ; 65Various kinds of branches can be added to a tree:; 66- Variables representing fundamental types, simple classes/structures or list of variables: for example for C or Fortran; 67structures.; 68- Any C++ object or collection, provided by the STL or ROOT.; 69 ; 70In the following, the details about the creation of different types of branches are given.; 71 ; 72\anchor addcolumnoffundamentaltypes; 73## Add a column (""branch"") holding fundamental types and arrays thereof; 74This strategy works also for lists of variables, e.g. to describe simple structures.; 75It is strongly recommended to persistify those as objects rather than lists of leaves.; 76 ; 77~~~ {.cpp}; 78 auto branch = tree.Branch(branchname, address, leaflist, bufsize); 79~~~; 80- address is the address of the first item of a structure; 81- leaflist is the concatenation of all the variable names and types; 82 separated by a colon character :; 83 The variable name and the variable type are separated by a; 84 slash (/). The variable type must be 1 character. (Characters; 85 after the first are legal and will be appended to the visible; 86 name of the leaf, but have no effect.) If no type is given, the; 87 type of the variable is assumed to be the same as the previous; 88 variable. If the first variable does not have a type, it is; 89 assumed of type F by default. The list of currently supported; 90 types is given below:; 91 - `C` : a character string terminated by the 0 character; 92 - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:3761,simpl,simple,3761,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['simpl'],['simple']
Usability,"ddobj, Int_t bufsize = 32000, Int_t splitlevel = 99); TBranch*TTree::Branch<const char>(const char* name, const char* classname, const char* obj, Int_t bufsize = 32000, Int_t splitlevel = 99); TBranch*TTree::Branch<void>(const char* name, void* obj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual TBranch*TTree::BranchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); virtual TBranch*TTree::BranchRef(); virtual TBranch*TTree::Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual voidBrowse(TBrowser*); virtual Int_tTTree::BuildIndex(const char* majorname, const char* minorname = ""0""); TStreamerInfo*TTree::BuildStreamerInfo(TClass* cl, void* pointer = 0, Bool_t canOptimize = kTRUE); virtual voidCanDeleteRefs(Bool_t flag = kTRUE); virtual TFile*TTree::ChangeFile(TFile* file); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TTree*TTree::CloneTree(Long64_t nentries = -1, Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTTree::CopyAddresses(TTree*, Bool_t undo = kFALSE); virtual Long64_tTTree::CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); virtual TTree*TTree::CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual TBasket*TTree::CreateBasket(TBranch*); virtual voidCreatePackets(); Int_tTTree::Debug() const; virtual voidTTree::Delete(Option_t* option = """")MENU ; virtual voidDirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual Long64_tDraw(const ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TChain.html:3471,Clear,Clear,3471,root/html602/TChain.html,https://root.cern,https://root.cern/root/html602/TChain.html,2,['Clear'],['Clear']
Usability,"de ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Private Member Functions |; Private Attributes |; Friends |; List of all members ; TMVA::Rule Class ReferenceTMVA. ; Implementation of a rule. ; A rule is simply a branch or a part of a branch in a tree. It fulfills the following:. First node is the root node of the originating tree; Consists of a minimum of 2 nodes; A rule returns for a given event:; 0 : if the event fails at any node; 1 : otherwise. If the rule contains <2 nodes, it returns 0 SHOULD NOT HAPPEN!. The coefficient is found by either brute force or some sort of intelligent fitting. See the RuleEnsemble class for more info. ; Definition at line 50 of file Rule.h. Public Member Functions;  Rule ();  the simple constructor ;  ;  Rule (const Rule &other);  ;  Rule (RuleEnsemble *re);  the simple constructor ;  ;  Rule (RuleEnsemble *re, const std::vector< const TMVA::Node * > &nodes);  the main constructor for a Rule ;  ; virtual ~Rule ();  destructor ;  ; void * AddXMLTo (void *parent) const;  ; void CalcImportance ();  ; Bool_t ContainsVariable (UInt_t iv) const;  check if variable in node ;  ; Bool_t Equal (const Rule &other, Bool_t useCutValue, Double_t maxdist) const;  Compare two rules. ;  ; Bool_t EvalEvent (const Event &e) const;  ; Double_t GetCoefficient () const;  ; Double_t GetImportance () const;  ; Double_t GetImportanceRef () const;  ; UInt_t GetNcuts () const;  ; Double_t GetNorm () const;  ; UInt_t GetNumVarsUsed () const;  ; Double_t GetRelImportance () const;  ; const RuleCut * GetRuleCut () const;  ; const RuleEnsemble * GetRuleEnsemble () const;  ; Double_t GetSigma () const;  ; Double_t GetSSB () const;  ; Double_t GetSSBNeve () const;  ; Double_t GetSupport () const;  ; Bool_t IsSignalRule () const;  ; Bool_t operator< (const Rule &other) const;  comparison operator < ;  ; void operator= (const Rule &other);  ; Bool_t operator== (const Rule &other) const;  comparison operator == ;  ; voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Rule.html:842,simpl,simple,842,doc/master/classTMVA_1_1Rule.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Rule.html,2,['simpl'],['simple']
Usability,"de a dataset and its counterpart on the outside will both see a modification of the range. ; Definition at line 372 of file RooCategory.cxx. ◆ addToRange() [2/2]. void RooCategory::addToRange ; (; const char * ; name, . RooAbsCategory::value_type ; stateIndex . ). Add the given state to the given range. ; NoteThis creates or accesses a shared map with allowed ranges. All copies of this category will share this range such that a category inside a dataset and its counterpart on the outside will both see a modification of the range. ; Definition at line 348 of file RooCategory.cxx. ◆ Class(). static TClass * RooCategory::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooCategory::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooCategory::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 141 of file RooCategory.h. ◆ clear(). void RooCategory::clear ; (; ). inline . Clear all defined category states. ; Definition at line 69 of file RooCategory.h. ◆ clearRange(). void RooCategory::clearRange ; (; const char * ; name, . bool ; silent . ). Clear the named range. ; NoteThis affects all copies of this category, because they are sharing range definitions. This ensures that categories inside a dataset and their counterparts on the outside will both see a modification of the range. ; Definition at line 321 of file RooCategory.cxx. ◆ clone(). TObject * RooCategory::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 37 of file RooCategory.h. ◆ DeclFileName(). static const char * RooCategory::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 141 of file RooCategory.h. ◆ defineType() [1/2]. bool RooCategory::defineType ; (; const std::string & ; label). Define a state with given name. ; The lowest available positi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCategory.html:55052,clear,clear,55052,doc/master/classRooCategory.html,https://root.cern,https://root.cern/doc/master/classRooCategory.html,1,['clear'],['clear']
Usability,"de this function. void SetArgs(Int_t narg, ...); Set do/redo and undo parameters. The format is; SetArgs(number_of_params, redo_params, undo_params). Example:; move_command->SetArgs(2, 100, 100, 200, 200);; 2 params, (100,100) - do/redo position, (200,200) - undo position. void SetRedoArgs(Int_t narg, ...); Set redo parameters. The format is; SetRedoArgs(number_of_params, params). Example:; move_command->SetRedoArgs(2, 100, 100);. void SetUndoArgs(Int_t narg, ...); Set undo parameters. The format is; SetUndoArgs(number_of_params, params). Example:; move_command->SetUndoArgs(2, 200, 200);. Bool_t CanRedo() const; Returns kTRUE if Redo action is possible, kFALSE if it's not.; By default, only single sequential redo action is possible. Bool_t CanUndo() const; Returns kTRUE if Undo action is possible, kFALSE if it's not.; By default, only single tial undo action is possible. void Redo(Option_t* option = """"); Execute command and then smerged commands. void Undo(Option_t* option = """"); Unexecute all merged commands and the command.; Merged commands are executed in reverse order. const char * GetName() const; Returns the command name. Default name is ""ClassName::RedoName(args)""; If list of merged commands is not empty the name is; ""ClassName::RedoName(args):cname1:cname2 ..."". const char * GetTitle() const; Returns command description.; By default, ""ClassName::RedoName(args)_ClassName::UndoName(args)"". const char * GetRedoName() const; Returns the name of redo command. const char * GetUndoName() const; Returns the name of undo command. Long_t * GetRedoArgs() const; Returns a pointer to array of redo arguments. Long_t * GetUndoArgs() const; Returns a pointer to array of undo arguments. Int_t GetNRargs() const; Returns a number of redo arguments. Int_t GetNUargs() const; Returns a number of undo arguments. void * GetObject() const; Returns an object for which undo redo acions are applied. Int_t GetStatus() const; Returns a number of sequential undo or redo operations. Bool_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TQCommand.html:22940,Undo,Undo,22940,root/html532/TQCommand.html,https://root.cern,https://root.cern/root/html532/TQCommand.html,4,['Undo'],['Undo']
Usability,"de, in contrast to e.g. STL. This class is also known as (typedefs to this class)THnSparseC. Function Members (Methods); public:. THnSparseT<TArrayC>(); THnSparseT<TArrayC>(const char* name, const char* title, Int_t dim, const Int_t* nbins, const Double_t* xmin = 0, const Double_t* xmax = 0, Int_t chunksize = 1024*16); ~THnSparseT<TArrayC>(); voidTObject::AbstractMethod(const char* method) const; voidTHnSparse::Add(const THnSparse* h, Double_t c = 1.); voidTHnSparse::AddBinContent(const Int_t* x, Double_t v = 1.); voidTHnSparse::AddBinContent(Long64_t bin, Double_t v = 1.); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTHnSparse::Browse(TBrowser* b); voidTHnSparse::CalculateErrors(Bool_t calc = kTRUE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnSparse::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THnSparse*THnSparse::CreateSparse(const char* name, const char* title, const TH1* h1, Int_t ChunkSize = 1024*16); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnSparse::Divide(const THnSparse* h); voidTHnSparse::Divide(const THnSparse* h1, const THnSparse* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/THnSparseT_TArrayC_.html:2364,Clear,Clear,2364,root/html532/THnSparseT_TArrayC_.html,https://root.cern,https://root.cern/root/html532/THnSparseT_TArrayC_.html,1,['Clear'],['Clear']
Usability,"de, in contrast to e.g. STL. This class is also known as (typedefs to this class)THnSparseD. Function Members (Methods); public:. THnSparseT<TArrayD>(); THnSparseT<TArrayD>(const char* name, const char* title, Int_t dim, const Int_t* nbins, const Double_t* xmin = 0, const Double_t* xmax = 0, Int_t chunksize = 1024*16); ~THnSparseT<TArrayD>(); voidTObject::AbstractMethod(const char* method) const; voidTHnSparse::Add(const THnSparse* h, Double_t c = 1.); voidTHnSparse::AddBinContent(const Int_t* x, Double_t v = 1.); voidTHnSparse::AddBinContent(Long64_t bin, Double_t v = 1.); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTHnSparse::Browse(TBrowser* b); voidTHnSparse::CalculateErrors(Bool_t calc = kTRUE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnSparse::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THnSparse*THnSparse::CreateSparse(const char* name, const char* title, const TH1* h1, Int_t ChunkSize = 1024*16); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnSparse::Divide(const THnSparse* h); voidTHnSparse::Divide(const THnSparse* h1, const THnSparse* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/THnSparseT_TArrayD_.html:2364,Clear,Clear,2364,root/html532/THnSparseT_TArrayD_.html,https://root.cern,https://root.cern/root/html532/THnSparseT_TArrayD_.html,1,['Clear'],['Clear']
Usability,"de, in contrast to e.g. STL. This class is also known as (typedefs to this class)THnSparseF. Function Members (Methods); public:. THnSparseT<TArrayF>(); THnSparseT<TArrayF>(const char* name, const char* title, Int_t dim, const Int_t* nbins, const Double_t* xmin = 0, const Double_t* xmax = 0, Int_t chunksize = 1024*16); ~THnSparseT<TArrayF>(); voidTObject::AbstractMethod(const char* method) const; voidTHnSparse::Add(const THnSparse* h, Double_t c = 1.); voidTHnSparse::AddBinContent(const Int_t* x, Double_t v = 1.); voidTHnSparse::AddBinContent(Long64_t bin, Double_t v = 1.); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTHnSparse::Browse(TBrowser* b); voidTHnSparse::CalculateErrors(Bool_t calc = kTRUE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnSparse::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THnSparse*THnSparse::CreateSparse(const char* name, const char* title, const TH1* h1, Int_t ChunkSize = 1024*16); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnSparse::Divide(const THnSparse* h); voidTHnSparse::Divide(const THnSparse* h1, const THnSparse* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/THnSparseT_TArrayF_.html:2364,Clear,Clear,2364,root/html532/THnSparseT_TArrayF_.html,https://root.cern,https://root.cern/root/html532/THnSparseT_TArrayF_.html,1,['Clear'],['Clear']
Usability,"de, in contrast to e.g. STL. This class is also known as (typedefs to this class)THnSparseI. Function Members (Methods); public:. THnSparseT<TArrayI>(); THnSparseT<TArrayI>(const char* name, const char* title, Int_t dim, const Int_t* nbins, const Double_t* xmin = 0, const Double_t* xmax = 0, Int_t chunksize = 1024*16); ~THnSparseT<TArrayI>(); voidTObject::AbstractMethod(const char* method) const; voidTHnSparse::Add(const THnSparse* h, Double_t c = 1.); voidTHnSparse::AddBinContent(const Int_t* x, Double_t v = 1.); voidTHnSparse::AddBinContent(Long64_t bin, Double_t v = 1.); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTHnSparse::Browse(TBrowser* b); voidTHnSparse::CalculateErrors(Bool_t calc = kTRUE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnSparse::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THnSparse*THnSparse::CreateSparse(const char* name, const char* title, const TH1* h1, Int_t ChunkSize = 1024*16); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnSparse::Divide(const THnSparse* h); voidTHnSparse::Divide(const THnSparse* h1, const THnSparse* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/THnSparseT_TArrayI_.html:2364,Clear,Clear,2364,root/html532/THnSparseT_TArrayI_.html,https://root.cern,https://root.cern/root/html532/THnSparseT_TArrayI_.html,1,['Clear'],['Clear']
Usability,"de, in contrast to e.g. STL. This class is also known as (typedefs to this class)THnSparseL. Function Members (Methods); public:. THnSparseT<TArrayL>(); THnSparseT<TArrayL>(const char* name, const char* title, Int_t dim, const Int_t* nbins, const Double_t* xmin = 0, const Double_t* xmax = 0, Int_t chunksize = 1024*16); ~THnSparseT<TArrayL>(); voidTObject::AbstractMethod(const char* method) const; voidTHnSparse::Add(const THnSparse* h, Double_t c = 1.); voidTHnSparse::AddBinContent(const Int_t* x, Double_t v = 1.); voidTHnSparse::AddBinContent(Long64_t bin, Double_t v = 1.); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTHnSparse::Browse(TBrowser* b); voidTHnSparse::CalculateErrors(Bool_t calc = kTRUE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnSparse::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THnSparse*THnSparse::CreateSparse(const char* name, const char* title, const TH1* h1, Int_t ChunkSize = 1024*16); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnSparse::Divide(const THnSparse* h); voidTHnSparse::Divide(const THnSparse* h1, const THnSparse* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/THnSparseT_TArrayL_.html:2364,Clear,Clear,2364,root/html532/THnSparseT_TArrayL_.html,https://root.cern,https://root.cern/root/html532/THnSparseT_TArrayL_.html,1,['Clear'],['Clear']
Usability,"de, in contrast to e.g. STL. This class is also known as (typedefs to this class)THnSparseS. Function Members (Methods); public:. THnSparseT<TArrayS>(); THnSparseT<TArrayS>(const char* name, const char* title, Int_t dim, const Int_t* nbins, const Double_t* xmin = 0, const Double_t* xmax = 0, Int_t chunksize = 1024*16); ~THnSparseT<TArrayS>(); voidTObject::AbstractMethod(const char* method) const; voidTHnSparse::Add(const THnSparse* h, Double_t c = 1.); voidTHnSparse::AddBinContent(const Int_t* x, Double_t v = 1.); voidTHnSparse::AddBinContent(Long64_t bin, Double_t v = 1.); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTHnSparse::Browse(TBrowser* b); voidTHnSparse::CalculateErrors(Bool_t calc = kTRUE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnSparse::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THnSparse*THnSparse::CreateSparse(const char* name, const char* title, const TH1* h1, Int_t ChunkSize = 1024*16); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnSparse::Divide(const THnSparse* h); voidTHnSparse::Divide(const THnSparse* h1, const THnSparse* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/THnSparseT_TArrayS_.html:2364,Clear,Clear,2364,root/html532/THnSparseT_TArrayS_.html,https://root.cern,https://root.cern/root/html532/THnSparseT_TArrayS_.html,1,['Clear'],['Clear']
Usability,"de, there is a single payload which is returned always. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooObjCacheManager(RooAbsArg* owner = 0, Int_t maxSize = 2, Bool_t clearCacheOnServerRedirect = kTRUE, Bool_t allowOptimize = kFALSE); Constructor of object cache manager for given owner. If clearCacheOnServerRedirect is true; all cache elements will be cleared when a server redirect is intercepted by the cache manager.; This is the default strategy and should only be overridden when you really understand; what you're doing as properly implementing server redirect in cache elements can get very; complicated, especially if there are (cyclical) reference back to the owning object. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); Copy constructor. ~RooObjCacheManager(); Destructor. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Intercept server redirect calls. If clearOnRedirect was set, sterilize; the cache (i.e. keep the structure but delete all contents). If not; forward serverRedirect to cache elements. void operModeHook(); Intercept changes to cache operation mode and forward to cache elements. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Intercept calls to perform automatic optimization of cache mode operation.; Forward calls to existing cache elements and save configuration of; cache mode optimization so that it can be applied on new cache elements; upon insertion. void sterilize(). void insertObjectHook(RooAbsCacheElement& ); Set owner link on all object inserted into cache.; Also if cache mode optimization was requested, apply; it now to cache element being inserted. void printCompactTreeHook(ostream& , const char* ); Add details on cache contents when printing in tree mode. void findConstantNodes(const RooArgSet& , RooArgSet& , RooLinkedList& ); If clearOnRedirect is false, forward constant term optimization calls to; cache eleme",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooObjCacheManager.html:4868,clear,clearOnRedirect,4868,root/html534/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html534/RooObjCacheManager.html,6,['clear'],['clearOnRedirect']
Usability,"de. rfio; ON; RFIO support, requires libshift from CASTOR >= 1.5.2. rpath; OFF; Set run-time library load path on executables and shared libraries (at installation area). runtime_cxxmodules; OFF; Enable runtime c++ modules. sapdb; ON; MaxDB/SapDB support, requires libsqlod and libsqlrte. shadowpw; ON; Shadow password support. shared; ON; Use shared 3rd party libraries if possible. soversion; OFF; Set version number in sonames (recommended). sqlite; ON; SQLite support, requires libsqlite3. srp; ON; SRP support, requires SRP source tree. ssl; ON; SSL encryption support, requires openssl. tbb; OFF; TBB multi-threading support, requires TBB. table; *; Build libTable contrib library. tcmalloc; OFF; Using the tcmalloc allocator. testing; OFF; Enable test suit of ROOT with CTest. thread; ON; Using thread library (cannot be disabled). tmva; ON; Build TMVA multi variate analysis library. unuran; *; UNURAN - package for generating non-uniform random numbers. vc; *; Vc adds a few new types for portable and intuitive SIMD programming. vdt; ON; VDT adds a set of fast and vectorisable mathematical functions. winrtdebug; OFF; Link against the Windows debug runtime library. xft; ON; Xft support (X11 antialiased fonts). xml; ON; XML parser interface. xrootd; ON; Build xrootd file server and its client (if supported). x11; *; X11 support. The default value for these options are platform dependent. CMake Generators; CMake can generate, in addition to standard makefiles, specific proejcts for various integrated development environments (IDEs) such as Xcode, Eclipse, Visual Studio, etc.. The available generators depend on the platform for which cmake have been build. To see the list of available generators do cmake --help .; Ninja; Generate a Ninja project with cmake -G Ninja /path/to/source/dir. Building ROOT with Ninja is faster.; Xcode; Generate the Xcode project with cmake -G Xcode /path/to/source/dir. Open the generated file with the Xcode application.; Visual Studio; Generate the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/building-root.html:12838,intuit,intuitive,12838,d/building-root.html,https://root.cern,https://root.cern/d/building-root.html,1,['intuit'],['intuitive']
Usability,"de; // spectrum display mode (points, grid, contours, bars, x_lines,; // y_lines, bars_x, bars_y, needles, surface, triangles); int z_scale; // z scale (linear, log, sqrt); int nodesx; // number of nodes in x dimension of grid; int nodesy; // number of nodes in y dimension of grid; int count_reg; // width between contours, applies only for contours display mode; int alfa; // angles of display,alfa+beta must be less or equal to 90, alpha- angle; // between base line of Canvas and left lower edge of picture picture; // base plane; int beta; // angle between base line of Canvas and right lower edge of picture base plane; int view_angle; // rotation angle of the view, it can be 0, 90, 180, 270 degrees; int levels; // # of color levels for rainbowed display modes, it does not apply for; // simple display modes algorithm group; float rainbow1_step; // determines the first component step for neighbouring color; // levels, applies only for rainbowed display modes, it does not apply; // for simple display modes algorithm group; float rainbow2_step; // determines the second component step for neighbouring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; float rainbow3_step; // determines the third component step for neighbouring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; int color_alg; // applies only for rainbowed display modes (rgb smooth algorithm,; // rgb modulo color component, cmy smooth algorithm, cmy modulo; // color component, cie smooth algorithm, cie modulo color component,; // yiq smooth algorithm, yiq modulo color component, hsv smooth; // algorithm, hsv modulo color component, it does not apply for simple; // display modes algorithm group [15]; float l_h_weight; // weight between shading according to fictive light source and; // according to channels counts, applies only for; // PICTURE2_MODE_GROUP_LIGHT_HEIGH",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/spectrum/Spectrum.html:72223,simpl,simple,72223,root/html534/guides/spectrum/Spectrum.html,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html,2,['simpl'],['simple']
Usability,"de;  WVE note: assumes nominal and alternates have identical structure, must add explicit check. ;  ; const RooArgList & lowList () const;  ; const RooAbsReal * nominalHist () const;  Return pointer to the nominal hist function. ;  ; const RooArgList & paramList () const;  ; std::list< double > * plotSamplingHint (RooAbsRealLValue &obs, double xlo, double xhi) const override;  Interface for returning an optional hint for initial sampling points when constructing a curve projected on observable obs. ;  ; bool positiveDefinite () const;  ; void printAllInterpCodes ();  ; void setAllInterpCodes (int code);  ; bool setBinIntegrator (RooArgSet &allVars);  ; void setInterpCode (RooAbsReal &param, int code, bool silent=false);  ; void setPositiveDefinite (bool flag=true);  ; void Streamer (TBuffer &) override;  Stream an object of class PiecewiseInterpolation. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void translate (RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ;  Public Member Functions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooAbsReal () override;  Destructor. ;  ; virtual double analyticalIntegral (Int_t code, const char *rangeName=nullptr) const;  Implements the actual analytical integral(s) advertised by getAnalyticalIntegral. ;  ; TF1 * asTF (const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) const;  Return a ROOT TF1,2,3 object bound to this RooAbsReal with give",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classPiecewiseInterpolation.html:3950,simpl,simple,3950,doc/master/classPiecewiseInterpolation.html,https://root.cern,https://root.cern/doc/master/classPiecewiseInterpolation.html,1,['simpl'],['simple']
Usability,"def std::vector<Bool_t, A> Cont_t;; 722 typedef typename Cont_t::iterator Iter_t;; 723 typedef typename Cont_t::value_type Value_t;; 724 typedef Environ<Iter_t> Env_t;; 725 typedef Env_t *PEnv_t;; 726 typedef Cont_t *PCont_t;; 727 typedef Value_t *PValue_t;; 728 ; 729 static void resize(void* obj,size_t n) {; 730 PCont_t c = PCont_t(obj);; 731 c->resize(n);; 732 }; 733 static void* feed(void* from, void *to, size_t size) {; 734 PCont_t c = PCont_t(to);; 735 PValue_t m = PValue_t(from);; 736 for (size_t i=0; i<size; ++i, ++m); 737 c->push_back(*m);; 738 return nullptr;; 739 }; 740 static int value_offset() {; 741 return 0;; 742 }; 743 };; 744 ; 745 // Need specialization for boolean references due to stupid STL std::vector<bool>; 746 template <class A> struct TCollectionProxyInfo::Address<std::vector<Bool_t, A>> {; 747 virtual ~Address() {}; 748 static void* address(typename std::vector<Bool_t, A>::const_reference) {; 749 R__ASSERT(false && ""Intentionally not implemented, should use VectorLooper or other functions specialized for ""; 750 ""vector<bool> instead"");; 751 return {};; 752 }; 753 };; 754 ; 755 template <typename Bitset_t> struct TCollectionProxyInfo::Type<Internal::TStdBitsetHelper<Bitset_t> > : public TCollectionProxyInfo::Address<const Bool_t &>; 756 {; 757 typedef Bitset_t Cont_t;; 758 typedef std::pair<size_t,Bool_t> Iter_t;; 759 typedef Bool_t Value_t;; 760 typedef Environ<Iter_t> Env_t;; 761 typedef Env_t *PEnv_t;; 762 typedef Cont_t *PCont_t;; 763 typedef Value_t *PValue_t;; 764 ; 765 virtual ~Type() {}; 766 ; 767 static inline PCont_t object(void* ptr) {; 768 return PCont_t(PEnv_t(ptr)->fObject);; 769 }; 770 static void* size(void* env) {; 771 PEnv_t e = PEnv_t(env);; 772 e->fSize = PCont_t(e->fObject)->size();; 773 return &e->fSize;; 774 }; 775 static void* clear(void* env) {; 776 object(env)->reset();; 777 return nullptr;; 778 }; 779 static void* first(void* env) {; 780 PEnv_t e = PEnv_t(env);; 781 PCont_t c = PCont_t(e->fObject);; 782 e->fIterator.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:26771,clear,clear,26771,doc/master/TCollectionProxyInfo_8h_source.html,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html,1,['clear'],['clear']
Usability,"defined states. Bool_t operator==(Int_t index); Equality operator with a integer (compares with state index number). Bool_t operator==(const char* label); Equality operator with a string (compares with state label string). Bool_t operator==(const RooAbsArg& other); Equality operator with another RooAbsArg. Only functional; is also a RooAbsCategory, will return true if index is the same. Bool_t isValidIndex(Int_t index) const; Check if state with given index is defined. Bool_t isValidLabel(const char* label) const; Check if state with given name is defined. const RooCatType* defineType(const char* label); Define a new state with given name. The lowest available; integer number is assigned as index value. const RooCatType* defineTypeUnchecked(const char* label, Int_t index); Internal version of defineType that does not check if type; already exists. const RooCatType* defineType(const char* label, Int_t index); Define new state with given name and index number. void clearTypes(); Delete all currently defined states. const RooCatType* lookupType(const RooCatType &other, Bool_t printError); Find our type that matches the specified type, or return 0 for no match. const RooCatType* lookupType(Int_t index, Bool_t printError); Find our type corresponding to the specified index, or return 0 for no match. const RooCatType* lookupType(const char* label, Bool_t printError); Find our type corresponding to the specified label, or return 0 for no match. Bool_t isValid() const; Check if current value is a valid state. Bool_t isValid(RooCatType value) const; Check if given state is defined for this object. Roo1DTable* createTable(const char* label) const; Create a table matching the shape of this category. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream (dummy for now). void writeToStream(ostream& os, Bool_t compact) const; Write object contents to ostream. void printValue(ostream& os) const; Print value (label name). void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCategory.html:21542,clear,clearTypes,21542,root/html526/RooAbsCategory.html,https://root.cern,https://root.cern/root/html526/RooAbsCategory.html,1,['clear'],['clearTypes']
Usability,"del encapulates the schema of an ntuple.Definition RNTupleModel.hxx:136; ROOT::Experimental::RNTupleModel::Createstatic std::unique_ptr< RNTupleModel > Create()Definition RNTupleModel.cxx:249; ROOT::Experimental::RNTupleWriterAn RNTuple that gets filled with entries (data) and writes them to storage.Definition RNTupleWriter.hxx:60; ROOT::Experimental::RNTupleWriter::Recreatestatic std::unique_ptr< RNTupleWriter > Recreate(std::unique_ptr< RNTupleModel > model, std::string_view ntupleName, std::string_view storage, const RNTupleWriteOptions &options=RNTupleWriteOptions())Throws an exception if the model is null.Definition RNTupleWriter.cxx:71; writerDefinition writer.py:1. Definition at line 161 of file RNTupleWriter.hxx. ◆ EnableMetrics(). void ROOT::Experimental::RNTupleWriter::EnableMetrics ; (; ). inline . Definition at line 137 of file RNTupleWriter.hxx. ◆ Fill() [1/2]. std::size_t ROOT::Experimental::RNTupleWriter::Fill ; (; ). inline . The simplest user interface if the default entry that comes with the ntuple model is used. ; ReturnsThe number of uncompressed bytes written. ; Definition at line 105 of file RNTupleWriter.hxx. ◆ Fill() [2/2]. std::size_t ROOT::Experimental::RNTupleWriter::Fill ; (; REntry & ; entry). inline . Multiple entries can have been instantiated from the ntuple model. ; This method will perform a light check whether the entry comes from the ntuple's own model. ReturnsThe number of uncompressed bytes written. ; Definition at line 109 of file RNTupleWriter.hxx. ◆ FillNoFlush(). void ROOT::Experimental::RNTupleWriter::FillNoFlush ; (; REntry & ; entry, . RNTupleFillStatus & ; status . ). inline . Fill an entry into this ntuple, but don't commit the cluster. ; The calling code must pass an RNTupleFillStatus and check RNTupleFillStatus::ShouldFlushCluster. ; Definition at line 112 of file RNTupleWriter.hxx. ◆ FlushCluster(). void ROOT::Experimental::RNTupleWriter::FlushCluster ; (; ). inline . Flush so far filled entries to storage. ; Definiti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleWriter.html:8157,simpl,simplest,8157,doc/master/classROOT_1_1Experimental_1_1RNTupleWriter.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleWriter.html,1,['simpl'],['simplest']
Usability,"del::basis() const; virtual Int_tbasisCode(const char* name) const; const RooRealVar&RooResolutionModel::basisConvVar() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual RooResolutionModel*RooResolutionModel::convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&RooResolutionModel::convVar() const; virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooGaussModel.html:3151,clear,clearEvalErrorLog,3151,root/html526/RooGaussModel.html,https://root.cern,https://root.cern/root/html526/RooGaussModel.html,3,['clear'],['clearEvalErrorLog']
Usability,"depSet=nullptr, bool force=false);  Interface function to force use of a given set of observables to interpret function value. ;  ; void setTreeBranchStatus (TTree &t, bool active) override;  (De)Activate associated tree branch ;  ; void syncCache (const RooArgSet *set=nullptr) override;  ; double traceEval (const RooArgSet *set) const;  Calculate current value of object, with error tracing wrapper. ;  ;  Protected Member Functions inherited from RooAbsArg; void attachToStore (RooAbsDataStore &store);  Attach this argument to the data store such that it reads data from there. ;  ; TString cleanBranchName () const;  Construct a mangled name from the actual name that is free of any math symbols that might be interpreted by TTree. ;  ; void clearShapeDirty () const;  ; void clearValueAndShapeDirty () const;  ; void clearValueDirty () const;  ; virtual void getObservablesHook (const RooArgSet *, RooArgSet *) const;  ; virtual void getParametersHook (const RooArgSet *, RooArgSet *, bool) const;  ; void graphVizAddConnections (std::set< std::pair< RooAbsArg *, RooAbsArg * > > &);  Utility function that inserts all point-to-point client-server connections between any two RooAbsArgs in the expression tree headed by this object in the linkSet argument. ;  ; bool inhibitDirty () const;  Delete watch flag. ;  ; virtual void ioStreamerPass2 ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ; virtual void operModeHook ();  ; virtual void optimizeDirtyHook (const RooArgSet *);  ; void printAttribList (std::ostream &os) const;  Transient boolean attributes (not copied in ctor) ;  ; void registerProxy (RooArgProxy &proxy);  Register an RooArgProxy in the proxy list. ;  ; void registerProxy (RooListProxy &proxy);  Register an RooListProxy in the proxy list. ;  ; void registerProxy (RooSetProxy &proxy);  Register an RooSetProxy in the proxy list. ;  ; void setProxyNormSet (const RooArgSet *nset);  Forw",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChebychev.html:67681,clear,clearShapeDirty,67681,doc/master/classRooChebychev.html,https://root.cern,https://root.cern/doc/master/classRooChebychev.html,6,['clear'],"['clearShapeDirty', 'clearValueAndShapeDirty', 'clearValueDirty']"
Usability,"der, ""muons.fPt"");; // Here, too we would need the definition of the Muon class.; TTreeReaderArray<Muon> raMuons(reader, ""muons"");. Accessing Data; The TTreeReader checks whether the type you specify is the type that's stored in the branch, i.e. whether it can actually access the data through the reader object. The TTreeReaderValue gets its values like so:; // Loop through all the TTree's entries; while (reader.Next()) {; // behaves like an iterator; float missingET = *rvMissingET;; ...; }. A TTreeReaderArray allows you to get the size and access the n-th element:; while (reader.Next()) {; for (int iMuon = 0, nMuons = raMuonPt.GetSize(); iMuon < nMuons; ++iMuon) {; hist->Fill(raMuonPt[iMuon]);; }; }. Of course in C++11 you could also just do; while (reader.Next()) {; for (float pT: raMuonPt) {; hist->Fill(pT);; }; }. We will try all of this out later; you are welcome to write a little script to test this on our TTree.; . ‹ 6. Multivariate Analysis; up; 8. Efficiency Calculation ›. Navigate through this book; 0. Setting up ROOT; 1. Extracting an object from a TFile; 2. Running code in ROOT; 4. Histogramming; 3. Examining a TTree's data; 5. Fitting; 6. Multivariate Analysis; 7. Using the TTreeReader; 8. Efficiency Calculation; 9. Fitting By Coding; 10. Go Parallel!; TutorialSelector.C; 11. Done!. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/7-using-ttreereader.html:4859,guid,guidelines,4859,d/7-using-ttreereader.html,https://root.cern,https://root.cern/d/7-using-ttreereader.html,1,['guid'],['guidelines']
Usability,"derTDataLoader ;  CTDataLoader< AData, TReference< AReal > >;  CTDeepNetGeneric Deep Neural Network class ;  CTDenseLayerGeneric layer class ;  CTDeviceTDevice ;  CTDLGradientDescent;  CTGradientDescent;  CTLayerGeneric layer class ;  CTNetGeneric neural network class ;  CTReferenceThe reference architecture class ;  CTReshapeLayer;  CTSharedLayerLayer class width shared weight and bias layers ;  CTTensorBatchTTensorBatch ;  CTTensorBatchIteratorTTensorBatchIterator ;  CTTensorDataLoaderTTensorDataLoader ;  CTTensorDataLoader< AData, TReference< AReal > >;  CVGeneralLayerGeneric General Layer class ;  ►NExperimental;  CClassification;  CClassificationResult;  ►NkNN;  CEvent;  CModulekNN;  CNodeThis file contains binary tree and global function template that searches tree for k-nearest neigbors ;  CAbsoluteDeviationLossFunctionAbsolute Deviation Loss Function ;  CAbsoluteDeviationLossFunctionBDTAbsolute Deviation BDT Loss Function ;  CAbsValue;  CBDTEventWrapper;  CBinarySearchTreeA simple Binary search tree including a volume search method ;  CBinarySearchTreeNodeNode for the BinarySearch or Decision Trees ;  CBinaryTreeBase class for BinarySearch and Decision Trees ;  CCCPrunerA helper class to prune a decision tree using the Cost Complexity method (see Classification and Regression Trees by Leo Breiman et al) ;  ►CCCTreeWrapper;  CCCTreeNode;  CClassificationClass to perform two class classification ;  CClassificationResultClass to save the results of the classifier ;  CClassifierFactoryThis is the MVA factory ;  CClassInfoClass that contains all the information of a class ;  Ccompose_binary_t;  Ccompose_unary_t;  ►CConfigSingleton class for global configuration settings used by TMVA ;  CIONames;  CVariablePlotting;  CConfigurable;  CConvergenceTestCheck for convergence ;  CCostComplexityPruneToolA class to prune a decision tree using the Cost Complexity method ;  CCrossEntropyImplementation of the CrossEntropy as separation criterion ;  CCrossValidationClass to pe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/annotated.html:79279,simpl,simple,79279,doc/v614/annotated.html,https://root.cern,https://root.cern/doc/v614/annotated.html,1,['simpl'],['simple']
Usability,"derived; 2877 if(!dynamic_cast<RooAbsRealLValue*>(var)) {; 2878 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: cannot plot variable \""""; 2879 << var->GetName() << ""\"" of type "" << var->ClassName() << std::endl;; 2880 return true;; 2881 }; 2882 ; 2883 // check if we actually depend on the plot variable; 2884 if(!this->dependsOn(*var)) {; 2885 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: WARNING: variable is not an explicit dependent: ""; 2886 << var->GetName() << std::endl;; 2887 }; 2888 ; 2889 return false ;; 2890}; 2891 ; 2892 ; 2893 ; 2894 ; 2895////////////////////////////////////////////////////////////////////////////////; 2896/// Utility function for plotOn() that constructs the set of; 2897/// observables to project when plotting ourselves as function of; 2898/// 'plotVar'. 'allVars' is the list of variables that must be; 2899/// projected, but may contain variables that we do not depend on. If; 2900/// 'silent' is cleared, warnings about inconsistent input parameters; 2901/// will be printed.; 2902 ; 2903void RooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars,; 2904 RooArgSet& projectedVars, bool silent) const; 2905{; 2906 cxcoutD(Plotting) << ""RooAbsReal::makeProjectionSet("" << GetName() << "") plotVar = "" << plotVar->GetName(); 2907 << "" allVars = "" << (allVars?(*allVars):RooArgSet()) << std::endl ;; 2908 ; 2909 projectedVars.removeAll() ;; 2910 if (!allVars) return ;; 2911 ; 2912 // Start out with suggested list of variables; 2913 projectedVars.add(*allVars) ;; 2914 ; 2915 // Take out plot variable; 2916 RooAbsArg *found= projectedVars.find(plotVar->GetName());; 2917 if(found) {; 2918 projectedVars.remove(*found);; 2919 ; 2920 // Take out eventual servers of plotVar; 2921 std::unique_ptr<RooArgSet> plotServers{plotVar->getObservables(&projectedVars)};; 2922 for(RooAbsArg * ps : *plotServers) {; 2923 RooAbsArg* tmp = projectedVars.find(ps->GetName()) ;; 2924 if (tmp) {; 2925 cxcoutD(Plotting",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:126362,clear,cleared,126362,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['clear'],['cleared']
Usability,"des in x dimension of grid; int nodesy; // number of nodes in y dimension of grid; int count_reg; // width between contours, applies only for contours display mode; int alfa; // angles of display,alfa+beta must be less or equal to 90, alpha- angle; // between base line of Canvas and left lower edge of picture picture; // base plane; int beta; // angle between base line of Canvas and right lower edge of picture base plane; int view_angle; // rotation angle of the view, it can be 0, 90, 180, 270 degrees; int levels; // # of color levels for rainbowed display modes, it does not apply for; // simple display modes algorithm group; float rainbow1_step; // determines the first component step for neighboring color; // levels, applies only for rainbowed display modes, it does not apply; // for simple display modes algorithm group; float rainbow2_step; // determines the second component step for neighboring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; float rainbow3_step; // determines the third component step for neighboring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; int color_alg; // applies only for rainbowed display modes (rgb smooth algorithm,; // rgb modulo color component, cmy smooth algorithm, cmy modulo; // color component, cie smooth algorithm, cie modulo color component,; // yiq smooth algorithm, yiq modulo color component, hsv smooth; // algorithm, hsv modulo color component, it does not apply for simple; // display modes algorithm group [15]; float l_h_weight; // weight between shading according to fictive light source and; // according to channels counts, applies only for; // PICTURE2_MODE_GROUP_LIGHT_HEIGHT modes group; int xlight; // x position of fictive light source, applies only for rainbowed display; // modes with shading according to light; int ylight; // y position of fictive light source, applies ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:73415,simpl,simple,73415,root/htmldoc/guides/spectrum/Spectrum.html,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html,2,['simpl'],['simple']
Usability,"des; Libraries. Function documentation; RooProfileLL(const char* name, const char* title, RooAbsReal& nll, const RooArgSet& observables); Constructor of profile likelihood given input likelihood nll w.r.t; the given set of variables. The input log likelihood is minimized w.r.t; to all other variables of the likelihood at each evaluation and the; value of the global log likelihood minimum is always subtracted. RooProfileLL(const RooProfileLL& other, const char* name = 0); Copy constructor. ~RooProfileLL(); Destructor. const RooArgSet& bestFitParams() const. const RooArgSet& bestFitObs() const. RooAbsReal* createProfile(const RooArgSet& paramsOfInterest); Optimized implementation of createProfile for profile likelihoods.; Return profile of original function in terms of stated parameters; of interest rather than profiling recursively. Double_t evaluate() const; Evaluate profile likelihood by minimizing likelihood w.r.t. all; parameters that are not considered observables of this profile; likelihood object. void validateAbsMin() const; Check that parameters and likelihood value for 'best fit' are still valid. If not,; because the best fit has never been calculated, or because constant parameters have; changed value or parameters have changed const/float status, the minimum is recalculated. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ). TObject* clone(const char* newname) const; { return new RooProfileLL(*this,newname); }. void setAlwaysStartFromMin(Bool_t flag); { _startFromMin = flag ; }. Bool_t alwaysStartFromMin() const; { return _startFromMin ; }. RooMinuit* minuit(); { return _minuit ; }. RooAbsReal& nll(); { return const_cast<RooAbsReal&>(_nll.arg()) ; }. void clearAbsMin(); { _absMinValid = kFALSE ; }. » Last changed: Tue Dec 8 17:03:18 2009 » Last generated: 2009-12-08 17:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooProfileLL.html:35198,clear,clearAbsMin,35198,root/html526/RooProfileLL.html,https://root.cern,https://root.cern/root/html526/RooProfileLL.html,1,['clear'],['clearAbsMin']
Usability,"devalue passed to exit() in interpreter; Int_tfGlobalsListSerialIndicator of the last time we refresh the ROOT list of globals.; TStringfIncludePathlist of CINT include paths; Bool_tfLockProcessLinetrue if ProcessLine should lock gCINTMutex; TEnv*fMapfilemap of classes and libraries; Int_tfMore1 if more input is required; charfPrompt[64]proposed prompt string; TObjArray*fRootmapFileslist of non-default rootmap files loaded; TStringfRootmapLoadPathdynamic load path used for loading rootmap files; TStringfSharedLibslist of shared libraries loaded by G__loadfile; Int_tfSharedLibsSerialIndicator of the last time we set fSharedLibs; static void*fgSetOfSpecialsset of TObject*s used in CINT variables. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCint(const char* name, const char* title); Initialize the CINT interpreter interface. ~TCint(); Destroy the CINT interpreter interface. void ClearFileBusy(); Reset CINT internal state in case a previous action was not correctly; terminated by G__init_cint() and G__dlmod(). void ClearStack(); Delete existing temporary values. Int_t InitializeDictionaries(); Initialize all registered dictionaries. Normally this is already done; by G__init_cint() and G__dlmod(). void EnableAutoLoading(); Enable the automatic loading of shared libraries when a class; is used that is stored in a not yet loaded library. Uses the; information stored in the class/library map (typically; $ROOTSYS/etc/system.rootmap). void EndOfLineAction(); It calls a ""fantom"" method to synchronize user keyboard input; and ROOT prompt line. Bool_t IsLoaded(const char* filename) const; Return true if the file has already been loaded by cint. Int_t Load(const char* filenam, Bool_t system = kFALSE); Load a library file in CINT's memory.; if 'system' is true, the library is never unloaded. void LoadMacro(const char* filename, TInterpreter::EErrorCode* error = 0); Load a macro file in CINT's memory. Long_t ProcessLine(const char* li",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TCint.html:19844,Clear,ClearFileBusy,19844,root/html532/TCint.html,https://root.cern,https://root.cern/root/html532/TCint.html,2,['Clear'],['ClearFileBusy']
Usability,"dex of the last filled point; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTPolyMarker3D::fNNumber of allocated points; TStringTPolyMarker3D::fNameName of polymarker; TStringTPolyMarker3D::fOptionOptions; Bool_tfOwnIdsFlag specifying id-objects are owned by the point-set; Float_t*TPolyMarker3D::fP[3*fN] Array of X,Y,Z coordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPointSet3D(const TPointSet3D& t); Copy constructor. ~TPointSet3D(); Destructor. void CopyIds(const TPointSet3D& t); Copy id objects from point-set 't'. TPointSet3D& operator=(const TPointSet3D& t); Assignement operator. void ComputeBBox(); Compute the bounding box of this points set. void SetPointId(TObject* id); Set id of last point.; Use this method if you also use TPolyMarker3D::SetNextPoint(). void SetPointId(Int_t n, TObject* id); Set id of point n. void ClearIds(); Clears the id-array. If ids are owned the TObjects are deleted. void PointSelected(Int_t n); This virtual method is called from TPointSet3DGL when a point is; selected.; At this point it just prints out n and id of the point (if it exists).; To make something useful out of this do:; a) subclass and re-implement this method;; b) extend this class to include TExec or some other kind of callback. void Streamer(TBuffer& ); Stream an object of class TPointSet3D. TPointSet3D(); { fName=""TPointSet3D""; }. TPointSet3D(Int_t n, Marker_t m = 1, Option_t* opt = """"); { fName=""TPointSet3D""; }. TPointSet3D(Int_t n, Float_t* p, Marker_t m = 1, Option_t* opt = """"); { fName=""TPointSet3D""; }. TPointSet3D(Int_t n, Double_t* p, Marker_t m = 1, Option_t* opt = """"); { fName=""TPointSet3D""; }. TObject* GetPointId(Int_t n) const; { return fIds.At(n); }. Bool_t GetOwnIds() const; { return fOwnIds; }. void SetOwnIds(Bool_t o); { fOwnIds = o; }. » Author: Matevz Tadel 7/4/2006 » Copyright (C) 1995-2006, Rene Brun a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPointSet3D.html:9662,Clear,ClearIds,9662,root/html534/TPointSet3D.html,https://root.cern,https://root.cern/root/html534/TPointSet3D.html,6,['Clear'],"['ClearIds', 'Clears']"
Usability,"df. ROOT::Math::VavilovAccurateQuantile. ROOT::Math::VavilovFast. ROOT::Math::VirtualIntegratorMultiDim←. ROOT::Math::AdaptiveIntegratorMultiDim. ROOT::Math::GSLMCIntegrator. ROOT::Math::VirtualIntegratorOneDim←. ROOT::Math::GSLIntegrator. ROOT::Math::GaussIntegrator; ←. ROOT::Math::GaussLegendreIntegrator. ROOT::Math::WrappedMultiTF1. ROOT::Math::WrappedTF1. ROOT::Minuit2::CombinedMinimizer. ROOT::Minuit2::FCNBase←. ROOT::Minuit2::FCNGradientBase. ROOT::Minuit2::FumiliFCNBase. ROOT::Minuit2::FCNGradientBase. ROOT::Minuit2::FumiliFCNBase. ROOT::Minuit2::FumiliMinimizer. ROOT::Minuit2::Minuit2Minimizer. ROOT::Minuit2::MnFumiliMinimize. ROOT::Minuit2::MnMigrad. ROOT::Minuit2::MnMinimize. ROOT::Minuit2::MnScan. ROOT::Minuit2::MnSimplex. ROOT::Minuit2::ModularFunctionMinimizer←. ROOT::Minuit2::CombinedMinimizer. ROOT::Minuit2::FumiliMinimizer. ROOT::Minuit2::ScanMinimizer. ROOT::Minuit2::SimplexMinimizer. ROOT::Minuit2::VariableMetricMinimizer. ROOT::Minuit2::ScanMinimizer. ROOT::Minuit2::SimplexMinimizer. ROOT::Minuit2::VariableMetricMinimizer. ROOT::TArrayProxy<ROOT::TArrayType<Long64_t,0> >. ROOT::TArrayProxy<ROOT::TArrayType<ULong64_t,0> >. ROOT::TArrayProxy<ROOT::TArrayType<bool,0> >. ROOT::TArrayProxy<ROOT::TArrayType<char,0> >. ROOT::TArrayProxy<ROOT::TArrayType<double,0> >. ROOT::TArrayProxy<ROOT::TArrayType<float,0> >. ROOT::TArrayProxy<ROOT::TArrayType<int,0> >. ROOT::TArrayProxy<ROOT::TArrayType<long,0> >. ROOT::TArrayProxy<ROOT::TArrayType<short,0> >. ROOT::TArrayProxy<ROOT::TArrayType<unsigned char,0> >. ROOT::TArrayProxy<ROOT::TArrayType<unsigned int,0> >. ROOT::TArrayProxy<ROOT::TArrayType<unsigned long,0> >. ROOT::TArrayProxy<ROOT::TArrayType<unsigned short,0> >. ROOT::TBranchProxyClassDescriptor. ROOT::TBranchProxyDescriptor. ROOT::TClaArrayProxy<ROOT::TArrayType<Long64_t,0> >. ROOT::TClaArrayProxy<ROOT::TArrayType<ULong64_t,0> >. ROOT::TClaArrayProxy<ROOT::TArrayType<bool,0> >. ROOT::TClaArrayProxy<ROOT::TArrayType<char,0> >. ROOT::TClaArrayProxy<ROOT::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ClassHierarchy.html:5025,Simpl,SimplexMinimizer,5025,root/html602/ClassHierarchy.html,https://root.cern,https://root.cern/root/html602/ClassHierarchy.html,2,['Simpl'],['SimplexMinimizer']
Usability,"dgets, like TGTextEntry,; TGFileDialog, etc. It is a little wrapper around the powerful; TString class and used for single line texts. For multi line texts; use TGText. Function Members (Methods); public:. virtual~TGTextBuffer(); voidAddText(Int_t pos, const char* text); voidAddText(Int_t pos, const char* text, Int_t length); static TClass*Class(); voidClear(); UInt_tGetBufferLength() const; const char*GetString() const; UInt_tGetTextLength() const; virtual TClass*IsA() const; voidRemoveText(Int_t pos, Int_t length); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGTextBuffer(); TGTextBuffer(Int_t length). protected:. TGTextBuffer&operator=(const TGTextBuffer& tb); TGTextBuffer(const TGTextBuffer& tb). Data Members; private:. TString*fBuffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGTextBuffer(const TGTextBuffer& tb); { }. TGTextBuffer& operator=(const TGTextBuffer& tb); {if(this!=&tb) fBuffer=tb.fBuffer; return *this;}. TGTextBuffer(); { }. TGTextBuffer(Int_t length); { }. virtual ~TGTextBuffer(); { delete fBuffer; }. UInt_t GetTextLength() const; { return fBuffer->Length(); }. UInt_t GetBufferLength() const; { return fBuffer->Capacity(); }. const char * GetString() const; { return fBuffer->Data(); }. void AddText(Int_t pos, const char* text); { fBuffer->Insert(pos, text); }. void AddText(Int_t pos, const char* text, Int_t length); { fBuffer->Insert(pos, text, length); }. void RemoveText(Int_t pos, Int_t length); { fBuffer->Remove(pos, length); }. void Clear(); { fBuffer->Remove(0, fBuffer->Length()); }. » Author: Fons Rademakers 05/05/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-02 13:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGTextBuffer.html:1958,Clear,Clear,1958,root/html602/TGTextBuffer.html,https://root.cern,https://root.cern/root/html602/TGTextBuffer.html,1,['Clear'],['Clear']
Usability,"dgets, like TGTextEntry,; TGFileDialog, etc. It is a little wrapper around the powerful; TString class and used for single line texts. For multi line texts; use TGText. Function Members (Methods); public:. virtual~TGTextBuffer(); voidAddText(Int_t pos, const char* text); voidAddText(Int_t pos, const char* text, Int_t length); static TClass*Class(); voidClear(); UInt_tGetBufferLength() const; const char*GetString() const; UInt_tGetTextLength() const; virtual TClass*IsA() const; voidRemoveText(Int_t pos, Int_t length); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGTextBuffer(); TGTextBuffer(Int_t length). protected:. TGTextBuffer&operator=(const TGTextBuffer& tb); TGTextBuffer(const TGTextBuffer& tb). Data Members; private:. TString*fBuffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGTextBuffer(const TGTextBuffer& tb); { }. TGTextBuffer& operator=(const TGTextBuffer& tb); {if(this!=&tb) fBuffer=tb.fBuffer; return *this;}. TGTextBuffer(); { }. TGTextBuffer(Int_t length); { }. virtual ~TGTextBuffer(); { delete fBuffer; }. UInt_t GetTextLength() const; { return fBuffer->Length(); }. UInt_t GetBufferLength() const; { return fBuffer->Capacity(); }. const char * GetString() const; { return fBuffer->Data(); }. void AddText(Int_t pos, const char* text); { fBuffer->Insert(pos, text); }. void AddText(Int_t pos, const char* text, Int_t length); { fBuffer->Insert(pos, text, length); }. void RemoveText(Int_t pos, Int_t length); { fBuffer->Remove(pos, length); }. void Clear(); { fBuffer->Remove(0, fBuffer->Length()); }. » Author: Fons Rademakers 05/05/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-02 15:57; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGTextBuffer.html:1958,Clear,Clear,1958,root/html604/TGTextBuffer.html,https://root.cern,https://root.cern/root/html604/TGTextBuffer.html,1,['Clear'],['Clear']
Usability,"dient: public TColorGradient. TColorGradient. TColorGradient extends basic TColor.; Actually, this is not a simple color, but linear gradient + shadow; for filled area. By inheriting from TColor, gradients can be placed; inside gROOT's list of colors and use it in all TAttXXX descendants; without modifying any existing code.; Shadow, of course, is not a property of any color, and gradient is; not, but this is the best way to add new attributes to filled area; without re-writing all the graphics code. Function Members (Methods); public:. virtual~TLinearGradient(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); const char*TColor::AsHexString() const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTColor::Copy(TObject& color) const; static voidTColor::CreateColorsCircle(Int_t offset, const char* name, UChar_t* rgb); static voidTColor::CreateColorsGray(); static voidTColor::CreateColorsRectangle(Int_t offset, const char* name, UChar_t* rgb); static voidTColor::CreateColorWheel(); static Int_tTColor::CreateGradientColorTable(UInt_t Number, Double_t* Stops, Double_t* Red, Double_t* Green, Double_t* Blue, UInt_t NColors, Float_t alpha = 1.); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TLinearGradient.html:1135,Clear,Clear,1135,root/html602/TLinearGradient.html,https://root.cern,https://root.cern/root/html602/TLinearGradient.html,2,['Clear'],['Clear']
Usability,"dient: public TColorGradient. TColorGradient. TColorGradient extends basic TColor.; Actually, this is not a simple color, but linear gradient + shadow; for filled area. By inheriting from TColor, gradients can be placed; inside gROOT's list of colors and use it in all TAttXXX descendants; without modifying any existing code.; Shadow, of course, is not a property of any color, and gradient is; not, but this is the best way to add new attributes to filled area; without re-writing all the graphics code. Function Members (Methods); public:. virtual~TRadialGradient(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); const char*TColor::AsHexString() const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTColor::Copy(TObject& color) const; static voidTColor::CreateColorsCircle(Int_t offset, const char* name, UChar_t* rgb); static voidTColor::CreateColorsGray(); static voidTColor::CreateColorsRectangle(Int_t offset, const char* name, UChar_t* rgb); static voidTColor::CreateColorWheel(); static Int_tTColor::CreateGradientColorTable(UInt_t Number, Double_t* Stops, Double_t* Red, Double_t* Green, Double_t* Blue, UInt_t NColors, Float_t alpha = 1.); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRadialGradient.html:1159,Clear,Clear,1159,root/html602/TRadialGradient.html,https://root.cern,https://root.cern/root/html602/TRadialGradient.html,2,['Clear'],['Clear']
Usability,"dients ();  ; const std::vector< Matrix_t > & GetWeightGradients () const;  ; Matrix_t & GetWeightGradientsAt (size_t i);  ; const Matrix_t & GetWeightGradientsAt (size_t i) const;  ; std::vector< Matrix_t > & GetWeights ();  ; const std::vector< Matrix_t > & GetWeights () const;  ; Matrix_t & GetWeightsAt (size_t i);  ; const Matrix_t & GetWeightsAt (size_t i) const;  ; size_t GetWidth () const;  ; virtual void Initialize ();  Initialize the weights and biases according to the given initialization method. ;  ; bool IsTraining () const;  ; void ReadMatrixXML (void *node, const char *name, Matrix_t &matrix);  ; virtual void ResetTraining ();  Reset some training flags after a loop on all batches Some layer (e.g. ;  ; void SetBatchSize (size_t batchSize);  Setters. ;  ; void SetDepth (size_t depth);  ; virtual void SetExtraLayerParameters (const std::vector< Matrix_t > &);  ; void SetHeight (size_t height);  ; void SetInputDepth (size_t inputDepth);  ; void SetInputHeight (size_t inputHeight);  ; void SetInputWidth (size_t inputWidth);  ; void SetIsTraining (bool isTraining);  ; void SetWidth (size_t width);  ; void Update (const Scalar_t learningRate);  Updates the weights and biases, given the learning rate. ;  ; void UpdateBiases (const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate);  Updates the biases, given the gradients and the learning rate. ;  ; void UpdateBiasGradients (const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate);  Updates the bias gradients, given some other weight gradients and learning rate. ;  ; void UpdateWeightGradients (const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate);  Updates the weight gradients, given some other weight gradients and learning rate. ;  ; void UpdateWeights (const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate);  Updates the weights, given the gradients and the learning rate,. ;  ; void WriteMatrixToXML (void *node, const char *nam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDenseLayer.html:6571,learn,learningRate,6571,doc/master/classTMVA_1_1DNN_1_1TDenseLayer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDenseLayer.html,2,['learn'],"['learning', 'learningRate']"
Usability,"ding of operator[]. Objects can be directly accessed via an index. The array expands automatically when objects are added. At creation time one specifies the default array size (default = 16) and lower bound (default = 0). Resizing involves a re-allocation and a copy of the old array to the new. This can be costly if done too often. If possible, set initial size close to expected final size. Index validity is always checked (if you are 100% sure and maximum performance is needed you can use UnCheckedAt() instead of At() or operator[]). If the stored objects are sort able the array can be sorted using Sort(). Once sorted, efficient searching is possible via the BinarySearch() method. The figure shows the internal data structure of a TObjArray:. The internal data structure of a TObjArray. Iterating can be done using a TIter iterator or via a simple for loop:; for (int i = 0; i <= fArr.GetLast(); i++); if ((track = (TTrack*)fArr[i])) // or fArr.At(i); track->Draw();; Main features of TObjArray are simple, well-known array semantics. Overhead per element: none, except possible over sizing of fCont.; 16.8 TClonesArray An Array of Identical Objects; A TClonesArray is an array of identical (clone) objects. The memory for the objects stored in the array is allocated only once in the lifetime of the clones array. All objects must be of the same class. For the rest this class has the same properties as a TObjArray. The internal data structure of a TClonesArray. The figure above shows the internal data structure of a TClonesArray. The class is specially designed for repetitive data analysis tasks, where in a loop many times the same objects, are created and deleted. The only supported way to add objects to a TClonesArray is via the new with placement method. The different Add() methods of TObjArray and its base classes are not supported.; 16.8.1 The Idea Behind TClonesArray; To reduce the very large number of new and delete calls in large loops like this (O(100000) x O(10000) t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:853672,simpl,simple,853672,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"directories. For example to delete a directory from a file, you must specify the directory cycle:; root[] f->Delete(""Wed011003;1""); Some other examples of namecycle format are:. foo:delete the object named foo from memory; foo;1: delete the cycle 1 of the object named foo from the file; foo;*: delete all cycles of foo from the file and also from memory; *;2: delete all objects with cycle number 2 from the file; *;*: delete all objects from memory and from the file; T*;*: delete all objects from memory and from the file including all subdirectories. 11.3 Streamers; To follow the discussion on Streamers, you need to know what a simple data type is. A variable is of a simple data type if it cannot be decomposed into other types. Examples of simple data types are longs, shorts, floats, and chars. In contrast, a variable is of a composite data type if it can be decomposed. For example, classes, structures, and arrays are composite types. Simple types are also called primitive types, basic types, and Cling sometimes calls them fundamental types.; When we say, “writing an object to a file”, we actually mean writing the current values of the data members. The most common way to do this is to decompose (also called the serialization of) the object into its data members and write them to disk. The decomposition is the job of the Streamer. Every class with ambitions to be stored in a file has a Streamerthat decomposes it and “streams” its members into a buffer.; The methods of the class are not written to the file, it contains only the persistent data members. To decompose the parent classes, the Streamercalls the Streamerof the parent classes. It moves up the inheritance tree until it reaches an ancestor without a parent. To serialize the object data members it calls their Streamer. They in turn move up their own inheritance tree and so forth. The simple data members are written to the buffer directly. Eventually the buffer contains all simple data members of all the classes t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:465842,Simpl,Simple,465842,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Simpl'],['Simple']
Usability,"distribution with errors; scaleBias: scale factor applied to the bias; Data members required:; fA, fX0, fL; Data members modified:; those documented in SetInput(); and those documented in DoUnfold(Double_t); Return value:; maximum global correlation coefficient; NOTE!!! return value >=1.0 means error, and the result is junk. Overflow bins of the input distribution are ignored!. Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; hist_vyy: if non-zero, defines the data covariance matrix; otherwise it is calculated from the data errors; hist_vyy_inv: if non-zero and if hist_vyy is set, defines the inverse of the data covariance matrix; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Data members modified:; fY, fVyy, , fBiasScale; Data members cleared; fVyyInv, fNdf; + see ClearResults. Double_t DoUnfold(Double_t tau); Unfold with given value of regularisation parameter tau; tau: new tau parameter; required data members:; fA: matrix to relate x and y; fY: measured data points; fX0: bias on x; fBiasScale: scale factor for fX0; fV: inverse of covariance matrix for y; fL: regularisation conditions; modified data members:; fTauSquared and those documented in DoUnfold(void). Int_t ScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); scan the L curve; nPoint: number of points on the resulting curve; tauMin: smallest tau value to study; tauMax: largest tau value to study; lCurve: the L curve as graph; logTauX: output spline of x-coordinates vs tau for the L c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TUnfold.html:26493,clear,cleared,26493,root/html602/TUnfold.html,https://root.cern,https://root.cern/root/html602/TUnfold.html,6,"['Clear', 'clear']","['ClearResults', 'cleared']"
Usability,"ditor::fgEditorNamename of the default pad editor ""Ged""; static TGedEditor*fgFrameCreator; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static TVirtualPadEditor*TVirtualPadEditor::fgPadEditorsingleton editor dialog; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGedEditor* GetFrameCreator(); Returns TGedEditor that currently creates TGedFrames. void SetFrameCreator(TGedEditor* e); Set the TGedEditor that currently creates TGedFrames. TGedEditor(TCanvas* canvas = 0, UInt_t width = 175, UInt_t height = 20); Constructor of graphics editor. ~TGedEditor(); Editor destructor. void Update(TGedFrame* frame = 0); Virtual method that is called on any change in the dependent frames.; This implementation simply calls fPad Modified()/Update(). TGCompositeFrame* GetEditorTab(const char* name); Find or create tab with name. TGedTabInfo* GetEditorTabInfo(const char* name); Find or create tab with name. void CloseWindow(); Called when closed via WM close button. Calls Hide(). void ReinitWorkspace(); Clears windows in editor tab.; Unmap and withdraw currently shown frames and thus prepare for; construction of a new class layout or destruction. void SetGlobal(Bool_t global); Set editor global. void GlobalClosed(); Delete global editor if no canvas exists. void GlobalSetModel(TVirtualPad* , TObject* , Int_t ); Set canvas to global editor. void ConnectToCanvas(TCanvas* c); Connect this editor to the Selected signal of canvas 'c'. void DisconnectFromCanvas(); Disconnect this editor from the Selected signal of fCanvas. void SetCanvas(TCanvas* c); Change connection to another canvas. void SetModel(TVirtualPad* pad, TObject* obj, Int_t event); Activate object editors according to the selected object. void ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGedEditor.html:26639,simpl,simply,26639,root/html528/TGedEditor.html,https://root.cern,https://root.cern/root/html528/TGedEditor.html,6,['simpl'],['simply']
Usability,dleInput methods ;  CTMPWorkerTreeFuncTemplated derivation of TMPWorkerTree handlign generic function tree processing ;  CTMPWorkerTreeSelTemplated derivation of TMPWorkerTree handlign selector tree processing ;  CTMrbSubevent_Caen;  CTMultiDimFitMultidimensional Fits in ROOT ;  CTMultiGraphA TMultiGraph is a collection of TGraph (or derived) objects ;  CTMultiLayerPerceptron;  CTMutex;  CTMutexImp;  CTMySQLResult;  CTMySQLRow;  CTMySQLServer;  ►CTMySQLStatement;  CTParamData;  CTNamedBase class for all named ROOT classes ;  CTNDArray;  CTNDArrayRef;  CTNDArrayT;  CTNetFile;  CTNetFileStager;  CTNetSystem;  CTNetXNGFile;  CTNetXNGFileStager;  CTNetXNGSystem;  CTNeuron;  CTNewChainDlg;  CTNewQueryDlg;  CTNodeTNode description ;  CTNodeDivDescription of parameters to divide a 3-D geometry object ;  CTNonCopyable;  CTNonSplitBrowsableAllows a TBrowser to browse non-split branches as if they were split ;  CTNtupleA simple TTree restricted to a list of float variables only ;  CTNtupleDA simple TTree restricted to a list of double variables only ;  CTObjArrayAn array of TObjects ;  CTObjArrayIterIterator of object array ;  CTObjectMother of all ROOT objects ;  CTObjectRefSpy;  CTObjectSet;  CTObjectSpyMonitors objects for deletion and reflects the deletion by reverting the internal pointer to zero ;  CTObjectTableThis class registers all instances of TObject and its derived classes in a hash table ;  CTObjLinkWrapper around a TObject so it can be stored in a TList ;  CTObjOptLink;  CTObjStringCollectable string class ;  CTOCCToStep;  CTODBCResult;  CTODBCRow;  CTODBCServer;  ►CTODBCStatement;  CODBCBufferRec_t;  CToolBarData_t;  CTOptionListItem;  CTOracleResult;  CTOracleRow;  CTOracleServer;  ►CTOracleStatement;  CTBufferRec;  CTOrdCollectionOrdered collection ;  CTOrdCollectionIterIterator of ordered collection ;  CTOutputListSelectorDataMapSet the selector's data members to the corresponding elements of the output list ;  CTPackageDescription;  CTPacketizerThis class g,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:181182,simpl,simple,181182,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,1,['simpl'],['simple']
Usability,dleInput methods ;  CTMPWorkerTreeFuncTemplated derivation of TMPWorkerTree handlign generic function tree processing ;  CTMPWorkerTreeSelTemplated derivation of TMPWorkerTree handlign selector tree processing ;  CTMrbSubevent_Caen;  CTMultiDimFitMultidimensional Fits in ROOT ;  CTMultiGraphA TMultiGraph is a collection of TGraph (or derived) objects ;  CTMultiLayerPerceptron;  CTMutex;  CTMutexImp;  CTMySQLResult;  CTMySQLRow;  CTMySQLServer;  ►CTMySQLStatement;  CTParamData;  CTNamedBase class for all named ROOT classes ;  CTNDArray;  CTNDArrayRef;  CTNDArrayT;  CTNetFile;  CTNetFileStager;  CTNetSystem;  CTNetXNGFile;  CTNetXNGFileStager;  CTNetXNGSystem;  CTNeuron;  CTNewChainDlg;  CTNewQueryDlg;  CTNodeTNode description ;  CTNodeDivDescription of parameters to divide a 3-D geometry object ;  CTNonCopyable;  CTNonSplitBrowsableAllows a TBrowser to browse non-split branches as if they were split ;  CTNtupleA simple TTree restricted to a list of float variables only ;  CTNtupleDA simple TTree restricted to a list of double variables only ;  CTObjArrayAn array of TObjects ;  CTObjArrayIterIterator of object array ;  CTObjectMother of all ROOT objects ;  CTObjectRefSpy;  CTObjectSet;  CTObjectSpyMonitors objects for deletion and reflects the deletion by reverting the internal pointer to zero ;  CTObjectTableThis class registers all instances of TObject and its derived classes in a hash table ;  CTObjLinkWrapper around a TObject so it can be stored in a TList ;  CTObjOptLink;  CTObjStringCollectable string class ;  CTOCCToStepThis class contains implementation of writing OpenCascade's geometry shapes to the STEP file reproducing the original ROOT geometry tree ;  CTODBCResult;  CTODBCRow;  CTODBCServer;  ►CTODBCStatement;  CODBCBufferRec_t;  CToolBarData_t;  CTOptionListItem;  CTOracleResult;  CTOracleRow;  CTOracleServer;  ►CTOracleStatement;  CTBufferRec;  CTOrdCollectionOrdered collection ;  CTOrdCollectionIterIterator of ordered collection ;  CTOutputListSelectorD,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:189749,simpl,simple,189749,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,2,['simpl'],['simple']
Usability,"dler*fInterruptHandler; TStringfSockPath; Bool_tfTerminatedtrue if Terminate() has been already called. Class Charts. Inheritance Chart:. TObject. TQObject. ←; TApplication. ←; TProofServ. TXHandler. ←; TXProofServ. Function documentation; TXProofServ(Int_t* argc, char** argv, FILE* flog = 0); Main constructor. Int_t CreateServer(); Finalize the server setup. If master, create the TProof instance to talk; the worker or submaster nodes.; Return 0 on success, -1 on error. ~TXProofServ(); Cleanup. Not really necessary since after this dtor there is no; live anyway. void HandleUrgentData(); Handle high priority data sent by the master or client. void HandleSigPipe(); Called when the client is not alive anymore; terminate the session. void HandleTermination(); Called when the client is not alive anymore; terminate the session. Int_t Setup(); Print the ProofServ logo on standard output.; Return 0 on success, -1 on error. TProofServ::EQueryAction GetWorkers(TList* workers, Int_t& prioritychange, Bool_t resume = kFALSE); Get list of workers to be used from now on.; The list must be provided by the caller. Bool_t HandleError(const void* in = 0); Handle error on the input socket. Bool_t HandleInput(const void* in = 0); Handle asynchronous input on the input socket. void DisableTimeout(); Disable read timeout on the underlying socket. void EnableTimeout(); Enable read timeout on the underlying socket. void Terminate(Int_t status); Terminate the proof server. Int_t LockSession(const char* sessiontag, TProofLockPath** lck); Try locking query area of session tagged sessiontag.; The id of the locking file is returned in fid and must be; unlocked via UnlockQueryFile(fid). void ReleaseWorker(const char* ord); Send message to intermediate coordinator to release worker of last ordinal; ord. TXProofServ(Int_t* argc, char** argv, FILE* flog = 0). » Author: G. Ganis Oct 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id$ » Last generated: 20",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXProofServ.html:19261,resume,resume,19261,root/html602/TXProofServ.html,https://root.cern,https://root.cern/root/html602/TXProofServ.html,4,['resume'],['resume']
Usability,"dles,; kDisplayModeSurface,; kDisplayModeTriangles. one can combine the above given modes groups and display modes. The meaningful; combinations (denoted by x) are given in the next table. SimpleLightHeightLight-Height. Points XXXX; Grid XXXX; Contours X-X-; Bars X-X-; LinesX XXXX; LinesY XXXX; BarsX X-X-; BarsY X-X-; Needles X---; Surface -XXX; TrianglesXXXX. Function:; void TSpectrum2Painter::SetDisplayMode (Int_t modeGroup, Int_t displayMode). This function controls the display mode group and display mode of the; histogram drawing. To illustrate the possible effects of the various display; modes we introduce a set of examples. Default values:. modeGroup = kModeGroupLightHeight ; displayMode = kDisplayModeSurface . Simple modes group, display mode = points, 256 x 256 channels. Simple modes group, display mode = grid, 64 x 64 channels. Simple modes group, display mode = contours, 64 x 64 channels. Simple modes group, display mode = bars, 64 x 64 channels. Simple modes group, display mode = linesX, 64 x 64 channels. Simple modes group, display mode = linesY, 64 x 64 channels. Simple modes group, display mode = barsX, 64 x 64 channels. Simple modes group, display mode = barsY, 64 x 64 channels. Simple modes group, display mode = needles, 64 x 64 channels. Simple modes group, display mode = triangles, 64 x 64 channels. Light modes group, display mode = points, 256 x 256 channels. Light modes group, display mode = grid, 256 x 256 channels. Light modes group, display mode = surface, 64 x 64 channels. Light modes group, display mode = triangles, 64 x 64 channels. Height modes group, display mode = points, 256 x 256 channels. Height modes group, display mode = grid, 256 x 256 channels. Height modes group, display mode = contours, 64 x 64 channels. Height modes group, display mode = bars, 64 x 64 channels. Height modes group, display mode = surface, 64 x 64 channels. Height modes group, display mode = triangles, 64 x 64 channels. Light - height modes group, display mode = s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSpectrum2Painter.html:18073,Simpl,Simple,18073,root/html532/TSpectrum2Painter.html,https://root.cern,https://root.cern/root/html532/TSpectrum2Painter.html,4,['Simpl'],['Simple']
Usability,"dm; ; # For speed, bind and cache the Fill member functions,; histos = [ 'hpx', 'hpxpy', 'hprof', 'ntuple' ]; for name in histos:; exec('%sFill = %s.Fill' % (name,name)); ; # Fill histograms randomly.; px_ref, py_ref = ctypes.c_double(), ctypes.c_double(); kUPDATE = 1000; for i in range( 25000 ):; # Generate random values. Use ctypes to pass doubles by reference; rannor( px_ref, py_ref ); # Retrieve the generated values; px = px_ref.value; py = py_ref.value; ; pz = px*px + py*py; random = rndm(1); ; # Fill histograms.; hpx.Fill( px ); hpxpy.Fill( px, py ); hprof.Fill( px, pz ); ntuple.Fill( px, py, pz, random, i ); ; # Update display every kUPDATE events.; if i and i%kUPDATE == 0:; if i == kUPDATE:; hpx.Draw(); ; c1.Modified(); c1.Update(); ; if gSystem.ProcessEvents(): # allow user interrupt; break; ; # Destroy member functions cache.; for name in histos:; exec('del %sFill' % name); del histos; ; gBenchmark.Show( 'hsimple' ); ; # Save all objects in this file.; hpx.SetFillColor( 0 ); hfile.Write(); hpx.SetFillColor( 48 ); c1.Modified(); c1.Update(); ; # Note that the file is automatically closed when application terminates; # or when the file destructor is called.; SetFillColorOption_t Option_t SetFillColorDefinition TGWin32VirtualXProxy.cxx:50; TCanvasThe Canvas class.Definition TCanvas.h:23; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TProfileProfile Histogram.Definition TProfile.h:32; SetBorderSizec SetBorderSize(2); AuthorWim Lavrijsen, Enric Tejedor ; Definition in file hsimple.py. tutorialspyroothsimple.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/hsimple_8py.html:3361,simpl,simple,3361,doc/master/hsimple_8py.html,https://root.cern,https://root.cern/doc/master/hsimple_8py.html,1,['simpl'],['simple']
Usability,"do(); TStringfTitlecommand description; TQConnection*fUndoundo action; Long_t*fUndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Init(const char* cl, void* object, const char* redo, const char* undo); common protected method used in several constructors. TQCommand(const char* cl = 0, void* object = 0, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. clname - class name.; 2. obj - an object; 3. redo - method or function to do/redo operation; 4. undo - method or function to undo operation. Comments:; - if either clname or obj is NULL that means that redo/undo is function; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(""TPad"", gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case undo parameter; can be omitted. Example:; TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. obj - an object; 2. redo - method or function to do/redo operation; 3. undo - method or function to undo operation. Comments:; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case ""undo""; can parameter be omitted. Example:; TQCommand(gPad, ""SetFillStyle(Style_t)"");. TQCommand(const TQCommand& com); Copy constructor. ~TQCommand(); dtor. TQCommand * GetCommand(); Return a command which is doing redo/undo action. This static method allows to set undo parameters dynamically, i.e.; during execution of Redo function. Example:; For redo actions like TGTextEdit::DelChar() it is not possible to; know ahead what character will be deleted.; To",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQCommand.html:18433,undo,undo,18433,root/html528/TQCommand.html,https://root.cern,https://root.cern/root/html528/TQCommand.html,6,['undo'],['undo']
Usability,"do-inverse is calculated . Tolerances and Scaling; The tolerance parameter (which is a member of this base class) plays a crucial role in all operations of the decomposition classes . It gives the user a powerful tool to monitor and steer the operations Its default value is sqrt(epsilon) where 1+epsilon = 1; If you do not want to be bothered by the following considerations, like in most other linear algebra packages, just set the tolerance with SetTol to an arbitrary small number .; The tolerance number is used by each decomposition method to decide whether the matrix is near singular, except of course SVD which can handle singular matrices . For each decomposition this will be checked in a different way; in LU the matrix is considered singular when, at some point in the decomposition, a diagonal element < fTol . Therefore, we had to set in the example above of the (10x10) Hilbert, which is near singular, the tolerance on 10e-12 . (The fact that we have to set the tolerance < sqrt(epsilon) is a clear indication that we are losing precision .); If the matrix is flagged as being singular, operations with the decomposition will fail and will return matrices/vectors that are invalid .; The observant reader will notice that by scaling the complete matrix by some small number the decomposition will detect a singular matrix . In this case the user will have to reduce the tolerance number by this factor . (For CPU time saving we decided not to make this an automatic procedure) .; Code for this could look as follows: const Double_t max_abs = Abs(a).Max();; const Double_t scale = TMath::Min(max_abs,1.);; a.SetTol(a.GetTol()*scale);; a#define a(i)Definition RSha256.hxx:99; double; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; For usage examples see $ROOTSYS/test/stressLinear.cxx ; Definition at line 33 of file TDecompBase.h. Public Member Functions;  TDecompBase ();  Default constructor. ;  ;  TDecompBase (const TDecompBa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDecompBase.html:3579,clear,clear,3579,doc/master/classTDecompBase.html,https://root.cern,https://root.cern/doc/master/classTDecompBase.html,1,['clear'],['clear']
Usability,"doUndo-Button; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTubeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for tube editor. ~TGeoTubeEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void DoRmin(); Slot for rmin. void DoRmax(); Slot for rmax. void DoDz(); Slot for dz. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTubeEditor.html:21363,undo,undoing,21363,root/html534/TGeoTubeEditor.html,https://root.cern,https://root.cern/root/html534/TGeoTubeEditor.html,2,['undo'],['undoing']
Usability,"dobj, Int_t bufsize = 32000, Int_t splitlevel = 1); Create a new TTree BranchObject. Build a TBranchObject for an object of class classname.; addobj is the address of a pointer to an object of class classname.; IMPORTANT: classname must derive from TObject.; The class dictionary must be available (ClassDef in class header). This option requires access to the library where the corresponding class; is defined. Accessing one single data member in the object implies; reading the full object.; See the next Branch constructor for a more efficient storage; in case the entry consists of arrays of identical objects. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. IMPORTANT NOTE about branch names; In case two or more master branches contain subbranches with; identical names, one must add a ""."" (dot) character at the end; of the master branch name. This will force the name of the subbranch; to be master.subbranch instead of simply subbranch.; This situation happens when the top level object (say event); has two or more members referencing the same class.; For example, if a Tree has two branches B1 and B2 corresponding; to objects of the same class MyClass, one can do:; tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate; subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c. bufsize is the buffer size in bytes for this branch; The default value is 32000 bytes and should be ok for most cases.; You can specify a larger value (e.g. 256000) if your Tree is not split; and each entry is large (Megabytes); A small value for bufsize is optimum if you intend to access; the entries in the Tree randomly and your Tree is in split mode. TBranch* BranchRef(); Build the optional branch supporting the TRefTable.; This branch will keep all the information to find the branches; containing referenced objects. At each T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTree.html:50683,simpl,simply,50683,root/html532/TTree.html,https://root.cern,https://root.cern/root/html532/TTree.html,8,['simpl'],['simply']
Usability,"dobj, Int_t bufsize = 32000, Int_t splitlevel = 1); Create a new TTree BranchObject. Build a TBranchObject for an object of class classname.; addobj is the address of a pointer to an object of class classname.; IMPORTANT: classname must derive from TObject.; The class dictionary must be available (ClassDef in class header). This option requires access to the library where the corresponding class; is defined. Accessing one single data member in the object implies; reading the full object.; See the next Branch constructor for a more efficient storage; in case the entry consists of arrays of identical objects. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. IMPORTANT NOTE about branch names; In case two or more master branches contain subbranches with; identical names, one must add a ""."" (dot) character at the end; of the master branch name. This will force the name of the subbranch; to be master.subbranch instead of simply subbranch.; This situation happens when the top level object (say event); has two or more members referencing the same class.; For example, if a Tree has two branches B1 and B2 corresponding; to objects of the same class MyClass, one can do:; tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate; subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c. bufsize is the buffer size in bytes for this branch; The default value is 32000 bytes and should be ok for most cases.; You can specify a larger value (eg 256000) if your Tree is not split; and each entry is large (Megabytes); A small value for bufsize is optimum if you intend to access; the entries in the Tree randomly and your Tree is in split mode. TBranch* BranchRef(); Build the optional branch supporting the TRefTable.; This branch will keep all the information to find the branches; containing referenced objects. At each Tre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:48346,simpl,simply,48346,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,2,['simpl'],['simply']
Usability,"domGenerator<TRandom3> rng(shuffleSeed);; 1440 ; 1441 // print weights before; 1442 if (fBuildNet && debug) {; 1443 Log() << ""Initial Deep Net Weights "" << Endl;; 1444 auto & weights_tensor = deepNet.GetLayerAt(0)->GetWeights();; 1445 for (size_t l = 0; l < weights_tensor.size(); ++l); 1446 weights_tensor[l].Print();; 1447 auto & bias_tensor = deepNet.GetLayerAt(0)->GetBiases();; 1448 bias_tensor[0].Print();; 1449 }; 1450 ; 1451 Log() << "" Start epoch iteration ..."" << Endl;; 1452 bool debugFirstEpoch = false;; 1453 bool computeLossInTraining = true; // compute loss in training or at test time; 1454 size_t nTrainEpochs = 0;; 1455 while (!converged) {; 1456 nTrainEpochs++;; 1457 trainingData.Shuffle(rng);; 1458 ; 1459 // execute all epochs; 1460 //for (size_t i = 0; i < batchesInEpoch; i += nThreads) {; 1461 ; 1462 Double_t trainingError = 0;; 1463 for (size_t i = 0; i < batchesInEpoch; ++i ) {; 1464 // Clean and load new batches, one batch for one slave net; 1465 //batches.clear();; 1466 //batches.reserve(nThreads);; 1467 //for (size_t j = 0; j < nThreads; j++) {; 1468 // batches.push_back(trainingData.GetTensorBatch());; 1469 //}; 1470 if (debugFirstEpoch) std::cout << ""\n\n----- batch # "" << i << ""\n\n"";; 1471 ; 1472 auto my_batch = trainingData.GetTensorBatch();; 1473 ; 1474 if (debugFirstEpoch); 1475 std::cout << ""got batch data - doing forward \n"";; 1476 ; 1477#ifdef DEBUG; 1478 ; 1479 Architecture_t::PrintTensor(my_batch.GetInput(),""input tensor"",true);; 1480 typename Architecture_t::Tensor_t tOut(my_batch.GetOutput());; 1481 typename Architecture_t::Tensor_t tW(my_batch.GetWeights());; 1482 Architecture_t::PrintTensor(tOut,""label tensor"",true) ;; 1483 Architecture_t::PrintTensor(tW,""weight tensor"",true) ;; 1484#endif; 1485 ; 1486 deepNet.Forward(my_batch.GetInput(), true);; 1487 // compute also loss; 1488 if (computeLossInTraining) {; 1489 auto outputMatrix = my_batch.GetOutput();; 1490 auto weights = my_batch.GetWeights();; 1491 trainingError += deepNet.Loss(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:58244,clear,clear,58244,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['clear'],['clear']
Usability,"domain - authentication domain; loopback - bind specified port to loopback 127.0.0.1 address; debug - enable debug mode, server always returns html page with request info. If necessary, one could bind http server to specific IP address like:; new THttpServer(""http:192.168.1.17:8080""); 1.2 Registering objects; At any time, one could register other objects with the command:; TGraph* gr = new TGraph(10);; gr->SetName(""gr1"");; serv->Register(""graphs/subfolder"", gr);; One should specify sub-folder name, where objects will be registered. If sub-folder name does not starts with slash /, than top-name folder /Objects/ will be prepended. At any time one could unregister objects:; serv->Unregister(gr);; THttpServer does not take ownership over registered objects - they should be deleted by user.; If the objects content is changing in the application, one could enable monitoring flag in the browser - then objects view will be regularly updated.; 1.3 Command interface; THttpServer class provide simple interface to invoke command from web browser. One just register command like:; serv->RegisterCommand(""/DoSomething"",""SomeFunction()"");; Element with name DoSomething will appear in the web browser and can be clicked. It will result in gROOT->ProcessLineSync(""SomeFunction()"") call. When registering command, one could specify icon name which will be displayed with the command.; serv->RegisterCommand(""/DoSomething"",""SomeFunction()"", ""/rootsys/icons/ed_execute.png"");; In example usage of images from $ROOTSYS/icons directory is shown. One could prepend button; string to the icon name to let browser show command as extra button. In last case one could hide command element from elements list:; serv->Hide(""/DoSomething"");; One can find example of command interface usage in tutorials/http/httpcontrol.C macro.; 1.4 Configuring user access; By default, the http server is open for anonymous access. One could restrict the access to the server for authenticated users only. First of all, one shou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/HttpServer/HttpServer.html:3252,simpl,simple,3252,root/html534/guides/HttpServer/HttpServer.html,https://root.cern,https://root.cern/root/html534/guides/HttpServer/HttpServer.html,2,['simpl'],['simple']
Usability,"done.; Returns -1 in case of error. void ShowData(); List contents of the data directory in the sandbox.; This is the place where files produced by the client queries are kept. void ClearData(UInt_t what = kUnregistered, const char* dsname = 0); Remove files for the data directory.; The option 'what' can take the values:; kPurge remove all files and directories under '~/data'; kUnregistered remove only files not in registered datasets (default); kDataset remove files belonging to dataset 'dsname'; User is prompt for confirmation, unless kForceClear is ORed with the option. Bool_t Prompt(const char* p); Prompt the question 'p' requiring an answer y,Y,n,N; Return kTRUE is the answer was y or Y, kFALSE in all other cases. void ClearDataProgress(Int_t r, Int_t t); Progress bar for clear data. void ShowCache(Bool_t all = kFALSE); List contents of file cache. If all is true show all caches also on; slaves. If everything is ok all caches are to be the same. void ClearCache(const char* file = 0); Remove file from all file caches. If file is 0 or """" or ""*"", remove all; the files. void SystemCmd(const char* cmd, Int_t fdout); Exec system command 'cmd'. If fdout > -1, append the output to fdout. void ShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); List contents of package directory. If all is true show all package; directories also on slaves. If everything is ok all package directories; should be the same. If redir is kTRUE the result is redirected to the log; file (option available for internal actions). void ShowEnabledPackages(Bool_t all = kFALSE); List which packages are enabled. If all is true show enabled packages; for all active slaves. If everything is ok all active slaves should; have the same packages enabled. Int_t ClearPackages(); Remove all packages.; Returns 0 in case of success and -1 in case of error. Int_t ClearPackage(const char* package); Remove a specific package.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackage(const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProof.html:60373,Clear,ClearCache,60373,root/html532/TProof.html,https://root.cern,https://root.cern/root/html532/TProof.html,4,['Clear'],['ClearCache']
Usability,"dow* p, TGuiBldEditor* editor); virtual~TGuiBldNameFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); voidChangeSelected(TGFrame* frame); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); Bool_tCheckItems(TGCompositeFrame* main); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()SIGNAL ; virtual voidTGWindow::DestroySubwindows(); virtual voidTGWindow::DestroyWindow(); Bool_tTQObject::Disconnect(const char* signal = 0, void* receive",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGuiBldNameFrame.html:1400,Clear,Clear,1400,root/html532/TGuiBldNameFrame.html,https://root.cern,https://root.cern/root/html532/TGuiBldNameFrame.html,2,['Clear'],['Clear']
Usability,"dow* p, const char* s, const char* cmd, Int_t id = -1, GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t option = 0); virtual~TGCheckButton(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTGButton::AllowStayDown(Bool_t a); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); voidTGTextButton::ChangeText(const char* title)MENU ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual voidTGButton::Clicked()SIGNAL ; virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()SIGNAL ; virtual voidTGWindow::DestroySubwindows(); virtual voidTGWindow::DestroyWindow(); Bool_tTQObject::Disconne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGCheckButton.html:4346,Clear,Clear,4346,root/html532/TGCheckButton.html,https://root.cern,https://root.cern/root/html532/TGCheckButton.html,2,['Clear'],['Clear']
Usability,"dow* p, const char* s, const char* cmd, Int_t id = -1, GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t option = 0); virtual~TGRadioButton(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTGButton::AllowStayDown(Bool_t a); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); voidTGTextButton::ChangeText(const char* title)MENU ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual voidTGButton::Clicked()SIGNAL ; virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()SIGNAL ; virtual voidTGWindow::DestroySubwindows(); virtual voidTGWindow::DestroyWindow(); Bool_tTQObject::Disconne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGRadioButton.html:4346,Clear,Clear,4346,root/html532/TGRadioButton.html,https://root.cern,https://root.cern/root/html532/TGRadioButton.html,2,['Clear'],['Clear']
Usability,"down the tree, one cycles through the axes used to select the splitting planes. (For example, the root would have an x-aligned plane, the root's children would both have y-aligned planes, the root's grandchildren would all have z-aligned planes, and so on.) At each step, the point selected to create the splitting plane is the median of the points being put into the kd-tree, with respect to their coordinates in the axis being used. (Note the assumption that we feed the entire set of points into the algorithm up-front.); This method leads to a balanced kd-tree, in which each leaf node is about the same distance from the root. However, balanced trees are not necessarily optimal for all applications. The following pseudo-code illustrates this canonical construction procedure (NOTE, that the procedure used by the TKDTree class is a bit different, the following pseudo-code is given as a simple illustration of the concept):; function kdtree (list of points pointList, int depth); {; if pointList is empty; return nil;; else; {; // Select axis based on depth so that axis cycles through all valid values; var int axis := depth mod k;; ; // Sort point list and choose median as pivot element; select median from pointList;; ; // Create node and construct subtrees; var tree_node node;; node.location := median;; node.leftChild := kdtree(points in pointList before median, depth+1);; node.rightChild := kdtree(points in pointList after median, depth+1);; return node;; }; }; pointsOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t pointsDefinition TGWin32VirtualXProxy.cxx:148; Our construction method is optimized to save memory, and differs a bit from the constraints above. In particular, the division axis is chosen as the one with the biggest spread, and the point to create the splitting plane is chosen so, that one of the two subtrees contains exactly 2^k terminal node",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTKDTree.html:2980,simpl,simple,2980,doc/master/classTKDTree.html,https://root.cern,https://root.cern/doc/master/classTKDTree.html,1,['simpl'],['simple']
Usability,"dows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoBBoxEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for volume editor. ~TGeoBBoxEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Update editor for a new selected box. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current parameters. void DoModified(); Slot for modifying current parameters. void DoUndo(); Slot for undoing last operation. void DoDx(); Slot for Dx modification. void DoDy(); Slot for Dy modification. void DoDz(); Slot for Dz modification. void DoOx(); Slot for Ox modification. void DoOy(); Slot for Oy modification. void DoOz(); Slot for Oz modification. TGeoBBoxEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-02 16:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoBBoxEditor.html:22304,undo,undoing,22304,root/html604/TGeoBBoxEditor.html,https://root.cern,https://root.cern/root/html604/TGeoBBoxEditor.html,2,['undo'],['undoing']
Usability,"dows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoBBoxEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for volume editor. ~TGeoBBoxEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Update editor for a new selected box. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current parameters. void DoModified(); Slot for modifying current parameters. void DoUndo(); Slot for undoing last operation. void DoDx(); Slot for Dx modification. void DoDy(); Slot for Dy modification. void DoDz(); Slot for Dz modification. void DoOx(); Slot for Ox modification. void DoOy(); Slot for Oy modification. void DoOz(); Slot for Oz modification. TGeoBBoxEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoBBoxEditor.html:22304,undo,undoing,22304,root/html602/TGeoBBoxEditor.html,https://root.cern,https://root.cern/root/html602/TGeoBBoxEditor.html,2,['undo'],['undoing']
Usability,"draw text always at the same place over a histogram, no matter what the histogram coordinates are. There are two ways to do this. You can set the NDC for one object or may convert NDC to user coordinates. Most graphical objects offer an option to be drawn in NDC. For instance, a line (TLine) may be drawn in NDC by using DrawLineNDC(). A latex formula or a text may use TText::SetNDC() to be drawn in NDC coordinates.; 9.3.3 Converting between Coordinate Systems; There are a few utility functions in TPad to convert from one system of coordinates to another. In the following table, a point is defined by (px,py) in pixel coordinates, (ux,uy) in user coordinates, (ndcx,ndcy) in normalized coordinates, (apx, apy) are in absolute pixel coordinates. Conversion; TPad’s Methods; Returns. NDC to Pixel; UtoPixel(ndcx); VtoPixel(ndcy); Int_t; Int_t. Pixel to User; PixeltoX(px); PixeltoY(py); PixeltoXY(px,py,&ux,&uy); Double_t; Double_t; Double_t ux,uy. User to Pixel; XtoPixel(ux); YtoPixel(uy); XYtoPixel(ux,uy,&px,&py); Int_t; Int_t; Int_t px,py. User to absolute pixel; XtoAbsPixel(ux); YtoAbsPixel(uy); XYtoAbsPixel(ux,uy,&apx,&apy); Int_t; Int_t; Int_t apx,apy. Absolute pixel to user; AbsPixeltoX(apx); AbsPixeltoY(apy); AbsPixeltoXY(apx,apy,&ux,&uy); Double_t; Double_t; Double_t ux,uy. Note: all the pixel conversion functions along the Y axis consider that py=0 is at the top of the pad except PixeltoY() which assume that the position py=0 is at the bottom of the pad. To make PixeltoY() converting the same way as the other conversion functions, it should be used the following way (p is a pointer to a TPad):; p->PixeltoY(py - p->GetWh());; 9.3.4 Dividing a Pad into Sub-pads; Dividing a pad into sub pads in order for instance to draw a few histograms, may be done in two ways. The first is to build pad objects and to draw them into a parent pad, which may be a canvas. The second is to automatically divide a pad into horizontal and vertical sub pads.; 9.3.4.1 Creating a Single Sub-pa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:310888,ux,ux,310888,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['ux'],['ux']
Usability,"drawn with different graphics options in different pads. When a displayed histogram is deleted, its image is automatically removed from the pad. To create a copy of the histogram when drawing it, you can use TH1::DrawClone(). This will clone the histogram and allow you to change and delete the original one without affecting the clone. You can use TH1::DrawNormalized() to draw a normalized copy of a histogram.; TH1 *TH1::DrawNormalized(Option_t *option,Double_t norm) const; A clone of this histogram is normalized to norm and drawn with option. A pointer to the normalized histogram is returned. The contents of the histogram copy are scaled such that the new sum of weights (excluding under and overflow) is equal to norm .; Note that the returned normalized histogram is not added to the list of histograms in the current directory in memory. It is the user’s responsibility to delete this histogram. The kCanDelete bit is set for the returned object. If a pad containing this copy is cleared, the histogram will be automatically deleted. See “Draw Options” for the list of options.; 3.8.1 Setting the Style; Histograms use the current style gStyle, which is the global object of class TStyle. To change the current style for histograms, the TStyle class provides a multitude of methods ranging from setting the fill color to the axis tick marks. Here are a few examples:; void SetHistFillColor(Color_t color = 1); void SetHistFillStyle(Style_t styl = 0); void SetHistLineColor(Color_t color = 1); void SetHistLineStyle(Style_t styl = 0); void SetHistLineWidth(Width_t width = 1); When you change the current style and would like to propagate the change to a previously created histogram you can call TH1::UseCurrentStyle(). You will need to call UseCurrentStyle() on each histogram. When reading many histograms from a file and you wish to update them to the current style, you can use gROOT::ForceStyle and all histograms read after this call will be updated to use the current style. See “Gra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:83650,clear,cleared,83650,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['clear'],['cleared']
Usability,"drenCount ; (; ). inlinefinalvirtual . Implements ROOT::Detail::RDF::RNodeBase.; Definition at line 235 of file RLoopManager.hxx. ◆ InitNodes(). void RLoopManager::InitNodes ; (; ). private . Initialize all nodes of the functional graph before running the event loop. ; This method is called once per event-loop and performs generic initialization operations that do not depend on the specific processing slot (i.e. operations that are common for all threads). ; Definition at line 791 of file RLoopManager.cxx. ◆ InitNodeSlots(). void RLoopManager::InitNodeSlots ; (; TTreeReader * ; r, . unsigned int ; slot . ). private . Build TTreeReaderValues for all nodes This method loops over all filters, actions and other booked objects and calls their InitSlot method, to get them ready for running a task. ; Definition at line 728 of file RLoopManager.cxx. ◆ Jit(). void RLoopManager::Jit ; (; ). Add RDF nodes that require just-in-time compilation to the computation graph. ; This method also clears the contents of GetCodeToJit(). ; Definition at line 848 of file RLoopManager.cxx. ◆ JitDeclarations(). void ROOT::Detail::RDF::RLoopManager::JitDeclarations ; (; ). ◆ operator=() [1/2]. RLoopManager & ROOT::Detail::RDF::RLoopManager::operator= ; (; const RLoopManager & ; ). delete . ◆ operator=() [2/2]. RLoopManager & ROOT::Detail::RDF::RLoopManager::operator= ; (; RLoopManager && ; ). delete . ◆ PartialReport(). void ROOT::Detail::RDF::RLoopManager::PartialReport ; (; ROOT::RDF::RCutFlowReport & ; ); const. inlinefinalvirtual . End of recursive chain of calls, does nothing. ; Implements ROOT::Detail::RDF::RNodeBase.; Definition at line 233 of file RLoopManager.hxx. ◆ Register() [1/5]. void RLoopManager::Register ; (; RDefineBase * ; definePtr). Definition at line 984 of file RLoopManager.cxx. ◆ Register() [2/5]. void RLoopManager::Register ; (; RDFInternal::RActionBase * ; actionPtr). Definition at line 946 of file RLoopManager.cxx. ◆ Register() [3/5]. void RLoopManager::Register ; (; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html:21903,clear,clears,21903,doc/master/classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html,1,['clear'],['clears']
Usability,"ds for the first parameter and a lower bound for the second parameter; fitter.SetFunction( fitFunction, false);; fitter.Config().ParSettings(0).SetLimits(0,1.E6);; fitter.Config().ParSettings(2).SetLowerLimit(0);; Note that a ROOT::Fit::ParameterSettings objects exists for each fit parameter and it created by the ROOT::Fit::FitConfig class, after the model function has been set in the Fitter. Only when the function is set, the number of parameter is known and automatically the FitConfig creates the corresponding ParameterSetting objects.; When fitting, different minimizer can be used. The can be implemented in different libraries and loaded ar run time by the plug-in manager system of ROOT. Each different minimizer (e.g. Minuit, Minuit2, Fumili, etc.) consists of a different implementation of the ROOT::Math::Minimizer interface. Within the same minimizer, thus within the same class implementing the Minimizer interface, different algorithms can exist. For example in the case of Minuit, we have Migrad, Simplex or Minimize. The minimizer and its corresponding algorithm, when available, can be set by using the function FitConfig::SetMinimizer(""minimizerName"") or by using directly the ROOT:Math::MinimizerOptions class.; If the requested minimizer is not available in ROOT, the default one is used. The default minimizer type and algorithm can be specified by using the static function ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""minimizerName""); 5.7.4 Minimizer Libraries and Algorithms; The list of available minimizer libraries currently available in ROOT, with their corresponding available algorithms is the following one. Some minimizers (e.g. Minuit) contain several algorithms that the user can choose. Others are based on a single algorithm (e.g. Fumili). Minuit (library libMinuit). Old version of Minuit, based on the TMinuit class. The list of possible algorithms are:. Migrad (default one); Simplex; Minimize (it is a combination of Migrad and Simplex); MigradImprov",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:201652,Simpl,Simplex,201652,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Simpl'],['Simplex']
Usability,"dth; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGGC*fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetRange(Float_t min, Float_t max); Set min and max of progress bar. void SetPosition(Float_t pos); Set progress position between [min,max]. void Increment(Float_t inc); Increment progress position. void Reset(); Reset progress bar (i.e. set pos to 0). void SetFillType(TGProgressBar::EFillType type); Set fill type. void SetBarType(TGProgressBar::EBarType type); Set bar type. void SetBarColor(ULong_t color); Set progress bar color. void SetBarColor(const char* color = ""blue""); Set progress bar color. void Format(const char* format = ""%.2f""); Set format for displaying a value. FontStruct_t GetDefaultFontStruct(); Return default font structure in use. const TGGC & GetDefaultGC(); Return default graphics context in use. void SetForegroundColor(Pixel_t pixel); Change text color drawing. void SavePrimitive(ostream& out, Option_t* option = """"); Save progress bar parameters as a C++ statement(s) on output stream out. Bool_t fDrawBar; // if true draw only bar in DoRedraw(). virtual ~TGProgressBar(); { }. Float_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGProgressBar.html:19118,progress bar,progress bar,19118,root/html528/TGProgressBar.html,https://root.cern,https://root.cern/root/html528/TGProgressBar.html,6,['progress bar'],['progress bar']
Usability,"dths. void DoCameraOverlay(); Update viewer with GUI state. void DoCameraCenterExt(); Set external camera center. void DoCaptureCenter(); Capture camera-center via picking. void DoDrawCameraCenter(); Draw camera center. void UpdateCameraCenter(); Update current camera with GUI state. void DoAnnotation(); Create annotation via picking. void UpdateViewerAxes(Int_t id); Update viewer with GUI state. void UpdateViewerReference(); Update viewer with GUI state. TGNumberEntry* MakeLabeledNEntry(TGCompositeFrame* p, const char* name, Int_t labelw, Int_t nd = 7, Int_t s = 5); Helper function to create fixed width TGLabel and TGNumberEntry in same row. void CreateStyleTab(); Creates ""Style"" tab. void CreateGuidesTab(); Create ""Guides"" tab. void CreateClippingTab(); Create GUI controls - clip type (none/plane/box) and plane/box properties. void CreateExtrasTab(); Create Extra Tab controls - camera rotator and stereo. void UpdateReferencePosState(); Enable/disable reference position (x/y/z) number edits based on; reference check box. void SetGuides(); Configuration of guides GUI called from SetModel(). void SetRotatorMode(). void UpdateRotator(); Update rotator related variables. void DoRotatorStart(); Start auto-rotator. void DoRotatorStop(); Stop auto-rotator. void DoASavImageGUIBaseName(const char* t); Update base-name. void DoASavImageGUIOutMode(Int_t m); Update output mode. void DoASavImageStart(); Start auto-rotator image auto-save. void DoASavImageStop(); Stop auto-rotator image auto-save. void UpdateStereo(); Update stereo related variables. TGLViewerEditor(const TGLViewerEditor& ). void DetachFromPad(); {fIsInPad = kFALSE;}. » Author: Alja Mrak-Tadel, Matevz Tadel, Timur Pocheptsov 08/03/2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-05-01 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLViewerEditor.html:24162,guid,guides,24162,root/html534/TGLViewerEditor.html,https://root.cern,https://root.cern/root/html534/TGLViewerEditor.html,2,['guid'],['guides']
Usability,"dths. void DoCameraOverlay(); Update viewer with GUI state. void DoCameraCenterExt(); Set external camera center. void DoCaptureCenter(); Capture camera-center via picking. void DoDrawCameraCenter(); Draw camera center. void UpdateCameraCenter(); Update current camera with GUI state. void DoAnnotation(); Create annotation via picking. void UpdateViewerAxes(Int_t id); Update viewer with GUI state. void UpdateViewerReference(); Update viewer with GUI state. TGNumberEntry* MakeLabeledNEntry(TGCompositeFrame* p, const char* name, Int_t labelw, Int_t nd = 7, Int_t s = 5); Helper function to create fixed width TGLabel and TGNumberEntry in same row. void CreateStyleTab(); Creates ""Style"" tab. void CreateGuidesTab(); Create ""Guides"" tab. void CreateClippingTab(); Create GUI controls - clip type (none/plane/box) and plane/box properties. void CreateExtrasTab(); Create Extra Tab controls - camera rotator and stereo. void UpdateReferencePosState(); Enable/disable reference position (x/y/z) number edits based on; reference check box. void SetGuides(); Configuration of guides GUI called from SetModel(). void SetRotatorMode(). void UpdateRotator(); Update rotator related variables. void DoRotatorStart(); Start auto-rotator. void DoRotatorStop(); Stop auto-rotator. void DoASavImageGUIBaseName(const char* t); Update base-name. void DoASavImageGUIOutMode(Int_t m); Update output mode. void DoASavImageStart(); Start auto-rotator image auto-save. void DoASavImageStop(); Stop auto-rotator image auto-save. void UpdateStereo(); Update stereo related variables. TGLViewerEditor(const TGLViewerEditor& ). void DetachFromPad(); {fIsInPad = kFALSE;}. » Author: Alja Mrak-Tadel, Matevz Tadel, Timur Pocheptsov 08/03/2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-02 15:54; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGLViewerEditor.html:24984,guid,guides,24984,root/html604/TGLViewerEditor.html,https://root.cern,https://root.cern/root/html604/TGLViewerEditor.html,2,['guid'],['guides']
Usability,"dths. void DoCameraOverlay(); Update viewer with GUI state. void DoCameraCenterExt(); Set external camera center. void DoCaptureCenter(); Capture camera-center via picking. void DoDrawCameraCenter(); Draw camera center. void UpdateCameraCenter(); Update current camera with GUI state. void DoAnnotation(); Create annotation via picking. void UpdateViewerAxes(Int_t id); Update viewer with GUI state. void UpdateViewerReference(); Update viewer with GUI state. TGNumberEntry* MakeLabeledNEntry(TGCompositeFrame* p, const char* name, Int_t labelw, Int_t nd = 7, Int_t s = 5); Helper function to create fixed width TGLabel and TGNumberEntry in same row. void CreateStyleTab(); Creates ""Style"" tab. void CreateGuidesTab(); Create ""Guides"" tab. void CreateClippingTab(); Create GUI controls - clip type (none/plane/box) and plane/box properties. void CreateExtrasTab(); Create Extra Tab controls - camera rotator and stereo. void UpdateReferencePosState(); Enable/disable reference position (x/y/z) number edits based on; reference check box. void SetGuides(); Configuration of guides GUI called from SetModel(). void SetRotatorMode(). void UpdateRotator(); Update rotator related variables. void DoRotatorStart(); Start auto-rotator. void DoRotatorStop(); Stop auto-rotator. void DoASavImageGUIBaseName(const char* t); Update base-name. void DoASavImageGUIOutMode(Int_t m); Update output mode. void DoASavImageStart(); Start auto-rotator image auto-save. void DoASavImageStop(); Stop auto-rotator image auto-save. void UpdateStereo(); Update stereo related variables. TGLViewerEditor(const TGLViewerEditor& ). void DetachFromPad(); {fIsInPad = kFALSE;}. » Author: Alja Mrak-Tadel, Matevz Tadel, Timur Pocheptsov 08/03/2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-30 14:54; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLViewerEditor.html:24984,guid,guides,24984,root/html602/TGLViewerEditor.html,https://root.cern,https://root.cern/root/html602/TGLViewerEditor.html,2,['guid'],['guides']
Usability,"dual axis but it does not give any hints about the correlations between the axes.; Avery simple technique allows to make the clusters appearing: Instead of painting solid lines we paint dotted lines. The cluttering of each individual line is reduced and the clusters show clearly as we can see on the next figure. The spacing between the dots is a parameter which can be adjusted in order to get the best results. Using dotted lines is a very simple method to reduce the cluttering. Interactivity is a very important aspect of the Parallel Coordinates plots. To really explore the data set it is essential to act directly with the events and the axes. For instance, changing the axes order may show clusters which were not visible in a different order. On the next figure the axes order has been changed interactively. We can see that many more clusters appear and all the “random spheres” we put in the data set are now clearly visible. Having moved the variables u,v,w after the variables x,y,z the correlation between these two sets of variables is clear also. Axis order is very important to show clusters. To pursue further data sets exploration we have implemented the possibility to define selections interactively. A selection is a set of ranges combined together. Within a selection, ranges along the same axis are combined with logical OR, and ranges on different axes with logical AND. A selection is displayed on top of the complete data set using its own color. Only the events fulfilling the selection criteria (ranges) are displayed. Ranges are defined interactively using cursors, like on the first axis on the figure. Several selections can be defined at the same time, each selection having its own color. Selections are set of ranges which can be defined interactively. Several selections can been defined. Each cluster is now clearly visible and the zone with crossing clusters is now understandable whereas, without any selection or with only a single one, it was not easy to und",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:614561,clear,clear,614561,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['clear'],['clear']
Usability,"duplicates and with the ability; to truncate the list by printEvalErrors. This is the standard mode of error logging; during MINUIT operations. If enableEvalErrorLogging() is false, all errors; reported through this method are passed for immediate printing through RooMsgService.; A string with server names and values is constructed automatically for error logging; purposes, unless a custom string with similar information is passed as argument. void clearEvalErrorLog(); Clear the stack of evaluation error messages. void printEvalErrors(ostream& os = std::cout, Int_t maxPerNode = 10000000); Print all outstanding logged evaluation error on the given ostream. If maxPerNode; is zero, only the number of errors for each source (object with unique name) is listed.; If maxPerNode is greater than zero, up to maxPerNode detailed error messages are shown; per source of errors. A truncation message is shown if there were more errors logged; than shown. Int_t numEvalErrors(); Return the number of logged evaluation errors since the last clearing. void fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); Fix the interpretation of the coefficient of any RooAddPdf component in; the expression tree headed by this object to the given set of observables. If the force flag is false, the normalization choice is only fixed for those; RooAddPdf components that have the default 'automatic' interpretation of; coefficients (i.e. the interpretation is defined by the observables passed; to getVal()). If force is true, also RooAddPdf that already have a fixed; interpretation are changed to a new fixed interpretation. void fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); Fix the interpretation of the coefficient of any RooAddPdf component in; the expression tree headed by this object to the given set of observables. If the force flag is false, the normalization range choice is only fixed for those; RooAddPdf components that currently use the de",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsReal.html:63138,clear,clearing,63138,root/html526/RooAbsReal.html,https://root.cern,https://root.cern/root/html526/RooAbsReal.html,10,['clear'],['clearing']
Usability,"d selectNormalization (const RooArgSet *depSet=nullptr, bool force=false);  Interface function to force use of a given set of observables to interpret function value. ;  ; void setTreeBranchStatus (TTree &t, bool active) override;  (De)Activate associated tree branch ;  ; void syncCache (const RooArgSet *set=nullptr) override;  ; double traceEval (const RooArgSet *set) const;  Calculate current value of object, with error tracing wrapper. ;  ;  Protected Member Functions inherited from RooAbsArg; void attachToStore (RooAbsDataStore &store);  Attach this argument to the data store such that it reads data from there. ;  ; TString cleanBranchName () const;  Construct a mangled name from the actual name that is free of any math symbols that might be interpreted by TTree. ;  ; void clearShapeDirty () const;  ; void clearValueAndShapeDirty () const;  ; void clearValueDirty () const;  ; virtual void getObservablesHook (const RooArgSet *, RooArgSet *) const;  ; void graphVizAddConnections (std::set< std::pair< RooAbsArg *, RooAbsArg * > > &);  Utility function that inserts all point-to-point client-server connections between any two RooAbsArgs in the expression tree headed by this object in the linkSet argument. ;  ; bool inhibitDirty () const;  Delete watch flag. ;  ; virtual void ioStreamerPass2 ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ; virtual void operModeHook ();  ; virtual void optimizeDirtyHook (const RooArgSet *);  ; void printAttribList (std::ostream &os) const;  Transient boolean attributes (not copied in ctor) ;  ; void registerProxy (RooArgProxy &proxy);  Register an RooArgProxy in the proxy list. ;  ; void registerProxy (RooListProxy &proxy);  Register an RooListProxy in the proxy list. ;  ; void registerProxy (RooSetProxy &proxy);  Register an RooSetProxy in the proxy list. ;  ; void setProxyNormSet (const RooArgSet *nset);  Forward a change in the cached normalization",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProdPdf.html:74523,clear,clearShapeDirty,74523,doc/master/classRooProdPdf.html,https://root.cern,https://root.cern/doc/master/classRooProdPdf.html,3,['clear'],"['clearShapeDirty', 'clearValueAndShapeDirty', 'clearValueDirty']"
Usability,"e & ; ). privatedelete . ◆ TGUndockedFrame() [2/2]. TGUndockedFrame::TGUndockedFrame ; (; const TGWindow * ; p = nullptr, . TGDockableFrame * ; dockable = nullptr . ). Create the undocked (transient) frame. ; Definition at line 176 of file TGDockableFrame.cxx. ◆ ~TGUndockedFrame(). TGUndockedFrame::~TGUndockedFrame ; (; ). override . Delete undocked frame. Puts back dockable frame in its original container. ; Definition at line 193 of file TGDockableFrame.cxx. Member Function Documentation. ◆ Class(). static TClass * TGUndockedFrame::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGUndockedFrame::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGUndockedFrame::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 78 of file TGDockableFrame.h. ◆ CloseWindow(). void TGUndockedFrame::CloseWindow ; (; ). overridevirtual . Close undocked frame (called via WM close button). ; Reimplemented from TGMainFrame.; Definition at line 213 of file TGDockableFrame.cxx. ◆ DeclFileName(). static const char * TGUndockedFrame::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 78 of file TGDockableFrame.h. ◆ FixSize(). void TGUndockedFrame::FixSize ; (; ). Fix the size of the undocked frame so it cannot be changed via the WM. ; Definition at line 203 of file TGDockableFrame.cxx. ◆ IsA(). TClass * TGUndockedFrame::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGTransientFrame.; Definition at line 78 of file TGDockableFrame.h. ◆ operator=(). TGUndockedFrame & TGUndockedFrame::operator= ; (; const TGUndockedFrame & ; ). privatedelete . ◆ Streamer(). void TGUndockedFrame::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TGTransientFrame. ◆ StreamerNVirtual(). void TGUndoc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGUndockedFrame.html:37491,undo,undocked,37491,doc/master/classTGUndockedFrame.html,https://root.cern,https://root.cern/doc/master/classTGUndockedFrame.html,1,['undo'],['undocked']
Usability,"e 'optStr' can contain a comma-separated list of servers for which the information is wanted. If ':lite:' (case insensitive) is specified in 'optStr' only the global information in the TFileCollection is retrieved; useful to only get the list of available datasets. ; Reimplemented in TProofLite.; Definition at line 10809 of file TProof.cxx. ◆ GetDataSetSrvMaps(). static TList * TProof::GetDataSetSrvMaps ; (; const TString & ; srvmaps). staticprivate . ◆ GetEnabledPackages(). TList * TProof::GetEnabledPackages ; (; ); const. inlineprotected . Definition at line 735 of file TProof.h. ◆ Getenv(). TString TProof::Getenv ; (; const char * ; env, . const char * ; ord = ""0"" . ). Get value of environment variable 'env' on node 'ord'. ; Definition at line 6644 of file TProof.cxx. ◆ GetEnvVars(). const TList * TProof::GetEnvVars ; (; ). static . Get environemnt variables. ; Definition at line 11751 of file TProof.cxx. ◆ GetFeedbackList(). TList * TProof::GetFeedbackList ; (; ); const. Return feedback list. ; Definition at line 10033 of file TProof.cxx. ◆ GetFileInCmd(). Bool_t TProof::GetFileInCmd ; (; const char * ; cmd, . TString & ; fn . ). staticprotected . Static method to extract the filename (if any) form a CINT command. ; Returns kTRUE and the filename in 'fn'; returns kFALSE if not found or not appliable. ; Definition at line 6495 of file TProof.cxx. ◆ GetGroup(). const char * TProof::GetGroup ; (; ); const. inline . Definition at line 907 of file TProof.h. ◆ GetImage(). const char * TProof::GetImage ; (; ); const. inline . Definition at line 910 of file TProof.h. ◆ GetInputData(). Int_t TProof::GetInputData ; (; TList * ; input, . const char * ; cachedir, . TString & ; emsg . ). staticprotected . Get the input data from the file defined in the input list. ; Definition at line 12413 of file TProof.cxx. ◆ GetInputList(). TList * TProof::GetInputList ; (; ). Get input list. ; Definition at line 9753 of file TProof.cxx. ◆ GetLastLog(). TMacro * TProof::GetLastLog ; (; )",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:94682,feedback,feedback,94682,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['feedback'],['feedback']
Usability,"e () const;  Returns the name of undo command. ;  ; TClass * IsA () const override;  ; Bool_t IsEqual (const TObject *obj) const override;  Equal comparison. ;  ; Bool_t IsExecuting () const;  Returns kTRUE if command execution is in progress. ;  ; Bool_t IsMacro () const;  Returns kTRUE if neither redo nor undo action specified. ;  ; Bool_t IsRedoing () const;  Redo action is in progress. ;  ; virtual Bool_t IsSetter () const;  Returns kTRUE is command if Redo is the same as Undo function and is the setter action. ;  ; Bool_t IsUndoing () const;  Undo action is in progress. ;  ; void ls (Option_t *option="""") const override;  ls this command and merged commands ;  ; virtual Long64_t Merge (TCollection *, TFileMergeInfo *);  Merge a collection of TQCommand. ;  ; virtual void Merge (TQCommand *c);  Add command to the list of merged commands. ;  ; virtual void Redo (Option_t *option="""");  Execute command and then merge commands. ;  ; virtual void SetArgs (Int_t nargs,...);  Set do/redo and undo parameters. ;  ; virtual void SetName (const char *name);  Sets name of the command. ;  ; virtual void SetRedoArgs (Int_t nargs,...);  Set redo parameters. ;  ; virtual void SetTitle (const char *title);  Sets description of the command. ;  ; virtual void SetUndoArgs (Int_t nargs,...);  Set undo parameters. ;  ; void Streamer (TBuffer &) override;  Stream all objects in the collection to or from the I/O buffer. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void Undo (Option_t *option="""");  Un-execute all merged commands and the command. ;  ;  Public Member Functions inherited from TList;  TList ();  ; The argument is ignored Use the default constructor TList ()."") ;  ;  TList (TObject *) R__DEPRECATED(6;  ; virtual ~TList ();  Delete the list. ;  ; void AddAfter (const TObject *after, TObject *obj) override;  Insert object after object after in the list. ;  ; virtual void AddAfter (TObjLink *after, TObject *obj);  Insert object after the specified",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:7617,undo,undo,7617,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['undo'],['undo']
Usability,"e (Option_t *opt) const;  ; virtual void printExtras (std::ostream &os) const;  Interface to print extras of object. ;  ; virtual void printStream (std::ostream &os, Int_t contents, StyleOption style, TString indent="""") const;  Print description of object on ostream, printing contents set by contents integer, which is interpreted as an OR of 'enum ContentsOptions' values and in the style given by 'enum StyleOption'. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::unique_ptr< RooRatio > makeRatio (const char *name, const char *title, RooArgList &nr, RooArgList &dr);  Return the RooRatio form of products and denominators of morphing functions. ;  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooLagrangianMorphFunc.html:56012,clear,clearEvalErrorLog,56012,doc/master/classRooLagrangianMorphFunc.html,https://root.cern,https://root.cern/doc/master/classRooLagrangianMorphFunc.html,1,['clear'],['clearEvalErrorLog']
Usability,"e - responds dynamically and presents the user interface according to the selected object in the canvas. 2.3.1 Main Menus and Toolbar; At the top of the canvas window are File, Edit, View, Options, Inspect, Classes and Help menus.; 2.3.1.1 File Menu. New Canvas: creates a new canvas window in the current ROOT session.; Open…: popup a dialog to open a file.; Close Canvas: close the canvas window.; Save: save the drawing of the current canvas in a format selectable from the submenu. The current canvas name is used as a file name for various formats such as PostScript, GIF, JPEG, C macro file, root file.; Save As…: popup a dialog for saving the current canvas drawing in a new filename.; Print: popup a dialog to print the current canvas drawing; Quit ROOT: exit the ROOT session. 2.3.1.2 Edit Menu; There is only one active menu entry in the Edit menu. The others menu entries will be implemented and will become active in the near future. Clear: delete all objects in the canvas or in the selected pad according to the selected entry in the submenu. 2.3.1.3 View Menu. Editor: toggles the view of the editor. If it is selected activates and shows up the editor on the left side of the canvas window. According to the selected object, the editor loads the corresponding user interface for easy change of the object’s attributes.; Toolbar: toggles the view of the toolbar. If it is selected activates and shows up the toolbar. It contains buttons for easy and fast access to most frequently used commands and for graphics primitive drawing. Tool tips are provided for helping users.; Status Bar: toggles the view of the status bar. If it is selected, the status bar below the canvas window shows up. There the identification of the objects is displayed when moving the mouse (such as the object’s name, the object’s type, its coordinates, etc.).; Colors: creates a new canvas showing the color palette.; Markers: creates a new canvas showing the various marker styles.; Iconify: create the canvas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:37956,Clear,Clear,37956,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Clear'],['Clear']
Usability,"e . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Development Run the tests. Running the ROOT battery of tests; Running all ROOT tests on at least a platform before sending a PR or before pushing anything to the ROOT repository is mandatory.; The ROOT continuous integration infrastructure allows to automatically check the PR also on a battery of platform, for example including macos and linux boxes.; In order to be able to run all tests, the simple steps below need to be followed; Prepare your development area and build ROOT; mkdir RootDevelopment; cd RootDevelopment; git clone https://github.com/root-project/root; git clone https://github.com/root-project/roottest; mkdir build; cd build; echo Note the cmake options; cmake -DCMAKE_BUILD_TYPE=Debug -Dtesting=ON -Droottest=ON ../root. Inspect and run the tests; From within the build directory. List all tests: ctest -N; List all test matching a regex: ctest -N -R myregex; Run all tests on N cores: ctest -j N. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/run-tests.html:2246,simpl,simple,2246,d/run-tests.html,https://root.cern,https://root.cern/d/run-tests.html,1,['simpl'],['simple']
Usability,"e . Find best visual, i.e. ; the one with the most planes and TrueColor or DirectColor. Sets fVisual, fDepth, fRootWin, fColormap, fBlackPixel and fWhitePixel. ; Definition at line 780 of file TGX11.cxx. ◆ FindColor(). Int_t TGX11::FindColor ; (; ULong_t ; pixel, . ULong_t * ; orgcolors, . Int_t ; ncolors . ). private . Returns index in orgcolors (and fNewColors) for pixel. ; Definition at line 3019 of file TGX11.cxx. ◆ FindRWindow(). Window_t TGX11::FindRWindow ; (; Window_t ; win, . Window_t ; dragwin, . Window_t ; input, . int ; x, . int ; y, . int ; maxd . ). overridevirtual . Recursively search in the children of Window for a Window which is at location x, y and is DND aware, with a maximum depth of maxd. ; Possibility to exclude dragwin and input. ; Reimplemented from TVirtualX.; Definition at line 2802 of file GX11Gui.cxx. ◆ FindUsableVisual(). void TGX11::FindUsableVisual ; (; RXVisualInfo * ; vlist, . Int_t ; nitems . ). private . Check if visual is usable, if so set fVisual, fDepth, fColormap, fBlackPixel and fWhitePixel. ; Definition at line 848 of file TGX11.cxx. ◆ FreeColor(). void TGX11::FreeColor ; (; Colormap_t ; cmap, . ULong_t ; pixel . ). overridevirtual . Free color cell with specified pixel value. ; Reimplemented from TVirtualX.; Definition at line 1391 of file GX11Gui.cxx. ◆ FreeFontNames(). void TGX11::FreeFontNames ; (; char ** ; fontlist). overridevirtual . Free list of font names. ; Reimplemented from TVirtualX.; Definition at line 2605 of file GX11Gui.cxx. ◆ FreeFontStruct(). void TGX11::FreeFontStruct ; (; FontStruct_t ; fs). overridevirtual . Free font structure returned by GetFontStruct(). ; Reimplemented from TVirtualX.; Definition at line 2123 of file GX11Gui.cxx. ◆ GetCharacterUp(). void TGX11::GetCharacterUp ; (; Float_t & ; chupx, . Float_t & ; chupy . ). overridevirtual . Return character up vector. ; Reimplemented from TVirtualX.; Definition at line 899 of file TGX11.cxx. ◆ GetColor(). XColor_t & TGX11::GetColor ; (; Int_t ; cid)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGX11.html:74633,usab,usable,74633,doc/master/classTGX11.html,https://root.cern,https://root.cern/doc/master/classTGX11.html,1,['usab'],['usable']
Usability,"e . ◆ Randomize(). void TMultiLayerPerceptron::Randomize ; (; ); const. Randomize the weights. ; Definition at line 1239 of file TMultiLayerPerceptron.cxx. ◆ Result(). Double_t TMultiLayerPerceptron::Result ; (; Int_t ; event, . Int_t ; index = 0 . ); const. Computes the output for a given event. ; Look at the output neuron designed by index. ; Definition at line 1033 of file TMultiLayerPerceptron.cxx. ◆ SetData(). void TMultiLayerPerceptron::SetData ; (; TTree * ; data). Set the data source. ; Definition at line 590 of file TMultiLayerPerceptron.cxx. ◆ SetDelta(). void TMultiLayerPerceptron::SetDelta ; (; Double_t ; delta). Sets Delta - used in stochastic minimisation (look at the constructor for the complete description of learning methods and parameters) ; Definition at line 720 of file TMultiLayerPerceptron.cxx. ◆ SetEpsilon(). void TMultiLayerPerceptron::SetEpsilon ; (; Double_t ; eps). Sets Epsilon - used in stochastic minimisation (look at the constructor for the complete description of learning methods and parameters) ; Definition at line 710 of file TMultiLayerPerceptron.cxx. ◆ SetEta(). void TMultiLayerPerceptron::SetEta ; (; Double_t ; eta). Sets Eta - used in stochastic minimisation (look at the constructor for the complete description of learning methods and parameters) ; Definition at line 700 of file TMultiLayerPerceptron.cxx. ◆ SetEtaDecay(). void TMultiLayerPerceptron::SetEtaDecay ; (; Double_t ; ed). Sets EtaDecay - Eta *= EtaDecay at each epoch (look at the constructor for the complete description of learning methods and parameters) ; Definition at line 730 of file TMultiLayerPerceptron.cxx. ◆ SetEventWeight(). void TMultiLayerPerceptron::SetEventWeight ; (; const char * ; branch). Set the event weight. ; Definition at line 606 of file TMultiLayerPerceptron.cxx. ◆ SetGammaDelta(). void TMultiLayerPerceptron::SetGammaDelta ; (; TMatrixD & ; gamma, . TMatrixD & ; delta, . Double_t * ; buffer . ). protected . Sets the gamma \((g_{(t+1)}-g_{(t)})\) and",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiLayerPerceptron.html:44963,learn,learning,44963,doc/master/classTMultiLayerPerceptron.html,https://root.cern,https://root.cern/doc/master/classTMultiLayerPerceptron.html,1,['learn'],['learning']
Usability,"e : Separation; : -------------------------------; : 1 : m_bb : 9.511e-02; : 2 : m_wbb : 4.268e-02; : 3 : m_wwbb : 4.178e-02; : 4 : m_jjj : 2.825e-02; : 5 : m_jlv : 1.999e-02; : 6 : m_jj : 3.834e-03; : 7 : m_lv : 3.699e-03; : -------------------------------; Factory : Train method: Likelihood for Classification; : ; : ; : ␛[1m================================================================␛[0m; : ␛[1mH e l p f o r M V A m e t h o d [ Likelihood ] :␛[0m; : ; : ␛[1m--- Short description:␛[0m; : ; : The maximum-likelihood classifier models the data with probability ; : density functions (PDF) reproducing the signal and background; : distributions of the input variables. Correlations among the ; : variables are ignored.; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : Required for good performance are decorrelated input variables; : (PCA transformation via the option ""VarTransform=Decorrelate""; : may be tried). Irreducible non-linear correlations may be reduced; : by precombining strongly correlated input variables, or by simply; : removing one of the variables.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : High fidelity PDF estimates are mandatory, i.e., sufficient training ; : statistics is required to populate the tails of the distributions; : It would be a surprise if the default Spline or KDE kernel parameters; : provide a satisfying fit to the data. The user is advised to properly; : tune the events per bin and smooth options in the spline cases; : individually per variable. If the KDE kernel is used, the adaptive; : Gaussian kernel may lead to artefacts, so please always also try; : the non-adaptive one.; : ; : All tuning parameters must be adjusted individually for each input; : variable!; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; : Filling reference histograms; : Building PDF out of reference histograms; : Elapsed time for t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html:16976,simpl,simply,16976,doc/master/TMVA__Higgs__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html,2,['simpl'],['simply']
Usability,"e = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TGeoPatternFinder&operator=(const TGeoPatternFinder&). Data Members; public:. enum EGeoPatternFlags { kPatternReflected; kPatternSpacedOut; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tfDivIndexindex of first div. node; Double_tfEndending point; Int_tfNdivisionsnumber of divisions; Double_tfStartstarting point on divided axis; Double_tfStepdivision step length; vector<ThreadData_t*>fThreadData! Vector of thread private transient data; Int_tfThreadSize! Size of the thread vector; TGeoVolume*fVolumevolume to which applies. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ClearThreadData() const. TGeoPatternFinder& operator=(const TGeoPatternFinder& ); assignment operator. ~TGeoPatternFinder(); Destructor. Int_t GetCurrent(); Return current index. TGeoMatrix* GetMatrix(); Return current matrix. Int_t GetNext() const; Get index of next division. void SetNext(Int_t index); Set index of next division. TGeoNode * CdNext(); Make next node (if any) current. void SetRange(Double_t start, Double_t step, Int_t ndivisions); Set division range. Use this method only when dividing an assembly. ThreadData_t& GetThreadData() const. TGeoMatrix* CreateMatrix() const; methods. void cd(Int_t ); {}. TGeoNode * FindNode(Double_t* , const Double_t* = 0); {return 0;}. Int_t GetByteCount() const; {return 36;}. Int_t GetDivIndex(); {return fDivIndex;}. Int_t GetDivAxis(); {return 1;}. Int_t GetNdiv() const; {return fNdivisions;}. TGeoNode * GetNodeOffset(Int_t idiv); {return fVolume->GetNode(fDivIndex+idiv);}. Double_t GetStart() const; {return fStart;}. Double_t GetStep() c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoPatternFinder.html:7640,Clear,ClearThreadData,7640,root/html532/TGeoPatternFinder.html,https://root.cern,https://root.cern/root/html532/TGeoPatternFinder.html,1,['Clear'],['ClearThreadData']
Usability,"e = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TGeoPatternFinder&operator=(const TGeoPatternFinder&). Data Members; public:. enum EGeoPatternFlags { kPatternReflected; kPatternSpacedOut; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tfDivIndexindex of first div. node; Double_tfEndending point; Int_tfNdivisionsnumber of divisions; Double_tfStartstarting point on divided axis; Double_tfStepdivision step length; vector<ThreadData_t*>fThreadData! Vector of thread private transient data; Int_tfThreadSize! Size of the thread vector; TGeoVolume*fVolumevolume to which applies. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ClearThreadData() const. void CreateThreadData(Int_t nthreads); Create thread data for n threads max. TGeoPatternFinder& operator=(const TGeoPatternFinder& ); assignment operator. ~TGeoPatternFinder(); Destructor. Int_t GetCurrent(); Return current index. TGeoMatrix* GetMatrix(); Return current matrix. Int_t GetNext() const; Get index of next division. void SetNext(Int_t index); Set index of next division. TGeoNode * CdNext(); Make next node (if any) current. void SetRange(Double_t start, Double_t step, Int_t ndivisions); Set division range. Use this method only when dividing an assembly. ThreadData_t& GetThreadData() const. TGeoMatrix* CreateMatrix() const; methods. void cd(Int_t ); {}. TGeoNode * FindNode(Double_t* , const Double_t* = 0); {return 0;}. Int_t GetByteCount() const; {return 36;}. Int_t GetDivIndex(); {return fDivIndex;}. Int_t GetDivAxis(); {return 1;}. Int_t GetNdiv() const; {return fNdivisions;}. TGeoNode * GetNodeOffset(Int_t idiv); {return fVolume->GetNode(fDivInd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoPatternFinder.html:7697,Clear,ClearThreadData,7697,root/html534/TGeoPatternFinder.html,https://root.cern,https://root.cern/root/html534/TGeoPatternFinder.html,1,['Clear'],['ClearThreadData']
Usability,"e = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual Bool_tTFormula::CheckOperands(Int_t operation, Int_t& err); virtual Bool_tTFormula::CheckOperands(Int_t leftoperand, Int_t rightoperartion, Int_t& err); voidTFormula::ClearFormula(Option_t* option = """"); virtual voidTFormula::Convert(UInt_t fromVersion); voidTF1::CreateFromFunctor(const char* name, Int_t npar); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Double_tTFormula::EvalParFast(const Double_t* x, const Double_t* params); Double_tTFormula::EvalPrimitive(const Double_t* x, const Double_t* params); Double_tTFormula::EvalPrimitive0(const Double_t* x, const Double_t* params); Double_tTFormula::EvalPrimitive1(const Double_t* x, const Double_t* params); Double_tTFormula::EvalPrimitive2(const Double_t* x, const Double_t* params); Double_tTFormula::EvalPrimitive3(const Double_t* x, const Double_t* params); Double_tTFormula::EvalPrimitive4(const Double_t* x, const Double_t* params); Short_tTFormula::GetAction(Int_t code) const; Short_tTFormula::GetActionOptimized(Int_t code) const; Int_tTFormula::GetActionParam(Int_t code) const; Int_tTFormula::GetActionParamOptimized(Int_t code) const; virtual Double_tTF1::GetMinMaxNDim(Double_t* x, Bool_t findmax, Double_t epsilon = 0, Int_t maxiter = 0) const; Int_t*TFormula::GetOper() const; Int_t*TFormula::GetOperOptimized() const; virtual voidTF1::GetRange(Double_t* xmin, Double_t* xmax) const; virtual Bool_tTFormula::IsString(Int_t oper) const; voidTFormula::MakePrimitive(const char* expr, Int_t pos); voidTObject::MakeZombie(); Int_tTFormula::PreCompile(); voidTFormula::SetAction(Int_t code, Int_t value, Int_t param = 0); voidTFormula::SetActionOptimized(Int_t code, Int_t value, Int_t param = 0); virtual Bool_tTFormula::StringToNumber(Int_t code). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDel",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TF12.html:16065,Clear,ClearFormula,16065,root/html602/TF12.html,https://root.cern,https://root.cern/root/html602/TF12.html,1,['Clear'],['ClearFormula']
Usability,"e = 0, Bool_t useAxisBinning = kTRUE); TH1*GetDeltaSysTau(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTUnfold::GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; TH2*GetEmatrixInput(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); voidTUnfoldSys::GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); TH2*GetEmatrixSysBackgroundUncorr(const char* bgrSource, const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); voidTUnfoldSys::GetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidTUnfoldSys::GetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); TH2*GetEmatrixSysUncorr(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); TH2*GetEmatrixTotal(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); Double_tTUnfold::GetEpsMatrix() const; TH1*GetFoldedOutput(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE, Bool_t addBgr = kFALSE) const; virtual const char*TObject::GetIconName() const; TH1*GetInput(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE) const; const TUnfoldBinning*GetInputBinning(const char* distribu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnfoldDensity.html:8680,clear,clearEmat,8680,root/html534/TUnfoldDensity.html,https://root.cern,https://root.cern/root/html534/TUnfoldDensity.html,6,['clear'],['clearEmat']
Usability,"e ASCII data file. ;  ; template Long64_t FillNtupleFromStream< Double_t, TNtupleD > (std::istream &, TNtupleD &, char, bool);  ; template Long64_t FillNtupleFromStream< Float_t, TNtuple > (std::istream &, TNtuple &, char, bool);  ; bool NextCharacterIsEOL (std::istream &input);  Either '\r' | '\n' or eof of some problem. ;  ; void SkipComment (std::istream &input);  Skips everything from '#' to (including) '\r' or '\n'. ;  ; void SkipEmptyLines (std::istream &input);  Skips empty lines (newline-characters), ws-lines (consisting only of whitespace characters + newline-characters). ;  ; void SkipWSCharacters (std::istream &input);  Skip whitespace characters, but not newline-characters we support ('\r' or '\n'). ;  . Function Documentation. ◆ FillNtupleFromStream(). template<class DataType , class Tuple > . Long64_t ROOT::TreeUtils::FillNtupleFromStream ; (; std::istream & ; inputStream, . Tuple & ; tuple, . char ; delimiter, . bool ; strictMode . ). Function to fill tuples (TNtuple/TNtupleD) from a simple ASCII data file. ; With auto and decltype - we can get rid of DataType parameter :) (or with a simple typedef inside ntuple class). An input file consists of non-empty lines (separated by newline-characters), possibly empty lines, and comments (treated as empty lines). Each non-empty line should contain N numbers - entry for a tuple. Non-strict mode lets you to have newline-characters inside a tuple's row (as it worked in ROOT prior to v5.3xxx). ; Definition at line 80 of file TreeUtils.cxx. ◆ FillNtupleFromStream< Double_t, TNtupleD >(). template Long64_t ROOT::TreeUtils::FillNtupleFromStream< Double_t, TNtupleD > ; (; std::istream & ; , . TNtupleD & ; , . char ; , . bool ;  . ). ◆ FillNtupleFromStream< Float_t, TNtuple >(). template Long64_t ROOT::TreeUtils::FillNtupleFromStream< Float_t, TNtuple > ; (; std::istream & ; , . TNtuple & ; , . char ; , . bool ;  . ). ◆ NextCharacterIsEOL(). bool ROOT::TreeUtils::NextCharacterIsEOL ; (; std::istream & ; input). Either",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1TreeUtils.html:1636,simpl,simple,1636,doc/master/namespaceROOT_1_1TreeUtils.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1TreeUtils.html,2,['simpl'],['simple']
Usability,"e Binary search tree including a volume search method. ; Definition at line 65 of file BinarySearchTree.h. Public Member Functions;  BinarySearchTree (const BinarySearchTree &b);  copy constructor that creates a true copy, i.e. a completely independent tree ;  ;  BinarySearchTree (void);  default constructor ;  ; virtual ~BinarySearchTree (void);  destructor ;  ; void CalcStatistics (TMVA::Node *n=nullptr);  calculate basic statistics (mean, rms for each variable) ;  ; virtual const char * ClassName () const;  ; void Clear (TMVA::Node *n=nullptr);  clear nodes ;  ; virtual Node * CreateNode (UInt_t) const;  ; virtual BinaryTree * CreateTree () const;  ; Double_t Fill (const std::vector< TMVA::Event * > &events, const std::vector< Int_t > &theVars, Int_t theType=-1);  create the search tree from the event collection using ONLY the variables specified in ""theVars"" ;  ; Double_t Fill (const std::vector< TMVA::Event * > &events, Int_t theType=-1);  create the search tree from the events in a TTree using ALL the variables specified included in the Event ;  ; UInt_t GetPeriode (void) const;  ; Double_t GetSumOfWeights (Int_t theType) const;  return the sum of event (node) weights ;  ; Double_t GetSumOfWeights (void) const;  return the sum of event (node) weights ;  ; void Insert (const Event *);  insert a new ""event"" in the binary tree ;  ; virtual TClass * IsA () const;  ; Float_t Max (Types::ESBType sb, UInt_t var);  access to Maximum for signal and background for each variable ;  ; Float_t Mean (Types::ESBType sb, UInt_t var);  access to mean for signal and background for each variable ;  ; Float_t Min (Types::ESBType sb, UInt_t var);  access to Minimum for signal and background for each variable ;  ; void NormalizeTree ();  Normalisation of tree. ;  ; Float_t RMS (Types::ESBType sb, UInt_t var);  access to RMS for signal and background for each variable ;  ; Float_t RMS (UInt_t var);  access to RMS for each variable ;  ; BinarySearchTreeNode * Search (Event *event) con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1BinarySearchTree.html:893,clear,clear,893,doc/master/classTMVA_1_1BinarySearchTree.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1BinarySearchTree.html,1,['clear'],['clear']
Usability,"e Graph Example . i 0 0.000000 1.986693 ; i 1 0.100000 2.955202 ; i 2 0.200000 3.894183 ; i 3 0.300000 4.794255 ; i 4 0.400000 5.646425 ; i 5 0.500000 6.442177 ; i 6 0.600000 7.173561 ; i 7 0.700000 7.833269 ; i 8 0.800000 8.414710 ; i 9 0.900000 8.912074 ; i 10 1.000000 9.320391 ; i 11 1.100000 9.635582 ; i 12 1.200000 9.854497 ; i 13 1.300000 9.974950 ; i 14 1.400000 9.995736 ; i 15 1.500000 9.916648 ; i 16 1.600000 9.738476 ; i 17 1.700000 9.463001 ; i 18 1.800000 9.092974 ; i 19 1.900000 8.632094 ; ; from __future__ import print_function; from ROOT import TCanvas, TGraph; from ROOT import gROOT; from math import sin; from array import array; ; ; c1 = TCanvas( 'c1', 'A Simple Graph Example', 200, 10, 700, 500 ); ; c1.SetFillColor( 42 ); c1.SetGrid(); ; n = 20; x, y = array( 'd' ), array( 'd' ); ; for i in range( n ):; x.append( 0.1*i ); y.append( 10*sin( x[i]+0.2 ) ); print(' i %i %f %f ' % (i,x[i],y[i])); ; gr = TGraph( n, x, y ); gr.SetLineColor( 2 ); gr.SetLineWidth( 4 ); gr.SetMarkerColor( 4 ); gr.SetMarkerStyle( 21 ); gr.SetTitle( 'a simple graph' ); gr.GetXaxis().SetTitle( 'X title' ); gr.GetYaxis().SetTitle( 'Y title' ); gr.Draw( 'ACP' ); ; # TCanvas.Update() draws the frame, after which one can change it; c1.Update(); c1.GetFrame().SetFillColor( 21 ); c1.GetFrame().SetBorderSize( 12 ); c1.Modified(); c1.Update(); # If the graph does not appear, try using the ""i"" flag, e.g. ""python3 -i graph.py""; # This will access the interactive mode after executing the script, and thereby persist; # long enough for the graph to appear.; SetFillColorOption_t Option_t SetFillColorDefinition TGWin32VirtualXProxy.cxx:50; TCanvasThe Canvas class.Definition TCanvas.h:23; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; SetBorderSizec SetBorderSize(2); AuthorWim Lavrijsen ; Definition in file graph.py. tutorialspyrootgraph.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/graph_8py.html:1284,simpl,simple,1284,doc/master/graph_8py.html,https://root.cern,https://root.cern/doc/master/graph_8py.html,1,['simpl'],['simple']
Usability,"e RWebWindow.cxx. Friends And Related Symbol Documentation. ◆ RFileDialog. friend class RFileDialog. friend . Definition at line 57 of file RWebWindow.hxx. ◆ RWebDisplayHandle. friend class RWebDisplayHandle. friend . Definition at line 56 of file RWebWindow.hxx. ◆ RWebWindowsManager. friend class RWebWindowsManager. friend . Definition at line 54 of file RWebWindow.hxx. ◆ RWebWindowWSHandler. friend class RWebWindowWSHandler. friend . Definition at line 55 of file RWebWindow.hxx. Member Data Documentation. ◆ fCallbacksThrdId. std::thread::id ROOT::RWebWindow::fCallbacksThrdId. private . ! thread id where callbacks should be invoked ; Definition at line 160 of file RWebWindow.hxx. ◆ fCallbacksThrdIdSet. bool ROOT::RWebWindow::fCallbacksThrdIdSet {false}. private . ! flag indicating that thread id is assigned ; Definition at line 161 of file RWebWindow.hxx. ◆ fClearOnClose. std::shared_ptr<void> ROOT::RWebWindow::fClearOnClose. private . ! entry which is cleared when last connection is closed ; Definition at line 176 of file RWebWindow.hxx. ◆ fClientVersion. std::string ROOT::RWebWindow::fClientVersion. private . ! configured client version, used as prefix in scripts URL ; Definition at line 169 of file RWebWindow.hxx. ◆ fConn. ConnectionsList_t ROOT::RWebWindow::fConn. private . ! list of all accepted connections ; Definition at line 150 of file RWebWindow.hxx. ◆ fConnCallback. WebWindowConnectCallback_t ROOT::RWebWindow::fConnCallback. private . ! callback for connect event ; Definition at line 157 of file RWebWindow.hxx. ◆ fConnCnt. unsigned ROOT::RWebWindow::fConnCnt {0}. private . ! counter of new connections to assign ids ; Definition at line 148 of file RWebWindow.hxx. ◆ fConnLimit. unsigned ROOT::RWebWindow::fConnLimit {1}. private . ! number of allowed active connections ; Definition at line 152 of file RWebWindow.hxx. ◆ fConnMutex. std::mutex ROOT::RWebWindow::fConnMutex. mutableprivate . ! mutex used to protect connection list ; Definition at line 151 of fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:53709,clear,cleared,53709,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,1,['clear'],['cleared']
Usability,"e RWebWindow.cxx. Friends And Related Symbol Documentation. ◆ RFileDialog. friend class RFileDialog. friend . Definition at line 59 of file RWebWindow.hxx. ◆ RWebDisplayHandle. friend class RWebDisplayHandle. friend . Definition at line 58 of file RWebWindow.hxx. ◆ RWebWindowsManager. friend class RWebWindowsManager. friend . Definition at line 56 of file RWebWindow.hxx. ◆ RWebWindowWSHandler. friend class RWebWindowWSHandler. friend . Definition at line 57 of file RWebWindow.hxx. Member Data Documentation. ◆ fCallbacksThrdId. std::thread::id ROOT::RWebWindow::fCallbacksThrdId. private . ! thread id where callbacks should be invoked ; Definition at line 163 of file RWebWindow.hxx. ◆ fCallbacksThrdIdSet. bool ROOT::RWebWindow::fCallbacksThrdIdSet {false}. private . ! flag indicating that thread id is assigned ; Definition at line 164 of file RWebWindow.hxx. ◆ fClearOnClose. std::shared_ptr<void> ROOT::RWebWindow::fClearOnClose. private . ! entry which is cleared when last connection is closed ; Definition at line 179 of file RWebWindow.hxx. ◆ fClientVersion. std::string ROOT::RWebWindow::fClientVersion. private . ! configured client version, used as prefix in scripts URL ; Definition at line 172 of file RWebWindow.hxx. ◆ fConn. ConnectionsList_t ROOT::RWebWindow::fConn. private . ! list of all accepted connections ; Definition at line 153 of file RWebWindow.hxx. ◆ fConnCallback. WebWindowConnectCallback_t ROOT::RWebWindow::fConnCallback. private . ! callback for connect event ; Definition at line 160 of file RWebWindow.hxx. ◆ fConnCnt. unsigned ROOT::RWebWindow::fConnCnt {0}. private . ! counter of new connections to assign ids ; Definition at line 151 of file RWebWindow.hxx. ◆ fConnLimit. unsigned ROOT::RWebWindow::fConnLimit {1}. private . ! number of allowed active connections ; Definition at line 155 of file RWebWindow.hxx. ◆ fConnMutex. std::mutex ROOT::RWebWindow::fConnMutex. mutableprivate . ! mutex used to protect connection list ; Definition at line 154 of fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindow.html:52593,clear,cleared,52593,doc/master/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindow.html,1,['clear'],['cleared']
Usability,"e ReadLeaves implementation to use.; TRefTable*fRefTablepointer to the TRefTable; Bool_tTBranch::fSkipZip! After being read, the buffer will not be unziped.; Int_tTBranch::fSplitLevelBranch split level; TStringTNamed::fTitleobject title; Long64_tTBranch::fTotBytesTotal number of bytes in all leaves before compression; TTree*TBranch::fTree! Pointer to Tree header; Int_tTBranch::fWriteBasketLast basket number written; Long64_tTBranch::fZipBytesTotal number of bytes in all leaves after compression; static Int_tTBranch::fgCount! branch counter; static TBranch::EStatusBitsTBranch::kAutoDelete; static TBranch::EStatusBitsTBranch::kDoNotUseBufferMap. private:. Long64_tfRequestedEntry! Cursor indicating which entry is being requested. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchRef(); Default constructor. TBranchRef(TTree* tree); Main constructor called by TTree::BranchRef. ~TBranchRef(); Typical destructor. void Clear(Option_t* option = """"); Clear entries in the TRefTable. Int_t Fill(); Fill the branch basket with the referenced objects parent numbers. Bool_t Notify(); This function is called by TRefTable::Notify, itself called by; TRef::GetObject.; The function reads the branch containing the object referenced; by the TRef. void Print(Option_t* option = """") const; Print the TRefTable branch. void ReadLeavesImpl(TBuffer& b); This function called by TBranch::GetEntry overloads TBranch::ReadLeaves. void FillLeavesImpl(TBuffer& b); This function called by TBranch::Fill overloads TBranch::FillLeaves. void Reset(Option_t* option = """"); Existing buffers are deleted; Entries, max and min are reset; TRefTable is cleared. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations); TRefTable is cleared. Int_t SetParent(const TObject* obj, Int_t branchID); -- Set the current parent branch. This function is called by TBranchElement::GetEntry(); and TBranchElement::Fill() when r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TBranchRef.html:14775,Clear,Clear,14775,root/html602/TBranchRef.html,https://root.cern,https://root.cern/root/html602/TBranchRef.html,4,['Clear'],['Clear']
Usability,"e TProofPlayer.h. ◆ DeleteDrawFeedback(). void TProofPlayer::DeleteDrawFeedback ; (; TDrawFeedback * ; f). overridevirtual . Delete draw feedback object. ; Implements TVirtualProofPlayer.; Definition at line 750 of file TProofPlayer.cxx. ◆ DrawCanvas(). Int_t TProofPlayer::DrawCanvas ; (; TObject * ; obj). protectedvirtual . Draw the object if it is a canvas. ; Return 0 in case of success, 1 if it is not a canvas or libProofDraw is not available. ; Definition at line 1696 of file TProofPlayer.cxx. ◆ DrawSelect(). Long64_t TProofPlayer::DrawSelect ; (; TDSet * ; set, . const char * ; varexp, . const char * ; selection, . Option_t * ; option = """", . Long64_t ; nentries = -1, . Long64_t ; firstentry = 0 . ). overridevirtual . Draw (may not be used in this class). ; Implements TVirtualProofPlayer.; Reimplemented in TProofPlayerRemote.; Definition at line 1658 of file TProofPlayer.cxx. ◆ Feedback(). void TProofPlayer::Feedback ; (; TList * ; objs). overridevirtual . Set feedback list (may not be used in this class). ; Implements TVirtualProofPlayer.; Reimplemented in TProofPlayerRemote.; Definition at line 724 of file TProofPlayer.cxx. ◆ FeedBackCanvas(). void TProofPlayer::FeedBackCanvas ; (; const char * ; name, . Bool_t ; create . ). Create/destroy a named canvas for feedback. ; Definition at line 1765 of file TProofPlayer.cxx. ◆ Finalize() [1/2]. Long64_t TProofPlayer::Finalize ; (; Bool_t ; force = kFALSE, . Bool_t ; sync = kFALSE . ). overridevirtual . Finalize query (may not be used in this class). ; Implements TVirtualProofPlayer.; Reimplemented in TProofPlayerRemote, and TProofPlayerLite.; Definition at line 1571 of file TProofPlayer.cxx. ◆ Finalize() [2/2]. Long64_t TProofPlayer::Finalize ; (; TQueryResult * ; qr). overridevirtual . Finalize query (may not be used in this class). ; Implements TVirtualProofPlayer.; Reimplemented in TProofPlayerRemote, and TProofPlayerLite.; Definition at line 1580 of file TProofPlayer.cxx. ◆ GetCacheSize(). Long64_t TProofPlayer:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayer.html:28421,feedback,feedback,28421,doc/master/classTProofPlayer.html,https://root.cern,https://root.cern/doc/master/classTProofPlayer.html,1,['feedback'],['feedback']
Usability,"e a form ""(TVirtualPad*,TObject*,Int_t,Int_t)"" root [0] .x $ROOTSYS/tutorials/hsimple.C; root [1] hpx->SetHighlight(kTRUE); root [2] .x hlprint.C; file hlprint.C void PrintInfo(TVirtualPad *pad, TObject *obj, Int_t x, Int_t y); {; auto h = (TH1F *)obj;; if (!h->IsHighlight()) // after highlight disabled; h->SetTitle(""highlight disable"");; else; h->SetTitle(TString::Format(""bin[%03d] (%5.2f) content %g"", x,; h->GetBinCenter(x), h->GetBinContent(x)));; pad->Update();; }; ; void hlprint(); {; if (!gPad) return;; gPad->GetCanvas()->HighlightConnect(""PrintInfo(TVirtualPad*,TObject*,Int_t,Int_t)"");; }; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TVirtualPadTVirtualPad is an abstract base class for the Pad and Canvas classes.Definition TVirtualPad.h:51; TVirtualPad::Updatevirtual void Update()=0. Highlight mode and simple user function; For more complex demo please see for example $ROOTSYS/tutorials/tree/temperature.C file. ; Definition at line 50 of file THistPainter.h. Public Member Functions;  THistPainter ();  Default constructor. ;  ;  ~THistPainter () override;  destructor. ;  ; virtual std::vector< THistRenderingRegion > ComputeRenderingRegions (TAxis *pAxis, Int_t nPixels, bool isLog);  Returns the rendering regions for an axis to use in the COL2 option. ;  ; virtual void DefineColorLevels (Int_t ndivz);  Define the color levels used to paint legos, surfaces etc.. ;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Compute the distance from the point px,py to a line. ;  ; void DrawPanel () override;  Display a panel with all histogram drawing options. ;  ; void ExecuteEvent (Int_t event, Int_t px, Int_t py) override;  Execute the actions corresponding to event. ;  ; TList * GetContourList (Double_t contour) const override;  Get a contour (as a list of TGraphs) using the Delaunay triangulation. ;  ; char * GetObjectInfo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:131866,simpl,simple,131866,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,1,['simpl'],['simple']
Usability,"e a gVirtualX Pixmap. void ClearDrawable(); Clear the current gVirtualX window. void CopyDrawable(Int_t id, Int_t px, Int_t py); Copy a gVirtualX pixmap. void DestroyDrawable(); Close the current gVirtualX pixmap. void SelectDrawable(Int_t device); Select the window in which the graphics will go. void DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Paint a simple line. void DrawLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2); Paint a simple line in normalized coordinates. void DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, TVirtualPadPainter::EBoxMode mode); Paint a simple box. void DrawFillArea(Int_t n, const Double_t* x, const Double_t* y); Paint filled area. void DrawFillArea(Int_t n, const Float_t* x, const Float_t* y); Paint filled area. void DrawPolyLine(Int_t n, const Double_t* x, const Double_t* y); Paint polyline. void DrawPolyLine(Int_t n, const Float_t* x, const Float_t* y); Paint polyline. void DrawPolyLineNDC(Int_t n, const Double_t* u, const Double_t* v); Paint polyline in normalized coordinates. void DrawPolyMarker(Int_t n, const Double_t* x, const Double_t* y); Paint polymarker. void DrawPolyMarker(Int_t n, const Float_t* x, const Float_t* y); Paint polymarker. void DrawText(Double_t x, Double_t y, const char* text, TVirtualPadPainter::ETextMode mode); Paint text. void DrawTextNDC(Double_t u, Double_t v, const char* text, TVirtualPadPainter::ETextMode mode); Paint text in normalized coordinates. void SaveImage(TVirtualPad* pad, const char* fileName, Int_t type) const; Save the image displayed in the canvas pointed by ""pad"" into a; binary file. TPadPainter(); Final overriders for TVirtualPadPainter pure virtual functions.; 1. Part, which simply delegates to TVirtualX.; Line attributes. » Last changed: Mon Jul 4 15:35:39 2011 » Last generated: 2011-07-04 15:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TPadPainter.html:6456,simpl,simply,6456,root/html530/TPadPainter.html,https://root.cern,https://root.cern/root/html530/TPadPainter.html,1,['simpl'],['simply']
Usability,"e a gVirtualX Pixmap. void ClearDrawable(); Clear the current gVirtualX window. void CopyDrawable(Int_t id, Int_t px, Int_t py); Copy a gVirtualX pixmap. void DestroyDrawable(); Close the current gVirtualX pixmap. void SelectDrawable(Int_t device); Select the window in which the graphics will go. void DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Paint a simple line. void DrawLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2); Paint a simple line in normalized coordinates. void DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, TVirtualPadPainter::EBoxMode mode); Paint a simple box. void DrawFillArea(Int_t n, const Double_t* x, const Double_t* y); Paint filled area. void DrawFillArea(Int_t n, const Float_t* x, const Float_t* y); Paint filled area. void DrawPolyLine(Int_t n, const Double_t* x, const Double_t* y); Paint polyline. void DrawPolyLine(Int_t n, const Float_t* x, const Float_t* y); Paint polyline. void DrawPolyLineNDC(Int_t n, const Double_t* u, const Double_t* v); Paint polyline in normalized coordinates. void DrawPolyMarker(Int_t n, const Double_t* x, const Double_t* y); Paint polymarker. void DrawPolyMarker(Int_t n, const Float_t* x, const Float_t* y); Paint polymarker. void DrawText(Double_t x, Double_t y, const char* text, TVirtualPadPainter::ETextMode mode); Paint text. void DrawTextNDC(Double_t u, Double_t v, const char* text, TVirtualPadPainter::ETextMode mode); Paint text in normalized coordinates. void SaveImage(TVirtualPad* pad, const char* fileName, Int_t type) const; Save the image displayed in the canvas pointed by ""pad"" into a; binary file. TPadPainter(); Final overriders for TVirtualPadPainter pure virtual functions.; 1. Part, which simply delegates to TVirtualX.; Line attributes. » Last changed: Thu Nov 3 20:21:02 2011 » Last generated: 2011-11-03 20:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TPadPainter.html:6456,simpl,simply,6456,root/html532/TPadPainter.html,https://root.cern,https://root.cern/root/html532/TPadPainter.html,2,['simpl'],['simply']
Usability,"e a list box and how to set and use its multiple selection feature ;  mditest.CGUI MDI features ;  ntupleTableTest.CThis TableTest class is a simple example of how to use a TGTable with a TTreeTableInterface ;  numberEntry.CThis macro gives an example of how to create a number entry and how to update a label according to the changed value of this number entry ;  QtFileDialog.CThis is a small ROOT macro to use Qt 3.3 class: QFileDialog See: https://doc.qt.io/archives/3.3/qfiledialog.html#getOpenFileName ;  QtMultiFileDialog.CThis is a small ROOT macro to use Qt 3.3 class :QFileDialog See: https://doc.qt.io/archives/3.3/qfiledialog.html#getOpenFileNames ;  QtPrintDialog.CThis is a small ROOT macro to use Qt 3.3 class: QPrinter to setup the printer via Qt ""setup printer dialog"" See: Printer setup dialog box and print out the ROOT TCanvas object either via the ""can"" pointer provided or the current one ;  simpleTableTest.CThis TableTest class is a simple example of how to use a TGSimpleTable that creates and owns it's own TGSimpleTableInterface ;  Slider3Demo.CSimple macro showing capabilities of triple slider ;  splitbuttonTest.CA simple example that shows the usage of a TGSplitButton ;  splitterHorizontal.CThis macro gives an example of how to create a horizontal splitter ;  splitterVertical.CThis macro gives an example of how to create a vertical splitter ;  staffTableTest.CThis TableTest class is a simple example of how to use a TGTable with a TTreeTableInterface ;  statusBar.CThis macro gives an example of how to create a status bar related to an embedded canvas that shows the info of the selected object, exactly as the status bar of any canvas window ;  textEntries.CThis macro gives an example of how to set/change text entry attributes ;  textviewostream.CThis macro gives an example of how to use the TGTextViewostream widget ;  WorldMap.CThis macro shows how to use a TGImageMap class ;  ► hist;  candledecay.C Candle Decay, illustrate a time development of a certain ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/files.html:121265,simpl,simple,121265,doc/v610/files.html,https://root.cern,https://root.cern/doc/v610/files.html,4,['simpl'],['simple']
Usability,"e a list box and how to set and use its multiple selection feature ;  mditest.CGUI MDI features ;  ntupleTableTest.CThis TableTest class is a simple example of how to use a TGTable with a TTreeTableInterface ;  numberEntry.CThis macro gives an example of how to create a number entry and how to update a label according to the changed value of this number entry ;  QtFileDialog.CThis is a small ROOT macro to use Qt 3.3 class: QFileDialog See: https://doc.qt.io/archives/3.3/qfiledialog.html#getOpenFileName ;  QtMultiFileDialog.CThis is a small ROOT macro to use Qt 3.3 class :QFileDialog See: https://doc.qt.io/archives/3.3/qfiledialog.html#getOpenFileNames ;  QtPrintDialog.CThis is a small ROOT macro to use Qt 3.3 class: QPrinter to setup the printer via Qt ""setup printer dialog"" See: Printer setup dialog box and print out the ROOT TCanvas object either via the ""can"" pointer provided or the current one ;  simpleTableTest.CThis TableTest class is a simple example of how to use a TGSimpleTable that creates and owns it's own TGSimpleTableInterface ;  Slider3Demo.CSimple macro showing capabilities of triple slider ;  splitbuttonTest.CA simple example that shows the usage of a TGSplitButton ;  splitterHorizontal.CThis macro gives an example of how to create a horizontal splitter ;  splitterVertical.CThis macro gives an example of how to create a vertical splitter ;  staffTableTest.CThis TableTest class is a simple example of how to use a TGTable with a TTreeTableInterface ;  statusBar.CThis macro gives an example of how to create a status bar related to an embedded canvas that shows the info of the selected object, exactly as the status bar of any canvas window ;  textEntries.CThis macro gives an example of how to set/change text entry attributes ;  textviewostream.CThis macro gives an example of how to use the TGTextViewostream widget ;  WorldMap.CThis macro shows how to use a TGImageMap class ;  ► hist;  candleplot.C Example of candle plot with 2-D histograms ;  candleplotop",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:120498,simpl,simple,120498,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,1,['simpl'],['simple']
Usability,"e address space and can not be used by the; consumer process(es)). Consumer processes can map the memory region; from this file and access the objects stored in it via the Get(); method (which returns a copy of the object stored in the shared; memory with correct vtbl ptr set). Only objects of classes with a; Streamer() member function defined can be shared. I know the current implementation is not ideal (you need to copy to; and from the shared memory file) but the main problem is with the; class' virtual_table pointer. This pointer points to a table unique; for every process. Therefore, different options are:; 1) One could allocate an object directly in shared memory in the; producer, but the consumer still has to copy the object from; shared memory into a local object which has the correct vtbl; pointer for that process (copy ctor's can be used for creating; the local copy).; 2) Another possibility is to only allow objects without virtual; functions in shared memory (like simple C structs), or to; forbid (how?) the consumer from calling any virtual functions; of the objects in shared memory.; 3) A last option is to copy the object internals to shared memory; and copy them again from there. This is what is done in the; TMapFile (using the object Streamer() to make a deep copy).; Option 1) saves one copy, but requires solid copy ctor's (along the; full inheritance chain) to rebuild the object in the consumer. Most; classes don't provide these copy ctor's, especially not when objects; contain collections, etc. 2) is too limiting or dangerous (calling; accidentally a virtual function will segv). So since we have a; robust Streamer mechanism I opted for 3). Function Members (Methods); public:. virtual~TMapFile(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TObject* obj, const char* name = """"); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); Bool_tcd(const char* path = 0); static TClass*Class(); virtual co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMapFile.html:1762,simpl,simple,1762,root/html528/TMapFile.html,https://root.cern,https://root.cern/root/html528/TMapFile.html,10,['simpl'],['simple']
Usability,"e address space and can not be used by the; consumer process(es)). Consumer processes can map the memory region; from this file and access the objects stored in it via the Get(); method (which returns a copy of the object stored in the shared; memory with correct vtbl ptr set). Only objects of classes with a; Streamer() member function defined can be shared. I know the current implementation is not ideal (you need to copy to; and from the shared memory file) but the main problem is with the; class' virtual_table pointer. This pointer points to a table unique; for every process. Therefore, different options are:; 1) One could allocate an object directly in shared memory in the; producer, but the consumer still has to copy the object from; shared memory into a local object which has the correct vtbl; pointer for that process (copy ctor's can be used for creating; the local copy).; 2) Another possibility is to only allow objects without virtual; functions in shared memory (like simple C structs), or to; forbid (how?) the consumer from calling any virtual functions; of the objects in shared memory.; 3) A last option is to copy the object internals to shared memory; and copy them again from there. This is what is done in the; TMapFile (using the object Streamer() to make a deep copy).; Option 1) saves one copy, but requires solid copy ctor's (along the; full inheritance chain) to rebuild the object in the consumer. Most; classes don't provide these copy ctor's, especially not when objects; contain collections, etc. 2) is too limiting or dangerous (calling; accidentally a virtual function will segv). So since we have a; robust Streamer mechanism I opted for 3). Function Members (Methods); public:. ~TMapRec(); void*GetBuffer(Long_t offset = 0) const; Int_tGetBufSize() const; const char*GetClassName(Long_t offset = 0) const; const char*GetName(Long_t offset = 0) const; TMapRec*GetNext(Long_t offset = 0) const; TObject*GetObject() const; TMapRec(const char* name, const TObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMapRec.html:1743,simpl,simple,1743,root/html602/TMapRec.html,https://root.cern,https://root.cern/root/html602/TMapRec.html,4,['simpl'],['simple']
Usability,"e an extra day is added to February to make the year; 366 days long. If the year is the last year of a century, eg. 1700, 1800,; 1900, 2000, then it is only a leap year if it is exactly divisible by; 400. Therefore, 1900 wasn't a leap year but 2000 was. The reason for; these rules is to bring the average length of the calendar year into; line with the length of the Earth's orbit around the Sun, so that the; seasons always occur during the same months each year. Int_t GetZoneOffset(); Static method returning local (current) time zone offset from UTC.; This is the value in seconds one must add to the local time to arrive at; Coordinated Universal Time, so it is negative east of the Prime Meridian. void Add(const TTimeStamp& offset); Add ""offset"" as a delta time. void Print(Option_t* option = """") const; Print date and time. void Set(); Set Date/Time to current time as reported by the system.; No accounting for nanoseconds with std ANSI functions,; ns part faked so that subsequent calls simply add 1 to it; this ensures that calls within the same second come back; distinct (and sortable). Time is since Jan 1, 1970. void Set(Int_t year, Int_t month, Int_t day, Int_t hour, Int_t min, Int_t sec, Int_t nsec, Bool_t isUTC, Int_t secOffset); Set Date/Time from components. Month & day both use normal 1..12 and 1..31 counting,; hours, min, sec run from 0 to 23, 59, 59 respectively,; secOffset provides method for adjusting for alternative timezones. ""year"" | 0 1 ... 37 | 38...69 | 70 .. 100 101 .. 137; true | 2000 2001 2037 | undefined | 1970 2000 2001 .. 2037. ""year"" | 138...1969 | 1970 .. 2037 | ...; true | undefined | 1970 .. 2037 | undefined. void Set(Int_t date, Int_t time, Int_t nsec, Bool_t isUTC, Int_t secOffset); Set date/time from integers of the form [yy]YYMMDD and HHMMSS,; assume UTC (UTC) components:. MM: 01=January .. 12=December; DD: 01 .. 31. HH: 00=midnight .. 23; MM: 00 .. 59; SS: 00 .. 69. Date must be in format 980418 or 19980418; 1001127 or 20001127 (i.e. year",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTimeStamp.html:8468,simpl,simply,8468,root/html528/TTimeStamp.html,https://root.cern,https://root.cern/root/html528/TTimeStamp.html,6,['simpl'],['simply']
Usability,"e and number of steps, the; : evolution of the path is defined by a cut-off parameter, tau.; : This parameter is unknown and depends on the training data.; : A large value will tend to give large weights to a few rules.; : Similarly, a small value will lead to a large set of rules; : with similar weights.; : ; : A final point is the model used; rules and/or linear terms.; : For a given training sample, the result may improve by adding; : linear terms. If best performance is obtained using only linear; : terms, it is very likely that the Fisher discriminant would be; : a better choice. Ideally the fitting procedure should be able to; : make this choice by giving appropriate weights for either terms.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : I. TUNING OF RULE ENSEMBLE:; : ; : ␛[1mForestType ␛[0m: Recommended is to use the default ""AdaBoost"".; : ␛[1mnTrees ␛[0m: More trees leads to more rules but also slow; : performance. With too few trees the risk is; : that the rule ensemble becomes too simple.; : ␛[1mfEventsMin ␛[0m; : ␛[1mfEventsMax ␛[0m: With a lower min, more large trees will be generated; : leading to more complex rules.; : With a higher max, more small trees will be; : generated leading to more simple rules.; : By changing this range, the average complexity; : of the rule ensemble can be controlled.; : ␛[1mRuleMinDist ␛[0m: By increasing the minimum distance between; : rules, fewer and more diverse rules will remain.; : Initially it is a good idea to keep this small; : or zero and let the fitting do the selection of; : rules. In order to reduce the ensemble size,; : the value can then be increased.; : ; : II. TUNING OF THE FITTING:; : ; : ␛[1mGDPathEveFrac ␛[0m: fraction of events in path evaluation; : Increasing this fraction will improve the path; : finding. However, a too high value will give few; : unique events available for error estimation.; : It is recommended to use the default = 0.5.; : ␛[1mGDTau ␛[0m: cutoff parameter ta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:54427,simpl,simple,54427,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['simpl'],['simple']
Usability,"e argument returned by reference is the unique code; defining this particular projection configuration. RooAbsPdf* createProjection(const RooArgSet& iset); Special version of RooAbsReal::createProjection that deals with; projections of projections. Instead of integrating twice, a new; RooProjectedPdf is returned that is configured to perform the; complete integration in one step. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to relegate integration of all observables to internal logic. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Mark all requested variables as internally integrated. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integral represent by appropriate element of projection cache. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; No internal generator is implemented. void generateEvent(Int_t code); No internal generator is implemented. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t , Bool_t , Bool_t ); Intercept a server redirection all and update list of dependents if necessary; Specifically update the set proxy 'deps' which introduces the dependency; on server value dirty flags of ourselves. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. TObject* clone(const char* newname) const; { return new RooProjectedPdf(*this,newname); }. virtual ~RooProjectedPdf(); { }. void initGenerator(Int_t ); {}. Bool_t selfNormalized() const; { return kTRUE ; }. » Last changed: Fri Dec 2 14:26:59 2011 » Last generated: 2011-12-02 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooProjectedPdf.html:44782,intuit,intuitively,44782,root/html532/RooProjectedPdf.html,https://root.cern,https://root.cern/root/html532/RooProjectedPdf.html,2,['intuit'],['intuitively']
Usability,"e argument returned by reference is the unique code; defining this particular projection configuration. RooAbsPdf* createProjection(const RooArgSet& iset); Special version of RooAbsReal::createProjection that deals with; projections of projections. Instead of integrating twice, a new; RooProjectedPdf is returned that is configured to perform the; complete integration in one step. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to relegate integration of all observables to internal logic. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Mark all requested variables as internally integrated. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integral represent by appropriate element of projection cache. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; No internal generator is implemented. void generateEvent(Int_t code); No internal generator is implemented. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t , Bool_t , Bool_t ); Intercept a server redirection all and update list of dependents if necessary; Specifically update the set proxy 'deps' which introduces the dependency; on server value dirty flags of ourselves. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. TObject* clone(const char* newname) const; { return new RooProjectedPdf(*this,newname); }. virtual ~RooProjectedPdf(); { }. void initGenerator(Int_t ); {}. Bool_t selfNormalized() const; { return kTRUE ; }. » Last changed: Mon Dec 7 13:48:46 2009 » Last generated: 2009-12-07 13:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooProjectedPdf.html:42489,intuit,intuitively,42489,root/html526/RooProjectedPdf.html,https://root.cern,https://root.cern/root/html526/RooProjectedPdf.html,1,['intuit'],['intuitively']
Usability,"e argument returned by reference is the unique code; defining this particular projection configuration. RooAbsPdf* createProjection(const RooArgSet& iset); Special version of RooAbsReal::createProjection that deals with; projections of projections. Instead of integrating twice, a new; RooProjectedPdf is returned that is configured to perform the; complete integration in one step. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to relegate integration of all observables to internal logic. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Mark all requested variables as internally integrated. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integral represent by appropriate element of projection cache. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; No internal generator is implemented. void generateEvent(Int_t code); No internal generator is implemented. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t , Bool_t , Bool_t ); Intercept a server redirection all and update list of dependents if necessary; Specifically update the set proxy 'deps' which introduces the dependency; on server value dirty flags of ourselves. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. TObject* clone(const char* newname) const; { return new RooProjectedPdf(*this,newname); }. virtual ~RooProjectedPdf(); { }. void initGenerator(Int_t ); {}. Bool_t selfNormalized() const; { return kTRUE ; }. » Last changed: Mon Jul 4 15:23:45 2011 » Last generated: 2011-07-04 15:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooProjectedPdf.html:43525,intuit,intuitively,43525,root/html530/RooProjectedPdf.html,https://root.cern,https://root.cern/root/html530/RooProjectedPdf.html,1,['intuit'],['intuitively']
Usability,"e argument returned by reference is the unique code; defining this particular projection configuration. RooAbsPdf* createProjection(const RooArgSet& iset); Special version of RooAbsReal::createProjection that deals with; projections of projections. Instead of integrating twice, a new; RooProjectedPdf is returned that is configured to perform the; complete integration in one step. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to relegate integration of all observables to internal logic. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Mark all requested variables as internally integrated. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integral represent by appropriate element of projection cache. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; No internal generator is implemented. void generateEvent(Int_t code); No internal generator is implemented. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t , Bool_t , Bool_t ); Intercept a server redirection all and update list of dependents if necessary; Specifically update the set proxy 'deps' which introduces the dependency; on server value dirty flags of ourselves. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. TObject* clone(const char* newname) const; { return new RooProjectedPdf(*this,newname); }. virtual ~RooProjectedPdf(); { }. void initGenerator(Int_t ); {}. Bool_t selfNormalized() const; { return kTRUE ; }. » Last changed: Sat Oct 9 20:48:34 2010 » Last generated: 2010-10-09 20:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooProjectedPdf.html:42965,intuit,intuitively,42965,root/html528/RooProjectedPdf.html,https://root.cern,https://root.cern/root/html528/RooProjectedPdf.html,1,['intuit'],['intuitively']
Usability,"e argument returned by reference is the unique code; defining this particular projection configuration. RooAbsPdf* createProjection(const RooArgSet& iset); Special version of RooAbsReal::createProjection that deals with; projections of projections. Instead of integrating twice, a new; RooProjectedPdf is returned that is configured to perform the; complete integration in one step. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to relegate integration of all observables to internal logic. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Mark all requested variables as internally integrated. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integral represent by appropriate element of projection cache. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; No internal generator is implemented. void generateEvent(Int_t code); No internal generator is implemented. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t , Bool_t , Bool_t ); Intercept a server redirection all and update list of dependents if necessary; Specifically update the set proxy 'deps' which introduces the dependency; on server value dirty flags of ourselves. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. TObject* clone(const char* newname) const; { return new RooProjectedPdf(*this,newname); }. virtual ~RooProjectedPdf(); { }. void initGenerator(Int_t ); {}. Bool_t selfNormalized() const; { return kTRUE ; }. » Last changed: Tue Jun 2 15:33:10 2015 » Last generated: 2015-06-02 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooProjectedPdf.html:47951,intuit,intuitively,47951,root/html604/RooProjectedPdf.html,https://root.cern,https://root.cern/root/html604/RooProjectedPdf.html,2,['intuit'],['intuitively']
Usability,"e assumed to refer to the default fit range. ;  ; bool forceAnalyticalInt (const RooAbsArg &) const override;  Force RooRealIntegral to offer all observables for internal integration. ;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &numVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Determine which part (if any) of given integral can be performed analytically. ;  ; const RooArgSet & getCoefNormalization () const;  ; const char * getCoefRange () const;  ; TClass * IsA () const override;  ; bool isBinnedDistribution (const RooArgSet &obs) const override;  If all components that depend on obs are binned, so is their sum. ;  ; const RooArgList & pdfList () const;  ; std::list< double > * plotSamplingHint (RooAbsRealLValue &obs, double xlo, double xhi) const override;  Loop over components for plot sampling hints and merge them if there are multiple. ;  ; void printMetaArgs (std::ostream &os) const override;  Customized printing of arguments of a RooAddPdf to more intuitively reflect the contents of the product operator construction. ;  ; void resetErrorCounters (Int_t resetValue=10) override;  Reset error counter to given value, limiting the number of future error messages for this pdf to 'resetValue'. ;  ; bool selfNormalized () const override;  Shows if a PDF is self-normalized, which means that no attempt is made to add a normalization term. ;  ; void setCacheAndTrackHints (RooArgSet &) override;  Label OK'ed components of a RooAddPdf with cache-and-track. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void translate (RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ;  Public Member Functions inherited from RooAbsPdf;  RooAbsPdf ();  Default constructor. ;  ;  RooAbsPdf (const char *na",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAddPdf.html:5816,intuit,intuitively,5816,doc/v632/classRooAddPdf.html,https://root.cern,https://root.cern/doc/v632/classRooAddPdf.html,2,['intuit'],['intuitively']
Usability,"e automatically available upon import of the ROOT module in a Notebook or at startup of a ROOT prompt kernel. We made it easier to use ROOT notebooks locally, by providing a ‘root –notebook’ command option to start a local notebook server customised with all the ROOT features.; New tutorials and code examples have been provided. The simplest example showing the integration of ROOT with the notebook technology can be found here and many more snippets here.; Support for capturing large outputs (stderr/stdout) coming from C++ libraries has been added.; JavaScript ROOT. support registered in THttpServer commands with arguments.; provide workaround for websites using require.js and older jquery-ui; support custom requests to remote objects, demonstrated in httptextlog.C tutorial; rewrite draw.htm (page for individual object drawing) to support all custom features as main gui does; See also the JSRoot 3.9 examples page and the JSRoot 3.9 release notes. Class Reference Guide; The ROOT reference guide is moving to the Doxygen system. Doxygen is the de-facto standard for code documentation. It offers many nice features we are now exploring and trying to get the best of them. Having MathJax rendered math formula is one of them. The documentation can be structured in a more logical way using groups. Still there is a lot to do but big progresses have been done. We developed also a Doxygen filter allowing to execute macros given as examples in the documentation and show the resulting picture directly in the documentation.; Tutorials; The tutorials in $ROOTSYS/tutorials are also presented on the web thanks to Doxygen. They are now part of the reference guide allowing nice cross-referencing with the classes documentation. Here also a filter has been developed to generate the resulting picture.; Build, Configuration and Testing Infrastructure; ROOT uses the CMake cross-platform build-generator tool as a primary build system. CMake does not build the project, it generates the files n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:22784,guid,guide,22784,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,1,['guid'],['guide']
Usability,"e background source ; [in]binMap(default=nullptr) remapping of histogram bins. returns true if the background source was found. ; This method returns the shifts of the unfolding result induced by varying the normalisation of the identified background by one sigma. ; the array binMap is explained with the method GetOutput(). ; Definition at line 1086 of file TUnfoldSys.cxx. ◆ GetEmatrixFromVyy(). void TUnfoldSys::GetEmatrixFromVyy ; (; const TMatrixDSparse * ; vyy, . TH2 * ; ematrix, . const Int_t * ; binMap, . Bool_t ; clearEmat . ). protected . propagate an error matrix on the input vector to the unfolding result ; Parameters. [in]vyyinput error matrix ; [in,out]ematrixhistogram to be updated ; [in]binMapmapping of histogram bins ; [in]clearEmatif set, clear histogram before adding this covariance contribution . Definition at line 1250 of file TUnfoldSys.cxx. ◆ GetEmatrixInput(). void TUnfoldSys::GetEmatrixInput ; (; TH2 * ; ematrix, . const Int_t * ; binMap = nullptr, . Bool_t ; clearEmat = kTRUE . ). covariance matrix contribution from input measurement uncertainties ; Parameters. [in,out]ematrixoutput histogram ; [in]binMap(default=nullptr) remapping of histogram bins ; [in]clearEmat(default=true) if true, clear the histogram. this method returns the covariance contributions to the unfolding result from the uncertainties or covariance of the input data. In many cases, these are the ""statistical uncertainties"". ; The array binMap is explained with the method GetOutput(). The flag clearEmat may be used to add covariance matrices from several uncertainty sources. ; Definition at line 1207 of file TUnfoldSys.cxx. ◆ GetEmatrixSysBackgroundScale(). void TUnfoldSys::GetEmatrixSysBackgroundScale ; (; TH2 * ; ematrix, . const char * ; name, . const Int_t * ; binMap = nullptr, . Bool_t ; clearEmat = kTRUE . ). covariance contribution from background normalisation uncertainty ; Parameters. [in,out]ematrixoutput histogram ; [in]sourceidentifier of the background source ; [in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldSys.html:37630,clear,clearEmat,37630,doc/master/classTUnfoldSys.html,https://root.cern,https://root.cern/doc/master/classTUnfoldSys.html,1,['clear'],['clearEmat']
Usability,"e box. void DrawFillArea(Int_t n, const Double_t* x, const Double_t* y); Paint filled area. void DrawFillArea(Int_t n, const Float_t* x, const Float_t* y); Paint filled area. void DrawPolyLine(Int_t n, const Double_t* x, const Double_t* y). void DrawPolyLine(Int_t n, const Float_t* x, const Float_t* y); Paint polyline. void DrawPolyLineNDC(Int_t n, const Double_t* u, const Double_t* v); Paint polyline in normalized coordinates. void DrawPolyMarker(Int_t n, const Double_t* x, const Double_t* y); Paint polymarker. void DrawPolyMarker(Int_t n, const Float_t* x, const Float_t* y); Paint polymarker. void DrawText(Double_t x, Double_t y, const char* text, TVirtualPadPainter::ETextMode mode); Paint text. void DrawText(Double_t x, Double_t y, const wchar_t* text, TVirtualPadPainter::ETextMode mode); That's a special version working with wchar_t and required by TMathText (who uses utf-8(?)). void DrawTextNDC(Double_t u, Double_t v, const char* text, TVirtualPadPainter::ETextMode mode); Paint text in normalized coordinates. void SaveImage(TVirtualPad* pad, const char* fileName, Int_t type) const; Save the image displayed in the canvas pointed by ""pad"" into a; binary file.; assert(pad != nullptr && ""SaveImage, parameter 'pad' is null"");; assert(fileName != nullptr && ""SaveImage, parameter 'fileName' is null"");. void DrawTextNDC(Double_t u, Double_t v, const wchar_t* text, TVirtualPadPainter::ETextMode mode); Paint text in normalized coordinates. TPadPainter(); Final overriders for TVirtualPadPainter pure virtual functions.; 1. Part, which simply delegates to TVirtualX.; Line attributes. TPadPainter(const TPadPainter& rhs); Let's make this clear:. » Author: Olivier Couet, Timur Pocheptsov 06/05/2009 » Copyright (C) 1995-2009, Rene Brun and Fons Rademakers. *; » Last changed: root/gpad:$Id$ » Last generated: 2015-06-30 15:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPadPainter.html:7698,simpl,simply,7698,root/html602/TPadPainter.html,https://root.cern,https://root.cern/root/html602/TPadPainter.html,4,"['clear', 'simpl']","['clear', 'simply']"
Usability,"e camera, Double_t fov, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); Set a perspective camera to supplied configuration - note this; does not need to be the current camera - though you will not see; the effect if it is not. 'camera' defines the persp camera - one of kCameraPerspXOZ, kCameraPerspYOZ, kCameraPerspXOY; 'fov' - field of view (lens angle) in degrees (clamped to 0.1 - 170.0); 'dolly' - distance from 'center'; 'center' - world position from which dolly/hRotate/vRotate are measured; camera rotates round this, always facing in (in center of viewport); 'hRotate' - horizontal rotation from initial configuration in degrees; 'hRotate' - vertical rotation from initial configuration in degrees. TGLAutoRotator* GetAutoRotator(); Get the auto-rotator for this viewer. void SetAutoRotator(TGLAutoRotator* ar); Set the auto-rotator for this viewer. The old rotator is deleted. void GetGuideState(Int_t& axesType, Bool_t& axesDepthTest, Bool_t& referenceOn, Double_t* referencePos) const; Fetch the state of guides (axes & reference markers) into arguments. void SetGuideState(Int_t axesType, Bool_t axesDepthTest, Bool_t referenceOn, const Double_t* referencePos); Set the state of guides (axes & reference markers) from arguments. void SetDrawCameraCenter(Bool_t x); Draw camera look at and rotation point. const TGLPhysicalShape * GetSelected() const; Return selected physical shape. void MouseOver(TGLPhysicalShape* ); Emit MouseOver signal. void MouseOver(TGLPhysicalShape* , UInt_t state); Emit MouseOver signal. void MouseOver(TObject* obj, UInt_t state); Emit MouseOver signal. void ReMouseOver(TObject* obj, UInt_t state); Emit MouseOver signal. void UnMouseOver(TObject* obj, UInt_t state); Emit UnMouseOver signal. void Clicked(TObject* obj); Emit Clicked signal. void Clicked(TObject* obj, UInt_t button, UInt_t state); Emit Clicked signal with button id and modifier state. void ReClicked(TObject* obj, UInt_t button, UInt_t state); Emit ReClicked signal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLViewer.html:32035,guid,guides,32035,root/html528/TGLViewer.html,https://root.cern,https://root.cern/root/html528/TGLViewer.html,4,['guid'],['guides']
Usability,"e constructors.; public:. virtual~TArray(); static TClass*Class(); virtual Double_tGetAt(Int_t i) const; Int_tGetSize() const; virtual TClass*IsA() const; TArray&operator=(const TArray& rhs); static TArray*ReadArray(TBuffer& b, const TClass* clReq); virtual voidSet(Int_t n); virtual voidSetAt(Double_t v, Int_t i); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TArray(); TArray(Int_t n); TArray(const TArray& a); static voidWriteArray(TBuffer& b, const TArray* a). protected:. Bool_tBoundsOk(const char* where, Int_t at) const; Bool_tOutOfBoundsError(const char* where, Int_t i) const. Data Members; public:. Int_tfNNumber of array elements. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t OutOfBoundsError(const char* where, Int_t i) const; Generate an out-of-bounds error. Always returns false. TArray * ReadArray(TBuffer& b, const TClass* clReq); Read TArray object from buffer. Simplified version of; TBuffer::ReadObject (does not keep track of multiple; references to same array). void WriteArray(TBuffer& b, const TArray* a); Write TArray object to buffer. Simplified version of; TBuffer::WriteObject (does not keep track of multiple; references to the same array). Bool_t BoundsOk(const char* where, Int_t at) const. TArray(); { }. TArray(Int_t n); { }. TArray(const TArray& a); { }. TArray & operator=(const TArray& rhs); {if(this!=&rhs) fN = rhs.fN; return *this; }. virtual ~TArray(); { fN = 0; }. Int_t GetSize() const; { return fN; }. void Set(Int_t n). Double_t GetAt(Int_t i) const. void SetAt(Double_t v, Int_t i). » Author: Fons Rademakers 21/10/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-06-02 15:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TArray.html:1587,Simpl,Simplified,1587,root/html604/TArray.html,https://root.cern,https://root.cern/root/html604/TArray.html,2,['Simpl'],['Simplified']
Usability,"e constructors.; public:. virtual~TArray(); static TClass*Class(); virtual Double_tGetAt(Int_t i) const; Int_tGetSize() const; virtual TClass*IsA() const; TArray&operator=(const TArray& rhs); static TArray*ReadArray(TBuffer& b, const TClass* clReq); virtual voidSet(Int_t n); virtual voidSetAt(Double_t v, Int_t i); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TArray(); TArray(Int_t n); TArray(const TArray& a); static voidWriteArray(TBuffer& b, const TArray* a). protected:. Bool_tBoundsOk(const char* where, Int_t at) const; Bool_tOutOfBoundsError(const char* where, Int_t i) const. Data Members; public:. Int_tfNNumber of array elements. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t OutOfBoundsError(const char* where, Int_t i) const; Generate an out-of-bounds error. Always returns false. TArray * ReadArray(TBuffer& b, const TClass* clReq); Read TArray object from buffer. Simplified version of; TBuffer::ReadObject (does not keep track of multiple; references to same array). void WriteArray(TBuffer& b, const TArray* a); Write TArray object to buffer. Simplified version of; TBuffer::WriteObject (does not keep track of multiple; references to the same array). Bool_t BoundsOk(const char* where, Int_t at) const. TArray(); { }. TArray(Int_t n); { }. TArray(const TArray& a); { }. TArray & operator=(const TArray& rhs); {if(this!=&rhs) fN = rhs.fN; return *this; }. virtual ~TArray(); { fN = 0; }. Int_t GetSize() const; { return fN; }. void Set(Int_t n). Double_t GetAt(Int_t i) const. void SetAt(Double_t v, Int_t i). » Author: Fons Rademakers 21/10/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-06-30 14:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TArray.html:1587,Simpl,Simplified,1587,root/html602/TArray.html,https://root.cern,https://root.cern/root/html602/TArray.html,2,['Simpl'],['Simplified']
Usability,"e define now C as an assembly containing A and B, positioning the assembly into D,E and F will actually position only A and Bdirectly into these volumes, taking into account their combined transformations A/B to C and C to D/E/F. This looks much nicer, is it? In fact, it is and it is not. Of course, we managed to get rid of the ‘unnecessary’ volume C in our geometry, but we end-up with a more flat structure for D,E and F (more daughters inside). This can get much worse when extensively used, as in the case: assemblies of assemblies.; For deciding what to choose between using virtual containers or assemblies for a specific case, one can use for both cases, after the geometry was closed:; gGeoManager->SetTopVolume(ptr_D);; gGeoManager->Test();; gGeoManager->RestoreMasterVolume();; The ptr_D is a pointer to volume D containing the interesting structure. The test will provide the timing for classifying 1 million random points inside D.; 18.4.2.5 Examples of Volume Positioning; Now let us make a simple volume representing a copper wire. We suppose that a medium is already created (see TGeoMedium class on how to create media).; We will create a TUBE shape for our wire, having Rmin=0cm, Rmax=0.01cm and a half-length dZ=1cm:; TGeoTube *tube = new TGeoTube(""wire_tube"",0,0.01,1);; One may omit the name for the shape wire_tube, if no retrieving by name is further needed during geometry building. Different volumes having different names and materials can share the same shape.; Now let’s make the volume for our wire:; TGeoVolume *wire_co = new TGeoVolume(""WIRE_CO"",tube,; ptrCOPPER); //(*); (*) Do not bother to delete the media, shapes or volumes that you have created since all will be automatically cleaned on exit by the manager class.; If we would have taken a look inside TGeoManager::MakeTube() method, we would have been able to create our wire with a single line:; TGeoVolume *wire_co = gGeoManager->MakeTube(""WIRE_CO"",ptrCOPPER,; 0,0.01,1); //(*); (*) The same applies for all p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:943759,simpl,simple,943759,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"e eventList; TFile*TEventIter::fFileCurrent file; TStringTEventIter::fFilenameName of the current file; Long64_tTEventIter::fFirstfirst entry to process; Long64_tTEventIter::fNumnumber of entries to process; Long64_tTEventIter::fOldBytesReadlast reported number of bytes read; TStringTEventIter::fPathPath to current TDirectory; TSelector*TEventIter::fSelselector to be used; Bool_tTEventIter::fStoptermination of run requested. private:. Long64_tfCacheSizeCache size; Bool_tfDontCacheFilesControl OS caching of read files (Mac Os X only); TList*fFileTreesFiles && Trees currently open; TTree*fTreetree we are iterating over; TTreeCache*fTreeCacheinstance of the tree cache for the tree; Bool_tfTreeCacheIsLearningWhether cache is in learning phase; TStringfTreeNamename of the tree object to iterate over; Bool_tfUseParallelUnzipControl usage of parallel unzip; Bool_tfUseTreeCacheControl usage of the tree cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEventIterTree(); Default ctor. TEventIterTree(TDSet* dset, TSelector* sel, Long64_t first, Long64_t num); Constructor. ~TEventIterTree(); Destructor. Long64_t GetCacheSize(); Return the size in bytes of the cache, if any; Return -1 if not used. Int_t GetLearnEntries(); Return the number of entries in the learning phase. TTree* GetTrees(TDSetElement* elem); Create a Tree for the main TDSetElement and for all the friends.; Returns the main tree or 0 in case of an error. TTree* Load(TDSetElement* elem, Bool_t& localfile); Load a tree from s TDSetElement. Long64_t GetNextEvent(); Get next event. TEventIterTree(). » Author: Maarten Ballintijn 07/01/02 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id: TEventIter.h 38810 2011-04-12 16:22:59Z ganis $ » Last generated: 2011-07-04 15:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TEventIterTree.html:7688,learn,learning,7688,root/html530/TEventIterTree.html,https://root.cern,https://root.cern/root/html530/TEventIterTree.html,1,['learn'],['learning']
Usability,"e eventList; TFile*TEventIter::fFileCurrent file; TStringTEventIter::fFilenameName of the current file; Long64_tTEventIter::fFirstfirst entry to process; Long64_tTEventIter::fNumnumber of entries to process; Long64_tTEventIter::fOldBytesReadlast reported number of bytes read; TStringTEventIter::fPathPath to current TDirectory; TSelector*TEventIter::fSelselector to be used; Bool_tTEventIter::fStoptermination of run requested. private:. Long64_tfCacheSizeCache size; Bool_tfDontCacheFilesControl OS caching of read files (Mac Os X only); TList*fFileTreesFiles && Trees currently open; TTree*fTreetree we are iterating over; TTreeCache*fTreeCacheinstance of the tree cache for the tree; Bool_tfTreeCacheIsLearningWhether cache is in learning phase; TStringfTreeNamename of the tree object to iterate over; Bool_tfUseParallelUnzipControl usage of parallel unzip; Bool_tfUseTreeCacheControl usage of the tree cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEventIterTree(); Default ctor. TEventIterTree(TDSet* dset, TSelector* sel, Long64_t first, Long64_t num); Constructor. ~TEventIterTree(); Destructor. Long64_t GetCacheSize(); Return the size in bytes of the cache, if any; Return -1 if not used. Int_t GetLearnEntries(); Return the number of entries in the learning phase. TTree* GetTrees(TDSetElement* elem); Create a Tree for the main TDSetElement and for all the friends.; Returns the main tree or 0 in case of an error. TTree* Load(TDSetElement* elem, Bool_t& localfile); Load a tree from s TDSetElement. Long64_t GetNextEvent(); Get next event. TEventIterTree(). » Author: Maarten Ballintijn 07/01/02 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id: TEventIter.h 38810 2011-04-12 16:22:59Z ganis $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEventIterTree.html:7688,learn,learning,7688,root/html532/TEventIterTree.html,https://root.cern,https://root.cern/root/html532/TEventIterTree.html,2,['learn'],['learning']
Usability,"e example or the full tutorial here.; @ROOT.Numba.Declare([""float""], ""bool""); def myFilter(x):; return x > 10; ; df = ROOT.RDataFrame(""myTree"", ""myFile.root""); sum = df.Filter(""Numba::myFilter(x)"").Sum(""y""); print(sum.GetValue()); It also works with collections: RVec objects of fundamental types can be transparently converted to/from numpy arrays:; @ROOT.Numba.Declare(['RVec<float>', 'int'], 'RVec<float>'); def pypowarray(numpyvec, pow):; return numpyvec**pow; ; df.Define('array', 'ROOT::RVecF{1.,2.,3.}')\; .Define('arraySquared', 'Numba::pypowarray(array, 2)'); Note that this functionality requires the Python packages numba and cffi to be installed. Interoperability with NumPy; Conversion to NumPy arrays; Eventually, you probably would like to inspect the content of the RDataFrame or process the data further with Python libraries. For this purpose, we provide the AsNumpy() function, which returns the columns of your RDataFrame as a dictionary of NumPy arrays. See a simple example below or a full tutorial here.; df = ROOT.RDataFrame(""myTree"", ""myFile.root""); cols = df.Filter(""x > 10"").AsNumpy([""x"", ""y""]) # retrieve columns ""x"" and ""y"" as NumPy arrays; print(cols[""x""], cols[""y""]) # the values of the cols dictionary are NumPy arrays; Processing data stored in NumPy arrays; In case you have data in NumPy arrays in Python and you want to process the data with ROOT, you can easily create an RDataFrame using ROOT.RDF.FromNumpy. The factory function accepts a dictionary where the keys are the column names and the values are NumPy arrays, and returns a new RDataFrame with the provided columns.; Only arrays of fundamental types (integers and floating point values) are supported and the arrays must have the same length. Data is read directly from the arrays: no copies are performed.; # Read data from NumPy arrays; # The column names in the RDataFrame are taken from the dictionary keys; x, y = numpy.array([1, 2, 3]), numpy.array([4, 5, 6]); df = ROOT.RDF.FromNumpy({""x"": x, ""y""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:82724,simpl,simple,82724,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['simpl'],['simple']
Usability,"e file, insert a “!” as the first character after the comment marks. It tells ROOT not to save that data member in a root file when saving the class. For example, in this version of Event, the fPt and fTransient data members are not persistent.; class Event : public TObject {; private:; TDirectory *fTransient; //! current directory; Float_t fPt; //! transient value; ...; 11.3.3 The Pointer to Objects (//->); The string “->” in the comment field of the members *fH and *fTracks instruct the automatic Streamer to assume these will point to valid objects and the Streamerof the objects can be called rather than the more expensive R__b << fH. It is important to note that no check is done on the validity of the pointer value. In particular if the pointer points, directly or indirectly, back to the current object, this will result in an infinite recursion and the abrupt end of the process.; TClonesArray *fTracks; //->; TH1F *fH; //->; 11.3.4 Variable Length Array; When the Streamercomes across a pointer to a simple type, it assumes it is an array. Somehow, it has to know how many elements are in the array to reserve enough space in the buffer and write out the appropriate number of elements. This is done in the class definition. For example:; class Event : public TObject {; private:; char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; ...; Float_t *fClosestDistance; //[fNvertex]; The array fClosestDistance is defined as a pointer of floating point numbers. A comment mark (//), and the number in square brackets tell the Streamerthe length of the array for this object. In general the syntax is:; <simple type> *<name>//[<length>]; The length cannot be an expression. If a variable is used, it needs to be an integer data member of the class. It must be defined ahead of its use, or in a base class.; The same notation also applies to variable length array of object and variable length array of pointer to objects.; MyObject *obj; //[fNojbs]; MyObject **objs; //[fDatas]; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:470115,simpl,simple,470115,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"e file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooArgSet. class RooArgSet: public RooAbsCollection. RooArgSet is a container object that can hold multiple RooAbsArg objects.; The container has set semantics which means that:. - Every object it contains must have a unique name returned by GetName(). - Contained objects are not ordered, although the set can be traversed; using an iterator returned by createIterator(). The iterator does not; necessarily follow the object insertion order. - Objects can be retrieved by name only, and not by index. Ownership of contents. Unowned objects are inserted with the add() method. Owned objects; are added with addOwned() or addClone(). A RooArgSet either owns all; of it contents, or none, which is determined by the first <add>; call. Once an ownership status is selected, inappropriate <add> calls; will return error status. Clearing the list via removeAll() resets the; ownership status. Arguments supplied in the constructor are always added; as unowned elements. Function Members (Methods); public:. RooArgSet(); RooArgSet(const RooArgList& list); RooArgSet(const char* name); RooArgSet(const RooArgList& list, const RooAbsArg* var1); RooArgSet(const TCollection& tcoll, const char* name = """"); RooArgSet(const RooAbsArg& var1, const char* name = """"); RooArgSet(const RooArgSet& other, const char* name = """"); RooArgSet(const RooArgSet& set1, const RooArgSet& set2, const char* name = """"); RooArgSet(const RooAbsArg& var1, const RooAbsArg& var2, const char* name = """"); RooArgSet(const RooAbsArg& var1, const RooAbsArg& var2, const RooAbsArg& var3, const char* name = """"); RooArgSet(const RooAbsArg& var1, const RooAbsArg& var2, const RooAbsArg& var3, const RooAbsArg& var4, const char* name = """"); RooArgSet(const RooAbsArg& var1, const RooAbsArg& var2, const RooAbsArg& var3, const RooAbsArg& var4, const RooAbsArg& var5, const char* name = """"); RooAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooArgSet.html:1076,Clear,Clearing,1076,root/html534/RooArgSet.html,https://root.cern,https://root.cern/root/html534/RooArgSet.html,1,['Clear'],['Clearing']
Usability,"e file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooArgSet. class RooArgSet: public RooAbsCollection. RooArgSet is a container object that can hold multiple RooAbsArg objects.; The container has set semantics which means that:. - Every object it contains must have a unique name returned by GetName(). - Contained objects are not ordered, although the set can be traversed; using an iterator returned by createIterator(). The iterator does not; necessarily follow the object insertion order. - Objects can be retrieved by name only, and not by index. Ownership of contents. Unowned objects are inserted with the add() method. Owned objects; are added with addOwned() or addClone(). A RooArgSet either owns all; of it contents, or none, which is determined by the first <add>; call. Once an ownership status is selected, inappropriate <add> calls; will return error status. Clearing the list via removeAll() resets the; ownership status. Arguments supplied in the constructor are always added; as unowned elements. Function Members (Methods); public:. virtual~RooArgSet(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tadd(const RooAbsArg& var, Bool_t silent = kFALSE); virtual Bool_tadd(const RooAbsCollection& list, Bool_t silent = kFALSE); virtual RooAbsArg*addClone(const RooAbsArg& var, Bool_t silent = kFALSE); virtual voidaddClone(const RooAbsCollection& list, Bool_t silent = kFALSE); virtual Bool_taddOwned(RooAbsArg& var, Bool_t silent = kFALSE); virtual Bool_taddOwned(const RooAbsCollection& list, Bool_t silent = kFALSE); Bool_tRooAbsCollection::allInRange(const char* rangeSpec) const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsCollection::assignFast(const RooAbsCollection& other, Bool_t setValDirty = kTRUE); RooAbsCollection&RooAbsCollection::assignValueOnly(const RooAbsCollection& other, Bool_t oneSafe = kFALSE); virtual voidTObject::Brows",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooArgSet.html:1076,Clear,Clearing,1076,root/html602/RooArgSet.html,https://root.cern,https://root.cern/root/html602/RooArgSet.html,2,['Clear'],['Clearing']
Usability,"e filled via; calls to SetPoint. TGraph2D(const char* filename, const char* format = ""%lg %lg %lg"", Option_t* option = """"); Graph2D constructor reading input from filename; filename is assumed to contain at least three columns of numbers.; For files separated by a specific delimiter different from ' ' and '\t' (e.g. ';' in csv files); you can avoid using %*s to bypass this delimiter by explicitly specify the ""option"" argument,; e.g. option="" \t,;"" for columns of figures separated by any of these characters (' ', '\t', ',', ';'); used once (e.g. ""1;1"") or in a combined way ("" 1;,;; 1"").; Note in that case, the instanciation is about 2 times slower. TGraph2D(const TGraph2D& ); Graph2D copy constructor.; copy everything apart from the list of contained functions. ~TGraph2D(); TGraph2D destructor. TGraph2D& operator=(const TGraph2D& ); Graph2D operator ""="". void Build(Int_t n); Creates the 2D graph basic data structure. void Browse(TBrowser* ); Browse. void Clear(Option_t* option = """"); Free all memory allocated by this object. void DirectoryAutoAdd(TDirectory* ); Perform the automatic addition of the graph to the given directory. Note this function is called in place when the semantic requires; this object to be added to a directory (I.e. when being read from; a TKey or being Cloned). Int_t DistancetoPrimitive(Int_t px, Int_t py); Computes distance from point px,py to a graph. void Draw(Option_t* option = """"); Specific drawing options can be used to paint a TGraph2D:. ""TRI"" : The Delaunay triangles are drawn using filled area.; An hidden surface drawing technique is used. The surface is; painted with the current fill area color. The edges of each; triangles are painted with the current line color.; ""TRIW"" : The Delaunay triangles are drawn as wire frame; ""TRI1"" : The Delaunay triangles are painted with color levels. The edges; of each triangles are painted with the current line color.; ""TRI2"" : the Delaunay triangles are painted with color levels.; ""P"" : Draw a marker a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGraph2D.html:19800,Clear,Clear,19800,root/html534/TGraph2D.html,https://root.cern,https://root.cern/root/html534/TGraph2D.html,3,['Clear'],['Clear']
Usability,"e for generating graphics. It is platform; and format-independent and works together with the most important TeX; backend drivers, including pdftex and dvips. It comes with a; user-friendly syntax layer called TikZ. To generate a such file it is enough to do:. gStyle->SetPaperSize(10.,10.);; hpx->Draw();; gPad->Print(""hpx.tex"");. Then, the generated file (hpx.tex) can be included in a; LaTeX document (simple.tex) in the following way:. \documentclass{article}; \usepackage{tikz}; \usetikzlibrary{patterns}; \usetikzlibrary{plotmarks}; \title{A simple LaTeX example}; \date{July 2013}; \begin{document}; \maketitle; The following image as been generated using the TTeXDump class:; \par; \input{hpx.tex}; \end{document}. Note the three directives needed at the top of the LaTeX file:. \usepackage{tikz}; \usetikzlibrary{patterns}; \usetikzlibrary{plotmarks}. Then including the picture in the document is done with the; \input<\tt> directive.; The command pdflatex simple.tex will generate the; corresponding pdf file simple.pdf.; . Function Members (Methods); public:. TTeXDump(); TTeXDump(const char* filename, Int_t type = -113); virtual~TTeXDump(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidCellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); virtual voidCellArrayEnd(); virtual voidCellArrayFill(Int_t r, Int_t g, Int_t b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); Int_tCMtoTeX(Double_t u); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; voidDefineMarkers(); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTeXDump.html:1490,simpl,simple,1490,root/html534/TTeXDump.html,https://root.cern,https://root.cern/root/html534/TTeXDump.html,2,['simpl'],['simple']
Usability,"e for generating graphics. It is platform; and format-independent and works together with the most important TeX; backend drivers, including pdftex and dvips. It comes with a; user-friendly syntax layer called TikZ. To generate a such file it is enough to do:. gStyle->SetPaperSize(10.,10.);; hpx->Draw();; gPad->Print(""hpx.tex"");. Then, the generated file (hpx.tex) can be included in a; LaTeX document (simple.tex) in the following way:. \documentclass{article}; \usepackage{tikz}; \usetikzlibrary{patterns}; \usetikzlibrary{plotmarks}; \title{A simple LaTeX example}; \date{July 2013}; \begin{document}; \maketitle; The following image as been generated using the TTeXDump class:; \par; \input{hpx.tex}; \end{document}. Note the three directives needed at the top of the LaTeX file:. \usepackage{tikz}; \usetikzlibrary{patterns}; \usetikzlibrary{plotmarks}. Then including the picture in the document is done with the; \input<\tt> directive.; The command pdflatex simple.tex will generate the; corresponding pdf file simple.pdf.; . Function Members (Methods); public:. virtual~TTeXDump(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidCellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); virtual voidCellArrayEnd(); virtual voidCellArrayFill(Int_t r, Int_t g, Int_t b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); Int_tCMtoTeX(Double_t u); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; voidDefineMarkers(); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitiv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTeXDump.html:1514,simpl,simple,1514,root/html602/TTeXDump.html,https://root.cern,https://root.cern/root/html602/TTeXDump.html,4,['simpl'],['simple']
Usability,"e frame, and if it contains a child frame, ask; the user where to keep it (top or bottom). This method is the actual; implementation. void SplitVer(); Vertically split the frame, and if it contains a child frame, ask; the user where to keep it (left or right). This is the method used; via the context menu. void SplitVertical(const char* side = ""left""); Vertically split the frame, and if it contains a child frame, ask; the user where to keep it (left or right). This method is the actual; implementation. void SwallowBack(); Swallow back the child frame previously extracted, and close its; parent (transient frame). void SwitchFrames(TGFrame* frame, TGCompositeFrame* dest, TGFrame* prev); Switch (exchange) two frames.; frame is the source, dest is the destination (the new parent); prev is the frame that has to be exchanged with the source; (the one actually in the destination). void SwitchToMain(); Switch the actual embedded frame to the main (first) split frame. void Undocked(TGFrame* frame); Emit Undocked() signal. void UnSplit(const char* which); Close (unmap and remove from the list of frames) the frame contained in; this split frame. void SavePrimitive(ostream& out, Option_t* option = """"); Save a splittable frame as a C++ statement(s) on output stream out. TGRectMap& operator=(const TGSplitFrame& ). TGSplitFrame(const TGSplitFrame& ). TGSplitFrame * GetFirst() const; { return fFirst; }. TGFrame * GetFrame() const; { return fFrame; }. TGSplitFrame * GetSecond() const; { return fSecond; }. TGSplitter * GetSplitter() const; { return fSplitter; }. TGSplitTool * GetSplitTool() const; { return fSplitTool; }. TGFrame * GetUndocked() const; { return fUndocked; }. Float_t GetHRatio() const; { return fHRatio; }. Float_t GetWRatio() const; { return fWRatio; }. void SetHRatio(Float_t r); { fHRatio = r; }. void SetWRatio(Float_t r); { fWRatio = r; }. » Author: Bertrand Bellenot 23/01/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGSplitFrame.html:22534,Undo,Undocked,22534,root/html534/TGSplitFrame.html,https://root.cern,https://root.cern/root/html534/TGSplitFrame.html,6,['Undo'],['Undocked']
Usability,"e frame, and if it contains a child frame, ask; the user where to keep it (top or bottom). This method is the actual; implementation. void SplitVer(); Vertically split the frame, and if it contains a child frame, ask; the user where to keep it (left or right). This is the method used; via the context menu. void SplitVertical(const char* side = ""left""); Vertically split the frame, and if it contains a child frame, ask; the user where to keep it (left or right). This method is the actual; implementation. void SwallowBack(); Swallow back the child frame previously extracted, and close its; parent (transient frame). void SwitchFrames(TGFrame* frame, TGCompositeFrame* dest, TGFrame* prev); Switch (exchange) two frames.; frame is the source, dest is the destination (the new parent); prev is the frame that has to be exchanged with the source; (the one actually in the destination). void SwitchToMain(); Switch the actual embedded frame to the main (first) split frame. void Undocked(TGFrame* frame); Emit Undocked() signal. void UnSplit(const char* which); Close (unmap and remove from the list of frames) the frame contained in; this split frame. void SavePrimitive(ostream& out, Option_t* option = """"); Save a splittable frame as a C++ statement(s) on output stream out. TGRectMap& operator=(const TGSplitFrame& ). TGSplitFrame(const TGSplitFrame& ). TGSplitFrame * GetFirst() const; { return fFirst; }. TGFrame * GetFrame() const; { return fFrame; }. TGSplitFrame * GetSecond() const; { return fSecond; }. TGSplitter * GetSplitter() const; { return fSplitter; }. TGSplitTool * GetSplitTool() const; { return fSplitTool; }. TGFrame * GetUndocked() const; { return fUndocked; }. Float_t GetHRatio() const; { return fHRatio; }. Float_t GetWRatio() const; { return fWRatio; }. void SetHRatio(Float_t r); { fHRatio = r; }. void SetWRatio(Float_t r); { fWRatio = r; }. » Author: Bertrand Bellenot 23/01/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGSplitFrame.html:22515,Undo,Undocked,22515,root/html532/TGSplitFrame.html,https://root.cern,https://root.cern/root/html532/TGSplitFrame.html,2,['Undo'],['Undocked']
Usability,"e given FCN function representing a multi-dimensional gradient function; interface (ROOT::Math::IMultiGradFunction). In this case the minimizer will use the; gradient information provided by the function.; For the options same consideration as in the previous method. bool FitFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0). Fit using a FitMethodGradFunction interface. Same as method above, but now extra information; can be taken from the function class. bool SetFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Set the FCN function represented by a multi-dimensional gradient function interface; (ROOT::Math::IMultiGenFunction) and optionally the initial parameters; See also note above for the initial parameters for FitFCN. bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). bool EvalFCN(). Perform a simple FCN evaluation. FitResult will be modified and contain the value of the FCN. bool LinearFit(const ROOT::Fit::BinData& data). do a linear fit on a set of bin-data. { return DoLinearFit(data); }. void SetFunction(const IModelFunction & func). Set the fitted function (model function) from a parametric function interface. void SetFunction(const IModel1DFunction & func). Set the fitted function from a parametric 1D function interface. bool CalculateHessErrors(). perform an error analysis on the result using the Hessian; Errors are obtaied from the inverse of the Hessian matrix; To be called only after fitting and when a minimizer supporting the Hessian calculations is used; otherwise an error (false) is returned.; A new FitResult with the Hessian result will be produced. bool CalculateMinosErrors(). perform an error analysis on the result using MINOS; To be called only after fitting and when a minimizer supporting MINOS is used; otherwise an error (false) is returned.; The result will be a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Fit__Fitter.html:9815,simpl,simple,9815,root/html530/ROOT__Fit__Fitter.html,https://root.cern,https://root.cern/root/html530/ROOT__Fit__Fitter.html,1,['simpl'],['simple']
Usability,"e given FCN function representing a multi-dimensional gradient function; interface (ROOT::Math::IMultiGradFunction). In this case the minimizer will use the; gradient information provided by the function.; For the options same consideration as in the previous method. bool FitFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0). Fit using a FitMethodGradFunction interface. Same as method above, but now extra information; can be taken from the function class. bool SetFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Set the FCN function represented by a multi-dimensional gradient function interface; (ROOT::Math::IMultiGenFunction) and optionally the initial parameters; See also note above for the initial parameters for FitFCN. bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). bool EvalFCN(). Perform a simple FCN evaluation. FitResult will be modified and contain the value of the FCN. bool LinearFit(const ROOT::Fit::BinData& data). do a linear fit on a set of bin-data. { return DoLinearFit(data); }. void SetFunction(const IModelFunction & func, bool useGradient = false). Set the fitted function (model function) from a parametric function interface. void SetFunction(const IModel1DFunction & func, bool useGradient = false). Set the fitted function from a parametric 1D function interface. bool CalculateHessErrors(). perform an error analysis on the result using the Hessian; Errors are obtaied from the inverse of the Hessian matrix; To be called only after fitting and when a minimizer supporting the Hessian calculations is used; otherwise an error (false) is returned.; A new FitResult with the Hessian result will be produced. bool CalculateMinosErrors(). perform an error analysis on the result using MINOS; To be called only after fitting and when a minimizer supporting MINOS is used; otherwise",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Fit__Fitter.html:11178,simpl,simple,11178,root/html532/ROOT__Fit__Fitter.html,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html,6,['simpl'],['simple']
Usability,"e given FCN function representing a multi-dimensional gradient function; interface (ROOT::Math::IMultiGradFunction). In this case the minimizer will use the; gradient information provided by the function.; For the options same consideration as in the previous method. bool FitFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0). Fit using a FitMethodGradFunction interface. Same as method above, but now extra information; can be taken from the function class. bool SetFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Set the FCN function represented by a multi-dimensional gradient function interface; (ROOT::Math::IMultiGenFunction) and optionally the initial parameters; See also note above for the initial parameters for FitFCN. bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). bool EvalFCN(). Perform a simple FCN evaluation. FitResult will be modified and contain the value of the FCN. void SetFunction(const IModelFunction & func, bool useGradient = false). Set the fitted function (model function) from a parametric function interface. void SetFunction(const IModel1DFunction & func, bool useGradient = false). Set the fitted function from a parametric 1D function interface. bool CalculateHessErrors(). perform an error analysis on the result using the Hessian; Errors are obtaied from the inverse of the Hessian matrix; To be called only after fitting and when a minimizer supporting the Hessian calculations is used; otherwise an error (false) is returned.; A new FitResult with the Hessian result will be produced. bool CalculateMinosErrors(). perform an error analysis on the result using MINOS; To be called only after fitting and when a minimizer supporting MINOS is used; otherwise an error (false) is returned.; The result will be appended in the fit result class; Optionally a vector of parameter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Fit__Fitter.html:10746,simpl,simple,10746,root/html604/ROOT__Fit__Fitter.html,https://root.cern,https://root.cern/root/html604/ROOT__Fit__Fitter.html,2,['simpl'],['simple']
Usability,"e given initialization method. */; 106 virtual void Initialize();; 107 ; 108 /*! Computes activation of the layer for the given input. The input; 109 * must be in 3D tensor form with the different matrices corresponding to; 110 * different events in the batch. */; 111 virtual void Forward(Tensor_t &input, bool applyDropout = false) = 0;; 112 ; 113 /*! Backpropagates the error. Must only be called directly at the corresponding; 114 * call to Forward(...). */; 115 virtual void Backward(Tensor_t &gradients_backward, const Tensor_t &activations_backward ) = 0;; 116 ///// std::vector<Matrix_t> &inp1, std::vector<Matrix_t> &inp2) = 0;; 117 ; 118 /*! Reset some training flags after a loop on all batches; 119 Some layer (e.g. batchnormalization) might need to implement the function in case some operations; 120 are needed after looping an all batches */; 121 virtual void ResetTraining() {}; 122 ; 123 /*! Updates the weights and biases, given the learning rate */; 124 void Update(const Scalar_t learningRate);; 125 ; 126 /*! Updates the weights, given the gradients and the learning rate, */; 127 void UpdateWeights(const std::vector<Matrix_t> &weightGradients, const Scalar_t learningRate);; 128 ; 129 /*! Updates the biases, given the gradients and the learning rate. */; 130 void UpdateBiases(const std::vector<Matrix_t> &biasGradients, const Scalar_t learningRate);; 131 ; 132 /*! Updates the weight gradients, given some other weight gradients and learning rate. */; 133 void UpdateWeightGradients(const std::vector<Matrix_t> &weightGradients, const Scalar_t learningRate);; 134 ; 135 /*! Updates the bias gradients, given some other weight gradients and learning rate. */; 136 void UpdateBiasGradients(const std::vector<Matrix_t> &biasGradients, const Scalar_t learningRate);; 137 ; 138 /*! Copies the weights provided as an input. */; 139 void CopyWeights(const std::vector<Matrix_t> &otherWeights);; 140 ; 141 /*! Copies the biases provided as an input. */; 142 void CopyBiases(const std:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GeneralLayer_8h_source.html:5087,learn,learning,5087,doc/master/GeneralLayer_8h_source.html,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html,5,['learn'],"['learning', 'learningRate']"
Usability,"e graph to be drawn in high resolution mode.; By default, the graph is drawn in low resolution; in case the number of points is greater than the number of; pixels in the current pad.; ; ""][""; ""Cutoff"" style. When this option is selected together with; H option, the first and last vertical lines of the histogram; are not drawn.; . . void PaintGraphAsymmErrors(TGraph* theGraph, Option_t* option). Paint this TGraphAsymmErrors with its current attributes.; . void PaintGraphBentErrors(TGraph* theGraph, Option_t* option). Paint this TGraphBentErrors with its current attributes.; . void PaintGraphErrors(TGraph* theGraph, Option_t* option). Paint this TGraphErrors with its current attributes.; . void PaintGraphPolar(TGraph* theGraph, Option_t* option). Paint this TGraphPolar with its current attributes.; . void PaintGraphQQ(TGraph* theGraph, Option_t* option). Paint this graphQQ. No options for the time being.; ; . void PaintGraphSimple(TGraph* theGraph, Option_t* option). Paint a simple graph, without errors bars.; ; . void PaintPolyLineHatches(TGraph* theGraph, Int_t n, const Double_t* x, const Double_t* y). Paint a polyline with hatches on one side showing an exclusion zone. x and y; are the the vectors holding the polyline and n the number of points in the; polyline and w the width of the hatches. w can be negative.; This method is not meant to be used directly. It is called automatically; according to the line style convention.; ; . void PaintStats(TGraph* theGraph, TF1* fit). Paint the statistics box with the fit info.; ; . void Smooth(TGraph* theGraph, Int_t npoints, Double_t* x, Double_t* y, Int_t drawtype). Smooth a curve given by N points.; ; The original code come from an underlaying routine for Draw based on the; CERN GD3 routine TVIPTE:; ; Author - Marlow etc. Modified by - P. Ward Date - 3.10.1973; ; This method draws a smooth tangentially continuous curve through; the sequence of data points P(I) I=1,N where P(I)=(X(I),Y(I)); the curve is approximated by a pol",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGraphPainter.html:22740,simpl,simple,22740,root/html528/TGraphPainter.html,https://root.cern,https://root.cern/root/html528/TGraphPainter.html,2,['simpl'],['simple']
Usability,"e histogram from the ROOT File; TH1 *hpx = nullptr; // pointer to base class TH1 is enough; example->GetObject(""hpx"", hpx);; ; TCanvas *c1 = new TCanvas(""c1"",""Histogram Drawing Options"",200,10,700,900);; TPad *pad1 = new TPad(""pad1"",; ""The pad with the function"",0.03,0.62,0.50,0.92);; TPad *pad2 = new TPad(""pad2"",; ""The pad with the histogram"",0.51,0.62,0.98,0.92);; TPad *pad3 = new TPad(""pad3"",; ""The pad with the histogram"",0.03,0.02,0.97,0.57);; pad1->Draw();; pad2->Draw();; pad3->Draw();; ; // Draw a global picture title; TPaveLabel *title = new TPaveLabel(0.1,0.94,0.9,0.98,; ""Drawing options for one dimensional histograms"");; title->SetTextFont(52);; title->Draw();; ; // Draw histogram hpx in first pad with the default option.; pad1->cd();; pad1->GetFrame()->SetFillColor(18);; hpx->SetFillColor(45);; hpx->DrawCopy();; TPaveLabel *label1 = new TPaveLabel(-3.5,700,-1,800,""Default option"");; label1->Draw();; ; // Draw hpx as a lego. Clicking on the lego area will show; // a ""transparent cube"" to guide you rotating the lego in real time.; pad2->cd();; hpx->DrawCopy(""lego1"");; TPaveLabel *label2 = new TPaveLabel(-0.72,0.74,-0.22,0.88,""option Lego1"");; label2->Draw();; TPaveLabel *label2a = new TPaveLabel(-0.93,-1.08,0.25,-0.92,; ""Click on lego to rotate"");; label2a->Draw();; ; // Draw hpx with its errors and a marker.; pad3->cd();; pad3->SetGridx();; pad3->SetGridy();; hpx->SetMarkerStyle(21);; hpx->Draw(""e1p"");; TPaveLabel *label3 = new TPaveLabel(2,600,3.5,650,""option e1p"");; label3->Draw();; ; // The following illustrates how to add comments using a PaveText.; // Attributes of text/lines/boxes added to a PaveText can be modified.; // The AddText function returns a pointer to the added object.; TPaveText *pave = new TPaveText(-3.78,500,-1.2,750);; TText *t1=pave->AddText(""You can move"");; t1->SetTextColor(4);; t1->SetTextSize(0.05);; pave->AddText(""Title and Stats pads"");; pave->AddText(""X and Y axis"");; pave->AddText(""You can modify bin contents"");; pave->Draw();;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/h1ReadAndDraw_8C.html:1872,guid,guide,1872,doc/master/h1ReadAndDraw_8C.html,https://root.cern,https://root.cern/doc/master/h1ReadAndDraw_8C.html,1,['guid'],['guide']
Usability,"e individual graphs or; histograms in them are added to the TLegend. TVirtualPad * cd(Int_t subpadnumber = 0); Set Current pad.; When a canvas/pad is divided via TPad::Divide, one can directly; set the current path to one of the subdivisions.; See TPad::Divide for the convention to number subpads.; Returns the new current pad, or 0 in case of failure.; For example:; c1.Divide(2,3); // create 6 pads (2 divisions along x, 3 along y).; To set the current pad to the bottom right pad, do; c1.cd(6);; Note1: c1.cd() is equivalent to c1.cd(0) and sets the current pad; to c1 itself.; Note2: after a statement like c1.cd(6), the global variable gPad; points to the current pad. One can use gPad to set attributes; of the current pad.; Note3: One can get a pointer to one of the sub-pads of pad with:; TPad *subpad = (TPad*)pad->GetPad(subpadnumber);. void Clear(Option_t* option = """"); Delete all pad primitives. If the bit kClearAfterCR has been set for this pad, the Clear function; will execute only after having pressed a CarriageReturn; Set the bit with mypad->SetBit(TPad::kClearAfterCR). Int_t Clip(Float_t* x, Float_t* y, Float_t xclipl, Float_t yclipb, Float_t xclipr, Float_t yclipt); Clipping routine: Cohen Sutherland algorithm. If Clip ==2 the segment is outside the boundary.; If Clip ==1 the segment has one point outside the boundary.; If Clip ==0 the segment is inside the boundary. _Input parameters:. x[2], y[2] : Segment coordinates; xclipl, yclipb, xclipr, yclipt : Clipping boundary. _Output parameters:. x[2], y[2] : New segment coordinates. Int_t Clip(Double_t* x, Double_t* y, Double_t xclipl, Double_t yclipb, Double_t xclipr, Double_t yclipt); Clipping routine: Cohen Sutherland algorithm. If Clip ==2 the segment is outside the boundary.; If Clip ==1 the segment has one point outside the boundary.; If Clip ==0 the segment is inside the boundary. _Input parameters:. x[2], y[2] : Segment coordinates; xclipl, yclipb, xclipr, yclipt : Clipping boundary. _Output parameters:. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TPad.html:32616,Clear,Clear,32616,root/html532/TPad.html,https://root.cern,https://root.cern/root/html532/TPad.html,1,['Clear'],['Clear']
Usability,"e individual; graphs or histograms in them are added to the TLegend. TVirtualPad * cd(Int_t subpadnumber = 0); Set Current pad.; When a canvas/pad is divided via TPad::Divide, one can directly; set the current path to one of the subdivisions.; See TPad::Divide for the convention to number subpads.; Returns the new current pad, or 0 in case of failure.; For example:; c1.Divide(2,3); // create 6 pads (2 divisions along x, 3 along y).; To set the current pad to the bottom right pad, do; c1.cd(6);; Note1: c1.cd() is equivalent to c1.cd(0) and sets the current pad; to c1 itself.; Note2: after a statement like c1.cd(6), the global variable gPad; points to the current pad. One can use gPad to set attributes; of the current pad.; Note3: One can get a pointer to one of the sub-pads of pad with:; TPad *subpad = (TPad*)pad->GetPad(subpadnumber);. void Clear(Option_t* option = """"); Delete all pad primitives. If the bit kClearAfterCR has been set for this pad, the Clear function; will execute only after having pressed a CarriageReturn; Set the bit with mypad->SetBit(TPad::kClearAfterCR). Int_t Clip(Float_t* x, Float_t* y, Float_t xclipl, Float_t yclipb, Float_t xclipr, Float_t yclipt); Clipping routine: Cohen Sutherland algorithm. If Clip ==2 the segment is outside the boundary.; If Clip ==1 the segment has one point outside the boundary.; If Clip ==0 the segment is inside the boundary. _Input parameters:. x[2], y[2] : Segment coordinates; xclipl, yclipb, xclipr, yclipt : Clipping boundary. _Output parameters:. x[2], y[2] : New segment coordinates. Int_t Clip(Double_t* x, Double_t* y, Double_t xclipl, Double_t yclipb, Double_t xclipr, Double_t yclipt); Clipping routine: Cohen Sutherland algorithm. If Clip ==2 the segment is outside the boundary.; If Clip ==1 the segment has one point outside the boundary.; If Clip ==0 the segment is inside the boundary. _Input parameters:. x[2], y[2] : Segment coordinates; xclipl, yclipb, xclipr, yclipt : Clipping boundary. _Output parameters:. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPad.html:33635,Clear,Clear,33635,root/html534/TPad.html,https://root.cern,https://root.cern/root/html534/TPad.html,3,['Clear'],['Clear']
Usability,"e interval in the fit residual case. ; Definition at line 207 of file TRatioPlot.h. ◆ GetConfidenceInterval2(). TGraphErrors * TRatioPlot::GetConfidenceInterval2 ; (; ); const. inline . Returns the graph for the 2 sigma confidence interval in the fit residual case. ; Definition at line 212 of file TRatioPlot.h. ◆ GetLowerPad(). TPad * TRatioPlot::GetLowerPad ; (; ); const. inline . Definition at line 215 of file TRatioPlot.h. ◆ GetLowerRefGraph(). TGraph * TRatioPlot::GetLowerRefGraph ; (; ); const. virtual . Returns the reference graph for the lower pad, which means the graph that is responsible for setting the coordinate system. ; It is the first graph added to the primitive list of the lower pad. This reference can be used to set the minimum and maximum of the lower pad. Note that TRatioPlot::Draw needs to have been called first, since the graphs are only created then.; ; void ratioplot3() {; gStyle->SetOptStat(0);; auto c1 = new TCanvas(""c1"", ""fit residual simple"");; c1->SetLogy();; auto h1 = new TH1D(""h1"", ""h1"", 50, -5, 5);; h1->FillRandom(""gaus"", 2000);; h1->Fit(""gaus"", ""0"");; h1->SetMinimum(0.001);; h1->GetXaxis()->SetTitle(""x"");; h1->GetYaxis()->SetTitle(""y"");; auto rp1 = new TRatioPlot(h1);; rp1->Draw();; rp1->GetLowerRefGraph()->SetMinimum(-2);; rp1->GetLowerRefGraph()->SetMaximum(2);; }; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::SetMinimumvirtual void SetMinimum(Double_t minimum=-1111)Definition TH1.h:405; ratioplot3Definition ratioplot3.py:1; . Definition at line 705 of file TRatioPlot.cxx. ◆ GetLowerRefXaxis(). TAxis * TRatioPlot::GetLowerRefXaxis ; (; ); const. Gets the x axis of the lower ref graph. ; Shortcut for:; rp->GetLowerRefGraph()->GetXaxis();. Definition at line 798 of file TRatioPlot.cxx. ◆ GetLowerRefYaxis(). TAxis * TRatioPlot::GetLowerRefYaxis ; (; ); const. Gets the y axis of the lower ref graph. ; Shortcut for:; rp->GetLowerRefGraph()->GetYaxis();. Definition at line 812 of file TRatioPlot.cxx. ◆ GetLowYaxis(). TAxis * TR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRatioPlot.html:33046,simpl,simple,33046,doc/master/classTRatioPlot.html,https://root.cern,https://root.cern/doc/master/classTRatioPlot.html,1,['simpl'],['simple']
Usability,"e line defined by the conjugate gradient. Parameters; are Tau and Reset, which defines the epochs where the direction is; reset to the steepes descent.; Conjugate gradients with the; Fletcher-Reeves updating formula: Weights are set to the; minimum along the line defined by the conjugate gradient. Parameters; are Tau and Reset, which defines the epochs where the direction is; reset to the steepes descent.; Broyden, Fletcher, Goldfarb, Shanno; (BFGS) method: Implies the computation of a NxN matrix; computation, but seems more powerful at least for less than 300; weights. Parameters are Tau and Reset, which defines the epochs where; the direction is reset to the steepes descent. How; to use it... TMLP is build from 3 classes: TNeuron, TSynapse and; TMultiLayerPerceptron. Only TMultiLayerPerceptron should be used; explicitly by the user.; TMultiLayerPerceptron will take examples from a TTree; given in the constructor. The network is described by a simple; string: The input/output layers are defined by giving the expression for; each neuron, separated by comas. Hidden layers are just described; by the number of neurons. The layers are separated by colons.; In addition, input/output layer formulas can be preceded by '@' (e.g ""@out""); if one wants to also normalize the data from the TTree.; Input and outputs are taken from the TTree given as second argument.; Expressions are evaluated as for TTree::Draw(), arrays are expended in; distinct neurons, one for each index.; This can only be done for fixed-size arrays.; If the formula ends with ""!"", softmax functions are used for the output layer.; One defines the training and test datasets by TEventLists. Example:; TMultiLayerPerceptron(""x,y:10:5:f"",inputTree);; Both the TTree and the TEventLists can be defined in; the constructor, or later with the suited setter method. The lists; used for training and test can be defined either explicitly, or via; a string containing the formula to be used to define them, exactly as; for a TCu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMultiLayerPerceptron.html:6305,simpl,simple,6305,root/html534/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html534/TMultiLayerPerceptron.html,6,['simpl'],['simple']
Usability,"e list of merged commands. Option string can contain substrings:; ""compress"" - try to compress input command; ""radd"" - execute redo action of input command; ""uadd"" - execute undo action of input command. Bool_t CanCompress(TQCommand* c) const; By default, commands can be compressed if they are:. - equal; - setter commands. More complicated commands might want to override this function. void Compress(TQCommand* c); Compress command. Compression is analogous to arithmetic ""addition operation"". Note:; - The compressed command will be deleted.; - Execution Compress method invokes Redo action with new redo arguments; inheritied from compressed command. More complicated commands might want to override this function. Bool_t IsEqual(const TObject* obj) const; Equal comparison. The commands are equal if they are; applied to the same object and have the same Redo/Undo actions. More complicated commands might want to override this function. Bool_t IsSetter() const; Returns kTRUE is command if Redo is the same as Undo function; and is the setter action. By default, all functions with names like ""SetXXX"" or ""setXXX""; considered as setters. Another type of setters are Move, Resize operations. More complicated commands might want to override this function. void SetArgs(Int_t narg, ...); Set do/redo and undo parameters. The format is; SetArgs(number_of_params, redo_params, undo_params). Example:; move_command->SetArgs(2, 100, 100, 200, 200);; 2 params, (100,100) - do/redo position, (200,200) - undo position. void SetRedoArgs(Int_t narg, ...); Set redo parameters. The format is; SetRedoArgs(number_of_params, params). Example:; move_command->SetRedoArgs(2, 100, 100);. void SetUndoArgs(Int_t narg, ...); Set undo parameters. The format is; SetUndoArgs(number_of_params, params). Example:; move_command->SetUndoArgs(2, 200, 200);. Bool_t CanRedo() const; Returns kTRUE if Redo action is possible, kFALSE if it's not.; By default, only single sequential redo action is possible. Bool_t CanUnd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TQCommand.html:21747,Undo,Undo,21747,root/html532/TQCommand.html,https://root.cern,https://root.cern/root/html532/TQCommand.html,4,['Undo'],['Undo']
Usability,"e list of predefined color names is the following:; kWhite = 0, kBlack = 1, kGray = 920, kRed = 632, kGreen = 416,; kBlue = 600, kYellow = 400, kMagenta = 616, kCyan = 432, kOrange = 800,; kSpring = 820, kTeal = 840, kAzure = 860, kViolet = 880, kPink = 900; kTeal@ kTealDefinition Rtypes.h:67; kGray@ kGrayDefinition Rtypes.h:65; kPink@ kPinkDefinition Rtypes.h:67; kOrange@ kOrangeDefinition Rtypes.h:67; kBlack@ kBlackDefinition Rtypes.h:65; kGreen@ kGreenDefinition Rtypes.h:66; kWhite@ kWhiteDefinition Rtypes.h:65; kCyan@ kCyanDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; kAzure@ kAzureDefinition Rtypes.h:67; kViolet@ kVioletDefinition Rtypes.h:67; kSpring@ kSpringDefinition Rtypes.h:67; Note the special role of color kWhite (color number 0). It is the default background color also. For instance in a PDF or PS files (as paper is usually white) it is simply not painted. To have a white color behaving like the other color the simplest is to define an other white color not attached to the color index 0:; Int_t ci = TColor::GetFreeColorIndex();; TColor *color = new TColor(ci, 1., 1., 1.);. Bright and dark colors; Dark and bright colors are used to add 3D effects to graphical objects like TWbox, TPave, TPaveText, TPaveLabel, etc. and in colored lego plots.; Two static functions are available that return the bright or dark color number corresponding to a given color index. If these variants don't already exist, they are created as needed: Int_t dark = TColor::GetColorDark(color_index);; Int_t bright = TColor::GetColorBright(color_index);; TColor::GetColorBrightstatic Int_t GetColorBright(Int_t color)Static function: Returns the bright color number corresponding to n If the TColor object does not exi...Definition TColor.cxx:2087; TColor::GetColorDarkstatic Int_t GetColorDark(Int_t color)Static function: Returns the dark color number corresponding to n If the TColor object does not exist...Definition TColor.cxx:2130. Accessible Color Schemes; Choosing an appro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTColor.html:5104,simpl,simplest,5104,doc/master/classTColor.html,https://root.cern,https://root.cern/doc/master/classTColor.html,1,['simpl'],['simplest']
Usability,"e most common mathematical functions are supported. It is possible to invoke them passing RVecs as arguments.; abs, fdim, fmod, remainder; floor, ceil, trunc, round, lround, llround; exp, exp2, expm1; log, log10, log2, log1p; pow; sqrt, cbrt; sin, cos, tan, asin, acos, atan, atan2, hypot; sinh, cosh, tanh, asinh, acosh; erf, erfc; lgamma, tgamma. If the VDT library is available, the following functions can be invoked. Internally the calculations are vectorized:; fast_expf, fast_logf, fast_sinf, fast_cosf, fast_tanf, fast_asinf, fast_acosf, fast_atanf; fast_exp, fast_log, fast_sin, fast_cos, fast_tan, fast_asin, fast_acos, fast_atan. Owning and adopting memory; RVec has contiguous memory associated to it. It can own it or simply adopt it. In the latter case, it can be constructed with the address of the memory associated to it and its length. For example: std::vector<int> myStlVec {1,2,3};; RVec<int> myRVec(myStlVec.data(), myStlVec.size());; In this case, the memory associated to myStlVec and myRVec is the same, myRVec simply ""adopted it"". If any method which implies a re-allocation is called, e.g. emplace_back or resize, the adopted memory is released and new one is allocated. The previous content is copied in the new memory and preserved. Sorting and manipulation of indices. Sorting; RVec complies to the STL interfaces when it comes to iterations. As a result, standard algorithms can be used, for example sorting: RVec<double> v{6., 4., 5.};; std::sort(v.begin(), v.end());; v@ vDefinition rootcling_impl.cxx:3687; For convenience, helpers are provided too: auto sorted_v = Sort(v);; auto reversed_v = Reverse(v);; ROOT::VecOps::ReverseRVec< T > Reverse(const RVec< T > &v)Return copy of reversed vector.Definition RVec.hxx:2481; ROOT::VecOps::SortRVec< T > Sort(const RVec< T > &v)Return copy of RVec with elements sorted in ascending order.Definition RVec.hxx:2502. Manipulation of indices; It is also possible to manipulated the RVecs acting on their indices. For example, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1VecOps_1_1RVec.html:4999,simpl,simply,4999,doc/v632/classROOT_1_1VecOps_1_1RVec.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1VecOps_1_1RVec.html,1,['simpl'],['simply']
Usability,"e most common mathematical functions are supported. It is possible to invoke them passing RVecs as arguments.; abs, fdim, fmod, remainder; floor, ceil, trunc, round, lround, llround; exp, exp2, expm1; log, log10, log2, log1p; pow; sqrt, cbrt; sin, cos, tan, asin, acos, atan, atan2, hypot; sinh, cosh, tanh, asinh, acosh; erf, erfc; lgamma, tgamma. If the VDT library is available, the following functions can be invoked. Internally the calculations are vectorized:; fast_expf, fast_logf, fast_sinf, fast_cosf, fast_tanf, fast_asinf, fast_acosf, fast_atanf; fast_exp, fast_log, fast_sin, fast_cos, fast_tan, fast_asin, fast_acos, fast_atan. Owning and adopting memory; RVec has contiguous memory associated to it. It can own it or simply adopt it. In the latter case, it can be constructed with the address of the memory associated to it and its length. For example: std::vector<int> myStlVec {1,2,3};; RVec<int> myRVec(myStlVec.data(), myStlVec.size());; In this case, the memory associated to myStlVec and myRVec is the same, myRVec simply ""adopted it"". If any method which implies a re-allocation is called, e.g. emplace_back or resize, the adopted memory is released and new one is allocated. The previous content is copied in the new memory and preserved. Sorting and manipulation of indices. Sorting; RVec complies to the STL interfaces when it comes to iterations. As a result, standard algorithms can be used, for example sorting: RVec<double> v{6., 4., 5.};; std::sort(v.begin(), v.end());; v@ vDefinition rootcling_impl.cxx:3699; For convenience, helpers are provided too: auto sorted_v = Sort(v);; auto reversed_v = Reverse(v);; ROOT::VecOps::ReverseRVec< T > Reverse(const RVec< T > &v)Return copy of reversed vector.Definition RVec.hxx:2481; ROOT::VecOps::SortRVec< T > Sort(const RVec< T > &v)Return copy of RVec with elements sorted in ascending order.Definition RVec.hxx:2502. Manipulation of indices; It is also possible to manipulated the RVecs acting on their indices. For example, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1VecOps_1_1RVec.html:5000,simpl,simply,5000,doc/master/classROOT_1_1VecOps_1_1RVec.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1VecOps_1_1RVec.html,1,['simpl'],['simply']
Usability,"e name.Definition TTreeReaderValue.cxx:693; TBranchElementA Branch for the case of an object.Definition TBranchElement.h:39; TBranchA TTree is a list of TBranches.Definition TBranch.h:93; TDictionaryThis class defines an abstract interface that must be implemented by all classes that contain diction...Definition TDictionary.h:168; TLeafA TLeaf describes individual elements of a TBranch See TBranch structure in TTree.Definition TLeaf.h:57; TStringBasic string class.Definition TString.h:139; TTreeReaderValueAn interface for reading values stored in ROOT columnar datasets.Definition TTreeReaderValue.h:174; TTreeReaderValue::operator->T * operator->()Return a pointer to the value of the current entry.Definition TTreeReaderValue.h:201; TTreeReaderValue::TTreeReaderValueTTreeReaderValue()=delete; TTreeReaderValue::GetT * Get()Return a pointer to the value of the current entry.Definition TTreeReaderValue.h:189; TTreeReaderValue::TTreeReaderValueTTreeReaderValue(TTreeReader &tr, const char *branchname)Definition TTreeReaderValue.h:180; TTreeReaderValue::operator*T & operator*()Return a reference to the value of the current entry.Definition TTreeReaderValue.h:206; TTreeReaderValue::NonConstT_ttypename std::remove_const< T >::type NonConstT_tDefinition TTreeReaderValue.h:178; TTreeReaderValue::GetDerivedTypeNameconst char * GetDerivedTypeName() const overrideGet the template argument as a string.Definition TTreeReaderValue.h:211; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:46; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; bool; int; ROOT::Minuit2::GradientParameterSpace::Internal@ Internal; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4. treetreeplayerincTTreeReaderValue.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:05 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeReaderValue_8h_source.html:20255,simpl,simple,20255,doc/master/TTreeReaderValue_8h_source.html,https://root.cern,https://root.cern/doc/master/TTreeReaderValue_8h_source.html,1,['simpl'],['simple']
Usability,"e normalization of inputs/outputs; TMultilayerPerceptron provides, thanks to Andrea Bocci, the possibility to use cross-entropy errors, which allows to train a network for pattern classification based on Bayesian posterior probability. Introduction; Neural Networks are more and more used in various fields for data analysis and classification, both for research and commercial institutions. Some randomly chosen examples are:. image analysis; financial movements predictions and analysis; sales forecast and product shipping optimisation; in particles physics: mainly for classification tasks (signal over background discrimination). More than 50% of neural networks are multilayer perceptrons. This implementation of multilayer perceptrons is inspired from the MLPfit package originally written by Jerome Schwindling. MLPfit remains one of the fastest tool for neural networks studies, and this ROOT add-on will not try to compete on that. A clear and flexible Object Oriented implementation has been chosen over a faster but more difficult to maintain code. Nevertheless, the time penalty does not exceed a factor 2. The MLP; The multilayer perceptron is a simple feed-forward network with the following structure:. It is made of neurons characterized by a bias and weighted links between them (let's call those links synapses). The input neurons receive the inputs, normalize them and forward them to the first hidden layer.; Each neuron in any subsequent layer first computes a linear combination of the outputs of the previous layer. The output of the neuron is then function of that combination with f being linear for output neurons or a sigmoid for hidden layers. This is useful because of two theorems:. A linear combination of sigmoids can approximate any continuous function.; Trained with output = 1 for the signal and 0 for the background, the approximated function of inputs X is the probability of signal, knowing X. Learning methods; The aim of all learning methods is to minimize the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiLayerPerceptron.html:2513,clear,clear,2513,doc/master/classTMultiLayerPerceptron.html,https://root.cern,https://root.cern/doc/master/classTMultiLayerPerceptron.html,1,['clear'],['clear']
Usability,e of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tfOneTime! used in the learning phase; Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch! Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeCache.html:20523,learn,learning,20523,root/html602/TTreeCache.html,https://root.cern,https://root.cern/root/html602/TTreeCache.html,4,['learn'],['learning']
Usability,"e of the fit. Only in cases where such a modification of fit behaviour is intentional,; this function should be used. RooArgSet* addColumns(const RooArgList& varList); Utility function to add multiple columns in one call; See addColumn() for details. RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge columns of supplied data set(s) with this data set. All; data sets must have equal number of entries. In case of; duplicate columns the column of the last dataset in the list; prevails. void reserve(Int_t nEvt). void append(RooAbsDataStore& other). Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kTRUE); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void forceCacheUpdate(). void recalculateCache(const RooArgSet* , Int_t firstEvent, Int_t lastEvent, Int_t stepSize, Bool_t skipZeroWeights). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Initialize cache of dataset: attach variables of cache ArgSet; to the corresponding TTree branches. void resetCache(). void setArgStatus(const RooArgSet& set, Bool_t active); Disabling of branches is (intentionally) not implemented in vector; data stores (as the doesn't result in a net saving of time). void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void dump(). void Streamer(TBuffer& ); Stream an object of class RooVectorDataStore. RooAbsDataStore* clone(const char* newname = 0) const; { return new RooVectorDataStore(*this,newname) ; }. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const; { return new RooVectorDataStore(*this,vars,newname) ; }. Bool_t isWeighted() ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooVectorDataStore.html:15983,clear,cleared,15983,root/html534/RooVectorDataStore.html,https://root.cern,https://root.cern/root/html534/RooVectorDataStore.html,6,['clear'],['cleared']
Usability,"e ore more container; limits. Suppose we want to position the same box inside 2 different volumes; and we want the Z size to match the one of each container:. TGeoVolume *container1 = gGeoManager->MakeBox(""C1"", imed, 10,10,30);; TGeoVolume *container2 = gGeoManager->MakeBox(""C2"", imed, 10,10,20);; TGeoVolume *pvol = gGeoManager->MakeBox(""PVOL"", jmed, 3,3,-1);; container1->AddNode(pvol, 1);; container2->AddNode(pvol, 1);. Note that the third parameter of PVOL is negative, which does not make sense; as half-length on Z. This is interpreted as: when positioned, create a box; replacing all invalid parameters with the corresponding dimensions of the; container. This is also internally handled by the TGeoVolumeMulti class, which; does not need to be instantiated by users. Dividing volumes. Volumes can be divided according a pattern. The most simple division can; be done along one axis, that can be: X, Y, Z, Phi, Rxy or Rxyz. Let's take; the most simple case: we would like to divide a box in N equal slices along X; coordinate, representing a new volume family. Supposing we already have created; the initial box, this can be done like:. TGeoVolume *slicex = box->Divide(""SLICEX"", 1, N);. where SLICE is the name of the new family representing all slices and 1 is the; slicing axis. The meaning of the axis index is the following: for all volumes; having shapes like box, trd1, trd2, trap, gtra or para - 1,2,3 means X,Y,Z; for; tube, tubs, cone, cons - 1 means Rxy, 2 means phi and 3 means Z; for pcon and; pgon - 2 means phi and 3 means Z; for spheres 1 means R and 2 means phi.; In fact, the division operation has the same effect as positioning volumes; in a given order inside the divided container - the advantage being that the; navigation in such a structure is much faster. When a volume is divided, a; volume family corresponding to the slices is created. In case all slices can; be represented by a single shape, only one volume is added to the family and; positioned N times inside",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoVolume.html:13135,simpl,simple,13135,root/html534/TGeoVolume.html,https://root.cern,https://root.cern/root/html534/TGeoVolume.html,18,['simpl'],['simple']
Usability,"e parameters at the time of the call. ; also prints other relevant information such as function value, estimated distance to minimum, parameter errors, step sizes.; According to the value of IKODE, the printout is: IKODE=INKODE=; 0 only info about function value; 1 parameter values, errors, limits; 2 values, errors, step sizes, internal values; 3 values, errors, step sizes, first derivs.; 4 values, parabolic errors, MINOS errors. when INKODE=5, MNPRIN chooses IKODE=1,2, or 3, according to fISW[1] ; Definition at line 6304 of file TMinuit.cxx. ◆ mnpsdf(). void TMinuit::mnpsdf ; (; ). virtual . Calculates the eigenvalues of v to see if positive-def. ; if not, adds constant along diagonal to make positive. ; Definition at line 6494 of file TMinuit.cxx. ◆ mnrazz(). void TMinuit::mnrazz ; (; Double_t ; ynew, . Double_t * ; pnew, . Double_t * ; y, . Int_t & ; jh, . Int_t & ; jl . ). virtual . Called only by MNSIMP (and MNIMPR) to add a new point. ; and remove an old one from the current simplex, and get the estimated distance to minimum. ; Definition at line 6568 of file TMinuit.cxx. ◆ mnrn15(). void TMinuit::mnrn15 ; (; Double_t & ; val, . Int_t & ; inseed . ). virtual . This is a super-portable random number generator. ; It should not overflow on any 32-bit machine. The cycle is only ~10**9, so use with care! Note especially that VAL must not be undefined on input.; Set Default Starting Seed ; Definition at line 6619 of file TMinuit.cxx. ◆ mnrset(). void TMinuit::mnrset ; (; Int_t ; iopt). virtual . Resets function value and errors to UNDEFINED. . If IOPT=1,; If IOPT=0, sets only MINOS errors to undefined Called from MNCLER and whenever problem changes, for example after SET LIMITS, SET PARAM, CALL FCN 6 . Definition at line 6661 of file TMinuit.cxx. ◆ mnsave(). void TMinuit::mnsave ; (; ). virtual . Writes current parameter values and step sizes onto file ISYSSA. ; in format which can be reread by Minuit for restarting. The covariance matrix is also output if it exists.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMinuit.html:61971,simpl,simplex,61971,doc/master/classTMinuit.html,https://root.cern,https://root.cern/doc/master/classTMinuit.html,1,['simpl'],['simplex']
Usability,"e paths can be specified at once separating them with a comma or; a blank.; Return 0 on success, -1 otherwise. Int_t RemoveDynamicPath(const char* libpath, Bool_t onClient = kFALSE); Remove 'libpath' from the lib path search.; Multiple paths can be specified at once separating them with a comma or; a blank.; Return 0 on success, -1 otherwise. Int_t RemoveIncludePath(const char* incpath, Bool_t onClient = kFALSE); Remove 'incpath' from the inc path search.; Multiple paths can be specified at once separating them with a comma or; a blank.; Return 0 on success, -1 otherwise. void HandleLibIncPath(const char* what, Bool_t add, const char* dirs); Handle lib, inc search paths modification request. TList * GetListOfPackages(); Get from the master the list of names of the packages available. TList * GetListOfEnabledPackages(); Get from the master the list of names of the packages enabled. void PrintProgress(Long64_t total, Long64_t processed, Float_t procTime = -1., Long64_t bytesread = -1); Print a progress bar on stderr. Used in batch mode. void Progress(Long64_t total, Long64_t processed); Get query progress information. Connect a slot to this signal; to track progress. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Get query progress information. Connect a slot to this signal; to track progress. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses); Get query progress information. Connect a slot to this signal; to track progress. void Feedback(TList* objs); Get list of feedback objects. Connect a slot to this signal; to monitor the feedback object. void CloseProgressDialog(); Close progress dialog. void ResetProgressDialog(const char* sel, Int_t sz, Long64_t fst, Long64_t ent); Reset progress dialog. void StartupMessage(const char* msg, Bool_t status, Int_t done,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:69784,progress bar,progress bar,69784,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,10,['progress bar'],['progress bar']
Usability,"e problem at hand, in particular along the borders; of the region of interest. This is because the algorithm presented; here, is a interpolation, rahter then a extrapolation; [5].; ; Also, the independent variables need to be linear; independent, since the procedure will perform poorly if they are not; [5]. One can find an linear transformation from ones; original variables to a set of linear independent variables; , using a Principal Components Analysis; (see TPrincipal), and; then use the transformed variable as input to this class [5]; [6].; ; H. Wind also outlines a method for parameterising a multidimensional; dependence over a multidimensional set of variables. An example; of the method from [5], is a follows (please refer to; [5] for a full discussion):; . Define ; are the 5 dependent; quantities that define a track.; ; Compute, for different values of ; , the tracks; through the magnetic field, and determine the corresponding; ; .; ; Use the simulated observations to determine, with a simple; approximation, the values of ; . We call these values; ; .; ; Determine from ; a set of at least five relevant; coordinates ; , using contrains, or; alternative:. Perform a Principal Component Analysis (using; TPrincipal), and use; to get a linear transformation; ; , so that; ; are constrained and linear independent.; ; Perform a Principal Component Analysis on; ; , to get linear; indenpendent (among themselves, but not independent of; ; ) quantities . For each component ; make a mutlidimensional fit,; using ; as the variables, thus determing a set of; coefficents ; .; . To process data, using this parameterisation, do; ; Test wether the observation ; within the domain of; the parameterization, using the result from the Principal Component; Analysis.; ; Determine ; as before.; ; Detetmine ; as before.; ; Use the result of the fit to determind ; .; ; Transform back to ; from ; , using; the result from the Principal Component Analysis.; . Testing the parameterization; . T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMultiDimFit.html:10875,simpl,simple,10875,root/html534/TMultiDimFit.html,https://root.cern,https://root.cern/root/html534/TMultiDimFit.html,6,['simpl'],['simple']
Usability,"e registered; to the analysis manager but have to be cleaned-up by the user via ClearTracks(). Int_t AddTrack(TVirtualGeoTrack* track); Add a track to the list of tracks. TVirtualGeoTrack * MakeTrack(Int_t id, Int_t pdgcode, TObject* particle); Makes a primary track but do not attach it to the list of tracks. The track; can be attached as daughter to another one with TVirtualGeoTrack::AddTrack. Int_t AddVolume(TGeoVolume* volume); Add a volume to the list. Returns index of the volume in list. TGeoNavigator * AddNavigator(); Add a navigator in the list of navigators. If it is the first one make it; current navigator. TGeoNavigator * GetCurrentNavigator() const; Returns current navigator for the calling thread. TGeoNavigatorArray * GetListOfNavigators() const; Get list of navigators for the calling thread. Bool_t SetCurrentNavigator(Int_t index); Switch to another existing navigator for the calling thread. void ClearNavigators(); Clear all navigators. void RemoveNavigator(const TGeoNavigator* nav); Clear a single navigator. void ClearThreadsMap(); Clear the current map of threads. This will be filled again by the calling; threads via ThreadId calls. Int_t ThreadId(); Translates the current thread id to an ordinal number. This can be used to; manage data which is pspecific for a given thread. void Browse(TBrowser* b); Describe how to browse this object. void Edit(Option_t* option = """"); Append a pad for this geometry. void SetVisibility(TObject* obj, Bool_t vis); Set visibility for a volume. void BombTranslation(const Double_t* tr, Double_t* bombtr); Get the new 'bombed' translation vector according current exploded view mode. void UnbombTranslation(const Double_t* tr, Double_t* bombtr); Get the new 'unbombed' translation vector according current exploded view mode. void DoBackupState(); Backup the current state without affecting the cache stack. void DoRestoreState(); Restore a backed-up state without affecting the cache stack. void RegisterMatrix(const TGeoMatrix* ma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoManager.html:38237,Clear,Clear,38237,root/html532/TGeoManager.html,https://root.cern,https://root.cern/root/html532/TGeoManager.html,1,['Clear'],['Clear']
Usability,"e results or varied results:; hx[""nominal""].Draw(); // same effect as nominal_hx->Draw(); hx[""pt:down""].Draw(""SAME"");; hx[""pt:up""].Draw(""SAME"");; ROOT::RDF::Experimental::RResultMapDefinition RResultMap.hxx:98; ROOT::RDF::Experimental::VariationsForRResultMap< T > VariationsFor(RResultPtr< T > resPtr)Produce all required systematic variations for the given result.Definition RDFHelpers.hxx:219; A list of variation ""tags"" is passed as the last argument to Vary(). The tags give names to the varied values that are returned as elements of an RVec of the appropriate C++ type. The number of variation tags must correspond to the number of elements of this RVec (2 in the example above: the first element will correspond to the tag ""down"", the second to the tag ""up""). The full variation name will be composed of the varied column name and the variation tags (e.g. ""pt:down"", ""pt:up"" in this example). Python usage looks similar.; Note how we use the ""pt"" column as usual in the Filter() and Define() calls and we simply use ""x"" as the value to fill the resulting histogram. To produce the varied results, RDataFrame will automatically execute the Filter and Define calls for each variation and fill the histogram with values and cuts that depend on the variation.; There is no limitation to the complexity of a Vary() expression. Just like for the Define() and Filter() calls, users are not limited to string expressions but they can also pass any valid C++ callable, including lambda functions and complex functors. The callable can be applied to zero or more existing columns and it will always receive their nominal value in input.; Varying multiple columns in lockstep; In the following Python snippet we use the Vary() signature that allows varying multiple columns simultaneously or ""in lockstep"":; df.Vary([""pt"", ""eta""],; ""RVec<RVecF>{{pt*0.9, pt*1.1}, {eta*0.9, eta*1.1}}"",; variationTags=[""down"", ""up""],; variationName=""ptAndEta""); The expression returns an RVec of two RVecs: each inner vect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:54857,simpl,simply,54857,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['simpl'],['simply']
Usability,"e same Postscript file: case 1; The following macro is an example illustrating how to open a Postscript; file and draw several pictures. The generation of a new Postscript page; is automatic when TCanvas::Clear is called by; object->Draw().; ; {; TFile f(""hsimple.root"");; TCanvas c1(""c1"",""canvas"",800,600);; // select postscript output type; // type = 111 portrait ps; // type = 112 landscape ps; // type = 113 eps; Int_t type = 111;; // create a postscript file and set the paper size; TPostScript ps(""test.ps"",type);; ps.Range(16,24); //set x,y of printed page; // draw 3 histograms from file hsimple.root on separate pages; hpx->Draw();; c1.Update(); //force drawing in a macro; hprof->Draw();; c1.Update();; hpx->Draw(""lego1"");; c1.Update();; ps.Close();; }; ; Making several pictures in the same Postscript file: case 2; This example shows 2 pages. The canvas is divided.; TPostScript::NewPage must be called before starting a new; picture.object->Draw does not clear the canvas in this case; because we clear only the pads and not the main canvas.; Note that c1->Update must be called at the end of the first; picture.; ; {; TFile *f1 = new TFile(""hsimple.root"");; TCanvas *c1 = new TCanvas(""c1"");; TPostScript *ps = new TPostScript(""file.ps"",112);; c1->Divide(2,1);; // picture 1; ps->NewPage();; c1->cd(1);; hpx->Draw();; c1->cd(2);; hprof->Draw();; c1->Update();; // picture 2; ps->NewPage();; c1->cd(1);; hpxpy->Draw();; c1->cd(2);; ntuple->Draw(""px"");; c1->Update();; ps->Close();; // invoke Postscript viewer; gSystem->Exec(""gs file.ps"");; }; ; Making several pictures in the same Postscript file: case 3; This is the recommended way. If the Postscript file name finishes with; ""("", the file remains opened (it is not closed). If the Postscript file name; finishes with "")"" and the file has been opened with ""("", the file is closed.; Example:; ; {; TCanvas c1(""c1"");; h1.Draw();; c1.Print(""c1.ps(""); // write canvas and keep the ps file open; h2.Draw();; c1.Print(""c1.ps""); // canvas is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPostScript.html:4517,clear,clear,4517,root/html534/TPostScript.html,https://root.cern,https://root.cern/root/html534/TPostScript.html,12,['clear'],['clear']
Usability,"e same library or in two libraries loaded by the same application if the original source files have the same name. This loose limitation is imposed by the registration mechanism ROOT has in place to keep track of dynamically loaded libraries.; In the following example, we walk through the steps necessary to generate a dictionary, I/O, and inspect member functions. Let’s start with a TEvent class, which contains a collection of TTracks.; The TEvent.h header is:; #ifndef __TEvent__; #define __TEvent__; #include ""TObject.h""; #include ""TCollection.h"". class TTrack;. class TEvent : public TObject {; private:; Int_t fId; // event sequential id; Float_t fTotalMom; // total momentum; TCollection *fTracks; // collection of tracks; public:; TEvent() { fId = 0; fTotalMom = 0; fTracks = nullptr; }; TEvent(Int_t id);; ~TEvent();; void AddTrack(TTrack *t);; Int_t GetId() const { return fId; }; Int_t GetNoTracks() const;; void Print(Option_t *opt="""");; Float_t TotalMomentum();. ClassDef(TEvent,1); //Simple event class; };. #endif; The things to notice in these header files are:. The usage of the ClassDef macro; The default constructors of the TEvent and TTrack classes; Comments to describe the data members and the comment after the ClassDef macro to describe the class. These classes are intended for you to create an event object with a certain id, and then add tracks to it. The track objects have a pointer to their event. This shows that the I/O system correctly handles circular references.; The TTrack.h header is:; #ifndef __TTrack__; #define __TTrack__; #include ""TObject.h"". class TEvent;. class TTrack : public TObject {; private:; Int_t fId; //track sequential id; TEvent *fEvent; //event to which track belongs; Float_t fPx; //x part of track momentum; Float_t fPy; //y part of track momentum; Float_t fPz; //z part of track momentum; public:; TTrack() { fId = 0; fEvent = nullptr; fPx = fPy = fPz = 0; }; TTrack(Int_t id, TEvent *ev, Float_t px,Float_t py,Float_t pz);; Float_t Mome",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:818719,Simpl,Simple,818719,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Simpl'],['Simple']
Usability,"e separate classes called iterator. For each collection class there is an associated iterator class that knows how to sequentially retrieve each member in turn. The relationship between a collection and its iterator is very close and may require that the iterator has full access to the collection (i.e. it is a friend class). In general iterator will be used via the TIter wrapper class. For example:. TList TListIter; TMap TMapIter. 16.3 Foundation Classes; All collections are based on the fundamental classes: TCollection and TIterator. They are so generic that it is not possible to create objects from them; they are only used as base classes for other classes (i.e. they are abstract base classes).; The TCollection class provides the basic protocol (i.e. the minimum set of member functions) that all collection classes have to implement. These include:. Add Adds another object to the collection.; GetSize Returns the number of objects in the collection.; Clear Clears out the collection, but does not delete the removed objects.; Delete Clears out the collection and deletes the removed objects. This should only be used if the collection owns its objects (which are not normally the case).; FindObject Finds an object given either its name or address.; MakeIterator Returns an iterator associated with the collection.; Remove Removes an object from the collection. The code example below shows a class containing three lists, where the fTracks list is the owning collection and the other two lists are used to store a sub-set of the track objects. In the destructor of the class, the method Delete is called for the owning collection to delete correctly its entire track objects. To delete the objects in the container use fTrack->Delete(). To delete the container itself, do ’delete fTracks'.; class TEvent : public TObject {; private:; TList *fTracks; //list of all tracks; TList *fVertex1; //subset of tracks part of vertex1; TList *fVertex2; //subset of tracks part of vertex2; };; TEve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:845413,Clear,Clear,845413,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['Clear'],"['Clear', 'Clears']"
Usability,"e spider plot is available from the treeviewer called by ""atree->StartViewer()"", or simply by calling its constructor and defining the variables to display.; {; TCanvas *c1 = new TCanvas(""c1"",""TSpider example"",200,10,700,700);; TFile *f = new TFile(""$(ROOTSYS)/tutorials/hsimple.root"");; if (!f || f->IsZombie()) {; printf(""Please run <ROOT location>/tutorials/hsimple.C before."");; return;; }; TNtuple* ntuple = (TNtuple*)f->Get(""ntuple"");; TString varexp = ""px:py:pz:random:sin(px):log(px/py):log(pz)"";; TString selectStr = ""px>0 && py>0 && pz>0"";; TString options = ""average"";; TSpider *spider = new TSpider(ntuple,varexp.Data(),selectStr.Data(),options.Data());; spider->Draw();; c1->ToggleEditor();; c1->Selected(c1,spider,1);; return c1;; }; f#define f(i)Definition RSha256.hxx:104; TCanvasThe Canvas class.Definition TCanvas.h:23; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TSpiderSpider class.Definition TSpider.h:40; TSpider::Drawvoid Draw(Option_t *options="""") overrideDraw the spider.Definition TSpider.cxx:454; TSpider::TSpiderTSpider()Default constructor.Definition TSpider.cxx:76; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; c1return c1Definition legend1.C:41. Definition at line 40 of file TSpider.h. Public Member Functions;  TSpider ();  Default constructor. ;  ;  TSpider (TTree *tree, const char *varexp, const char *selection, Option_t *option="""", Long64_t nentries=0, Long64_t firstentry=0);  Normal constructor. ;  ;  ~TSpider () override;  Destructor. ;  ; void AddSuperposed (TSpider *sp);  Allow to superpose several spider views. ;  ; void AddVariable (const char *varexp);  Add a variable to the plot from its expression. ;  ; void DeleteVariable (const char *varexp);  Delete a variable from its expression. ;  ; Int_t D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpider.html:1741,simpl,simple,1741,doc/master/classTSpider.html,https://root.cern,https://root.cern/doc/master/classTSpider.html,1,['simpl'],['simple']
Usability,e the bin volume; 629 const double* xlow = Coords( fNPoints-1 );; 630 ; 631 double binVolume = 1.0;; 632 for ( unsigned int j = 0; j < fDim; j++ ); 633 {; 634 binVolume *= ( xup[j] - xlow[j] );; 635 }; 636 ; 637 // store the minimum bin volume found as reference for future normalizations; 638 if ( fNPoints == 1 ); 639 fRefVolume = binVolume;; 640 else if ( binVolume < fRefVolume ); 641 fRefVolume = binVolume;; 642 }; 643 ; 644 ; 645 void BinData::InitDataVector (); 646 {; 647 fData.resize(fMaxPoints + FitData::VectorPadding(fMaxPoints));; 648 fDataPtr = fData.empty() ? nullptr : &fData.front();; 649 }; 650 ; 651 void BinData::InitializeErrors(); 652 {; 653 assert( kValueError == fErrorType || kCoordError == fErrorType ||; 654 kAsymError == fErrorType || kNoError == fErrorType );; 655 ; 656 if ( fpTmpCoordErrorVector ); 657 {; 658 delete[] fpTmpCoordErrorVector;; 659 fpTmpCoordErrorVector = nullptr;; 660 }; 661 ; 662 if ( kNoError == fErrorType ); 663 {; 664 fCoordErrors.clear();; 665 fCoordErrorsPtr.clear();; 666 ; 667 fDataErrorHigh.clear();; 668 fDataErrorHighPtr = nullptr;; 669 ; 670 fDataErrorLow.clear();; 671 fDataErrorLowPtr = nullptr;; 672 ; 673 fDataError.clear();; 674 fDataErrorPtr = nullptr;; 675 ; 676 return;; 677 }; 678 ; 679 if ( kCoordError == fErrorType || kAsymError == fErrorType ); 680 {; 681 fCoordErrorsPtr.resize( fDim );; 682 fCoordErrors.resize( fDim );; 683 for( unsigned int i=0; i < fDim; i++ ); 684 {; 685 fCoordErrors[i].resize(fMaxPoints + FitData::VectorPadding(fMaxPoints));; 686 ; 687 fCoordErrorsPtr[i] = fCoordErrors[i].empty() ? nullptr : &fCoordErrors[i].front();; 688 }; 689 ; 690 fpTmpCoordErrorVector = new double[fDim];; 691 }; 692 else; 693 {; 694 fCoordErrors.clear();; 695 fCoordErrorsPtr.clear();; 696 }; 697 ; 698 if ( kValueError == fErrorType || kCoordError == fErrorType ); 699 {; 700 fDataError.resize(fMaxPoints + FitData::VectorPadding(fMaxPoints));; 701 fDataErrorPtr = fDataError.empty() ? nullptr : &fDataError.front();; 702 ;,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8cxx_source.html:20431,clear,clear,20431,doc/master/BinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BinData_8cxx_source.html,1,['clear'],['clear']
Usability,"e the container constructor. void * NewArray(Int_t nElements) const; Return a new container object. void * NewArray(Int_t nElements, void* arena) const; Execute the container constructor. void Destructor(void* p, Bool_t dtorOnly = kFALSE); Execute the container destructor. void DeleteArray(void* p, Bool_t dtorOnly = kFALSE); Execute the container array destructor. UInt_t Sizeof() const; Return the sizeof the collection object. void PushProxy(void* objectstart); Set the address of the container being proxied and keep track of the previous one. void PopProxy(); Reset the address of the container being proxied to the previous container. Bool_t HasPointers() const; Return true if the content is of type 'pointer to'. TClass * GetValueClass(); Return a pointer to the TClass representing the content. EDataType GetType(); If the content is a simple numerical value, return its type (see TDataType). void * At(UInt_t idx); Return the address of the value at index 'idx'. void Clear(const char* opt = """"); Clear the container. UInt_t Size() const; Return the current size of the container. void* Allocate(UInt_t n, Bool_t forceDelete). void Commit(void* ). char * operator[](UInt_t idx) const; { return (char*)(const_cast<TVirtualCollectionProxy*>(this))->At(idx); }. TStreamerInfoActions::TActionSequence * GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); MemberWise actions. TStreamerInfoActions::TActionSequence * GetReadMemberWiseActions(Int_t version). TStreamerInfoActions::TActionSequence * GetWriteMemberWiseActions(). CreateIterators_t GetFunctionCreateIterators(Bool_t read = kTRUE); begin_arena and end_arena should contain the location of a memory arena of size fgIteratorSize.; If the collection iterator are of that size or less, the iterators will be constructed in place in those location (new with placement); Otherwise the iterators will be allocated via a regular new and their address returned by modifying the value of begin_arena and end_arena. CopyIterator",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TVirtualCollectionProxy.html:4528,Clear,Clear,4528,root/html532/TVirtualCollectionProxy.html,https://root.cern,https://root.cern/root/html532/TVirtualCollectionProxy.html,2,['Clear'],['Clear']
Usability,"e the current camera - though you will not see; the effect if it is not. 'camera' defines the persp camera - one of kCameraPerspXOZ, kCameraPerspYOZ, kCameraPerspXOY; 'fov' - field of view (lens angle) in degrees (clamped to 0.1 - 170.0); 'dolly' - distance from 'center'; 'center' - world position from which dolly/hRotate/vRotate are measured; camera rotates round this, always facing in (in center of viewport); 'hRotate' - horizontal rotation from initial configuration in degrees; 'hRotate' - vertical rotation from initial configuration in degrees. TGLAutoRotator* GetAutoRotator(); Get the auto-rotator for this viewer. void SetAutoRotator(TGLAutoRotator* ar); Set the auto-rotator for this viewer. The old rotator is deleted. void GetGuideState(Int_t& axesType, Bool_t& axesDepthTest, Bool_t& referenceOn, Double_t* referencePos) const; Fetch the state of guides (axes & reference markers) into arguments. void SetGuideState(Int_t axesType, Bool_t axesDepthTest, Bool_t referenceOn, const Double_t* referencePos); Set the state of guides (axes & reference markers) from arguments. void SetDrawCameraCenter(Bool_t x); Draw camera look at and rotation point. const TGLPhysicalShape * GetSelected() const; Return selected physical shape. void MouseOver(TGLPhysicalShape* ); Emit MouseOver signal. void MouseOver(TGLPhysicalShape* , UInt_t state); Emit MouseOver signal. void MouseOver(TObject* obj, UInt_t state); Emit MouseOver signal. void ReMouseOver(TObject* obj, UInt_t state); Emit MouseOver signal. void UnMouseOver(TObject* obj, UInt_t state); Emit UnMouseOver signal. void Clicked(TObject* obj); Emit Clicked signal. void Clicked(TObject* obj, UInt_t button, UInt_t state); Emit Clicked signal with button id and modifier state. void ReClicked(TObject* obj, UInt_t button, UInt_t state); Emit ReClicked signal with button id and modifier state. void UnClicked(TObject* obj, UInt_t button, UInt_t state); Emit UnClicked signal with button id and modifier state. void MouseIdle(TGLPhysical",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLViewer.html:32210,guid,guides,32210,root/html528/TGLViewer.html,https://root.cern,https://root.cern/root/html528/TGLViewer.html,4,['guid'],['guides']
Usability,"e title on window. void FitCanvas(); Fit canvas container to current window size. void PrintCanvas(); Print the canvas. void EventInfo(Int_t event, Int_t px, Int_t py, TObject* selected); Display a tooltip with infos about the primitive below the cursor. void ShowMenuBar(Bool_t show = kTRUE); Show or hide menubar. void ShowStatusBar(Bool_t show = kTRUE); Show or hide statusbar. void ShowEditor(Bool_t show = kTRUE); Show or hide side frame. void CreateEditor(); Create embedded editor. void ShowToolBar(Bool_t show = kTRUE); Show or hide toolbar. void ShowToolTips(Bool_t show = kTRUE); Enable or disable tooltip info. Bool_t HasEditor() const; Returns kTRUE if the editor is shown. Bool_t HasMenuBar() const; Returns kTRUE if the menu bar is shown. Bool_t HasStatusBar() const; Returns kTRUE if the status bar is shown. Bool_t HasToolBar() const; Returns kTRUE if the tool bar is shown. Bool_t HasToolTips() const; Returns kTRUE if the tooltips are enabled. void AdjustSize(); Keep the same canvas size while docking/undocking toolbar. Bool_t HandleContainerButton(Event_t* ev); Handle mouse button events in the canvas container. Bool_t HandleContainerDoubleClick(Event_t* ev); Handle mouse button double click events in the canvas container. Bool_t HandleContainerConfigure(Event_t* ev); Handle configure (i.e. resize) event. Bool_t HandleContainerKey(Event_t* ev); Handle keyboard events in the canvas container. Bool_t HandleContainerMotion(Event_t* ev); Handle mouse motion event in the canvas container. Bool_t HandleContainerExpose(Event_t* ev); Handle expose events. Bool_t HandleContainerCrossing(Event_t* ev); Handle enter/leave events. Only leave is activated at the moment. Bool_t HandleDNDDrop(TDNDData* data); Handle drop events. Atom_t HandleDNDPosition(Int_t x, Int_t y, Atom_t action, Int_t xroot, Int_t yroot); Handle dragging position events. Atom_t HandleDNDEnter(Atom_t* typelist); Handle drag enter events. Bool_t HandleDNDLeave(); Handle drag leave events. TRootCanvas(cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRootCanvas.html:27732,undo,undocking,27732,root/html528/TRootCanvas.html,https://root.cern,https://root.cern/root/html528/TRootCanvas.html,4,['undo'],['undocking']
Usability,"e title on window. void FitCanvas(); Fit canvas container to current window size. void PrintCanvas(); Print the canvas. void EventInfo(Int_t event, Int_t px, Int_t py, TObject* selected); Display a tooltip with infos about the primitive below the cursor. void ShowMenuBar(Bool_t show = kTRUE); Show or hide menubar. void ShowStatusBar(Bool_t show = kTRUE); Show or hide statusbar. void ShowEditor(Bool_t show = kTRUE); Show or hide side frame. void CreateEditor(); Create embedded editor. void ShowToolBar(Bool_t show = kTRUE); Show or hide toolbar. void ShowToolTips(Bool_t show = kTRUE); Enable or disable tooltip info. Bool_t HasEditor() const; Returns kTRUE if the editor is shown. Bool_t HasMenuBar() const; Returns kTRUE if the menu bar is shown. Bool_t HasStatusBar() const; Returns kTRUE if the status bar is shown. Bool_t HasToolBar() const; Returns kTRUE if the tool bar is shown. Bool_t HasToolTips() const; Returns kTRUE if the tooltips are enabled. void AdjustSize(); Keep the same canvas size while docking/undocking toolbar. Bool_t HandleContainerButton(Event_t* ev); Handle mouse button events in the canvas container. Bool_t HandleContainerDoubleClick(Event_t* ev); Handle mouse button double click events in the canvas container. Bool_t HandleContainerConfigure(Event_t* ev); Handle configure (i.e. resize) event. Bool_t HandleContainerKey(Event_t* ev); Handle keyboard events in the canvas container. Bool_t HandleContainerMotion(Event_t* ev); Handle mouse motion event in the canvas container. Bool_t HandleContainerExpose(Event_t* ev); Handle expose events. Bool_t HandleContainerCrossing(Event_t* ev); Handle enter/leave events. Only leave is activated at the moment. Bool_t HandleDNDDrop(TDNDData* data); Handle drop events. Atom_t HandleDNDPosition(Int_t x, Int_t y, Atom_t action, Int_t xroot, Int_t yroot); Handle dragging position events. Atom_t HandleDNDEnter(Atom_t* typelist); Handle drag enter events. Bool_t HandleDNDLeave(); Handle drag leave events. void Activated(I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TRootCanvas.html:28003,undo,undocking,28003,root/html534/TRootCanvas.html,https://root.cern,https://root.cern/root/html534/TRootCanvas.html,6,['undo'],['undocking']
Usability,"e traversed backwards and upwards performing undo and redo operations. To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);; TQCommand::TQUndoManagerfriend class TQUndoManagerDefinition TQCommand.h:29; TQUndoManagerRecorder of operations for undo and redo.Definition TQCommand.h:103; TQUndoManager::Addvoid Add(TObject *obj, Option_t *opt) overrideAdd command to the stack of commands.Definition TQCommand.cxx:959; TQUndoManager::Add automatically invokes execution of command's Redo method. Use TQUndoManager::Undo to undo commands in history list. Redo is Undo for undo action. Use TQUndoManager::Redo method for that ; Definition at line 27 of file TQCommand.h. Public Member Functions;  TQCommand (const char *cl=nullptr, void *object=nullptr, const char *redo=nullptr, const char *undo=nullptr);  Constructor. ;  ;  TQCommand (const TQCommand &com);  Copy constructor. ;  ;  TQCommand (TObject *obj, const char *redo=nullptr, const char *undo=nullptr);  Constructor. ;  ; virtual ~TQCommand ();  dtor. ;  ; void Add (TObject *obj) override;  ; void Add (TObject *obj, Option_t *opt) override;  Add command to the list of merged commands. ;  ; virtual Bool_t CanCompress (TQCommand *c) const;  By default, commands can be compressed if they are: ;  ; virtual Bool_t CanMerge (TQCommand *c) const;  Two commands can be merged if they can be composed into a single command (Macro command). ;  ; virtual Bool_t CanRedo () const;  Returns kTRUE if Redo action is possible, kFALSE if it's not. ;  ; virtual Bool_t CanUndo () const;  Returns kTRUE if Undo action is possible, kFALSE if it's not. ;  ; virtual void Compress (TQCommand *c);  Compress command. ;  ; void Delete (Option_t *option="""") override;  If ""opt"" is not zero delete every merged command which option string is equal to ""opt"". ;  ; const char * GetName () const override;  Returns the command name. ;  ; Int_t GetNRargs () const;  Returns a number of redo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:4959,undo,undo,4959,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['undo'],['undo']
Usability,"e two ways to do this. You can set the NDC for one object or may convert NDC to user coordinates. Most graphical objects offer an option to be drawn in NDC. For instance, a line (TLine) may be drawn in NDC by using DrawLineNDC(). A latex formula or a text may use TText::SetNDC() to be drawn in NDC coordinates.; 9.3.3 Converting between Coordinate Systems; There are a few utility functions in TPad to convert from one system of coordinates to another. In the following table, a point is defined by (px,py) in pixel coordinates, (ux,uy) in user coordinates, (ndcx,ndcy) in normalized coordinates, (apx, apy) are in absolute pixel coordinates. Conversion; TPad’s Methods; Returns. NDC to Pixel; UtoPixel(ndcx); VtoPixel(ndcy); Int_t; Int_t. Pixel to User; PixeltoX(px); PixeltoY(py); PixeltoXY(px,py,&ux,&uy); Double_t; Double_t; Double_t ux,uy. User to Pixel; XtoPixel(ux); YtoPixel(uy); XYtoPixel(ux,uy,&px,&py); Int_t; Int_t; Int_t px,py. User to absolute pixel; XtoAbsPixel(ux); YtoAbsPixel(uy); XYtoAbsPixel(ux,uy,&apx,&apy); Int_t; Int_t; Int_t apx,apy. Absolute pixel to user; AbsPixeltoX(apx); AbsPixeltoY(apy); AbsPixeltoXY(apx,apy,&ux,&uy); Double_t; Double_t; Double_t ux,uy. Note: all the pixel conversion functions along the Y axis consider that py=0 is at the top of the pad except PixeltoY() which assume that the position py=0 is at the bottom of the pad. To make PixeltoY() converting the same way as the other conversion functions, it should be used the following way (p is a pointer to a TPad):; p->PixeltoY(py - p->GetWh());; 9.3.4 Dividing a Pad into Sub-pads; Dividing a pad into sub pads in order for instance to draw a few histograms, may be done in two ways. The first is to build pad objects and to draw them into a parent pad, which may be a canvas. The second is to automatically divide a pad into horizontal and vertical sub pads.; 9.3.4.1 Creating a Single Sub-pad; The simplest way to divide a pad is to build sub-pads in it. However, this forces the user to explicitly",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:310996,ux,ux,310996,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['ux'],['ux']
Usability,"e type; NMED Tracking medium number; NPAR Number of shape parameters; UPAR Vector containing shape parameters. TGeoVolume * Volume(const char* name, const char* shape, Int_t nmed, Double_t* upar, Int_t npar = 0); Create a volume in GEANT3 style.; NAME Volume name; SHAPE Volume type; NMED Tracking medium number; NPAR Number of shape parameters; UPAR Vector containing shape parameters. void SetAllIndex(); Assigns uid's for all materials,media and matrices. void ClearAttributes(); Reset all attributes to default ones. Default attributes for visualization; are those defined before closing the geometry. void CloseGeometry(Option_t* option = ""d""); Closing geometry implies checking the geometry validity, fixing shapes; with negative parameters (run-time shapes)building the cache manager,; voxelizing all volumes, counting the total number of physical nodes and; registring the manager class to the browser. void ClearOverlaps(); Clear the list of overlaps. void ClearShape(const TGeoShape* shape); Remove a shape from the list of shapes. void CleanGarbage(); Clean temporary volumes and shapes from garbage collection. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). Int_t GetCurrentNodeId() const; Get the unique ID of the current node. void CdTop(); Make top level node the current node. Updates the cache accordingly.; Determine the overlapping state of current node. void CdUp(); Go one level up in geometry. Updates cache accordingly.; Determine the overlapping state of current node. void CdDown(Int_t index); Make a daughter of current node current. Can be called only with a valid; daughter index (no check). Updates cache accordingly. void CdNext(); Do a cd to the node found next by FindNextBoundary. Bool_t cd(const char* path = """"); Browse the tree of nodes starting from fTopNode according to pathname.; Changes the path accordingly. Bool_t CheckPath(const char* path",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoManager.html:45191,Clear,ClearShape,45191,root/html532/TGeoManager.html,https://root.cern,https://root.cern/root/html532/TGeoManager.html,4,['Clear'],['ClearShape']
Usability,"e user is trying to set types only of existing columns; 363 ValidateColTypes(columns);; 364 ; 365 // Infer types of columns with first record; 366 InferColTypes(columns);; 367 ; 368 // rewind; 369 fCsvFile->Seek(fDataPos);; 370 } else {; 371 std::string msg = ""Could not infer column types of CSV file "";; 372 msg += fileName;; 373 throw std::runtime_error(msg);; 374 }; 375}; 376 ; 377void RCsvDS::FreeRecords(); 378{; 379 for (auto &record : fRecords) {; 380 for (size_t i = 0; i < record.size(); ++i) {; 381 void *p = record[i];; 382 const auto colType = fColTypes[fHeaders[i]];; 383 switch (colType) {; 384 case 'D': {; 385 delete static_cast<double *>(p);; 386 break;; 387 }; 388 case 'L': {; 389 delete static_cast<Long64_t *>(p);; 390 break;; 391 }; 392 case 'O': {; 393 delete static_cast<bool *>(p);; 394 break;; 395 }; 396 case 'T': {; 397 delete static_cast<std::string *>(p);; 398 break;; 399 }; 400 }; 401 }; 402 }; 403 fRecords.clear();; 404}; 405 ; 406////////////////////////////////////////////////////////////////////////; 407/// Destructor.; 408RCsvDS::~RCsvDS(); 409{; 410 FreeRecords();; 411}; 412 ; 413void RCsvDS::Finalize(); 414{; 415 fCsvFile->Seek(fDataPos);; 416 fProcessedLines = 0ULL;; 417 fEntryRangesRequested = 0ULL;; 418 FreeRecords();; 419}; 420 ; 421const std::vector<std::string> &RCsvDS::GetColumnNames() const; 422{; 423 return fHeaders;; 424}; 425 ; 426std::vector<std::pair<ULong64_t, ULong64_t>> RCsvDS::GetEntryRanges(); 427{; 428 // Read records and store them in memory; 429 auto linesToRead = fLinesChunkSize;; 430 FreeRecords();; 431 ; 432 std::string line;; 433 while ((-1LL == fLinesChunkSize || 0 != linesToRead) && fCsvFile->Readln(line)) {; 434 if (line.empty()) continue; // skip empty lines; 435 fRecords.emplace_back();; 436 FillRecord(line, fRecords.back());; 437 --linesToRead;; 438 }; 439 ; 440 if (!fColContainingEmpty.empty()) {; 441 std::string msg = """";; 442 for (const auto &col : fColContainingEmpty) {; 443 const auto colT = GetTypeName(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RCsvDS_8cxx_source.html:13952,clear,clear,13952,doc/master/RCsvDS_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RCsvDS_8cxx_source.html,1,['clear'],['clear']
Usability,"e width; TStringTGMainFrame::fWindowNamewindow name; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fCancelcancel button; TGTextButton*fOkok button; char*fStrcutsaddress to store cuts string; char*fStrvarsaddress to store variables string; TGTextEntry*fTECutstext entry widget for cuts; TGTextEntry*fTEVarstext entry widget for variables. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeInput(const TGWindow* p, const TGWindow* main, char* strvars, char* strcuts); Create simple input dialog. ~TTreeInput(); Cleanup dialog. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t ); Handle button and text enter events. TTreeInput(const TTreeInput& ). TTreeInput & operator=(const TTreeInput& ). » Author: David Gonzalez Maline 21/10/2008 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TTreeInput.h 26245 2008-11-17 16:32:49Z moneta $ » Last generated: 2010-09-23 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeInput.html:22077,simpl,simple,22077,root/html528/TTreeInput.html,https://root.cern,https://root.cern/root/html528/TTreeInput.html,1,['simpl'],['simple']
Usability,"e width; TStringTGMainFrame::fWindowNamewindow name; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fCancelcancel button; TGTextButton*fOkok button; char*fStrcutsaddress to store cuts string; char*fStrvarsaddress to store variables string; TGTextEntry*fTECutstext entry widget for cuts; TGTextEntry*fTEVarstext entry widget for variables. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeInput(const TGWindow* p, const TGWindow* main, char* strvars, char* strcuts); Create simple input dialog. ~TTreeInput(); Cleanup dialog. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t ); Handle button and text enter events. TTreeInput(const TTreeInput& ). TTreeInput & operator=(const TTreeInput& ). » Author: David Gonzalez Maline 21/10/2008 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TTreeInput.h 26245 2008-11-17 16:32:49Z moneta $ » Last generated: 2011-07-04 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTreeInput.html:22230,simpl,simple,22230,root/html530/TTreeInput.html,https://root.cern,https://root.cern/root/html530/TTreeInput.html,1,['simpl'],['simple']
Usability,"e width; TStringTGMainFrame::fWindowNamewindow name; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fCancelcancel button; TGTextButton*fOkok button; char*fStrcutsaddress to store cuts string; char*fStrvarsaddress to store variables string; TGTextEntry*fTECutstext entry widget for cuts; TGTextEntry*fTEVarstext entry widget for variables. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeInput(const TGWindow* p, const TGWindow* main, char* strvars, char* strcuts); Create simple input dialog. ~TTreeInput(); Cleanup dialog. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t ); Handle button and text enter events. TTreeInput(const TTreeInput& ). TTreeInput & operator=(const TTreeInput& ). » Author: David Gonzalez Maline 21/10/2008 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TTreeInput.h 26245 2008-11-17 16:32:49Z moneta $ » Last generated: 2011-11-03 20:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreeInput.html:22230,simpl,simple,22230,root/html532/TTreeInput.html,https://root.cern,https://root.cern/root/html532/TTreeInput.html,2,['simpl'],['simple']
Usability,"e window. The objects/widgets receive the events and react to them according to the application functionality. The signals/slot communication mechanism is an advanced object communication concept; it largely replaces the concept of callback functions to handle actions in GUI’s. Signals and slots are just like any object-oriented methods implemented in C++. The objects are the instances of classes that don’t know anything about each other. They interact and allow method calls of other object’s methods. The idea is simple: any object can send out (emit) a signal in certain situations saying that something happened. This is all it does to communicate and it does not know whether anything is interested in this information. On the other side there might be an object waiting for that signal and ready to react to it. This object disposes of special instruments to listen to the sent out signals. To have a communication we need a message transmission between the objects. In this simple example we use signals and slots. The code of the method TGButton::Clicked() is:; virtual void Clicked() { Emit(""Clicked()""); } // *SIGNAL*; I.e. any button emits the signal Clicked() any time someone clicks on it. As you can see this method is virtual and could be overridden if you need to. In our simple example we call the Connect() method to connect the Clicked() signal of Draw button with MyMainFrame::DoDraw():; draw->Connect(""Clicked()"",""MyMainFrame"",this,""DoDraw()"");; In the same way we can connect to the signal Clicked() of the Exit button with the system call gApplication->Terminate(0). We declare a new slot DoExit(), implement it to invoke the termination call and associate this slot with the signal Clicked() of the Exit button.; The code of example.C can be changed as follows:; public:; ...; void DoExit(); // a new slot is added; }; void MyMainFrame::DoExit() {; gApplication->Terminate(0);; }; MyMainFrame::MyMainFrame(const TGWindow *p,UInt_t w,UInt_t h) {; ...; TGTextButton *exit = n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1164071,simpl,simple,1164071,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"e y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTranslationEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for translation editor. ~TGeoTranslationEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the new matrix. void DoName(); Slot for name. Bool_t DoParameters(); Slot for checking parameters. void DoApply(); Slot for applying changes. void DoCancel(); Slot for cancelling last modifications non-applied. void DoModified(); Slot for notifying changes. void DoUndo(); Slot for undoing last operation. void DoDx(); Slot for dx. void DoDy(); Slot for dx. void DoDz(); Slot for dx. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoMatrixEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoTranslationEditor.html:21285,undo,undoing,21285,root/html528/TGeoTranslationEditor.html,https://root.cern,https://root.cern/root/html528/TGeoTranslationEditor.html,1,['undo'],['undoing']
Usability,"e y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTranslationEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for translation editor. ~TGeoTranslationEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the new matrix. void DoName(); Slot for name. Bool_t DoParameters(); Slot for checking parameters. void DoApply(); Slot for applying changes. void DoCancel(); Slot for cancelling last modifications non-applied. void DoModified(); Slot for notifying changes. void DoUndo(); Slot for undoing last operation. void DoDx(); Slot for dx. void DoDy(); Slot for dx. void DoDz(); Slot for dx. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoMatrixEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoTranslationEditor.html:21385,undo,undoing,21385,root/html530/TGeoTranslationEditor.html,https://root.cern,https://root.cern/root/html530/TGeoTranslationEditor.html,1,['undo'],['undoing']
Usability,"e y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTranslationEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for translation editor. ~TGeoTranslationEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the new matrix. void DoName(); Slot for name. Bool_t DoParameters(); Slot for checking parameters. void DoApply(); Slot for applying changes. void DoCancel(); Slot for cancelling last modifications non-applied. void DoModified(); Slot for notifying changes. void DoUndo(); Slot for undoing last operation. void DoDx(); Slot for dx. void DoDy(); Slot for dx. void DoDz(); Slot for dx. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoMatrixEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoTranslationEditor.html:21385,undo,undoing,21385,root/html532/TGeoTranslationEditor.html,https://root.cern,https://root.cern/root/html532/TGeoTranslationEditor.html,2,['undo'],['undoing']
Usability,"e(). static const char * TMethodArg::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMethodArg::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 64 of file TMethodArg.h. ◆ DeclFileName(). static const char * TMethodArg::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 64 of file TMethodArg.h. ◆ GetDataMember(). TDataMember * TMethodArg::GetDataMember ; (; ); const. Returns TDataMember pointed by this methodarg. ; If you want to specify list of options or current value for your MethodArg (i.e. it is used as initial values in argument-asking dialogs popped up from context-meny),you can get this value from one of data members of the class.; The only restriction is, that this DataMember object must have its Getter/Setter methods set-up correctly - for details look at TDataMember. To learn how to specify the data member to which the argument should ""point"", look at TMethod. This is TMethod which sets up fDataMember, so it could work correctly. ; Definition at line 128 of file TMethodArg.cxx. ◆ GetDefault(). const char * TMethodArg::GetDefault ; (; ); const. Get default value of method argument. ; Definition at line 57 of file TMethodArg.cxx. ◆ GetFullTypeName(). const char * TMethodArg::GetFullTypeName ; (; ); const. Get full type description of method argument, e.g.: ""class TDirectory*"". ; Definition at line 74 of file TMethodArg.cxx. ◆ GetMethod(). TFunction * TMethodArg::GetMethod ; (; ); const. inline . Definition at line 52 of file TMethodArg.h. ◆ GetOptions(). TList * TMethodArg::GetOptions ; (; ); const. Returns list of possible options - according to pointed datamember. ; If there is no datamember field assigned to this methodarg - returns 0. ; Definition at line 110 of file TMethodArg.cxx. ◆ GetTypeInfo(). TypeInfo_t * TMethodArg::GetTypeInfo ; (; ); const. Get the TypeInfo of the method argument. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMethodArg.html:16379,learn,learn,16379,doc/master/classTMethodArg.html,https://root.cern,https://root.cern/doc/master/classTMethodArg.html,1,['learn'],['learn']
Usability,"e(). void TProof::SetActive ; (; Bool_t ; = kTRUE). inline . Definition at line 988 of file TProof.h. ◆ SetAlias(). void TProof::SetAlias ; (; const char * ; alias = """"). virtual . Set an alias for this session. ; If reconnection is supported, the alias will be communicated to the remote coordinator so that it can be recovered when reconnecting ; Definition at line 10583 of file TProof.cxx. ◆ SetDataPoolUrl(). void TProof::SetDataPoolUrl ; (; const char * ; url). inline . Definition at line 1044 of file TProof.h. ◆ SetDataSetTreeName(). Int_t TProof::SetDataSetTreeName ; (; const char * ; dataset, . const char * ; treename . ). virtual . Set/Change the name of the default tree. ; The tree name may contain subdir specification in the form ""subdir/name"". Returns 0 on success, -1 otherwise. ; Reimplemented in TProofLite.; Definition at line 10766 of file TProof.cxx. ◆ SetDrawFeedbackOption(). void TProof::SetDrawFeedbackOption ; (; TDrawFeedback * ; f, . Option_t * ; opt . ). Set draw feedback option. ; Definition at line 10102 of file TProof.cxx. ◆ SetDSet(). void TProof::SetDSet ; (; TDSet * ; dset). inlineprotected . Definition at line 737 of file TProof.h. ◆ SetFeedback(). void TProof::SetFeedback ; (; TString & ; opt, . TString & ; optfb, . Int_t ; action . ). protected . Extract from opt in optfb information about wanted feedback settings. ; Feedback are removed from the input string opt. If action == 0, set up feedback accordingly, if action == 1 clean related feedback settings (using info in optfb, if available, or reparsing opt).; Feedback requirements are in the form <previous_option>fb=name1,name2,name3,... <next_option>; <previous_option>feedback=name1,name2,name3,...;<next_option>; The special name 'stats' triggers feedback about events and packets. The separator from the next option is either a ' ' or a ';'. Called interanally by TProof::Process. ; Definition at line 5232 of file TProof.cxx. ◆ SetInputDataFile(). void TProof::SetInputDataFile ; (; const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:142371,feedback,feedback,142371,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['feedback'],['feedback']
Usability,"e(); TFile(const char* fname, Option_t* option = """", const char* ftitle = """", Int_t compress = 1); virtual~TFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidTDirectoryFile::Append(TObject* obj, Bool_t replace = kFALSE); virtual Int_tTDirectoryFile::AppendKey(TKey* key); virtual voidTObject::AppendPad(Option_t* option = """"); static TFileOpenHandle*AsyncOpen(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); virtual voidTDirectoryFile::Browse(TBrowser* b); virtual voidTDirectoryFile::Build(TFile* motherFile = 0, TDirectory* motherDir = 0); virtual Bool_tTDirectoryFile::cd(const char* path = 0); static Bool_tTDirectory::Cd(const char* path); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTDirectory::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TObject*TDirectoryFile::CloneObject(const TObject* obj, Bool_t autoadd = kTRUE); virtual voidClose(Option_t* option = """")MENU ; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(TObject&) const; virtual Bool_tCp(const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); static Bool_tCp(const char* src, const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); virtual TKey*CreateKey(TDirectory* mother, const TObject* obj, const char* name, Int_t bufsize); virtual TKey*CreateKey(TDirectory* mother, const void* obj, const TClass* cl, const char* name, Int_t bufsize); static TDirectory*&TDirectory::CurrentDirectory(); static TFile*&CurrentFile(); static voidTDirectory::DecodeNameCycle(const char* namecycle, char* name, Short_t& cycle); virtual voidDelete(const char* namecycle = """"); virtual voidTDirectory::DeleteAll(Option_t* option = """")",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TFile.html:3357,Clear,Clear,3357,root/html532/TFile.html,https://root.cern,https://root.cern/root/html532/TFile.html,1,['Clear'],['Clear']
Usability,"e(); TFile(const char* fname, Option_t* option = """", const char* ftitle = """", Int_t compress = 1); virtual~TFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidTDirectoryFile::Append(TObject* obj, Bool_t replace = kFALSE); virtual Int_tTDirectoryFile::AppendKey(TKey* key); virtual voidTObject::AppendPad(Option_t* option = """"); static TFileOpenHandle*AsyncOpen(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); virtual voidTDirectoryFile::Browse(TBrowser* b); virtual voidTDirectoryFile::Build(TFile* motherFile = 0, TDirectory* motherDir = 0); virtual Bool_tTDirectoryFile::cd(const char* path = 0); static Bool_tTDirectory::Cd(const char* path); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTDirectory::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TObject*TDirectoryFile::CloneObject(const TObject* obj, Bool_t autoadd = kTRUE); virtual voidClose(Option_t* option = """")MENU ; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(TObject&) const; virtual Bool_tCp(const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); static Bool_tCp(const char* src, const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); virtual TKey*CreateKey(TDirectory* mother, const TObject* obj, const char* name, Int_t bufsize); virtual TKey*CreateKey(TDirectory* mother, const void* obj, const TClass* cl, const char* name, Int_t bufsize); static TDirectory*&TDirectory::CurrentDirectory(); static TFile*&CurrentFile(); static voidTDirectory::DecodeNameCycle(const char* namecycle, char* name, Short_t& cycle, const size_t namesize = 0); virtual voidDelete(const char* namecycle = """"); virtual voidTDirectory::Delet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFile.html:3357,Clear,Clear,3357,root/html534/TFile.html,https://root.cern,https://root.cern/root/html534/TFile.html,1,['Clear'],['Clear']
Usability,"e(); Update gui builder. Bool_t IsSelectMode() const; Return the status of the selected mode. Bool_t IsGrabButtonDown() const; Return the status of the grab mode. Bool_t HandleKey(Event_t* event); Handle keys. Bool_t NewProject(TString type = """"); Create a new project. Bool_t OpenProject(Event_t* event = 0); Open new gui builder project. Bool_t SaveProject(Event_t* event = 0); Save selected project. void AddMacro(const char* macro, TImage* img); Add macro to ""User's Macros"" section; Input img must be static - do not delete it. TGMdiFrame * FindEditableMdiFrame(const TGWindow* win); Find the editable frame. void SwitchToolbarButton(); Switch image of toolbar edit button according to the current state. void HandleMenu(Int_t id); Handle menu items. void MaybeCloseWindow(); Handler before closing MDI frame. void HandleWindowClosed(Int_t id); Handler for closed MDI frame. void UpdateStatusBar(const char* text = 0); Update information shown on the status bar. void EraseStatusBar(); Clear information shown in the status bar. void BindKeys(); Keyborad key binding. TGFrame * VSplitter(); Create new vertical splitter (TGVSplitter). TGFrame * HSplitter(); Creates new horizontal splitter (TGHSplitter). void Hide(); Hide builder. ULong_t GetBgnd(); Return default background color. void PropagateBgndColor(TGFrame* frame, Pixel_t color); Set a background color to frame and all its subframes. ULong_t GetPopupBgnd(); Return background color for popup menus. ULong_t GetPopupHlght(); Return highlighted color for popup menu entry. TGPopupMenu * CreatePopup(); Return style popup menu. TGFrame * BuildListTree(); Helper method used in guibuilding. TGFrame * BuildCanvas(); Helper method used in guibuilding to create TGCanvas widget. TGFrame * BuildShutter(); Helper method used in guibuilding to create TGShutter widget. TGFrame * BuildTextEdit(); Helper method to create TGTextEdit widget. TGFrame * BuildTab(); Helper method to create TGTab widget. TGFrame * BuildListBox(); Helper method to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TRootGuiBuilder.html:28754,Clear,Clear,28754,root/html532/TRootGuiBuilder.html,https://root.cern,https://root.cern/root/html532/TRootGuiBuilder.html,4,['Clear'],['Clear']
Usability,"e(const TStreamerInfoActions::TActionSequence& sequence, void* object); virtual Int_tApplySequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); virtual Int_tApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); voidAutoExpand(Int_t size_needed); virtual voidTObject::Browse(TBrowser* b); char*Buffer() const; Int_tBufferSize() const; virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); virtual Bool_tCheckObject(const TObject* obj); virtual Bool_tCheckObject(const void* obj, const TClass* ptrClass); static TClass*Class(); virtual voidClassBegin(const TClass*, Version_t = -1); virtual voidClassEnd(const TClass*); virtual voidClassMember(const char*, const char* = 0, Int_t = -1, Int_t = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExpand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TBuffer.html:1658,Clear,Clear,1658,root/html532/TBuffer.html,https://root.cern,https://root.cern/root/html532/TBuffer.html,4,['Clear'],['Clear']
Usability,"e(const char* url, Option_t* option = """", const char* ftitle = """", Int_t compress = 1); virtual~TRFIOFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidTDirectoryFile::Append(TObject* obj, Bool_t replace = kFALSE); virtual Int_tTDirectoryFile::AppendKey(TKey* key); virtual voidTObject::AppendPad(Option_t* option = """"); static TFileOpenHandle*TFile::AsyncOpen(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); virtual voidTDirectoryFile::Browse(TBrowser* b); virtual voidTDirectoryFile::Build(TFile* motherFile = 0, TDirectory* motherDir = 0); virtual Bool_tTDirectoryFile::cd(const char* path = 0); static Bool_tTDirectory::Cd(const char* path); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTDirectory::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TObject*TDirectoryFile::CloneObject(const TObject* obj, Bool_t autoadd = kTRUE); virtual voidTFile::Close(Option_t* option = """")MENU ; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTFile::Copy(TObject&) const; virtual Bool_tTFile::Cp(const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); static Bool_tTFile::Cp(const char* src, const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); virtual TKey*TFile::CreateKey(TDirectory* mother, const TObject* obj, const char* name, Int_t bufsize); virtual TKey*TFile::CreateKey(TDirectory* mother, const void* obj, const TClass* cl, const char* name, Int_t bufsize); static TDirectory*&TDirectory::CurrentDirectory(); static TFile*&TFile::CurrentFile(); static voidTDirectory::DecodeNameCycle(const char* namecycle, char* name, Short_t& cycle); virtual voidTFile::Delete(const char* namecycle = """"); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TRFIOFile.html:2499,Clear,Clear,2499,root/html532/TRFIOFile.html,https://root.cern,https://root.cern/root/html532/TRFIOFile.html,1,['Clear'],['Clear']
Usability,"e(file, ""MyTree"");. Compiling; You can also have your code compiled into a shared library, simply by adding a ""+"" behind the file name:; .x printTree.C+(file, ""MyTree"");. In the above example this will fail: we need to add the #includes for he compiler to be able to understand the code, while the interpreter has a lot of contextual knowledge and can automatically include headers and load libraries.; Expressions; You saw that with "".x"", ROOT prints the result of running the function while when using "".L"" and calling th function it does not. The way to trigger the printing of expression results is by omitting the trailing semicolon:; TMath::Gaus(1., 1., 1.). will print; (Double_t) 1.000000e+00. Help!; For TMath::Gaus() as well as for any other ROOT class or function, please check ROOT's reference guide.; Try to find the documentation for TTree::Print()!; We have now covered the basics - let's look at the tree's data!; . ‹ 1. Extracting an object from a TFile; up; 4. Histogramming ›. Navigate through this book; 0. Setting up ROOT; 1. Extracting an object from a TFile; 2. Running code in ROOT; 4. Histogramming; 3. Examining a TTree's data; 5. Fitting; 6. Multivariate Analysis; 7. Using the TTreeReader; 8. Efficiency Calculation; 9. Fitting By Coding; 10. Go Parallel!; TutorialSelector.C; 11. Done!. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/2-running-code-root.html:4058,guid,guidelines,4058,d/2-running-code-root.html,https://root.cern,https://root.cern/d/2-running-code-root.html,1,['guid'],['guidelines']
Usability,"e); Set an input list parameter. void SetParameter(const char* par, Long_t value); Set an input list parameter. void SetParameter(const char* par, Long64_t value); Set an input list parameter. void SetParameter(const char* par, Double_t value); Set an input list parameter. TObject * GetParameter(const char* par) const; Get specified parameter. A parameter set via SetParameter() is either; a TParameter or a TNamed or 0 in case par is not defined. void DeleteParameters(const char* wildcard); Delete the input list parameters specified by a wildcard (e.g. PROOF_*); or exact name (e.g. PROOF_MaxSlavesPerNode). void ShowParameters(const char* wildcard = ""PROOF_*"") const; Show the input list parameters specified by the wildcard.; Default is the special PROOF control parameters (PROOF_*). void AddFeedback(const char* name); Add object to feedback list. void RemoveFeedback(const char* name); Remove object from feedback list. void ClearFeedback(); Clear feedback list. void ShowFeedback() const; Show items in feedback list. TList * GetFeedbackList() const; Return feedback list. TTree * GetTreeHeader(TDSet* tdset); Creates a tree header (a tree with nonexisting files) object for; the DataSet. TDrawFeedback * CreateDrawFeedback(); Draw feedback creation proxy. When accessed via TProof avoids; link dependency on libProofPlayer. void SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); Set draw feedback option. void DeleteDrawFeedback(TDrawFeedback* f); Delete draw feedback object. TList * GetOutputNames(); FIXME: to be written. void Browse(TBrowser* b); Build the PROOF's structure in the browser. void SetPlayer(TVirtualProofPlayer* player); Set a new PROOF player. TVirtualProofPlayer * MakePlayer(const char* player = 0, TSocket* s = 0); Construct a TProofPlayer object. The player string specifies which; player should be created: remote, slave, sm (supermaster) or base.; Default is remote. Socket is needed in case a slave player is created. void AddChain(TChain* chain); Add cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:74743,feedback,feedback,74743,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,10,['feedback'],['feedback']
Usability,"e); result = fitter.Result(); result.Print(ROOT.std.cout); ; c1 = ROOT.TCanvas(""Simfit"", ""Simultaneous fit of two histograms"", 10, 10, 700, 700); c1.Divide(1, 2); c1.cd(1); ROOT.gStyle.SetOptFit(1111); ; fB.SetFitResult(result, iparB); fB.SetRange(rangeB().first, rangeB().second); fB.SetLineColor(ROOT.kBlue); hB.GetListOfFunctions().Add(fB); hB.Draw(); ; c1.cd(2); fSB.SetFitResult(result, iparSB); fSB.SetRange(rangeSB().first, rangeSB().second); fSB.SetLineColor(ROOT.kRed); hSB.GetListOfFunctions().Add(fSB); hSB.Draw(); ; c1.SaveAs(""combinedFit.png""); ROOT::Fit::BinDataClass describing the binned data sets : vectors of x coordinates, y values and optionally error on y ...Definition BinData.h:52; ROOT::Fit::Chi2FCNChi2FCN class for binned fits using the least square methods.Definition Chi2FCN.h:46; ROOT::Fit::DataRangeclass describing the range in the coordinates it supports multiple range in a coordinate.Definition DataRange.h:35; ROOT::Fit::FitterFitter class, entry point for performing all type of fits.Definition Fitter.h:77; ROOT::Math::FunctorDocumentation for class Functor class.Definition Functor.h:47; ROOT::Math::WrappedMultiTF1TemplClass to Wrap a ROOT Function class (like TF1) in a IParamMultiFunction interface of multi-dimensions...Definition WrappedMultiTF1.h:48; object; ROOT::Fit::FillDatavoid FillData(BinData &dv, const TH1 *hist, TF1 *func=nullptr)fill the data vector from a TH1.Definition HFitInterface.cxx:107; TMatrixTAutoloadOps::AddTMatrixT< Element > & Add(TMatrixT< Element > &target, Element scalar, const TMatrixT< Element > &source)Modify addition: target += scalar * source.Definition TMatrixT.cxx:2936; ROOT::Fit::DataOptionsDataOptions : simple structure holding the options on how the data are filled.Definition DataOptions.h:28; AuthorJonas Rembser, Lorenzo Moneta (C++ version) ; Definition in file combinedFit.py. tutorialsfitcombinedFit.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/combinedFit_8py.html:5022,simpl,simple,5022,doc/master/combinedFit_8py.html,https://root.cern,https://root.cern/doc/master/combinedFit_8py.html,1,['simpl'],['simple']
Usability,"e);; 1000 setup.Append('\n');; 1001 }; 1002 setup.Chop(); // trim final `\n`; 1003 return setup;; 1004}; 1005 ; 1006////////////////////////////////////////////////////////////////////////////////; 1007/// It opens a Forum topic in a web browser with prefilled ROOT version; 1008///; 1009/// \param[in] type the issue type (only bug supported right now); 1010 ; 1011void TApplication::OpenForumTopic(const TString &type); 1012{; 1013 // https://meta.discourse.org/t/how-to-create-a-post-clicking-a-link/96197; 1014 ; 1015 if (type == ""bug"") {; 1016 //OpenInBrowser(""\""https://root-forum.cern.ch/new-topic?title=topic%20title&body=topic%20body&category=category/subcategory&tags=email,planned\"""");; 1017 TString report_template =; 1018R""(___; 1019_Please read [tips for efficient and successful posting](https://root-forum.cern.ch/t/tips-for-efficient-and-successful-posting/28292) and [posting code](https://root-forum.cern.ch/t/posting-code-read-this-first/28293)_; 1020 ; 1021### Describe the bug; 1022<!--; 1023A clear and concise description of what the wrong behavior is.; 1024-->; 1025### Expected behavior; 1026<!--; 1027A clear and concise description of what you expected to happen.; 1028-->; 1029 ; 1030### To Reproduce; 1031<!--; 1032Steps to reproduce the behavior:; 10331. Your code that triggers the issue: at least a part; ideally something we can run ourselves.; 10342. Don't forget to attach the required input files!; 10353. How to run your code and / or build it, e.g. `root myMacro.C`, ...; 1036-->; 1037 ; 1038### Setup; 1039)""+GetSetup()+; 1040R""(; 1041<!--; 1042Please specify also how you obtained ROOT, such as `dnf install` / binary download / you built it yourself.; 1043-->; 1044 ; 1045### Additional context; 1046<!--; 1047Add any other context about the problem here.; 1048-->)"";; 1049 report_template = FormatHttpUrl(report_template);; 1050 ; 1051 OpenInBrowser(""\""https://root-forum.cern.ch/new-topic?category=ROOT&tags=bug&body=""+report_template+""&\"""");; 1052 } else ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:39109,clear,clear,39109,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,1,['clear'],['clear']
Usability,"e, const char *classname, void *addobj, Int_t bufsize=32000, Int_t splitlevel=1);  Create a new TTree BranchObject. ;  ; virtual TBranch * BranchRef ();  Build the optional branch supporting the TRefTable. ;  ; virtual TBranch * Bronch (const char *name, const char *classname, void *addobj, Int_t bufsize=32000, Int_t splitlevel=99);  Create a new TTree BranchElement. ;  ; void Browse (TBrowser *) override;  Browse content of the TTree. ;  ; virtual Int_t BuildIndex (const char *majorname, const char *minorname=""0"");  Build a Tree Index (default is TTreeIndex). ;  ; TStreamerInfo * BuildStreamerInfo (TClass *cl, void *pointer=nullptr, bool canOptimize=true);  Build StreamerInfo for class cl. ;  ; virtual TFile * ChangeFile (TFile *file);  Called by TTree::Fill() when file has reached its maximum fgMaxTreeSize. ;  ; virtual TTree * CloneTree (Long64_t nentries=-1, Option_t *option="""");  Create a clone of this tree and copy nentries. ;  ; virtual void CopyAddresses (TTree *, bool undo=false);  Set branch addresses of passed tree equal to ours. ;  ; virtual Long64_t CopyEntries (TTree *tree, Long64_t nentries=-1, Option_t *option="""", bool needCopyAddresses=false);  Copy nentries from given tree to this tree. ;  ; virtual TTree * CopyTree (const char *selection, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Copy a tree with selection. ;  ; virtual TBasket * CreateBasket (TBranch *);  Create a basket for this tree and given branch. ;  ; Int_t Debug () const;  ; void Delete (Option_t *option="""") override;  Delete this tree from memory or/and disk. ;  ; virtual void DirectoryAutoAdd (TDirectory *);  Called by TKey and TObject::Clone to automatically add us to a directory when we are read from a file. ;  ; virtual Long64_t Draw (const char *varexp, const char *selection, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Draw expression varexp for entries and objects that pass a (optional) selection. ;  ; virtual Long6",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:23908,undo,undo,23908,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,4,['undo'],['undo']
Usability,"e, const char *classname, void *addobj, Int_t bufsize=32000, Int_t splitlevel=1);  Create a new TTree BranchObject. ;  ; virtual TBranch * BranchRef ();  Build the optional branch supporting the TRefTable. ;  ; virtual TBranch * Bronch (const char *name, const char *classname, void *addobj, Int_t bufsize=32000, Int_t splitlevel=99);  Create a new TTree BranchElement. ;  ; void Browse (TBrowser *) override;  Browse content of the TTree. ;  ; virtual Int_t BuildIndex (const char *majorname, const char *minorname=""0"");  Build a Tree Index (default is TTreeIndex). ;  ; TStreamerInfo * BuildStreamerInfo (TClass *cl, void *pointer=nullptr, bool canOptimize=true);  Build StreamerInfo for class cl. ;  ; virtual TFile * ChangeFile (TFile *file);  Called by TTree::Fill() when file has reached its maximum fgMaxTreeSize. ;  ; virtual TTree * CloneTree (Long64_t nentries=-1, Option_t *option="""");  Create a clone of this tree and copy nentries. ;  ; virtual void CopyAddresses (TTree *, bool undo=false);  Set branch addresses of passed tree equal to ours. ;  ; virtual Long64_t CopyEntries (TTree *tree, Long64_t nentries=-1, Option_t *option="""", bool needCopyAddresses=false);  Copy nentries from given tree to this tree. ;  ; virtual TTree * CopyTree (const char *selection, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Copy a tree with selection. ;  ; virtual TBasket * CreateBasket (TBranch *);  Create a basket for this tree and given branch. ;  ; Int_t Debug () const;  ; void Delete (Option_t *option="""") override;  Delete this tree from memory or/and disk. ;  ; void Draw (Option_t *opt) override;  Default Draw method for all objects. ;  ; virtual void DropBaskets ();  Remove some baskets from memory. ;  ; virtual Int_t DropBranchFromCache (const char *bname, bool subbranches=false);  Remove the branch with name 'bname' from the Tree cache. ;  ; virtual Int_t DropBranchFromCache (TBranch *branch, bool subbranches=false);  Remove the branch b from the T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTChain.html:16324,undo,undo,16324,doc/v632/classTChain.html,https://root.cern,https://root.cern/doc/v632/classTChain.html,3,['undo'],['undo']
Usability,"e->GetMatrix();; 1626 fGeoManager->SetMatrixReflection(matrix->IsReflection());; 1627 fGeoManager->SetPaintVolume(vcrt);; 1628 if (!node->IsVolAttributes() && !strstr(option, ""range"")) {; 1629 col = vcrt->GetLineColor();; 1630 wid = vcrt->GetLineWidth();; 1631 sty = vcrt->GetLineStyle();; 1632 vcrt->SetLineColor(node->GetLineColor());; 1633 vcrt->SetLineWidth(node->GetLineWidth());; 1634 vcrt->SetLineStyle(node->GetLineStyle());; 1635 ((TAttLine *)vcrt)->Modify();; 1636 PaintShape(*shape, option);; 1637 vcrt->SetLineColor(col);; 1638 vcrt->SetLineWidth(wid);; 1639 vcrt->SetLineStyle(sty);; 1640 } else {; 1641 PaintShape(*shape, option);; 1642 }; 1643 } else {; 1644 // Paint full branch, except top node; 1645 for (i = 1; i <= level; i++) {; 1646 vcrt = node->GetVolume(i);; 1647 if (!strstr(option, ""range"")); 1648 ((TAttLine *)vcrt)->Modify();; 1649 shape = vcrt->GetShape();; 1650 *matrix = node->GetMatrix(i);; 1651 fGeoManager->SetMatrixReflection(matrix->IsReflection());; 1652 fGeoManager->SetPaintVolume(vcrt);; 1653 if (!node->IsVolAttributes() && !strstr(option, ""range"")) {; 1654 col = vcrt->GetLineColor();; 1655 wid = vcrt->GetLineWidth();; 1656 sty = vcrt->GetLineStyle();; 1657 vcrt->SetLineColor(node->GetLineColor());; 1658 vcrt->SetLineWidth(node->GetLineWidth());; 1659 vcrt->SetLineStyle(node->GetLineStyle());; 1660 ((TAttLine *)vcrt)->Modify();; 1661 PaintShape(*shape, option);; 1662 vcrt->SetLineColor(col);; 1663 vcrt->SetLineWidth(wid);; 1664 vcrt->SetLineStyle(sty);; 1665 } else {; 1666 PaintShape(*shape, option);; 1667 }; 1668 }; 1669 }; 1670 fGeoManager->SetMatrixReflection(kFALSE);; 1671}; 1672 ; 1673////////////////////////////////////////////////////////////////////////////////; 1674/// Print overlaps (see TGeoChecker::PrintOverlaps()); 1675 ; 1676void TGeoPainter::PrintOverlaps() const; 1677{; 1678 fChecker->PrintOverlaps();; 1679}; 1680 ; 1681////////////////////////////////////////////////////////////////////////////////; 1682/// Text progress bar.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoPainter_8cxx_source.html:54736,progress bar,progress bar,54736,doc/master/TGeoPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html,1,['progress bar'],['progress bar']
Usability,"e-WM"" - does server run on MacOS X;; ""XINERAMA"" - does server support Xinerama.; See also the output of xdpyinfo. void PutImage(Int_t offset, Int_t itran, Int_t x0, Int_t y0, Int_t nx, Int_t ny, Int_t xmin, Int_t ymin, Int_t xmax, Int_t ymax, UChar_t* image, Drawable_t id). void MapGCValues(GCValues_t& gval, ULong_t& xmask, RXGCValues& xgval, Bool_t tox = kTRUE); Private methods used for GUI. void MapSetWindowAttributes(SetWindowAttributes_t* attr, ULong_t& xmask, RXSetWindowAttributes& xattr). void MapColorStruct(ColorStruct_t* color, RXColor& xcolor). void MapPictureAttributes(PictureAttributes_t& attr, RXpmAttributes& xpmattr, Bool_t toxpm = kTRUE). void MapEvent(Event_t& ev, void* xev, Bool_t tox = kTRUE); void MapEvent(Event_t &ev, XEvent &xev, Bool_t tox = kTRUE);. void MapEventMask(UInt_t& emask, UInt_t& xemask, Bool_t tox = kTRUE). void MapKeySym(UInt_t& keysym, UInt_t& xkeysym, Bool_t tox = kTRUE). Bool_t AllocColor(Colormap cmap, RXColor* color); needed by TGX11TTF. void ClearWindow(). void DrawLine(Int_t x1, Int_t y1, Int_t x2, Int_t y2). void DrawText(Int_t x, Int_t y, Float_t angle, Float_t mgn, const char* text, TVirtualX::ETextMode mode). Handle_t GetNativeEvent() const; { return (Handle_t) fXEvent; }. void GetTextExtent(UInt_t& w, UInt_t& h, char* mess). Float_t GetTextMagnitude(); { return fTextMagnitude; }. Bool_t HasTTFonts() const; { return fHasTTFonts; }. void MoveWindow(Int_t wid, Int_t x, Int_t y). Int_t OpenDisplay(void* display). void QueryPointer(Int_t& ix, Int_t& iy). void ResizeWindow(Int_t wid). void SetCursor(Int_t win, ECursor cursor). void SetTextMagnitude(Float_t mgn = 1); { fTextMagnitude = mgn;}. void GetWindowAttributes(Window_t id, WindowAttributes_t& attr); Methods used for GUI. void MapWindow(Window_t id). void MapSubwindows(Window_t id). void MapRaised(Window_t id). void UnmapWindow(Window_t id). void DestroyWindow(Window_t id). void DestroySubwindows(Window_t id). void RaiseWindow(Window_t id). void LowerWindow(Window_t id). ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGX11.html:41428,Clear,ClearWindow,41428,root/html602/TGX11.html,https://root.cern,https://root.cern/root/html602/TGX11.html,2,['Clear'],['ClearWindow']
Usability,"e. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Protected Member Functions |; Protected Attributes |; List of all members ; TMVA::DNN::TAdadelta< Architecture_t, Layer_t, DeepNet_t > Class Template Reference. ; template<typename Architecture_t, typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>>; class TMVA::DNN::TAdadelta< Architecture_t, Layer_t, DeepNet_t >Adadelta Optimizer class. ; This class represents the Adadelta Optimizer. ; Definition at line 45 of file Adadelta.h. Public Types; using Matrix_t = typename Architecture_t::Matrix_t;  ; using Scalar_t = typename Architecture_t::Scalar_t;  ;  Public Types inherited from TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >; using Matrix_t = typename Architecture_t::Matrix_t;  ; using Scalar_t = typename Architecture_t::Scalar_t;  . Public Member Functions;  TAdadelta (DeepNet_t &deepNet, Scalar_t learningRate=1.0, Scalar_t rho=0.95, Scalar_t epsilon=1e-8);  Constructor. ;  ;  ~TAdadelta ()=default;  Destructor. ;  ; Scalar_t GetEpsilon () const;  ; std::vector< std::vector< Matrix_t > > & GetPastSquaredBiasGradients ();  ; std::vector< Matrix_t > & GetPastSquaredBiasGradientsAt (size_t i);  ; std::vector< std::vector< Matrix_t > > & GetPastSquaredBiasUpdates ();  ; std::vector< Matrix_t > & GetPastSquaredBiasUpdatesAt (size_t i);  ; std::vector< std::vector< Matrix_t > > & GetPastSquaredWeightGradients ();  ; std::vector< Matrix_t > & GetPastSquaredWeightGradientsAt (size_t i);  ; std::vector< std::vector< Matrix_t > > & GetPastSquaredWeightUpdates ();  ; std::vector< Matrix_t > & GetPastSquaredWeightUpdatesAt (size_t i);  ; Scalar_t GetRho () const;  Getters. ;  ;  Public Member Functions inherited from TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >;  VOptimizer (Scalar_t learningRate, DeepNet_t &deepNet);  Constructor. ;  ; virtual ~VOpt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdadelta.html:1116,learn,learningRate,1116,doc/master/classTMVA_1_1DNN_1_1TAdadelta.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdadelta.html,1,['learn'],['learningRate']
Usability,"e. ; Reimplemented from RooAbsReal.; Definition at line 32 of file RooConstVar.h. ◆ IsA(). TClass * RooConstVar::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsReal.; Definition at line 59 of file RooConstVar.h. ◆ isDerived(). bool RooConstVar::isDerived ; (; ); const. inlineoverridevirtual . Returns false, as the value of the constant doesn't depend on other objects. ; Reimplemented from RooAbsArg.; Definition at line 39 of file RooConstVar.h. ◆ Streamer(). void RooConstVar::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsReal. ◆ StreamerNVirtual(). void RooConstVar::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 59 of file RooConstVar.h. ◆ translate(). void RooConstVar::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 61 of file RooConstVar.cxx. ◆ writeToStream(). void RooConstVar::writeToStream ; (; std::ostream & ; os, . bool ; compact . ); const. overridevirtual . Write object contents to stream. ; Reimplemented from RooAbsReal.; Definition at line 54 of file RooConstVar.cxx. Libraries for RooConstVar:. [legend]; The documentation for this class was generated from the following files:; roofit/roofitcore/inc/RooConstVar.h; roofit/roofitco",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooConstVar.html:62822,simpl,simple,62822,doc/master/classRooConstVar.html,https://root.cern,https://root.cern/doc/master/classRooConstVar.html,1,['simpl'],['simple']
Usability,"e. ;  ; virtual void CurrentChanged (TQCommand *c);  emit signal ;  ; TQCommand * GetCurrent () const;  Returns the last executed command. ;  ; TQCommand * GetCursor () const;  Returns a command correspondent to the current cursor position in stack. ;  ; UInt_t GetLimit () const;  Returns a maximum number of commands which could be located in stack. ;  ; TClass * IsA () const override;  ; Bool_t IsLogging () const;  Returns kTRUE if logging is ON. ;  ; void ls (Option_t *option="""") const override;  Lists all commands in stack. ;  ; void Redo (Option_t *option="""") override;  Performs redo action. Move cursor position forward in history stack. ;  ; virtual void SetLimit (UInt_t limit);  Returns a maximum number of commands which could be located in stack. ;  ; virtual void SetLogging (Bool_t on=kTRUE);  Start logging. ;  ; void Streamer (TBuffer &) override;  Stream all objects in the collection to or from the I/O buffer. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Undo (Option_t *option="""") override;  Performs undo action. Move cursor position backward in history stack. ;  ;  Public Member Functions inherited from TQCommand;  TQCommand (const char *cl=nullptr, void *object=nullptr, const char *redo=nullptr, const char *undo=nullptr);  Constructor. ;  ;  TQCommand (const TQCommand &com);  Copy constructor. ;  ;  TQCommand (TObject *obj, const char *redo=nullptr, const char *undo=nullptr);  Constructor. ;  ; virtual ~TQCommand ();  dtor. ;  ; virtual Bool_t CanCompress (TQCommand *c) const;  By default, commands can be compressed if they are: ;  ; virtual Bool_t CanMerge (TQCommand *c) const;  Two commands can be merged if they can be composed into a single command (Macro command). ;  ; virtual void Compress (TQCommand *c);  Compress command. ;  ; void Delete (Option_t *option="""") override;  If ""opt"" is not zero delete every merged command which option string is equal to ""opt"". ;  ; const char * GetName () const override;  Returns the comm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQUndoManager.html:1851,undo,undo,1851,doc/master/classTQUndoManager.html,https://root.cern,https://root.cern/doc/master/classTQUndoManager.html,1,['undo'],['undo']
Usability,"e. By default it is "" "". The caller; program owns the returned TLegend. If the pad contains some TMultiGraph or THStack the individual; graphs or histograms in them are added to the TLegend. TVirtualPad * cd(Int_t subpadnumber = 0); Set Current pad.; When a canvas/pad is divided via TPad::Divide, one can directly; set the current path to one of the subdivisions.; See TPad::Divide for the convention to number subpads.; Returns the new current pad, or 0 in case of failure.; For example:; c1.Divide(2,3); // create 6 pads (2 divisions along x, 3 along y).; To set the current pad to the bottom right pad, do; c1.cd(6);; Note1: c1.cd() is equivalent to c1.cd(0) and sets the current pad; to c1 itself.; Note2: after a statement like c1.cd(6), the global variable gPad; points to the current pad. One can use gPad to set attributes; of the current pad.; Note3: One can get a pointer to one of the sub-pads of pad with:; TPad *subpad = (TPad*)pad->GetPad(subpadnumber);. void Clear(Option_t* option = """"); Delete all pad primitives. If the bit kClearAfterCR has been set for this pad, the Clear function; will execute only after having pressed a CarriageReturn; Set the bit with mypad->SetBit(TPad::kClearAfterCR). Int_t Clip(Float_t* x, Float_t* y, Float_t xclipl, Float_t yclipb, Float_t xclipr, Float_t yclipt); Clipping routine: Cohen Sutherland algorithm. If Clip ==2 the segment is outside the boundary.; If Clip ==1 the segment has one point outside the boundary.; If Clip ==0 the segment is inside the boundary. _Input parameters:. x[2], y[2] : Segment coordinates; xclipl, yclipb, xclipr, yclipt : Clipping boundary. _Output parameters:. x[2], y[2] : New segment coordinates. Int_t Clip(Double_t* x, Double_t* y, Double_t xclipl, Double_t yclipb, Double_t xclipr, Double_t yclipt); Clipping routine: Cohen Sutherland algorithm. If Clip ==2 the segment is outside the boundary.; If Clip ==1 the segment has one point outside the boundary.; If Clip ==0 the segment is inside the boundary. _Inpu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPad.html:33522,Clear,Clear,33522,root/html534/TPad.html,https://root.cern,https://root.cern/root/html534/TPad.html,3,['Clear'],['Clear']
Usability,"e. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TBuffer3D. class TBuffer3D: public TObject. TBuffer3D. Generic 3D primitive description class - see TBuffer3DTypes for; producer classes. ; Filling TBuffer3D and Adding to Viewer; The viewers behind the TVirtualViewer3D interface differ greatly in their; capabilities e.g. Some know how to draw certain shapes natively (e.g. spheres/tubes in; OpenGL) - others always require a raw tessellation description of points/lines/segments.; Some; need the 3D object positions in the global frame, others can cope with; local frames + a translation matrix - which can give considerable performance; benefits. To cope with these situations the object buffer is filled out in negotiation; with the viewer. TBuffer3D classes are conceptually divided into enumerated; sections Core, BoundingBox, Raw etc (see TBuffer3D.h for more details). . The SectionsValid() / SetSectionsValid / ClearSectionsValid() methods of TBuffer3D; are used to test/set/clear these section valid flags.; The sections found in TBuffer3D (Core/BoundingBox/Raw Sizes/Raw); are sufficient to describe any tessellated shape in a generic fashion. An additional ShapeSpecific section; in derived shape specific classes allows a more abstract shape description; (""a sphere of inner radius x, outer radius y""). This enables a viewer; which knows how to draw (tessellate) the shape itself to do so, which can bring; considerable performance and quality benefits, while providing a generic fallback; suitable for all viewers.; The rules for client negotiation with the viewer are:. If suitable specialized TBuffer3D class exists, use it, otherwise use; TBuffer3D.; Complete the mandatory Core section.; Complete the ShapeSpecific section; if applicable.; Complete the BoundingBox if you can.; Pass this buffer to the viewer using; one of the AddObject() methods - see below. If the viewer requires more sections to be completed (Raw/RawSizes) A",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBuffer3D.html:1178,clear,clear,1178,root/html526/TBuffer3D.html,https://root.cern,https://root.cern/root/html526/TBuffer3D.html,15,"['Clear', 'clear']","['ClearSectionsValid', 'clear']"
Usability,"e. Such a range is called ""bin"". Let's look at an example: draw the histogram of the momentum (""fPt"") of all electrons with an energy (""fE"") > 80 and fTriggered being true.; Binning; You can tell TTree::Draw() what the binning should be:; tree->Draw(""electrons.fE >> htemp(15, 0., 30.)"",...). will use 15 bins, where the lower bin border of the first bin is at 0. and the upper bin border of the highest is at 30.; Style; ROOT displays a few properties for the histogram in the box in the upper right. You can move things around in the graphical display (""canvas"") of the histogram. You can modify graphical properties of the canvas by showing the editor: in the menu, select ""View"", then ""Editor"". Click on the histogram to select it, then change its visual appearance to magenta line, 5 pixels width, with pink fill. Eeew. This is likely the only time in your life that you are allowed to use this color combination - enjoy! :-); . ‹ 2. Running code in ROOT; up; 3. Examining a TTree's data ›. Navigate through this book; 0. Setting up ROOT; 1. Extracting an object from a TFile; 2. Running code in ROOT; 4. Histogramming; 3. Examining a TTree's data; 5. Fitting; 6. Multivariate Analysis; 7. Using the TTreeReader; 8. Efficiency Calculation; 9. Fitting By Coding; 10. Go Parallel!; TutorialSelector.C; 11. Done!. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/4-histogramming.html:3661,guid,guidelines,3661,d/4-histogramming.html,https://root.cern,https://root.cern/d/4-histogramming.html,1,['guid'],['guidelines']
Usability,"e. These projections are useful for measurement or checking alignments, as the sizes and angles between objects are preserved. You can select the active camera from the viewer’s Camera menu on the top menu bar. There are three perspective camera choices:. Perspective (Floor XOZ) Default; Perspective (Floor YOZ); Perspective (Floor XOY). In each case the perspective camera is constrained to keep the chosen floor plane, defined by a pair of world axes, appearing level at all times - i.e. there is no banking of the ‘horizon’ that you experience when a plane rolls. There are also three orthographic camera choices:. Orthographic (XOY); Orthographic (XOZ); Orthographic (ZOY). Orthographic projections are generally constrained to look down one of the global axes of the world, with the other two axes lying horizontal/vertical on the viewer window. Therefore, XOY has the X-axis horizontal, the Y-axis vertical. You can always confirm the orientation and constraints of the camera in the world by enabling axis drawing in the “Guides” tab - see sections “Guides” and “Clipping” below. For orthographic camera a ruler-depicting current scene units is also available.; You can also pick the current camera by obtaining a handle to the GL Viewer object behind the interface:; TGLViewer * v = (TGLViewer *)gPad->GetViewer3D();; calling the method TGLViewer::SetCurrentCamera with one of the TGLViewer::ECameraType types:; v->SetCurrentCamera(TGLViewer::kCameraPerspXOZ);; See also $ROOTSYS/tutorials/gl/glViewerExercise.C.; 9.13.2.2 Adjusting Cameras; The interactions with the camera are summarized above. In each case the interaction is listed, along with description and user actions required to achieve it. For all cameras you can reset the original default view, framing the entire scene, by double clicking any mouse button. GL Viewer camera interactions. For the Zoom interaction you can use the following modifiers combinations to adjust the sensitivity:. Shiftx 10; Ctrlx 0.1; Shift + Ctrlx 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:389822,Guid,Guides,389822,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['Guid'],['Guides']
Usability,"e. protected:. TStringTNamed::fNameobject identifier; TGeoRotation*fRotationrotation matrix; TStringTNamed::fTitleobject title; Double_tfTranslation[3]translation vector. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoCombiTrans(); dummy ctor. TGeoCombiTrans(const TGeoCombiTrans& other); Copy ctor. TGeoCombiTrans(const TGeoMatrix& other); Copy ctor. TGeoCombiTrans(const TGeoTranslation& tr, const TGeoRotation& rot); Constructor from a translation and a rotation. TGeoCombiTrans(const char* name); Named ctor. TGeoCombiTrans(Double_t dx, Double_t dy, Double_t dz, TGeoRotation* rot); Constructor from a translation specified by X,Y,Z and a pointer to a rotation. The rotation will not be owned by this. TGeoCombiTrans(const char* name, Double_t dx, Double_t dy, Double_t dz, TGeoRotation* rot); Named ctor. TGeoCombiTrans & operator=(const TGeoMatrix& matrix); Assignment operator. ~TGeoCombiTrans(); destructor. void Clear(Option_t* option = """"); Reset translation/rotation to identity. TGeoMatrix& Inverse() const; Return a temporary inverse of this. TGeoMatrix * MakeClone() const; Make a clone of this matrix. void RegisterYourself(); Register the matrix in the current manager, which will become the owner. void RotateX(Double_t angle); Rotate about X axis with angle expressed in degrees. void RotateY(Double_t angle); Rotate about Y axis with angle expressed in degrees. void RotateZ(Double_t angle); Rotate about Z axis with angle expressed in degrees. void ReflectX(Bool_t leftside, Bool_t rotonly = kFALSE); Multiply by a reflection respect to YZ. void ReflectY(Bool_t leftside, Bool_t rotonly = kFALSE); Multiply by a reflection respect to ZX. void ReflectZ(Bool_t leftside, Bool_t rotonly = kFALSE); Multiply by a reflection respect to XY. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetRotation(const TGeoRotation* rot); Assign a foreign rotation to the co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoCombiTrans.html:16760,Clear,Clear,16760,root/html602/TGeoCombiTrans.html,https://root.cern,https://root.cern/root/html602/TGeoCombiTrans.html,2,['Clear'],['Clear']
Usability,"e0.C Simple Event class example ;  tree1.C This example is a variant of hsimple.C but using a TTree instead of a TNtuple ;  tree2.C This example illustrates how to make a Tree from variables or arrays in a C struct ;  tree2a.C This example is the same as tree2.C, but uses a class instead of a C-struct ;  tree3.C Example of a Tree where branches are variable length arrays A second Tree is created and filled in parallel ;  tree4.C This example writes a tree with objects of the class Event ;  treefriend.C Illustrates how to use Tree friends: ;  treegetval.C Illustrates how to retrieve TTree variables in arrays ;  tv3.C;  tvdemo.C;  ► unuran;  unuranDemo.CExample macro to show unuran capabilities The results are compared with what is obtained using TRandom or TF1::GetRandom The macro is divided in 3 parts: ;  unuranFoamTest.CThis program must be compiled and executed with Aclic as follows ;  ► v7;  concurrentfill.cxx;  draw.cxx;  histops.cxx;  histspeedtest.cxx;  perf.cxx;  perfcomp.cxx;  simple.cxx;  ► xml;  DOMParsePerson.C ROOT implementation of a XML DOM Parser ;  DOMRecursive.C ROOT implementation of a XML DOM Parser ;  SAXHandler.C ROOT implementation of a simple SAX Handler ;  xmlnewfile.C Example to create a new xml file with the TXMLEngine class ;  xmlreadfile.C Example to read and parse any xml file, supported by TXMLEngine class The input file, produced by xmlnewfile.C macro is used If you need full xml syntax support, use TXMLParser instead ;  benchmarks.CThis macro run several tests and produces an benchmark report ;  demos.CThis macro shows a control bar to run some of the ROOT tutorials ;  demoshelp.CThis macro shows help on running the Demos ;  geant3tasks.CThis script is a representation using TTasks of the Geant3 simulation program This example uses directly TTask objects ;  hsimple.C This program creates : ;  htmlex.CThis file demonstrates how THtml can document sources ;  MyTasks.cxxA set of classes deriving from TTask ;  regexp.CA regular expression,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:158064,simpl,simple,158064,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,1,['simpl'],['simple']
Usability,"e4); virtual~TAttParticle(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; static Int_tConvertISAtoPDG(Int_t isaNumber); virtual voidTNamed::Copy(TObject& named) const; static voidDefinePDG(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TAttParticle.html:968,Clear,Clear,968,root/html532/TAttParticle.html,https://root.cern,https://root.cern/root/html532/TAttParticle.html,2,['Clear'],['Clear']
Usability,"e::RedoName(args)""; TStringTCollection::fNamename of the collection; Bool_tfNewDeletekTRUE if Redo/Undo methods are new/delete; void*fObjectobject to which undo/redo actions applied; TQConnection*fRedodo/redo action; Long_t*fRedoArgsredo values; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; Int_tfState-1 undoing on, 1 redoing on, 0 nothing in progress; Int_tfStatusfStatus++ after Redo(), fStatus-- after Undo(); TStringfTitlecommand description; TQConnection*fUndoundo action; Long_t*fUndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TCollection::(anonymous)TCollection::kIsOwner. Class Charts. Inheritance Chart:. TObject. ←; TCollection. ←; TSeqCollection. ←; TList. TQObject. ←; TQCommand. ←. TQUndoManager. Function documentation; void Init(const char* cl, void* object, const char* redo, const char* undo); common protected method used in several constructors. TQCommand(const char* cl = 0, void* object = 0, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. clname - class name.; 2. obj - an object; 3. redo - method or function to do/redo operation; 4. undo - method or function to undo operation. Comments:; - if either clname or obj is NULL that means that redo/undo is function; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(""TPad"", gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case undo parameter; can be omitted. Example:; TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. obj - an object; 2. redo - method or function to do/redo operation; 3. undo - method or function to undo operation. Comments:; - to specify",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQCommand.html:18719,undo,undo,18719,root/html602/TQCommand.html,https://root.cern,https://root.cern/root/html602/TQCommand.html,4,['undo'],['undo']
Usability,"e::SetEstimate. A possible recipee is to do; tree->SetEstimate(tree->GetEntries());; You must call SetEstimate if the expected number of selected rows; is greater than 1000000. You can use the option ""goff"" to turn off the graphics output; of TTree::Draw in the above example. Automatic interface to TTree::Draw via the TTreeViewer. A complete graphical interface to this function is implemented; in the class TTreeViewer.; To start the TTreeViewer, three possibilities:; - select TTree context menu item ""StartViewer""; - type the command ""TTreeViewer TV(treeName)""; - execute statement ""tree->StartViewer();"". void DropBaskets(); Remove some baskets from memory. void DropBuffers(Int_t nbytes); Drop branch buffers to accomodate nbytes below MaxVirtualsize. Int_t Fill(); Fill all branches. This function loops on all the branches of this tree. For; each branch, it copies to the branch buffer (basket) the current; values of the leaves data types. If a leaf is a simple data type,; a simple conversion to a machine independent format has to be done. This machine independent version of the data is copied into a; basket (each branch has its own basket). When a basket is full; (32k worth of data by default), it is then optionally compressed; and written to disk (this operation is also called comitting or; 'flushing' the basket). The committed baskets are then; immediately removed from memory. The function returns the number of bytes committed to the; individual branches. If a write error occurs, the number of bytes returned is -1. If no data are written, because, e.g., the branch is disabled,; the number of bytes returned is 0. The baskets are flushed and the Tree header saved at regular intervals. At regular intervals, when the amount of data written so far is; greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk.; This makes future reading faster as it guarantees that baskets belonging to nearby; entries will be on the same disk region.; When the first ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:82453,simpl,simple,82453,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,2,['simpl'],['simple']
Usability,"e::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; TGButtonGroup*fgrGroup the Radiobuttons:. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPieEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor of graph editor. ~TPieEditor(); Destructor of pie editor. void ConnectSignals2Slots(); Connect signals to slots. void ActivateBaseClassEditors(TClass* ); Exclude TAttTextEditor from this interface. void SetModel(TObject* ); Pick up the used values of graph attributes. void DoTitle(const char* text); Slot for setting the graph title. void DoShape(); Slot connected to the draw options. void DoMarkerOnOff(Bool_t on); Slot for setting markers as visible/invisible. void DoChange3DAngle(); Slot for setting the 3D angle. void DoGraphLineWidth(); Slot connected to the graph line width. void DoTextChange(); Change text. TGComboBox* BuildFontSizeComboBox(TGFrame* , Int_t ); Create text size combo box. » Author: Guido Volpi 04/10/2007 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/ged:$Id$ » Last generated: 2015-03-14 16:46; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPieEditor.html:21678,Guid,Guido,21678,root/html534/TPieEditor.html,https://root.cern,https://root.cern/root/html534/TPieEditor.html,1,['Guid'],['Guido']
Usability,"e::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoHypeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for Hype editor. ~TGeoHypeEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current settings. void DoModified(); Slot for notifying modifications. void DoUndo(); Slot for undoing last operation. void DoRin(); Slot for Rin. void DoRout(); Slot for Rout. void DoDz(); Slot for Z. void DoStIn(); Slot for StIn. void DoStOut(); Slot for StOut. TGeoHypeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-02 16:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoHypeEditor.html:22325,undo,undoing,22325,root/html604/TGeoHypeEditor.html,https://root.cern,https://root.cern/root/html604/TGeoHypeEditor.html,2,['undo'],['undoing']
Usability,"e::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoHypeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for Hype editor. ~TGeoHypeEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current settings. void DoModified(); Slot for notifying modifications. void DoUndo(); Slot for undoing last operation. void DoRin(); Slot for Rin. void DoRout(); Slot for Rout. void DoDz(); Slot for Z. void DoStIn(); Slot for StIn. void DoStOut(); Slot for StOut. TGeoHypeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoHypeEditor.html:22325,undo,undoing,22325,root/html602/TGeoHypeEditor.html,https://root.cern,https://root.cern/root/html602/TGeoHypeEditor.html,2,['undo'],['undoing']
Usability,"e::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; TGButtonGroup*fgrGroup the Radiobuttons:; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPieEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor of graph editor. ~TPieEditor(); Destructor of pie editor. void ConnectSignals2Slots(); Connect signals to slots. void ActivateBaseClassEditors(TClass* ); Exclude TAttTextEditor from this interface. void SetModel(TObject* ); Pick up the used values of graph attributes. void DoTitle(const char* text); Slot for setting the graph title. void DoShape(); Slot connected to the draw options. void DoMarkerOnOff(Bool_t on); Slot for setting markers as visible/invisible. void DoChange3DAngle(); Slot for setting the 3D angle. void DoGraphLineWidth(); Slot connected to the graph line width. void DoTextChange(); Change text. TGComboBox* BuildFontSizeComboBox(TGFrame* , Int_t ); Create text size combo box. TPieEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: Guido Volpi 04/10/2007 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/ged:$Id$ » Last generated: 2015-06-02 16:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TPieEditor.html:22668,Guid,Guido,22668,root/html604/TPieEditor.html,https://root.cern,https://root.cern/root/html604/TPieEditor.html,1,['Guid'],['Guido']
Usability,"e::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; TGButtonGroup*fgrGroup the Radiobuttons:; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPieEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor of graph editor. ~TPieEditor(); Destructor of pie editor. void ConnectSignals2Slots(); Connect signals to slots. void ActivateBaseClassEditors(TClass* ); Exclude TAttTextEditor from this interface. void SetModel(TObject* ); Pick up the used values of graph attributes. void DoTitle(const char* text); Slot for setting the graph title. void DoShape(); Slot connected to the draw options. void DoMarkerOnOff(Bool_t on); Slot for setting markers as visible/invisible. void DoChange3DAngle(); Slot for setting the 3D angle. void DoGraphLineWidth(); Slot connected to the graph line width. void DoTextChange(); Change text. TGComboBox* BuildFontSizeComboBox(TGFrame* , Int_t ); Create text size combo box. TPieEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: Guido Volpi 04/10/2007 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/ged:$Id$ » Last generated: 2015-06-30 15:25; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPieEditor.html:22668,Guid,Guido,22668,root/html602/TPieEditor.html,https://root.cern,https://root.cern/root/html602/TPieEditor.html,1,['Guid'],['Guido']
Usability,"e::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGView(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, Int_t id = -1, UInt_t xMargin = 0, UInt_t yMargin = 0, UInt_t options = kSunkenFrame | kDoubleBorder, UInt_t sboptions = 0, Pixel_t back = GetWhitePixel()); Create an editor view, containing an TGEditorFrame and (optionally); a horizontal and vertical scrollbar. ~TGView(); Delete view. void Clear(Option_t* = """"); Clear view. void SetVisibleStart(Int_t newTop, Int_t direction); Scroll view in specified direction to make newTop the visible location. void DrawRegion(Int_t x, Int_t y, UInt_t width, UInt_t height); Draw region. void UpdateRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); update a part of view. void UpdateBackgroundStart(); set some gc values. Bool_t HandleButton(Event_t* event); handle button. void DoRedraw(); redraw. Bool_t HandleExpose(Event_t* event); Handle expose events. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process scrollbar messages. void Layout(); layout view. void DrawBorder(); Draw the border of the text edit widget. void ScrollToPosition(TGLongPosition newPos); Scroll the canvas to pos. void ScrollCanvas(Int_t newTop, Int_t direction); Scroll the canvas to new_top in the kVertical or kHorizontal direction. void ChangeBackground(Pixel_t ); Change background color of the canvas frame. void SetBackgroundColor(Pixel_t ); Set background color of t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGView.html:22463,Clear,Clear,22463,root/html602/TGView.html,https://root.cern,https://root.cern/root/html602/TGView.html,4,['Clear'],['Clear']
Usability,"e::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled; static TGMainFrame::(anonymous)TGMainFrame::kDontCallClose. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofProgressMemoryPlot(TProofProgressDialog* d, Int_t w = 700, Int_t h = 300); Main constructor. ~TProofProgressMemoryPlot(); Destructor. TGListBox* BuildLogList(TGFrame* parent); Build the list of workers. For this, extract the logs and take the names; of TProofLogElements. void Clear(Option_t* = 0); Clear the canvases. void DoPlot(); Draw the plot from the logs. TGraph * DoAveragePlot(Int_t& max_el, Int_t& min_el); Create the average plots. Int_t ParseLine(TString l, Long64_t& v, Long64_t& r, Long64_t& e); Extract from line 'l' the virtual memory 'v', the resident memory 'r' and the; number of events 'e'.; The line is assumed to be in the form; ""... Memory 130868 virtual 31540 ... event 5550""; The fields are only filled if >= 0 .; Return 0 on success, -1 if any of the values coudl not be filled (the output; fields are not touched in such a case). TGraph * DoWorkerPlot(TProofLogElem* ple); Make a memory consumption graph for a worker. TGraph * DoMasterPlot(TProofLogElem* ple); a master or submaster log; display without meaningful labels for now. void Select(Int_t id); actions of select all/clear all button. TGraph* DoAveragePlotOld(Int_t& max_el, Int_t& min_el). TProofProgressMemoryPlot(TProofProgressDialog* d, Int_t w = 700, Int_t h = 300). » Author: Anna Kreshuk 18/07/2008 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id$ » Last generated: 2015-06-02 16:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofProgressMemoryPlot.html:25165,clear,clear,25165,root/html604/TProofProgressMemoryPlot.html,https://root.cern,https://root.cern/root/html604/TProofProgressMemoryPlot.html,2,['clear'],['clear']
Usability,"e::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled; static TGMainFrame::(anonymous)TGMainFrame::kDontCallClose. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofProgressMemoryPlot(TProofProgressDialog* d, Int_t w = 700, Int_t h = 300); Main constructor. ~TProofProgressMemoryPlot(); Destructor. TGListBox* BuildLogList(TGFrame* parent); Build the list of workers. For this, extract the logs and take the names; of TProofLogElements. void Clear(Option_t* = 0); Clear the canvases. void DoPlot(); Draw the plot from the logs. TGraph * DoAveragePlot(Int_t& max_el, Int_t& min_el); Create the average plots. Int_t ParseLine(TString l, Long64_t& v, Long64_t& r, Long64_t& e); Extract from line 'l' the virtual memory 'v', the resident memory 'r' and the; number of events 'e'.; The line is assumed to be in the form; ""... Memory 130868 virtual 31540 ... event 5550""; The fields are only filled if >= 0 .; Return 0 on success, -1 if any of the values coudl not be filled (the output; fields are not touched in such a case). TGraph * DoWorkerPlot(TProofLogElem* ple); Make a memory consumption graph for a worker. TGraph * DoMasterPlot(TProofLogElem* ple); a master or submaster log; display without meaningful labels for now. void Select(Int_t id); actions of select all/clear all button. TGraph* DoAveragePlotOld(Int_t& max_el, Int_t& min_el). TProofProgressMemoryPlot(TProofProgressDialog* d, Int_t w = 700, Int_t h = 300). » Author: Anna Kreshuk 18/07/2008 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id$ » Last generated: 2015-06-30 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofProgressMemoryPlot.html:25165,clear,clear,25165,root/html602/TProofProgressMemoryPlot.html,https://root.cern,https://root.cern/root/html602/TProofProgressMemoryPlot.html,2,['clear'],['clear']
Usability,"e; 2564 return h;; 2565}; 2566 ; 2567////////////////////////////////////////////////////////////////////////////////; 2568/// Return size of the formula along X in pad coordinates when the text precision; 2569/// is smaller than 3.; 2570 ; 2571Double_t TLatex::GetXsize(); 2572{; 2573 if (!gPad) return 0.;; 2574 TString newText = GetTitle();; 2575 if( newText.Length() == 0) return 0;; 2576 ; 2577 // The text is a TMathText.; 2578 if ( newText.Contains(""\\"") ) {; 2579 TMathText tm(0., 0., newText.Data());; 2580 return tm.GetXsize();; 2581 }; 2582 ; 2583 fError = nullptr;; 2584 if (CheckLatexSyntax(newText)) {; 2585 std::cout<<""\n*ERROR<TLatex>: ""<<fError<<std::endl;; 2586 std::cout<<""==> ""<<GetTitle()<<std::endl;; 2587 return 0;; 2588 }; 2589 fError = nullptr;; 2590 ; 2591 const Char_t *text = newText.Data() ;; 2592 Double_t angle_old = GetTextAngle();; 2593 TLatexFormSize fs = FirstParse(0,GetTextSize(),text);; 2594 SetTextAngle(angle_old);; 2595 fTabSize.clear();; 2596 return TMath::Abs(gPad->AbsPixeltoX(Int_t(fs.Width())) - gPad->AbsPixeltoX(0));; 2597}; 2598 ; 2599////////////////////////////////////////////////////////////////////////////////; 2600/// Return text size in pixels; 2601 ; 2602void TLatex::GetBoundingBox(UInt_t &w, UInt_t &h, Bool_t angle); 2603{; 2604 if (!gPad) return;; 2605 TString newText = GetTitle();; 2606 if( newText.Length() == 0) return;; 2607 ; 2608 // The text is a TMathText.; 2609 if ( newText.Contains(""\\"") ) {; 2610 TMathText tm(0., 0., newText.Data());; 2611 tm.GetBoundingBox(w, h);; 2612 return;; 2613 }; 2614 ; 2615 fError = nullptr;; 2616 if (CheckLatexSyntax(newText)) {; 2617 std::cout<<""\n*ERROR<TLatex>: ""<<fError<<std::endl;; 2618 std::cout<<""==> ""<<GetTitle()<<std::endl;; 2619 return;; 2620 }; 2621 fError = nullptr;; 2622 ; 2623 if (angle) {; 2624 Int_t cBoxX[4], cBoxY[4];; 2625 Int_t ptx, pty;; 2626 if (TestBit(kTextNDC)) {; 2627 ptx = gPad->UtoPixel(fX);; 2628 pty = gPad->VtoPixel(fY);; 2629 } else {; 2630 ptx = gPad->XtoAbsPi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TLatex_8cxx_source.html:92160,clear,clear,92160,doc/master/TLatex_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TLatex_8cxx_source.html,1,['clear'],['clear']
Usability,"e; 5 = X; 6 = Diamond; 7 = Triangle. cg(enable,color) channel grid. In addition to the surface drawn using any above given algorithm one can display grid using the color parameter. The parameter enable can be set to:. 0 = Grid not drawn; 1 = Grid drawn. See example spectrumpainter.C. Definition at line 7674 of file TSpectrum2Painter.cxx. ◆ SetAngles(). void TSpectrum2Painter::SetAngles ; (; Int_t ; alpha, . Int_t ; beta, . Int_t ; view . ). Sets angles of the view: . alpha - angles of display,alpha+beta must be less or equal to 90, alpha- angle between base line of Canvas and right lower edge of picture base plane; beta - angle between base line of Canvas and left lower edge of picture base plane; view - rotation angle of the view, it can be 0, 90, 180, 270 degrees . Definition at line 7117 of file TSpectrum2Painter.cxx. ◆ SetBezier(). void TSpectrum2Painter::SetBezier ; (; Int_t ; bezier). Sets on/off Bezier smoothing: . bezier - determines Bezier interpolation (applies only for simple display modes group for grid, x_lines, y_lines display modes) . Definition at line 7205 of file TSpectrum2Painter.cxx. ◆ SetChanGrid(). void TSpectrum2Painter::SetChanGrid ; (; Int_t ; enable, . Int_t ; color . ). This function sets enables/disables drawing of channel grid and sets its color: -enable - decides whether the channel grid is shown or not -color - color of channel grid. ; Definition at line 7271 of file TSpectrum2Painter.cxx. ◆ SetChanMarks(). void TSpectrum2Painter::SetChanMarks ; (; Int_t ; enable, . Int_t ; color, . Int_t ; width, . Int_t ; height, . Int_t ; style . ). Sets enables/disables drawing of channel marks and sets their attributes: . enable - decides whether the channel marks are shown or not; color - color of channel marks; width - width of channel marks in pixels; height - height of channel marks in pixels; style - style of channel marks (dot, cross, star, rectangle, X, diamond, triangle) . Definition at line 7244 of file TSpectrum2Painter.cxx. ◆ SetColorAl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrum2Painter.html:51731,simpl,simple,51731,doc/master/classTSpectrum2Painter.html,https://root.cern,https://root.cern/doc/master/classTSpectrum2Painter.html,1,['simpl'],['simple']
Usability,"e; 5.14 MnUserParameters; 5.15 MnUserParameterState; 5.16 MnPrint.h. 6 How to get the right answer from M; 6.1 Which minimizer to use; 6.2 Floating point precision; 6.3 Parameter limits; 6.4 Fixing and releasing parameters; 6.5 Interpretation of parameter errors; 6.6 Convergence in \(\mbox{MIGRAD}\), and positive–definiteness; 6.7 Additional trouble–shooting. 7 A complete example; 7.1 The user’s \(\mbox{FCN}\); 7.2 The user’s main program. Minuit 2; *** Fred JAMES and Matthias WINKLER CERN, Geneva ***; 1 Foreword; 1.1 What M is intended to do; M is conceived as a tool to find the minimum value of a multi-parameter function (the “\(\mbox{FCN}\)”) and analyze the shape of the function around the minimum. The principal application is foreseen for statistical analysis, working on chisquare or log-likelihood functions, to compute the best-fit parameter values and uncertainties, including correlations between the parameters. It is especially suited to handle difficult problems, including those which may require guidance in order to find the correct solution.; 1.2 What M is not intended to do; Although M will of course solve easy problems faster than complicated ones, it is not intended for the repeated solution of identically parametrized problems (such as track fitting in a detector) where a specialized program will in general be much more efficient.; 1.3 Further remarks; M was initially written in Fortran around 1975-1980 at CERN by Fred James @bib-MINUIT. Its main field of usage is statistical data analysis of experimental data recorded at CERN, but it is also used by people doing data analysis outside CERN or outside high energy physics (HEP). In 2002 Fred James started a project aiming to re-implement M in an object-oriented way using .; More information about recent developments, releases and installation can be obtained from the M homepage @bib-C++MINUIT.; The names of M applications are written in capital letters (e.g. \(\mbox{MIGRAD}\), \(\mbox{MINOS}\), \(\mbox{",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:2045,guid,guidance,2045,root/htmldoc/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html,2,['guid'],['guidance']
Usability,"e; 60 ; 61////////////////////////////////////////////////////////////////////////////; 62/// Releases the resources associated to a file opened with davix; 63int VfsRdOnlyClose(sqlite3_file *pFile); 64{; 65 VfsRootFile *p = reinterpret_cast<VfsRootFile *>(pFile);; 66 // We can't use delete because the storage for p is managed by sqlite; 67 p->~VfsRootFile();; 68 return SQLITE_OK;; 69}; 70 ; 71////////////////////////////////////////////////////////////////////////////; 72/// Issues a byte range request for a chunk to the raw file; 73int VfsRdOnlyRead(sqlite3_file *pFile, void *zBuf, int count, sqlite_int64 offset); 74{; 75 VfsRootFile *p = reinterpret_cast<VfsRootFile *>(pFile);; 76 auto nbytes = p->fRawFile->ReadAt(zBuf, count, offset);; 77 return (nbytes != static_cast<unsigned int>(count)) ? SQLITE_IOERR : SQLITE_OK;; 78}; 79 ; 80////////////////////////////////////////////////////////////////////////////; 81/// We do not write to a database in the RDataSource and therefore can simply return an error for this callback; 82int VfsRdOnlyWrite(sqlite3_file * /*pFile*/, const void * /*zBuf*/, int /*iAmt*/, sqlite_int64 /*iOfst*/); 83{; 84 return SQLITE_OPEN_READONLY;; 85}; 86 ; 87////////////////////////////////////////////////////////////////////////////; 88/// We do not write to a database in the RDataSource and therefore can simply return an error for this callback; 89int VfsRdOnlyTruncate(sqlite3_file * /*pFile*/, sqlite_int64 /*size*/); 90{; 91 return SQLITE_OPEN_READONLY;; 92}; 93 ; 94////////////////////////////////////////////////////////////////////////////; 95/// As the database is read-only, syncing data to disc is a no-op and always succeeds; 96int VfsRdOnlySync(sqlite3_file * /*pFile*/, int /*flags*/); 97{; 98 return SQLITE_OK;; 99}; 100 ; 101////////////////////////////////////////////////////////////////////////////; 102/// Returns the cached file size; 103int VfsRdOnlyFileSize(sqlite3_file *pFile, sqlite_int64 *pSize); 104{; 105 VfsRootFile *p = reinte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RSqliteDS_8cxx_source.html:3953,simpl,simply,3953,doc/master/RSqliteDS_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html,1,['simpl'],['simply']
Usability,"e; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » RECORDER; » TRecorderRecording. class TRecorderRecording: public TRecorderState. Represents state of TRecorder when recording events. Function Members (Methods); public:. TRecorderRecording(const TRecorderRecording&); static TClass*Class(); voidFilterEventPave(); virtual TRecorder::ERecorderStateGetState() const; virtual TClass*IsA() const; virtual voidTRecorderState::ListCmd(const char*); virtual voidTRecorderState::ListGui(const char*); TRecorderRecording&operator=(const TRecorderRecording&); virtual voidTRecorderState::Pause(TRecorder*); virtual voidTRecorderState::PrevCanvases(const char*, Option_t*); voidRecordCmdEvent(const char* line); voidRecordExtraEvent(TString line, TTime extTime); voidRecordGuiBldEvent(Event_t* e); voidRecordGuiCNEvent(Event_t* e); voidRecordGuiEvent(Event_t* e, Window_t wid); voidRecordMousePosition(); voidRecordPave(const TObject* obj); voidRecordText(const TObject* obj); voidRegisterWindow(Window_t w); virtual Bool_tTRecorderState::Replay(TRecorder*, const char*, Bool_t, TRecorder::EReplayModes); virtual voidTRecorderState::ReplayStop(TRecorder*); virtual voidTRecorderState::Resume(TRecorder*); virtual voidShowMembers(TMemberInspector&); virtual voidTRecorderState::Start(TRecorder*, const char*, Option_t*, Window_t*, Int_t); voidStartEditing(); virtual voidStop(TRecorder* r, Bool_t guiCommand); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. TRecorderRecording(TRecorder* r, const char* filename, Option_t* option, Window_t* w, Int_t winCount); voidTRecorderState::ChangeState(TRecorder* r, TRecorderState* s, Bool_t deletePreviousState); Bool_tStartRecording(). private:. (unknown)(); voidCopyEvent(Event_t* e, Window_t wid); Bool_tIsFiltered(Window_t id); voidSetTypeOfConfigureNotify(Event_t*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TRecorderRecording.html:772,Pause,Pause,772,root/html534/TRecorderRecording.html,https://root.cern,https://root.cern/root/html534/TRecorderRecording.html,2,"['Pause', 'Resume']","['Pause', 'Resume']"
Usability,"e; Inherited Members; Includes; Libraries. Function documentation; void SetFunction( Function & f). double Integral(const ROOT::Math::IGenFunction& f, double a, double b). double Integral(double a, double b). double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). IntegratorOneDim(ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, unsigned int rule = 0); constructors. Constructor of one dimensional Integrator, default type is adaptive. @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL kADAPTIVE type). Possible type values are : kGAUSS (simple Gauss method), kADAPTIVE (from GSL), kADAPTIVESINGULAR (from GSL), kNONADAPTIVE (from GSL); Possible rule values are kGAUS15 (rule = 1), kGAUS21( rule = 2), kGAUS31(rule =3), kGAUS41 (rule=4), kGAUS51 (rule =5), kGAUS61(rule =6); lower rules are indicated for singular functions while higher for smooth functions to get better accuracies. NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Constructor of one dimensional Integrator passing a function interface. @param f integration function (1D interface). It is copied inside; @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). NOTE: When the default values are passed, the values used are taken from the defa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__IntegratorOneDim.html:4966,simpl,simple,4966,root/html528/ROOT__Math__IntegratorOneDim.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__IntegratorOneDim.html,10,['simpl'],['simple']
Usability,"e; static TObject::(anonymous)TObject::kZombie. protected:. TStringfFilenameEvents file name. private:. TRecorderState*fRecorderState! Current state of recorder. Class Charts. Inheritance Chart:. TObject. ←; TRecorder. Function documentation; TRecorder(); Creates initial INACTIVE state for the recorder. TRecorder(const char* filename, Option_t* option = ""READ""); Creates a recorder with filename to replay or to record,; depending on option (NEW or RECREATE will start recording,; READ will start replaying). ~TRecorder(); Destructor. void Browse(TBrowser* ); Browse the recorder from a ROOT file. This allows to replay a; session from the browser. void Start(const char* filename, Option_t* option = ""RECREATE"", Window_t* w = 0, Int_t winCount = 0); Starts recording events. void Stop(Bool_t guiCommand = kFALSE); Stopps recording events. Bool_t Replay(const char* filename, Bool_t showMouseCursor = kTRUE, TRecorder::EReplayModes mode = kRealtime); Replays events from 'filename'. void Pause(); Pauses replaying. void Resume(); Resumes replaying. void ReplayStop(); Cancells replaying. void ListCmd(const char* filename); Prints out recorded commandline events. void ListGui(const char* filename); Prints out recorded GUI events. void ChangeState(TRecorderState* newstate, Bool_t deletePreviousState = kTRUE); Changes state from the current to the passed one (newstate); Deletes the old state if delPreviousState = KTRUE. void PrevCanvases(const char* filename, Option_t* option); Save previous canvases in a .root file. TRecorder(const TRecorder& ). TRecorder & operator=(const TRecorder& ). Bool_t Replay(const char* filename, Bool_t showMouseCursor = kTRUE, TRecorder::EReplayModes mode = kRealtime); Replays recorded events from given file. TRecorder::ERecorderState GetState() const; Gets current state of recorder. » Author: Katerina Opocenska 11/09/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-02 16:32; This pag",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TRecorder.html:9690,Pause,Pause,9690,root/html604/TRecorder.html,https://root.cern,https://root.cern/root/html604/TRecorder.html,2,['Pause'],"['Pause', 'Pauses']"
Usability,"e; static TObject::(anonymous)TObject::kZombie. protected:. TStringfFilenameEvents file name. private:. TRecorderState*fRecorderState! Current state of recorder. Class Charts. Inheritance Chart:. TObject. ←; TRecorder. Function documentation; TRecorder(); Creates initial INACTIVE state for the recorder. TRecorder(const char* filename, Option_t* option = ""READ""); Creates a recorder with filename to replay or to record,; depending on option (NEW or RECREATE will start recording,; READ will start replaying). ~TRecorder(); Destructor. void Browse(TBrowser* ); Browse the recorder from a ROOT file. This allows to replay a; session from the browser. void Start(const char* filename, Option_t* option = ""RECREATE"", Window_t* w = 0, Int_t winCount = 0); Starts recording events. void Stop(Bool_t guiCommand = kFALSE); Stopps recording events. Bool_t Replay(const char* filename, Bool_t showMouseCursor = kTRUE, TRecorder::EReplayModes mode = kRealtime); Replays events from 'filename'. void Pause(); Pauses replaying. void Resume(); Resumes replaying. void ReplayStop(); Cancells replaying. void ListCmd(const char* filename); Prints out recorded commandline events. void ListGui(const char* filename); Prints out recorded GUI events. void ChangeState(TRecorderState* newstate, Bool_t deletePreviousState = kTRUE); Changes state from the current to the passed one (newstate); Deletes the old state if delPreviousState = KTRUE. void PrevCanvases(const char* filename, Option_t* option); Save previous canvases in a .root file. TRecorder(const TRecorder& ). TRecorder & operator=(const TRecorder& ). Bool_t Replay(const char* filename, Bool_t showMouseCursor = kTRUE, TRecorder::EReplayModes mode = kRealtime); Replays recorded events from given file. TRecorder::ERecorderState GetState() const; Gets current state of recorder. » Author: Katerina Opocenska 11/09/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 15:29; This pag",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRecorder.html:9690,Pause,Pause,9690,root/html602/TRecorder.html,https://root.cern,https://root.cern/root/html602/TRecorder.html,2,['Pause'],"['Pause', 'Pauses']"
Usability,"e;  ; void AddInput (TObject *inp) override;  Add object to input list. ;  ; void AddQueryResult (TQueryResult *q) override;  Add query result to the list, making sure that there are no duplicates. ;  ; void ClearInput () override;  Clear input list. ;  ; TDrawFeedback * CreateDrawFeedback (TProof *p) override;  Draw feedback creation proxy. ;  ; void DeleteDrawFeedback (TDrawFeedback *f) override;  Delete draw feedback object. ;  ; void FeedBackCanvas (const char *name, Bool_t create);  Create/destroy a named canvas for feedback. ;  ; Long64_t GetCacheSize () override;  Return the size in bytes of the cache. ;  ; TQueryResult * GetCurrentQuery () const override;  ; Int_t GetDrawArgs (const char *var, const char *sel, Option_t *opt, TString &selector, TString &objname) override;  Parse the arguments from var, sel and opt and fill the selector and object name accordingly. ;  ; Long64_t GetEventsProcessed () const override;  ; EExitStatus GetExitStatus () const override;  ; TList * GetInputList () const override;  ; Int_t GetLearnEntries () override;  Return the number of entries in the learning phase. ;  ; TList * GetListOfResults () const override;  ; TObject * GetOutput (const char *name) const override;  Get output object by name. ;  ; TList * GetOutputList () const override;  Get output list. ;  ; TProofProgressStatus * GetProgressStatus () const override;  ; TQueryResult * GetQueryResult (const char *ref) override;  Get query result instances referenced 'ref' from the list of results. ;  ; void HandleGetTreeHeader (TMessage *mess) override;  Handle tree header request. ;  ; void HandleRecvHisto (TMessage *mess) override;  Receive histo from slave. ;  ; Int_t ReinitSelector (TQueryResult *qr) override;  Reinitialize fSelector using the selector files in the query result. ;  ; void RemoveQueryResult (const char *ref) override;  Remove all query result instances referenced 'ref' from the list of results. ;  ; void RestorePreviousQuery () override;  ; Int_t SavePart",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerLite.html:6123,learn,learning,6123,doc/master/classTProofPlayerLite.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerLite.html,3,['learn'],['learning']
Usability,"e;; 1038 if ((hype->GetStIn() == 0) && (hype->GetStOut() == 0)); 1039 return countTubeFaces({hype->GetRmax(), hype->GetRmax()}, {hype->GetRmin(), hype->GetRmin()});; 1040 int radiusSegments = GetUsedNSegments(4), heightSegments = 30;; 1041 return radiusSegments * (heightSegments + 1) * ((hype->GetRmin() > 0.) ? 4 : 2);; 1042 } else if (shape->IsA() == TGeoTessellated::Class()) {; 1043 auto tess = (TGeoTessellated *)shape;; 1044 int numfaces = 0;; 1045 for (int i = 0; i < tess->GetNfacets(); ++i) {; 1046 if (tess->GetFacet(i).GetNvert() == 4); 1047 numfaces += 2;; 1048 else; 1049 numfaces += 1;; 1050 }; 1051 return numfaces;; 1052 } else if (shape->IsA() == TGeoScaledShape::Class()) {; 1053 auto scaled = (TGeoScaledShape *)shape;; 1054 return CountShapeFaces(scaled->GetShape());; 1055 } else if (shape->IsA() == TGeoCompositeShape::Class()) {; 1056 auto comp = (TGeoCompositeShape *)shape;; 1057 if (!comp->GetBoolNode()); 1058 return 0;; 1059 return CountShapeFaces(comp->GetBoolNode()->GetLeftShape()) +; 1060 CountShapeFaces(comp->GetBoolNode()->GetRightShape());; 1061 }; 1062 ; 1063 // many of simple shapes have 12 faces; 1064 return 12;; 1065}; 1066 ; 1067/////////////////////////////////////////////////////////////////////; 1068/// Find description object and create render information; 1069 ; 1070RGeomDescription::ShapeDescr &RGeomDescription::MakeShapeDescr(TGeoShape *shape); 1071{; 1072 auto &elem = FindShapeDescr(shape);; 1073 ; 1074 if (elem.nfaces == 0) {; 1075 ; 1076 int boundary = 3; //; 1077 if (shape->IsComposite()) {; 1078 // composite is most complex for client, therefore by default build on server; 1079 boundary = 1;; 1080 } else if (!shape->IsCylType()) {; 1081 // simple box geometry is compact and can be delivered as raw; 1082 boundary = 2;; 1083 }; 1084 ; 1085 if (IsBuildShapes() < boundary) {; 1086 elem.nfaces = 1;; 1087 elem.fShapeInfo.shape = shape;; 1088 } else {; 1089 ; 1090 int old_nsegm = -1;; 1091 if (fCfg.nsegm > 0 && gGeoManager) {; 1092 old_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RGeomData_8cxx_source.html:31718,simpl,simple,31718,doc/master/RGeomData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RGeomData_8cxx_source.html,2,['simpl'],['simple']
Usability,"e< T; ROOT::InternalDefinition TErrorDefaultHandler.hxx:16; ROOT::Internal::GetSymInLibImtstatic Func_t GetSymInLibImt(const char *funcname)Definition TROOT.cxx:401; ROOT::Internal::gGetROOTstatic GetROOTFun_t gGetROOTDefinition TROOT.cxx:399; ROOT::Internal::gROOTLocalR__EXTERN TROOT * gROOTLocalDefinition TROOT.h:379; ROOT::Internal::DisableParBranchProcessingvoid DisableParBranchProcessing()Globally disables the IMT use case of parallel branch processing, deactivating the corresponding lock...Definition TROOT.cxx:434; ROOT::Internal::ErrorSystemMsgHandlerFunc_tstd::function< const char *()> ErrorSystemMsgHandlerFunc_tRetrieves the error string associated with the last system error.Definition TError.h:59; ROOT::Internal::IsImplicitMTEnabledImplstatic Bool_t & IsImplicitMTEnabledImpl()Keeps track of the status of ImplicitMT w/o resorting to the load of libImt.Definition TROOT.cxx:463; ROOT::Internal::MinimalErrorHandlervoid MinimalErrorHandler(int level, Bool_t abort, const char *location, const char *msg)A very simple error handler that is usually replaced by the TROOT default error handler.Definition TError.cxx:67; ROOT::Internal::GetROOTFun_tTROOT *(* GetROOTFun_t)()Definition TROOT.cxx:397; ROOT::Internal::SetErrorSystemMsgHandlerErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystemMsgHandlerFunc_t h)Returns the previous system error message handler.Definition TError.cxx:56; ROOT::Internal::EnableParBranchProcessingvoid EnableParBranchProcessing()Globally enables the parallel branch processing, which is a case of implicit multi-threading (IMT) in...Definition TROOT.cxx:420; ROOT::Internal::IsParBranchProcessingEnabledBool_t IsParBranchProcessingEnabled()Returns true if parallel branch processing is enabled.Definition TROOT.cxx:447; ROOT::Internal::GetROOT2TROOT * GetROOT2()Definition TROOT.cxx:387; ROOT::Internal::GetROOT1TROOT * GetROOT1()Definition TROOT.cxx:380; ROOT::Internal::ReleaseDefaultErrorHandlervoid ReleaseDefaultErrorHandler()Destructs r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TROOT_8cxx_source.html:171412,simpl,simple,171412,doc/v632/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html,1,['simpl'],['simple']
Usability,"e< T; ROOT::InternalDefinition TErrorDefaultHandler.hxx:16; ROOT::Internal::GetSymInLibImtstatic Func_t GetSymInLibImt(const char *funcname)Definition TROOT.cxx:401; ROOT::Internal::gGetROOTstatic GetROOTFun_t gGetROOTDefinition TROOT.cxx:399; ROOT::Internal::gROOTLocalR__EXTERN TROOT * gROOTLocalDefinition TROOT.h:379; ROOT::Internal::DisableParBranchProcessingvoid DisableParBranchProcessing()Globally disables the IMT use case of parallel branch processing, deactivating the corresponding lock...Definition TROOT.cxx:434; ROOT::Internal::ErrorSystemMsgHandlerFunc_tstd::function< const char *()> ErrorSystemMsgHandlerFunc_tRetrieves the error string associated with the last system error.Definition TError.h:60; ROOT::Internal::IsImplicitMTEnabledImplstatic Bool_t & IsImplicitMTEnabledImpl()Keeps track of the status of ImplicitMT w/o resorting to the load of libImt.Definition TROOT.cxx:463; ROOT::Internal::MinimalErrorHandlervoid MinimalErrorHandler(int level, Bool_t abort, const char *location, const char *msg)A very simple error handler that is usually replaced by the TROOT default error handler.Definition TError.cxx:67; ROOT::Internal::GetROOTFun_tTROOT *(* GetROOTFun_t)()Definition TROOT.cxx:397; ROOT::Internal::SetErrorSystemMsgHandlerErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystemMsgHandlerFunc_t h)Returns the previous system error message handler.Definition TError.cxx:56; ROOT::Internal::EnableParBranchProcessingvoid EnableParBranchProcessing()Globally enables the parallel branch processing, which is a case of implicit multi-threading (IMT) in...Definition TROOT.cxx:420; ROOT::Internal::IsParBranchProcessingEnabledBool_t IsParBranchProcessingEnabled()Returns true if parallel branch processing is enabled.Definition TROOT.cxx:447; ROOT::Internal::GetROOT2TROOT * GetROOT2()Definition TROOT.cxx:387; ROOT::Internal::GetROOT1TROOT * GetROOT1()Definition TROOT.cxx:380; ROOT::Internal::ReleaseDefaultErrorHandlervoid ReleaseDefaultErrorHandler()Destructs r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:171588,simpl,simple,171588,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,1,['simpl'],['simple']
Usability,"e=10""); // full output every; // 10 epochs; network.Train(100,""text,+""); // 100 more epochs; //starts with existing weights; The weights can be saved to a file (DumpWeights) and then reloaded (LoadWeights) to a new compatible network. The output can also be evaluated (Evaluate) for a given output neuron and an array of double input parameters or the network can be exported (Export) as a standalone code. Up to now, this is only as a C++ or PYTHON class, but other languages could be implemented.; 5.12.5 Examples; An example of how to use TMultiLayerPerceptron is the macro mlpHiggs.C in $ROOTSYS/tutorials. Using some standard simulated information that could have been obtained at LEP, a neural network is build, which can make the difference between WW events and events containing a Higgs boson. Starting with a TFile containing two TTrees: one for the signal, the other for the background, a simple script is used:; void mlpHiggs(Int_t ntrain=100) {; if (!gROOT->GetClass(""TMultiLayerPerceptron"")); gSystem->Load(""libMLP"");; // prepare inputs - the 2 trees are merged into one, and a; // ""type"" branch, equal to 1 for the signal and 0 for the; // background is added; TFile input(""mlpHiggs.root"");; TTree *signal = (TTree *)input.Get(""sig_filtered"");; TTree *background = (TTree *)input.Get(""bg_filtered"");; TTree *simu = new TTree(""MonteCarlo"",; ""Filtered Monte Carlo Events"");; ...; Since the input is a TTree and we are starting from two different TTrees (with different names), they are first merged into one, and a “type” branch is added, that says whether there is a signal or a background event. Those irrelevant details are skipped here.; ...; TMultiLayerPerceptron *mlp = new TMultiLayerPerceptron(; ""msumf,ptsumf, acolin, acopl:8:type"",""ptsumf"",simu,; ""Entry$%2"",""Entry$/2"");; mlp->Train(ntrain, ""text,graph,update=10"");; The neural network is instantiated and trained. “ptsumf” is used as a weight, and the standard event lists are explicit. The network that is then build has four",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:238200,simpl,simple,238200,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"e> Template of Lazy Symmeytric class; TMatrixTSymLazy<float> Template of Lazy Symmeytric class; TMehrotraSolver Mehrotra Qp Solver class; TMemStat a user interface class of MemStat; TMemberInspector ABC for inspecting class data members; TMemberStreamer ; TMergerInfo Basic info on merger, i.e. worker serving as merger; TMessage Message buffer class; TMessageHandler Generic message handler; TMethod Dictionary for a class member function (method); TMethodArg Dictionary for a method argument; TMethodBrowsable Helper object to browse methods; TMethodCall Method calling interface; TMinuit The MINUIT minimisation package; TMinuitMinimizer Implementation of Minimizer interface using TMinuit ; TMixture Mixtures used in the Geometry Shapes; TModuleDocInfo documentation for a group of classes; TMonitor Monitor activity on a set of TSocket objects; TMultiDimFit Multi dimensional fit class; TMultiGraph A collection of TGraph objects; TMultiLayerPerceptron a Neural Network; TMutex Mutex lock class; TMutexImp Mutex lock implementation ABC; TMySQLResult MySQL query result; TMySQLRow One row of MySQL query result; TMySQLServer Connection to MySQL server; TMySQLStatement SQL statement class for MySQL DB; TNamed The basis for a named object (name, title); TNetFile A ROOT file that reads/writes via a rootd server; TNetSystem Directory handler for NetSystem; TNeuron Neuron for MultiLayerPerceptrons; TNewChainDlg New chain dialog; TNewQueryDlg New query dialog; TNode Description of parameters to position a 3-D geometry object; TNodeDiv Description of parameters to divide a 3-D geometry object; TNonSplitBrowsable Helper object to browse unsplit objects; TNtuple A simple tree with branches of floats.; TNtupleD A simple tree with branches of floats.; TObjArray An array of objects; TObjArrayIter Object array iterator; TObjString Collectable string class; TObject Basic ROOT object; TObjectRefSpy Spy object reference for deletion; TObjectSet TDataSet wrapper for TObject class objects; TObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ClassIndex.html:109063,simpl,simple,109063,root/html528/ClassIndex.html,https://root.cern,https://root.cern/root/html528/ClassIndex.html,1,['simpl'],['simple']
Usability,"e? ROOT is not a particularly good framework that is written in a language that isn't quite C++. If you are going to break away and make/use/write cling, then fix the poor design decisions: cling will probably break compatibility anyways despite your best efforts, so you might as well take the time and effort to refactor and clean up the code base. A simple example, taken from this website: """""" TFFTComplex One of the interface classes to the FFTW package, can be used directly or via the TVirtualFFT class. Only the basic interface of FFTW is implemented. Computes complex input/output discrete Fourier transforms (DFT) in one or more dimensions. For the detailed information on the computed transforms please refer to the FFTW manual, chapter ""What FFTW really computes"". How to use it: 1) Create an instance of TFFTComplex - this will allocate input and output arrays (unless an in-place transform is specified) 2) Run the Init() function with the desired flags and settings ... """""" This is simply poor design. This should look like: root::Fft, removing the T, using a namespace, using templates instead of inheritence, etc. But also, notice that you have to run an Init function. Why? That is specifically what the constructor is for. Why does everything in ROOT know how to draw itself? Why does everything in ROOT have 100 methods, for ""quick access"" to other objects that do the actual work of those methods? These are questions that should be asked. But most of all, if you aren't going to fix these problems, why bother migrating at all? You fail to treat this migration as what it actually is. You are migrating to a new language, not a new version of a language. ROOT isn't written in C++. It's written in CINT. I am just frustrated to see this happen, because I know this community can do better. Maybe I'll make a draft of some smaller changes that need to be made and submit them to the mailing list. But honestly, I'm not very hopeful about this migration. Submitted by Anonymous (n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html:11371,simpl,simply,11371,d/blog/do-we-need-yet-another-custom-c-interpreter.html,https://root.cern,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html,1,['simpl'],['simply']
Usability,"eAll(""**"",""^"");; 1774 formula.ReplaceAll(""++"",""@""); // for linear functions; 1775 formula.ReplaceAll("" "","""");; 1776 HandlePolN(formula);; 1777 HandleParametrizedFunctions(formula);; 1778 HandleParamRanges(formula);; 1779 HandleFunctionArguments(formula);; 1780 HandleExponentiation(formula);; 1781 // ""++"" wil be dealt with Handle Linear; 1782 HandleLinear(formula);; 1783 // special case for ""--"" and ""++""; 1784 // (""++"" needs to be written with whitespace that is removed before but then we re-add it again; 1785 formula.ReplaceAll(""--"",""- -"");; 1786 formula.ReplaceAll(""++"",""+ +"");; 1787}; 1788 ; 1789////////////////////////////////////////////////////////////////////////////////; 1790/// prepare the formula to be executed; 1791/// normally is called with fFormula; 1792 ; 1793Bool_t TFormula::PrepareFormula(TString &formula); 1794{; 1795 fFuncs.clear();; 1796 fReadyToExecute = false;; 1797 ExtractFunctors(formula);; 1798 ; 1799 // update the expression with the new formula; 1800 fFormula = formula;; 1801 // save formula to parse variable and parameters for Cling; 1802 fClingInput = formula;; 1803 // replace all { and }; 1804 fFormula.ReplaceAll(""{"","""");; 1805 fFormula.ReplaceAll(""}"","""");; 1806 ; 1807 // std::cout << ""functors are extracted formula is "" << std::endl;; 1808 // std::cout << fFormula << std::endl << std::endl;; 1809 ; 1810 fFuncs.sort();; 1811 fFuncs.unique();; 1812 ; 1813 // use inputFormula for Cling; 1814 ProcessFormula(fClingInput);; 1815 ; 1816 // for pre-defined functions (need after processing); 1817 if (fNumber != 0) SetPredefinedParamNames();; 1818 ; 1819 return fReadyToExecute && fClingInitialized;; 1820}; 1821 ; 1822////////////////////////////////////////////////////////////////////////////////; 1823/// Extracts functors from formula, and put them in fFuncs.; 1824/// Simple grammar:; 1825/// - `<function>` := name(arg1,arg2...); 1826/// - `<variable>` := name; 1827/// - `<parameter>` := [number]; 1828/// - `<name>` := String containing lower and ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFormula_8cxx_source.html:68024,clear,clear,68024,doc/master/TFormula_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html,1,['clear'],['clear']
Usability,"eAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCLsCleanupThreshold(Double_t th); virtual voidSetConfidenceLevel(Double_t cl); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetInterpolationOption(RooStats::HypoTestInverterResult::InterpolOption_t opt); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetTestSize(Double_t size); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; RooStats::SimpleIntervalRooStats::SimpleInterval::SimpleInterval(const char* name = 0); RooStats::SimpleIntervalRooStats::SimpleInterval::SimpleInterval(const RooStats::SimpleInterval&); RooStats::SimpleIntervalRooStats::SimpleInterval::SimpleInterval(const RooStats::SimpleInterval& other, const char* name); RooStats::SimpleIntervalRooStats::SimpleInterval::SimpleInterval(const char* name, const RooRealVar& var, Double_t lower, Double_t upper, Double_t cl); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Double_tUpperLimit(); Double_tUpperLimitEstimatedError(); voidUseCLs(bool on = true); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HypoTestInverterResult.html:7287,Simpl,SimpleInterval,7287,root/html602/RooStats__HypoTestInverterResult.html,https://root.cern,https://root.cern/root/html602/RooStats__HypoTestInverterResult.html,18,['Simpl'],"['SimpleInterval', 'SimpleIntervalRooStats']"
Usability,eCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cache; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; TTree*fOwner! pointer to the owner Tree/chain; Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; Long64_t*TFileCacheRead::fSeek[fNseek] Position on file of buffers to be prefetched; Int_t*TFileCacheRead::fSeekIndex[fNseek] sorted index table of fSeek; Int_t*TFileCacheRead::fSeekLen[fNseek] Length of buffers to be prefetched; Int_t*TFileCacheRead::fSeekPos[fNseek] Position of sorted blocks in fBuffer; Int_tTFileCacheRead::fSeekSizeAllocated size of fSeek; Long64_t*TFileCacheRead::fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*TFileCacheRead::fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted); TTree*fTree! pointer to the current Tree; Long64_tfZipBytes! Total compressed size of branches in cache; static Int_tfgLearnEntriesNumber of entries used for learning mode.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCache.html:17103,learn,learning,17103,root/html528/TTreeCache.html,https://root.cern,https://root.cern/root/html528/TTreeCache.html,1,['learn'],['learning']
Usability,"eCacheRead::fSeekSizeAllocated size of fSeek; Long64_t*TFileCacheRead::fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*TFileCacheRead::fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted); Long64_tfTotalUnzipBytes! The total sum of the currently unzipped blks; TTree*TTreeCache::fTree! pointer to the current Tree; Long64_tfUnzipBufferSize! Max Size for the ready unzipped blocks (default is 2*fBufferSize); char**fUnzipChunks! [fNseek] Individual unzipped chunks. Their summed size is kept under control.; TCondition*fUnzipDoneConditionUsed to wait for an unzip tour to finish. Gives the Async feel.; Int_t*fUnzipLen! [fNseek] Length of the unzipped buffers; TCondition*fUnzipStartConditionUsed to signal the threads to start.; unsigned char*fUnzipStatus! [fNSeek] For each blk, tells us if it's unzipped or pending; TThread*fUnzipThread[10]; Long64_tTTreeCache::fZipBytes! Total compressed size of branches in cache; static Int_tTTreeCache::fgLearnEntriesnumber of entries used for learning mode; static TTreeCacheUnzip::EParUnzipModefgParallelIndicate if we want to activate the parallelism; static Double_tfgRelBuffSizeThis is the percentage of the TTreeCacheUnzip that will be used. private:. char*fCompBuffer; Int_tfCompBufferSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeCacheUnzip(); Default Constructor. TTreeCacheUnzip(TTree* tree, Int_t buffersize = 0); Constructor. void Init(); Initialization procedure common to all the constructors. ~TTreeCacheUnzip(); destructor. (in general called by the TFile destructor; destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTreeCacheUnzip.html:13662,learn,learning,13662,root/html530/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html530/TTreeCacheUnzip.html,1,['learn'],['learning']
Usability,"eCurrentStyle(); Bool_tTGWidget::WantFocus() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidTGDoubleSlider::ChangeCursor(Event_t* event); static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static TStringTQObject::CompressName(const char* method_name); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidDoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); static voidTGDoubleSlider::FixBounds(Float_t& min, Float_t& max); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; TStringTGDoubleSlider::GetSString() const; voidTObject::MakeZombie(); Int_tTGWidget::SetFlags(Int_t flags); virtual voidSetPointerPos(Int_t z, Int_t opt = 0); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TGWindow::EEditModeTGWindow::kEditDisable; static TGWindow::EEditModeTGWindow::kEditDisableBtnEnable; static TGWindow::EEditModeTGWindow::kEditDisableEvents; static TGWindow::EEdit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGTripleHSlider.html:16243,Clear,ClearFlags,16243,root/html602/TGTripleHSlider.html,https://root.cern,https://root.cern/root/html602/TGTripleHSlider.html,4,['Clear'],['ClearFlags']
Usability,"eCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTCollection::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTCollection::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTSeqCollection::Changed(); static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTList::DeleteLink(TObjLink* lnk); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; TObjLink**TList::DoSort(TObjLink** head, Int_t n); TObjLink*TList::FindLink(const TObject* obj, Int_t& idx) const; virtual const char*TCollection::GetCollectionEntryName(TObject* entry) const; virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; virtual voidInit(const char* cl, void* object, const char* redo, const char* undo); TObjLink*TList::LinkAt(Int_t idx) const; Bool_tTList::LnkCompare(TObjLink* l1, TObjLink* l2); voidTObject::MakeZombie(); virtual TObjLink*TList::NewLink(TObject* obj, TObjLink* prev = NULL); virtual TObjLink*TList::NewOptLink(TObject* obj, Option_t* opt, TObjLink* prev = NULL); virtual voidTCollection::PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; virtual voidPrintCollectionHeader(Option_t* option) const. Data Members; public:. enum TCollection::[unnamed] { kIsOwner; kInitCapacity; kInitHashTableCapacity; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDele",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQCommand.html:15507,undo,undo,15507,root/html528/TQCommand.html,https://root.cern,https://root.cern/root/html528/TQCommand.html,4,['undo'],['undo']
Usability,"eCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTCollection::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTCollection::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTSeqCollection::Changed(); static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTList::DeleteLink(TObjLink* lnk); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; TObjLink**TList::DoSort(TObjLink** head, Int_t n); TObjLink*TList::FindLink(const TObject* obj, Int_t& idx) const; virtual const char*TCollection::GetCollectionEntryName(TObject* entry) const; virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; virtual voidInit(const char* cl, void* object, const char* redo, const char* undo); TObjLink*TList::LinkAt(Int_t idx) const; Bool_tTList::LnkCompare(TObjLink* l1, TObjLink* l2); voidTObject::MakeZombie(); virtual TObjLink*TList::NewLink(TObject* obj, TObjLink* prev = NULL); virtual TObjLink*TList::NewOptLink(TObject* obj, Option_t* opt, TObjLink* prev = NULL); virtual voidTCollection::PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; virtual voidPrintCollectionHeader(Option_t* option) const. private:. TQCommand&operator=(const TQCommand&). Data Members; public:. enum TCollection::[unnamed] { kIsOwner; kInitCapacity; kInitHashTableCapacity; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TQCommand.html:15651,undo,undo,15651,root/html534/TQCommand.html,https://root.cern,https://root.cern/root/html534/TQCommand.html,2,['undo'],['undo']
Usability,"eDirty() const; Returns true of value has been invalidated by server value change. Bool_t isValueDirtyAndClear() const; Returns true of value has been invalidated by server value change. Bool_t isValueOrShapeDirtyAndClear() const; Returns true of value has been invalidated by server value change. OperMode operMode() const; { return _operMode ; }. const RooArgSet* ownedComponents() const; { return _ownedComponents ; }. void setProhibitServerRedirect(Bool_t flag); { _prohibitServerRedirect = flag ; }. void operModeHook(); friend class RooSimCloneTool ;. {}. void optimizeDirtyHook(const RooArgSet* ); {}. void getParametersHook(const RooArgSet* , RooArgSet* , Bool_t ) const; {}. void getObservablesHook(const RooArgSet* , RooArgSet* ) const; {}. void setValueDirty() const; Dirty state modifiers. { if (_operMode==Auto && !inhibitDirty()) setValueDirty(0) ; }. void setShapeDirty() const; { setShapeDirty(0) ; }. void clearValueAndShapeDirty() const. void clearValueDirty() const. void clearShapeDirty() const. const char* cacheUniqueSuffix() const; { return 0 ; }. const TNamed* namePtr() const. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); { return kFALSE ; }. void serverNameChangeHook(const RooAbsArg* , const RooAbsArg* ); { }. void setExpensiveObjectCache(RooExpensiveObjectCache& cache); { _eocache = &cache ; }. Bool_t importWorkspaceHook(RooWorkspace& ); { return kFALSE ; }. void syncCache(const RooArgSet* nset = 0). void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE). void attachToVStore(RooVectorDataStore& vstore). void setTreeBranchStatus(TTree& t, Bool_t active). void fillTreeBranch(TTree& t). void setLocalNoDirtyInhibit(Bool_t flag) const; { _localNoInhibitDirty = flag ; }. Bool_t localNoDirtyInhibit() const; { return _localNoInhibitDirty ; }. » Last changed: Sat Jun 20 17:29:22 2015 » Last generated: 2015-06-20 17:29; This page has been automatically generated. For comments or suggestions r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooAbsArg.html:45984,clear,clearShapeDirty,45984,root/html604/RooAbsArg.html,https://root.cern,https://root.cern/root/html604/RooAbsArg.html,2,['clear'],['clearShapeDirty']
Usability,"eDirty() const; Returns true of value has been invalidated by server value change. Bool_t isValueDirtyAndClear() const; Returns true of value has been invalidated by server value change. Bool_t isValueOrShapeDirtyAndClear() const; Returns true of value has been invalidated by server value change. OperMode operMode() const; { return _operMode ; }. const RooArgSet* ownedComponents() const; { return _ownedComponents ; }. void setProhibitServerRedirect(Bool_t flag); { _prohibitServerRedirect = flag ; }. void operModeHook(); friend class RooSimCloneTool ;. {}. void optimizeDirtyHook(const RooArgSet* ); {}. void getParametersHook(const RooArgSet* , RooArgSet* , Bool_t ) const; {}. void getObservablesHook(const RooArgSet* , RooArgSet* ) const; {}. void setValueDirty() const; Dirty state modifiers. { if (_operMode==Auto && !inhibitDirty()) setValueDirty(0) ; }. void setShapeDirty() const; { setShapeDirty(0) ; }. void clearValueAndShapeDirty() const. void clearValueDirty() const. void clearShapeDirty() const. const char* cacheUniqueSuffix() const; { return 0 ; }. const TNamed* namePtr() const. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); { return kFALSE ; }. void serverNameChangeHook(const RooAbsArg* , const RooAbsArg* ); { }. void setExpensiveObjectCache(RooExpensiveObjectCache& cache); { _eocache = &cache ; }. Bool_t importWorkspaceHook(RooWorkspace& ); { return kFALSE ; }. void syncCache(const RooArgSet* nset = 0). void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE). void attachToVStore(RooVectorDataStore& vstore). void setTreeBranchStatus(TTree& t, Bool_t active). void fillTreeBranch(TTree& t). void setLocalNoDirtyInhibit(Bool_t flag) const; { _localNoInhibitDirty = flag ; }. Bool_t localNoDirtyInhibit() const; { return _localNoInhibitDirty ; }. » Last changed: Sun Jun 28 16:37:40 2015 » Last generated: 2015-06-28 16:37; This page has been automatically generated. For comments or suggestions r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsArg.html:44288,clear,clearShapeDirty,44288,root/html534/RooAbsArg.html,https://root.cern,https://root.cern/root/html534/RooAbsArg.html,2,['clear'],['clearShapeDirty']
Usability,"eDirty() const; Returns true of value has been invalidated by server value change. Bool_t isValueDirtyAndClear() const; Returns true of value has been invalidated by server value change. Bool_t isValueOrShapeDirtyAndClear() const; Returns true of value has been invalidated by server value change. OperMode operMode() const; { return _operMode ; }. const RooArgSet* ownedComponents() const; { return _ownedComponents ; }. void setProhibitServerRedirect(Bool_t flag); { _prohibitServerRedirect = flag ; }. void operModeHook(); friend class RooSimCloneTool ;. {}. void optimizeDirtyHook(const RooArgSet* ); {}. void getParametersHook(const RooArgSet* , RooArgSet* , Bool_t ) const; {}. void getObservablesHook(const RooArgSet* , RooArgSet* ) const; {}. void setValueDirty() const; Dirty state modifiers. { if (_operMode==Auto && !inhibitDirty()) setValueDirty(0) ; }. void setShapeDirty() const; { setShapeDirty(0) ; }. void clearValueAndShapeDirty() const. void clearValueDirty() const. void clearShapeDirty() const. const char* cacheUniqueSuffix() const; { return 0 ; }. const TNamed* namePtr() const. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); { return kFALSE ; }. void serverNameChangeHook(const RooAbsArg* , const RooAbsArg* ); { }. void setExpensiveObjectCache(RooExpensiveObjectCache& cache); { _eocache = &cache ; }. Bool_t importWorkspaceHook(RooWorkspace& ); { return kFALSE ; }. void syncCache(const RooArgSet* nset = 0). void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE). void attachToVStore(RooVectorDataStore& vstore). void setTreeBranchStatus(TTree& t, Bool_t active). void fillTreeBranch(TTree& t). void setLocalNoDirtyInhibit(Bool_t flag) const; { _localNoInhibitDirty = flag ; }. Bool_t localNoDirtyInhibit() const; { return _localNoInhibitDirty ; }. » Last changed: Tue Jun 30 14:29:52 2015 » Last generated: 2015-06-30 14:29; This page has been automatically generated. For comments or suggestions r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsArg.html:45984,clear,clearShapeDirty,45984,root/html602/RooAbsArg.html,https://root.cern,https://root.cern/root/html602/RooAbsArg.html,2,['clear'],['clearShapeDirty']
Usability,"eElement>::_wired! In wired mode, there is a single payload which is returned always. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooObjCacheManager(RooAbsArg* owner = 0, Int_t maxSize = 10, Bool_t clearCacheOnServerRedirect = kTRUE); Constructor of object cache manager for given owner. If clearCacheOnServerRedirect is true; all cache elements will be cleared when a server redirect is intercepted by the cache manager.; This is the default strategy and should only be overridden when you really understand; what you're doing as properly implementing server redirect in cache elements can get very; complicated, especially if there are (cyclical) reference back to the owning object. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); Copy constructor. ~RooObjCacheManager(); Destructor. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Intercept server redirect calls. If clearOnRedirect was set, sterilize; the cache (i.e. keep the structure but delete all contents). If not; forward serverRedirect to cache elements. void operModeHook(); Intercept changes to cache operation mode and forward to cache elements. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Intercept calls to perform automatic optimization of cache mode operation.; Forward calls to existing cache elements and save configuration of; cache mode optimization so that it can be applied on new cache elements; upon insertion. void sterilize(). void insertObjectHook(RooAbsCacheElement& ); Set owner link on all object inserted into cache.; Also if cache mode optimization was requested, apply; it now to cache element being inserted. void printCompactTreeHook(ostream& , const char* ); Add details on cache contents when printing in tree mode. void findConstantNodes(const RooArgSet& , RooArgSet& , RooLinkedList& ); If clearOnRedirect is false, forward constant term optimization calls to; cache eleme",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooObjCacheManager.html:4783,clear,clearOnRedirect,4783,root/html532/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html532/RooObjCacheManager.html,2,['clear'],['clearOnRedirect']
Usability,"eForCameraInterest. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveBoxSetGL(); Default constructor. ~TEveBoxSetGL(); Destructor. Int_t PrimitiveType() const; Return GL primitive used to render the boxes, based on the; render-mode specified in the model object. void MakeOriginBox(Float_t p[][3], Float_t dx, Float_t dy, Float_t dz) const; Fill array p to represent a box (0,0,0) - (dx,dy,dz). void RenderBoxStdNorm(const Float_t p[][3]) const; Render a box specified by points in array p with standard; axis-aligned normals. void RenderBoxAutoNorm(const Float_t p[][3]) const; Render box, calculate normals on the fly from first three points. void MakeDisplayList() const; Create a display-list for rendering a single box, based on the; current box-type.; Some box-types don't benefit from the display-list rendering and; so display-list is not created. Bool_t ShouldDLCache(const TGLRnrCtx& rnrCtx) const; Determines if display-list will be used for rendering.; Virtual from TGLLogicalShape. void DLCacheDrop(); Called when display lists have been destroyed externally and the; internal display-list data needs to be cleare.; Virtual from TGLLogicalShape. void DLCachePurge(); Called when display-lists need to be returned to the system.; Virtual from TGLLogicalShape. Bool_t SetModel(TObject* obj, Option_t* opt = 0); Set model object.; Virtual from TGLObject. void RenderBoxes(TGLRnrCtx& rnrCtx) const; GL rendering for all box-types. void DirectDraw(TGLRnrCtx& rnrCtx) const; Actual rendering code.; Virtual from TGLLogicalShape. void Render(TGLRnrCtx& rnrCtx); Interface for direct rendering from classes that include TEveBoxSet; as a member. TEveBoxSetGL(const TEveBoxSetGL& ). TEveBoxSetGL& operator=(const TEveBoxSetGL& ). » Last changed: root/eve:$Id$ » Last generated: 2015-03-13 19:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveBoxSetGL.html:5733,clear,cleare,5733,root/html534/TEveBoxSetGL.html,https://root.cern,https://root.cern/root/html534/TEveBoxSetGL.html,2,['clear'],['cleare']
Usability,eFrame.h. Member Data Documentation. ◆ fButtons. TGCompositeFrame* TGDockableFrame::fButtons. protected . container containing dock and hide buttons ; Definition at line 97 of file TGDockableFrame.h. ◆ fContainer. TGCompositeFrame* TGDockableFrame::fContainer. protected . container containing dockable frame ; Definition at line 96 of file TGDockableFrame.h. ◆ fDeleted. Bool_t TGDockableFrame::fDeleted. protected . kTRUE if it is being deleted ; Definition at line 93 of file TGDockableFrame.h. ◆ fDockButton. TGDockButton* TGDockableFrame::fDockButton. protected . dock button ; Definition at line 98 of file TGDockableFrame.h. ◆ fDockName. TString TGDockableFrame::fDockName. protected . name of frame ; Definition at line 95 of file TGDockableFrame.h. ◆ fEnableHide. Bool_t TGDockableFrame::fEnableHide. protected . if frame can be hidden ; Definition at line 91 of file TGDockableFrame.h. ◆ fEnableUndock. Bool_t TGDockableFrame::fEnableUndock. protected . if frame can be undocked ; Definition at line 92 of file TGDockableFrame.h. ◆ fFixedSize. Bool_t TGDockableFrame::fFixedSize. protected . kTRUE if fixed size when undocked ; Definition at line 94 of file TGDockableFrame.h. ◆ fFrame. TGUndockedFrame* TGDockableFrame::fFrame. protected . undocked frame ; Definition at line 100 of file TGDockableFrame.h. ◆ fHidden. Bool_t TGDockableFrame::fHidden. protected . if frame is hidden ; Definition at line 90 of file TGDockableFrame.h. ◆ fHideButton. TGDockHideButton* TGDockableFrame::fHideButton. protected . hide button ; Definition at line 99 of file TGDockableFrame.h. ◆ fHints. TGLayoutHints* TGDockableFrame::fHints. protected . layout hints ; Definition at line 101 of file TGDockableFrame.h. ◆ fLb. TGLayoutHints* TGDockableFrame::fLb. protected . Definition at line 102 of file TGDockableFrame.h. ◆ fLc. TGLayoutHints * TGDockableFrame::fLc. protected . layout hints ; Definition at line 102 of file TGDockableFrame.h. Libraries for TGDockableFrame:. [legend]; The documentation for,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGDockableFrame.html:40124,undo,undocked,40124,doc/master/classTGDockableFrame.html,https://root.cern,https://root.cern/doc/master/classTGDockableFrame.html,1,['undo'],['undocked']
Usability,"eKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TStringfDrawstring to send to TTree::Draw(), NOT by GetScope()!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Browse(TBrowser* b); Browses a TCollectionPropertyBrowsable. The only difference to; the generic TVirtualBranchBrowsable::Browse is our fDraw. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); If the element to browse (given by either parent of branch) contains; a collection (TClonesArray or something for which a TVirtualCollectionProxy; exists), we will add some special objects to the browser. For now there is; just one object ""@size"", returning the size of the collection (as in; std::list::size(), or TClonesArray::GetEntries()).; The objects we create are simply used to forward strings (like ""@size"") to; TTreeFormula via our Browse method. These strings are stored in fName. void Register(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... void Unregister(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... ~TCollectionPropertyBrowsable(); {}. const char* GetDraw() const; return the string passed to TTree::Draw. TCollectionPropertyBrowsable(const char* name, const char* title, const char* draw, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); constructor, which sets the name and title according to the parameters; (and thus differently than our base class TVirtualBranchBrowsable). » Author: Axel Naumann 14/10/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-02 15:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TCollectionPropertyBrowsable.html:10129,simpl,simply,10129,root/html604/TCollectionPropertyBrowsable.html,https://root.cern,https://root.cern/root/html604/TCollectionPropertyBrowsable.html,2,['simpl'],['simply']
Usability,"eKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TStringfDrawstring to send to TTree::Draw(), NOT by GetScope()!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Browse(TBrowser* b); Browses a TCollectionPropertyBrowsable. The only difference to; the generic TVirtualBranchBrowsable::Browse is our fDraw. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); If the element to browse (given by either parent of branch) contains; a collection (TClonesArray or something for which a TVirtualCollectionProxy; exists), we will add some special objects to the browser. For now there is; just one object ""@size"", returning the size of the collection (as in; std::list::size(), or TClonesArray::GetEntries()).; The objects we create are simply used to forward strings (like ""@size"") to; TTreeFormula via our Browse method. These strings are stored in fName. void Register(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... void Unregister(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... ~TCollectionPropertyBrowsable(); {}. const char* GetDraw() const; return the string passed to TTree::Draw. TCollectionPropertyBrowsable(const char* name, const char* title, const char* draw, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); constructor, which sets the name and title according to the parameters; (and thus differently than our base class TVirtualBranchBrowsable). » Author: Axel Naumann 14/10/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-30 14:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TCollectionPropertyBrowsable.html:10129,simpl,simply,10129,root/html602/TCollectionPropertyBrowsable.html,https://root.cern,https://root.cern/root/html602/TCollectionPropertyBrowsable.html,2,['simpl'],['simply']
Usability,"eManager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); voidBuildList(TStyle* style = 0); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()SIGNAL ; virtual voidTGWindow::DestroySubwindows(); virtual voidTGWindow::DestroyWindow(); Bool_tTQObject::Disconnect(const char",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TStyleManager.html:5515,Clear,Clear,5515,root/html532/TStyleManager.html,https://root.cern,https://root.cern/root/html532/TStyleManager.html,4,['Clear'],['Clear']
Usability,"eMap(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); voidvector<long>::assign(initializer_list<vector<long>::value_type> __l); voidvector<long>::assign(vector<bool>::size_type __n, const vector<long>::value_type& __val); vector<long>::referencevector<long>::at(vector<bool>::size_type __n); vector<long>::const_referencevector<long>::at(vector<bool>::size_type __n) const; vector<long>::referencevector<long>::back(); vector<long>::const_referencevector<long>::back() const; TTable::iteratorBegin(); TTable::iteratorBegin() const; vector<long>::iteratorvector<long>::begin(); vector<long>::const_iteratorvector<long>::begin() const; virtual voidTObject::Browse(TBrowser* b); vector<bool>::size_typevector<long>::capacity() const; vector<long>::const_iteratorvector<long>::cbegin() const; vector<long>::const_iteratorvector<long>::cend() const; static TClass*Class(); virtual const char*TObject::ClassName() const; voidvector<long>::clear(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; vector<long>::const_reverse_iteratorvector<long>::crbegin() const; vector<long>::const_reverse_iteratorvector<long>::crend() const; long*vector<long>::data(); const long*vector<long>::data() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; boolvector<long>::empty() const; TTable::iteratorEnd(); TTable::iteratorEnd() const; vector<long>::iteratorvector<long>::end(); vector<long>::const_iteratorvector<long>::end() const; vector<long>::iteratorvector<long>::erase(vector<long>::iterator __positi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTableMap.html:2442,clear,clear,2442,root/html602/TTableMap.html,https://root.cern,https://root.cern/root/html602/TTableMap.html,2,['clear'],['clear']
Usability,"eMode (const RooArgSet &, RooArgSet &, RooLinkedList &) override;  Intercept calls to perform automatic optimization of cache mode operation. ;  ; void printCompactTreeHook (std::ostream &, const char *) override;  Add details on cache contents when printing in tree mode. ;  ; bool redirectServersHook (const RooAbsCollection &, bool, bool, bool) override;  Intercept server redirect calls. ;  ; void setClearOnRedirect (bool flag);  ; void sterilize () override;  Clear the cache payload but retain slot mapping w.r.t to normalization and integration sets. ;  ; void Streamer (TBuffer &) override;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooCacheManager< RooAbsCacheElement >;  RooCacheManager (const RooCacheManager &other, RooAbsArg *owner=nullptr);  Copy constructor. ;  ;  RooCacheManager (Int_t maxSize=2);  Constructor for simple caches without RooAbsArg payload. ;  ;  RooCacheManager (RooAbsArg *owner, Int_t maxSize=2);  Constructor for simple caches with RooAbsArg derived payload. ;  ;  ~RooCacheManager () override;  Destructor. ;  ; Int_t cacheSize () const;  Return size of cache. ;  ; RooAbsCacheElement * getObj (const RooArgSet *nset, const RooArgSet *iset, Int_t *sterileIdx, const char *isetRangeName);  ; RooAbsCacheElement * getObj (const RooArgSet *nset, const RooArgSet *iset, Int_t *sterileIndex=nullptr, const TNamed *isetRangeName=nullptr);  Retrieve payload object indexed on nset,uset amd isetRangeName If sterileIdx is not null, it is set to the index of the sterile slot in cacse such a slot is recycled. ;  ; RooAbsCacheElement * getObj (const RooArgSet *nset, Int_t *sterileIndex=nullptr, const TNamed *isetRangeName=nullptr);  Getter function without integration set. ;  ; RooAbsCacheElement * getObjByIndex (Int_t index) const;  Retrieve payload object by slot index. ;  ; Int_t lastIndex () const;  Return index of slot used in last get or set operation. ;  ; void reset ();  Clear the cache. ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooObjCacheManager.html:2741,simpl,simple,2741,doc/master/classRooObjCacheManager.html,https://root.cern,https://root.cern/doc/master/classRooObjCacheManager.html,1,['simpl'],['simple']
Usability,"eName=nullptr) const override;  Return analytical integral represent by appropriate element of projection cache. ;  ; std::unique_ptr< RooAbsArg > compileForNormSet (RooArgSet const &normSet, RooFit::Detail::CompileContext &ctx) const override;  ; RooAbsPdf * createProjection (const RooArgSet &iset) override;  Special version of RooAbsReal::createProjection that deals with projections of projections. ;  ; bool forceAnalyticalInt (const RooAbsArg &dep) const override;  Force RooRealIntegral to relegate integration of all observables to internal logic. ;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Mark all requested variables as internally integrated. ;  ; void initGenerator (Int_t) override;  Interface for one-time initialization to setup the generator for the specified code. ;  ; TClass * IsA () const override;  ; void printMetaArgs (std::ostream &os) const override;  Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the integration operation. ;  ; bool selfNormalized () const override;  Shows if a PDF is self-normalized, which means that no attempt is made to add a normalization term. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsPdf;  RooAbsPdf ();  Default constructor. ;  ;  RooAbsPdf (const char *name, const char *title, double minVal, double maxVal);  Constructor with name, title, and plot range. ;  ;  RooAbsPdf (const char *name, const char *title=nullptr);  Constructor with name and title only. ;  ;  ~RooAbsPdf () override;  Destructor. ;  ; virtual RooAbsGenContext * autoGenContext (const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool verbose=false, bool autoBinned=true, const char *binnedTag="""") const;  ; virtual Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classxRooProjectedPdf.html:2488,intuit,intuitively,2488,doc/master/classxRooProjectedPdf.html,https://root.cern,https://root.cern/doc/master/classxRooProjectedPdf.html,1,['intuit'],['intuitively']
Usability,"eName=nullptr, bool force=false);  Interface function to force use of a given normalization range to interpret function value. ;  ; void setTreeBranchStatus (TTree &t, bool active) override;  (De)Activate associated tree branch ;  ; void syncCache (const RooArgSet *set=nullptr) override;  ; double traceEval (const RooArgSet *set) const;  Calculate current value of object, with error tracing wrapper. ;  ;  Protected Member Functions inherited from RooAbsArg; void attachToStore (RooAbsDataStore &store);  Attach this argument to the data store such that it reads data from there. ;  ; TString cleanBranchName () const;  Construct a mangled name from the actual name that is free of any math symbols that might be interpreted by TTree. ;  ; void clearShapeDirty () const;  ; void clearValueAndShapeDirty () const;  ; void clearValueDirty () const;  ; virtual void getObservablesHook (const RooArgSet *, RooArgSet *) const;  ; virtual void getParametersHook (const RooArgSet *, RooArgSet *, bool) const;  ; void graphVizAddConnections (std::set< std::pair< RooAbsArg *, RooAbsArg * > > &);  Utility function that inserts all point-to-point client-server connections between any two RooAbsArgs in the expression tree headed by this object in the linkSet argument. ;  ; bool inhibitDirty () const;  Delete watch flag. ;  ; virtual void ioStreamerPass2 ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ; virtual void operModeHook ();  ; virtual void optimizeDirtyHook (const RooArgSet *);  ; void printAttribList (std::ostream &os) const;  Transient boolean attributes (not copied in ctor) ;  ; void registerProxy (RooArgProxy &proxy);  Register an RooArgProxy in the proxy list. ;  ; void registerProxy (RooListProxy &proxy);  Register an RooListProxy in the proxy list. ;  ; void registerProxy (RooSetProxy &proxy);  Register an RooSetProxy in the proxy list. ;  ; void setProxyNormSet (const RooArgSet *nset);  Forw",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinWidthFunction.html:55439,clear,clearShapeDirty,55439,doc/master/classRooBinWidthFunction.html,https://root.cern,https://root.cern/doc/master/classRooBinWidthFunction.html,399,['clear'],"['clearShapeDirty', 'clearValueAndShapeDirty', 'clearValueDirty']"
Usability,"eName=nullptr, bool force=false);  Interface function to force use of a given normalization range to interpret function value. ;  ; void setTreeBranchStatus (TTree &t, bool active) override;  (De)Activate associated tree branch ;  ; void syncCache (const RooArgSet *set=nullptr) override;  ; double traceEval (const RooArgSet *set) const;  Calculate current value of object, with error tracing wrapper. ;  ;  Protected Member Functions inherited from RooAbsArg; void attachToStore (RooAbsDataStore &store);  Attach this argument to the data store such that it reads data from there. ;  ; TString cleanBranchName () const;  Construct a mangled name from the actual name that is free of any math symbols that might be interpreted by TTree. ;  ; void clearShapeDirty () const;  ; void clearValueAndShapeDirty () const;  ; void clearValueDirty () const;  ; virtual void getObservablesHook (const RooArgSet *, RooArgSet *) const;  ; virtual void getParametersHook (const RooArgSet *, RooArgSet *, bool) const;  ; void graphVizAddConnections (std::set< std::pair< RooAbsArg *, RooAbsArg * > > &);  Utility function that inserts all point-to-point client-server connections between any two RooAbsArgs in the expression tree headed by this object in the linkSet argument. ;  ; bool inhibitDirty () const;  Delete watch flag. ;  ; virtual void ioStreamerPass2 ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ; virtual void optimizeDirtyHook (const RooArgSet *);  ; void printAttribList (std::ostream &os) const;  Transient boolean attributes (not copied in ctor) ;  ; void registerProxy (RooArgProxy &proxy);  Register an RooArgProxy in the proxy list. ;  ; void registerProxy (RooListProxy &proxy);  Register an RooListProxy in the proxy list. ;  ; void registerProxy (RooSetProxy &proxy);  Register an RooSetProxy in the proxy list. ;  ; void setProxyNormSet (const RooArgSet *nset);  Forward a change in the cached normal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedReal.html:55360,clear,clearShapeDirty,55360,doc/master/classRooCachedReal.html,https://root.cern,https://root.cern/doc/master/classRooCachedReal.html,3,['clear'],"['clearShapeDirty', 'clearValueAndShapeDirty', 'clearValueDirty']"
Usability,"eName=nullptr, bool force=false);  Interface function to force use of a given normalization range to interpret function value. ;  ; void setTreeBranchStatus (TTree &t, bool active) override;  (De)Activate associated tree branch ;  ; void syncCache (const RooArgSet *set=nullptr) override;  ; double traceEval (const RooArgSet *set) const;  Calculate current value of object, with error tracing wrapper. ;  ;  Protected Member Functions inherited from RooAbsArg; void attachToStore (RooAbsDataStore &store);  Attach this argument to the data store such that it reads data from there. ;  ; TString cleanBranchName () const;  Construct a mangled name from the actual name that is free of any math symbols that might be interpreted by TTree. ;  ; void clearShapeDirty () const;  ; void clearValueAndShapeDirty () const;  ; void clearValueDirty () const;  ; virtual void getObservablesHook (const RooArgSet *, RooArgSet *) const;  ; virtual void getParametersHook (const RooArgSet *, RooArgSet *, bool) const;  ; void graphVizAddConnections (std::set< std::pair< RooAbsArg *, RooAbsArg * > > &);  Utility function that inserts all point-to-point client-server connections between any two RooAbsArgs in the expression tree headed by this object in the linkSet argument. ;  ; bool inhibitDirty () const;  Delete watch flag. ;  ; virtual void operModeHook ();  ; virtual void optimizeDirtyHook (const RooArgSet *);  ; void printAttribList (std::ostream &os) const;  Transient boolean attributes (not copied in ctor) ;  ; void registerProxy (RooArgProxy &proxy);  Register an RooArgProxy in the proxy list. ;  ; void registerProxy (RooListProxy &proxy);  Register an RooListProxy in the proxy list. ;  ; void registerProxy (RooSetProxy &proxy);  Register an RooSetProxy in the proxy list. ;  ; void setProxyNormSet (const RooArgSet *nset);  Forward a change in the cached normalization argset to all the registered proxies. ;  ; void setShapeDirty (const RooAbsArg *source);  Notify that a shape-like property",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHistFunc.html:54663,clear,clearShapeDirty,54663,doc/master/classRooHistFunc.html,https://root.cern,https://root.cern/doc/master/classRooHistFunc.html,6,['clear'],"['clearShapeDirty', 'clearValueAndShapeDirty', 'clearValueDirty']"
Usability,eOutputindicates a potential tranformation of the output values before further computation DIRECT does not further transformation; SIGMOID applies a sigmoid transformation to each output value (to create a probability); SOFTMAX applies a softmax transformation to all output values (mutually exclusive probability) . Definition at line 122 of file NeuralNet.cxx. ◆ LayerData() [5/6]. TMVA::DNN::LayerData::LayerData ; (; const LayerData & ; other). inline . copy c'tor of LayerData ; Definition at line 515 of file NeuralNet.h. ◆ LayerData() [6/6]. TMVA::DNN::LayerData::LayerData ; (; LayerData && ; other). inline . move c'tor of LayerData ; Definition at line 538 of file NeuralNet.h. Member Function Documentation. ◆ activationFunction(). std::shared_ptr< std::function< double(double)> > TMVA::DNN::LayerData::activationFunction ; (; ); const. inline . Definition at line 607 of file NeuralNet.h. ◆ clear(). void TMVA::DNN::LayerData::clear ; (; ). inline . clear the values and the deltas ; Definition at line 576 of file NeuralNet.h. ◆ clearDropOut(). void TMVA::DNN::LayerData::clearDropOut ; (; ). inline . clear the drop-out-data for this layer ; Definition at line 620 of file NeuralNet.h. ◆ computeProbabilities(). LayerData::container_type TMVA::DNN::LayerData::computeProbabilities ; (; ); const. private . compute the probabilities from the node values ; Definition at line 140 of file NeuralNet.cxx. ◆ deltasBegin() [1/2]. iterator_type TMVA::DNN::LayerData::deltasBegin ; (; ). inline . returns iterator to the begin of the deltas (back-propagation) ; Definition at line 591 of file NeuralNet.h. ◆ deltasBegin() [2/2]. const_iterator_type TMVA::DNN::LayerData::deltasBegin ; (; ); const. inline . returns const iterator to the begin of the deltas (back-propagation) ; Definition at line 594 of file NeuralNet.h. ◆ deltasEnd() [1/2]. iterator_type TMVA::DNN::LayerData::deltasEnd ; (; ). inline . returns iterator to the end of the deltas (back-propagation) ; Definition at line 592 o,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1LayerData.html:10954,clear,clear,10954,doc/master/classTMVA_1_1DNN_1_1LayerData.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1LayerData.html,1,['clear'],['clear']
Usability,"ePad(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddCompositeOp(UInt_t operation); voidAddHistoPhysical(TGLLogicalShape* log, const Float_t* histColor = 0); virtual Int_tAddObject(const TBuffer3D& buffer, Bool_t* addChildren = 0); virtual Int_tAddObject(UInt_t physicalID, const TBuffer3D& buffer, Bool_t* addChildren = 0); voidTGLSceneBase::AddViewer(TGLViewerBase* viewer); virtual voidTGLScene::AdoptLogical(TGLLogicalShape& shape); virtual voidTGLScene::AdoptPhysical(TGLPhysicalShape& shape); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBeginScene(); UInt_tTGLScene::BeginSmartRefresh(); virtual Bool_tTGLScene::BeginUpdate(); const TGLBoundingBox&TGLSceneBase::BoundingBox() const; virtual voidTObject::Browse(TBrowser* b); virtual Bool_tBuildingScene() const; virtual voidTGLScene::CalcBoundingBox() const; virtual Bool_tCanLoopOnPrimitives() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); TGLClip*TGLSceneBase::Clip() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseComposite(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGLScene::TSceneInfo*TGLScene::CreateSceneInfo(TGLViewerBase* view); TGLLockable::ELockTGLLockable::CurrentLock() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Bool_tTGLScene::DestroyLogical(TObject* logid, Bool_t mustFind = kTRUE); virtual Int_tTGLScene::DestroyLogicals(); virtual Bool_tTGLScene::DestroyPhysical(UInt_t phid); virtual Int_tTGLScene::DestroyPhysicals(); virtual Int_tDistancetoPrimitive(Int_t, Int_t); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTVirtualViewer3D::DrawViewer(); virtual voidTObject::Dump() constMENU ; voidTGLScene::DumpMapSizes() const; virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGLScenePad.html:1520,Clear,Clear,1520,root/html532/TGLScenePad.html,https://root.cern,https://root.cern/root/html532/TGLScenePad.html,4,['Clear'],['Clear']
Usability,"ePoint(Float_t& x, Float_t& y); Pre-scale point (x, y) in projected coordinates for 2D projections:; RhoZ ~ (rho, z); RPhi ~ (r, phi), scaling phi doesn't make much sense. void PreScalePoint(Float_t& x, Float_t& y, Float_t& z); Pre-scale point (x, y, z) in projected coordinates for 3D projection. void AddPreScaleEntry(Int_t coord, Float_t max_val, Float_t scale); Add new scaling range for given coordinate.; Arguments:; coord 0 ~ x, 1 ~ y, 2 ~ z; value value of input coordinate from which to apply this scale;; scale the scale to apply from value onwards. NOTE: If pre-scaling is combined with center-displaced then; the scale of the central region should be 1. This limitation; can be removed but will cost CPU. void ChangePreScaleEntry(Int_t coord, Int_t entry, Float_t new_scale); Change scale for given entry and coordinate. NOTE: If the first entry you created used other value than 0,; one entry (covering range from 0 to this value) was created; automatically. void ClearPreScales(); Clear all pre-scaling information. void SetDistortion(Float_t d); Set distortion. void SetFixR(Float_t x); Set fixed radius. void SetFixZ(Float_t x); Set fixed radius. void SetPastFixRFac(Float_t x); Set 2's-exponent for relative scaling beyond FixR. Float_t* GetProjectedCenter(); Get projected center. void SetDisplaceOrigin(bool ); Set flag to displace for center.; This options is useful if want to have projected center; at (0, 0) position in projected coordinates and want to dismiss; gap around projected center in RhoZ projection. void SetPastFixZFac(Float_t x); Set 2's-exponent for relative scaling beyond FixZ. void BisectBreakPoint(TEveVector& vL, TEveVector& vR, Float_t eps_sqr); Find break-point on both sides of the discontinuity.; They still need to be projected after the call.; This is an obsolete version of the method that required manual; specification of precision -- this lead to (infrequent) infinite loops. void BisectBreakPoint(TEveVector& vL, TEveVector& vR, Bool_t project_res",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveProjection.html:6641,Clear,ClearPreScales,6641,root/html532/TEveProjection.html,https://root.cern,https://root.cern/root/html532/TEveProjection.html,8,['Clear'],"['Clear', 'ClearPreScales']"
Usability,"eProjectable::AnnihilateProjecteds(); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTEveElement::ApplyVizTag(const TString& tag, const TString& fallback_tag = """"); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual Bool_tCanMakeNewSlots() const; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidTEveWindow::ClearEveFrame(); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElementList*TEveElementList::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTEveElement::CopyVizParams(const TEveElement* el); virtual voidTEveElement::CopyVizParamsFromDB(); static TEveWindowSlot*TEveWindow::CreateDefaultWindowSlot(); static TEveWindowSlot*TEveWindow::CreateWindowInTab(TGTab* tab, TEveWindow* eve_parent = 0); static TEveWindowSlot*TEveWindow::CreateWindowMainFrame",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveWindowPack.html:2299,Clear,ClearEveFrame,2299,root/html532/TEveWindowPack.html,https://root.cern,https://root.cern/root/html532/TEveWindowPack.html,8,['Clear'],['ClearEveFrame']
Usability,"eProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCategoryLValue.html:2330,clear,clearValueDirty,2330,root/html532/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html532/RooAbsCategoryLValue.html,1,['clear'],['clearValueDirty']
Usability,"eProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*createFundamental(const char* newname = 0) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsString.html:2089,clear,clearValueDirty,2089,root/html532/RooAbsString.html,https://root.cern,https://root.cern/root/html532/RooAbsString.html,1,['clear'],['clearValueDirty']
Usability,"eProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*createFundamental(const char* newname = 0) const; Roo1DTable*createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCategory.html:2261,clear,clearValueDirty,2261,root/html532/RooAbsCategory.html,https://root.cern,https://root.cern/root/html532/RooAbsCategory.html,1,['clear'],['clearValueDirty']
Usability,"eProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooBinningCategory.html:2100,clear,clearValueDirty,2100,root/html532/RooBinningCategory.html,https://root.cern,https://root.cern/root/html532/RooBinningCategory.html,9,['clear'],['clearValueDirty']
Usability,"eProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsString::createFundamental(const char* newname = 0) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStringVar.html:1984,clear,clearValueDirty,1984,root/html532/RooStringVar.html,https://root.cern,https://root.cern/root/html532/RooStringVar.html,2,['clear'],['clearValueDirty']
Usability,"eProp)RooAbsArg; CheckedHash()TObjectinline; checkObservables(const RooArgSet *nset) constRooAbsArgvirtual; chi2FitTo(RooDataHist &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={})RooAbsRealvirtual; chi2FitTo(RooDataHist &data, const RooLinkedList &cmdList)RooAbsRealvirtual; chi2FitTo(RooDataSet &xydata, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={})RooAbsRealvirtual; chi2FitTo(RooDataSet &xydata, const RooLinkedList &cmdList)RooAbsRealvirtual; Class()RooAbsPdfstatic; Class_Name()RooAbsPdfstatic; Class_Version()RooAbsPdfinlinestatic; ClassName() constTObjectvirtual; cleanBranchName() constRooAbsArgprotected; Clear(Option_t *option="""") overrideTNamedvirtual; clearEvalErrorLog()RooAbsRealstatic; clearShapeDirty() constRooAbsArginlineprotected; clearValueAndShapeDirty() constRooAbsArginlineprotected; clearValueDirty() constRooAbsArginlineprotected; clients() constRooAbsArginline; Clone(const char *newname=nullptr) const overrideRooAbsArginlinevirtual; clone(const char *newname=nullptr) const =0RooAbsArgpure virtual; cloneTree(const char *newname=nullptr) constRooAbsArgvirtual; CollectErrors enum valueRooAbsReal; Compare(const TObject *other) const overrideRooAbsArgvirtual; compileForNormSet(RooArgSet const &normSet, RooFit::Detail::CompileContext &ctx) const overrideRooAbsPdfvirtual; ConfigChange enum valueRooAbsArg; constRooAbsArg; constRooAbsArg; ConstOpCode enum nameRooAbsArg; constOptimizeTestStatistic(ConstOpCode opcode, bool doAlsoTrackingOpt=true)RooAbsArgvirtual; ContentsOption enum nameRooPrintable; Copy(TObject &named) const overrideTNamedvirtual; copyCache(const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) overrideRooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf-members.html:5978,clear,clearEvalErrorLog,5978,doc/master/classRooAbsPdf-members.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf-members.html,1,['clear'],['clearEvalErrorLog']
Usability,"ePtr;  CTConfigurationBase class of the Configurations ;  CTConfiguredAction;  CTIDNode;  CTLoopConfigurationBase class of the Configurations for the member wise looping routines ;  CTNestedIDs;  ►Nwriter;  Cwriter;  C_x3d_data_;  C_x3d_sizeof_;  CAnyCollectionProxy;  CAnyCollectionStreamer;  CBalancerInfo;  Cbasic_string_view;  CBasicRNNLayerGeneric implementation ;  ►CBidirMMapPipeBidirMMapPipe creates a bidirectional channel between the current process and a child it forks ;  CPollEntryFor poll() interface ;  CBinaryOpPolicy;  CBinomialNeymanInterval;  CBinomialProbHelper;  CClassificationClass to perform two class classification ;  CClassificationResultClass to save the results of the classifier ;  CColorStruct_t;  CCompareAsc;  CcompareBAasc;  CcompareBAdesc;  CCompareDesc;  CContDistFree functions adapter needed by UNURAN for onedimensional continuous distributions ;  CContextSmall helper to keep current directory context ;  CCpuInfo_t;  CDebuggingSamplerDebuggingSampler is a simple implementation of the DistributionCreator interface used for debugging ;  CDebuggingTestStatDebuggingTestStat is a simple implementation of the DistributionCreator interface used for debugging ;  CDiscrDistFree functions adapter needed by UNURAN for one-dimensional discrete distribution ;  CEvent_t;  CExceptionContext_t;  CFeldmanCousinsBinomialInterval;  CFeldmanCousinsSorter;  CFileStat_t;  CFontAttributes_t;  CFontMetrics_t;  CFoption_t;  Cfuncptr_and_voidptr_t;  CGcCache_t;  CGCValues_t;  CGraphCreatorHelperHelper class that provides the operation graph nodes ;  CGraphNodeClass used to create the operation graph to be printed in the dot representation ;  Cgroup;  Ch1analysis;  Ch1analysisTreeReader;  Chash< std::experimental::basic_string_view< _CharT, _Traits > >;  CHelperOps;  CHEPEVT_DEFHEPEVT common block ;  CHit;  CHoption_tHistogram option structure ;  CHparam_tHistogram parameters structure ;  CJet;  CJetEvent;  CMemInfo_t;  ►CMemPoolForRooSetsMemory pool for RooArgSet an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:95241,simpl,simple,95241,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,1,['simpl'],['simple']
Usability,"eQuantile. ROOT::Math::VavilovFast. ROOT::Math::VirtualIntegratorMultiDim←. ROOT::Math::AdaptiveIntegratorMultiDim. ROOT::Math::GSLMCIntegrator. ROOT::Math::VirtualIntegratorOneDim←. ROOT::Math::GSLIntegrator. ROOT::Math::GaussIntegrator; ←. ROOT::Math::GaussLegendreIntegrator. ROOT::Math::WrappedMultiTF1. ROOT::Math::WrappedTF1. ROOT::Minuit2::CombinedMinimizer. ROOT::Minuit2::FCNBase←. ROOT::Minuit2::FCNGradientBase; ←. TFcnAdapter. ROOT::Minuit2::FumiliFCNBase. ROOT::Minuit2::FCNGradientBase←. TFcnAdapter. ROOT::Minuit2::FumiliFCNBase. ROOT::Minuit2::FumiliMinimizer. ROOT::Minuit2::Minuit2Minimizer. ROOT::Minuit2::MnFumiliMinimize. ROOT::Minuit2::MnMigrad. ROOT::Minuit2::MnMinimize. ROOT::Minuit2::MnScan. ROOT::Minuit2::MnSimplex. ROOT::Minuit2::ModularFunctionMinimizer←. ROOT::Minuit2::CombinedMinimizer. ROOT::Minuit2::FumiliMinimizer. ROOT::Minuit2::ScanMinimizer. ROOT::Minuit2::SimplexMinimizer. ROOT::Minuit2::VariableMetricMinimizer. ROOT::Minuit2::ScanMinimizer. ROOT::Minuit2::SimplexMinimizer. ROOT::Minuit2::VariableMetricMinimizer. ROOT::TArrayProxy<ROOT::TArrayType<Long64_t,0> >. ROOT::TArrayProxy<ROOT::TArrayType<ULong64_t,0> >. ROOT::TArrayProxy<ROOT::TArrayType<bool,0> >. ROOT::TArrayProxy<ROOT::TArrayType<char,0> >. ROOT::TArrayProxy<ROOT::TArrayType<double,0> >. ROOT::TArrayProxy<ROOT::TArrayType<float,0> >. ROOT::TArrayProxy<ROOT::TArrayType<int,0> >. ROOT::TArrayProxy<ROOT::TArrayType<long,0> >. ROOT::TArrayProxy<ROOT::TArrayType<short,0> >. ROOT::TArrayProxy<ROOT::TArrayType<unsigned char,0> >. ROOT::TArrayProxy<ROOT::TArrayType<unsigned int,0> >. ROOT::TArrayProxy<ROOT::TArrayType<unsigned long,0> >. ROOT::TArrayProxy<ROOT::TArrayType<unsigned short,0> >. ROOT::TBranchProxyClassDescriptor. ROOT::TBranchProxyDescriptor. ROOT::TClaArrayProxy<ROOT::TArrayType<Long64_t,0> >. ROOT::TClaArrayProxy<ROOT::TArrayType<ULong64_t,0> >. ROOT::TClaArrayProxy<ROOT::TArrayType<bool,0> >. ROOT::TClaArrayProxy<ROOT::TArrayType<char,0> >. ROOT::TClaArrayProxy<ROOT::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ClassHierarchy.html:5033,Simpl,SimplexMinimizer,5033,root/html534/ClassHierarchy.html,https://root.cern,https://root.cern/root/html534/ClassHierarchy.html,1,['Simpl'],['SimplexMinimizer']
Usability,"eReadCalls;  Number of read calls by basket to fill cached tree. ;  ; Int_t fNseek;  Number of blocks to be prefetched. ;  ; Int_t fNtot;  Total size of prefetched blocks. ;  ; Long64_t * fPos;  [fNb] start of long buffers ;  ; TFilePrefetch * fPrefetch;  ! Object that does the asynchronous reading in another thread ;  ; Long64_t fPrefetchedBlocks;  Number of blocks prefetched. ;  ; Int_t fReadCalls;  Number of read calls for this cache. ;  ; Long64_t * fSeek;  [fNseek] Position on file of buffers to be prefetched ;  ; Int_t * fSeekIndex;  [fNseek] sorted index table of fSeek ;  ; Int_t * fSeekLen;  [fNseek] Length of buffers to be prefetched ;  ; Int_t * fSeekPos;  [fNseek] Position of sorted blocks in fBuffer ;  ; Int_t fSeekSize;  Allocated size of fSeek. ;  ; Long64_t * fSeekSort;  [fNseek] Position on file of buffers to be prefetched (sorted) ;  ; Int_t * fSeekSortLen;  [fNseek] Length of buffers to be prefetched (sorted) ;  . Static Protected Attributes; static Int_t fgLearnEntries = 100;  number of entries used for learning mode ;  . Private Member Functions;  TTreeCache (const TTreeCache &)=delete;  this class cannot be copied ;  ; bool CalculateMissCache ();  Calculate the appropriate miss cache to fetch; helper function for FillMissCache. ;  ; TBranch * CalculateMissEntries (Long64_t, int, bool);  Given an file read, try to determine the corresponding branch. ;  ; bool CheckMissCache (char *buf, Long64_t pos, int len);  Check the miss cache for a particular buffer, fetching if deemed necessary. ;  ; bool FillMissCache ();  Fill the miss cache from the current set of active branches. ;  ; IOPos FindBranchBasketPos (TBranch &, Long64_t entry);  Given a branch and an entry, determine the file location (offset / size) of the corresponding basket. ;  ; TTreeCache & operator= (const TTreeCache &)=delete;  ; bool ProcessMiss (Long64_t pos, int len);  ! Given a file read not in the miss cache, handle (possibly) loading the data. ;  . Additional Inherited Members;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:32165,learn,learning,32165,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,['learn'],['learning']
Usability,"eTracker Class ReferenceRooFit » RooFit Core. ; Meta object that tracks value changes in a given set of RooAbsArgs by registering itself as value client of these objects. ; The change tracker can perform an additional validation step where it also compares the numeric values of the tracked arguments with reference values to ensure that values have actually changed. This may be useful in case some of the tracked observables are in binned datasets where each observable propagates a valueDirty flag when an event is loaded even though usually only one observable actually changes. ; Definition at line 23 of file RooChangeTracker.h. Public Member Functions;  RooChangeTracker ()=default;  ;  RooChangeTracker (const char *name, const char *title, const RooArgSet &trackSet, bool checkValues=false);  Constructor. ;  ;  RooChangeTracker (const RooChangeTracker &other, const char *name=nullptr);  Copy constructor. ;  ; TObject * clone (const char *newname) const override;  ; bool hasChanged (bool clearState);  Returns true if state has changed since last call with clearState=true. ;  ; TClass * IsA () const override;  ; RooArgSet parameters () const;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooAbsReal () override;  Destructor. ;  ; virtual double analyticalIntegral (Int_t code, const char *rangeName=nullptr) const;  Implements the actual analytical integral(s) advertised by getAnalyticalIntegral. ;  ; virtual double an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChangeTracker.html:1291,clear,clearState,1291,doc/master/classRooChangeTracker.html,https://root.cern,https://root.cern/doc/master/classRooChangeTracker.html,2,['clear'],['clearState']
Usability,"eTwoIterators_t)(void *begin, void *end); If the sizeof iterator is greater than fgIteratorArenaSize, call delete on the addresses, Otherwise just call the iterator's destructor. ;  ; Next_t GetFunctionNext (Bool_t read=kTRUE) override;  See typedef void* (*Next_t)(void *iter, void *end); iter and end should be pointer to respectively an iterator to be incremented and the result of colleciton.end() 'Next' will increment the iterator 'iter' and return 0 if the iterator reached the end. ;  ; ULong_t GetIncrement () const override;  Return the offset between two consecutive value_types (memory layout). ;  ; virtual TClass * GetOnFileClass () const;  ; TStreamerInfoActions::TActionSequence * GetReadMemberWiseActions (Int_t version) override;  Return the set of action necessary to stream in this collection member-wise coming from the old value class layout refered to by 'version'. ;  ; EDataType GetType () const override;  If the content is a simple numerical value, return its type (see TDataType) ;  ; TClass * GetValueClass () const override;  Return a pointer to the TClass representing the content. ;  ; TStreamerInfoActions::TActionSequence * GetWriteMemberWiseActions () override;  Return the set of action necessary to stream out this collection member-wise. ;  ; Bool_t HasPointers () const override;  Return true if the content is of type 'pointer to'. ;  ; void Insert (const void *data, void *container, size_t size) override;  Insert data into the container where data is a C-style array of the actual type contained in the collection of the given size. ;  ; virtual void operator() (TBuffer &refBuffer, void *pObject);  TClassStreamer IO overload. ;  ; void PopProxy () override;  Remove the last object. ;  ; void PushProxy (void *objstart) override;  Add an object. ;  ; Bool_t Reset () override;  Reset the info gathered from StreamerInfos and value's TClass. ;  ; virtual void Resize (UInt_t n, Bool_t force_delete);  Resize the container. ;  ; virtual void SetOnFileClass ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenCollectionStreamer.html:4202,simpl,simple,4202,doc/master/classTGenCollectionStreamer.html,https://root.cern,https://root.cern/doc/master/classTGenCollectionStreamer.html,1,['simpl'],['simple']
Usability,"eTwoIterators_t)(void *begin, void *end); If the sizeof iterator is greater than fgIteratorArenaSize, call delete on the addresses, Otherwise just call the iterator's destructor. ;  ; Next_t GetFunctionNext (Bool_t read=kTRUE) override;  See typedef void* (*Next_t)(void *iter, void *end); iter and end should be pointer to respectively an iterator to be incremented and the result of colleciton.end() 'Next' will increment the iterator 'iter' and return 0 if the iterator reached the end. ;  ; ULong_t GetIncrement () const override;  Return the offset between two consecutive value_types (memory layout). ;  ; virtual TClass * GetOnFileClass () const;  ; TStreamerInfoActions::TActionSequence * GetReadMemberWiseActions (Int_t version) override;  Return the set of action necessary to stream in this collection member-wise coming from the old value class layout refered to by 'version'. ;  ; EDataType GetType () const override;  If the content is a simple numerical value, return its type (see TDataType) ;  ; TClass * GetValueClass () const override;  Return a pointer to the TClass representing the content. ;  ; TStreamerInfoActions::TActionSequence * GetWriteMemberWiseActions () override;  Return the set of action necessary to stream out this collection member-wise. ;  ; Bool_t HasPointers () const override;  Return true if the content is of type 'pointer to'. ;  ; void Insert (const void *data, void *container, size_t size) override;  Insert data into the container where data is a C-style array of the actual type contained in the collection of the given size. ;  ; virtual void operator() (TBuffer &refBuffer, void *pObject);  TClassStreamer IO overload. ;  ; void PopProxy () override;  Remove the last object. ;  ; void PushProxy (void *objstart) override;  Add an object. ;  ; Bool_t Reset () override;  Reset the info gathered from StreamerInfos and value's TClass. ;  ; virtual void SetOnFileClass (TClass *cl);  ; UInt_t Size () const override;  Return the current size of the c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEmulatedCollectionProxy.html:7984,simpl,simple,7984,doc/master/classTEmulatedCollectionProxy.html,https://root.cern,https://root.cern/doc/master/classTEmulatedCollectionProxy.html,2,['simpl'],['simple']
Usability,"eTwoIterators_t)(void *begin, void *end); If the sizeof iterator is greater than fgIteratorArenaSize, call delete on the addresses, Otherwise just call the iterator's destructor. ;  ; Next_t GetFunctionNext (Bool_t read=kTRUE) override;  See typedef void* (*Next_t)(void *iter, void *end); iter and end should be pointer to respectively an iterator to be incremented and the result of colleciton.end() 'Next' will increment the iterator 'iter' and return 0 if the iterator reached the end. ;  ; ULong_t GetIncrement () const override;  Return the offset between two consecutive value_types (memory layout). ;  ; virtual TClass * GetOnFileClass () const;  ; TStreamerInfoActions::TActionSequence * GetReadMemberWiseActions (Int_t version) override;  Return the set of action necessary to stream in this collection member-wise coming from the old value class layout refered to by 'version'. ;  ; EDataType GetType () const override;  If the content is a simple numerical value, return its type (see TDataType) ;  ; TClass * GetValueClass () const override;  Return a pointer to the TClass representing the content. ;  ; TStreamerInfoActions::TActionSequence * GetWriteMemberWiseActions () override;  Return the set of action necessary to stream out this collection member-wise. ;  ; Bool_t HasPointers () const override;  Return true if the content is of type 'pointer to'. ;  ; void Insert (const void *data, void *container, size_t size) override;  Insert data into the container where data is a C-style array of the actual type contained in the collection of the given size. ;  ; virtual void operator() (TBuffer &refBuffer, void *pObject);  TClassStreamer IO overload. ;  ; void PopProxy () override;  Remove the last object. ;  ; void PushProxy (void *objstart) override;  Add an object. ;  ; virtual void ReadBuffer (TBuffer &b, void *obj);  ; virtual void ReadBuffer (TBuffer &b, void *obj, const TClass *onfileClass);  ; Bool_t Reset () override;  Reset the info gathered from StreamerInfos and",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenBitsetProxy.html:3771,simpl,simple,3771,doc/master/classTGenBitsetProxy.html,https://root.cern,https://root.cern/doc/master/classTGenBitsetProxy.html,7,['simpl'],['simple']
Usability,"eWeightFile, TDirectory* theTargetDir = __null); constructor from weight file. void Init( void ); default initialisation. void DeclareOptions(); define the options (their key words) that can be set in the option string. format of function string:; ""x0*(0)+((1)/x1)**(2)...""; where ""[i]"" are the parameters, and ""xi"" the input variables. format of parameter string:; ""(-1.2,3.4);(-2.3,4.55);...""; where the numbers in ""(a,b)"" correspond to the a=min, b=max parameter ranges;; each parameter defined in the function string must have a corresponding range. void CreateFormula(); translate formula string into TFormula, and parameter string into par ranges. void ProcessOptions(); the option string is decoded, for availabel options see ""DeclareOptions"". ~MethodFDA( void ); destructor. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); FDA can handle classification with 2 classes and regression with one regression-target. void ClearAll( void ); delete and clear all class members. void Train( void ); FDA training. void PrintResults(const TString& , vector<Double_t>& , const Double_t ) const; display fit parameters; check maximum length of variable name. Double_t EstimatorFunction(vector<Double_t>& ); compute estimator for given parameter set (to be minimised); const Double_t sumOfWeights[] = { fSumOfWeightsSig, fSumOfWeightsBkg, fSumOfWeights };. Double_t InterpretFormula(const TMVA::Event* , vector<double>::iterator begin, vector<double>::iterator end); formula interpretation. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns MVA value for given event. const std::vector<Float_t>& GetRegressionValues(). const std::vector<Float_t>& GetMulticlassValues(). void CalculateMulticlassValues(const TMVA::Event*& evt, vector<Double_t>& parameters, vector<Float_t>& values); calculate the values for multiclass. void ReadWeightsFromStream(istream& i); read back the training results from a file (stream). void AddWeightsXMLT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodFDA.html:20240,clear,clear,20240,root/html602/TMVA__MethodFDA.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodFDA.html,6,"['Clear', 'clear']","['ClearAll', 'clear']"
Usability,"e_t value); Set an input list parameter. TObject * GetParameter(const char* par) const; Get specified parameter. A parameter set via SetParameter() is either; a TParameter or a TNamed or 0 in case par is not defined. void DeleteParameters(const char* wildcard); Delete the input list parameters specified by a wildcard (e.g. PROOF_*); or exact name (e.g. PROOF_MaxSlavesPerNode). void ShowParameters(const char* wildcard = ""PROOF_*"") const; Show the input list parameters specified by the wildcard.; Default is the special PROOF control parameters (PROOF_*). void AddFeedback(const char* name); Add object to feedback list. void RemoveFeedback(const char* name); Remove object from feedback list. void ClearFeedback(); Clear feedback list. void ShowFeedback() const; Show items in feedback list. TList * GetFeedbackList() const; Return feedback list. TTree * GetTreeHeader(TDSet* tdset); Creates a tree header (a tree with nonexisting files) object for; the DataSet. TDrawFeedback * CreateDrawFeedback(); Draw feedback creation proxy. When accessed via TProof avoids; link dependency on libProofPlayer. void SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); Set draw feedback option. void DeleteDrawFeedback(TDrawFeedback* f); Delete draw feedback object. TList * GetOutputNames(); FIXME: to be written. void Browse(TBrowser* b); Build the PROOF's structure in the browser. void SetPlayer(TVirtualProofPlayer* player); Set a new PROOF player. TVirtualProofPlayer * MakePlayer(const char* player = 0, TSocket* s = 0); Construct a TProofPlayer object. The player string specifies which; player should be created: remote, slave, sm (supermaster) or base.; Default is remote. Socket is needed in case a slave player is created. void AddChain(TChain* chain); Add chain to data set. void RemoveChain(TChain* chain); Remove chain from data set. void GetLog(Int_t start = -1, Int_t end = -1); Ask for remote logs in the range [start, end]. If start == -1 all the; messages not yet received are sent bac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:74972,feedback,feedback,74972,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,10,['feedback'],['feedback']
Usability,"e_t* working_space, Int_t num, Int_t hartley, Int_t direction, Int_t zt_clear). AUXILIARY FUNCION. This function calculates Fourier based transform of a part of data; Function parameters:; -working_space-pointer to vector of transformed data; -num-length of processed data; -hartley-1 if it is Hartley transform, 0 othewise; -direction-forward or inverse transform. void BitReverseHaar(Double_t* working_space, Int_t shift, Int_t num, Int_t start). AUXILIARY FUNCION. This function carries out bir-reverse reordering for Haar transform; Function parameters:; -working_space-pointer to vector of processed data; -shift-shift of position of processing; -start-initial position of processed data; -num-length of processed data. int GeneralExe(Double_t* working_space, Int_t zt_clear, Int_t num, Int_t degree, Int_t type). AUXILIARY FUNCION. This function calculates generalized (mixed) transforms of different degrees; Function parameters:; -working_space-pointer to vector of transformed data; -zt_clear-flag to clear imaginary data before staring; -num-length of processed data; -degree-degree of transform (see manual); -type-type of mixed transform (see manual). int GeneralInv(Double_t* working_space, Int_t num, Int_t degree, Int_t type). AUXILIARY FUNCION. This function calculates inverse generalized (mixed) transforms; Function parameters:; -working_space-pointer to vector of transformed data; -num-length of processed data; -degree-degree of transform (see manual); -type-type of mixed transform (see manual). void Transform(const Double_t* source, Double_t* destVector). ONE-DIMENSIONAL TRANSFORM FUNCTION; This function transforms the source spectrum. The calling program; should fill in input parameters.; Transformed data are written into dest spectrum. Function parameters:; source-pointer to the vector of source spectrum, its length should; be size except for inverse FOURIER, FOUR-WALSH, FOUR-HAAR; transform. These need 2*size length to supply real and; imaginary coefficients.; des",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpectrumTransform.html:11664,clear,clear,11664,root/html602/TSpectrumTransform.html,https://root.cern,https://root.cern/root/html602/TSpectrumTransform.html,4,['clear'],['clear']
Usability,"e_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tcacheAlpha() const; virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooIntegralMorph.html:6615,clear,clearEvalErrorLog,6615,root/html534/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html534/RooIntegralMorph.html,6,['clear'],['clearEvalErrorLog']
Usability,"e_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tcanBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidclearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooAbsRe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsPdf.html:6613,clear,clearValueDirty,6613,root/html532/RooAbsPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsPdf.html,1,['clear'],['clearValueDirty']
Usability,"e_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsAnaConvPdf.html:4256,clear,clearShapeDirty,4256,root/html532/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsAnaConvPdf.html,1,['clear'],['clearShapeDirty']
Usability,"e_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCachedPdf.html:3356,clear,clearShapeDirty,3356,root/html532/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsCachedPdf.html,1,['clear'],['clearShapeDirty']
Usability,"e_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooEffProd.html:2957,clear,clearShapeDirty,2957,root/html532/RooEffProd.html,https://root.cern,https://root.cern/root/html532/RooEffProd.html,6,['clear'],['clearShapeDirty']
Usability,"e`) or not (`false`). It should perform ""read-only"" operations on the; 501columns, and should not have side-effects (e.g. modification of an external or static variable) to ensure correctness; 502when implicit multi-threading is active. The second overload takes a string with a valid C++ expression in which column; 503names are used as variable names (e.g. `Filter(""x[0] + x[1] > 0"")`). This is a convenience feature that comes with a; 504certain runtime overhead: C++ code has to be generated on the fly from this expression before using it in the event; 505loop. See the paragraph about ""Just-in-time compilation"" below for more information.; 506 ; 507RDataFrame only evaluates filters when necessary: if multiple filters are chained one after another, they are executed; 508in order and the first one returning `false` causes the event to be discarded and triggers the processing of the next; 509entry. If multiple actions or transformations depend on the same filter, that filter is not executed multiple times for; 510each entry: after the first access it simply serves a cached result.; 511 ; 512\anchor named-filters-and-cutflow-reports; 513#### Named filters and cutflow reports; 514An optional string parameter `name` can be passed to the Filter() method to create a **named filter**. Named filters; 515work as usual, but also keep track of how many entries they accept and reject.; 516 ; 517Statistics are retrieved through a call to the Report() method:; 518 ; 519- when Report() is called on the main RDataFrame object, it returns a ROOT::RDF::RResultPtr<RCutFlowReport> relative to all; 520named filters declared up to that point; 521- when called on a specific node (e.g. the result of a Define() or Filter()), it returns a ROOT::RDF::RResultPtr<RCutFlowReport>; 522relative all named filters in the section of the chain between the main RDataFrame and that node (included).; 523 ; 524Stats are stored in the same order as named filters have been added to the graph, and *refer to the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:31191,simpl,simply,31191,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['simpl'],['simply']
Usability,"e`) or not (`false`). It should perform ""read-only"" operations on the; 541columns, and should not have side-effects (e.g. modification of an external or static variable) to ensure correctness; 542when implicit multi-threading is active. The second overload takes a string with a valid C++ expression in which column; 543names are used as variable names (e.g. `Filter(""x[0] + x[1] > 0"")`). This is a convenience feature that comes with a; 544certain runtime overhead: C++ code has to be generated on the fly from this expression before using it in the event; 545loop. See the paragraph about ""Just-in-time compilation"" below for more information.; 546 ; 547RDataFrame only evaluates filters when necessary: if multiple filters are chained one after another, they are executed; 548in order and the first one returning `false` causes the event to be discarded and triggers the processing of the next; 549entry. If multiple actions or transformations depend on the same filter, that filter is not executed multiple times for; 550each entry: after the first access it simply serves a cached result.; 551 ; 552\anchor named-filters-and-cutflow-reports; 553#### Named filters and cutflow reports; 554An optional string parameter `name` can be passed to the Filter() method to create a **named filter**. Named filters; 555work as usual, but also keep track of how many entries they accept and reject.; 556 ; 557Statistics are retrieved through a call to the Report() method:; 558 ; 559- when Report() is called on the main RDataFrame object, it returns a ROOT::RDF::RResultPtr<RCutFlowReport> relative to all; 560named filters declared up to that point; 561- when called on a specific node (e.g. the result of a Define() or Filter()), it returns a ROOT::RDF::RResultPtr<RCutFlowReport>; 562relative all named filters in the section of the chain between the main RDataFrame and that node (included).; 563 ; 564Stats are stored in the same order as named filters have been added to the graph, and *refer to the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:32831,simpl,simply,32831,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['simpl'],['simply']
Usability,"each with no cache will imply 10s penalty where a local read of the 10 MBytes would take about 1 second.; The TreeCache tries to prefetch all the buffers for the selected branches in order to transfer a few multi-Megabytes large buffers instead of many multi-kilobytes small buffers. In addition, TTreeCache can sort the blocks to be read in increasing order such that the file is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TTreeCache in reading ahead as much data as they can and return to the application the maximum data specified in the cache and have the next chunk of data ready when the next request comes. Are there cases for which the usage of TTreeCache is detrimental for performance?; Yes, some corner cases. For example, when reading only a small fraction of all entries such that not all branch buffers are read. General Description; This class acts as a file cache, registering automatically the baskets from the branches being processed via direct manipulation of TTrees or with tools such as TTree::Draw, TTree::Process, TSelector, TTreeReader and RDataFrame when in the learning phase. The learning phase is by default 100 entries. It can be changed via TTreeCache::SetLearnEntries.; The usage of a TTreeCache can considerably improve the runtime performance at the price of a modest investment in memory, in particular when the TTree is accessed remotely, e.g. via a high latency network.; For each TTree being processed a TTreeCache object is created. This object is automatically deleted when the Tree is deleted or when the file is deleted. The user can change the size of the cache with the TTree::SetCacheSize method (by default the size is 30 Megabytes). This feature can be controlled with the environment variable ROOT_TTREECACHE_SIZE or the TTreeCache.Size option. The entry range for which the cache is active can also be set with the SetEntryRange method. Changes of behavior when using TChain and TEventList; The usage of TChain or TE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:2495,learn,learning,2495,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,['learn'],['learning']
Usability,"ead Returns:; 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 2072 of file TTreeCache.cxx. ◆ SetEntryRange(). void TTreeCache::SetEntryRange ; (; Long64_t ; emin, . Long64_t ; emax . ). virtual . Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2105 of file TTreeCache.cxx. ◆ SetFile(). void TTreeCache::SetFile ; (; TFile * ; file, . TFile::ECacheAction ; action = TFile::kDisconnect . ). overridevirtual . Change the file that is being cached. ; Reimplemented from TFileCacheRead.; Definition at line 2127 of file TTreeCache.cxx. ◆ SetLearnEntries(). void TTreeCache::SetLearnEntries ; (; Int_t ; n = 10). static . Static function to set the number of entries to be used in learning mode The default value for n is 10. ; n must be >= 1 ; Definition at line 2144 of file TTreeCache.cxx. ◆ SetLearnPrefill(). void TTreeCache::SetLearnPrefill ; (; TTreeCache::EPrefillType ; type = kNoPrefill). virtual . Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches. The default prefilling behavior can be controlled by setting TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. . Definition at line 2159 of file TTreeCache.cxx. ◆ SetOptimizeMisses(). void TTreeCache::SetOptimizeMisses ; (; bool ; opt). Start of methods for the miss cache. ; Enable / disable the miss cache.; The first time this is called on a TTreeCache object, the corresponding data structures will be allocated. Subsequent enable / disables will simply turn the fu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:49429,learn,learning,49429,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,1,['learn'],['learning']
Usability,"ead and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cache; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tfOneTime! used in the learning phase ; TTree*fOwner! pointer to the owner Tree/chain; Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch!Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.; Bool_tfReadDirectionSet! read direction established; Bool_tfReverseRead! reading in reverse mode ; Long64_t*TFileCacheRead::fSeek[fNseek] Position on file of buffers to be prefetched; Int_t*TFileCacheRead::fSeekIndex[fNseek] sorted index table of fSeek; Int_t*TFileCacheRead::fSeekLen[fNseek] Length of buffers to be prefetched; Int_t*TFileCacheRead::fSeekPos[fNseek] Position of sorted blocks in fBuffer; Int_tTFileCacheRead::fSeekSizeAllocated size of fSeek; Long64_t*TFileCacheRead::fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*TFileCacheRead::fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted); TTree*fTree! pointer to the current Tree; static Int_tfgLearnEntriesnumber of entries used for learning mode. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeCache(); Default Constructor. TTreeCache(TTree* tree, Int_t buffersize = 0); Constructor. ~TTreeCache(); destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); Add a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the bra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreeCache.html:19094,learn,learning,19094,root/html532/TTreeCache.html,https://root.cern,https://root.cern/root/html532/TTreeCache.html,2,['learn'],['learning']
Usability,"eadPool.CUsage: ;  threads.CExample of a simple script creating 3 threads ;  threadsh1.CExample of a simple script creating 3 threads ;  threadsh2.CExample of a simple script creating 2 threads each with one canvas ;  ► tmva;  ► envelope;  classification.C;  ► keras;  ApplicationClassificationKeras.py;  ApplicationRegressionKeras.py;  ClassificationKeras.py;  GenerateModel.py;  LaunchClasGUI.C;  LaunchMultiGUI.C;  LaunchRegGUI.C;  MulticlassKeras.py;  RegressionKeras.py;  createData.CPlot the variables ;  TMVAClassification.C This macro provides examples for the training and testing of the TMVA classifiers ;  TMVAClassificationApplication.C This macro provides a simple example on how to use the trained classifiers within an analysis module ;  TMVAClassificationCategory.C This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode ;  TMVAClassificationCategoryApplication.C This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ;  TMVACrossValidation.C This example explains how to use the cross-validation feature of TMVA ;  TMVAGAexample.C This exectutable gives an example of a very simple use of the genetic algorithm of TMVA ;  TMVAGAexample2.C This exectutable gives an example of a very simple use of the genetic algorithm of TMVA ;  TMVAMulticlass.C This macro provides a simple example for the training and testing of the TMVA multiclass classification ;  TMVAMulticlassApplication.C This macro provides a simple example on how to use the trained multiclass classifiers within an analysis module ;  TMVAMultipleBackgroundExample.C This example shows the training of signal with three different backgrounds Then in the application a tree is created with all signal and background events where the true class ID and the three classifier outputs are added finally with the application tree, the significance is maximized with the help of the TMVA genetic algrorithm ;  TMVA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:156050,simpl,simple,156050,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,1,['simpl'],['simple']
Usability,"eadWeightsFromStream() [3/3]. virtual void TMVA::MethodBase::ReadWeightsFromStream ; (; TFile & ; ). inlinevirtual . Reimplemented from TMVA::MethodBase.; Definition at line 266 of file MethodBase.h. ◆ ReadWeightsFromXML(). void TMVA::MethodTMlpANN::ReadWeightsFromXML ; (; void * ; wghtnode). virtual . rebuild temporary textfile from xml weightfile and load this file into MLP ; Implements TMVA::MethodBase.; Definition at line 379 of file MethodTMlpANN.cxx. ◆ SetHiddenLayer(). void TMVA::MethodTMlpANN::SetHiddenLayer ; (; TString ; hiddenlayer = """"). inline . Definition at line 81 of file MethodTMlpANN.h. ◆ Streamer(). virtual void TMVA::MethodTMlpANN::Streamer ; (; TBuffer & ; ). virtual . Reimplemented from TMVA::MethodBase. ◆ StreamerNVirtual(). void TMVA::MethodTMlpANN::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 121 of file MethodTMlpANN.h. ◆ Train(). void TMVA::MethodTMlpANN::Train ; (; void ; ). virtual . performs TMlpANN training available learning methods: . TMultiLayerPerceptron::kStochastic; TMultiLayerPerceptron::kBatch; TMultiLayerPerceptron::kSteepestDescent; TMultiLayerPerceptron::kRibierePolak; TMultiLayerPerceptron::kFletcherReeves; TMultiLayerPerceptron::kBFGS. TMultiLayerPerceptron wants test and training tree at once so merge the training and testing trees from the MVA factory first: ; Implements TMVA::MethodBase.; Definition at line 260 of file MethodTMlpANN.cxx. Member Data Documentation. ◆ fHiddenLayer. TString TMVA::MethodTMlpANN::fHiddenLayer. private . string containing the hidden layer structure ; Definition at line 111 of file MethodTMlpANN.h. ◆ fLayerSpec. TString TMVA::MethodTMlpANN::fLayerSpec. private . Layer specification option. ; Definition at line 106 of file MethodTMlpANN.h. ◆ fLearningMethod. TString TMVA::MethodTMlpANN::fLearningMethod. private . the learning method (given via option string) ; Definition at line 116 of file MethodTMlpANN.h. ◆ fLocalTrainingTree. TTree* TMVA::Method",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodTMlpANN.html:35435,learn,learning,35435,doc/master/classTMVA_1_1MethodTMlpANN.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodTMlpANN.html,1,['learn'],['learning']
Usability,"eaflist, Int_t bufsize = 32000); virtual TBranch*Branch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); TBranch*Branch<const char>(const char* name, const char* classname, const char* obj, Int_t bufsize = 32000, Int_t splitlevel = 99); TBranch*Branch<void>(const char* name, void* obj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual TBranch*BranchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); virtual TBranch*BranchRef(); virtual TBranch*Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual voidBrowse(TBrowser*); virtual Int_tBuildIndex(const char* majorname, const char* minorname = ""0""); TStreamerInfo*BuildStreamerInfo(TClass* cl, void* pointer = 0, Bool_t canOptimize = kTRUE); virtual TFile*ChangeFile(TFile* file); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TTree*CloneTree(Long64_t nentries = -1, Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidCopyAddresses(TTree*, Bool_t undo = kFALSE); virtual Long64_tCopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); virtual TTree*CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual TBasket*CreateBasket(TBranch*); Int_tDebug() const; virtual voidDelete(Option_t* option = """")MENU ; virtual voidDirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual Long64_tDraw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTree.html:14228,Clear,Clear,14228,root/html602/TTree.html,https://root.cern,https://root.cern/root/html602/TTree.html,2,['Clear'],['Clear']
Usability,"eal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tcacheAlpha() const; virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooIntegralMorph.html:6574,clear,clearEvalError,6574,root/html534/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html534/RooIntegralMorph.html,6,['clear'],['clearEvalError']
Usability,"eal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; const RooArgList&coefList() const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual RooResolutionModel*convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&RooResolutionModel::convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAddModel.html:3786,clear,clearShapeDirty,3786,root/html534/RooAddModel.html,https://root.cern,https://root.cern/root/html534/RooAddModel.html,6,['clear'],['clearShapeDirty']
Usability,"ealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; virtual RooAbsGenContext*RooAbsPdf::binnedGenContext(const RooArgSet& vars, Bool_t verbose = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCFunction1PdfBinding_double_double_.html:3157,Clear,Clear,3157,root/html534/RooCFunction1PdfBinding_double_double_.html,https://root.cern,https://root.cern/root/html534/RooCFunction1PdfBinding_double_double_.html,32,['Clear'],['Clear']
Usability,"ean and sigma parameters; the algorithm works on the same principle as in multivariate case -; it finds a subset of size hh with smallest sigma, and then returns mean and; sigma of this subset. Int_t GetBDPoint(); returns the breakdown point of the algorithm. Double_t GetChiQuant(Int_t i) const; returns the chi2 quantiles. void GetCovariance(TMatrixDSym& matr); returns the covariance matrix. void GetCorrelation(TMatrixDSym& matr); returns the correlation matrix. const TVectorD* GetHyperplane() const; if the points are on a hyperplane, returns this hyperplane. void GetHyperplane(TVectorD& vec); if the points are on a hyperplane, returns this hyperplane. void GetMean(TVectorD& means); return the estimate of the mean. void GetRDistances(TVectorD& rdist); returns the robust distances (helps to find outliers). Int_t GetNOut(); returns the number of outliers. void AddToSscp(TMatrixD& sscp, TVectorD& vec); update the sscp matrix with vector vec. void ClearSscp(TMatrixD& sscp); clear the sscp matrix, used for covariance and mean calculation. void Classic(); called when h=n. Returns classic covariance matrix; and mean. void Covar(TMatrixD& sscp, TVectorD& m, TMatrixDSym& cov, TVectorD& sd, Int_t nvec); calculates mean and covariance. void Correl(); transforms covariance matrix into correlation matrix. void CreateSubset(Int_t ntotal, Int_t htotal, Int_t p, Int_t* index, TMatrixD& data, TMatrixD& sscp, Double_t* ndist); creates a subset of htotal elements from ntotal elements; first, p+1 elements are drawn randomly(without repetitions); if their covariance matrix is singular, more elements are; added one by one, until their covariance matrix becomes regular; or it becomes clear that htotal observations lie on a hyperplane; If covariance matrix determinant!=0, distances of all ntotal elements; are calculated, using formula d_i=Sqrt((x_i-M)*S_inv*(x_i-M)), where; M is mean and S_inv is the inverse of the covariance matrix; htotal points with smallest distances are included in the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRobustEstimator.html:13826,clear,clear,13826,root/html528/TRobustEstimator.html,https://root.cern,https://root.cern/root/html528/TRobustEstimator.html,14,"['Clear', 'clear']","['ClearSscp', 'clear']"
Usability,eanVariance;  CNetNeural net ;  CSettingsSettings for the training of the neural net ;  CSteepestSteepest Gradient Descent algorithm (SGD) ;  CTBatchTBatch ;  CTBatchIteratorTBatchIterator ;  CTCpuThe TCpu architecture class ;  ►CTCpuBufferTCpuBuffer ;  CTDestructor;  CTCpuMatrixThe TCpuMatrix class ;  CTCudaThe TCuda architecture class ;  ►CTCudaDeviceBufferTCudaDeviceBuffer ;  CTDestructor;  CTCudaDeviceReferenceTCudaDeviceReference ;  ►CTCudaHostBufferTCudaHostBuffer ;  CTDestructor;  CTCudaMatrixTCudaMatrix Class ;  CTDataLoaderTDataLoader ;  CTDeviceTDevice ;  CTGradientDescent;  CTLayerGeneric layer class ;  CTNetGeneric neural network class ;  CTReferenceThe reference architecture class ;  CTSharedLayerLayer class width shared weight and bias layers ;  ►NkNN;  CEvent;  CModulekNN;  CNode;  CAbsoluteDeviationLossFunctionAbsolute Deviation Loss Function ;  CAbsoluteDeviationLossFunctionBDTAbsolute Deviation BDT Loss Function ;  CAbsValue;  CBDTEventWrapper;  CBinarySearchTreeA simple Binary search tree including a volume search method ;  CBinarySearchTreeNodeNode for the BinarySearch or Decision Trees ;  CBinaryTreeBase class for BinarySearch and Decision Trees ;  CCCPrunerA helper class to prune a decision tree using the Cost Complexity method (see Classification and Regression Trees by Leo Breiman et al) ;  ►CCCTreeWrapper;  CCCTreeNode;  CClassifierFactoryThis is the MVA factory ;  CClassInfoClass that contains all the information of a class ;  Ccompose_binary_t;  Ccompose_unary_t;  ►CConfigSingleton class for global configuration settings used by TMVA ;  CIONames;  CVariablePlotting;  CConfigurable;  CConvergenceTestCheck for convergence ;  CCostComplexityPruneToolA class to prune a decision tree using the Cost Complexity method ;  CCrossEntropyImplementation of the CrossEntropy as separation criterion ;  CCrossValidation;  CCrossValidationResult;  CDataInputHandlerClass that contains all the data information ;  CDataLoader;  CDataSetClass that contains all ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:69305,simpl,simple,69305,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,1,['simpl'],['simple']
Usability,"ean} \\; 51 \end{align}; 52 \f]; 53 The bin content is always the mean of the Y values, but errors change depending on options:; 54 \f[; 55 \begin{align}; 56 \text{GetBinContent}(j) &= h(j) \\; 57 \text{GetBinError}(j) &=; 58 \begin{cases}; 59 e(j) &\text{if option="""" (default). Error of the mean of all y values.} \\; 60 s(j) &\text{if option=""s"". Standard deviation of all y values.} \\; 61 \begin{cases} e(j) &\text{if } h(j) \ne 0 \\ 1/\sqrt{12 N} &\text{if } h(j)=0 \end{cases} &\text{if option=""i"". This is useful for storing integers such as ADC counts.} \\; 62 1/\sqrt{W(j)} &\text{if option=""g"". Error of a weighted mean for combining measurements with variances of } w. \\; 63 \end{cases}; 64 \end{align}; 65 \f]; 66 In the special case where s(j) is zero (eg, case of 1 entry only in one bin); 67 the bin error e(j) is computed from the average of the s(j) for all bins if; 68 the static function TProfile::Approximate() has been called.; 69 This simple/crude approximation was suggested in order to keep the bin; 70 during a fit operation. But note that this approximation is not the default behaviour.; 71 See also TProfile::BuildOptions for more on error options.; 72 ; 73 ### Creating and drawing a profile histogram; 74~~~{.cpp}; 75{; 76 auto c1 = new TCanvas(""c1"",""Profile histogram example"",200,10,700,500);; 77 auto hprof = new TProfile(""hprof"",""Profile of pz versus px"",100,-4,4,0,20);; 78 Float_t px, py, pz;; 79 for ( Int_t i=0; i<25000; i++) {; 80 gRandom->Rannor(px,py);; 81 pz = px*px + py*py;; 82 hprof->Fill(px,pz,1);; 83 }; 84 hprof->Draw();; 85}; 86~~~; 87*/; 88 ; 89////////////////////////////////////////////////////////////////////////////////; 90/// Default constructor for Profile histograms; 91 ; 92TProfile::TProfile(); 93{; 94 BuildOptions(0,0,"""");; 95}; 96 ; 97////////////////////////////////////////////////////////////////////////////////; 98/// Default destructor for Profile histograms; 99 ; 100TProfile::~TProfile(); 101{; 102}; 103 ; 104/////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile_8cxx_source.html:3182,simpl,simple,3182,doc/master/TProfile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html,1,['simpl'],['simple']
Usability,"earch. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::SimpleLikelihoodRatioTestStat. class RooStats::SimpleLikelihoodRatioTestStat: public RooStats::TestStatistic. ; SimpleLikelihoodRatioTestStat: TestStatistic that returns -log(L[null] / L[alt]) where; L is the likelihood.; . Function Members (Methods); public:. virtual~SimpleLikelihoodRatioTestStat(); static TClass*Class(); virtual Double_tEvaluate(RooAbsData& data, RooArgSet& nullPOI); virtual const TStringGetVarName() const; virtual TClass*IsA() const; RooStats::SimpleLikelihoodRatioTestStat&operator=(const RooStats::SimpleLikelihoodRatioTestStat&); boolParamsAreEqual(); virtual boolRooStats::TestStatistic::PValueIsRightTail() const; voidSetAltParameters(const RooArgSet& altParameters); static voidSetAlwaysReuseNLL(Bool_t flag); voidSetNullParameters(const RooArgSet& nullParameters); voidSetReuseNLL(Bool_t flag); virtual voidShowMembers(TMemberInspector& insp); RooStats::SimpleLikelihoodRatioTestStatSimpleLikelihoodRatioTestStat(); RooStats::SimpleLikelihoodRatioTestStatSimpleLikelihoodRatioTestStat(const RooStats::SimpleLikelihoodRatioTestStat&); RooStats::SimpleLikelihoodRatioTestStatSimpleLikelihoodRatioTestStat(RooAbsPdf& nullPdf, RooAbsPdf& altPdf); RooStats::SimpleLikelihoodRatioTestStatSimpleLikelihoodRatioTestStat(RooAbsPdf& nullPdf, RooAbsPdf& altPdf, const RooArgSet& nullParameters, const RooArgSet& altParameters); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; private:. RooArgSet*fAltParameters; RooAbsPdf*fAltPdf; static Bool_tfAlwaysReuseNll; boolfFirstEval; RooNLLVar*fNllAlt! transient copy of the alt NLL; RooNLLVar*fNllNull! transient copy of the null NLL; RooArgSet*fNullParameters; RooAbsPdf*fNullPdf; Bool_tfReuseNll. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SimpleLikelihoodRatioTestStat(). SimpleLikelihoodR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__SimpleLikelihoodRatioTestStat.html:535,Simpl,SimpleLikelihoodRatioTestStat,535,root/html532/RooStats__SimpleLikelihoodRatioTestStat.html,https://root.cern,https://root.cern/root/html532/RooStats__SimpleLikelihoodRatioTestStat.html,8,['Simpl'],"['SimpleLikelihoodRatioTestStat', 'SimpleLikelihoodRatioTestStatSimpleLikelihoodRatioTestStat']"
Usability,"earningRate). Updates the weights and biases, given the learning rate. ; Definition at line 410 of file GeneralLayer.h. ◆ UpdateBiases(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateBiases ; (; const std::vector< Matrix_t > & ; biasGradients, . const Scalar_t ; learningRate . ). Updates the biases, given the gradients and the learning rate. ; Definition at line 428 of file GeneralLayer.h. ◆ UpdateBiasGradients(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateBiasGradients ; (; const std::vector< Matrix_t > & ; biasGradients, . const Scalar_t ; learningRate . ). Updates the bias gradients, given some other weight gradients and learning rate. ; Definition at line 448 of file GeneralLayer.h. ◆ UpdateWeightGradients(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateWeightGradients ; (; const std::vector< Matrix_t > & ; weightGradients, . const Scalar_t ; learningRate . ). Updates the weight gradients, given some other weight gradients and learning rate. ; Definition at line 438 of file GeneralLayer.h. ◆ UpdateWeights(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateWeights ; (; const std::vector< Matrix_t > & ; weightGradients, . const Scalar_t ; learningRate . ). Updates the weights, given the gradients and the learning rate,. ; Definition at line 418 of file GeneralLayer.h. ◆ WriteMatrixToXML(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::WriteMatrixToXML ; (; void * ; node, . const char * ; name, . const Matrix_t & ; matrix . ). Definition at line 521 of file GeneralLayer.h. ◆ WriteTensorToXML(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::WriteTensorToXML ; (; void * ; node, . const char * ; name, . const std::vector< Matrix_t > & ; tensor . ). helper functions for XML ; Definition at line 496 of file ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html:26281,learn,learningRate,26281,doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html,1,['learn'],['learningRate']
Usability,ease 5.12/00d - 2006-09-02. Release 5.12/00 - 2006-07-14. Release 5.11/06 - 2006-06-07. Release 5.11/04 - 2006-05-31. Release 5.11/02 - 2006-05-08. Release 5.10/00 - 2006-03-02. Release 5.08/00 - 2005-12-15. Release 5.06/00 - 2005-10-31. Release 5.04/00 - 2005-09-20. Release 5.02/00 - 2005-07-05. Version 4 ; ; Release 4.04/02 - 2005-05-14. Release 4.03/04 - 2005-04-06. Release 4.03/02 - 2005-02-10. Release 4.02/00 - 2004-12-17. Release 4.01/04 - 2004-11-20. Release 4.01/02 - 2004-09-24. Release 4.00/08 - 2004-07-11. Release 4.00/06a - 2004-07-11. Release 4.00/06 - 2004-07-11. Release 4.00/04 - 2004-05-04. Release 4.00/03 - 2004-03-25. Release 4.00/02 - 2004-02-20. Release 4.00/01 - 2004-02-02. Version 3 ; ; Release 3.10/02 - 2004-01-23. Release 3.10/01a - 2004-01-23. Release 3.10/01 - 2004-01-23. Release 3.05/07a - 2003-08-06. Release 3.05/07 - 2003-07-27. Release 3.05/06 - 2003-07-18. Release 3.05/05 - 2003-05-08. Release 3.05/04 - 2003-04-21. Release 3.05/03 - 2003-03-11. Release 3.05/02 - 2003-02-12. Release 3.04/02 - 2002-12-18. Release 3.04/01 - 2002-12-11. Release 3.03/09b - 2002-11-05. Release 3.03/09a - 2002-10-31. Release 3.03/09 - 2002-09-18. Release 3.02/07 - 2002-02-06. . Release notes can be found on the respective release page; release notes for old releases can be found here. ; . Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/releases.html:8325,guid,guidelines,8325,d/releases.html,https://root.cern,https://root.cern/d/releases.html,1,['guid'],['guidelines']
Usability,"eates :; // - a one dimensional histogram; // - a two dimensional histogram; // - a profile histogram; // - a tree; //; // These objects are filled with some random numbers and saved on a file.; ; #include ""TFile.h""; #include ""TH1.h""; #include ""TH2.h""; #include ""TProfile.h""; #include ""TRandom.h""; #include ""TTree.h""; ; //__________________________________________________________________________; main(int argc, char **argv); {; // Create a new ROOT binary machine independent file.; // Note that this file may contain any kind of ROOT objects, histograms,trees; // pictures, graphics objects, detector geometries, tracks, events, etc..; // This file is now becoming the current directory.; TFile hfile(""htree.root"",""RECREATE"",""Demo ROOT file with histograms & trees"");; ; // Create some histograms and a profile histogram; TH1F hpx(""hpx"",""This is the px distribution"",100,-4,4);; TH2F hpxpy(""hpxpy"",""py ps px"",40,-4,4,40,-4,4);; TProfile hprof(""hprof"",""Profile of pz versus px"",100,-4,4,0,20);; ; // Define some simple structures; typedef struct {Float_t x,y,z;} POINT;; typedef struct {; Int_t ntrack,nseg,nvertex;; UInt_t flag;; Float_t temperature;; } EVENTN;; POINT point;; EVENTN eventn;; ; // Create a ROOT Tree; TTree tree(""T"",""An example of ROOT tree with a few branches"");; tree.Branch(""point"",&point,""x:y:z"");; tree.Branch(""eventn"",&eventn,""ntrack/I:nseg:nvertex:flag/i:temperature/F"");; tree.Branch(""hpx"",""TH1F"",&hpx,128000,0);; ; Float_t px,py,pz;; ; // Here we start a loop on 1000 events; for ( Int_t i=0; i<1000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; const auto random = gRandom->::Rndm(1);; ; // Fill histograms; hpx.Fill(px);; hpxpy.Fill(px,py,1);; hprof.Fill(px,pz,1);; ; // Fill structures; point.x = 10*(random-1);; point.y = 5*random;; point.z = 20*random;; eventn.ntrack = Int_t(100*random);; eventn.nseg = Int_t(2*eventn.ntrack);; eventn.nvertex = 1;; eventn.flag = Int_t(random+0.5);; eventn.temperature = 20+random;; ; // Fill the tree. For each event, save ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:12628,simpl,simple,12628,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['simpl'],['simple']
Usability,"eation date, 3 - file modification date; utc - select timeZone to ‘UTC’; datex - X position of date; datey - Y position of date; optfile - plot file name on the canvas, 1 - file name, 2 - full file URL, 3 - object item name; opttitle - disable/enable drawing of object title in the canvas; nomenu - disable context menu; notouch - disable touch events handling; progress - switch progress display mode between ‘off’, ‘on’ and ‘modal’. For instance:. https://root.cern/js/latest/?file=../files/hsimple.root&item=hpx;1; https://root.cern/js/latest/?file=../files/hsimple.root&nobrowser&item=hpxpy;1&opt=colz; https://root.cern/js/latest/?file=../files/hsimple.root&noselect&layout=grid2x2&item=hprof;1. Following layouts are supported:. simple - available space used for single object (default); flex - creates as many frames as necessary, each can be individually moved/enlarged; tabs - tabs for each object drawing; gridNxM - fixed-size grid with NxM frames; vertN - N frames sorted in vertical direction (like gridi1xN); horizN - N frames sorted in horizontal direction (like gridiNx1); vert121 - 3 frames sorted in vertical direction, second frame divided on two sub-frames; horiz32_12 - 2 horizontal frames with 3 and 2 subframes, and 1/3 and 2/3 as relative size. When specifying files, items or opts parameters, array of strings could be provided like files=['file1.root','file2.root']. One could skip quotes when specifying elements names items=[file1.root/hpx,file2.root/hpy] or opts=['',colz].; As item name, URL to existing image can be provided like item=img:http://server/image.png. Such image will be just inserted in the existing layout. One could specify option ""scale"" to automatically scale image to available space.; Many examples of URL string usage can be found on JSROOT API examples page.; One can very easy integrate JSROOT graphic into arbitrary HTML pages using a iframe tag:; <iframe width=""700"" height=""400""; src=""https://root.cern/js/latest/?nobrowser&file=https://root.cern",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:4353,simpl,simple,4353,root/htmldoc/guides/JSROOT/JSROOT.html,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html,2,['simpl'],['simple']
Usability,"ec"": 1.5,; 1486 ""sample_category"" = ""MC_background""; 1487 }; 1488 }; 1489 }; 1490}; 1491~~~; 1492 ; 1493The metadata information from the specification file can be then accessed using the DefinePerSample function.; 1494For example, to access luminosity information (stored as a double):; 1495 ; 1496~~~{.python}; 1497df.DefinePerSample(""lumi"", 'rdfsampleinfo_.GetD(""lumi"")'); 1498~~~; 1499 ; 1500or sample_category information (stored as a string):; 1501 ; 1502~~~{.python}; 1503df.DefinePerSample(""sample_category"", 'rdfsampleinfo_.GetS(""sample_category"")'); 1504~~~; 1505 ; 1506or directly the filename:; 1507 ; 1508~~~{.python}; 1509df.DefinePerSample(""name"", ""rdfsampleinfo_.GetSampleName()""); 1510~~~; 1511 ; 1512An example implementation of the ""FromSpec"" method is available in tutorial: df106_HiggstoFourLeptons.py, which also; 1513provides a corresponding exemplary JSON file for the dataset specification.; 1514 ; 1515\anchor progressbar; 1516### Adding a progress bar ; 1517 ; 1518A progress bar showing the processed event statistics can be added to any RDataFrame program.; 1519The event statistics include elapsed time, currently processed file, currently processed events, the rate of event processing ; 1520and an estimated remaining time (per file being processed). It is recorded and printed in the terminal every m events and every ; 1521n seconds (by default m = 1000 and n = 1). The ProgressBar can be also added when the multithread (MT) mode is enabled. ; 1522 ; 1523ProgressBar is added after creating the dataframe object (df):; 1524~~~{.cpp}; 1525ROOT::RDataFrame df(""tree"", ""file.root"");; 1526ROOT::RDF::Experimental::AddProgressBar(df);; 1527~~~; 1528 ; 1529Alternatively, RDataFrame can be cast to an RNode first, giving the user more flexibility ; 1530For example, it can be called at any computational node, such as Filter or Define, not only the head node,; 1531with no change to the ProgressBar function itself (please see the [Efficient analysis in Python](#python) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:85552,progress bar,progress bar,85552,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,2,['progress bar'],['progress bar']
Usability,"ec"": 1.5,; 1526 ""sample_category"" = ""MC_background""; 1527 }; 1528 }; 1529 }; 1530}; 1531~~~; 1532 ; 1533The metadata information from the specification file can be then accessed using the DefinePerSample function.; 1534For example, to access luminosity information (stored as a double):; 1535 ; 1536~~~{.python}; 1537df.DefinePerSample(""lumi"", 'rdfsampleinfo_.GetD(""lumi"")'); 1538~~~; 1539 ; 1540or sample_category information (stored as a string):; 1541 ; 1542~~~{.python}; 1543df.DefinePerSample(""sample_category"", 'rdfsampleinfo_.GetS(""sample_category"")'); 1544~~~; 1545 ; 1546or directly the filename:; 1547 ; 1548~~~{.python}; 1549df.DefinePerSample(""name"", ""rdfsampleinfo_.GetSampleName()""); 1550~~~; 1551 ; 1552An example implementation of the ""FromSpec"" method is available in tutorial: df106_HiggstoFourLeptons.py, which also; 1553provides a corresponding exemplary JSON file for the dataset specification.; 1554 ; 1555\anchor progressbar; 1556### Adding a progress bar ; 1557 ; 1558A progress bar showing the processed event statistics can be added to any RDataFrame program.; 1559The event statistics include elapsed time, currently processed file, currently processed events, the rate of event processing ; 1560and an estimated remaining time (per file being processed). It is recorded and printed in the terminal every m events and every ; 1561n seconds (by default m = 1000 and n = 1). The ProgressBar can be also added when the multithread (MT) mode is enabled. ; 1562 ; 1563ProgressBar is added after creating the dataframe object (df):; 1564~~~{.cpp}; 1565ROOT::RDataFrame df(""tree"", ""file.root"");; 1566ROOT::RDF::Experimental::AddProgressBar(df);; 1567~~~; 1568 ; 1569Alternatively, RDataFrame can be cast to an RNode first, giving the user more flexibility ; 1570For example, it can be called at any computational node, such as Filter or Define, not only the head node,; 1571with no change to the ProgressBar function itself (please see the [Efficient analysis in Python](#python) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:87232,progress bar,progress bar,87232,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,2,['progress bar'],['progress bar']
Usability,"ec(""print1+1"");; 2. // create a TBrowser on the Python side, and transfer it back and forth; root[] TBrowser* b = (void*)TPython::Eval(""ROOT.TBrowser()"");; (class TObject*)0x8d1daa0; root[] TPython::Bind(b,""b"");. // builtin variables can cross-over (after the call i==2); root[] int i = TPython::Eval( ""1+1"" );; root[] i; (int)2; 19.1.4 Installation; There are several ways of obtaining PyROOT, and which is best depends on your specific situation. If you work at CERN, you can use the installation available on afs. Otherwise, you will want to build from source, as PyROOT is not build by default in the binaries distributed from the ROOT project site. If you download the ROOT binaries, take care to download and install the Python distribution from http://www.python.org/ against which they were built.; 19.1.4.1 Environment Settings; ROOT installations with the build of PyROOT enabled are available from the CERN afs cell /afs/cern.ch/sw/root/<version>/<platform>. To use them, simply modify your shell environment accordingly. For Unix:; export PATH=$ROOTSYS/bin:$PYTHONDIR/bin:$PATH; export LD_LIBRARY_PATH=$ROOTSYS/lib:$PYTHONDIR/lib:$LD_LIBRARY_PATH; export PYTHONPATH=$ROOTSYS/lib:$PYTHONPATH; For Windows:; set PATH=%ROOTSYS%/bin;%PYTHONDIR%/bin;%PATH%; set PYTHONPATH=%ROOTSYS%/bin;%PYTHONPATH%; where $ROOTSYS should be set to /afs/cern.ch/sw/root/<version>/<platform>, and PYTHONDIR to /afs/cern.ch/sw/lcg/external/Python/2.3.4/<platform> with <version> and <platform> as appropriate. Note that the latest version of Python is 2.4.1.; 19.1.4.2 Building from Source; The standard installation instructions for building ROOT from source apply, with the addition that the build of PyROOT needs to be enabled at the configuration step. First, follow the instructions for obtaining and unpacking the source, and setting up the build environment.; Then, use the following command to configure the build process (of course, feel free to add any additional flags you may need):; $ ./configure <a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1047078,simpl,simply,1047078,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simply']
Usability,"eclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 52 of file TXMLPlayer.h. ◆ ElementGetter(). const char * TXMLPlayer::ElementGetter ; (; TClass * ; cl, . const char * ; membername, . int ; specials = 0 . ). protected . produce code to access member of given class. ; Parameter specials has following meaning: 0 - nothing special 1 - cast to data type 2 - produce pointer on given member 3 - skip casting when produce pointer by buf.P() function ; Definition at line 333 of file TXMLPlayer.cxx. ◆ ElementSetter(). const char * TXMLPlayer::ElementSetter ; (; TClass * ; cl, . const char * ; membername, . char * ; endch . ). protected . Produce code to set value to given data member. ; endch should be output after value is specified. ; Definition at line 392 of file TXMLPlayer.cxx. ◆ GetBasicTypeName(). TString TXMLPlayer::GetBasicTypeName ; (; TStreamerElement * ; el). protected . return simple data types for given TStreamerElement object ; Definition at line 260 of file TXMLPlayer.cxx. ◆ GetBasicTypeReaderMethodName(). TString TXMLPlayer::GetBasicTypeReaderMethodName ; (; Int_t ; type, . const char * ; realname . ). protected . return functions name to read simple data type from xml file ; Definition at line 293 of file TXMLPlayer.cxx. ◆ GetMemberTypeName(). TString TXMLPlayer::GetMemberTypeName ; (; TDataMember * ; member). protected . returns name of simple data type for given data member ; Definition at line 222 of file TXMLPlayer.cxx. ◆ GetStreamerName(). TString TXMLPlayer::GetStreamerName ; (; TClass * ; cl). protected . returns streamer function name for given class ; Definition at line 150 of file TXMLPlayer.cxx. ◆ IsA(). TClass * TXMLPlayer::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 52 of file TXMLPlayer.h. ◆ ProduceCode(). Bool_t TXMLPlayer::ProduceCode ; (; TList * ; cllist, . const char * ; filename . ). Produ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLPlayer.html:13589,simpl,simple,13589,doc/master/classTXMLPlayer.html,https://root.cern,https://root.cern/doc/master/classTXMLPlayer.html,1,['simpl'],['simple']
Usability,"ect 'newobj' in the list 'outlist'.; The object is merged with an object of the same name already existing in; the list, or just added.; The boolean merged is set to kFALSE when the object is just added to 'outlist';; this happens if the Merge() method does not exist or if a object named as 'obj'; is not already in the list. If the obj is not 'merged' than it should not be; deleted, unless outlist is not owner of its objects.; Return 0 on success, -1 on error. TObject * HandleHistogram(TObject* obj, Bool_t& merged); Low statistic histograms need a special treatment when using autobin. Bool_t HistoSameAxis(TH1* h0, TH1* h1); Return kTRUE is the histograms 'h0' and 'h1' have the same binning and ranges; on the axis (i.e. if they can be just Add-ed for merging). void StoreOutput(TList* out); Store received output list. TList * MergeFeedback(); Merge feedback lists. void StoreFeedback(TObject* slave, TList* out); Store feedback results from the specified slave. void SetupFeedback(); Setup reporting of feedback objects. void StopFeedback(); Stop reporting of feedback objects. Bool_t HandleTimer(TTimer* timer); Send feedback objects to client. TDSetElement * GetNextPacket(TSlave* slave, TMessage* r); Get next packet for specified slave. Bool_t IsClient() const; Is the player running on the client?. Long64_t DrawSelect(TDSet* set, const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Draw (support for TChain::Draw()).; Returns -1 in case of error or number of selected events in case of success. void SetInitTime(); Set init time. TVirtualPacketizer * GetPacketizer() const; { return 0; }. void Progress(Long64_t total, Long64_t processed). void Progress(TSlave* , Long64_t total, Long64_t processed); { Progress(total, processed); }. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti). TProof * GetProof() const; { return fProof; }. TP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofPlayerRemote.html:19364,feedback,feedback,19364,root/html532/TProofPlayerRemote.html,https://root.cern,https://root.cern/root/html532/TProofPlayerRemote.html,8,['feedback'],['feedback']
Usability,"ect (TQObject *sender, const char *signal, const char *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  ; static const char * DeclFileName ();  ; static Bool_t Disconnect (const char *class_name, const char *signal, void *receiver=nullptr, const char *slot=nullptr);  Disconnects ""class signal"". ;  ; static Bool_t Disconnect (TQObject *sender, const char *signal=nullptr, void *receiver=nullptr, const char *slot=nullptr);  Disconnects signal in object sender from slot_method in object receiver. ;  . Protected Member Functions; Bool_t HandleTimer (TTimer *timer) override;  Send feedback objects to client. ;  ; Int_t MakeSelector (const char *selfile);  Create the selector object and save the relevant files and binary information in the cache so that the worker can pick it up. ;  ; void SetupFeedback () override;  Setup reporting of feedback objects. ;  ;  Protected Member Functions inherited from TProofPlayerRemote; TProof * GetProof () const;  ; Bool_t HandleTimer (TTimer *timer) override;  Send feedback objects to client. ;  ; Int_t InitPacketizer (TDSet *dset, Long64_t nentries, Long64_t first, const char *defpackunit, const char *defpackdata);  Init the packetizer Return 0 on success (fPacketizer is correctly initialized), -1 on failure. ;  ; TList * MergeFeedback ();  Merge feedback lists. ;  ; Bool_t MergeOutputFiles ();  Merge output in files. ;  ; void NotifyMemory (TObject *obj);  Printout the memory record after merging object 'obj' This record is used by the memory monitor. ;  ; virtual Bool_t SendSelector (const char *selector_file);  Send the selector file(s) to master or worker nodes. ;  ; void SetLastMergingMsg (TObject *obj);  Set the message to be notified in case of exception. ;  ; void SetSelectorDataMembersFromOutputList ();  Set the selector's data members: find the mapping of data members to otuput list entries in the output list and apply it. ;  ; void SetupFeedback () override;  Setup reportin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerLite.html:21109,feedback,feedback,21109,doc/master/classTProofPlayerLite.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerLite.html,1,['feedback'],['feedback']
Usability,"ect can be requested and displayed in the web browser. There are many benefits of such approach:. standard http interface to ROOT application; no any temporary ROOT files to access data; user interface running in all browsers. 1.1 Starting the HTTP server; To start the http server, at any time, create an instance of the THttpServer class like:; serv = new THttpServer(""http:8080"");; This will start a civetweb-based http server on the port 8080. Then one should be able to open the address “http://localhost:8080” in any modern browser (IE9, Firefox, Chrome, Opera) and browse objects created in application. By default, the server can access files, canvases, and histograms via the gROOT pointer. All those objects can be displayed with JSROOT graphics.; There is a snapshot (frozen copy) of such server, running in tutorials/http/httpserver.C macro from ROOT tutorial.; <iframe width=“800” height=“500” src=“https://root.cern.ch/js/3.6/httpserver.C/?layout=simple&item=Canvases/c1”> ; One could specify several options when creating http server. They could be add as additional URL parameters to the constructor arguments like:; serv = new THttpServer(""http:8080?loopback&thrds=2"");; Following parameters are supported:. thrds=N - number of threads used by the civetweb (default is 5); top=name - configure top name, visible in the web browser; auth_file=filename - authentication file name, created with htdigets utility; auth_domain=domain - authentication domain; loopback - bind specified port to loopback 127.0.0.1 address; debug - enable debug mode, server always returns html page with request info. If necessary, one could bind http server to specific IP address like:; new THttpServer(""http:192.168.1.17:8080""); 1.2 Registering objects; At any time, one could register other objects with the command:; TGraph* gr = new TGraph(10);; gr->SetName(""gr1"");; serv->Register(""graphs/subfolder"", gr);; One should specify sub-folder name, where objects will be registered. If sub-folder name does",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/HttpServer/HttpServer.html:1776,simpl,simple,1776,root/html534/guides/HttpServer/HttpServer.html,https://root.cern,https://root.cern/root/html534/guides/HttpServer/HttpServer.html,2,['simpl'],['simple']
Usability,"ect editor in a transient frame. Closing these transient frames will not delete, but just hide existing opened editors for later reuse. Their lifetime is determined by the canvas to which the manager editor is attached to, since these will be destroyed together. Editors for shapes, materials, media, matrices; For most editors, the functionalities Apply and Undo are provided.; For shapes, changing any of the shape parameters will activate the ""Apply"" button only if the check button ""Delayed draw"" is checked, otherwise the changes are immediately applied. Once the apply button is pressed, the changes are applied to the edited shape and drawn. The ""Undo"" button becomes active after the first modification has been applied. It allows restoring the initial parameters of the shape.; NOTE: In this version the ""Undo"" does not allow restoring an intermediate state of the parameters that was applied - it will always restore the parameters at the moment the shape was edited.; All material properties changes are undoable. The mixture editor currently allows adding elements one by one in the mixture composition. This can be done either by element weight fraction or by number of atoms. Once an element was added using one method the other method is not selectable anymore. Summing component fractions up to 1 in the final mixture is the user responsibility. Adding materials as components of a mixture is not supported in this version.; The elements that were added to the mixture appear in the bottom of the mixture editor. The operations performed on mixture are not undoable. Creation of New Objects; As described above, all geometry object creators are accessible within the geometry manager editor frame. Generally, if the new object that needs to be created does not depend on other objects, it will be built with a set of default parameters. This is the case for all shapes (except composite shapes) and matrices. For all the other objects the interface forces the selection of components b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:141323,undo,undoable,141323,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['undo'],['undoable']
Usability,"ect to the weights. Exploiting the well-known properties of the derivative, especially the derivative of compound functions, one can write:. for a neuron: product of the local derivative with the weighted sum on the outputs of the derivatives.; for a synapse: product of the input with the local derivative of the output neuron. This computation is called back-propagation of the errors. A loop over all examples is called an epoch. Six learning methods are implemented.; Stochastic minimization:; is the most trivial learning method. This is the Robbins-Monro stochastic approximation applied to multilayer perceptrons. The weights are updated after each example according to the formula: \(w_{ij}(t+1) = w_{ij}(t) + \Delta w_{ij}(t)\); with; \(\Delta w_{ij}(t) = - \eta(d e_p / d w_{ij} + \delta) + \epsilon \Delta w_{ij}(t-1)\); The parameters for this method are Eta, EtaDecay, Delta and Epsilon.; Steepest descent with fixed step size (batch learning):; It is the same as the stochastic minimization, but the weights are updated after considering all the examples, with the total derivative dEdw. The parameters for this method are Eta, EtaDecay, Delta and Epsilon.; Steepest descent algorithm:; Weights are set to the minimum along the line defined by the gradient. The only parameter for this method is Tau. Lower tau = higher precision = slower search. A value Tau = 3 seems reasonable.; Conjugate gradients with the Polak-Ribiere updating formula:; Weights are set to the minimum along the line defined by the conjugate gradient. Parameters are Tau and Reset, which defines the epochs where the direction is reset to the steepest descent.; Conjugate gradients with the Fletcher-Reeves updating formula:; Weights are set to the minimum along the line defined by the conjugate gradient. Parameters are Tau and Reset, which defines the epochs where the direction is reset to the steepest descent.; Broyden, Fletcher, Goldfarb, Shanno (BFGS) method:; Implies the computation of a NxN matrix compu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiLayerPerceptron.html:4764,learn,learning,4764,doc/master/classTMultiLayerPerceptron.html,https://root.cern,https://root.cern/doc/master/classTMultiLayerPerceptron.html,1,['learn'],['learning']
Usability,"ect(name, tree);; if (tree) {; tree->Print();; return 0;; } else {; Error(""printTree()"", ""Cannot find tree %s!"", name);; return -1;; }; }. You can now run this as; .x printTree.C(file, ""MyTree"");. This is equivalent to; .L printTree.C; printTree(file, ""MyTree"");. Compiling; You can also have your code compiled into a shared library, simply by adding a ""+"" behind the file name:; .x printTree.C+(file, ""MyTree"");. In the above example this will fail: we need to add the #includes for he compiler to be able to understand the code, while the interpreter has a lot of contextual knowledge and can automatically include headers and load libraries.; Expressions; You saw that with "".x"", ROOT prints the result of running the function while when using "".L"" and calling th function it does not. The way to trigger the printing of expression results is by omitting the trailing semicolon:; TMath::Gaus(1., 1., 1.). will print; (Double_t) 1.000000e+00. Help!; For TMath::Gaus() as well as for any other ROOT class or function, please check ROOT's reference guide.; Try to find the documentation for TTree::Print()!; We have now covered the basics - let's look at the tree's data!; . ‹ 1. Extracting an object from a TFile; up; 4. Histogramming ›. Navigate through this book; 0. Setting up ROOT; 1. Extracting an object from a TFile; 2. Running code in ROOT; 4. Histogramming; 3. Examining a TTree's data; 5. Fitting; 6. Multivariate Analysis; 7. Using the TTreeReader; 8. Efficiency Calculation; 9. Fitting By Coding; 10. Go Parallel!; TutorialSelector.C; 11. Done!. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/2-running-code-root.html:3312,guid,guide,3312,d/2-running-code-root.html,https://root.cern,https://root.cern/d/2-running-code-root.html,1,['guid'],['guide']
Usability,"ect* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidTObjArray::AddAt(TObject* obj, Int_t idx); virtual voidTObjArray::AddAtAndExpand(TObject* obj, Int_t idx); virtual Int_tTObjArray::AddAtFree(TObject* obj); virtual voidTObjArray::AddBefore(const TObject* before, TObject* obj); virtual voidTObjArray::AddFirst(TObject* obj); virtual voidTObjArray::AddLast(TObject* obj); voidTCollection::AddVector(TObject* obj1); virtual TObject*TObjArray::After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*TObjArray::At(Int_t i) const; virtual TObject*TObjArray::Before(const TObject* obj) const; TIterTCollection::begin() const; virtual Int_tTObjArray::BinarySearch(TObject* obj, Int_t upto = kMaxInt); virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObjArray::Clear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; virtual voidTObjArray::Compress(); Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObjArray::Delete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); TIterTCollection::end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooRefArray.html:1546,Clear,Clear,1546,root/html534/RooRefArray.html,https://root.cern,https://root.cern/root/html534/RooRefArray.html,2,['Clear'],['Clear']
Usability,"ect::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); voidAdjustSize(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); TCanvas*TCanvasImp::Canvas() const; virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(); virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()SIGNAL ; virtual voidTGWindow::DestroySubwindows(); virtual voidTGWindow::DestroyWindow(); Bool_tTQObject::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TRootCanvas.html:1720,Clear,Clear,1720,root/html532/TRootCanvas.html,https://root.cern,https://root.cern/root/html532/TRootCanvas.html,1,['Clear'],['Clear']
Usability,"ect::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. Double_tfConfidenceLevelconfidence level; Double_tfLowerLimitlower interval limit; RooArgSetfParametersset containing the parameter of interest; Double_tfUpperLimitupper interval limit. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SimpleInterval(const char* name = 0); Default constructor. SimpleInterval(const RooStats::SimpleInterval& other, const char* name); fParameters.add( other.fParameters );. operator=(const RooStats::SimpleInterval& other). SimpleInterval(const char* name, const RooRealVar& var, Double_t lower, Double_t upper, Double_t cl); Alternate constructor. ~SimpleInterval(); Destructor. Bool_t IsInInterval(const RooArgSet& ) const. RooArgSet* GetParameters() const; return cloned list of parameters. Bool_t CheckParameters(const RooArgSet& ) const. explicit SimpleInterval(const char* name = 0); default constructors. void SetConfidenceLevel(Double_t ); set the confidence level for the interval. Simple interval is defined at construction time so this function; has no effect. {}. Double_t ConfidenceLevel() const; return the confidence interval. {return fConfidenceLevel;}. Double_t LowerLimit(); return the interval lower limit. {return fLowerLimit;}. Double_t UpperLimit(); return the interval upper limit. {return fUpperLimit;}. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id$ » Last generated: 2015-03-10 17:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__SimpleInterval.html:7163,Simpl,SimpleInterval,7163,root/html534/RooStats__SimpleInterval.html,https://root.cern,https://root.cern/root/html534/RooStats__SimpleInterval.html,2,['Simpl'],"['Simple', 'SimpleInterval']"
Usability,"ect::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TMethod*fMethodpointer to a method. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMethodBrowsable(const TBranch* branch, TMethod* m, const TVirtualBranchBrowsable* parent = 0); Constructor.; Links a TBranchElement to a TMethod, allowing the TBrowser to; browse simple methods. The c'tor sets the name for a method ""Class::Method(params) const""; to ""Method(params)"", title to TMethod::GetPrototype. void GetBrowsableMethodsForClass(TClass* cl, TList& list); Given a class, this methods fills list with TMethodBrowsables; for the class and its base classes, and returns the number of; added elements. If called from a TBranch::Browse overload, ""branch""; should be set to the calling TBranch, otherwise ""parent"" should; be set to the TVirtualBranchBrowsable being browsed, and branch; should be the branch of the parent. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); This methods fills list with TMethodBrowsables; for the branch's or parent's class and its base classes, and returns; the number of added elements. If called from a TBranch::Browse; overload, ""branch"" should be set to the calling TBranch, otherwise; ""parent"" should be set to the TVirtualBranchBrowsable being brows",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMethodBrowsable.html:9597,simpl,simple,9597,root/html602/TMethodBrowsable.html,https://root.cern,https://root.cern/root/html602/TMethodBrowsable.html,4,['simpl'],['simple']
Usability,"ect::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TMapfDescriptionMapstores the key, value pairs of the JDL; TMapfMapstores the key, value pairs of the JDL. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGridJDL(); Cleanup. void Clear(Option_t* = 0); Clears the JDL information. void SetValue(const char* key, const char* value); Sets a value. If the entry already exists the old one is replaced. const char * GetValue(const char* key); Returns the value corresponding to the provided key. Return 0 in case; key is not found. void SetDescription(const char* key, const char* description); Sets a value. If the entry already exists the old one is replaced. const char * GetDescription(const char* key); Returns the value corresponding to the provided key. Return 0 in case; key is not found. TString AddQuotes(const char* value); Adds quotes to the provided string.; E.g. Value --> ""Value"". void AddToSet(const char* key, const char* value); Adds a value to a key value which hosts a set of values.; E.g. InputSandbox: {""file1"",""file2""}. void AddToSetDescription(const char* key, const char* description); Adds a value to a key value which hosts a set of values.; E.g. InputSandbox: {""file1"",""file2""}. TString Generate(); Generates the JDL snippet. voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGridJDL.html:7575,Clear,Clear,7575,root/html532/TGridJDL.html,https://root.cern,https://root.cern/root/html532/TGridJDL.html,4,['Clear'],"['Clear', 'Clears']"
Usability,"ect::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Bool_tfColourfulOutputflag for use of colors; TMVA::MsgLogger*fLoggerthe output logger; Int_tfNcountsreference number of ""counts""; TStringfPrefixprefix for outputs; static const TStringfgClassNameused for output; static const Int_tfgNbinsnumber of bins in progress bar. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Timer(const char* prefix = """", Bool_t colourfulOutput = kTRUE); constructor. Timer(Int_t ncounts, const char* prefix = """", Bool_t colourfulOutput = kTRUE); standard constructor: ncounts gives the total number of counts that; the loop will iterate through. At each call of the timer, the current; number of counts is provided by the user, so that the timer can obtain; the due time from linearly interpolating the spent time. ~Timer( void ); destructor. void Init(Int_t ncounts); timer initialisation. void Reset( void ); resets timer. Double_t ElapsedSeconds( void ); computes elapsed tim in seconds. TString GetElapsedTime(Bool_t Scientific = kTRUE); returns pretty string with elaplsed time. TString GetLeftTime(Int_t icounts); returns pretty string with time left. void DrawProgressBar(); draws the progressbar. void DrawProgressBar(TString ); draws a string in the progress bar. void DrawProgressBar(Int_t , const TString& comment = """"); draws progress bar in color or B&W; caution:. TString SecToText(Double_t , Bool_t ) const; pretty string output. Timer(const char* prefix = """", Bool_t colourfulOutput = kTRUE). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss » Copyright (c) 2006: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__Timer.html:8094,progress bar,progress bar,8094,root/html604/TMVA__Timer.html,https://root.cern,https://root.cern/root/html604/TMVA__Timer.html,4,['progress bar'],['progress bar']
Usability,"ect::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Bool_tfColourfulOutputflag for use of colors; TMVA::MsgLogger*fLoggerthe output logger; Int_tfNcountsreference number of ""counts""; TStringfPrefixprefix for outputs; static const TStringfgClassNameused for output; static const Int_tfgNbinsnumber of bins in progress bar. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Timer(const char* prefix = """", Bool_t colourfulOutput = kTRUE); constructor. Timer(Int_t ncounts, const char* prefix = """", Bool_t colourfulOutput = kTRUE); standard constructor: ncounts gives the total number of counts that; the loop will iterate through. At each call of the timer, the current; number of counts is provided by the user, so that the timer can obtain; the due time from linearly interpolating the spent time. ~Timer( void ); destructor. void Init(Int_t ncounts); timer initialisation. void Reset( void ); resets timer. Double_t ElapsedSeconds( void ); computes elapsed tim in seconds. TString GetElapsedTime(Bool_t Scientific = kTRUE); returns pretty string with elaplsed time. TString GetLeftTime(Int_t icounts); returns pretty string with time left. void DrawProgressBar(); draws the progressbar. void DrawProgressBar(TString ); draws a string in the progress bar. void DrawProgressBar(Int_t , const TString& comment = """"); draws progress bar in color or B&W; caution:. TString SecToText(Double_t , Bool_t ) const; pretty string output. Timer(const char* prefix = """", Bool_t colourfulOutput = kTRUE). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss » Copyright (c) 2006: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-30 15:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__Timer.html:8086,progress bar,progress bar,8086,root/html602/TMVA__Timer.html,https://root.cern,https://root.cern/root/html602/TMVA__Timer.html,4,['progress bar'],['progress bar']
Usability,"ectWise! List of write action resulting from the compilation.; static Int_tfgCountNumber of TStreamerInfo instances. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStreamerInfo(); Default ctor. TStreamerInfo(TClass* cl); Create a TStreamerInfo object. ~TStreamerInfo(); TStreamerInfo dtor. void Build(); Build the I/O data structure for the current class version.; A list of TStreamerElement derived classes is built by scanning; one by one the list of data members of the analyzed class. void BuildCheck(TFile* file = 0); Check if built and consistent with the class dictionary.; This method is called by TFile::ReadStreamerInfo. void BuildEmulated(TFile* file); Create an Emulation TStreamerInfo object. Bool_t BuildFor(const TClass* cl). Check if we can build this for foreign class - do we have some rules; to do that. void BuildOld(); rebuild the TStreamerInfo structure. void Clear(Option_t* ); If opt cointains 'built', reset this StreamerInfo as if Build or BuildOld; was never called on it (usefull to force their re-running). void CallShowMembers(void* obj, TMemberInspector& insp) const; Emulated a call ShowMembers() on the obj of this class type, passing insp and parent. TObject * Clone(const char* newname = """") const; Make a clone of an object using the Streamer facility.; If newname is specified, this will be the name of the new object. Bool_t CompareContent(TClass* cl, TVirtualStreamerInfo* info, Bool_t warn, Bool_t complete, TFile* file); Return True if the current StreamerInfo in cl or info is equivalent to this TStreamerInfo.; 'Equivalent' means the same number of persistent data member which the same actual C++ type and; the same name.; if 'warn' is true, Warning message are printed to explicit the differences.; if 'complete' is false, stop at the first error, otherwise continue until all members have been checked. void ComputeSize(); Compute total size of all persistent elements of the class. void ForceWriteInfo(TFile* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TStreamerInfo.html:16359,Clear,Clear,16359,root/html534/TStreamerInfo.html,https://root.cern,https://root.cern/root/html534/TStreamerInfo.html,1,['Clear'],['Clear']
Usability,"ected . Init the packetizer Return 0 on success (fPacketizer is correctly initialized), -1 on failure. ; Definition at line 1915 of file TProofPlayer.cxx. ◆ IsA(). TClass * TProofPlayerRemote::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TProofPlayer.; Reimplemented in TProofPlayerSuperMaster.; Definition at line 366 of file TProofPlayer.h. ◆ IsClient(). Bool_t TProofPlayerRemote::IsClient ; (; ); const. overridevirtual . Is the player running on the client? ; Reimplemented from TProofPlayer.; Definition at line 4223 of file TProofPlayer.cxx. ◆ JoinProcess(). Bool_t TProofPlayerRemote::JoinProcess ; (; TList * ; workers). overridevirtual . Prepares the given list of new workers to join a progressing process. ; Returns kTRUE on success, kFALSE otherwise. ; Reimplemented from TProofPlayer.; Definition at line 2533 of file TProofPlayer.cxx. ◆ MergeFeedback(). TList * TProofPlayerRemote::MergeFeedback ; (; ). protected . Merge feedback lists. ; Definition at line 3926 of file TProofPlayer.cxx. ◆ MergeOutput(). void TProofPlayerRemote::MergeOutput ; (; Bool_t ; savememvalues = kFALSE). overridevirtual . Merge objects in output the lists. ; Reimplemented from TProofPlayer.; Definition at line 3114 of file TProofPlayer.cxx. ◆ MergeOutputFiles(). Bool_t TProofPlayerRemote::MergeOutputFiles ; (; ). protected . Merge output in files. ; Definition at line 2582 of file TProofPlayer.cxx. ◆ NotifyMemory(). void TProofPlayerRemote::NotifyMemory ; (; TObject * ; obj). protected . Printout the memory record after merging object 'obj' This record is used by the memory monitor. ; Definition at line 3593 of file TProofPlayer.cxx. ◆ Process() [1/2]. Long64_t TProofPlayerRemote::Process ; (; TDSet * ; dset, . const char * ; selector_file, . Option_t * ; option = """", . Long64_t ; nentries = -1, . Long64_t ; first = 0 . ). overridevirtual . Process specified TDSet on PROOF. ; This method is called on client and on the PROOF master.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerRemote.html:31837,feedback,feedback,31837,doc/master/classTProofPlayerRemote.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerRemote.html,1,['feedback'],['feedback']
Usability,"ected . propagate an error matrix on the input vector to the unfolding result ; Parameters. [in]vyyinput error matrix ; [in,out]ematrixhistogram to be updated ; [in]binMapmapping of histogram bins ; [in]clearEmatif set, clear histogram before adding this covariance contribution . Definition at line 1250 of file TUnfoldSys.cxx. ◆ GetEmatrixInput(). void TUnfoldSys::GetEmatrixInput ; (; TH2 * ; ematrix, . const Int_t * ; binMap = nullptr, . Bool_t ; clearEmat = kTRUE . ). covariance matrix contribution from input measurement uncertainties ; Parameters. [in,out]ematrixoutput histogram ; [in]binMap(default=nullptr) remapping of histogram bins ; [in]clearEmat(default=true) if true, clear the histogram. this method returns the covariance contributions to the unfolding result from the uncertainties or covariance of the input data. In many cases, these are the ""statistical uncertainties"". ; The array binMap is explained with the method GetOutput(). The flag clearEmat may be used to add covariance matrices from several uncertainty sources. ; Definition at line 1207 of file TUnfoldSys.cxx. ◆ GetEmatrixSysBackgroundScale(). void TUnfoldSys::GetEmatrixSysBackgroundScale ; (; TH2 * ; ematrix, . const char * ; name, . const Int_t * ; binMap = nullptr, . Bool_t ; clearEmat = kTRUE . ). covariance contribution from background normalisation uncertainty ; Parameters. [in,out]ematrixoutput histogram ; [in]sourceidentifier of the background source ; [in]binMap(default=nullptr) remapping of histogram bins ; [in]clearEmat(default=true) if true, clear the histogram prior to adding the covariance matrix contribution. this method returns the uncertainties on the unfolding result arising from the background source source and its normalisation uncertainty. See method SubtractBackground() how to set the normalisation uncertainty ; the array binMap is explained with the method GetOutput(). The flag clearEmat may be used to add covariance matrices from several uncertainty sources. ; Definition a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldSys.html:38142,clear,clearEmat,38142,doc/master/classTUnfoldSys.html,https://root.cern,https://root.cern/doc/master/classTUnfoldSys.html,1,['clear'],['clearEmat']
Usability,"ectedRows][fDimension] Local buffer for the variables; Int_tfValSize; TTreeFormula**fVar![fDimension] Array of pointers to variables formula; Bool_t*fVarMultiple![fDimension] true if fVar[i] has a variable index; Double_t*fVmax![fDimension] Maxima of varexp columns; Double_t*fVmin![fDimension] Minima of varexp columns; Double_t*fW![fSelectedRows]Local buffer for weights; Double_tfWeightTree weight (see TTree::SetWeight). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSelectorDraw(); Default selector constructor. ~TSelectorDraw(); Selector destructor. void Begin(TTree* tree); Called everytime a loop on the tree(s) starts. void ClearFormula(); Delete internal buffers. Bool_t CompileVariables(const char* varexp = """", const char* selection = """"); Compile input variables and selection expression. varexp is an expression of the general form e1:e2:e3; where e1,etc is a formula referencing a combination of the columns; Example:; varexp = x simplest case: draw a 1-Dim distribution of column named x; = sqrt(x) : draw distribution of sqrt(x); = x*y/z; = y:sqrt(x) 2-Dim dsitribution of y versus sqrt(x). selection is an expression with a combination of the columns; Example:; selection = ""x<y && sqrt(z)>3.2""; in a selection all the C++ operators are authorized. Return kFALSE if any of the variable is not compilable. Double_t* GetVal(Int_t i) const; Get variable buffer. TTreeFormula* GetVar(Int_t i) const; Get variable formula. void InitArrays(Int_t newsize); Initialization of the primitive type arrays if the new size is bigger than the available space. UInt_t SplitNames(const TString& varexp, vector<TString>& names); Build Index array for names in varexp.; This will allocated a C style array of TString and Ints. Bool_t Notify(); This function is called at the first entry of a new tree in a chain. void ProcessFill(Long64_t entry); Called in the entry loop for all entries accepted by Select. void ProcessFillMultiple(Long64_t entry); Call",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSelectorDraw.html:9526,simpl,simplest,9526,root/html528/TSelectorDraw.html,https://root.cern,https://root.cern/root/html528/TSelectorDraw.html,1,['simpl'],['simplest']
Usability,"ectedRows][fDimension] Local buffer for the variables; Int_tfValSize; TTreeFormula**fVar![fDimension] Array of pointers to variables formula; Bool_t*fVarMultiple![fDimension] true if fVar[i] has a variable index; Double_t*fVmax![fDimension] Maxima of varexp columns; Double_t*fVmin![fDimension] Minima of varexp columns; Double_t*fW![fSelectedRows]Local buffer for weights; Double_tfWeightTree weight (see TTree::SetWeight). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSelectorDraw(); Default selector constructor. ~TSelectorDraw(); Selector destructor. void Begin(TTree* tree); Called everytime a loop on the tree(s) starts. void ClearFormula(); Delete internal buffers. Bool_t CompileVariables(const char* varexp = """", const char* selection = """"); Compile input variables and selection expression. varexp is an expression of the general form e1:e2:e3; where e1,etc is a formula referencing a combination of the columns; Example:; varexp = x simplest case: draw a 1-Dim distribution of column named x; = sqrt(x) : draw distribution of sqrt(x); = x*y/z; = y:sqrt(x) 2-Dim dsitribution of y versus sqrt(x). selection is an expression with a combination of the columns; Example:; selection = ""x<y && sqrt(z)>3.2""; in a selection all the C++ operators are authorized. Return kFALSE if any of the variable is not compilable. Double_t* GetVal(Int_t i) const; Return the last values corresponding to the i-th component; of the formula being processed (where the component are ':' separated).; The actual number of entries is:; GetSelectedRows() % tree->GetEstimate(); Note GetSelectedRows currently returns the actual number of values plotted; and thus if the formula contains arrays, this number might be greater than; the number of entries in the trees.; By default TTree::Draw creates the arrays obtained; with all GetVal and GetW with a length corresponding to the; parameter fEstimate. By default fEstimate=10000 and can be modified; via TTree::SetEstim",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSelectorDraw.html:9632,simpl,simplest,9632,root/html530/TSelectorDraw.html,https://root.cern,https://root.cern/root/html530/TSelectorDraw.html,5,['simpl'],['simplest']
Usability,"ection of TGraph objects; TMultiLayerPerceptron a Neural Network; TMutex Mutex lock class; TMutexImp Mutex lock implementation ABC; TMySQLResult MySQL query result; TMySQLRow One row of MySQL query result; TMySQLServer Connection to MySQL server; TMySQLStatement SQL statement class for MySQL DB; TNDArray Base for n-dimensional array; TNDArrayRef<Long64_t> subdimension of a TNDArray; TNDArrayRef<ULong64_t> subdimension of a TNDArray; TNDArrayRef<char> subdimension of a TNDArray; TNDArrayRef<double> subdimension of a TNDArray; TNDArrayRef<float> subdimension of a TNDArray; TNDArrayRef<int> subdimension of a TNDArray; TNDArrayRef<long> subdimension of a TNDArray; TNDArrayRef<short> subdimension of a TNDArray; TNDArrayRef<unsigned int> subdimension of a TNDArray; TNDArrayRef<unsigned long> subdimension of a TNDArray; TNDArrayRef<unsigned short> subdimension of a TNDArray; TNDArrayT<Long64_t> N-dimensional array; TNDArrayT<ULong64_t> N-dimensional array; TNDArrayT<char> N-dimensional array; TNDArrayT<double> N-dimensional array; TNDArrayT<float> N-dimensional array; TNDArrayT<int> N-dimensional array; TNDArrayT<long> N-dimensional array; TNDArrayT<short> N-dimensional array; TNDArrayT<unsigned int> N-dimensional array; TNDArrayT<unsigned long> N-dimensional array; TNDArrayT<unsigned short> N-dimensional array; TNamed The basis for a named object (name, title); TNetFile A ROOT file that reads/writes via a rootd server; TNetFileStager Implementation for a 'rootd' backend; TNetSystem Directory handler for NetSystem; TNetXNGFile ROOT class definition; TNetXNGFileStager ! Interface to a 'XRD' staging; TNetXNGSystem ROOT class definition; TNeuron Neuron for MultiLayerPerceptrons; TNewChainDlg New chain dialog; TNewQueryDlg New query dialog; TNode Description of parameters to position a 3-D geometry object; TNodeDiv Description of parameters to divide a 3-D geometry object; TNonSplitBrowsable Helper object to browse unsplit objects; TNtuple A simple tree with branches of floats.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ClassIndex.html:117040,simpl,simple,117040,root/html534/ClassIndex.html,https://root.cern,https://root.cern/root/html534/ClassIndex.html,2,['simpl'],['simple']
Usability,"ection(); virtual TClass*IsA() const; virtual voidTGLPlotPainter::Paint(); virtual voidPan(Int_t px, Int_t py); virtual Bool_tTGLPlotPainter::PlotSelected(Int_t px, Int_t py); virtual voidProcessEvent(Int_t event, Int_t px, Int_t py); const TGLPlotBox&TGLPlotPainter::RefBackBox() const; voidTGLPlotPainter::SetDrawAxes(Bool_t s); voidTGLPlotPainter::SetDrawBackBox(Bool_t b); voidTGLPlotPainter::SetDrawFrontBox(Bool_t b); virtual voidTGLPlotPainter::SetFrameColor(const TColor* frameColor); voidTGLPlotPainter::SetPadColor(const TColor* color); voidTGLPlotPainter::SetPhysicalShapeColor(const Float_t* rgba); virtual voidShowMembers(TMemberInspector& insp); virtual voidStartPan(Int_t px, Int_t py); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. virtual voidTGLPlotPainter::ClearBuffers() const; voidTGLPlotPainter::DrawSections() const; const TColor*TGLPlotPainter::GetPadColor() const; voidTGLPlotPainter::MoveSection(Int_t px, Int_t py); voidTGLPlotPainter::PrintPlot() const; voidTGLPlotPainter::RestoreModelviewMatrix() const; voidTGLPlotPainter::RestoreProjectionMatrix() const; voidTGLPlotPainter::SaveModelviewMatrix() const; voidTGLPlotPainter::SaveProjectionMatrix() const. private:. TGLBoxPainter(const TGLBoxPainter&); virtual voidDeInitGL() const; voidDrawCloud() const; voidDrawPalette() const; virtual voidDrawPaletteAxis() const; virtual voidDrawPlot() const; virtual voidDrawSectionXOY() const; virtual voidDrawSectionXOZ() const; virtual voidDrawSectionYOZ() const; Bool_tHasSections() const; virtual voidInitGL() const; TGLBoxPainter&operator=(const TGLBoxPainter&); voidSetPlotColor() const. Data Members; public:. enum EBoxType { kBox; kBox1; };; enum TGLPlotPainter::ESelectionBase { kHighColorSelectionBase; kTrueColorSelectionBase; };; enum TGLPlotPainter::ECutAxisID { kXAxis; kYAxis; kZAxis; };. protected:. TGLPlotBoxTGLPlotPainter::fBackBox; TGLBoxCutTGLPlotPainter::fBoxCut; TGLPlotCamera*TGLPlotPainter::fCamera; TGLPlotCoordinates*TG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGLBoxPainter.html:1695,Clear,ClearBuffers,1695,root/html532/TGLBoxPainter.html,https://root.cern,https://root.cern/root/html532/TGLBoxPainter.html,1,['Clear'],['ClearBuffers']
Usability,"ection(); virtual TClass*IsA() const; virtual voidTGLPlotPainter::Paint(); virtual voidPan(Int_t px, Int_t py); virtual Bool_tTGLPlotPainter::PlotSelected(Int_t px, Int_t py); virtual voidProcessEvent(Int_t event, Int_t px, Int_t py); const TGLPlotBox&TGLPlotPainter::RefBackBox() const; voidTGLPlotPainter::SetDrawAxes(Bool_t s); voidTGLPlotPainter::SetDrawBackBox(Bool_t b); voidTGLPlotPainter::SetDrawFrontBox(Bool_t b); virtual voidTGLPlotPainter::SetFrameColor(const TColor* frameColor); voidTGLPlotPainter::SetPadColor(const TColor* color); voidTGLPlotPainter::SetPhysicalShapeColor(const Float_t* rgba); virtual voidShowMembers(TMemberInspector& insp); virtual voidStartPan(Int_t px, Int_t py); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. virtual voidTGLPlotPainter::ClearBuffers() const; voidTGLPlotPainter::DrawSections() const; const TColor*TGLPlotPainter::GetPadColor() const; voidTGLPlotPainter::MoveSection(Int_t px, Int_t py); voidTGLPlotPainter::PrintPlot() const; voidTGLPlotPainter::RestoreModelviewMatrix() const; voidTGLPlotPainter::RestoreProjectionMatrix() const; voidTGLPlotPainter::SaveModelviewMatrix() const; voidTGLPlotPainter::SaveProjectionMatrix() const. private:. TGLLegoPainter(const TGLLegoPainter&); Bool_tClampZ(Double_t& zVal) const; virtual voidDeInitGL() const; voidDrawLegoCartesian() const; voidDrawLegoCylindrical() const; voidDrawLegoPolar() const; voidDrawLegoSpherical() const; voidDrawPalette() const; virtual voidDrawPaletteAxis() const; virtual voidDrawPlot() const; virtual voidDrawSectionXOY() const; virtual voidDrawSectionXOZ() const; virtual voidDrawSectionYOZ() const; Bool_tInitGeometryCartesian(); Bool_tInitGeometryCylindrical(); Bool_tInitGeometryPolar(); Bool_tInitGeometrySpherical(); virtual voidInitGL() const; TGLLegoPainter&operator=(const TGLLegoPainter&); Bool_tPreparePalette() const; voidSetLegoColor() const. Data Members; public:. enum ELegoType { kColorSimple; kColorLevel; kCylindricBars; };; e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGLLegoPainter.html:1641,Clear,ClearBuffers,1641,root/html532/TGLLegoPainter.html,https://root.cern,https://root.cern/root/html532/TGLLegoPainter.html,1,['Clear'],['ClearBuffers']
Usability,"ection(); virtual TClass*IsA() const; virtual voidTGLPlotPainter::Paint(); virtual voidPan(Int_t px, Int_t py); virtual Bool_tTGLPlotPainter::PlotSelected(Int_t px, Int_t py); virtual voidProcessEvent(Int_t event, Int_t px, Int_t py); const TGLPlotBox&TGLPlotPainter::RefBackBox() const; voidTGLPlotPainter::SetDrawAxes(Bool_t s); voidTGLPlotPainter::SetDrawBackBox(Bool_t b); voidTGLPlotPainter::SetDrawFrontBox(Bool_t b); virtual voidTGLPlotPainter::SetFrameColor(const TColor* frameColor); voidTGLPlotPainter::SetPadColor(const TColor* color); voidTGLPlotPainter::SetPhysicalShapeColor(const Float_t* rgba); virtual voidShowMembers(TMemberInspector& insp); virtual voidStartPan(Int_t px, Int_t py); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. virtual voidTGLPlotPainter::ClearBuffers() const; voidTGLPlotPainter::DrawSections() const; const TColor*TGLPlotPainter::GetPadColor() const; voidTGLPlotPainter::MoveSection(Int_t px, Int_t py); voidTGLPlotPainter::PrintPlot() const; voidTGLPlotPainter::RestoreModelviewMatrix() const; voidTGLPlotPainter::RestoreProjectionMatrix() const; voidTGLPlotPainter::SaveModelviewMatrix() const; voidTGLPlotPainter::SaveProjectionMatrix() const. private:. TGLVoxelPainter(const TGLVoxelPainter&); virtual voidDeInitGL() const; voidDrawPalette() const; virtual voidDrawPaletteAxis() const; virtual voidDrawPlot() const; virtual voidDrawSectionXOY() const; virtual voidDrawSectionXOZ() const; virtual voidDrawSectionYOZ() const; voidFindVoxelColor(Double_t binContent, Float_t* rgba) const; Bool_tHasSections() const; virtual voidInitGL() const; TGLVoxelPainter&operator=(const TGLVoxelPainter&); voidPreparePalette() const; voidSetVoxelColor(const Float_t* rgba) const. Data Members; public:. enum TGLPlotPainter::ESelectionBase { kHighColorSelectionBase; kTrueColorSelectionBase; };; enum TGLPlotPainter::ECutAxisID { kXAxis; kYAxis; kZAxis; };. protected:. TGLPlotBoxTGLPlotPainter::fBackBox; TGLBoxCutTGLPlotPainter::fBoxCut",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGLVoxelPainter.html:1624,Clear,ClearBuffers,1624,root/html532/TGLVoxelPainter.html,https://root.cern,https://root.cern/root/html532/TGLVoxelPainter.html,1,['Clear'],['ClearBuffers']
Usability,"ection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::SetPointvirtual void SetPoint(Int_t i, Double_t x, Double_t y)Set x and y values for point number i.Definition TGraph.cxx:2342; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::SetBinContentvirtual void SetBinContent(Int_t bin, Double_t content)Set bin content see convention for numbering bins in TH1::GetBin In case the bin number is greater th...Definition TH1.cxx:9222; TListA doubly linked list.Definition TList.h:38; TList::AtTObject * At(Int_t idx) const overrideReturns the object at position idx. Returns 0 if idx is out of range.Definition TList.cxx:355; TMVA::BinarySearchTreeA simple Binary search tree including a volume search method.Definition BinarySearchTree.h:65; TMVA::Config::WriteOptionsReferenceBool_t WriteOptionsReference() constDefinition Config.h:65; TMVA::Configurable::CheckForUnusedOptionsvoid CheckForUnusedOptions() constchecks for unused options in option stringDefinition Configurable.cxx:270; TMVA::DataSetInfoClass that contains all the data information.Definition DataSetInfo.h:62; TMVA::EventDefinition Event.h:51; TMVA::Event::GetValueFloat_t GetValue(UInt_t ivar) constreturn value of i'th variableDefinition Event.cxx:236; TMVA::FitterBaseBase class for TMVA fitters.Definition FitterBase.h:51; TMVA::FitterBase::SetIPythonInteractivevoid SetIPythonInteractive(bool *ExitFromTraining, UInt_t *fIPyMaxIter_, UInt_t *fIPyCurrentIter_)Definition FitterBase.h:73; TMVA::FitterBase::RunDouble_t Run()estimator function interface for fittingDefinition FitterBase.cxx:74; TMVA::GeneticFitterFitter using a Genetic Algorithm.Definition GeneticFitter.h:44; TMVA::Interval",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodCuts_8cxx_source.html:76905,simpl,simple,76905,doc/master/MethodCuts_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodCuts_8cxx_source.html,1,['simpl'],['simple']
Usability,"ection::sort(Bool_t ascend = kTRUE); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; voidRooAbsCollection::takeOwnership(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; voidwriteToFile(const char* fileName) const; virtual voidwriteToStream(ostream& os, Bool_t compact, const char* section = 0) const. protected:. Bool_tRooAbsCollection::addServerClonesToList(const RooAbsArg& var); Bool_tcheckForDup(const RooAbsArg& arg, Bool_t silent) const; voidRooAbsCollection::clearStructureTags(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidRooAbsCollection::makeStructureTag(); voidRooAbsCollection::makeTypedStructureTag(); voidTObject::MakeZombie(); voidRooAbsCollection::safeDeleteList(); TNamed*RooAbsCollection::structureTag(); TNamed*RooAbsCollection::typedStructureTag(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. Bool_tRooAbsCollection::_allRRVAll contents are RRV; RooLinkedListRooAbsCollection::_listActual object store; TStringRooAbsCollection::_nameOur name.; static Int_tRooPrintable::_nameLength; Bool_tRooAbsCollection::_ownContFlag to identif",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooArgSet.html:12961,clear,clearStructureTags,12961,root/html532/RooArgSet.html,https://root.cern,https://root.cern/root/html532/RooArgSet.html,1,['clear'],['clearStructureTags']
Usability,"ection; if (reqSections & TBuffer3D::kRaw) {; //buffer.SetSectionsValid(TBuffer3D::kRaw);; }; ; return buffer;; }; ; class Box : public Shape; {; public:; Box(Int_t color, Double_t x, Double_t y, Double_t z,; Double_t dX, Double_t dY, Double_t dZ);; ~Box() override {};; ; TBuffer3D & GetBuffer3D(UInt_t reqSections) override;; ; private:; Double_t fDX, fDY, fDZ; // Half lengths; ; ClassDefOverride(Box,0);; };; ; ClassImp(Box);; ; Box::Box(Int_t color, Double_t x, Double_t y, Double_t z,; Double_t dX, Double_t dY, Double_t dZ) :; Shape(color,x,y,z),; fDX(dX), fDY(dY), fDZ(dZ); {}; ; TBuffer3D & Box::GetBuffer3D(UInt_t reqSections); {; static TBuffer3D buffer(TBuffer3DTypes::kGeneric);; ; // Complete kCore section - this could be moved to Shape base class; if (reqSections & TBuffer3D::kCore) {; buffer.ClearSectionsValid();; buffer.fID = this;; buffer.fColor = fColor; // Color index - see gROOT->GetColor(); buffer.fTransparency = 0; // Transparency 0 (opaque) - 100 (fully transparent); ; // Complete local/master transformation matrix - simple x/y/z; // translation. Easiest way to set identity then override the; // translation components; buffer.SetLocalMasterIdentity();; buffer.fLocalMaster[12] = fX;; buffer.fLocalMaster[13] = fY;; buffer.fLocalMaster[14] = fZ;; buffer.fLocalFrame = kTRUE; // Local frame; ; buffer.fReflection = kFALSE;; buffer.SetSectionsValid(TBuffer3D::kCore);; }; // Complete kBoundingBox section; if (reqSections & TBuffer3D::kBoundingBox) {; Double_t origin[3] = { fX, fY, fZ };; Double_t halfLength[3] = { fDX, fDY, fDZ };; buffer.SetAABoundingBox(origin, halfLength);; buffer.SetSectionsValid(TBuffer3D::kBoundingBox);; }; // No kShapeSpecific section; ; // Complete kRawSizes section; if (reqSections & TBuffer3D::kRawSizes) {; buffer.SetRawSizes(8, 3*8, 12, 3*12, 6, 6*6);; buffer.SetSectionsValid(TBuffer3D::kRawSizes);; }; // Complete kRaw section; if (reqSections & TBuffer3D::kRaw) {; // Points (8); // 3 components: x,y,z; buffer.fPnts[ 0] = fX - fDX; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/viewer3DLocal_8C.html:4984,simpl,simple,4984,doc/master/viewer3DLocal_8C.html,https://root.cern,https://root.cern/doc/master/viewer3DLocal_8C.html,1,['simpl'],['simple']
Usability,"ectionProxy::CheckFunctions() const; virtual voidTGenCollectionProxy::DeleteItem(Bool_t force, void* ptr) const; voidExpand(UInt_t nCurr, UInt_t left); TGenCollectionProxy*TGenCollectionProxy::Initialize(Bool_t silent) const; virtual TGenCollectionProxy*InitializeEx(Bool_t silent); voidReadItems(int nElements, TBuffer& b); voidShrink(UInt_t nCurr, UInt_t left, Bool_t force); voidWriteItems(int nElements, TBuffer& b). Data Members; public:. enum TGenCollectionProxy::[unnamed] { kBIT_ISSTRING; kBIT_ISTSTRING; kBOOL_t; };; enum TVirtualCollectionProxy::EProperty { kIsInitialized; kIsAssociative; kIsEmulated; kNeedDelete; };. public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodTGenCollectionProxy::fClearMethod cache for container accessors: clear container; TGenCollectionProxy::MethodTGenCollectionProxy::fCollectMethod to collect objects from container; void*TGenCollectionProxy::fConstructContainer accessors: block construct; map<std::string,TObjArray*>*TGenCollectionProxy::fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0TGenCollectionProxy::fCreateEnvMethod to allocate an Environment holder.; void*TGenCollectionProxy::fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*TGenCollectionProxy::fEnvAddress of the currently proxied object; void*TGenCollectionProxy::fFeedContainer accessors: block feed; TGenCollectionProxy::MethodTGenCollectionProxy::fFirstContainer accessors: generic iteration: first; void*TGenCollectionProxy::fFunctionCreateIterators; void*TGenCollectionProxy::fFunctionDeleteTwoIterators; TGenCollectionProxy::Value*TGenCollectionProxy::fKeyDescriptor of the key_type; stringTGenCollectionProxy::fNameName of the class being proxied.; TGenCollectionProxy::MethodTGenCollectionProxy::fNextCont",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEmulatedCollectionProxy.html:4340,clear,clear,4340,root/html532/TEmulatedCollectionProxy.html,https://root.cern,https://root.cern/root/html532/TEmulatedCollectionProxy.html,2,['clear'],['clear']
Usability,"ector.h, TQuaternion.h, TRobustEstimator.h, TRolke.h,; TRotation.h, TVector2.h, TVector3.h; 1.7 How to Find More Information; website The ROOT web site has up to date documentation. The ROOT source code automatically generates this documentation, so each class is explicitly documented on its own web page, which is always up to date with the latest official release of ROOT.; The ROOT Reference Guide web pages can be found at class index reference guide https://root.cern/doc/master/classes.html. Each page contains a class description, and an explanation of each method. It shows the class inheritance tree and lets you jump to the parent class page by clicking on the class name. If you want more details, you can even see the source. There is a help page available in the little box on the upper right hand side of each class documentation page. You can see on the next page what a typical class documentation web page looks like. The ROOT web site also contains in addition to this Reference Guide, “How To’s”, a list of publications and example applications.; 1.7.1 Class Reference Guide; The top of any class reference page lets you jump to different parts of the documentation. The first line links to the class index and the index for the current module (a group of classes, often a library). The second line links to the ROOT homepage and the class overviews. The third line links the source information - a HTML version of the source and header file as well as the CVS (the source management system used for the ROOT development) information of the files. The last line links the different parts of the current pages. Example of function documentation, with automatically generated LaTeX-like graphics. Inheritance tree, showing what the current class derives from, and which classes inherit from it. HTML version of the source file linking all types and most functions. 2 Getting Started; We begin by showing you how to use ROOT interactively. There are two examples to click through and",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:29193,Guid,Guide,29193,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Guid'],['Guide']
Usability,"ector< double > m_dropOutDefinition NeuralNet.h:850; TMVA::DNN::Settings::m_minProgressdouble m_minProgresscurrent limits for the progress barDefinition NeuralNet.h:833; TMVA::DNN::Settings::cyclevirtual void cycle(double progress, TString text)Definition NeuralNet.h:799; TMVA::DNN::Settings::setProgressLimitsvirtual void setProgressLimits(double minProgress=0, double maxProgress=100)Definition NeuralNet.h:790; TMVA::DNN::Settings::m_maxProgressdouble m_maxProgresscurrent limits for the progress barDefinition NeuralNet.h:834; TMVA::DNN::Settings::endTrainCyclevirtual void endTrainCycle(double)callback for monitoring and loggingDefinition NeuralNet.h:788; TMVA::DNN::Settings::count_dEsize_t count_dEDefinition NeuralNet.h:843; TMVA::DNN::Settings::drawSamplevirtual void drawSample(const std::vector< double > &, const std::vector< double > &, const std::vector< double > &, double)callback for monitoring and loggingDefinition NeuralNet.h:807; TMVA::DNN::Settings::learningRatedouble learningRate() constget the learning rateDefinition NeuralNet.h:771; TMVA::DNN::Settings::m_dropRepetitionsdouble m_dropRepetitionsDefinition NeuralNet.h:849; TMVA::DNN::Settings::dropFractionsconst std::vector< double > & dropFractions() constDefinition NeuralNet.h:762; TMVA::DNN::Settings::addPointvoid addPoint(std::string histoName, double x)for monitoringDefinition NeuralNet.h:821; TMVA::DNN::Settings::~Settingsvirtual ~Settings()d'torDefinition NeuralNet.cxx:261; TMVA::DNN::Settings::m_convergenceCountsize_t m_convergenceCountDefinition NeuralNet.h:857; TMVA::DNN::Settings::m_regularizationEnumRegularization m_regularizationDefinition NeuralNet.h:847; TMVA::DNN::Settings::repetitionsint repetitions() consthow many steps have to be gone until the batch is changedDefinition NeuralNet.h:773; TMVA::DNN::Settings::m_minErrordouble m_minErrorDefinition NeuralNet.h:859; TMVA::DNN::Settings::testSamplevirtual void testSample(double, double, double, double)virtual function to be used for monitorin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:74593,learn,learningRatedouble,74593,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,3,['learn'],"['learning', 'learningRate', 'learningRatedouble']"
Usability,"ectory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  ;  Public Member Functions inherited from RooPrintable;  RooPrintable ();  ; virtual ~RooPrintable ();  ; virtual StyleOption defaultPrintStyle (Option_t *opt) const;  ; virtual void printExtras (std::ostream &os) const;  Interface to print extras of object. ;  ; virtual void printStream (std::ostream &os, Int_t contents, StyleOption style, TString indent="""") const;  Print description of object on ostream, printing contents set by contents integer, which is interpreted as an OR of 'enum ContentsOptions' values and in the style given by 'enum StyleOption'. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the numb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCFunction1Binding.html:45370,clear,clearEvalErrorLog,45370,doc/master/classRooCFunction1Binding.html,https://root.cern,https://root.cern/doc/master/classRooCFunction1Binding.html,42,['clear'],['clearEvalErrorLog']
Usability,"ects () const;  Return list of all generic objects in the workspace. ;  ; RooArgSet allPdfs () const;  Return set with all probability density function objects. ;  ; RooArgSet allResolutionModels () const;  Return set with all resolution model objects. ;  ; RooArgSet allVars () const;  Return set with all variable objects. ;  ; RooAbsArg * arg (RooStringView name) const;  Return RooAbsArg with given name. A null pointer is returned if none is found. ;  ; RooArgSet argSet (RooStringView nameList) const;  Return set of RooAbsArgs matching to given list of names. ;  ; bool cancelTransaction ();  Cancel an ongoing import transaction. ;  ; RooCategory * cat (RooStringView name) const;  Retrieve discrete variable (RooCategory) with given name. A null pointer is returned if not found. ;  ; RooAbsCategory * catfunc (RooStringView name) const;  Retrieve discrete function (RooAbsCategory) with given name. A null pointer is returned if not found. ;  ; bool cd (const char *path=nullptr);  ; void clearStudies ();  Remove all RooStudyManager modules. ;  ; TObject * Clone (const char *newname="""") const override;  TObject::Clone() needs to be overridden. ;  ; bool commitTransaction ();  ; const RooArgSet & components () const;  ; RooAbsData * data (RooStringView name) const;  Retrieve dataset (binned or unbinned) with given name. A null pointer is returned if not found. ;  ; bool defineSet (const char *name, const char *contentList);  Define a named set in the workspace through a comma separated list of names of objects already in the workspace. ;  ; bool defineSet (const char *name, const RooArgSet &aset, bool importMissing=false);  Define a named RooArgSet with given constituents. ;  ; RooAbsData * embeddedData (RooStringView name) const;  Retrieve dataset (binned or unbinned) with given name. A null pointer is returned if not found. ;  ; RooExpensiveObjectCache & expensiveObjectCache ();  ; bool extendSet (const char *name, const char *newContents);  Define a named set in the wor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooWorkspace.html:4134,clear,clearStudies,4134,doc/master/classRooWorkspace.html,https://root.cern,https://root.cern/doc/master/classRooWorkspace.html,1,['clear'],['clearStudies']
Usability,"ects a new; 51# implementation for `__str__`, the mechanism that Python provides to define; 52# how to represent objects as strings. This new implementation; 53# always returns the string ""This is a MyClass object"".; 54@pythonization('MyClass'); 55def pythonizor_of_myclass(klass):; 56 klass.__str__ = lambda o : 'This is a MyClass object'; 57 ; 58# Once we have defined our pythonizor function, let's see it in action.; 59# We will now use the `MyClass` class for the first time from Python: we will; 60# create a new instance of that class. At this moment, the pythonizor will; 61# execute and modify the class - pythonizors are always lazily run when a given; 62# class is used for the first time from a Python script.; 63my_object = ROOT.MyClass(); 64 ; 65# Since the pythonizor already executed, we should now see the new behaviour.; 66# For that purpose, let's print `my_object` (should show ""This is a MyClass; 67# object"").; 68print(my_object); 69 ; 70# The previous example is just a simple one, but there are many ways in which a; 71# class can be pythonized. Typical examples are the redefinition of dunder; 72# methods (e.g. `__iter__` and `__next__` to make your objects iterable from; 73# Python). If you need some inspiration, many ROOT classes are pythonized in; 74# the way we just saw; their pythonizations can be seen at:; 75# https://github.com/root-project/root/tree/master/bindings/pyroot/pythonizations/python/ROOT/pythonization; 76 ; 77# The @pythonization decorator offers a few more options when it comes to; 78# matching classes that you want to pythonize. We saw that we can match a; 79# single class, but we can also specify a list of classes to pythonize.; 80#; 81# The following code defines a couple of new classes:; 82ROOT.gInterpreter.Declare('''; 83namespace NS {; 84 class Class1 {};; 85 class Class2 {};; 86}; 87'''); 88 ; 89# Note that these classes belong to the `NS` namespace. As mentioned above, the; 90# @pythonization decorator accepts a parameter with the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/pyroot002__pythonizationDecorator_8py_source.html:3495,simpl,simple,3495,doc/master/pyroot002__pythonizationDecorator_8py_source.html,https://root.cern,https://root.cern/doc/master/pyroot002__pythonizationDecorator_8py_source.html,1,['simpl'],['simple']
Usability,"ects of the corresponding type stored in the geometry. This can be done by clicking the button next to the blue label Select <object>. The dialog interfaces are generally different for different types of objects. The volume selection dialog offers the possibility to select either a volume already connected to the geometry hierarchy or non-connected ones. Selection for shapes and matrices is split into categories represented by top-level list tree items for: boxes, tubes, translations, rotations, etc. Selection dialogs for different TGeo objects. Once a selection is made and the dialog is closed, the selected item name will appear in the corresponding label and the button Edit will start the object editor in a transient frame. Closing these transient frames will not delete, but just hide existing opened editors for later reuse. Their lifetime is determined by the canvas to which the manager editor is attached to, since these will be destroyed together.; ; For most editors, the functionalities Apply and Undo are provided.; For shapes, changing any of the shape parameters will activate the “Apply” button only if the check button “Delayed draw” is checked, otherwise the changes are immediately applied. Once the apply button is pressed, the changes are applied to the edited shape and drawn. The “Undo” button becomes active after the first modification has been applied. It allows restoring the initial parameters of the shape.; NOTE: In this version the “Undo” does not allow restoring an intermediate state of the parameters that was applied - it will always restore the parameters at the moment the shape was edited.; All material properties changes are undoable. The mixture editor currently allows adding elements one by one in the mixture composition. This can be done either by element weight fraction or by number of atoms. Once an element was added using one method the other method is not selectable anymore. Summing component fractions up to 1 in the final mixture is the u",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1036244,Undo,Undo,1036244,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Undo'],['Undo']
Usability,"ects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. TCollectionMethodBrowsable(const TCollectionMethodBrowsable&); virtual~TCollectionMethodBrowsable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TCollectionMethodBrowsable.html:1433,simpl,simple,1433,root/html526/TCollectionMethodBrowsable.html,https://root.cern,https://root.cern/root/html526/TCollectionMethodBrowsable.html,7,['simpl'],['simple']
Usability,"ects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. TCollectionPropertyBrowsable(const TCollectionPropertyBrowsable&); virtual~TCollectionPropertyBrowsable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TCollectionPropertyBrowsable.html:1446,simpl,simple,1446,root/html526/TCollectionPropertyBrowsable.html,https://root.cern,https://root.cern/root/html526/TCollectionPropertyBrowsable.html,7,['simpl'],['simple']
Usability,"ects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. TMethodBrowsable(const TMethodBrowsable&); virtual~TMethodBrowsable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTVirtualBranchBrowsable::Brow",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMethodBrowsable.html:1410,simpl,simple,1410,root/html528/TMethodBrowsable.html,https://root.cern,https://root.cern/root/html528/TMethodBrowsable.html,6,['simpl'],['simple']
Usability,"ects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. TNonSplitBrowsable(const TNonSplitBrowsable&); virtual~TNonSplitBrowsable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTVirtualBranchBrowsable",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TNonSplitBrowsable.html:1416,simpl,simple,1416,root/html528/TNonSplitBrowsable.html,https://root.cern,https://root.cern/root/html528/TNonSplitBrowsable.html,6,['simpl'],['simple']
Usability,"ects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. TVirtualBranchBrowsable(const TVirtualBranchBrowsable&); virtual~TVirtualBranchBrowsable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualBranchBrowsable.html:1414,simpl,simple,1414,root/html528/TVirtualBranchBrowsable.html,https://root.cern,https://root.cern/root/html528/TVirtualBranchBrowsable.html,6,['simpl'],['simple']
Usability,"ects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. virtual~TCollectionMethodBrowsable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTVirtualBranchBrowsable::Browse(TBrowser* b); static TClass*Cl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TCollectionMethodBrowsable.html:1433,simpl,simple,1433,root/html602/TCollectionMethodBrowsable.html,https://root.cern,https://root.cern/root/html602/TCollectionMethodBrowsable.html,4,['simpl'],['simple']
Usability,"ects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. virtual~TCollectionPropertyBrowsable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TCollectionPropertyBrowsable.html:1446,simpl,simple,1446,root/html602/TCollectionPropertyBrowsable.html,https://root.cern,https://root.cern/root/html602/TCollectionPropertyBrowsable.html,4,['simpl'],['simple']
Usability,"ects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. virtual~TMethodBrowsable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTVirtualBranchBrowsable::Browse(TBrowser* b); static TClass*Class(); vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMethodBrowsable.html:1410,simpl,simple,1410,root/html602/TMethodBrowsable.html,https://root.cern,https://root.cern/root/html602/TMethodBrowsable.html,4,['simpl'],['simple']
Usability,"ects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. virtual~TNonSplitBrowsable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTVirtualBranchBrowsable::Browse(TBrowser* b); static TClass*Class(); v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TNonSplitBrowsable.html:1416,simpl,simple,1416,root/html602/TNonSplitBrowsable.html,https://root.cern,https://root.cern/root/html602/TNonSplitBrowsable.html,4,['simpl'],['simple']
Usability,"ects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. virtual~TVirtualBranchBrowsable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualBranchBrowsable.html:1438,simpl,simple,1438,root/html602/TVirtualBranchBrowsable.html,https://root.cern,https://root.cern/root/html602/TVirtualBranchBrowsable.html,4,['simpl'],['simple']
Usability,"ecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidGetBackground(TH1* bgr, const char* bgrSource = 0, const Int_t* binMap = 0, Int_t includeError = 3, Bool_t clearHist = kTRUE) const; voidTUnfold::GetBias(TH1* bias, const Int_t* binMap = 0) const; Double_tTUnfold::GetChi2A() const; Double_tTUnfold::GetChi2L() const; Double_tGetChi2Sys(); Bool_tGetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0); Bool_tGetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); Bool_tGetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTUnfold::GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; voidGetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysBackgroundUncorr(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); Double_tTUnfold::GetEpsMatrix() const; voidTUnfold::GetFoldedOutput(TH1* folded, const Int_t* binMap = 0) const; virtual const char*TObject::GetIconName() const; voidTUnfold::GetInput(TH1* inputData, const Int_t* binMap = 0) const; voidTUnfold::GetInputInverseEmatrix(TH2* ematrix); voidTUnfold::GetL(TH2* l) const; virtual Double_tTUnfold::GetLcurveX() const; virtual Double_tTUnfold::GetLcurveY() ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnfoldSys.html:5928,clear,clearEmat,5928,root/html534/TUnfoldSys.html,https://root.cern,https://root.cern/root/html534/TUnfoldSys.html,6,['clear'],['clearEmat']
Usability,"ed . Add widget catched from external scripts. ; Definition at line 573 of file RBrowser.cxx. ◆ AddInitWidget(). void RBrowser::AddInitWidget ; (; const std::string & ; kind). protected . Create new widget and send init message to the client. ; Definition at line 592 of file RBrowser.cxx. ◆ AddRCanvas(). void ROOT::RBrowser::AddRCanvas ; (; ). inline . Definition at line 86 of file RBrowser.hxx. ◆ AddTCanvas(). void ROOT::RBrowser::AddTCanvas ; (; ). inline . Definition at line 85 of file RBrowser.hxx. ◆ AddWidget(). std::shared_ptr< RBrowserWidget > RBrowser::AddWidget ; (; const std::string & ; kind). protected . Creates new widget. ; Definition at line 541 of file RBrowser.cxx. ◆ CheckWidgtesModified(). void RBrowser::CheckWidgtesModified ; (; ). protected . Check if any widget was modified and update if necessary. ; Definition at line 752 of file RBrowser.cxx. ◆ ClearOnClose(). void RBrowser::ClearOnClose ; (; const std::shared_ptr< void > & ; handle). Set handle which will be cleared when connection is closed. ; Definition at line 975 of file RBrowser.cxx. ◆ CloseTab(). void RBrowser::CloseTab ; (; const std::string & ; name). protected . Close and delete specified widget. ; Definition at line 618 of file RBrowser.cxx. ◆ FindWidget(). std::shared_ptr< RBrowserWidget > RBrowser::FindWidget ; (; const std::string & ; name, . const std::string & ; kind = """" . ); const. protected . Find widget by name or kind. ; Definition at line 602 of file RBrowser.cxx. ◆ GetActiveWidget(). std::shared_ptr< RBrowserWidget > ROOT::RBrowser::GetActiveWidget ; (; ); const. inlineprotected . Definition at line 54 of file RBrowser.hxx. ◆ GetCatchWindowShow(). bool ROOT::RBrowser::GetCatchWindowShow ; (; ); const. inline . Is RWebWindow::Show calls catched for embeding of created widgets. ; Definition at line 102 of file RBrowser.hxx. ◆ GetCurrentWorkingDirectory(). std::string RBrowser::GetCurrentWorkingDirectory ; (; ). protected . Return the current directory of ROOT. ; Definition ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RBrowser.html:6445,clear,cleared,6445,doc/v632/classROOT_1_1RBrowser.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RBrowser.html,1,['clear'],['cleared']
Usability,"ed by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fBtnAbortabort process button; TGTextButton*fBtnFinalizefinalize query button; TGTextButton*fBtnRetrieveretrieve query button; TGTextButton*fBtnSavesave query button; TGTextButton*fBtnShowLogshow log button; TGTextButton*fBtnStopstop process button; TGTextButton*fBtnSubmitsubmit query button; TQueryDescription*fDescquery description; TRootEmbeddedCanvas*fECanvasnode statistics embeded canvas; Long64_tfEntriesnumber of events/entries to process; TGCompositeFrame*fFA; TGCompositeFrame*fFB; TGCompositeFrame*fFCthree tabs element; TEditQueryFrame*fFDfourth tab element (edit query frame); Int_tfFilesnumber of files processed; Long64_tfFirstfirst event/entry to process; TGTextView*fInfoTextViewsummary on current query; TGLabel*fLabInfosinfos on current process; TGLabel*fLabStatusactual process status; Bool_tfModifiedkTRUE if settings have changed; Long64_tfPrevProcessedused for progress bar; Long64_tfPrevTotalused for progress bar; TGLabel*fRaterate of process in events/sec; TCanvas*fStatsCanvasnode statistics canvas; TSessionQueryFrame::EQueryStatusfStatusstatus of actual query; TGTab*fTabmain tab frame; TGLabel*fTotaltotal progress info; TSessionViewer*fViewerpointer on main viewer; TGHProgressBar*frmProgcurrent process progress bar. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionQueryFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionQueryFrame(); Destructor. void Build(TSessionViewer* gui); Build query information frame. void Modified(Bool_t mod = kTRUE); Notify changes in query editor settings. void Feedback(TList* objs); Feedb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSessionQueryFrame.html:20543,progress bar,progress bar,20543,root/html534/TSessionQueryFrame.html,https://root.cern,https://root.cern/root/html534/TSessionQueryFrame.html,6,['progress bar'],['progress bar']
Usability,"ed by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fBtnAbortabort process button; TGTextButton*fBtnFinalizefinalize query button; TGTextButton*fBtnRetrieveretrieve query button; TGTextButton*fBtnSavesave query button; TGTextButton*fBtnShowLogshow log button; TGTextButton*fBtnStopstop process button; TGTextButton*fBtnSubmitsubmit query button; TQueryDescription*fDescquery description; TRootEmbeddedCanvas*fECanvasnode statistics embeded canvas; Long64_tfEntriesnumber of events/entries to process; TGCompositeFrame*fFA; TGCompositeFrame*fFB; TGCompositeFrame*fFCthree tabs element; TEditQueryFrame*fFDfourth tab element (edit query frame); Int_tfFilesnumber of files processed; Long64_tfFirstfirst event/entry to process; TGTextView*fInfoTextViewsummary on current query; TGLabel*fLabInfosinfos on current process; TGLabel*fLabStatusactual process status; Bool_tfModifiedkTRUE if settings have changed; Long64_tfPrevProcessedused for progress bar; Long64_tfPrevTotalused for progress bar; TGLabel*fRaterate of process in events/sec; TCanvas*fStatsCanvasnode statistics canvas; TSessionQueryFrame::EQueryStatusfStatusstatus of actual query; TGTab*fTabmain tab frame; TGLabel*fTotaltotal progress info; TSessionViewer*fViewerpointer on main viewer; TGHProgressBar*frmProgcurrent process progress bar. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionQueryFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionQueryFrame(); Destructor. void Build(TSessionViewer* gui); Build query informations frame. void Modified(Bool_t mod = kTRUE); Notify changes in query editor settings. void Feedback(TList* objs); Feed",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSessionQueryFrame.html:20249,progress bar,progress bar,20249,root/html528/TSessionQueryFrame.html,https://root.cern,https://root.cern/root/html528/TSessionQueryFrame.html,12,['progress bar'],['progress bar']
Usability,"ed columns. ; Implemented in ROOT::Experimental::Internal::RPageNullSink, ROOT::Experimental::Internal::RPageSinkBuf, and ROOT::Experimental::Internal::RPagePersistentSink. Member Data Documentation. ◆ fCompressor. std::unique_ptr<RNTupleCompressor> ROOT::Experimental::Internal::RPageSink::fCompressor. protected . Helper to zip pages and header/footer; includes a 16MB (kMAXZIPBUF) zip buffer. ; There could be concrete page sinks that don't need a compressor. Therefore, and in order to stay consistent with the page source, we leave it up to the derived class whether or not the compressor gets constructed. ; Definition at line 280 of file RPageStorage.hxx. ◆ fIsInitialized. bool ROOT::Experimental::Internal::RPageSink::fIsInitialized = false. private . Flag if sink was initialized. ; Definition at line 291 of file RPageStorage.hxx. ◆ fOnDatasetCommitCallbacks. std::vector<Callback_t> ROOT::Experimental::Internal::RPageSink::fOnDatasetCommitCallbacks. private . Definition at line 292 of file RPageStorage.hxx. ◆ fOptions. std::unique_ptr<RNTupleWriteOptions> ROOT::Experimental::Internal::RPageSink::fOptions. protected . Definition at line 275 of file RPageStorage.hxx. ◆ fSealPageBuffer. std::vector<unsigned char> ROOT::Experimental::Internal::RPageSink::fSealPageBuffer. private . Used as destination buffer in the simple SealPage overload. ; Definition at line 293 of file RPageStorage.hxx. ◆ fWritePageMemoryManager. RWritePageMemoryManager ROOT::Experimental::Internal::RPageSink::fWritePageMemoryManager. private . Used in ReservePage to maintain the page buffer budget. ; Definition at line 296 of file RPageStorage.hxx. Libraries for ROOT::Experimental::Internal::RPageSink:. [legend]; The documentation for this class was generated from the following files:; tree/ntuple/v7/inc/ROOT/RPageStorage.hxx; tree/ntuple/v7/src/RPageStorage.cxx. ROOTExperimentalInternalRPageSink. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:14 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSink.html:18828,simpl,simple,18828,doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSink.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSink.html,1,['simpl'],['simple']
Usability,"ed explicitly, a diagonal covariance will be built given the errors of bdat). The corresponding spectrum in the Monte Carlo is given by bini, with the true underlying spectrum given by xini. The detector response is described by Adet, with Adet filled with events (not probabilities) with the true observable on the y-axis and the reconstructed observable on the x-axis.; ; The measured distribution can be unfolded for any combination of resolution, efficiency and acceptance effects, provided an appropriate definition of xini and Adet. The unfolding can be performed by; . TSVDUnfold *tsvdunf = new TSVDUnfold( bdat, Bcov, bini, xini, Adet );; TH1D* unfresult = tsvdunf->Unfold( kreg );; . where kreg determines the regularisation of the unfolding. In general, overregularisation (too small kreg) will bias the unfolded spectrum towards the Monte Carlo input, while underregularisation (too large kreg) will lead to large fluctuations in the unfolded spectrum. The optimal regularisation can be determined following guidelines in Nucl. Instrum. Meth. A372, 469 (1996) [hep-ph/9509307] using the distribution of the |d_i|<\tt> that can be obtained by tsvdunf->GetD() and/or using pseudo-experiments.; ; Covariance matrices on the measured spectrum (for either the total uncertainties or individual sources of uncertainties) can be propagated to covariance matrices using the GetUnfoldCovMatrix method, which uses pseudo experiments for the propagation. In addition, GetAdetCovMatrix allows for the propagation of the statistical uncertainties on the response matrix using pseudo experiments. The covariance matrix corresponding to Bcov is also computed as described in Nucl. Instrum. Meth. A372, 469 (1996) [hep-ph/9509307] and can be obtained from tsvdunf->GetXtau() and its (regularisation independent) inverse from tsvdunf->GetXinv(). The distribution of singular values can be retrieved using tsvdunf->GetSV().; ; See also the tutorial for a toy example.; ; . Function Members (Methods); public:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSVDUnfold.html:2084,guid,guidelines,2084,root/html534/TSVDUnfold.html,https://root.cern,https://root.cern/root/html534/TSVDUnfold.html,6,['guid'],['guidelines']
Usability,"ed for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrapEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for para editor. ~TGeoTrapEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current settings. void DoModified(); Slot for notifying modifications. void DoUndo(); Slot for undoing last operation. void DoH1(); Slot for H1. void DoBl1(); Slot for Bl1. void DoTl1(); Slot for Tl1. void DoDz(); Slot for Z. void DoSc1(); Slot for H2. void DoSc2(); Slot for H2. void DoAlpha1(); Slot for alpha1. void DoTheta(); Slot for theta. void DoPhi(); Slot for phi. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTrapEditor.html:21991,undo,undoing,21991,root/html534/TGeoTrapEditor.html,https://root.cern,https://root.cern/root/html534/TGeoTrapEditor.html,2,['undo'],['undoing']
Usability,"ed int ipar = 0; ipar < npar; ++ipar) {; 161 const ParameterSettings & par = fconfig.ParSettings(ipar);; 162 if (par.IsFixed() ) fFixedParams[ipar] = true;; 163 else nfree++;; 164 if (par.IsBound() ) {; 165 double lower = (par.HasLowerLimit()) ? par.LowerLimit() : - std::numeric_limits<double>::infinity() ;; 166 double upper = (par.HasUpperLimit()) ? par.UpperLimit() : std::numeric_limits<double>::infinity() ;; 167 fBoundParams[ipar] = fParamBounds.size();; 168 fParamBounds.push_back(std::make_pair(lower,upper));; 169 }; 170 }; 171 // check if nfree (from FitConfig) and fNFree (from minimizer) are consistent; 172 if (nfree != fNFree ) {; 173 MATH_ERROR_MSG(""FitResult"",""FitConfiguration and Minimizer result are not consistent"");; 174 std::cout << ""Number of free parameters from FitConfig = "" << nfree << std::endl;; 175 std::cout << ""Number of free parameters from Minimizer = "" << fNFree << std::endl;; 176 }; 177 ; 178 // if flag is binned compute a chi2 when a chi2 function is given; 179 if (fitType == 1) {; 180 if (chi2func == nullptr); 181 fChi2 = fVal;; 182 else {; 183 // compute chi2 equivalent for likelihood fits; 184 // NB: empty bins are considered; 185 fChi2 = (*chi2func)(&fParams[0]);; 186 }; 187 }; 188 else if (fitType == 3) {; 189 // case of binned likelihood fits (use Baker-Cousins chi2); 190 fChi2 = 2 * fVal;; 191 }; 192 ; 193 // fill error matrix; 194 // if minimizer provides error provides also error matrix; 195 // clear in case of re-filling an existing result; 196 if (!fCovMatrix.empty()) fCovMatrix.clear();; 197 if (!fGlobalCC.empty()) fGlobalCC.clear();; 198 ; 199 if (min->Errors() != nullptr) {; 200 ; 201 fErrors = std::vector<double>(min->Errors(), min->Errors() + npar ) ;; 202 ; 203 if (fCovStatus != 0) {; 204 unsigned int r = npar * ( npar + 1 )/2;; 205 fCovMatrix.reserve(r);; 206 for (unsigned int i = 0; i < npar; ++i); 207 for (unsigned int j = 0; j <= i; ++j); 208 fCovMatrix.push_back(min->CovMatrix(i,j) );; 209 }; 210 // minos errors are se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/FitResult_8cxx_source.html:6788,clear,clear,6788,doc/master/FitResult_8cxx_source.html,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html,1,['clear'],['clear']
Usability,"ed is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; they are going to use.; For the moment it's just a call to FillBuffer() since that method; will cr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeCache.html:25857,learn,learning,25857,root/html602/TTreeCache.html,https://root.cern,https://root.cern/root/html602/TTreeCache.html,2,['learn'],['learning']
Usability,"ed object. RooPlot* GetPosteriorPlot(bool norm = false, double precision = 0.01) const; return a RooPlot with the posterior and the credibility region; NOTE: User takes ownership of the returned object. void SetIntegrationType(const char* type); set the integration type (possible type are) :; 1D integration ( used when only one nuisance and when the posterior is scanned):; adaptive , gauss, nonadaptive; multidim:; ADAPTIVE, adaptive numerical integration; The parameter numIters (settable with SetNumIters) is the max number of function calls.; It can be reduced to make teh integration faster but it will be difficult to reach the required tolerance; VEGAS MC integration method based on importance sampling - numIters is number of function calls; Extra Vegas parameter can be set using IntegratorMultiDimOptions class; MISER MC integration method based on stratified sampling; See also http://en.wikipedia.org/wiki/Monte_Carlo_integration for VEGAS and MISER description; PLAIN simple MC integration method, where the max number of calls can be specified using SetNumIters(numIters). Extra integration types are:. TOYMC:; evaluate posterior by generating toy MC for the nuisance parameters. It is a MC; integration, where the function is sampled according to the nuisance. It is convenient to use when all; the nuisance are uncorrelated and it is efficient to generate them; The toy are generated by default for each poi values; (this method has been proposed and provided by J.P Chou); 1-TOYMC : same method as before but in this case the toys are generated only one time and then used for; each poi value. It can be convenient when the generation time is much larger than the evaluation time,; otherwise it is recoomended to re-generate the toy for each poi scanned point of the posterior function. ROOFIT:; use roofit default integration methods which will produce a nested integral (not reccomended for more; than 1 nuisance parameters). if type = 0 use default specified via class Integrato",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__BayesianCalculator.html:13030,simpl,simple,13030,root/html530/RooStats__BayesianCalculator.html,https://root.cern,https://root.cern/root/html530/RooStats__BayesianCalculator.html,9,['simpl'],['simple']
Usability,"ed parameter from TDatime object. Bool_t SetDatime(Int_t , const TDatime& ); set date & time value for specified parameter from TDatime object. Bool_t SetTimestamp(Int_t , const TDatime& ); set timestamp value for specified parameter from TDatime object. TDatime GetDatime(Int_t ); return value of parameter in form of TDatime; Be aware, that TDatime does not allow dates before 1995-01-01. Int_t GetYear(Int_t ); return year value for parameter (if applicable). Int_t GetMonth(Int_t ); return month value for parameter (if applicable). Int_t GetDay(Int_t ); return day value for parameter (if applicable). Int_t GetHour(Int_t ); return hours value for parameter (if applicable). Int_t GetMinute(Int_t ); return minutes value for parameter (if applicable). Int_t GetSecond(Int_t ); return seconds value for parameter (if applicable). TDatime GetTimestamp(Int_t ); return value of parameter in form of TDatime; Be aware, that TDatime does not allow dates before 1995-01-01. TSQLStatement(Bool_t errout = kTRUE); { ClearError(); }. virtual ~TSQLStatement(); {}. Int_t GetBufferLength() const. Int_t GetNumParameters(). Bool_t NextIteration(). Bool_t SetNull(Int_t ); { return kFALSE; }. Bool_t SetInt(Int_t , Int_t ); { return kFALSE; }. Bool_t SetUInt(Int_t , UInt_t ); { return kFALSE; }. Bool_t SetLong(Int_t , Long_t ); { return kFALSE; }. Bool_t SetLong64(Int_t , Long64_t ); { return kFALSE; }. Bool_t SetULong64(Int_t , ULong64_t ); { return kFALSE; }. Bool_t SetDouble(Int_t , Double_t ); { return kFALSE; }. Bool_t SetString(Int_t , const char* , Int_t = 256); { return kFALSE; }. Bool_t SetDate(Int_t , Int_t , Int_t , Int_t ); { return kFALSE; }. Bool_t SetTime(Int_t , Int_t , Int_t , Int_t ); { return kFALSE; }. Bool_t SetDatime(Int_t , Int_t , Int_t , Int_t , Int_t , Int_t , Int_t ); { return kFALSE; }. Bool_t SetTimestamp(Int_t , Int_t , Int_t , Int_t , Int_t , Int_t , Int_t , Int_t = 0); { return kFALSE; }. void SetTimeFormating(const char* ); {}. Bool_t SetBinary(Int_t , void* , L",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSQLStatement.html:20881,Clear,ClearError,20881,root/html602/TSQLStatement.html,https://root.cern,https://root.cern/root/html602/TSQLStatement.html,2,['Clear'],['ClearError']
Usability,"ed to _any_ kind of plot (components, asymmetries, efficiencies; // etc..); model.plotOn(frame, VisualizeError(*r, 1), FillColor(kOrange), Components(""bkg""));; model.plotOn(frame, VisualizeError(*r, 1, false), DrawOption(""L""), LineWidth(2), LineColor(kRed), Components(""bkg""),; LineStyle(kDashed));; ; // Overlay central value; model.plotOn(frame);; model.plotOn(frame, Components(""bkg""), LineStyle(kDashed));; d->plotOn(frame);; frame->SetMinimum(0);; ; // V i s u a l i z e p a r t i a l f i t e r r o r; // ------------------------------------------------------; ; // Make plot frame; RooPlot *frame2 = x.frame(Bins(40), Title(""Visualization of 2-sigma partial error from (m,m2)""));; ; // Visualize partial error. For partial error visualization the covariance matrix is first reduced as follows; // ___ -1; // Vred = V22 = V11 - V12 * V22 * V21; //; // Where V11,V12,V21,V22 represent a block decomposition of the covariance matrix into observables that; // are propagated (labeled by index '1') and that are not propagated (labeled by index '2'), and V22bar; // is the Shur complement of V22, calculated as shown above; //; // (Note that Vred is _not_ a simple sub-matrix of V); ; // Propagate partial error due to shape parameters (m,m2) using linear and sampling method; model.plotOn(frame2, VisualizeError(*r, RooArgSet(m, m2), 2), FillColor(kCyan));; model.plotOn(frame2, Components(""bkg""), VisualizeError(*r, RooArgSet(m, m2), 2), FillColor(kCyan));; ; model.plotOn(frame2);; model.plotOn(frame2, Components(""bkg""), LineStyle(kDashed));; frame2->SetMinimum(0);; ; // Make plot frame; RooPlot *frame3 = x.frame(Bins(40), Title(""Visualization of 2-sigma partial error from (s,s2)""));; ; // Propagate partial error due to yield parameter using linear and sampling method; model.plotOn(frame3, VisualizeError(*r, RooArgSet(s, s2), 2), FillColor(kGreen));; model.plotOn(frame3, Components(""bkg""), VisualizeError(*r, RooArgSet(s, s2), 2), FillColor(kGreen));; ; model.plotOn(frame3);; model.plotO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf610__visualerror_8C.html:4519,simpl,simple,4519,doc/master/rf610__visualerror_8C.html,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8C.html,1,['simpl'],['simple']
Usability,"ed to suggest the type of action that; 104one can do on this object. Clicking with the right mouse button on an object; 105pops-up a contextmenu with a complete list of actions possible on this object.; 106 ; 107A graphical editor may be started from the canvas ""View"" menu under the menu; 108entry ""Toolbar"".; 109 ; 110An interactive HELP is available by clicking on the HELP button at the top right; 111of the canvas. It gives a short explanation about the canvas' menus.; 112 ; 113A canvas may be automatically divided into pads via `TPad::Divide`.; 114 ; 115At creation time, no matter if in interactive or batch mode, the constructor; 116defines the size of the canvas window (including the size of the window; 117manager's decoration). To define precisely the graphics area size of a canvas in; 118the interactive mode, the following four lines of code should be used:; 119~~~ {.cpp}; 120 {; 121 Double_t w = 600;; 122 Double_t h = 600;; 123 auto c = new TCanvas(""c"", ""c"", w, h);; 124 c->SetWindowSize(w + (w - c->GetWw()), h + (h - c->GetWh()));; 125 }; 126~~~; 127and in the batch mode simply do:; 128~~~ {.cpp}; 129 c->SetCanvasSize(w,h);; 130~~~; 131 ; 132If the canvas size exceeds the window size, scroll bars will be added to the canvas; 133This allows to display very large canvases (even bigger than the screen size). The; 134Following example shows how to proceed.; 135~~~ {.cpp}; 136 {; 137 auto c = new TCanvas(""c"",""c"");; 138 c->SetCanvasSize(1500, 1500);; 139 c->SetWindowSize(500, 500);; 140 }; 141~~~; 142*/; 143 ; 144////////////////////////////////////////////////////////////////////////////////; 145/// Canvas default constructor.; 146 ; 147TCanvas::TCanvas(Bool_t build) : TPad(), fDoubleBuffer(0); 148{; 149 fPainter = nullptr;; 150 fWindowTopX = 0;; 151 fWindowTopY = 0;; 152 fWindowWidth = 0;; 153 fWindowHeight = 0;; 154 fCw = 0;; 155 fCh = 0;; 156 fXsizeUser = 0;; 157 fYsizeUser = 0;; 158 fXsizeReal = kDefaultCanvasSize;; 159 fYsizeReal = kDefaultCanvasSize;; 160 fHi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCanvas_8cxx_source.html:4135,simpl,simply,4135,doc/master/TCanvas_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html,1,['simpl'],['simply']
Usability,"ed to the integrand of which the integral is requested. ;  ; bool getFloor () const;  ; TClass * IsA () const override;  ; bool isBinnedDistribution (const RooArgSet &obs) const override;  Tests if the distribution is binned. Unless overridden by derived classes, this always returns false. ;  ; std::list< double > * plotSamplingHint (RooAbsRealLValue &, double, double) const override;  Interface for returning an optional hint for initial sampling points when constructing a curve projected on observable obs. ;  ; void printMetaArgs (std::ostream &os) const override;  Customized printing of arguments of a RooRealSumFunc to more intuitively reflect the contents of the product operator construction. ;  ; void setCacheAndTrackHints (RooArgSet &) override;  ; void setFloor (bool flag);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void translate (RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ;  Public Member Functions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooAbsReal () override;  Destructor. ;  ; virtual double analyticalIntegral (Int_t code, const char *rangeName=nullptr) const;  Implements the actual analytical integral(s) advertised by getAnalyticalIntegral. ;  ; TF1 * asTF (const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) const;  Return a ROOT TF1,2,3 object bound to this RooAbsReal with give",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooRealSumFunc.html:3204,simpl,simple,3204,doc/v632/classRooRealSumFunc.html,https://root.cern,https://root.cern/doc/v632/classRooRealSumFunc.html,2,['simpl'],['simple']
Usability,"ed when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - TTree automatically creates a cache. This feature can be; controlled with an env. variable or the TTreeCache.Size option.; - TTree::SetCacheSize is called with a non-zero size and a cache; did not previously exist; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of Trees with several; hundred or thousand branches.; When writing, this does not generate a performance problem because branch; buffers are always written sequentially and the OS is in general clever enough; to flush the data to the output file when a few MBytes of data have to be written.; When reading at the contrary, one may hit a performance problem when reading; across a network (LAN or WAN) and the network latency is high.; For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each; with no cache will imply 10s penalty where a local ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeCache.html:2001,learn,learning,2001,root/html604/TTreeCache.html,https://root.cern,https://root.cern/root/html604/TTreeCache.html,4,['learn'],['learning']
Usability,"ed() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidBrowseObj(TObject* obj); TBrowser*TBrowserImp::Browser() const; virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); voidChdir(TGListTreeItem* item); voidChecked(TObject* obj, Bool_t check); Bool_tCheckFiltered(TGListTreeItem* item, Bool_t but = kFALSE); virtual voidTBrowserImp::CheckObjectItem(TObject*, Bool_t = kFALSE); voidCheckRemote(TGListTreeItem* item); Bool_tCheckSorted(TGListTreeItem* item, Bool_t but = kFALSE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); voidClicked(TGListTreeItem* item, Int_t btn, Int_t x, Int_t y); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTBrowserImp::CloseTabs(); virtual voidTGMainFrame::CloseWindow()SIGNAL ; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()SIGNAL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGFileBrowser.html:2264,Clear,Clear,2264,root/html532/TGFileBrowser.html,https://root.cern,https://root.cern/root/html532/TGFileBrowser.html,4,['Clear'],['Clear']
Usability,"ed(); Bool_tTQObject::AreSignalsBlocked() const; Float_t*TAttBBox::AssertBBox(); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); Float_tCalculateLineLength() const; virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTPointSet3D::ClearIds(); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEvePointSet*TEvePointSet::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEvePointSet::ClonePoints(const TEvePointSet& e); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTPointSet3D::ComputeBBox(); Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveLine.html:2618,Clear,Clear,2618,root/html534/TEveLine.html,https://root.cern,https://root.cern/root/html534/TEveLine.html,3,['Clear'],['Clear']
Usability,"ed) return;; 6391 }; 6392 ; 6393 // Get Primitives; 6394 prims = gPad->GetListOfPrimitives();; 6395 n = TMath::Min(15,prims->GetSize());; 6396 Int_t lineColor = TColor::GetColor(239, 202, 0);; 6397 ; 6398 TAttBBox2D *cur = dynamic_cast<TAttBBox2D *>( object );; 6399 if (cur) {; 6400 //create invisible TPad above gPad; 6401 if (!tmpGuideLinePad){; 6402 tmpGuideLinePad = new TPad(""tmpGuideLinePad"", ""tmpGuideLinePad"", 0, 0, 1, 1);; 6403 Double_t x1, y1, x2, y2;; 6404 gPad->GetRange(x1, y1, x2, y2);; 6405 tmpGuideLinePad->Range(x1, y1, x2, y2);; 6406 tmpGuideLinePad->SetFillStyle(0);; 6407 tmpGuideLinePad->SetFillColor(0);; 6408 tmpGuideLinePad->Draw();; 6409 tmpGuideLinePad->cd();; 6410 gPad->GetRange(x1, y1, x2, y2);; 6411 }; 6412 if (cling && !log) threshold = 7;; 6413 else threshold = 1;; 6414 ; 6415 Rectangle_t BBox = cur->GetBBox();; 6416 TPoint center = cur->GetBBoxCenter();; 6417 ; 6418 otherDist.clear();; 6419 curDist.clear();; 6420 ; 6421 switch (event) {; 6422 ; 6423 case kButton1Down:; 6424 case kButton1Motion:; 6425 MX = gPad->GetX1() + 0.5 * (gPad->GetX2()-gPad->GetX1());; 6426 MY = gPad->GetY1() + 0.5 * (gPad->GetY2()-gPad->GetY1());; 6427 pMX = gPad->XtoPixel(MX);; 6428 pMY = gPad->YtoPixel(MY);; 6429 // Middlelines; 6430 if (TMath::Abs(pMX-center.GetX())<threshold) {; 6431 if (cling && (!resize)) {; 6432 cur->SetBBoxCenterX(pMX);; 6433 center = cur->GetBBoxCenter();; 6434 BBox = cur->GetBBox();; 6435 center = cur->GetBBoxCenter();; 6436 }; 6437 L = new TLine(MX, gPad->GetY1(), MX, gPad->GetY2());; 6438 L->SetBit(kCanDelete);; 6439 L->SetLineColor(lineColor);; 6440 L->Draw();; 6441 }; 6442 if (TMath::Abs(pMY-center.GetY())<threshold) {; 6443 if (cling && (!resize)) {; 6444 cur->SetBBoxCenterY(pMY);; 6445 center = cur->GetBBoxCenter();; 6446 BBox = cur->GetBBox();; 6447 center = cur->GetBBoxCenter();; 6448 }; 6449 L = new TLine(gPad->GetX1(), MY, gPad->GetX2(), MY);; 6450 L->SetBit(kCanDelete);; 6451 L->SetLineColor(lineColor);; 6452 L->Draw();; 6453 }; 64",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPad_8cxx_source.html:211468,clear,clear,211468,doc/master/TPad_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html,1,['clear'],['clear']
Usability,"ed). Since TGeoTube derives brom the base shape class, we can provide it to the volume; constructor :. TGeoVolume *wire_co = new TGeoVolume(""WIRE_CO"", tube, ptrCOPPER);. Do not bother to delete neither the media, shapes or volumes that you have; created since all will be automatically cleaned on exit by the manager class.; If we would have taken a look inside TGeoManager::MakeTube() method, we would; have been able to create our wire with a single line :. TGeoVolume *wire_co = gGeoManager->MakeTube(""WIRE_CO"", ptrCOPPER, 0, 0.01, 1);. The same applies for all primitive shapes, for which there can be found; corresponding MakeSHAPE() methods. Their usage is much more convenient unless; a shape has to be shared between more volumes. Let's make now an aluminium wire; having the same shape, supposing that we have created the copper wire with the; line above :. TGeoVolume *wire_al = new TGeoVolume(""WIRE_AL"", wire_co->GetShape(), ptrAL);. Now that we have learned how to create elementary volumes, let's see how we; can create a geometrical hierarchy. Positioning volumes. When creating a volume one does not specify if this will contain or not other; volumes. Adding daughters to a volume implies creating those and adding them; one by one to the list of daughters. Since the volume has to know the position; of all its daughters, we will have to supply at the same time a geometrical; transformation with respect to its local reference frame for each of them.; The objects referencing a volume and a transformation are called NODES and; their creation is fully handled by the modeler. They represent the link; elements in the hierarchy of volumes. Nodes are unique and distinct geometrical; objects ONLY from their container point of view. Since volumes can be replicated; in the geometry, the same node may be found on different branches. /*. */. An important observation is that volume objects are owned by the TGeoManager; class. This stores a list of all volumes in the geometry, that is c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoVolume.html:4346,learn,learned,4346,root/html528/TGeoVolume.html,https://root.cern,https://root.cern/root/html528/TGeoVolume.html,12,['learn'],['learned']
Usability,"ed). Since TGeoTube derives from the base shape class, we can provide it to the volume; constructor :. TGeoVolume *wire_co = new TGeoVolume(""WIRE_CO"", tube, ptrCOPPER);. Do not bother to delete neither the media, shapes or volumes that you have; created since all will be automatically cleaned on exit by the manager class.; If we would have taken a look inside TGeoManager::MakeTube() method, we would; have been able to create our wire with a single line :. TGeoVolume *wire_co = gGeoManager->MakeTube(""WIRE_CO"", ptrCOPPER, 0, 0.01, 1);. The same applies for all primitive shapes, for which there can be found; corresponding MakeSHAPE() methods. Their usage is much more convenient unless; a shape has to be shared between more volumes. Let's make now an aluminium wire; having the same shape, supposing that we have created the copper wire with the; line above :. TGeoVolume *wire_al = new TGeoVolume(""WIRE_AL"", wire_co->GetShape(), ptrAL);. Now that we have learned how to create elementary volumes, let's see how we; can create a geometrical hierarchy. Positioning volumes. When creating a volume one does not specify if this will contain or not other; volumes. Adding daughters to a volume implies creating those and adding them; one by one to the list of daughters. Since the volume has to know the position; of all its daughters, we will have to supply at the same time a geometrical; transformation with respect to its local reference frame for each of them.; The objects referencing a volume and a transformation are called NODES and; their creation is fully handled by the modeler. They represent the link; elements in the hierarchy of volumes. Nodes are unique and distinct geometrical; objects ONLY from their container point of view. Since volumes can be replicated; in the geometry, the same node may be found on different branches. /*. */. An important observation is that volume objects are owned by the TGeoManager; class. This stores a list of all volumes in the geometry, that is c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoVolume.html:4366,learn,learned,4366,root/html534/TGeoVolume.html,https://root.cern,https://root.cern/root/html534/TGeoVolume.html,18,['learn'],['learned']
Usability,"ed* set2RangeName = 0); Bool_tcontainsSet1(const RooArgSet* set1); Int_tentries() const; Int_tindex(const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0); voidinitialize(const RooNormSetCache& other); virtual TClass*IsA() const; const RooArgSet*lastSet1() const; const RooArgSet*lastSet2() const; const RooNameSet&nameSet1() const; const RooNameSet&nameSet2() const; RooNormSetCache&operator=(const RooNormSetCache&); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. ULong_t_max!; RooNameSet_name1!; RooNameSet_name2!; ULong_t_next!; map<pair<const RooArgSet*,const RooArgSet*>,unsigned long>_pairToIdx!; vector<pair<const RooArgSet*,const RooArgSet*> >_pairs!; TNamed*_set2RangeName!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNormSetCache(ULong_t max = 32). ~RooNormSetCache(); Destructor. void clear(); Clear contents. void add(const RooArgSet* set1, const RooArgSet* set2 = 0); Add given pair of RooArgSet pointers to our store. Bool_t autoCache(const RooAbsArg* self, const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0, Bool_t autoRefill = kTRUE); If RooArgSets set1 and set2 or sets with similar contents have; been seen by this cache manager before return kFALSE If not,; return kTRUE. If sets have not been seen and doRefill is true,; update cache reference to current input sets. RooNormSetCache(ULong_t max = 32). Int_t index(const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0); Match range name first. Bool_t contains(const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0); { return (index(set1,set2,set2RangeName) >= 0); }. Bool_t containsSet1(const RooArgSet* set1). const RooArgSet* lastSet1() const; { return _pairs.empty()?0:_pairs.back().first; }. const RooArgSet* lastSet2() const; { return _pairs.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNormSetCache.html:2474,clear,clear,2474,root/html534/RooNormSetCache.html,https://root.cern,https://root.cern/root/html534/RooNormSetCache.html,3,"['Clear', 'clear']","['Clear', 'clear']"
Usability,"ed. Unless overridden by derived classes, this always returns false. ;  ; double maxVal (Int_t code) const override;  Return maximum value for set of observables identified by code assigned in getMaxVal. ;  ; std::list< double > * plotSamplingHint (RooAbsRealLValue &obs, double xlo, double xhi) const override;  Return sampling hint for making curves of (projections) of this function as the recursive division strategy of RooCurve cannot deal efficiently with the vertical lines that occur in a non-interpolated histogram. ;  ; bool selfNormalized () const override;  Shows if a PDF is self-normalized, which means that no attempt is made to add a normalization term. ;  ; void setCdfBoundaries (bool flag);  ; void setInterpolationOrder (Int_t order);  ; void setUnitNorm (bool flag);  ; void Streamer (TBuffer &) override;  Stream an object of class RooHistPdf. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void translate (RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ;  Public Member Functions inherited from RooAbsPdf;  RooAbsPdf ();  Default constructor. ;  ;  RooAbsPdf (const char *name, const char *title, double minVal, double maxVal);  Constructor with name, title, and plot range. ;  ;  RooAbsPdf (const char *name, const char *title=nullptr);  Constructor with name and title only. ;  ;  ~RooAbsPdf () override;  Destructor. ;  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). ;  ; virtual RooAbsGenContext * autoGenContext (const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool verbose=false, bool autoBinned=true, const char *binnedTag="""") const;  ; virtual RooAbsGenContext * binnedGenContext (con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHistPdf.html:4156,simpl,simple,4156,doc/master/classRooHistPdf.html,https://root.cern,https://root.cern/doc/master/classRooHistPdf.html,1,['simpl'],['simple']
Usability,"ed.Definition TCanvas.cxx:2476; TCanvas::fBatchBool_t fBatch! True when in batchmodeDefinition TCanvas.h:59; TCanvas::fUseGLBool_t fUseGL! True when rendering is with GLDefinition TCanvas.h:62; TCanvas::GetEventYInt_t GetEventY() const overrideDefinition TCanvas.h:137; TCanvas::fEventXInt_t fEventX! Last X mouse position in canvasDefinition TCanvas.h:46; TCanvas::IsBatchBool_t IsBatch() const overrideDefinition TCanvas.h:171; TCanvas::DrawCloneTObject * DrawClone(Option_t *option="""") const overrideDraw a clone of this canvas A new canvas is created that is a clone of this canvas.Definition TCanvas.cxx:907; TCanvas::fXsizeRealSize_t fXsizeRealCurrent size of canvas along X in CM.Definition TCanvas.h:35; TCanvas::HasMenuBarBool_t HasMenuBar() constDefinition TCanvas.h:168; TCanvas::GetCanvasPainterTVirtualPadPainter * GetCanvasPainter()Access and (probably) creation of pad painter.Definition TCanvas.cxx:2616; TCanvas::HighlightConnectvirtual void HighlightConnect(const char *slot)This is ""simplification"" for function TCanvas::Connect with Highlighted signal for specific slot.Definition TCanvas.cxx:1631; TCanvas::PickTPad * Pick(Int_t px, Int_t py, TObjLink *&pickobj) overrideSearch for an object at pixel position px,py.Definition TCanvas.h:183; TCanvas::Closevoid Close(Option_t *option="""") overrideClose canvas.Definition TCanvas.cxx:788; TCanvas::SetFixedAspectRatiovoid SetFixedAspectRatio(Bool_t fixed=kTRUE) overrideFix canvas aspect ratio to current value if fixed is true.Definition TCanvas.cxx:2016; TCanvas::Resizevirtual void Resize(Option_t *option="""")Recompute canvas parameters following a X11 Resize.Definition TCanvas.cxx:1668; TCanvas::GetHighLightColorColor_t GetHighLightColor() const overrideDefinition TCanvas.h:138; TCanvas::GetShowToolBarBool_t GetShowToolBar() constDefinition TCanvas.h:149; TCanvas::DrawEventStatusvoid DrawEventStatus(Int_t event, Int_t x, Int_t y, TObject *selected)Report name and title of primitive below the cursor.Definition TCanvas.cxx",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCanvas_8h_source.html:19205,simpl,simplification,19205,doc/master/TCanvas_8h_source.html,https://root.cern,https://root.cern/doc/master/TCanvas_8h_source.html,1,['simpl'],['simplification']
Usability,"ed:. virtual Bool_tROOT::v5::TFormula::CheckOperands(Int_t operation, Int_t& err); virtual Bool_tROOT::v5::TFormula::CheckOperands(Int_t leftoperand, Int_t rightoperartion, Int_t& err); voidROOT::v5::TFormula::ClearFormula(Option_t* option = """"); virtual voidROOT::v5::TFormula::Convert(UInt_t fromVersion); virtual Double_tDefinedValue(Int_t code); Int_tDefinedVariable(TString& name); virtual Int_tDefinedVariable(TString& name, int& action); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Double_tROOT::v5::TFormula::EvalParFast(const Double_t* x, const Double_t* params); Double_tROOT::v5::TFormula::EvalPrimitive(const Double_t* x, const Double_t* params); Double_tROOT::v5::TFormula::EvalPrimitive0(const Double_t* x, const Double_t* params); Double_tROOT::v5::TFormula::EvalPrimitive1(const Double_t* x, const Double_t* params); Double_tROOT::v5::TFormula::EvalPrimitive2(const Double_t* x, const Double_t* params); Double_tROOT::v5::TFormula::EvalPrimitive3(const Double_t* x, const Double_t* params); Double_tROOT::v5::TFormula::EvalPrimitive4(const Double_t* x, const Double_t* params); Short_tROOT::v5::TFormula::GetAction(Int_t code) const; Short_tROOT::v5::TFormula::GetActionOptimized(Int_t code) const; Int_tROOT::v5::TFormula::GetActionParam(Int_t code) const; Int_tROOT::v5::TFormula::GetActionParamOptimized(Int_t code) const; Int_t*ROOT::v5::TFormula::GetOper() const; Int_t*ROOT::v5::TFormula::GetOperOptimized() const; voidinitCopy(const RooFormula& other); virtual Bool_tROOT::v5::TFormula::IsString(Int_t oper) const; voidROOT::v5::TFormula::MakePrimitive(const char* expr, Int_t pos); voidTObject::MakeZombie(); RooFormula&operator=(const RooFormula& other); Int_tROOT::v5::TFormula::PreCompile(); voidROOT::v5::TFormula::SetAction(Int_t code, Int_t value, Int_t param = 0); voidROOT::v5::TFormula::SetActionOptimized(Int_t code, Int_t value, Int_t param = 0); virtual Bool_tROOT::v5::TFormula::StringToNumber(Int_t code). Dat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooFormula.html:9886,Clear,ClearFormula,9886,root/html604/RooFormula.html,https://root.cern,https://root.cern/root/html604/RooFormula.html,1,['Clear'],['ClearFormula']
Usability,"edBackground; static const TGGC*fgDefaultSelectedBackgroundGC; static const TGGC*fgDefaultSelectedGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGTextEntry(const TGWindow* p, TGTextBuffer* text, Int_t id = -1, GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t option = kSunkenFrame|kDoubleBorder, Pixel_t back = GetWhitePixel()); Create a text entry widget. It will adopt the TGTextBuffer object; (i.e. the text buffer will be deleted by the text entry widget). TGTextEntry(const TGWindow* parent = 0, const char* text = 0, Int_t id = -1); Simple text entry constructor. TGTextEntry(const TString& contents, const TGWindow* parent, Int_t id = -1); Simple test entry constructor. Notice TString argument comes before the; parent argument (to make this ctor different from the first one taking a; const char*). ~TGTextEntry(); Delete a text entry widget. void Init(); Do default initialization. TGDimension GetDefaultSize() const; Return the default / minimal size of the widget. void SetDefaultSize(UInt_t w, UInt_t h); Set the default / minimal size of the widget. void ReturnPressed(); This signal is emitted when the return or enter key is pressed. void ShiftTabPressed(); This signal is emitted when <SHIFT> and <TAB> keys are pressed. void TabPressed(); This signal is emitted when the <TAB> key is pressed. void TextChanged(const char* text = 0); This signal is emitted every time the text has changed. void CursorOutLeft(); This signal is emitted when cursor is going out of left side. void CursorOutRight(); This signal is emitted when cursor is going out of right side. void CursorOutUp(); This signal is emitted whe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGTextEntry.html:26702,Simpl,Simple,26702,root/html532/TGTextEntry.html,https://root.cern,https://root.cern/root/html532/TGTextEntry.html,2,['Simpl'],['Simple']
Usability,"edBiasGradientsAt (size_t i);  ; std::vector< std::vector< Matrix_t > > & GetPastSquaredBiasUpdates ();  ; std::vector< Matrix_t > & GetPastSquaredBiasUpdatesAt (size_t i);  ; std::vector< std::vector< Matrix_t > > & GetPastSquaredWeightGradients ();  ; std::vector< Matrix_t > & GetPastSquaredWeightGradientsAt (size_t i);  ; std::vector< std::vector< Matrix_t > > & GetPastSquaredWeightUpdates ();  ; std::vector< Matrix_t > & GetPastSquaredWeightUpdatesAt (size_t i);  ; Scalar_t GetRho () const;  Getters. ;  ;  Public Member Functions inherited from TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >;  VOptimizer (Scalar_t learningRate, DeepNet_t &deepNet);  Constructor. ;  ; virtual ~VOptimizer ()=default;  Virtual Destructor. ;  ; size_t GetGlobalStep () const;  ; Layer_t * GetLayerAt (size_t i);  ; std::vector< Layer_t * > & GetLayers ();  ; Scalar_t GetLearningRate () const;  Getters. ;  ; void IncrementGlobalStep ();  Increments the global step. ;  ; void SetLearningRate (size_t learningRate);  Setters. ;  ; void Step ();  Performs one step of optimization. ;  . Protected Member Functions; void UpdateBiases (size_t layerIndex, std::vector< Matrix_t > &biases, const std::vector< Matrix_t > &biasGradients);  Update the biases, given the current bias gradients. ;  ; void UpdateWeights (size_t layerIndex, std::vector< Matrix_t > &weights, const std::vector< Matrix_t > &weightGradients);  Update the weights, given the current weight gradients. ;  . Protected Attributes; Scalar_t fEpsilon;  The Smoothing term used to avoid division by zero. ;  ; std::vector< std::vector< Matrix_t > > fPastSquaredBiasGradients;  The accumulation of the square of the past bias gradients associated with the deep net. ;  ; std::vector< std::vector< Matrix_t > > fPastSquaredBiasUpdates;  The accumulation of the square of the past bias updates associated with the deep net. ;  ; std::vector< std::vector< Matrix_t > > fPastSquaredWeightGradients;  The accumulation of the square of the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdadelta.html:2391,learn,learningRate,2391,doc/master/classTMVA_1_1DNN_1_1TAdadelta.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdadelta.html,1,['learn'],['learningRate']
Usability,"edCalculator::fPdf; Double_tRooStats::CombinedCalculator::fSizesize of the test (eg. specified rate of Type I error). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ProfileLikelihoodCalculator(); default constructor. ProfileLikelihoodCalculator(RooAbsData& data, RooAbsPdf& pdf, const RooArgSet& paramsOfInterest, Double_t size = 0.050000000000000003, const RooArgSet* nullParams = 0); constructor from pdf and parameters; the pdf must contain eventually the nuisance parameters. ProfileLikelihoodCalculator(RooAbsData& data, RooStats::ModelConfig& model, Double_t size = 0.050000000000000003); construct from a ModelConfig. Assume data model.GetPdf() will provide full description of model including; constraint term on the nuisances parameters. ~ProfileLikelihoodCalculator(); destructor; cannot delete prod pdf because it will delete all the composing pdf's; if (fOwnPdf) delete fPdf;; fPdf = 0;. void DoReset() const; reset and clear fit result; to be called when a new model or data are set in the calculator. RooAbsReal * DoGlobalFit() const; perform a global fit of the likelihood letting with all parameter of interest and; nuisance parameters; keep the list of fitted parameters. RooFitResult * DoMinimizeNLL(RooAbsReal* nll); Minimizer the given NLL using the default options. LikelihoodInterval* GetInterval() const; Main interface to get a RooStats::ConfInterval.; It constructs a profile likelihood ratio and uses that to construct a RooStats::LikelihoodInterval. HypoTestResult* GetHypoTest() const; Main interface to get a HypoTestResult.; It does two fits:; the first lets the null parameters float, so it's a maximum likelihood estimate; the second is to the null (fixing null parameters to their specified values): eg. a conditional maximum likelihood; the ratio of the likelihood at the conditional MLE to the MLE is the profile likelihood ratio.; Wilks' theorem is used to get p-values. ProfileLikelihoodCalculator(); default constructor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__ProfileLikelihoodCalculator.html:7606,clear,clear,7606,root/html602/RooStats__ProfileLikelihoodCalculator.html,https://root.cern,https://root.cern/root/html602/RooStats__ProfileLikelihoodCalculator.html,4,['clear'],['clear']
Usability,"edGenContext(const RooArgSet& vars, Bool_t verbose = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; virtual Bool_tchangeModel(const RooResolutionModel& newModel); voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); const RooRealVar*convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsAnaConvPdf.html:4716,clear,clearShapeDirty,4716,root/html534/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html,4,['clear'],['clearShapeDirty']
Usability,"edStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TProofPlayer (TProof *proof=0);  Default ctor. ;  ;  ~TProofPlayer () override;  Destructor. ;  ; void AddEventsProcessed (Long64_t ev) override;  ; void AddInput (TObject *inp) override;  Add object to input list. ;  ; void AddOutput (TList *out) override;  Incorporate output list (may not be used in this class). ;  ; Int_t AddOutputObject (TObject *obj) override;  Incorporate output object (may not be used in this class). ;  ; void AddQueryResult (TQueryResult *q) override;  Add query result to the list, making sure that there are no duplicates. ;  ; void ClearInput () override;  Clear input list. ;  ; TDrawFeedback * CreateDrawFeedback (TProof *p) override;  Draw feedback creation proxy. ;  ; void DeleteDrawFeedback (TDrawFeedback *f) override;  Delete draw feedback object. ;  ; Long64_t DrawSelect (TDSet *set, const char *varexp, const char *selection, Option_t *option="""", Long64_t nentries=-1, Long64_t firstentry=0) override;  Draw (may not be used in this class). ;  ; void Feedback (TList *objs) override;  Set feedback list (may not be used in this class). ;  ; void FeedBackCanvas (const char *name, Bool_t create);  Create/destroy a named canvas for feedback. ;  ; Long64_t Finalize (Bool_t force=kFALSE, Bool_t sync=kFALSE) override;  Finalize query (may not be used in this class). ;  ; Long64_t Finalize (TQueryResult *qr) override;  Finalize query (may not be used in this class). ;  ; Long64_t GetCacheSize () override;  Return the size in bytes of the cache. ;  ; TQueryResult * GetCurrentQuery () const override;  ; Int_t GetDrawArgs (const char *var, const char *sel, Option_t *opt, TString &selector, TString &objname) o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayer.html:2783,feedback,feedback,2783,doc/master/classTProofPlayer.html,https://root.cern,https://root.cern/doc/master/classTProofPlayer.html,1,['feedback'],['feedback']
Usability,"ed_ptr will be removed.Definition RCanvas.cxx:225; ROOT::Experimental::RCanvas::ResolveSharedPtrsvoid ResolveSharedPtrs()To resolve problem with storing of shared pointers Call this method when reading canvas from the file...Definition RCanvas.cxx:299; ROOT::Experimental::RCanvas::Runvoid Run(double tm=0.)Run canvas functionality for given time (in seconds)Definition RCanvas.cxx:285; ROOT::Experimental::RCanvas::IncModifieduint64_t IncModified()Definition RCanvas.hxx:82; ROOT::Experimental::RCanvas::GetUIDstd::string GetUID() constReturn unique identifier for the canvas Used in iPython display.Definition RCanvas.cxx:199; ROOT::Experimental::RCanvas::CreateJSONstd::string CreateJSON()Provide JSON which can be used for offline display.Definition RCanvas.cxx:211; ROOT::Experimental::RCanvas::Createstatic std::shared_ptr< RCanvas > Create(const std::string &title)Create new canvas instance.Definition RCanvas.cxx:89; ROOT::Experimental::RCanvas::ClearOnClosevoid ClearOnClose(const std::shared_ptr< void > &handle)Set handle which will be cleared when connection is closed.Definition RCanvas.cxx:239; ROOT::Experimental::RCanvas::Updatevoid Update(bool async=false, CanvasCallback_t callback=nullptr)update drawingDefinition RCanvas.cxx:78; ROOT::Experimental::RCanvas::Hidevoid Hide()Hide all canvas displays.Definition RCanvas.cxx:171; ROOT::Experimental::RChangeAttrRequest::Processstd::unique_ptr< RDrawableReply > Process() overrideApply attributes changes to the drawable Return mask with actions which were really applied.Definition RCanvas.cxx:327; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TString::HashUInt_t Hash(ECaseCompare cmp=kExact) constReturn hash value.Definition TString.cxx:677; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; int; nconst Int_t nDefinition lege",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RCanvas_8cxx_source.html:15861,clear,cleared,15861,doc/master/RCanvas_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RCanvas_8cxx_source.html,1,['clear'],['cleared']
Usability,"eded in; 270// the dictionary.; 271#include ""TQClass.h""; 272#endif; 273 ; 274 ; 275//---- ClassImpQ macro ----------------------------------------------; 276//; 277// This macro used to correspond to the ClassImp macro and should be used; 278// for classes derived from TQObject instead of the ClassImp macro.; 279// This macro makes it possible to have a single connection from; 280// all objects of the same class.; 281// *** It is now obsolete ***; 282 ; 283#define ClassImpQ(name) \; 284 ClassImp(name); 285 ; 286#endif; R__EXTERN#define R__EXTERNDefinition DllImport.h:26; b#define b(i)Definition RSha256.hxx:100; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; ClassDef#define ClassDef(name, id)Definition Rtypes.h:342; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; TList.h; TQClass.h; gTQSenderR__EXTERN void * gTQSenderDefinition TQObject.h:46; ConnectCINTBool_t ConnectCINT(TQObject *sender, const char *signal, const char *slot)Global function which simplifies making connection in interpreted ROOT session.Definition TQObject.cxx:1069; TString.h; TVirtualQConnection.h; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TCollection::IsEmptyvirtual Bool_t IsEmpty() constDefinition TCollection.h:188; TIterDefinition TCollection.h:235; TListA doubly linked list.Definition TList.h:38; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TQObjSenderDefinition TQObject.h:233; TQObjSender::SetSendervirtual void SetSender(void *sender)Definition TQObject.h:250; TQObjSender::fSenderClassTString fSenderClassDefinition TQObject.h:237; TQObjSender::TQObjSenderTQObjSender(const TQObjSender &)=delete; TQObjSender::~TQObjSendervirtual ~TQObjSender()Definition TQObject.h:248; TQObjSender::operator=TQObjSender & operator=(const TQObjSender &)=delete; TQObjSender::SetSenderClas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TQObject_8h_source.html:10681,simpl,simplifies,10681,doc/master/TQObject_8h_source.html,https://root.cern,https://root.cern/doc/master/TQObject_8h_source.html,1,['simpl'],['simplifies']
Usability,"edia; The class TGeoMedium describes tracking media properties. This has a pointer to a material and the additional data members representing the properties related to tracking.; TGeoMedium(const char *name,Int_t numed,TGeoMaterial *mat,; Double_t *params=0);; TGeoMediumMedia are used to store properties related to tracking and which are useful only when using geometry ...Definition TGeoMedium.h:23. name: name assigned to the medium; mat: pointer to a material; params: array of additional parameters. Another constructor allows effectively defining tracking parameters in GEANT3 style:; TGeoMedium(const char *name,Int_t numed,Int_t imat,Int_t ifield,; Double_t fieldm,Double_t tmaxfd,Double_t stemax,; Double_t deemax,Double_t epsil,Double_t stmin);; This constructor is reserved for creating tracking media from the VMC interface [...]:. numed: user-defined medium index; imat: unique ID of the material; others: see G3 documentation. Looking at our simple world example, one can see that for creating volumes one needs to create tracking media before. The way to proceed for those not interested in performing tracking with external MC's is to define and use only one dummy tracking medium as in the example (or a NULL pointer). User Interface for Handling Materials and Media; The TGeoManager class contains the API for accessing and handling defined materials:; TGeoManager::GetMaterial(name);; TGeoManager::GetMaterialTGeoMaterial * GetMaterial(const char *matname) constSearch for a named material. All trailing blanks stripped.Definition TGeoManager.cxx:3011; . Classes; class  TGeoElement;  Base class for chemical elements. More...;  ; class  TGeoMaterial;  Base class describing materials. More...;  ; class  TGeoMedium;  Media are used to store properties related to tracking and which are useful only when using geometry with a particle transport MC package (via VMC). More...;  ; class  TGeoMixture;  Mixtures of elements. More...;  . ROOT master - Reference Guide Generated on Tue",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Materials__classes.html:12647,simpl,simple,12647,doc/master/group__Materials__classes.html,https://root.cern,https://root.cern/doc/master/group__Materials__classes.html,1,['simpl'],['simple']
Usability,"edirection) plugin for the new ROOT Browser; TGCompositeFrame Base class for composite widgets (menubars, etc.); TGContainer Canvas container; TGDMLParse imports GDML using DOM and binds it to ROOT; TGDMLRefl helper class used for the storage of reflected solids; TGDMLWrite imports GDML using DOM and binds it to ROOT; TGDNDManager The main Drag and Drop Manager; TGDimension Dimension object (width, height); TGDockButton Dock button; TGDockHideButton Hide dock button; TGDockableFrame Dockable widget; TGDoubleHSlider Horizontal double slider widget; TGDoubleSlider Double slider widget abstract base class; TGDoubleVSlider Vertical double slider widget; TGDragWindow Window used for dragging; TGEventHandler Abstract event handler; TGFSComboBox Combo box widget for file system path; TGFileBrowser File browser.; TGFileContainer Container containing file system objects; TGFileDialog File selection dialog; TGFileInfo ; TGFileItem Class representing file system object; TGFont GUI font description; TGFontDialog Font selection dialog; TGFontDialog::FontProp_t ; TGFontPool Font pool; TGFontTypeComboBox Font type combobox widget; TGFrame Base class for simple widgets (button, etc.); TGFrameElement Base class used in GUI containers; TGFrameElementPack Class used in TGPack.; TGGC Graphics context; TGGCPool Graphics context pool; TGGotoDialog Goto line dialog used by TGTextEdit widget; TGGroupFrame A composite frame with border and title; TGHButtonGroup A button group with one horizontal row; TGHProgressBar Horizontal progress bar widget; TGHScrollBar Horizontal scrollbar widget; TGHSlider Horizontal slider widget; TGHSplitter A horizontal frame splitter; TGHeaderFrame Header frame with buttons and splitters; TGHorizontal3DLine A horizontal 3D separator line; TGHorizontalFrame Composite frame with horizontal child layout; TGHorizontalLayout Horizontal layout manager; TGHotString Graphics string with hot character; TGHtml HTML widget; TGHtmlBrowser very simple html browser; TGIcon Ic",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ClassIndex.html:76118,simpl,simple,76118,root/html532/ClassIndex.html,https://root.cern,https://root.cern/root/html532/ClassIndex.html,7,['simpl'],['simple']
Usability,"edo arguments inherited from compressed command. More complicated commands might want to override this function. ; Definition at line 402 of file TQCommand.cxx. ◆ DeclFileName(). static const char * TQCommand::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 98 of file TQCommand.h. ◆ Delete(). void TQCommand::Delete ; (; Option_t * ; opt = """"). overridevirtual . If ""opt"" is not zero delete every merged command which option string is equal to ""opt"". ; If ""opt"" is zero - delete all merged commands. ; Reimplemented from TList.; Definition at line 285 of file TQCommand.cxx. ◆ GetCommand(). TQCommand * TQCommand::GetCommand ; (; ). static . Return a command which is doing redo/undo action. ; This static method allows to set undo parameters dynamically, i.e. during execution of Redo function.; Example: For redo actions like TGTextEdit::DelChar() it is not possible to know ahead what character will be deleted. To set arguments for undo action ( e.g. TGTextEdit::InsChar(char)), one needs to call TQCommand::SetUndoArgs(1, character) from inside of TGTextEdit::DelChar() method, i.e. TQCommand::GetCommand()->SetUndoArgs(1, somechar);; TQCommand::GetCommandstatic TQCommand * GetCommand()Return a command which is doing redo/undo action.Definition TQCommand.cxx:276. Definition at line 276 of file TQCommand.cxx. ◆ GetName(). const char * TQCommand::GetName ; (; ); const. overridevirtual . Returns the command name. ; Default name is ""ClassName::RedoName(args)"" If list of merged commands is not empty the name is ""ClassName::RedoName(args):cname1:cname2 ..."" ; Reimplemented from TCollection.; Definition at line 670 of file TQCommand.cxx. ◆ GetNRargs(). Int_t TQCommand::GetNRargs ; (; ); const. Returns a number of redo arguments. ; Definition at line 768 of file TQCommand.cxx. ◆ GetNUargs(). Int_t TQCommand::GetNUargs ; (; ); const. Returns a number of undo arguments. ; Definition at line 776 of file TQCommand.cxx. ◆ Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:36859,undo,undo,36859,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['undo'],['undo']
Usability,"edrawn ;  ; const TGWindow * fParent;  Parent window. ;  ;  Protected Attributes inherited from TGObject; TGClient * fClient;  Connection to display server. ;  ; Handle_t fId;  X11/Win32 Window identifier. ;  ;  Protected Attributes inherited from TQObject; TList * fListOfConnections;  list of signals from this object ;  ; TList * fListOfSignals;  ; Bool_t fSignalsBlocked;  list of connections to this object ;  ;  Protected Attributes inherited from TBrowserImp; TBrowser * fBrowser {nullptr};  TBrowser associated with this implementation. ;  ; Bool_t fShowCycles {kFALSE};  Show object cycle numbers in browser. ;  . Private Member Functions;  TRootBrowserLite (const TRootBrowserLite &)=delete;  ; void AddToHistory (TGListTreeItem *item);  helper method to track history ;  ; void BrowseTextFile (const char *file);  browse text file ;  ; void Chdir (TGListTreeItem *item);  Make object associated with item the current directory. ;  ; void ClearHistory ();  clear navigation history ;  ; void CreateBrowser (const char *name);  Create the actual browser. ;  ; void DeleteListTreeItem (TGListTreeItem *item);  delete list tree item, remove it from history ;  ; void DisplayDirectory ();  Display current directory in second label, fLbl2. ;  ; void DisplayTotal (Int_t total, Int_t selected);  Display in statusbar total number of objects and number of selected objects in IconBox. ;  ; void HideTextEdit ();  hide text edit ;  ; void HighlightListLevel ();  helper method to track history ;  ; Bool_t HistoryBackward ();  go to the past ;  ; Bool_t HistoryForward ();  go to the future ;  ; void IconBoxAction (TObject *obj);  Default action when double clicking on icon. ;  ; void ListTreeHighlight (TGListTreeItem *item);  Open tree item and list in iconbox its contents. ;  ; TRootBrowserLite & operator= (const TRootBrowserLite &)=delete;  ; void Search ();  starts serach dialog ;  ; void SetViewMode (Int_t new_mode, Bool_t force=kFALSE);  Set iconbox's view mode and update menu and too",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRootBrowserLite.html:35383,clear,clear,35383,doc/master/classTRootBrowserLite.html,https://root.cern,https://root.cern/doc/master/classTRootBrowserLite.html,1,['clear'],['clear']
Usability,"edvirtual . Set up feedback (may not be used in this class). ; Reimplemented in TProofPlayerLocal, TProofPlayerRemote, TProofPlayerSlave, TProofPlayerSuperMaster, and TProofPlayerLite.; Definition at line 1642 of file TProofPlayer.cxx. ◆ StopFeedback(). void TProofPlayer::StopFeedback ; (; ). virtual . Stop feedback (may not be used in this class). ; Reimplemented in TProofPlayerLocal, TProofPlayerRemote, and TProofPlayerSlave.; Definition at line 1650 of file TProofPlayer.cxx. ◆ StopProcess(). void TProofPlayer::StopProcess ; (; Bool_t ; abort, . Int_t ; timeout = -1 . ). overridevirtual . Stop the process after this event. ; If timeout is positive, start a timer firing after timeout seconds to hard-stop time-expensive events. ; Implements TVirtualProofPlayer.; Reimplemented in TProofPlayerRemote.; Definition at line 287 of file TProofPlayer.cxx. ◆ StoreFeedback(). void TProofPlayer::StoreFeedback ; (; TObject * ; slave, . TList * ; out . ). overridevirtual . Store feedback list (may not be used in this class). ; Implements TVirtualProofPlayer.; Reimplemented in TProofPlayerRemote, and TProofPlayerLite.; Definition at line 689 of file TProofPlayer.cxx. ◆ StoreOutput(). void TProofPlayer::StoreOutput ; (; TList * ; out). overridevirtual . Store output list (may not be used in this class). ; Implements TVirtualProofPlayer.; Reimplemented in TProofPlayerRemote.; Definition at line 681 of file TProofPlayer.cxx. ◆ Streamer(). void TProofPlayer::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject.; Reimplemented in TProofPlayerLocal, TProofPlayerRemote, TProofPlayerSlave, TProofPlayerSuperMaster, and TProofPlayerLite. ◆ StreamerNVirtual(). void TProofPlayer::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 228 of file TProofPlayer.h. ◆ UpdateAutoBin(). void TProofPlayer::UpdateAutoBin ; (; const char * ; name, . Double_t & ; xmin, . Double_t & ; xmax, . Double_t & ; y",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayer.html:42975,feedback,feedback,42975,doc/master/classTProofPlayer.html,https://root.cern,https://root.cern/doc/master/classTProofPlayer.html,1,['feedback'],['feedback']
Usability,"ee [howto:errordef]).; 5.6.5 Parameter interaction; MnMigrad retains the result after each minimization (MnUserParameterStae, see [api:state]) and forwards the interface.; 5.6.6 VariableMetricMinimizer(); The VariableMetricMinimizer is instantiated using default constructor.; 5.6.7 minimize(const FCNBase&, …); The VariableMetricMinimizer provides several overloaded methods minimize with return value FunctionMinimum. Together with the user \(\mbox{FCN}\) (either an implementation of FCNBase or FCNGradientBase) the user has to give as input the parameters with starting values in one of the defined formats (std::vector\(<\)double\(>\), MnUserParameters or MnUserParameterState).; 5.7 MnMinimize and CombinedMinimizer; [api:minimize]; Causes minimization of the function by the method of \(\mbox{MIGRAD}\), as does the MnMigrad class, but switches to the \(\mbox{SIMPLEX}\) method if \(\mbox{MIGRAD}\) fails to converge. Constructor arguments, methods arguments and names of methods are the same as for MnMigrad or MnSimplex and VariableMetricMinimizer or SimplexMinimizer.; 5.8 MnMinos; [api:minos] Causes a \(\mbox{MINOS}\) error analysis to be performed on the parameter whose number is specified. \(\mbox{MINOS}\) errors may be expensive to calculate, but are very reliable since they take account of non-linearities in the problem as well as parameter correlations, and are in general asymmetric. The optional argument \(\mbox{maxcalls}\) specifies the (approximate) maximum number of function calls per parameter requested, after which the calculation will be stopped for that parameter.; 5.8.1 MnMinos(const FCNBase&, const FunctionMinimum&); Construct an MnMinos object from the user’s \(\mbox{FCN}\) and a valid FunctionMinimum. Additional constructors for user specific MnStrategy settings are provided.; 5.8.2 operator(); MnMinos::operator()(unsigned int n, unsigned int maxcalls) causes a \(\mbox{MINOS}\) error analysis for external parameter \(\mbox{n}\). The return value is a std::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:50134,Simpl,SimplexMinimizer,50134,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,2,['Simpl'],['SimplexMinimizer']
Usability,"ee(); destructor. void SetParentTreeInNodes(TMVA::Node* n = NULL); descend a tree to find all its leaf nodes, fill max depth reached in the; tree at the same time. TMVA::DecisionTree* CreateFromXML(void* node, UInt_t tmva_Version_Code = TMVA_VERSION_CODE); re-create a new tree (decision tree or search tree) from XML. UInt_t BuildTree(const TMVA::DecisionTree::EventConstList& eventSample, TMVA::DecisionTreeNode* node = NULL); building the decision tree by recursively calling the splitting of; one (root-) node into two daughter nodes (returns the number of nodes). void FillTree(const TMVA::DecisionTree::EventList& eventSample); fill the existing the decision tree structure by filling event; in from the top node and see where they happen to end up. void FillEvent(const TMVA::Event& event, TMVA::DecisionTreeNode* node); fill the existing the decision tree structure by filling event; in from the top node and see where they happen to end up. void ClearTree(); clear the tree nodes (their S/N, Nevents etc), just keep the structure of the tree. UInt_t CleanTree(TMVA::DecisionTreeNode* node = NULL); remove those last splits that result in two leaf nodes that; are both of the type (i.e. both signal or both background); this of course is only a reasonable thing to do when you use; ""YesOrNo"" leafs, while it might loose s.th. if you use the; purity information in the nodes.; --> hence I don't call it automatically in the tree building. Double_t PruneTree(const TMVA::DecisionTree::EventConstList* validationSample = NULL); prune (get rid of internal nodes) the Decision tree to avoid overtraining; serveral different pruning methods can be applied as selected by the; variable ""fPruneMethod"". void ApplyValidationSample(const TMVA::DecisionTree::EventConstList* validationSample) const; run the validation sample through the (pruned) tree and fill in the nodes; the variables NSValidation and NBValidadtion (i.e. how many of the Signal; and Background events from the validation sample. Thi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__DecisionTree.html:10455,clear,clear,10455,root/html534/TMVA__DecisionTree.html,https://root.cern,https://root.cern/root/html534/TMVA__DecisionTree.html,3,"['Clear', 'clear']","['ClearTree', 'clear']"
Usability,"eed to be made for the fit procedure to be carried out:. (1) The total number of events in each template is not too small; (so that its Poisson uncertainty can be neglected).; (2) The number of events in each bin is much smaller than the total; number of events in each template (so that multinomial; uncertainties can be replaced with Poisson uncertainties). Biased fit uncertainties may result if these conditions are not fulfilled; (see e.g. arXiv:0803.2711). Instantiation. A fit object is instantiated through; TFractionFitter* fit = new TFractionFitter(data, mc);; A number of basic checks (intended to ensure that the template histograms; represent the same ""kind"" of distribution as the data one) are carried out.; The TVirtualFitter object is then addressed and all fit parameters (the; template fractions) declared (initially unbounded). Applying constraints. Fit parameters can be constrained through; fit->Constrain(parameter #, lower bound, upper bound);; Setting lower bound = upper bound = 0 removes the constraint (a la Minuit);; however, a function; fit->Unconstrain(parameter #); is also provided to simplify this. Setting parameter values. The function; TVirtualFitter* vFit = fit->GetFitter();; is provided for direct access to the TVirtualFitter object. This allows to; set and fix parameter values, and set step sizes directly. Restricting the fit range. The fit range can be restricted through; fit->SetRangeX(first bin #, last bin #);; and freed using; fit->ReleaseRangeX();; For 2D histograms the Y range can be similarly restricted using; fit->SetRangeY(first bin #, last bin #);; fit->ReleaseRangeY();; and for 3D histograms also; fit->SetRangeZ(first bin #, last bin #);; fit->ReleaseRangeZ();. Weights histograms. Weights histograms (for a motivation see the above publication) can be specified; for the individual MC sources through; fit->SetWeight(parameter #, pointer to weights histogram);; and unset by specifying a null pointer. Obtaining fit results. The fit is car",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFractionFitter.html:3163,simpl,simplify,3163,root/html528/TFractionFitter.html,https://root.cern,https://root.cern/root/html528/TFractionFitter.html,1,['simpl'],['simplify']
Usability,"eed to be made for the fit procedure to be carried out:. (1) The total number of events in each template is not too small; (so that its Poisson uncertainty can be neglected).; (2) The number of events in each bin is much smaller than the total; number of events in each template (so that multinomial; uncertainties can be replaced with Poisson uncertainties). Biased fit uncertainties may result if these conditions are not fulfilled; (see e.g. arXiv:0803.2711). Instantiation. A fit object is instantiated through; TFractionFitter* fit = new TFractionFitter(data, mc);; A number of basic checks (intended to ensure that the template histograms; represent the same ""kind"" of distribution as the data one) are carried out.; The TVirtualFitter object is then addressed and all fit parameters (the; template fractions) declared (initially unbounded). Applying constraints. Fit parameters can be constrained through; fit->Constrain(parameter #, lower bound, upper bound);; Setting lower bound = upper bound = 0 removes the constraint (a la Minuit);; however, a function; fit->Unconstrain(parameter #); is also provided to simplify this. Setting parameter values. The function; TVirtualFitter* vFit = fit->GetFitter();; is provided for direct access to the TVirtualFitter object. This allows to; set and fix parameter values, and set step sizes directly. Restricting the fit range. The fit range can be restricted through; fit->SetRangeX(first bin #, last bin #);; and freed using; fit->ReleaseRangeX();; For 2D histograms the Y range can be similarly restricted using; fit->SetRangeY(first bin #, last bin #);; fit->ReleaseRangeY();; and for 3D histograms also; fit->SetRangeZ(first bin #, last bin #);; fit->ReleaseRangeZ();; It is also possible to exclude individual bins from the fit through; fit->ExcludeBin(bin #);; where the given bin number is assumed to follow the TH1::GetBin() numbering.; Any bins excluded in this way can be included again using the corresponding; fit->IncludeBin(bin #);. Weig",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TFractionFitter.html:3163,simpl,simplify,3163,root/html530/TFractionFitter.html,https://root.cern,https://root.cern/root/html530/TFractionFitter.html,9,['simpl'],['simplify']
Usability,"eed; 2446 BookMethod(subseedloader, theMethod, methodTitle, theOption);; 2447 ; 2448 // Train/Test/Evaluation; 2449 TrainAllMethods();; 2450 TestAllMethods();; 2451 EvaluateAllMethods();; 2452 ; 2453 // getting ROC; 2454 SSROC = GetROCIntegral(ybitset.to_string(), methodTitle);; 2455 importances[ny] += SROC - SSROC;; 2456 ; 2457 // cleaning information; 2458 TMVA::MethodBase *ssmethod = dynamic_cast<TMVA::MethodBase *>(fMethodsMap[ybitset.to_string().c_str()][0][0]);; 2459 TMVA::ResultsClassification *ssresults = (TMVA::ResultsClassification *)ssmethod->Data()->GetResults(; 2460 ssmethod->GetMethodName(), Types::kTesting, Types::kClassification);; 2461 delete ssresults;; 2462 delete subseedloader;; 2463 this->DeleteAllMethods();; 2464 fMethodsMap.clear();; 2465 }; 2466 }; 2467 std::cout << ""--- Variable Importance Results (Short)"" << std::endl;; 2468 return GetImportance(nbits, importances, varNames);; 2469}; 2470 ; 2471////////////////////////////////////////////////////////////////////////////////; 2472 ; 2473TH1F *TMVA::Factory::EvaluateImportanceRandom(DataLoader *loader, UInt_t nseeds, Types::EMVA theMethod,; 2474 TString methodTitle, const char *theOption); 2475{; 2476 TRandom3 *rangen = new TRandom3(0); // Random Gen.; 2477 ; 2478 uint64_t x = 0;; 2479 uint64_t y = 0;; 2480 ; 2481 // getting number of variables and variable names from loader; 2482 const int nbits = loader->GetDataSetInfo().GetNVariables();; 2483 std::vector<TString> varNames = loader->GetDataSetInfo().GetListOfVariables();; 2484 ; 2485 long int range = pow(2, nbits);; 2486 ; 2487 // vector to save importances; 2488 std::vector<Double_t> importances(nbits);; 2489 for (int i = 0; i < nbits; i++); 2490 importances[i] = 0;; 2491 ; 2492 Double_t SROC, SSROC; // computed ROC value; 2493 for (UInt_t n = 0; n < nseeds; n++) {; 2494 x = rangen->Integer(range);; 2495 ; 2496 std::bitset<32> xbitset(x);; 2497 if (x == 0); 2498 continue; // data loader need at least one variable; 2499 ; 2500 // creating lo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:102483,clear,clear,102483,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['clear'],['clear']
Usability,"een. The global visible level put a limitation on the maximum applied depth. Combined with visibility settings per volume, these can tune quite well what should appear on the screen. However, there are situations when users want to see a volume branch displayed down to the maximum depth, keeping at the same time a limitation or even suppressing others. In order to accomplish that, one should use the volume attribute: Visible daughters. By default, all daughters of all volumes are displayed if there is no limitation related with their level depth with respect to the top drawn volume.; 18.7.3 Ray Tracing; Ray tracing is a quite known drawing technique based on tracking rays from the eye position through all pixels of a view port device. The pixel color is derived from the properties of the first crossed surface, according some illumination model and material optical properties. While there are currently existing quite sophisticated ray tracing models, TGeo is currently using a very simple approach where the light source is matching the eye position (no shadows or back-tracing of the reflected ray). In future we are considering providing a base class in order to be able to derive more complex models.; Due to the fact that the number of rays that have to be tracked matches the size in pixels of the pad, the time required by this algorithm is proportional to the pad size. On the other hand, the speed is quite acceptable for the default ROOT pad size and the images produced by using this technique have high quality. Since the algorithm is practically using all navigation features, producing ray-traced pictures is also a geometry validation check. Ray tracing can be activated at volume level as the normal Draw(). Ray-traced view in a pad. myVolume->Raytrace(); Once ray-tracing a view, this can be zoomed or rotated as a usual one. Objects on the screen are no longer highlighted when picking the vertices but the corresponding volumes is still accessible.; 18.7.3.1 Clipping Ra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1011178,simpl,simple,1011178,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"eenDefinition Rtypes.h:66; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; qfloat * qDefinition THbookFile.cxx:89; Formchar * Form(const char *fmt,...)Formats a string in a circular formatting buffer.Definition TString.cxx:2489; TAttFill::SetFillStylevirtual void SetFillStyle(Style_t fstyle)Set the fill area style.Definition TAttFill.h:39; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttText::SetTextAnglevirtual void SetTextAngle(Float_t tangle=0)Set the text angle.Definition TAttText.h:43; TAttText::SetTextFontvirtual void SetTextFont(Font_t tfont=62)Set the text font.Definition TAttText.h:46; TF11-Dim function classDefinition TF1.h:233; TH1I1-D histogram with an int per channel (see TH1 documentation)Definition TH1.h:540; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH2I2-D histogram with an int per channel (see TH1 documentation)Definition TH2.h:225; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TTextBase class for several text objects.Definition TText.h:22; TText::DrawTextvirtual TText * DrawText(Double_t x, Double_t y, const char *text)Draw this text with new coordinates.Definition TText.cxx:176; . The candle reduces the information coming from a whole distribution into few values. Independently from the number of entries or the significance of the underlying distribution a candle will always look like a candle. So candle plots should be used carefully in particular with unknown distributions. The definition of a candle is based on unbinned data. Here, candles are created from binned data. Because of this, the deviation is connected to the bin width used. The calculation of the quantiles normally done on unbinned data ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:56021,simpl,simple,56021,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,1,['simpl'],['simple']
Usability,"efault Constructor. ; Definition at line 313 of file TTreeCache.cxx. ◆ TTreeCache() [3/3]. TTreeCache::TTreeCache ; (; TTree * ; tree, . Int_t ; buffersize = 0 . ). Constructor. ; Definition at line 320 of file TTreeCache.cxx. ◆ ~TTreeCache(). TTreeCache::~TTreeCache ; (; ). override . Destructor. (in general called by the TFile destructor) ; Definition at line 332 of file TTreeCache.cxx. Member Function Documentation. ◆ AddBranch() [1/2]. Int_t TTreeCache::AddBranch ; (; const char * ; bname, . bool ; subbranches = false . ). overridevirtual . Add a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ; It works in exactly the same way as TTree::SetBranchStatus so you probably want to look over there for details about the use of bname with regular expressions. The branches are taken with respect to the Owner of this TTreeCache (i.e. the original Tree) NB: if bname=""*"" all branches are put in the cache and the learning phase stopped Returns:; 0 branch added or already included; -1 on error . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 446 of file TTreeCache.cxx. ◆ AddBranch() [2/2]. Int_t TTreeCache::AddBranch ; (; TBranch * ; b, . bool ; subbranches = false . ). overridevirtual . Add a branch to the list of branches to be stored in the cache this function is called by the user via TTree::AddBranchToCache. ; The branch is added even if we are outside of the training phase. Returns:; 0 branch added or already included; -1 on error . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 376 of file TTreeCache.cxx. ◆ CalculateMissCache(). bool TTreeCache::CalculateMissCache ; (; ). private . Calculate the appropriate miss cache to fetch; helper function for FillMissCache. . ◆ CalculateMissEntries(). TBranch * TTreeCache::CalculateMissEntries ; (; Long64_t ; pos, . int ; len, . bool ; all . ). private . Given an file",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:35142,learn,learning,35142,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,['learn'],['learning']
Usability,"eference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Classes |; Public Member Functions |; Static Public Attributes |; Private Attributes |; Friends |; List of all members ; ROOT::Experimental::RNTupleDescriptor Class ReferenceNTuple-related classes. ; The on-storage meta-data of an ntuple. ; Represents the on-disk (on storage) information about an ntuple. The meta-data consists of a header and one or several footers. The header carries the ntuple schema, i.e. the fields and the associated columns and their relationships. The footer(s) carry information about one or several clusters. For every cluster, a footer stores its location and size, and for every column the range of element indexes as well as a list of pages and page locations.; The descriptor provide machine-independent (de-)serialization of headers and footers, and it provides lookup routines for ntuple objects (pages, clusters, ...). It is supposed to be usable by all RPageStorage implementations.; The serialization does not use standard ROOT streamers in order to not let it depend on libCore. The serialization uses the concept of frames: header, footer, and substructures have a preamble with version numbers and the size of the writte struct. This allows for forward and backward compatibility when the meta-data evolves. ; Definition at line 528 of file RNTupleDescriptor.hxx. Classes; class  RClusterDescriptorIterable;  Used to loop over all the clusters of an ntuple (in unspecified order) More...;  ; class  RClusterGroupDescriptorIterable;  Used to loop over all the cluster groups of an ntuple (in unspecified order) More...;  ; class  RColumnDescriptorIterable;  Used to loop over a field's associated columns. More...;  ; struct  RCreateModelOptions;  Modifiers passed to CreateModel More...;  ; class  RExtraTypeInfoDescriptorIterable;  Used to loop over all the extra type info record of an ntuple (in unspecified order) More...;  ; class  RFieldDes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleDescriptor.html:1043,usab,usable,1043,doc/master/classROOT_1_1Experimental_1_1RNTupleDescriptor.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleDescriptor.html,1,['usab'],['usable']
Usability,"efine first somewhere, as a code comment or in a separate page a ; group using the \defgroup tag. ; Example; /**; \defgroup Hist Histogram Library;  ; The Histogram library is documented in the class TH1.;  ; */; Then one needs to add in the class description comments the \ingroup tag. For example in the class TH1, which is part of the Hist group one should add; /**; \class TH1; \ingroup Hist ; ....; */; Include additional documentation pages in HTML or Markdown format; One can add extra pages for the documentation in HTML or Markdown format (preferable) in the package/doc directory (e.g. hist/doc). These page could be used to; provide a general documentation of the package. The pages should be included in a file with name as the package name and the .md or .html suffix (e.g. hist.md).; The file should contain, in addition to the package description, the Doxygen command \page [name] [title] which defines the internal page name (used to reference that page) and ; the page title.; For example; /**;  ; \page HistPage The Histogram Library;  ; This page provides a description of the Histogram library. ;  ; */; Inside page you can reference to groups or other pages using the Doxygen commands \subpage [refname] [""text""] and \ref [refname] [""text""]. ; See as example the existing math/doc/Math.md file. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/formatting-comments-doxygen.html:11302,guid,guidelines,11302,d/formatting-comments-doxygen.html,https://root.cern,https://root.cern/d/formatting-comments-doxygen.html,1,['guid'],['guidelines']
Usability,"efinition at line 492 of file TClass.h. ◆ GetTypeInfo(). const std::type_info * TClass::GetTypeInfo ; (; ); const. inline . Definition at line 496 of file TClass.h. ◆ HasConsistentHashMember(). Bool_t TClass::HasConsistentHashMember ; (; ). inline . Return 'true' if we can guarantee that if this class (or any class in this class inheritance hierarchy) overload TObject::Hash it also starts the RecursiveRemove process from its own destructor. ; Definition at line 501 of file TClass.h. ◆ HasCustomStreamerMember(). Bool_t TClass::HasCustomStreamerMember ; (; ); const. inline . The class has a Streamer method and it is implemented by the user or an older (not StreamerInfo based) automatic streamer. ; Definition at line 508 of file TClass.h. ◆ HasDataMemberInfo(). Bool_t TClass::HasDataMemberInfo ; (; ); const. inline . Definition at line 407 of file TClass.h. ◆ HasDefaultConstructor(). Bool_t TClass::HasDefaultConstructor ; (; Bool_t ; testio = kFALSE); const. Return true if we have access to a constructor usable for I/O. ; This is typically the default constructor but can also be a constructor specifically marked for I/O (for example a constructor taking a TRootIOCtor* as an argument). In other words, if this routine returns true, TClass::New is guarantee to succeed. To know if the class described by this TClass has a default constructor (public or not), use cl->GetProperty() & kClassHasDefaultCtor; kClassHasDefaultCtor@ kClassHasDefaultCtorDefinition TDictionary.h:140; To know if the class described by this TClass has a public default constructor use: gInterpreter->ClassInfo_HasDefaultConstructor(aClass->GetClassInfo());; gInterpreter#define gInterpreterDefinition TInterpreter.h:573. Definition at line 7393 of file TClass.cxx. ◆ HasDictionary(). Bool_t TClass::HasDictionary ; (; ); const. Check whether a class has a dictionary or not. ; This is equivalent to ask if a class is coming from a bootstrapping procedure initiated during the loading of a library. ; Definition a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:94106,usab,usable,94106,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['usab'],['usable']
Usability,"efinition at line 492 of file TClass.h. ◆ GetTypeInfo(). const std::type_info * TClass::GetTypeInfo ; (; ); const. inline . Definition at line 496 of file TClass.h. ◆ HasConsistentHashMember(). Bool_t TClass::HasConsistentHashMember ; (; ). inline . Return 'true' if we can guarantee that if this class (or any class in this class inheritance hierarchy) overload TObject::Hash it also starts the RecursiveRemove process from its own destructor. ; Definition at line 501 of file TClass.h. ◆ HasCustomStreamerMember(). Bool_t TClass::HasCustomStreamerMember ; (; ); const. inline . The class has a Streamer method and it is implemented by the user or an older (not StreamerInfo based) automatic streamer. ; Definition at line 508 of file TClass.h. ◆ HasDataMemberInfo(). Bool_t TClass::HasDataMemberInfo ; (; ); const. inline . Definition at line 407 of file TClass.h. ◆ HasDefaultConstructor(). Bool_t TClass::HasDefaultConstructor ; (; Bool_t ; testio = kFALSE); const. Return true if we have access to a constructor usable for I/O. ; This is typically the default constructor but can also be a constructor specifically marked for I/O (for example a constructor taking a TRootIOCtor* as an argument). In other words, if this routine returns true, TClass::New is guarantee to succeed. To know if the class described by this TClass has a default constructor (public or not), use cl->GetProperty() & kClassHasDefaultCtor; kClassHasDefaultCtor@ kClassHasDefaultCtorDefinition TDictionary.h:140; To know if the class described by this TClass has a public default constructor use: gInterpreter->ClassInfo_HasDefaultConstructor(aClass->GetClassInfo());; gInterpreter#define gInterpreterDefinition TInterpreter.h:573. Definition at line 7460 of file TClass.cxx. ◆ HasDictionary(). Bool_t TClass::HasDictionary ; (; ); const. Check whether a class has a dictionary or not. ; This is equivalent to ask if a class is coming from a bootstrapping procedure initiated during the loading of a library. ; Definition a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:94107,usab,usable,94107,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['usab'],['usable']
Usability,"efresh the ROOT list of globals.; TStringfIncludePathlist of CINT include paths; Bool_tfLockProcessLinetrue if ProcessLine should lock gCINTMutex; TEnv*fMapfilemap of classes and libraries; Int_tfMore1 if more input is required; charfPrompt[64]proposed prompt string; TObjArray*fRootmapFileslist of non-default rootmap files loaded; TStringfRootmapLoadPathdynamic load path used for loading rootmap files; TStringfSharedLibslist of shared libraries loaded by G__loadfile; Int_tfSharedLibsSerialIndicator of the last time we set fSharedLibs; static void*fgSetOfSpecialsset of TObject*s used in CINT variables. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCint(const char* name, const char* title); Initialize the CINT interpreter interface. ~TCint(); Destroy the CINT interpreter interface. void ClearFileBusy(); Reset CINT internal state in case a previous action was not correctly; terminated by G__init_cint() and G__dlmod(). void ClearStack(); Delete existing temporary values. Int_t InitializeDictionaries(); Initialize all registered dictionaries. Normally this is already done; by G__init_cint() and G__dlmod(). void EnableAutoLoading(); Enable the automatic loading of shared libraries when a class; is used that is stored in a not yet loaded library. Uses the; information stored in the class/library map (typically; $ROOTSYS/etc/system.rootmap). void EndOfLineAction(); It calls a ""fantom"" method to synchronize user keyboard input; and ROOT prompt line. Bool_t IsLoaded(const char* filename) const; Return true if the file has already been loaded by cint. Int_t Load(const char* filenam, Bool_t system = kFALSE); Load a library file in CINT's memory.; if 'system' is true, the library is never unloaded. void LoadMacro(const char* filename, TInterpreter::EErrorCode* error = 0); Load a macro file in CINT's memory. Long_t ProcessLine(const char* line, TInterpreter::EErrorCode* error = 0); Let CINT process a command line.; If the command is ex",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TCint.html:19982,Clear,ClearStack,19982,root/html532/TCint.html,https://root.cern,https://root.cern/root/html532/TCint.html,2,['Clear'],['ClearStack']
Usability,"eft); TGenCollectionProxy*TGenCollectionProxy::Initialize() const; virtual TGenCollectionProxy*TEmulatedCollectionProxy::InitializeEx(); voidTEmulatedCollectionProxy::ReadItems(int nElements, TBuffer& b); voidReadMap(int nElements, TBuffer& b); voidTEmulatedCollectionProxy::Shrink(UInt_t nCurr, UInt_t left, Bool_t force); voidTEmulatedCollectionProxy::WriteItems(int nElements, TBuffer& b); voidWriteMap(int nElements, TBuffer& b). Data Members; public:. enum TGenCollectionProxy::[unnamed] { kBIT_ISSTRING; kBIT_ISTSTRING; kBOOL_t; };; enum TVirtualCollectionProxy::EProperty { kIsInitialized; kIsAssociative; kIsEmulated; };. public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodTGenCollectionProxy::fClearMethod cache for container accessors: clear container; TGenCollectionProxy::MethodTGenCollectionProxy::fCollectMethod to collect objects from container; void*TGenCollectionProxy::fConstructContainer accessors: block construct; map<std::string,TObjArray*>*TGenCollectionProxy::fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0TGenCollectionProxy::fCreateEnvMethod to allocate an Environment holder.; void*TGenCollectionProxy::fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*TGenCollectionProxy::fEnvAddress of the currently proxied object; void*TGenCollectionProxy::fFeedContainer accessors: block feed; TGenCollectionProxy::MethodTGenCollectionProxy::fFirstContainer accessors: generic iteration: first; void*TGenCollectionProxy::fFunctionCreateIterators; void*TGenCollectionProxy::fFunctionDeleteTwoIterators; TGenCollectionProxy::Value*TGenCollectionProxy::fKeyDescriptor of the key_type; stringTGenCollectionProxy::fNameName of the class being proxied.; TGenCollectionProxy::MethodTGenCollectionProxy::fNextCont",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEmulatedMapProxy.html:4544,clear,clear,4544,root/html528/TEmulatedMapProxy.html,https://root.cern,https://root.cern/root/html528/TEmulatedMapProxy.html,2,['clear'],['clear']
Usability,egator.h;  FeldmanCousins.h;  FrequentistCalculator.h;  Heaviside.h;  HLFactory.h;  HybridCalculator.h;  HybridCalculatorOriginal.h;  HybridPlot.h;  HybridResult.h;  HypoTestCalculator.h;  HypoTestCalculatorGeneric.h;  HypoTestInverter.h;  HypoTestInverterOriginal.h;  HypoTestInverterPlot.h;  HypoTestInverterResult.h;  HypoTestPlot.h;  HypoTestResult.h;  IntervalCalculator.h;  LikelihoodInterval.h;  LikelihoodIntervalPlot.h;  MarkovChain.h;  MaxLikelihoodEstimateTestStat.h;  MCMCCalculator.h;  MCMCInterval.h;  MCMCIntervalPlot.h;  MetropolisHastings.h;  MinNLLTestStat.h;  ModelConfig.h;  NeymanConstruction.h;  NumberCountingPdfFactory.h;  NumberCountingUtils.h;  NumEventsTestStat.h;  PdfProposal.h;  PointSetInterval.h;  ProfileInspector.h;  ProfileLikelihoodCalculator.h;  ProfileLikelihoodTestStat.h;  ProofConfig.h;  ProposalFunction.h;  ProposalHelper.h;  RatioOfProfiledLikelihoodsTestStat.h;  RooStatsUtils.h;  SamplingDistPlot.h;  SamplingDistribution.h;  SequentialProposal.h;  SimpleInterval.h;  SimpleLikelihoodRatioTestStat.h;  SPlot.h;  TestStatistic.h;  TestStatSampler.h;  ToyMCImportanceSampler.h;  ToyMCSampler.h;  ToyMCStudy.h;  UniformProposal.h;  UpperLimitMCSModule.h;  LinkDef.h;  ► src;  AsymptoticCalculator.cxx;  BayesianCalculator.cxx;  BernsteinCorrection.cxx;  ConfidenceBelt.cxx;  DetailedOutputAggregator.cxx;  FeldmanCousins.cxx;  FrequentistCalculator.cxx;  Heaviside.cxx;  HLFactory.cxx;  HybridCalculator.cxx;  HybridCalculatorOriginal.cxx;  HybridPlot.cxx;  HybridResult.cxx;  HypoTestCalculatorGeneric.cxx;  HypoTestInverter.cxx;  HypoTestInverterOriginal.cxx;  HypoTestInverterPlot.cxx;  HypoTestInverterResult.cxx;  HypoTestPlot.cxx;  HypoTestResult.cxx;  LikelihoodInterval.cxx;  LikelihoodIntervalPlot.cxx;  MarkovChain.cxx;  MCMCCalculator.cxx;  MCMCInterval.cxx;  MCMCIntervalPlot.cxx;  MetropolisHastings.cxx;  ModelConfig.cxx;  NeymanConstruction.cxx;  NumberCountingPdfFactory.cxx;  NumberCountingUtils.cxx;  PdfProposal.cxx;  PointSetInterval.cxx;,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/files.html:85785,Simpl,SimpleInterval,85785,root/html606/files.html,https://root.cern,https://root.cern/root/html606/files.html,1,['Simpl'],['SimpleInterval']
Usability,"egration configuration. If no integration can be performed, zero should be returned. ; Reimplemented from RooAbsReal.; Definition at line 77 of file RooExponential.cxx. ◆ IsA(). TClass * RooExponential::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 55 of file RooExponential.h. ◆ negateCoefficient(). bool RooExponential::negateCoefficient ; (; ); const. inline . Definition at line 39 of file RooExponential.h. ◆ Streamer(). void RooExponential::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsPdf. ◆ StreamerNVirtual(). void RooExponential::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 55 of file RooExponential.h. ◆ translate(). void RooExponential::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 116 of file RooExponential.cxx. ◆ variable(). RooAbsReal const & RooExponential::variable ; (; ); const. inline . Get the x variable. ; Definition at line 34 of file RooExponential.h. Member Data Documentation. ◆ _negateCoefficient. bool RooExponential::_negateCoefficient = false. protected . Definition at line 48 of file RooExponential.h. ◆ c. RooRealProxy RooExponential::c. protected . Definition at line 47 of file RooExpone",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooExponential.html:78567,simpl,simple,78567,doc/master/classRooExponential.html,https://root.cern,https://root.cern/doc/master/classRooExponential.html,1,['simpl'],['simple']
Usability,"egrator1D(const RooAbsFunc& function, const RooNumIntConfig& config); RooIntegrator1D(const RooAbsFunc& function, RooIntegrator1D::SummationRule rule = Trapezoid, Int_t maxSteps = 0, Double_t eps = 0); RooIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, const RooNumIntConfig& config); RooIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, RooIntegrator1D::SummationRule rule = Trapezoid, Int_t maxSteps = 0, Double_t eps = 0); virtual~RooIntegrator1D(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Double_tRooAbsIntegrator::calculate(const Double_t* yvec = 0); virtual Bool_tcanIntegrate1D() const; virtual Bool_tcanIntegrate2D() const; virtual Bool_tcanIntegrateND() const; virtual Bool_tcanIntegrateOpenEnded() const; virtual Bool_tcheckLimits() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual RooAbsIntegrator*clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooIntegrator1D.html:1517,Clear,Clear,1517,root/html532/RooIntegrator1D.html,https://root.cern,https://root.cern/root/html532/RooIntegrator1D.html,2,['Clear'],['Clear']
Usability,"egularization ; _regularization = TMVA::DNN::EnumRegularization::NONE, . MinimizerType ; _eMinimizerType = MinimizerType::fSteepest, . double ; _learningRate = 1e-5, . double ; _momentum = 0.3, . int ; _repetitions = 3, . bool ; _multithreading = true . ). c'tor ; Definition at line 232 of file NeuralNet.cxx. ◆ ~Settings(). TMVA::DNN::Settings::~Settings ; (; ). virtual . d'tor ; Definition at line 261 of file NeuralNet.cxx. Member Function Documentation. ◆ addPoint() [1/2]. void TMVA::DNN::Settings::addPoint ; (; std::string ; histoName, . double ; x . ). inline . for monitoring ; Definition at line 821 of file NeuralNet.h. ◆ addPoint() [2/2]. void TMVA::DNN::Settings::addPoint ; (; std::string ; histoName, . double ; x, . double ; y . ). inline . for monitoring ; Definition at line 822 of file NeuralNet.h. ◆ batchSize(). size_t TMVA::DNN::Settings::batchSize ; (; ); const. inline . mini-batch size ; Definition at line 767 of file NeuralNet.h. ◆ clear(). void TMVA::DNN::Settings::clear ; (; std::string ; histoName). inline . for monitoring ; Definition at line 824 of file NeuralNet.h. ◆ computeResult(). virtual void TMVA::DNN::Settings::computeResult ; (; const Net & ; , . std::vector< double > & ;  . ). inlinevirtual . callback for monitoring and logging ; Definition at line 809 of file NeuralNet.h. ◆ convergenceCount(). size_t TMVA::DNN::Settings::convergenceCount ; (; ); const. inline . returns the current convergence count ; Definition at line 827 of file NeuralNet.h. ◆ convergenceSteps(). size_t TMVA::DNN::Settings::convergenceSteps ; (; ); const. inline . how many steps until training is deemed to have converged ; Definition at line 766 of file NeuralNet.h. ◆ create() [1/2]. void TMVA::DNN::Settings::create ; (; std::string ; histoName, . int ; bins, . double ; min, . double ; max . ). inline . for monitoring ; Definition at line 819 of file NeuralNet.h. ◆ create() [2/2]. void TMVA::DNN::Settings::create ; (; std::string ; histoName, . int ; bins, . double ; m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html:6065,clear,clear,6065,doc/master/classTMVA_1_1DNN_1_1Settings.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html,1,['clear'],['clear']
Usability,"eight = 1.0 . ). private . update the network based on how closely the output matched the desired output ; Definition at line 1302 of file MethodMLP.cxx. ◆ UpdateNetwork() [2/2]. void TMVA::MethodMLP::UpdateNetwork ; (; Double_t ; desired, . Double_t ; eventWeight = 1.0 . ). private . update the network based on how closely the output matched the desired output ; Definition at line 1286 of file MethodMLP.cxx. ◆ UpdatePriors(). void TMVA::MethodMLP::UpdatePriors ; (; ). private . zjh ; Definition at line 1454 of file MethodMLP.cxx. ◆ UpdateRegulators(). void TMVA::MethodMLP::UpdateRegulators ; (; ). private . zjh ; Definition at line 1468 of file MethodMLP.cxx. ◆ UpdateSynapses(). void TMVA::MethodMLP::UpdateSynapses ; (; ). private . update synapse error fields and adjust the weights (if in sequential mode) ; Definition at line 1412 of file MethodMLP.cxx. Member Data Documentation. ◆ fBatchSize. Int_t TMVA::MethodMLP::fBatchSize. private . batch size, only matters if in batch learning mode ; Definition at line 192 of file MethodMLP.h. ◆ fBPMode. EBPTrainingMode TMVA::MethodMLP::fBPMode. private . backprop learning mode (sequential or batch) ; Definition at line 190 of file MethodMLP.h. ◆ fBpModeS. TString TMVA::MethodMLP::fBpModeS. private . backprop learning mode option string (sequential or batch) ; Definition at line 191 of file MethodMLP.h. ◆ fCalculateErrors. bool TMVA::MethodMLP::fCalculateErrors. private . compute inverse hessian matrix at the end of the training ; Definition at line 165 of file MethodMLP.h. ◆ fDecayRate. Double_t TMVA::MethodMLP::fDecayRate. private . decay rate for above learning rate ; Definition at line 189 of file MethodMLP.h. ◆ fDeviationsFromTargets. std::vector<std::pair<Float_t,Float_t> >* TMVA::MethodMLP::fDeviationsFromTargets. private . deviation from the targets, event weight ; Definition at line 204 of file MethodMLP.h. ◆ fEpochMon. Bool_t TMVA::MethodMLP::fEpochMon. private . create and fill epoch-wise monitoring histograms (mak",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodMLP.html:49829,learn,learning,49829,doc/master/classTMVA_1_1MethodMLP.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodMLP.html,1,['learn'],['learning']
Usability,"eight; 114 int GetHeight() const { return fHeight; }; 115 ; 116 /// Display the canvas.; 117 void Show(const std::string &where = """");; 118 ; 119 /// returns true if Show() method was called; 120 bool IsShown() const { return fShown; }; 121 ; 122 /// clear IsShown() flag; 123 void ClearShown() { fShown = false; }; 124 ; 125 /// Returns window name used to display canvas; 126 std::string GetWindowAddr() const;; 127 ; 128 /// Returns window URL which can be used for connection; 129 std::string GetWindowUrl(bool remote);; 130 ; 131 /// Hide all canvas displays; 132 void Hide();; 133 ; 134 /// Remove canvas from global canvas lists, will be destroyed when shared_ptr will be removed; 135 void Remove();; 136 ; 137 /// Insert panel into the canvas, canvas should be shown at this moment; 138 template <class PANEL>; 139 bool AddPanel(std::shared_ptr<PANEL> &panel); 140 {; 141 if (!fPainter) return false;; 142 return fPainter->AddPanel(panel->GetWindow());; 143 }; 144 ; 145 /// Get modify counter; 146 uint64_t GetModified() const { return fModified; }; 147 ; 148 // Set newest version to all primitives; 149 void Modified() { SetDrawableVersion(IncModified()); }; 150 ; 151 /// Set newest version to specified drawable; 152 void Modified(std::shared_ptr<RDrawable> drawable); 153 {; 154 // TODO: may be check that drawable belong to the canvas; 155 if (drawable); 156 drawable->SetDrawableVersion(IncModified());; 157 }; 158 ; 159 // Return if canvas was modified and not yet updated; 160 bool IsModified() const;; 161 ; 162 /// update drawing; 163 void Update(bool async = false, CanvasCallback_t callback = nullptr);; 164 ; 165 /// returns true if Update() method was called; 166 bool IsUpdated() const { return fUpdated; }; 167 ; 168 /// clear IsUpdated() flag; 169 void ClearUpdated() { fUpdated = false; }; 170 ; 171 /// Run canvas functionality for given time (in seconds); 172 void Run(double tm = 0.);; 173 ; 174 /// Save canvas in image file; 175 bool SaveAs(const std::string &filenam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RCanvas_8hxx_source.html:4221,clear,clear,4221,doc/master/RCanvas_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RCanvas_8hxx_source.html,2,['clear'],['clear']
Usability,"eightDecay = 1e-5, . TMVA::DNN::EnumRegularization ; _regularization = TMVA::DNN::EnumRegularization::NONE, . MinimizerType ; _eMinimizerType = MinimizerType::fSteepest, . double ; _learningRate = 1e-5, . double ; _momentum = 0.3, . int ; _repetitions = 3, . bool ; _multithreading = true . ). c'tor ; Definition at line 232 of file NeuralNet.cxx. ◆ ~Settings(). TMVA::DNN::Settings::~Settings ; (; ). virtual . d'tor ; Definition at line 261 of file NeuralNet.cxx. Member Function Documentation. ◆ addPoint() [1/2]. void TMVA::DNN::Settings::addPoint ; (; std::string ; histoName, . double ; x . ). inline . for monitoring ; Definition at line 821 of file NeuralNet.h. ◆ addPoint() [2/2]. void TMVA::DNN::Settings::addPoint ; (; std::string ; histoName, . double ; x, . double ; y . ). inline . for monitoring ; Definition at line 822 of file NeuralNet.h. ◆ batchSize(). size_t TMVA::DNN::Settings::batchSize ; (; ); const. inline . mini-batch size ; Definition at line 767 of file NeuralNet.h. ◆ clear(). void TMVA::DNN::Settings::clear ; (; std::string ; histoName). inline . for monitoring ; Definition at line 824 of file NeuralNet.h. ◆ computeResult(). virtual void TMVA::DNN::Settings::computeResult ; (; const Net & ; , . std::vector< double > & ;  . ). inlinevirtual . callback for monitoring and logging ; Definition at line 809 of file NeuralNet.h. ◆ convergenceCount(). size_t TMVA::DNN::Settings::convergenceCount ; (; ); const. inline . returns the current convergence count ; Definition at line 827 of file NeuralNet.h. ◆ convergenceSteps(). size_t TMVA::DNN::Settings::convergenceSteps ; (; ); const. inline . how many steps until training is deemed to have converged ; Definition at line 766 of file NeuralNet.h. ◆ create() [1/2]. void TMVA::DNN::Settings::create ; (; std::string ; histoName, . int ; bins, . double ; min, . double ; max . ). inline . for monitoring ; Definition at line 819 of file NeuralNet.h. ◆ create() [2/2]. void TMVA::DNN::Settings::create ; (; std::string ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html:6030,clear,clear,6030,doc/master/classTMVA_1_1DNN_1_1Settings.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html,1,['clear'],['clear']
Usability,"el () const override;  ; Int_t GetVisOption () const override;  ; const char * GetVolumeInfo (const TGeoVolume *volume, Int_t px, Int_t py) const override;  Get some info about the current selected volume. ;  ; void GrabFocus (Int_t nfr=0, Double_t dlong=0, Double_t dlat=0, Double_t dpsi=0) override;  Move focus to current volume. ;  ; Bool_t IsExplodedView () const override;  ; Bool_t IsPaintingShape () const override;  ; Bool_t IsRaytracing () const override;  ; TH2F * LegoPlot (Int_t ntheta=60, Double_t themin=0., Double_t themax=180., Int_t nphi=90, Double_t phimin=0., Double_t phimax=360., Double_t rmin=0., Double_t rmax=9999999, Option_t *option="""") override;  Generate a lego plot fot the top volume, according to option. ;  ; void Lock (Bool_t flag=kTRUE);  ; void ModifiedPad (Bool_t update=kFALSE) const override;  Check if a pad and view are present and send signal ""Modified"" to pad. ;  ; void OpProgress (const char *opname, Long64_t current, Long64_t size, TStopwatch *watch=nullptr, Bool_t last=kFALSE, Bool_t refresh=kFALSE, const char *msg="""") override;  Text progress bar. ;  ; void Paint (Option_t *option="""") override;  Paint current geometry according to option. ;  ; void PaintNode (TGeoNode *node, Option_t *option="""", TGeoMatrix *global=nullptr) override;  Paint recursively a node and its content according to visualization options. ;  ; void PaintOverlap (void *ovlp, Option_t *option="""") override;  Paint an overlap. ;  ; void PaintPhysicalNode (TGeoPhysicalNode *node, Option_t *option="""");  Paints a physical node associated with a path. ;  ; Bool_t PaintShape (const TGeoShape &shape, Option_t *option) const;  Paint the supplied shape into the current 3D viewer. ;  ; void PaintShape (TGeoShape *shape, Option_t *option="""") override;  Paint an overlap. ;  ; void PaintVolume (TGeoVolume *vol, Option_t *option="""", TGeoMatrix *global=nullptr) override;  Paint recursively a node and its content according to visualization options. ;  ; void PrintOverlaps () const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoPainter.html:6276,progress bar,progress bar,6276,doc/master/classTGeoPainter.html,https://root.cern,https://root.cern/doc/master/classTGeoPainter.html,1,['progress bar'],['progress bar']
Usability,"el branch is created for each element of the TObjArray.; If splitlevel = 2, one top level branch is created for each array element. If one of the array elements is a TCollection, one top level branch will be created for each element of this collection. In case a collection element is a TClonesArray, the special Tree constructor for TClonesArray is called. The collection itself cannot be a TClonesArray. If name is given, all branch names will be prefixed with name_.; IMPORTANT NOTE1: This function should not be called if splitlevel<1. IMPORTANT NOTE2: The branches created by this function will have names corresponding to the collection or object names. It is important to give names to collections to avoid misleading branch names or identical branch names. By default collections have a name equal to the corresponding class name, e.g. the default name of TList is “TList”.; 12.13 Examples for Writing and Reading Trees; The following sections are examples of writing and reading trees increasing in complexity from a simple tree with a few variables to a tree containing folders and complex Event objects. Each example has a named script in the $ROOTSYS/tutorials/tree directory. They are called tree1.C to tree4.C. The examples are:. tree1.C: a tree with several simple (integers and floating point) variables.; tree2.C: a tree built from a C structure (struct). This example uses the Geant3 C wrapper as an example of a FORTRAN common block ported to C with a C structure.; tree3.C: in this example, we will show how to extend a tree with a branch from another tree with the Friends feature. These trees have branches with variable length arrays. Each entry has a variable number of tracks, and each track has several variables.; tree4.C: a tree with a class (Event). The class Event is defined in $ROOTSYS/test. In this example we first encounter the impact of splitting a branch. Each script contains the main function, with the same name as the file (i.e. tree1), the function to write ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:550858,simpl,simple,550858,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"el*fLabInfosinfos on current process; TGLabel*fLabStatusactual process status; Bool_tfModifiedkTRUE if settings have changed; Long64_tfPrevProcessedused for progress bar; Long64_tfPrevTotalused for progress bar; TGLabel*fRaterate of process in events/sec; TCanvas*fStatsCanvasnode statistics canvas; TSessionQueryFrame::EQueryStatusfStatusstatus of actual query; TGTab*fTabmain tab frame; TGLabel*fTotaltotal progress info; TSessionViewer*fViewerpointer on main viewer; TGHProgressBar*frmProgcurrent process progress bar. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionQueryFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionQueryFrame(); Destructor. void Build(TSessionViewer* gui); Build query informations frame. void Modified(Bool_t mod = kTRUE); Notify changes in query editor settings. void Feedback(TList* objs); Feedback function connected to Feedback signal.; Used to update feedback histograms. void UpdateHistos(TList* objs); Update feedback histograms. void Progress(Long64_t total, Long64_t processed); Update progress bar and status labels. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); New version of Progress (just forward to the old version; for the time being). void ProgressLocal(Long64_t total, Long64_t processed); Update progress bar and status labels. void IndicateStop(Bool_t aborted); Indicate that Cancel or Stop was clicked. void ResetProgressDialog(const char* selec, Int_t files, Long64_t first, Long64_t entries); Reset progress frame information fields. void OnBtnFinalize(); Finalize query. void OnBtnStop(); Stop processing query. void OnBtnShowLog(); Show query log. void OnBtnRetrieve(); Retrieve query. void OnBtnAbort(); Abort processing query. void OnBtnSubmit(); Submit query. void UpdateButtons(TQueryDescription* desc); Update buttons state for the current query status. void UpdateInfos(); Update que",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSessionQueryFrame.html:21102,feedback,feedback,21102,root/html528/TSessionQueryFrame.html,https://root.cern,https://root.cern/root/html528/TSessionQueryFrame.html,2,['feedback'],['feedback']
Usability,"el*fLabInfosinfos on current process; TGLabel*fLabStatusactual process status; Bool_tfModifiedkTRUE if settings have changed; Long64_tfPrevProcessedused for progress bar; Long64_tfPrevTotalused for progress bar; TGLabel*fRaterate of process in events/sec; TCanvas*fStatsCanvasnode statistics canvas; TSessionQueryFrame::EQueryStatusfStatusstatus of actual query; TGTab*fTabmain tab frame; TGLabel*fTotaltotal progress info; TSessionViewer*fViewerpointer on main viewer; TGHProgressBar*frmProgcurrent process progress bar. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionQueryFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionQueryFrame(); Destructor. void Build(TSessionViewer* gui); Build query informations frame. void Modified(Bool_t mod = kTRUE); Notify changes in query editor settings. void Feedback(TList* objs); Feedback function connected to Feedback signal.; Used to update feedback histograms. void UpdateHistos(TList* objs); Update feedback histograms. void Progress(Long64_t total, Long64_t processed); Update progress bar and status labels. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses); New version of Progress (just forward to the old version; for the time being). void ProgressLocal(Long64_t total, Long64_t processed); Update progress bar and status labels. void IndicateStop(Bool_t aborted); Indicate that Cancel or Stop was clicked. void ResetProgressDialog(const char* selec, Int_t files, Long64_t first, Long64_t entries); Reset progress frame information fields. void OnBtnFinalize(); Finalize query. void OnBtnStop(); Stop processing query. void OnBtnShowLog(); Show query log. void OnBtnRetrieve(); Retrieve query. void OnBtnAbort(); Abort processing query. void OnBtnSubmit(); Submit query. void UpdateButtons(TQueryDescription* desc); Update buttons state for the current query ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSessionQueryFrame.html:21377,feedback,feedback,21377,root/html532/TSessionQueryFrame.html,https://root.cern,https://root.cern/root/html532/TSessionQueryFrame.html,2,['feedback'],['feedback']
Usability,"el, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_t_debug; TFile*_refFile; list<std::pair<RooPlot*,std::string> >_regPlots; list<std::pair<RooFitResult*,std::string> >_regResults; list<std::pair<TH1*,std::string> >_regTH; list<std::pair<RooTable*,std::string> >_regTables; list<std::pair<Double_t,std::string> >_regValues; list<std::pair<RooWorkspace*,std::string> >_regWS; Int_t_verb; Bool_t_write; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; static TDirectory*gMemDir. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooUnitTest(). void regPlot(RooPlot* frame, const char* refName). void regResult(RooFitResult* r, const char* refName). void regValue(Double_t value, const char* refName). void regTable(RooTable* t, const char* refName). void regWS(RooWorkspace* ws, const char* refName). void regTH(TH1* h, const char* refName). RooWorkspace* getWS(const char* refName). Bool_t areTHidentical(TH1* htest, TH1* href). Bool_t runCompTests(). void setSilentMode(). void clearSilentMode(). Bool_t runTest(). void setMemDir(TDirectory* memDir); Set gMemDir to memDir. void setDebug(Bool_t flag); { _debug = flag ; }. Bool_t isTestAvailable(); { return kTRUE ; }. Bool_t testCode(). Double_t htol(); { return 5e-4 ; }. Double_t ctol(); { return 2e-3 ; }. Double_t fptol(); { return 1e-3 ; }. Double_t fctol(); { return 1e-3 ; }. Double_t vtol(); { return 1e-3 ; }. » Last changed: Tue Mar 10 17:21:08 2015 » Last generated: 2015-03-10 17:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooUnitTest.html:7683,clear,clearSilentMode,7683,root/html534/RooUnitTest.html,https://root.cern,https://root.cern/root/html534/RooUnitTest.html,2,['clear'],['clearSilentMode']
Usability,"el; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fCancelcancel button; TGLabel*fLabeltext entry label; TGTextButton*fOkok button; char*fRetStraddress to store return string; TGTextEntry*fTEtext entry widget. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGInputDialog(const TGWindow* p = 0, const TGWindow* main = 0, const char* prompt = 0, const char* defval = 0, char* retstr = 0, UInt_t options = kVerticalFrame); Create simple input dialog. It is important to know that the case where the constructor in; which all the variables are initialized to their default values is; only used for the TBrowser to inspect on the classes. For normal; use the only variable that should be free is options. Variables prompt, defval are the content of the input dialog while; retstr has to be initialized to a char[256]. In case these are not; initialized, they will show default values while retstr will be; automatically allocated by the dialog. However this will make; impossible to retrieve the value entered by the dialog. To see TGInputDialog in use see:; $ROOTSYS/tutorials/testInputDialog.cxx. ~TGInputDialog(); Cleanup dialog. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t ); Handle button and text enter events. TGInputDialog(const TGInputDialog& ). TGInputDialog & operator=(const TGInputDialog& ). » Author: David Gonzalez Mali",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGInputDialog.html:22100,simpl,simple,22100,root/html528/TGInputDialog.html,https://root.cern,https://root.cern/root/html528/TGInputDialog.html,6,['simpl'],['simple']
Usability,"elSize(h->GetZaxis()->GetLabelSize());; 4520 palette->SetTitleOffset(h->GetZaxis()->GetTitleOffset());; 4521 palette->SetTitleSize(h->GetZaxis()->GetTitleSize());; 4522 palette->SetNdivisions(h->GetZaxis()->GetNdivisions());; 4523 palette->SetTitle(h->GetZaxis()->GetTitle());; 4524 palette->SetTitleColor(h->GetZaxis()->GetTitleColor());; 4525 palette->SetTitleFont(h->GetZaxis()->GetTitleFont());; 4526 ; 4527 functions->AddFirst(palette);; 4528 }; 4529 if (palette) palette->Paint();; 4530 }; 4531 ; 4532 // Draw markers; 4533 auto nbcol = gStyle->GetNumberOfColors();; 4534 int logx = gPad->GetLogx();; 4535 int logy = gPad->GetLogy();; 4536 int logz = gPad->GetLogz();; 4537 if (theColor && logz) {; 4538 if (minc>0) minc = log10(minc);; 4539 if (maxc>0) maxc = log10(maxc);; 4540 }; 4541 theScatter->SetMarkerColor(theScatter->GetMarkerColor());; 4542 theScatter->TAttMarker::Modify();; 4543 double x,y,c,ms;; 4544 int nc;; 4545 for (int i=0; i<n; i++) {; 4546 if (theColor) {; 4547 if (logz) {; 4548 if (theColor[i]>0) c = log10(theColor[i]);; 4549 else continue;; 4550 } else {; 4551 c = theColor[i];; 4552 }; 4553 if (c<minc) continue;; 4554 if (c>maxc) continue;; 4555 nc = TMath::Nint(((c-minc)/(maxc-minc))*(nbcol-1));; 4556 if (nc > nbcol-1) nc = nbcol-1;; 4557 theScatter->SetMarkerColor(gStyle->GetColorPalette(nc));; 4558 }; 4559 if (theSize) {; 4560 ms = (MaxMarkerSize-MinMarkerSize)*((theSize[i]-mins)/(maxs-mins))+MinMarkerSize;; 4561 theScatter->SetMarkerSize(ms);; 4562 }; 4563 if (theColor || theSize) theScatter->TAttMarker::Modify();; 4564 if (logx) {; 4565 if (theX[i]>0) x = log10(theX[i]);; 4566 else break;; 4567 } else {; 4568 x = theX[i];; 4569 }; 4570 if (logy) {; 4571 if (theY[i]>0) y = log10(theY[i]);; 4572 else break;; 4573 } else {; 4574 y = theY[i];; 4575 }; 4576 gPad->PaintPolyMarker(1,&x,&y);; 4577 }; 4578}; 4579 ; 4580 ; 4581////////////////////////////////////////////////////////////////////////////////; 4582/// Paint a simple graph, without errors bars.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphPainter_8cxx_source.html:161199,simpl,simple,161199,doc/master/TGraphPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html,1,['simpl'],['simple']
Usability,"el_t back = GetDefaultFrameBackground()); virtual~TGMdiMainFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCanvas::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidArrangeFrames(Int_t mode); virtual voidArrangeMinimized(); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidCascade(); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); virtual voidCirculateDown(); virtual voidCirculateUp(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual voidTGCanvas::ClearViewPort(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tClose(TGMdiFrame* frame); virtual voidCloseAll(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; voidConfigureWindow(TGMdiFrame* f, TGMdiGeometry& geom); Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual Int_tContextHelp(TGMdiFrame* frame); virtual voidTObject::Copy(TObject& object) const; virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGMdiMainFrame.html:1488,Clear,ClearViewPort,1488,root/html532/TGMdiMainFrame.html,https://root.cern,https://root.cern/root/html532/TGMdiMainFrame.html,2,['Clear'],['ClearViewPort']
Usability,"eld() when recreating a field / model from the stored descriptor. ; Definition at line 179 of file RFieldBase.hxx. ◆ fOnDiskTypeChecksum. std::uint32_t ROOT::Experimental::RFieldBase::fOnDiskTypeChecksum = 0. protected . TClass checksum cached from the descriptor after a call to ConnectPageSource(). ; Only set for classes with dictionaries. ; Definition at line 246 of file RFieldBase.hxx. ◆ fOnDiskTypeVersion. std::uint32_t ROOT::Experimental::RFieldBase::fOnDiskTypeVersion = kInvalidTypeVersion. protected . C++ type version cached from the descriptor after a call to ConnectPageSource() ; Definition at line 243 of file RFieldBase.hxx. ◆ fParent. RFieldBase* ROOT::Experimental::RFieldBase::fParent. protected . Sub fields point to their mother field. ; Definition at line 222 of file RFieldBase.hxx. ◆ fPrincipalColumn. Internal::RColumn* ROOT::Experimental::RFieldBase::fPrincipalColumn = nullptr. protected . All fields that have columns have a distinct main column. ; E.g., for simple fields (float, int, ...), the principal column corresponds to the field type. For collection fields except fixed-sized arrays, the main column is the offset field. Class fields have no column of their own. When reading, points to any column of the column team of the active representation. Usually, this is just the first column. When writing, points to the first column index of the currently active (not suppressed) column representation. ; Definition at line 229 of file RFieldBase.hxx. ◆ fReadCallbacks. std::vector<ReadCallback_t> ROOT::Experimental::RFieldBase::fReadCallbacks. protected . List of functions to be called after reading a value. ; Definition at line 241 of file RFieldBase.hxx. ◆ fState. EState ROOT::Experimental::RFieldBase::fState = EState::kUnconnected. private . Changed by ConnectTo[Sink,Source], reset by Clone() ; Definition at line 183 of file RFieldBase.hxx. ◆ fStructure. ENTupleStructure ROOT::Experimental::RFieldBase::fStructure. private . The role of this field in the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RFieldBase.html:56277,simpl,simple,56277,doc/master/classROOT_1_1Experimental_1_1RFieldBase.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RFieldBase.html,1,['simpl'],['simple']
Usability,"elegate to gVirtualX. Float_t GetTextMagnitude() const; Delegate to gVirtualX. void SetTextAlign(Short_t align); Delegate to gVirtualX. void SetTextAngle(Float_t tangle); Delegate to gVirtualX. void SetTextColor(Color_t tcolor); Delegate to gVirtualX. void SetTextFont(Font_t tfont); Delegate to gVirtualX. void SetTextSize(Float_t tsize); Delegate to gVirtualX. void SetTextSizePixels(Int_t npixels); Delegate to gVirtualX. Int_t CreateDrawable(UInt_t w, UInt_t h); Create a gVirtualX Pixmap. void ClearDrawable(); Clear the current gVirtualX window. void CopyDrawable(Int_t id, Int_t px, Int_t py); Copy a gVirtualX pixmap. void DestroyDrawable(); Close the current gVirtualX pixmap. void SelectDrawable(Int_t device); Select the window in which the graphics will go. void DrawPixels(const unsigned char* pixelData, UInt_t width, UInt_t height, Int_t dstX, Int_t dstY, Bool_t enableAlphaBlending); Noop, for non-gl pad TASImage calls gVirtualX->CopyArea. void DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Paint a simple line. void DrawLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2); Paint a simple line in normalized coordinates. void DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, TVirtualPadPainter::EBoxMode mode); Paint a simple box. void DrawFillArea(Int_t n, const Double_t* x, const Double_t* y); Paint filled area. void DrawFillArea(Int_t n, const Float_t* x, const Float_t* y); Paint filled area. void DrawPolyLine(Int_t n, const Double_t* x, const Double_t* y). void DrawPolyLine(Int_t n, const Float_t* x, const Float_t* y); Paint polyline. void DrawPolyLineNDC(Int_t n, const Double_t* u, const Double_t* v); Paint polyline in normalized coordinates. void DrawPolyMarker(Int_t n, const Double_t* x, const Double_t* y); Paint polymarker. void DrawPolyMarker(Int_t n, const Float_t* x, const Float_t* y); Paint polymarker. void DrawText(Double_t x, Double_t y, const char* text, TVirtualPadPainter::ETextMode mode); Paint text. void DrawText(Dou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPadPainter.html:5900,simpl,simple,5900,root/html602/TPadPainter.html,https://root.cern,https://root.cern/root/html602/TPadPainter.html,2,['simpl'],['simple']
Usability,"elegate to gVirtualX. Float_t GetTextMagnitude() const; Delegate to gVirtualX. void SetTextAlign(Short_t align); Delegate to gVirtualX. void SetTextAngle(Float_t tangle); Delegate to gVirtualX. void SetTextColor(Color_t tcolor); Delegate to gVirtualX. void SetTextFont(Font_t tfont); Delegate to gVirtualX. void SetTextSize(Float_t tsize); Delegate to gVirtualX. void SetTextSizePixels(Int_t npixels); Delegate to gVirtualX. Int_t CreateDrawable(UInt_t w, UInt_t h); Create a gVirtualX Pixmap. void ClearDrawable(); Clear the current gVirtualX window. void CopyDrawable(Int_t id, Int_t px, Int_t py); Copy a gVirtualX pixmap. void DestroyDrawable(); Close the current gVirtualX pixmap. void SelectDrawable(Int_t device); Select the window in which the graphics will go. void DrawPixels(const unsigned char* pixelData, UInt_t width, UInt_t height, Int_t dstX, Int_t dstY, Bool_t enableAlphaBlending); Noop, for non-gl pad TASImage calls gVirtualX->CopyArea. void DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Paint a simple line. void DrawLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2); Paint a simple line in normalized coordinates. void DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, TVirtualPadPainter::EBoxMode mode); Paint a simple box. void DrawFillArea(Int_t n, const Double_t* x, const Double_t* y); Paint filled area. void DrawFillArea(Int_t n, const Float_t* x, const Float_t* y); Paint filled area. void DrawPolyLine(Int_t n, const Double_t* x, const Double_t* y); Paint Polyline. void DrawPolyLine(Int_t n, const Float_t* x, const Float_t* y); Paint polyline. void DrawPolyLineNDC(Int_t n, const Double_t* u, const Double_t* v); Paint polyline in normalized coordinates. void DrawPolyMarker(Int_t n, const Double_t* x, const Double_t* y); Paint polymarker. void DrawPolyMarker(Int_t n, const Float_t* x, const Float_t* y); Paint polymarker. void DrawText(Double_t x, Double_t y, const char* text, TVirtualPadPainter::ETextMode mode); Paint text. v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TPadPainter.html:5900,simpl,simple,5900,root/html604/TPadPainter.html,https://root.cern,https://root.cern/root/html604/TPadPainter.html,2,['simpl'],['simple']
Usability,"element of type STL container; TStreamerSTLstring Streamer element of type C++ string; TStreamerString Streamer element of type TString; TString Basic string class; TStringLong Long string class (more than 255 chars); TStringToken String tokenizer using PCRE for finding next tokens.; TStructNode Node with information about class; TStructNodeEditor GUI fo editing TStructNode; TStructNodeProperty Class with nodes color property; TStructViewer A 3D struct viewer; TStructViewerGUI A GUI fo 3D struct viewer ; TStyle A collection of all graphics attributes; TStyleDialog Dialog box used by the TStyleManager class; TStyleManager Graphical User Interface for managing styles; TStylePreview Preview window used by the TStyleManager class; TSubString ; TSynapse simple weighted bidirectionnal connection between 2 neurons; TSysEvtHandler ABC for handling system events; TSystem ABC defining a generic interface to the OS; TSystemDirectory A system directory; TSystemFile A system file; TTF Interface to TTF font handling; TTRAP TRAP shape; TTRD1 TRD1 shape; TTRD2 TRD2 shape; TTUBE TUBE shape; TTUBS TUBS shape; TTVLVContainer A dragging-capable LVContainer; TTVLVEntry Item that goes into the tree list view widget; TTVRecord A draw record for TTreeViewer; TTVSession A tree viewer session; TTabCom Perform command line completion when hitting <TAB>; TTable vector of the C structures; TTable3Points A 3-D Points; TTable::iterator ; TTableDescriptor descrpitor defining the internal layout of TTable objects; TTableIter Iterator over ""sorted"" TTable objects; TTableMap ""Map"" array for TTable object; TTablePadView3D ; TTablePoints Defines the TTable as an element of ""event"" geometry; TTableRange Range used in TGTable.; TTableSorter Is an ""observer"" class to sort the TTable objects; TTask Base class for tasks; TTeXDump Tex driver; TText Text; TTextEditor text editor; TThread Thread class; TThreadFactory Thread factory ABC; TThreadImp ThreadImp class; TTime Basic time type with milli second precis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ClassIndex.html:135007,simpl,simple,135007,root/html534/ClassIndex.html,https://root.cern,https://root.cern/root/html534/ClassIndex.html,2,['simpl'],['simple']
Usability,"elete); virtual voidSetOnFileClass(TClass* cl); virtual voidSetValueClass(TClass* newcl); virtual UInt_tSize() const; virtual UInt_tSizeof() const; virtual voidStreamer(TBuffer& refBuffer); virtual voidStreamer(TBuffer& refBuffer, void* pObject, int siz). protected:. voidCheckFunctions() const; virtual voidDeleteItem(Bool_t force, void* ptr) const; TGenCollectionProxy*Initialize(Bool_t silent) const; virtual TGenCollectionProxy*InitializeEx(Bool_t silent). private:. TGenCollectionProxy(). Data Members; public:. enum { kBIT_ISSTRING; kBIT_ISTSTRING; kBOOL_t; };; enum TVirtualCollectionProxy::EProperty { kIsInitialized; kIsAssociative; kIsEmulated; kNeedDelete; };. public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodfClearMethod cache for container accessors: clear container; TGenCollectionProxy::MethodfCollectMethod to collect objects from container; void*fConstructContainer accessors: block construct; map<std::string,TObjArray*>*fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0fCreateEnvMethod to allocate an Environment holder.; void*fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*fEnvAddress of the currently proxied object; void*fFeedContainer accessors: block feed; TGenCollectionProxy::MethodfFirstContainer accessors: generic iteration: first; void*fFunctionCreateIterators; void*fFunctionDeleteTwoIterators; TGenCollectionProxy::Value*fKeyDescriptor of the key_type; stringfNameName of the class being proxied.; TGenCollectionProxy::MethodfNextContainer accessors: generic iteration: next; TClass*fOnFileClassOn file class; Bool_tfPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionProxy::fProperties; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGenCollectionProxy.html:3888,clear,clear,3888,root/html532/TGenCollectionProxy.html,https://root.cern,https://root.cern/root/html532/TGenCollectionProxy.html,2,['clear'],['clear']
Usability,"eleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tfNRargsnumber of redo arguments; Int_tfNUargsnumber of undo arguments; TStringfNamecommand name. Default is ""ClassName::RedoName(args)""; TStringTCollection::fNamename of the collection; Bool_tfNewDeletekTRUE if Redo/Undo methods are new/delete; void*fObjectobject to which undo/redo actions applied; TQConnection*fRedodo/redo action; Long_t*fRedoArgsredo values; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; Int_tfState-1 undoing on, 1 redoing on, 0 nothing in progress; Int_tfStatusfStatus++ after Redo(), fStatus-- after Undo(); TStringfTitlecommand description; TQConnection*fUndoundo action; Long_t*fUndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Init(const char* cl, void* object, const char* redo, const char* undo); common protected method used in several constructors. TQCommand(const char* cl = 0, void* object = 0, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. clname - class name.; 2. obj - an object; 3. redo - method or function to do/redo operation; 4. undo - method or function to undo operation. Comments:; - if either clname or obj is NULL that means that redo/undo is function; - to specify default arguments for redo/undo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQCommand.html:17041,undo,undo,17041,root/html528/TQCommand.html,https://root.cern,https://root.cern/root/html528/TQCommand.html,16,"['Undo', 'undo']","['Undo', 'undo', 'undoing']"
Usability,"eleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TDocOutput::EFileTypekSource; static TDocOutput::EFileTypekTree; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. THtml*fHtmlTHtml object we belong to; static TDocOutput::EGraphvizToolkCirco; static TDocOutput::EGraphvizToolkDot; static TDocOutput::EGraphvizToolkFdp; static TDocOutput::EGraphvizToolkNeato. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDocOutput(THtml& html); {}. ~TDocOutput(); {}. void AddLink(TSubString& str, TString& link, const char* comment); Add a link around str, with title comment.; Update str so it surrounds the link. void AdjustSourcePath(TString& line, const char* relpath = ""../""); adjust the path of links for source files, which are in src/, but need; to point to relpath (usually ""../""). Simply replaces ""=\""./"" by ""=\""../"". void Convert(istream& in, const char* infilename, const char* outfilename, const char* title, const char* relpath = ""../"", Int_t includeOutput = 0, const char* context = """", TGClient* gclient = 0); Convert a text file into a html file.; outfilename doesn't have an extension yet; up to us to decide.; We generate HTML, so our extension is "".html"".; See THtml::Convert() for the other parameters. Bool_t CopyHtmlFile(const char* sourceName, const char* destName = """"); Copy file to HTML directory. Input: sourceName - source file name (fully qualified i.e. file system path); destName - optional destination name, if not; specified it would be the same; as the source file name. Output: TRUE if file is successfully copied, or; FALSE if it's not. NOTE: The destination directory is always fHtml->GetOutputDir(). void CreateHierarchy(); Create a hierarchical class list; The algorithm descends from the base classes and branches into; all derived classes. Mixing classes are ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TDocOutput.html:9851,Simpl,Simply,9851,root/html602/TDocOutput.html,https://root.cern,https://root.cern/root/html602/TDocOutput.html,2,['Simpl'],['Simply']
Usability,"elf. In case the object member is a TClonesArray,; the mechanism described in case C is applied to this array.; if splitlevel=0, the object is serialized in the branch buffer. ==> Case C. TBranch *branch = tree->Branch(branchname,clonesarray, bufsize, splitlevel); clonesarray is the address of a pointer to a TClonesArray.; The TClonesArray is a direct access list of objects of the same class.; For example, if the TClonesArray is an array of TTrack objects,; this function will create one subbranch for each data member of; the object TTrack. ==> branch->SetAddress(Void *address); In case of dynamic structures changing with each entry for example, one must; redefine the branch address before filling the branch again.; This is done via the TBranch::SetAddress member function. ==> tree->Fill(); loops on all defined branches and for each branch invokes the Fill function. See also the class TNtuple (a simple Tree with only one branch). /*. */. A simple example with histograms and a tree*-*-*-; *-* ===========================================. This program creates :; - a one dimensional histogram; - a two dimensional histogram; - a profile histogram; - a tree. These objects are filled with some random numbers and saved on a file. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. #include ""TFile.h""; #include ""TH1.h""; #include ""TH2.h""; #include ""TProfile.h""; #include ""TRandom.h""; #include ""TTree.h"". //______________________________________________________________________________; main(int argc, char **argv); {; // Create a new ROOT binary machine independent file.; // Note that this file may contain any kind of ROOT objects, histograms,trees; // pictures, graphics objects, detector geometries, tracks, events, etc..; // This file is now becoming the current directory.; TFile hfile(""htree.root"",""RECREATE"",""Demo ROOT file with histograms & trees"");. // Create some histograms and a profile histogram; TH1F *hpx = new TH1F(""hpx"",""This is the px distribution"",10",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreePlayer.html:4395,simpl,simple,4395,root/html528/TTreePlayer.html,https://root.cern,https://root.cern/root/html528/TTreePlayer.html,1,['simpl'],['simple']
Usability,"ellow, kPink, etc are defined in the header file; 147Rtypes.h that is included in all ROOT other header files. It is better; 148to use these keywords in user code instead of hardcoded color numbers, e.g.:; 149 ; 150~~~ {.cpp}; 151 myObject.SetFillColor(kRed);; 152 myObject.SetFillColor(kYellow-10);; 153 myLine.SetLineColor(kMagenta+2);; 154~~~; 155 ; 156Begin_Macro(source); 157{; 158 auto w = new TColorWheel();; 159 auto cw = new TCanvas(""cw"",""cw"",0,0,400,400);; 160 w->SetCanvas(cw);; 161 w->Draw();; 162}; 163End_Macro; 164 ; 165The complete list of predefined color names is the following:; 166 ; 167~~~ {.cpp}; 168kWhite = 0, kBlack = 1, kGray = 920, kRed = 632, kGreen = 416,; 169kBlue = 600, kYellow = 400, kMagenta = 616, kCyan = 432, kOrange = 800,; 170kSpring = 820, kTeal = 840, kAzure = 860, kViolet = 880, kPink = 900; 171~~~; 172 ; 173Note the special role of color `kWhite` (color number 0). It is the default; 174background color also. For instance in a PDF or PS files (as paper is usually white); 175it is simply not painted. To have a white color behaving like the other color the; 176simplest is to define an other white color not attached to the color index 0:; 177 ; 178~~~ {.cpp}; 179 Int_t ci = TColor::GetFreeColorIndex();; 180 TColor *color = new TColor(ci, 1., 1., 1.);; 181~~~; 182 ; 183\anchor C03; 184## Bright and dark colors; 185Dark and bright colors are used to add 3D effects to graphical objects like; 186TWbox, TPave, TPaveText, TPaveLabel, etc. and in colored lego plots.; 187 ; 188Two static functions are available that return the bright or dark color number corresponding; 189to a given color index. If these variants don't already exist, they are created as needed:; 190~~~ {.cpp}; 191 Int_t dark = TColor::GetColorDark(color_index);; 192 Int_t bright = TColor::GetColorBright(color_index);; 193~~~; 194 ; 195\anchor C031; 196## Accessible Color Schemes; 197Choosing an appropriate color scheme is essential for making results easy to understand and; 198i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:5874,simpl,simply,5874,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['simpl'],['simply']
Usability,"elope:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ Envelope(). Envelope::Envelope ; (; const TString & ; name, . DataLoader * ; dataloader = nullptr, . TFile * ; file = nullptr, . const TString ; options = """" . ). protected . Constructor for the initialization of Envelopes, differents Envelopes may needs differents constructors then this is a generic one protected. ; Parameters. namethe name algorithm. ; dataloaderTMVA::DataLoader object with the data. ; fileoptional file to save the results. ; optionsextra options for the algorithm. . Definition at line 40 of file Envelope.cxx. ◆ ~Envelope(). Envelope::~Envelope ; (; ). Default destructor. ; Definition at line 62 of file Envelope.cxx. Member Function Documentation. ◆ BookMethod() [1/2]. void TMVA::Envelope::BookMethod ; (; TString ; methodName, . TString ; methodTitle, . TString ; options = """" . ). virtual . Method to book the machine learning method to perform the algorithm. ; Parameters. methodNameString with the name of the mva method ; methodTitleString with the method title. ; optionsString with the options for the method. . Definition at line 163 of file Envelope.cxx. ◆ BookMethod() [2/2]. void TMVA::Envelope::BookMethod ; (; Types::EMVA ; method, . TString ; methodTitle, . TString ; options = """" . ). virtual . Method to book the machine learning method to perform the algorithm. ; Parameters. methodenum TMVA::Types::EMVA with the type of the mva method ; methodTitleString with the method title. ; optionsString with the options for the method. . Definition at line 152 of file Envelope.cxx. ◆ Class(). static TClass * TMVA::Envelope::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TMVA::Envelope::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMVA::Envelope::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Envelope.html:17952,learn,learning,17952,doc/master/classTMVA_1_1Envelope.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Envelope.html,1,['learn'],['learning']
Usability,"els ;  hlabels2.C 2-D histograms with alphanumeric labels ;  hlHisto1.CThis tutorial demonstrates how the highlight mechanism can be used on an histogram ;  hlHisto2.CThis tutorial demonstrates how the highlight mechanism can be used on an histogram ;  hlHisto3.CThis tutorial demonstrates how the highlight mechanism can be used on a ntuple ;  hlHisto4.CThis tutorial demonstrates how the highlight mechanism can be used on an histogram ;  hstack.C Example of stacked histograms: class THStack ;  hsum.C Histograms filled and drawn in a loop ;  hsumTimer.C Demo of Timers ;  legendautoplaced.C The legend can be placed automatically in the current pad in an empty space found at painting time ;  logscales.C Draw parametric functions with log scales ;  multicolor.C Use a THStack to show a 2-D hist with cells with different colors ;  ratioplot1.C Example creating a simple ratio plot of two histograms using the pois division option ;  ratioplot1.py Example creating a simple ratio plot of two histograms using the pois division option ;  ratioplot2.C Example of a fit residual plot ;  ratioplot2.py Example of a fit residual plot ;  ratioplot3.C Example which shows how you can get the graph of the lower plot and set the y axis range for it ;  ratioplot3.py Example which shows how you can get the graph of the lower plot and set the y axis range for it ;  ratioplot4.C Example that shows custom dashed lines on the lower plot, specified by a vector of floats ;  ratioplot4.py Example that shows custom dashed lines on the lower plot, specified by a vector of floats ;  ratioplot5.C Example that shows how you can set the colors of the confidence interval bands by using the method TRatioPlot::SetConfidenceIntervalColors ;  ratioplot5.py Example that shows how you can set the colors of the confidence interval bands by using the method TRatioPlot::SetConfidenceIntervalColors ;  ratioplot6.C Example showing a fit residual plot, where the separation margin has been set to 0 ;  ratioplot6.py Exa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:127721,simpl,simple,127721,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['simpl'],['simple']
Usability,"em path; TGFileBrowser File browser.; TGFileContainer Container containing file system objects; TGFileDialog File selection dialog; TGFileInfo ; TGFileItem Class representing file system object; TGFont GUI font description; TGFontDialog Font selection dialog; TGFontDialog::FontProp_t ; TGFontPool Font pool; TGFontTypeComboBox Font type combobox widget; TGFrame Base class for simple widgets (button, etc.); TGFrameElement Base class used in GUI containers; TGFrameElementPack Class used in TGPack.; TGGC Graphics context; TGGCPool Graphics context pool; TGGotoDialog Goto line dialog used by TGTextEdit widget; TGGroupFrame A composite frame with border and title; TGHButtonGroup A button group with one horizontal row; TGHProgressBar Horizontal progress bar widget; TGHScrollBar Horizontal scrollbar widget; TGHSlider Horizontal slider widget; TGHSplitter A horizontal frame splitter; TGHeaderFrame Header frame with buttons and splitters; TGHorizontal3DLine A horizontal 3D separator line; TGHorizontalFrame Composite frame with horizontal child layout; TGHorizontalLayout Horizontal layout manager; TGHotString Graphics string with hot character; TGHtml HTML widget; TGHtmlBrowser very simple html browser; TGIcon Icon GUI class; TGIconLBEntry Icon + text listbox entry; TGIdleHandler Idle event handler; TGImageMap Clickable image (like MAP in HTML); TGInputDialog Simple input dialog; TGInsets Inset (left, right, top, bottom); TGL5DDataSet Class to read data from TTree and create TGL5DPainter.; TGL5DDataSetEditor GUI for editing OpenGL 5D Viewer attributes; TGLAdapter Allow plot-painters to be used for gl-inpad and gl-viewer.; TGLAnnotation GL-annotation.; TGLAutoRotator Short description.; TGLAxis a GL Axis; TGLAxisPainter GL axis painter.; TGLAxisPainterBox Painter of GL axes for a 3D box.; TGLBContainer Listbox container; TGLBEntry Basic listbox entry; TGLBoundingBox a 3D orientated bounding box; TGLBoxCut Cuts away part of a plot.; TGLBoxPainter Box painter; TGLCamera Camera abs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ClassIndex.html:74484,progress bar,progress bar,74484,root/html528/ClassIndex.html,https://root.cern,https://root.cern/root/html528/ClassIndex.html,2,"['progress bar', 'simpl']","['progress bar', 'simple']"
Usability,"ember Functions;  LayerData (const LayerData &other);  copy c'tor of LayerData ;  ;  LayerData (const_iterator_type itInputBegin, const_iterator_type itInputEnd, ModeOutputValues eModeOutput=ModeOutputValues::DIRECT);  c'tor of LayerData ;  ;  LayerData (LayerData &&other);  move c'tor of LayerData ;  ;  LayerData (size_t inputSize);  c'tor of LayerData ;  ;  LayerData (size_t size, const_iterator_type itWeightBegin, iterator_type itGradientBegin, std::shared_ptr< std::function< double(double)> > activationFunction, std::shared_ptr< std::function< double(double)> > inverseActivationFunction, ModeOutputValues eModeOutput=ModeOutputValues::DIRECT);  c'tor of LayerData ;  ;  LayerData (size_t size, const_iterator_type itWeightBegin, std::shared_ptr< std::function< double(double)> > activationFunction, ModeOutputValues eModeOutput=ModeOutputValues::DIRECT);  c'tor of LayerData ;  ;  ~LayerData ();  ; std::shared_ptr< std::function< double(double)> > activationFunction () const;  ; void clear ();  clear the values and the deltas ;  ; void clearDropOut ();  clear the drop-out-data for this layer ;  ; iterator_type deltasBegin ();  returns iterator to the begin of the deltas (back-propagation) ;  ; const_iterator_type deltasBegin () const;  returns const iterator to the begin of the deltas (back-propagation) ;  ; iterator_type deltasEnd ();  returns iterator to the end of the deltas (back-propagation) ;  ; const_iterator_type deltasEnd () const;  returns const iterator to the end of the deltas (back-propagation) ;  ; const_dropout_iterator dropOut () const;  return the begin of the drop-out information ;  ; iterator_type gradientsBegin ();  returns iterator to the begin of the gradients ;  ; const_iterator_type gradientsBegin () const;  returns const iterator to the begin of the gradients ;  ; bool hasDropOut () const;  has this layer drop-out turned on? ;  ; std::shared_ptr< std::function< double(double)> > inverseActivationFunction () const;  ; ModeOutputValues outputMod",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1LayerData.html:1929,clear,clear,1929,doc/master/classTMVA_1_1DNN_1_1LayerData.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1LayerData.html,1,['clear'],['clear']
Usability,"embers; Includes; Libraries. Function documentation; TProofProgressLog(TProofProgressDialog* d, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. TProofProgressLog(const char* url = 0, Int_t sessionidx = 0, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. void Init(Int_t w = 700, Int_t h = 600); Init window frame for log messages. ~TProofProgressLog(); Destructor. void Popup(); Show log window. void Clear(Option_t* = 0); Clear log window. void LoadBuffer(const char* buffer); Load a text buffer in the window. void LoadFile(const char* file); Load a file in the window. void AddBuffer(const char* buffer); Add text to the window. void CloseWindow(); Handle close button or when closed via window manager action. void BuildLogList(Bool_t create = kFALSE); Build the list of workers. For this, extract the logs and take the names; of TProofLogElements. void DoLog(Bool_t grep = kFALSE); Display logs. 'grep' is set to kTRUE if it is invoked by pressing the; 'Filter' button. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame, if open. void SaveToFile(); Save the logs to a file; Only the name of the file is taken, no expansion. void SetGrepView(); Sets the view of grep filters according to the value of checkboxes. void NoLineEntry(); Enable/disable the line number entry. void Select(Int_t id, Bool_t all = kTRUE); actions of select all/clear all button. void Rebuild(); Rebuild the log info for a new entered session. TProofProgressLog(TProofProgressDialog* d, Int_t w = 700, Int_t h = 600). void SetUrl(const char* url); slots. { fSessionUrl = url; }. » Author: G Ganis, Aug 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: c52dc6cb225c25e34d388329d41570a484d98ce0 $ » Last generated: 2015-06-02 16:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofProgressLog.html:26292,clear,clear,26292,root/html604/TProofProgressLog.html,https://root.cern,https://root.cern/root/html604/TProofProgressLog.html,2,['clear'],['clear']
Usability,"embers; Includes; Libraries. Function documentation; TProofProgressLog(TProofProgressDialog* d, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. TProofProgressLog(const char* url = 0, Int_t sessionidx = 0, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. void Init(Int_t w = 700, Int_t h = 600); Init window frame for log messages. ~TProofProgressLog(); Destructor. void Popup(); Show log window. void Clear(Option_t* = 0); Clear log window. void LoadBuffer(const char* buffer); Load a text buffer in the window. void LoadFile(const char* file); Load a file in the window. void AddBuffer(const char* buffer); Add text to the window. void CloseWindow(); Handle close button or when closed via window manager action. void BuildLogList(Bool_t create = kFALSE); Build the list of workers. For this, extract the logs and take the names; of TProofLogElements. void DoLog(Bool_t grep = kFALSE); Display logs. 'grep' is set to kTRUE if it is invoked by pressing the; 'Filter' button. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame, if open. void SaveToFile(); Save the logs to a file; Only the name of the file is taken, no expansion. void SetGrepView(); Sets the view of grep filters according to the value of checkboxes. void NoLineEntry(); Enable/disable the line number entry. void Select(Int_t id, Bool_t all = kTRUE); actions of select all/clear all button. void Rebuild(); Rebuild the log info for a new entered session. TProofProgressLog(TProofProgressDialog* d, Int_t w = 700, Int_t h = 600). void SetUrl(const char* url); slots. { fSessionUrl = url; }. » Author: G Ganis, Aug 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: c52dc6cb225c25e34d388329d41570a484d98ce0 $ » Last generated: 2015-06-30 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofProgressLog.html:26292,clear,clear,26292,root/html602/TProofProgressLog.html,https://root.cern,https://root.cern/root/html602/TProofProgressLog.html,2,['clear'],['clear']
Usability,"ement::ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainTransparencyToAllChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainTransparencyToMatchingChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBImplySelectAllChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBTakeAnyParentAsMaster; static TEveElement::EDestructTEveElement::kNone; static TEveElement::EDestructTEveElement::kStandard. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveViewer(const char* n = ""TEveViewer"", const char* t = """"); Constructor.; The base-class TEveWindowFrame is constructed without a frame so; a default composite-frame is instantiated and stored in fGUIFrame.; Cleanup is set to no-cleanup as viewers need to be zapped with some; more care. ~TEveViewer(); Destructor. void InitInternal(); Initialize static data-members according to running conditions. void PreUndock(); Virtual function called before a window is undocked.; On mac we have to force recreation of gl-context. void PostDock(); Virtual function called after a window is docked.; On mac we have to force recreation of gl-context. const TGPicture* GetListTreeIcon(Bool_t open = kFALSE); Return TEveViewer icon. void SetGLViewer(TGLViewer* viewer, TGFrame* frame); Set TGLViewer that is represented by this object.; The old gl-viewer is deleted. TGLSAViewer* SpawnGLViewer(TGedEditor* ged = 0, Bool_t stereo = kFALSE); Spawn new GLViewer and adopt it. TGLEmbeddedViewer* SpawnGLEmbeddedViewer(TGedEditor* ged = 0, Int_t border = 0); Spawn new GLViewer and adopt it. void Redraw(Bool_t resetCameras = kFALSE); Redraw viewer immediately. void SwitchStereo(); Switch stereo mode.; This only works TGLSAViewers and, of course, with stereo support; provided by the OpenGL driver. void AddScene(TEveScene* scene); Add 'scene' to the list of scenes. void RemoveElementLocal(TEveElement* el); Remove element 'el' from the list of child",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveViewer.html:24040,undo,undocked,24040,root/html602/TEveViewer.html,https://root.cern,https://root.cern/root/html602/TEveViewer.html,2,['undo'],['undocked']
Usability,"ement::ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainTransparencyToAllChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainTransparencyToMatchingChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBImplySelectAllChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBTakeAnyParentAsMaster; static TEveElement::EDestructTEveElement::kNone; static TEveElement::EDestructTEveElement::kStandard. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveViewer(const char* n = ""TEveViewer"", const char* t = """"); Constructor.; The base-class TEveWindowFrame is constructed without a frame so; a default composite-frame is instantiated and stored in fGUIFrame.; Cleanup is set to no-cleanup as viewers need to be zapped with some; more care. ~TEveViewer(); Destructor. void InitInternal(); Initialize static data-members according to running conditions. void PreUndock(); Virtual function called before a window is undocked.; On mac we have to force recreation of gl-context. void PostDock(); Virtual function called after a window is docked.; On mac we have to force recreation of gl-context. const TGPicture* GetListTreeIcon(Bool_t open = kFALSE); Return TEveViewer icon. void SetGLViewer(TGLViewer* viewer, TGFrame* frame); Set TGLViewer that is represented by this object.; The old gl-viewer is deleted. TGLSAViewer* SpawnGLViewer(TGedEditor* ged = 0, Bool_t stereo = kFALSE, Bool_t quad_buf = kTRUE); Spawn new GLViewer and adopt it. TGLEmbeddedViewer* SpawnGLEmbeddedViewer(TGedEditor* ged = 0, Int_t border = 0); Spawn new GLViewer and adopt it. void Redraw(Bool_t resetCameras = kFALSE); Redraw viewer immediately. void SwitchStereo(); Switch stereo mode.; This only works TGLSAViewers and, of course, with stereo support; provided by the OpenGL driver. void AddScene(TEveScene* scene); Add 'scene' to the list of scenes. void RemoveElementLocal(TEveElement* el); Remove element 'e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TEveViewer.html:24065,undo,undocked,24065,root/html604/TEveViewer.html,https://root.cern,https://root.cern/root/html604/TEveViewer.html,2,['undo'],['undocked']
Usability,"ement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); Float_tCalculateLineLength() const; virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTPointSet3D::ClearIds(); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEvePointSet*TEvePointSet::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEvePointSet::ClonePoints(const TEvePointSet& e); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTPointSet3D::ComputeBBox(); Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveLine.html:2699,Clear,ClearProjectedList,2699,root/html534/TEveLine.html,https://root.cern,https://root.cern/root/html534/TEveLine.html,3,['Clear'],['ClearProjectedList']
Usability,"ement> Use(Int_t nrows, const double* data) const; { return Use(0,nrows-1,data); }. template <class Element> inline TMatrixTSym<Element> &TMatrixTSym<Element> Use(TMatrixTSym<double>& a); { return Use(a.GetRowLwb(),a.GetRowUpb(),a.GetMatrixArray()); }. template <class Element> inline const TMatrixTSym<Element> &TMatrixTSym<Element> Use(const TMatrixTSym<double>& a) const; { return Use(a.GetRowLwb(),a.GetRowUpb(),a.GetMatrixArray()); }. template <class Element> inline TMatrixTSym<Element> TMatrixTSym<Element> GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Option_t* option = ""S"") const. template <class Element> inline Element TMatrixTSym<Element> operator()(Int_t rown, Int_t coln) const. template <class Element> inline Element &TMatrixTSym<Element> operator()(Int_t rown, Int_t coln). void Mult(const TMatrixTSym<double>& a); { TMult(a); }. const Int_t * GetRowIndexArray() const; { return 0; }. Int_t * GetRowIndexArray(); { return 0; }. const Int_t * GetColIndexArray() const; { return 0; }. Int_t * GetColIndexArray(); { return 0; }. TMatrixTBase<Element> & SetRowIndexArray(Int_t* ); { MayNotUse(""SetRowIndexArray(Int_t *)""); return *this; }. TMatrixTBase<Element> & SetColIndexArray(Int_t* ); { MayNotUse(""SetColIndexArray(Int_t *)""); return *this; }. void Clear(Option_t* = """"). Bool_t IsSymmetric() const; { return kTRUE; }. TMatrixTSym <Element> & Use(Int_t row_lwb, Int_t row_upb, double* data). TMatrixTBase<Element> & ResizeTo(Int_t nrows, Int_t ncols, Int_t = -1). const TMatrixTRow_const<Element> operator[](Int_t rown) const; or as a[i][j]. { return TMatrixTRow_const<Element>(*this,rown); }. TMatrixTRow <Element> operator[](Int_t rown); { return TMatrixTRow <Element>(*this,rown); }. » Last changed: root/matrix:$Id: TMatrixTSym.h 34744 2010-08-07 06:16:36Z brun $ » Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMatrixTSym_double_.html:22519,Clear,Clear,22519,root/html532/TMatrixTSym_double_.html,https://root.cern,https://root.cern/root/html532/TMatrixTSym_double_.html,1,['Clear'],['Clear']
Usability,"ement> inline TVectorT<Element> &TVectorT<Element> Use(Int_t n, double* data); { return Use(0,n-1,data); }. template<class Element> inline const TVectorT<Element> &TVectorT<Element> Use(Int_t n, const double* data) const; { return Use(0,n-1,data); }. template<class Element> inline TVectorT<Element> &TVectorT<Element> Use(TVectorT<double>& v). template<class Element> inline const TVectorT<Element> &TVectorT<Element> Use(const TVectorT<double>& v) const. template<class Element> inline TVectorT<Element> TVectorT<Element> GetSub(Int_t row_lwb, Int_t row_upb, Option_t* option = ""S"") const. template<class Element> inline const Element &TVectorT<Element> operator()(Int_t ind) const; Access a vector element. template<class Element> inline Element &TVectorT<Element> operator()(Int_t ind); Access a vector element. Int_t GetLwb() const; { return fRowLwb; }. Int_t GetUpb() const; { return fNrows+fRowLwb-1; }. Int_t GetNrows() const; { return fNrows; }. Int_t GetNoElements() const; { return fNrows; }. Element * GetMatrixArray(); { return fElements; }. const Element * GetMatrixArray() const; { return fElements; }. void Invalidate(); { SetBit(kStatus); }. void MakeValid(); { ResetBit(kStatus); }. Bool_t IsValid() const; { return !TestBit(kStatus); }. Bool_t IsOwner() const; { return fIsOwner; }. void SetElements(const double* elements). TVectorT<Element> & Shift(Int_t row_shift); { fRowLwb += row_shift; return *this; }. TVectorT<Element> & ResizeTo(Int_t lwb, Int_t upb). TVectorT<Element> & ResizeTo(Int_t n); { return ResizeTo(0,n-1); }. TVectorT<Element> & Use(Int_t lwb, Int_t upb, double* data). const Element & operator[](Int_t index) const; { return (*this)(index); }. Element & operator[](Int_t index); { return (*this)(index); }. void Clear(Option_t* = """"). » Last changed: root/matrix:$Id$ » Last generated: 2015-03-15 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVectorT_double_.html:18539,Clear,Clear,18539,root/html534/TVectorT_double_.html,https://root.cern,https://root.cern/root/html534/TVectorT_double_.html,1,['Clear'],['Clear']
Usability,"emented from RooAbsPdf.; Definition at line 55 of file RooChebychev.h. ◆ selectNormalizationRange(). void RooChebychev::selectNormalizationRange ; (; const char * ; rangeName = nullptr, . bool ; force = false . ). overridevirtual . Interface function to force use of a given normalization range to interpret function value. ; Needed for functions or p.d.f.s whose shape depends on the choice of normalization such as RooAddPdf ; Reimplemented from RooAbsReal.; Definition at line 66 of file RooChebychev.cxx. ◆ Streamer(). void RooChebychev::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsPdf. ◆ StreamerNVirtual(). void RooChebychev::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 55 of file RooChebychev.h. ◆ translate(). void RooChebychev::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 93 of file RooChebychev.cxx. Member Data Documentation. ◆ _coefList. RooListProxy RooChebychev::_coefList. private . Definition at line 46 of file RooChebychev.h. ◆ _refRangeName. TNamed* RooChebychev::_refRangeName = nullptr. mutableprivate . Definition at line 47 of file RooChebychev.h. ◆ _x. RooRealProxy RooChebychev::_x. private . Definition at line 45 of file RooChebychev.h. Libraries for RooChebychev:. [legend]; The docu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChebychev.html:78573,simpl,simple,78573,doc/master/classRooChebychev.html,https://root.cern,https://root.cern/doc/master/classRooChebychev.html,1,['simpl'],['simple']
Usability,"emented: meaningful only in the remote player. Returns kFALSE. Bool_t CheckMemUsage(Long64_t& mfreq, Bool_t& w80r, Bool_t& w80v, TString& wmsg); Check the memory usage, if requested.; Return kTRUE if OK, kFALSE if above 95% of at least one between virtual or; resident limits are depassed. Long64_t Finalize(Bool_t force = kFALSE, Bool_t sync = kFALSE); Finalize query (may not be used in this class). Long64_t Finalize(TQueryResult* qr); Finalize query (may not be used in this class). void MergeOutput(); Merge output (may not be used in this class). void MapOutputListToDataMembers() const. void UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); Update automatic binning parameters for given object ""name"". TDSetElement * GetNextPacket(TSlave* slave, TMessage* r); Get next packet (may not be used in this class). void SetupFeedback(); Set up feedback (may not be used in this class). void StopFeedback(); Stop feedback (may not be used in this class). Long64_t DrawSelect(TDSet* set, const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Draw (may not be used in this class). void HandleGetTreeHeader(TMessage* mess); Handle tree header request. void HandleRecvHisto(TMessage* mess); Receive histo from slave. Int_t DrawCanvas(TObject* obj); Draw the object if it is a canvas.; Return 0 in case of success, 1 if it is not a canvas or libProofDraw; is not available. Int_t GetDrawArgs(const char* var, const char* sel, Option_t* opt, TString& selector, TString& objname); Parse the arguments from var, sel and opt and fill the selector and; object name accordingly.; Return 0 in case of success, 1 if libProofDraw is not available. void FeedBackCanvas(const char* name, Bool_t create); Create/destroy a named canvas for feedback. Long64_t GetCacheSize(); Return the size in bytes of the cache. Int_t GetLearnEntries(); Return the number of entries in the l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofPlayer.html:21651,feedback,feedback,21651,root/html602/TProofPlayer.html,https://root.cern,https://root.cern/root/html602/TProofPlayer.html,2,['feedback'],['feedback']
Usability,"en a file.Definition TFile.cxx:4089; TFile::SetCacheFileDirstatic Bool_t SetCacheFileDir(std::string_view cacheDir, Bool_t operateDisconnected=kTRUE, Bool_t forceCacheread=kFALSE)Sets the directory where to locally stage/cache remote files.Definition TFile.cxx:4626; TMVA::DataLoaderDefinition DataLoader.h:50; TMVA::DataLoader::AddSpectatorvoid AddSpectator(const TString &expression, const TString &title="""", const TString &unit="""", Double_t min=0, Double_t max=0)user inserts target in data set infoDefinition DataLoader.cxx:524; TMVA::DataLoader::SetBackgroundWeightExpressionvoid SetBackgroundWeightExpression(const TString &variable)Definition DataLoader.cxx:556; TMVA::DataLoader::AddVariablevoid AddVariable(const TString &expression, const TString &title, const TString &unit, char type='F', Double_t min=0, Double_t max=0)user inserts discriminating variable in data set infoDefinition DataLoader.cxx:485; TMVA::Envelope::BookMethodvirtual void BookMethod(TString methodname, TString methodtitle, TString options="""")Method to book the machine learning method to perform the algorithm.Definition Envelope.cxx:163; TMVA::Experimental::ClassificationDefinition Classification.h:162; TMVA::Experimental::Classification::GetResultsstd::vector< ClassificationResult > & GetResults()Return the vector of TMVA::Experimental::ClassificationResult objects.Definition Classification.cxx:945; TMVA::Experimental::Classification::Evaluatevirtual void Evaluate()Method to perform Train/Test over all ml method booked.Definition Classification.cxx:248; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools.cxx:71; TMVA::Types::kBDT@ kBDTDefinition Types.h:86; TMVA::Types::kSVM@ kSVMDefinition Types.h:89; TMultiGraphA TMultiGraph is a collection of TGraph (or derived) objects.Definition TMultiGraph.h:34; TStringBasic string class.Definition TString.h:139; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a fil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Classification.html:5245,learn,learning,5245,doc/master/classTMVA_1_1Classification.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Classification.html,1,['learn'],['learning']
Usability,"en looping over a TTree with a friend with a larger number of entries, the loop spans all entries in the friend; [#7143] - TTreeProcessorMT: Fails when iterating over different treenames within same ROOT file; [#7039] - TExecutor: handling of non-IMT/… case; [#6933] - ROOT 6.22 should reject TBB 2021.1.1 and above during configuration (fails to compile); [#6765] - PyROOT breaks if ROOT objects are unpickled in a multiprocess environment; [#6915] - roottest-python-regression-regression requires OpenGL but still run when it is disable; [#6472] - TThreadExecutor::Map should be able to accept const std::vector arguments; [#6363] - [IMT] ROOT::GetThreadPoolSize does not reflect tbb::global_control settings; [#7055] - Fatal error after running make install when built against LLVM 9; [#7067] - RooFit RooAbsArg::graphVizTree produces invalid dot files for graph titles including spaces; [#7115] - regex_error when selecting pdf components to plot; [#7164] - TGSpeedo mean value calculation; [#7195] - ROOT crash when parameter by value passed to slot: StrDup; [#7240] - [RF] Batch mode returns broken logarithms when -DVDT=OFF; [#7180] - TGCommandLinePlugin Up-Down Arrows and Tab Keys; [#7181] - RDataFrame Snapshot of friend trees; [#7258] - [RF] Update crystal ball shapes in RooFit; [#7086] - [DF] Section of RDF reference guide about RDF+RVec; [#7182] - Range not considered when computing integral of RooParamHistFunc; [#7547] - [DF] Crash in lazy jitted Snapshot; [#7010] - fifo in $CWD causes TCanvas to hang on macOS; [#7676] - hadd reverses order of object cycles; [#6343] - Problem with using namespace std in generated dictionary files; [#7657] - New dictionary-related crash in 6.24.00-patches; [#7718] - PyROOT in root 6.24 branch hangs while loading CMSSW library; [#7090] - Apple M1: bug in jitting argument of type short; [#6802] - Allow to pass Bearer token authentication header to Davix client; [#7345] - Issue building built-in libafterimage; [#6812] - root REPL problem with ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:44691,guid,guide,44691,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['guid'],['guide']
Usability,"en name. If no such object; is found return a null pointer. TObject* FindObject(const TObject* obj); Find object in list. If list contains object return; (same) pointer to object, otherwise return null pointer. void Clear(Option_t* o = 0); Remove all elements from collection. void Delete(Option_t* o = 0); Remove all elements in collection and delete all elements; NB: Collection does not own elements, this function should; be used judiciously by caller. TObject* find(const char* name) const; Return pointer to object with given name in collection.; If no such object is found, return null pointer. Int_t IndexOf(const TObject* arg); Return position of given object in list. If object; is not contained in list, return -1. Int_t IndexOf(const char* name); Return position of given object in list. If object; is not contained in list, return -1. void Print(const char* opt) const; Print contents of list, defers to Print() function; of contained objects. TIterator* MakeIterator(Bool_t dir = kTRUE) const; Return an iterator over this list. RooLinkedListIter iterator(Bool_t dir = kTRUE) const; Return an iterator over this list. void Sort(Bool_t ascend = kTRUE); Sort elements of this list according to their; TObject::Compare() ranking via a simple; bubble sort algorithm. void swapWithNext(RooLinkedListElem* elem); Swap given to elements in the linked list. Auxiliary function for Sort(). void Streamer(TBuffer& b); Custom streaming handling schema evolution w.r.t past implementations. Int_t getHashTableSize() const; Return size of hash table. Int_t GetSize() const; { return _size ; }. void Add(TObject* arg); { Add(arg,1) ; }. TObject* First() const. const char* GetName() const; { return _name.Data() ; }. void SetName(const char* name); { _name = name ; }. » Last changed: Mon Dec 7 13:48:08 2009 » Last generated: 2009-12-07 13:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooLinkedList.html:8792,simpl,simple,8792,root/html526/RooLinkedList.html,https://root.cern,https://root.cern/root/html526/RooLinkedList.html,1,['simpl'],['simple']
Usability,"en signal efficiencyDefinition MethodCuts.cxx:551; TMVA::MethodCuts::PrintCutsvoid PrintCuts(Double_t effS) constprint cutsDefinition MethodCuts.cxx:465; TMVA::MinuitFitter/Fitter using MINUITDefinition MinuitFitter.h:48; TMVA::PDFPDF wrapper for histograms; uses user-defined spline interpolation.Definition PDF.h:63; TMVA::PDF::kSpline2@ kSpline2Definition PDF.h:70; TMVA::ResultsClass that is the base-class for a vector of result.Definition Results.h:57; TMVA::Results::Storevoid Store(TObject *obj, const char *alias=nullptr)Definition Results.cxx:86; TMVA::Results::GetHistTH1 * GetHist(const TString &alias) constDefinition Results.cxx:136; TMVA::SimulatedAnnealingFitterFitter using a Simulated Annealing Algorithm.Definition SimulatedAnnealingFitter.h:49; TMVA::TSpline1Linear interpolation of TGraph.Definition TSpline1.h:43; TMVA::TimerTiming information for training and evaluation of MVA methods.Definition Timer.h:58; TMVA::Timer::DrawProgressBarvoid DrawProgressBar(Int_t, const TString &comment="""")draws progress bar in color or B&W caution:Definition Timer.cxx:202; TMVA::Tools::ParseFormatLineTList * ParseFormatLine(TString theString, const char *sep="":"")Parse the string and cut into labels separated by "":"".Definition Tools.cxx:401; TMVA::Tools::Colorconst TString & Color(const TString &)human readable color stringsDefinition Tools.cxx:828; TMVA::Tools::ReadAttrvoid ReadAttr(void *node, const char *, T &value)read attribute from xmlDefinition Tools.h:329; TMVA::Tools::AddCommentBool_t AddComment(void *node, const char *comment)Definition Tools.cxx:1132; TMVA::Tools::GetChildvoid * GetChild(void *parent, const char *childname=nullptr)get child nodeDefinition Tools.cxx:1150; TMVA::Tools::AddAttrvoid AddAttr(void *node, const char *, const T &value, Int_t precision=16)add attribute to xmlDefinition Tools.h:347; TMVA::Tools::AddChildvoid * AddChild(void *parent, const char *childname, const char *content=nullptr, bool isRootNode=false)add child nodeDefinition Tools.cxx",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodCuts_8cxx_source.html:83685,progress bar,progress bar,83685,doc/master/MethodCuts_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodCuts_8cxx_source.html,1,['progress bar'],['progress bar']
Usability,"en to disk, nor is there any streamerinfo for such a member.; A data member that is a C++ pointer (not to be confused with ""pointers to persistent; objects"" described below) is never written to disk as a pointer value. If it is a pointer to an object, the object itself (or 0 (4 bytes) if the pointer value is NULL) is written. If the declaration line has a comment beginning with ""//->"", this indicates that the pointer value will never be null, which allows a performance optimization. Another optimization is that if two or more pointers pointing to the same object are streamed in the same I/O operation, the object is written only once. The remaining pointers reference the object through a unique object identifier. This saves space and avoids the infinite loop that might otherwise arise if the directed graph of object instance pointer references contains a cycle.; If a data member is a pointer to a simple type, the Streamer presumes it is an array, with the dimension defined in a comment of the form ""//[<length>]"", where length is either an integer constant or a variable that is an integer data member of the class. If a variable is used, it must be defined ahead of its use or in a base class.; The above describes the function of the StreamerInfo record in decomposing a self-identifying object if the user uses the streamer generated by ""rootcint"". There are two reasons why a user may need to write a specialized streamer for a class. One reason is that it may be necessary to execute some code before or after data is read or written, for example, to initialize some non-persistent data members after the persistent data is read. In this case, the custom streamer can use the StreamerInfo record to decompose a self-identifying object in the exact same manner as the generated streamer would have done. An example is given (for the Event class) in the Root User's Guide (URL below) (Input/Output chapter, Streamers subchapter). On the other hand, if the user needs to write a stream",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootio.html:8991,simpl,simple,8991,doc/master/rootio.html,https://root.cern,https://root.cern/doc/master/rootio.html,1,['simpl'],['simple']
Usability,"en to the buffer directly. Eventually the buffer contains all simple data members of all the classes that make up this particular object. Data members that are references (as MyClass &fObj;) are never saved, it is always the responsibility of the object’s constructor to set them properly.; 11.3.1 Automatically Generated Streamers; A Streamerusually calls other Streamers: the Streamerof its parents and data members. This architecture depends on all classes having Streamers, because eventually they will be called. To ensure that a class has a Streamer, rootcling automatically creates one in the ClassDef macro that is defined in $ROOTSYS/include/Rtypes.h. ClassDef defines several methods for any class, and one of them is the Streamer. The automatically generated Streameris complete and can be used as long as no customization is needed.; The Event class is defined in $ROOTSYS/test/Event.h. Looking at the class definition, we find that it inherits from TObject. It is a simple example of a class with diverse data members.; class Event : public TObject {; private:; TDirectory *fTransient; //! current directory; Float_t fPt; //! transient value; char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; UInt_t fFlag;; Float_t fTemperature;; EventHeader fEvtHdr; //|| don't split; TClonesArray *fTracks; //->; TH1F *fH; //->; Int_t fMeasures[10];; Float_t fMatrix[4][4];; Float_t *fClosestDistance; //[fNvertex]; ...; The Event class is added to the dictionary by the rootcling utility. This is the rootcling statement in the $ROOTSYS/test/Makefile:; @rootcling -f EventDict.cxx -c Event.h EventLinkDef.h; The EventDict.cxx file contains the automatically generated Streamerfor Event:; void Event::Streamer(TBuffer &R__b){; // Stream an object of class Event.; if (R__b.IsReading()) {; Event::Class()->ReadBuffer(R__b, this);; } else {; Event::Class()->WriteBuffer(R__b, this);; }; }; When writing an Event object, TClass::WriteBuffer is called. WriteBuffer writes the current version ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:467773,simpl,simple,467773,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"en(""root://my.server.org/data/file.root"",""new""); root[] TFile *f3 = TFile::Open(""http://root.cern.ch/files/hsimple.root""); root[] f3.ls(); TDavixFile** http://root.cern.ch/files/hsimple.root; TDavixFile* http://root.cern.ch/files/hsimple.root; KEY: TH1F hpx;1 This is the px distribution; KEY: TH2F hpxpy;1 py vs px; KEY: TProfile hprof;1 Profile of pz versus px; KEY: TNtuple ntuple;1 Demo ntuple; root[] hpx.Draw(); 11.8 XML Interface; A new module xml as implemented by Sergey Linev (GSI). It is an optional package that can be used to save a canvas into file.xml file format instead of file.root. XML files do not have any advantages compared to the normal ROOT files, except that the information in these files can be edited via a normal editor. The main motivation for this new format is to facilitate the communication with other non ROOT applications. Currently writing and reading XML files is limited to ROOT applications. It is our intention to develop a simple reader independent of the ROOT libraries that could be used as an example for real applications.; The XML format should be used only for small data volumes, typically histogram files, pictures, geometries, calibrations. The XML file is built in memory before being dumped to disk. Like for normal ROOT files, XML files use the same I/O mechanism exploiting the ROOT/Cling dictionary. Any class having a dictionary can be saved in XML format. This first implementation does not support subdirectories or trees.; The shared library libRXML.so may be loaded dynamically via gSystem->Load(""libRXML""). This library is also automatically loaded by the plug-in manager as soon a XML file is created. To create an XTM file, simply specify a filename with an .xml extension when calling TFile::Open. TFile::Open will recognize that you are trying to open an XML file and return a TXMLFile object. When a XML file is open in write mode, one can use the normal TObject::Write to write an object in the file.; // example of a session saving",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:517893,simpl,simple,517893,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"enFile(filename);; let obj = await file.readObject(""hpxpy;1"");; await draw(""drawing"", obj, ""colz"");; </script>; Here the default location https://root.cern/js/latest/ is specified. One always can install JSROOT on private web server. When JSROOT is used with THttpServer, the address looks like:; <script type='module'>; import { httpRequest, draw } from 'http://your_root_server:8080/jsrootsys/modules/main.mjs';; let obj = await httpRequest('http://your_root_server:8080/Objects/hist/root.json','object');; await draw('drawing', obj, 'hist');; </script>; Loading main module is enough to get public JSROOT functionality - reading files and drawing objects. One also can load some special components directly like:; <script type='module'>; import { HierarchyPainter } from 'https://root.cern/js/latest/modules/gui.mjs';. let h = new HierarchyPainter(""example"", ""myTreeDiv"");. // configure 'simple' in provided <div> element; // one also can specify ""grid2x2"" or ""flex"" or ""tabs""; h.setDisplay(""simple"", ""myMainDiv"");. // open file and display element; await h.openRootFile('../../files/hsimple.root');; await h.display('hpxpy;1"",""colz');; </script>; After script loading one can configure different parameters in gStyle object. It is instance of the TStyle object and behaves like gStyle variable in ROOT. For instance, to change stat format using to display value in stats box:; import { gStyle } from 'https://root.cern/js/latest/modules/main.mjs';; gStyle.fStatFormat = '7.5g';; There is also settings object which contains all other JSROOT settings. For instance, one can configure custom format for different axes:; import { settings } from 'https://root.cern/js/latest/modules/main.mjs';; settings.XValuesFormat = '4.2g';; settings.YValuesFormat = '6.1f';; One also can use build/jsroot.js bundle to load all functionality at one and access it via JSROOT global handle:; <script src=""https://root.cern/js/latest/build/jsroot.js""></script>; <script>; // getting json string from somewhere; let o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:24060,simpl,simple,24060,root/htmldoc/guides/JSROOT/JSROOT.html,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html,2,['simpl'],['simple']
Usability,"ename = ""https://root.cern/js/files/hsimple.root"";; let file = await openFile(filename);; let obj = await file.readObject(""hpxpy;1"");; await draw(""drawing"", obj, ""colz"");; </script>; Here the default location https://root.cern/js/latest/ is specified. One always can install JSROOT on private web server. When JSROOT is used with THttpServer, the address looks like:; <script type='module'>; import { httpRequest, draw } from 'http://your_root_server:8080/jsrootsys/modules/main.mjs';; let obj = await httpRequest('http://your_root_server:8080/Objects/hist/root.json','object');; await draw('drawing', obj, 'hist');; </script>; Loading main module is enough to get public JSROOT functionality - reading files and drawing objects. One also can load some special components directly like:; <script type='module'>; import { HierarchyPainter } from 'https://root.cern/js/latest/modules/gui.mjs';. let h = new HierarchyPainter(""example"", ""myTreeDiv"");. // configure 'simple' in provided <div> element; // one also can specify ""grid2x2"" or ""flex"" or ""tabs""; h.setDisplay(""simple"", ""myMainDiv"");. // open file and display element; await h.openRootFile('../../files/hsimple.root');; await h.display('hpxpy;1"",""colz');; </script>; After script loading one can configure different parameters in gStyle object. It is instance of the TStyle object and behaves like gStyle variable in ROOT. For instance, to change stat format using to display value in stats box:; import { gStyle } from 'https://root.cern/js/latest/modules/main.mjs';; gStyle.fStatFormat = '7.5g';; There is also settings object which contains all other JSROOT settings. For instance, one can configure custom format for different axes:; import { settings } from 'https://root.cern/js/latest/modules/main.mjs';; settings.XValuesFormat = '4.2g';; settings.YValuesFormat = '6.1f';; One also can use build/jsroot.js bundle to load all functionality at one and access it via JSROOT global handle:; <script src=""https://root.cern/js/latest/build/jsroo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:23956,simpl,simple,23956,root/htmldoc/guides/JSROOT/JSROOT.html,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html,2,['simpl'],['simple']
Usability,"ename DeepNet_t = TDeepNet<Architecture_t, Layer_t>>; class TMVA::DNN::TAdagrad< Architecture_t, Layer_t, DeepNet_t >Adagrad Optimizer class. ; This class represents the Adagrad Optimizer. ; Definition at line 45 of file Adagrad.h. Public Types; using Matrix_t = typename Architecture_t::Matrix_t;  ; using Scalar_t = typename Architecture_t::Scalar_t;  ;  Public Types inherited from TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >; using Matrix_t = typename Architecture_t::Matrix_t;  ; using Scalar_t = typename Architecture_t::Scalar_t;  . Public Member Functions;  TAdagrad (DeepNet_t &deepNet, Scalar_t learningRate=0.01, Scalar_t epsilon=1e-8);  Constructor. ;  ;  ~TAdagrad ()=default;  Destructor. ;  ; Scalar_t GetEpsilon () const;  Getters. ;  ; std::vector< std::vector< Matrix_t > > & GetPastSquaredBiasGradients ();  ; std::vector< Matrix_t > & GetPastSquaredBiasGradientsAt (size_t i);  ; std::vector< std::vector< Matrix_t > > & GetPastSquaredWeightGradients ();  ; std::vector< Matrix_t > & GetPastSquaredWeightGradientsAt (size_t i);  ;  Public Member Functions inherited from TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >;  VOptimizer (Scalar_t learningRate, DeepNet_t &deepNet);  Constructor. ;  ; virtual ~VOptimizer ()=default;  Virtual Destructor. ;  ; size_t GetGlobalStep () const;  ; Layer_t * GetLayerAt (size_t i);  ; std::vector< Layer_t * > & GetLayers ();  ; Scalar_t GetLearningRate () const;  Getters. ;  ; void IncrementGlobalStep ();  Increments the global step. ;  ; void SetLearningRate (size_t learningRate);  Setters. ;  ; void Step ();  Performs one step of optimization. ;  . Protected Member Functions; void UpdateBiases (size_t layerIndex, std::vector< Matrix_t > &biases, const std::vector< Matrix_t > &biasGradients);  Update the biases, given the current bias gradients. ;  ; void UpdateWeights (size_t layerIndex, std::vector< Matrix_t > &weights, const std::vector< Matrix_t > &weightGradients);  Update the weights, given the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdagrad.html:1678,learn,learningRate,1678,doc/master/classTMVA_1_1DNN_1_1TAdagrad.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdagrad.html,1,['learn'],['learningRate']
Usability,"ence< Real_t >::SymmetricReluDerivative ; (; TMatrixT< AReal > & ; B, . const TMatrixT< AReal > & ; A . ). inlinestatic . Definition at line 157 of file ActivationFunctions.hxx. ◆ Tanh(). template<typename AReal > . void TMVA::DNN::TReference< Real_t >::Tanh ; (; TMatrixT< AReal > & ; B). inlinestatic . Definition at line 109 of file ActivationFunctions.hxx. ◆ TanhDerivative(). template<typename AReal > . void TMVA::DNN::TReference< Real_t >::TanhDerivative ; (; TMatrixT< AReal > & ; B, . const TMatrixT< AReal > & ; A . ). inlinestatic . Definition at line 125 of file ActivationFunctions.hxx. ◆ UpdateParams(). template<typename AReal > . void TMVA::DNN::TReference< Real_t >::UpdateParams ; (; TMatrixT< AReal > & ; x, . TMatrixT< AReal > & ; tildeX, . TMatrixT< AReal > & ; y, . TMatrixT< AReal > & ; z, . TMatrixT< AReal > & ; fVBiases, . TMatrixT< AReal > & ; fHBiases, . TMatrixT< AReal > & ; fWeights, . TMatrixT< AReal > & ; VBiasError, . TMatrixT< AReal > & ; HBiasError, . AReal ; learningRate, . size_t ; fBatchSize . ). static . Definition at line 48 of file DenoisePropagation.hxx. ◆ UpdateParamsLogReg(). template<typename AReal > . void TMVA::DNN::TReference< Real_t >::UpdateParamsLogReg ; (; TMatrixT< AReal > & ; input, . TMatrixT< AReal > & ; output, . TMatrixT< AReal > & ; difference, . TMatrixT< AReal > & ; p, . TMatrixT< AReal > & ; fWeights, . TMatrixT< AReal > & ; fBiases, . AReal ; learningRate, . size_t ; fBatchSize . ). static . Definition at line 191 of file DenoisePropagation.hxx. Member Data Documentation. ◆ fgRandomGen. template<typename Real_t > . TRandom * TMVA::DNN::TReference< Real_t >::fgRandomGen = nullptr. staticprivate . Definition at line 55 of file Reference.h. tmva/tmva/inc/TMVA/DNN/Architectures/Reference.h; tmva/tmva/src/DNN/Architectures/Reference/ActivationFunctions.hxx; tmva/tmva/src/DNN/Architectures/Reference/Arithmetic.hxx; tmva/tmva/src/DNN/Architectures/Reference/DenoisePropagation.hxx; tmva/tmva/src/DNN/Architectures/Reference/",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TReference.html:45581,learn,learningRate,45581,doc/master/classTMVA_1_1DNN_1_1TReference.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TReference.html,1,['learn'],['learningRate']
Usability,"enceSteps ; (; size_t ; steps). inline . Setters. ; Definition at line 153 of file DLMinimizers.h. ◆ SetLearningRate(). template<typename Architecture_t > . void TMVA::DNN::TDLGradientDescent< Architecture_t >::SetLearningRate ; (; Scalar_t ; rate). inline . Definition at line 155 of file DLMinimizers.h. ◆ SetTestInterval(). template<typename Architecture_t > . void TMVA::DNN::TDLGradientDescent< Architecture_t >::SetTestInterval ; (; size_t ; interval). inline . Definition at line 154 of file DLMinimizers.h. ◆ Step() [1/2]. template<typename Architecture_t > . void TMVA::DNN::TDLGradientDescent< Architecture_t >::Step ; (; DeepNet_t & ; deepNet, . std::vector< Matrix_t > & ; input, . const Matrix_t & ; output, . const Matrix_t & ; weights . ). Perform a single optimization step on a given batch. ; Propagates the input matrix forward through the net, evaluates the loss and propagates the gradients backward through the net. The computed gradients are scaled by the learning rate \(\alpha\) and subtracted from the weights and bias values of each layer. ; Definition at line 182 of file DLMinimizers.h. ◆ Step() [2/2]. template<typename Architecture_t > . void TMVA::DNN::TDLGradientDescent< Architecture_t >::Step ; (; DeepNet_t & ; master, . std::vector< DeepNet_t > & ; nets, . std::vector< TTensorBatch< Architecture_t > > & ; batches . ). Perform multiple optimization steps simultaneously. ; Performs the backprop algorithm on the input batches given in batches on the neural networks given in nets. The forward and backward propagation steps are executed in an interleaving manner in order to exploit potential batch-level parallelism for asynchronous device calls. ; Definition at line 246 of file DLMinimizers.h. ◆ StepLoss(). template<typename Architecture_t > . auto TMVA::DNN::TDLGradientDescent< Architecture_t >::StepLoss ; (; DeepNet_t & ; deepNet, . std::vector< Matrix_t > & ; input, . const Matrix_t & ; output, . const Matrix_t & ; weights . ). Same as Step(...) but als",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDLGradientDescent.html:8257,learn,learning,8257,doc/master/classTMVA_1_1DNN_1_1TDLGradientDescent.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDLGradientDescent.html,1,['learn'],['learning']
Usability,ency of the filters applied ;  df004_cutFlowReport.py This tutorial shows how to get information about the efficiency of the filters applied ;  df005_fillAnyObject.C This tutorial shows how to fill any object the class of which exposes a Fill method ;  df006_ranges.C This tutorial shows how to express the concept of ranges when working with the RDataFrame ;  df006_ranges.py This tutorial shows how to express the concept of ranges when working with the RDataFrame ;  df007_snapshot.C This tutorial shows how to write out datasets in ROOT formatusing the RDataFrame ;  df007_snapshot.py This tutorial shows how to write out datasets in ROOT formatusing the RDataFrame ;  df008_createDataSetFromScratch.C This tutorial shows how to create a dataset from scratch with RDataFrame ;  df008_createDataSetFromScratch.py This tutorial shows how to create a dataset from scratch with RDataFrame ;  df009_FromScratchVSTTree.C This tutorial illustrates how simpler it can be to use a RDataFrame to create a dataset with respect to the usage of the TTree interfaces ;  df010_trivialDataSource.C This tutorial illustrates how use the RDataFrame in combination with a RDataSource ;  df010_trivialDataSource.py This tutorial illustrates how use the RDataFrame in combination with a RDataSource ;  df011_ROOTDataSource.C This tutorial illustrates how use the RDataFrame in combination with a RDataSource ;  df011_ROOTDataSource.py This tutorial illustrates how use the RDataFrame in combination with a RDataSource ;  df012_DefinesAndFiltersAsStrings.C ;  df012_DefinesAndFiltersAsStrings.py ;  df013_InspectAnalysis.C Showcase registration of callback functions that act on partial results while the event-loop is running using OnPartialResult and OnPartialResultSlot ;  df014_CSVDataSource.C This tutorial illustrates how use the RDataFrame in combination with a RDataSource ;  df014_CSVDataSource.py This tutorial illustrates how use the RDataFrame in combination with a RDataSource ;  df015_LazyDataSource.C Thi,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:99525,simpl,simpler,99525,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['simpl'],['simpler']
Usability,"ency"" and label the axis pEff->SetTitle(""My Efficiency;x label;eff""); ; Reimplemented from TNamed.; Definition at line 3726 of file TEfficiency.cxx. ◆ SetTotalEvents(). Bool_t TEfficiency::SetTotalEvents ; (; Int_t ; bin, . Double_t ; events . ). Sets the number of total events in the given global bin. ; returns ""true"" if the number of total events has been updated otherwise ""false"" ist returned; Note: - requires: fPassedHistogram->GetBinContent(bin) <= events ; Definition at line 3760 of file TEfficiency.cxx. ◆ SetTotalHistogram(). Bool_t TEfficiency::SetTotalHistogram ; (; const TH1 & ; rTotal, . Option_t * ; opt . ). Sets the histogram containing all events. ; The given histogram is cloned and stored internally as histogram containing all events. The given histogram has to be consistent with the current fPassedHistogram (see CheckConsistency(const TH1&,const TH1&)). The method returns whether the fTotalHistogram has been replaced (true) or not (false).; Note: The list of associated functions fFunctions is cleared.; Option:; ""f"": force the replacement without checking the consistency This can lead to inconsistent histograms and useless results or unexpected behaviour. But sometimes it might be the only way to change the histograms. If you use this option, you should ensure that the fPassedHistogram is replaced by a consistent one (with respect to rTotal) as well. . Definition at line 3791 of file TEfficiency.cxx. ◆ SetUseWeightedEvents(). void TEfficiency::SetUseWeightedEvents ; (; Bool_t ; on = kTRUE). Definition at line 3825 of file TEfficiency.cxx. ◆ SetWeight(). void TEfficiency::SetWeight ; (; Double_t ; weight). Sets the global weight for this TEfficiency object. ; Note: - weight has to be positive ( > 0) ; Definition at line 3843 of file TEfficiency.cxx. ◆ Streamer(). void TEfficiency::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TEfficiency::StreamerNVirtual ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEfficiency.html:112396,clear,cleared,112396,doc/master/classTEfficiency.html,https://root.cern,https://root.cern/doc/master/classTEfficiency.html,1,['clear'],['cleared']
Usability,"end feedback objects to client. ;  ; Int_t InitPacketizer (TDSet *dset, Long64_t nentries, Long64_t first, const char *defpackunit, const char *defpackdata);  Init the packetizer Return 0 on success (fPacketizer is correctly initialized), -1 on failure. ;  ; TList * MergeFeedback ();  Merge feedback lists. ;  ; Bool_t MergeOutputFiles ();  Merge output in files. ;  ; void NotifyMemory (TObject *obj);  Printout the memory record after merging object 'obj' This record is used by the memory monitor. ;  ; virtual Bool_t SendSelector (const char *selector_file);  Send the selector file(s) to master or worker nodes. ;  ; void SetLastMergingMsg (TObject *obj);  Set the message to be notified in case of exception. ;  ; void SetSelectorDataMembersFromOutputList ();  Set the selector's data members: find the mapping of data members to otuput list entries in the output list and apply it. ;  ; void SetupFeedback () override;  Setup reporting of feedback objects. ;  ; void StopFeedback () override;  Stop reporting of feedback objects. ;  ;  Protected Member Functions inherited from TProofPlayer; Int_t AssertSelector (const char *selector_file);  Make sure that a valid selector object Return -1 in case of problems, 0 otherwise. ;  ; Bool_t CheckMemUsage (Long64_t &mfreq, Bool_t &w80r, Bool_t &w80v, TString &wmsg);  Check the memory usage, if requested. ;  ; virtual Int_t DrawCanvas (TObject *obj);  Draw the object if it is a canvas. ;  ; void * GetSender () override;  ; void MapOutputListToDataMembers () const;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TQObject; virtual const char * GetSenderClassName () const;  . Additional Inherited Members;  Public Types inherited from TProofPlayer; enum  EStatusBits { kDispatchOneEvent = (1ULL << ( 15 )); , kIsProcessing = (1ULL << ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerLite.html:22125,feedback,feedback,22125,doc/master/classTProofPlayerLite.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerLite.html,1,['feedback'],['feedback']
Usability,"end feedback objects to client. ;  ; Int_t InitPacketizer (TDSet *dset, Long64_t nentries, Long64_t first, const char *defpackunit, const char *defpackdata);  Init the packetizer Return 0 on success (fPacketizer is correctly initialized), -1 on failure. ;  ; TList * MergeFeedback ();  Merge feedback lists. ;  ; Bool_t MergeOutputFiles ();  Merge output in files. ;  ; void NotifyMemory (TObject *obj);  Printout the memory record after merging object 'obj' This record is used by the memory monitor. ;  ; virtual Bool_t SendSelector (const char *selector_file);  Send the selector file(s) to master or worker nodes. ;  ; void SetLastMergingMsg (TObject *obj);  Set the message to be notified in case of exception. ;  ; void SetSelectorDataMembersFromOutputList ();  Set the selector's data members: find the mapping of data members to otuput list entries in the output list and apply it. ;  ; void SetupFeedback () override;  Setup reporting of feedback objects. ;  ; void StopFeedback () override;  Stop reporting of feedback objects. ;  ;  Protected Member Functions inherited from TProofPlayer; Int_t AssertSelector (const char *selector_file);  Make sure that a valid selector object Return -1 in case of problems, 0 otherwise. ;  ; Bool_t CheckMemUsage (Long64_t &mfreq, Bool_t &w80r, Bool_t &w80v, TString &wmsg);  Check the memory usage, if requested. ;  ; virtual Int_t DrawCanvas (TObject *obj);  Draw the object if it is a canvas. ;  ; void * GetSender () override;  ; void MapOutputListToDataMembers () const;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TQObject; virtual const char * GetSenderClassName () const;  . Protected Attributes; TDSet * fDSet;  ; ErrorHandlerFunc_t fErrorHandler;  tdset for current processing ;  ; TList * fFeedback;  ; TList * fFeedbackLists;  ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerRemote.html:20418,feedback,feedback,20418,doc/master/classTProofPlayerRemote.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerRemote.html,1,['feedback'],['feedback']
Usability,"ensible default value here; auto df_default = df.DefaultValueFor(""col"", default_value).Define(""twice"", ""col * 2"");; auto df_filtered = df.FilterAvailable(""col"").Define(""twice"", ""col * 2"");; ; // Same number of total entries as the input dataset, with defaulted values; df_default.Display({""twice""})->Print();; // Only keep the entries where ""col"" has values; df_filtered.Display({""twice""})->Print();; Further considerations; Note that working with missing values is currently supported with a TTree-based data source. Support of this functionality for other data sources may come in the future. Efficient analysis in Python; You can use RDataFrame in Python thanks to the dynamic Python/C++ translation of PyROOT. In general, the interface is the same as for C++, a simple example follows.; df = ROOT.RDataFrame(""myTree"", ""myFile.root""); sum = df.Filter(""x > 10"").Sum(""y""); print(sum.GetValue()). User code in the RDataFrame workflow; C++ code; In the simple example that was shown above, a C++ expression is passed to the Filter() operation as a string (""x > 0""), even if we call the method from Python. Indeed, under the hood, the analysis computations run in C++, while Python is just the interface language.; To perform more complex operations that don't fit into a simple expression string, you can just-in-time compile C++ functions - via the C++ interpreter cling - and use those functions in an expression. See the following snippet for an example:; # JIT a C++ function from Python; ROOT.gInterpreter.Declare(""""""; bool myFilter(float x) {; return x > 10;; }; """"""); ; df = ROOT.RDataFrame(""myTree"", ""myFile.root""); # Use the function in an RDF operation; sum = df.Filter(""myFilter(x)"").Sum(""y""); print(sum.GetValue()); To increase the performance even further, you can also pre-compile a C++ library with full code optimizations and load the function into the RDataFrame computation as follows.; ROOT.gSystem.Load(""path/to/myLibrary.so"") # Library with the myFilter function; ROOT.gInterprete",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDataFrame.html:86817,simpl,simple,86817,doc/master/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDataFrame.html,1,['simpl'],['simple']
Usability,"ent = kFALSE, TList* wrks = 0); voidTProof::AddInput(TObject* obj); voidTProof::AddInputData(TObject* obj, Bool_t push = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); Int_tTProof::Archive(Int_t query, const char* url); Int_tTProof::Archive(const char* queryref, const char* url = 0); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTProof::Browse(TBrowser* b); voidTProof::cd(Int_t id = -1); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; Int_tTProof::CleanupSession(const char* sessiontag); virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTProof::ClearCache(const char* file = 0); voidTProof::ClearData(UInt_t what = kUnregistered, const char* dsname = 0); virtual voidTProof::ClearDataSetCache(const char* dataset = 0); voidTProof::ClearFeedback(); voidTProof::ClearInput(); voidTProof::ClearInputData(TObject* obj = 0); voidTProof::ClearInputData(const char* name); Int_tTProof::ClearPackage(const char* package); Int_tTProof::ClearPackages(); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTProof::Close(Option_t* option = """"); voidTProof::CloseProgressDialog()SIGNAL ; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual voidTNamed::Copy(TObject& named) const; TDrawFeedback*TProof::CreateDrawFeedback(); voidTProo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofCondor.html:2189,Clear,ClearFeedback,2189,root/html532/TProofCondor.html,https://root.cern,https://root.cern/root/html532/TProofCondor.html,2,['Clear'],['ClearFeedback']
Usability,"ent Tree branches. When a top level object (eg Event *event) is a tree/graph of many objects,; the normal ROOT Streaming mechanism ensures that only one copy of each object; in the tree/graph is written to the output buffer to avoid circular; dependencies.; However if the object event is split into several files or into several; branches of one or more Trees, normal C++ pointers cannot be used because; each I/O operation will write the referenced objects.; When a TRef is used to point to a TObject *robj, for example in a class with; TRef fRef;; one can do:; fRef = robj; //to set the pointer; This TRef and robj can be written with two different I/O calls; in the same or different files, in the same or different branches of a Tree. If the TRef is read and the referenced object has not yet been read,; the TRef will return a null pointer. As soon as the referenced object; will be read, the TRef will point to it. If the referenced object is; contained in a TTree it can be autoloaded using the TBranchRef mechanism,; which is set up by simply calling TTree::BranchRef(). TRef also supports the complex situation where a TFile is updated; multiple times on the same machine or a different machine. How does it work. A TRef is itself a TObject with an additional transient pointer fPID.; When the statement fRef = robj is executed, the following actions happen:; - The pointer fPID is set to the current TProcessID.; - The current ObjectNumber (see below) is incremented by one.; - robj::fUniqueID is set to ObjectNumber.; - In the fPID object, the element fObjects[ObjectNumber] is set to robj; - ref::fUniqueID is also set to ObjectNumber.; After having set fRef, one can immediatly return the value of robj; using fRef.GetObject(). This function returns directly fObjects[fUniqueID]; from the fPID object. When the TRef is written, the process id number pidf of fPID is written; in addition to the TObject part of TRef (fBits,fUniqueID).; When the TRef is read, its pointer fPID is set to t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRef.html:1616,simpl,simply,1616,root/html528/TRef.html,https://root.cern,https://root.cern/root/html528/TRef.html,10,['simpl'],['simply']
Usability,"ent direction (nx,ny,nz). This direction is stored as Double_t fCurrentDirection[3] by the navigator and it represents a direction in the global frame. It can be retrieved with:; Const Double_t *cdir = gGeoManager->GetCurrentDirection();; TGeoManager::GetCurrentDirectionconst Double_t * GetCurrentDirection() constDefinition TGeoManager.h:502; The direction can be initialized in a similar manner as the current point:; gGeoManager->SetCurrentDirection(nx,ny,nz);; // or:; gGeoManager->SetCurrentDirection(Double_t *dir);; TGeoManager::SetCurrentDirectionvoid SetCurrentDirection(Double_t *dir)Definition TGeoManager.h:518. Initializing the State; Setting the initial point and direction is not enough for initializing tracking. The modeller needs to find out where the initial point is located in the geometrical hierarchy. Due to the containment based architecture of the model, this is the deepest positioned object containing the point. For illustrating this, imagine that we have a simple structure with a top volume A and another one Bpositioned inside. Since Ais a top volume, its associated node A_1 will define MARS and our simple hierarchy of nodes (positioned volumes) will be: /A_1/B_1. Suppose now that the initial point is contained by B_1. This implies by default that the point is also contained by A_1, since B_1 have to be fully contained by this. After searching the point location, the modeller will consider that the point is located inside B_1, which will be considered as the representative object (node) for the current state. This is stored as: TGeoNode *TGeoNavigator::fCurrentNode and can be asked from the manager class only after the ‘'Where am I?’` was completed:; TGeoNode *current = gGeoManager->GetCurrentNode();; TGeoManager::GetCurrentNodeTGeoNode * GetCurrentNode() constDefinition TGeoManager.h:499; In order to find the location of the current point inside the hierarchy of nodes, after setting this point it is mandatory to call the ‘‘Where am I?’` method:; gGe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:70688,simpl,simple,70688,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['simpl'],['simple']
Usability,"ent variables seen so far. void ClearFiles(); Close all files. void ClearGlobalFunctions(); Forget all global functions seen so far.; Not needed anymore. Use gROOT->GetListOfGlobalFunctions(). void ClearGlobals(); Forget all global variables seen so far.; With teh new implamentation the list is gROOT->GetListOfGlobals(true). void ClearPragmas(); Forget all pragmas seen so far. void ClearSysIncFiles(); Close system files. void ClearUsers(); Forget all user seen so far. void ClearAll(); clears all lists; except for user names and system include files. void RehashClasses(); Do the class rehash. void RehashCppDirectives(); Cpp rehashing. void RehashEnvVars(); Environemnt variables rehashing. void RehashFiles(); Close files. void RehashGlobalFunctions(); Reload global functions. void RehashGlobals(); Reload globals. void RehashPragmas(); Reload pragmas. void RehashSysIncFiles(); Reload system include files. void RehashUsers(); Reload users. void RehashAll(); clears and then rebuilds all lists; except for user names and system include files. const TSeqCollection * GetListOfClasses(); Return the list of classes. const TSeqCollection * GetListOfCppDirectives(); Return the list of CPP directives. const TSeqCollection * GetListOfFilesInPath(const char[] path); ""path"" should be initialized with a colon separated list of; system directories. const TSeqCollection * GetListOfEnvVars(); Uses ""env"" (Unix) or ""set"" (Windows) to get list of environment variables. const TSeqCollection * GetListOfGlobals(); Return the list of globals. TCollection * GetListOfGlobalFunctions(); Return the list of global functions. const TSeqCollection * GetListOfPragmas(); Return the list of pragmas. const TSeqCollection * GetListOfSysIncFiles(); Return the list of system include files. const TSeqCollection * GetListOfUsers(); reads from ""/etc/passwd"". Char_t AllAgreeOnChar(int i, const TSeqCollection* pList, Int_t& nGoodStrings); [static utility function]. if all the strings in ""*pList"" have the same it",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTabCom.html:8729,clear,clears,8729,root/html602/TTabCom.html,https://root.cern,https://root.cern/root/html602/TTabCom.html,4,['clear'],['clears']
Usability,"ent); TList*fUnAllocatednodes with unallocated files. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPacketizerAdaptive(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Constructor. ~TPacketizerAdaptive(); Destructor. void InitStats(); (re)initialise the statistics; called at the begining or after a worker dies. void RemoveUnAllocNode(TPacketizerAdaptive::TFileNode* ); Remove unallocated node. void RemoveActive(TPacketizerAdaptive::TFileStat* file); Remove file from the list of actives. void RemoveActiveNode(TPacketizerAdaptive::TFileNode* ); Remove node from the list of actives. void Reset(); Reset the internal data structure for packet distribution. void ValidateFiles(TDSet* dset, TList* slaves, Long64_t maxent = -1, Bool_t byfile = kFALSE); Check existence of file/dir/tree an get number of entries.; Assumes the files have been setup. Int_t CalculatePacketSize(TObject* slstat, Long64_t cachesz, Int_t learnent); The result depends on the fStrategy. Int_t AddProcessed(TSlave* sl, TProofProgressStatus* st, Double_t latency, TList** listOfMissingFiles = 0); To be used by GetNextPacket but also in reaction to kPROOF_STOPPROCESS; message (when the worker was asked to stop processing during a packet).; returns the #entries intended in the last packet - #processed entries. TDSetElement * GetNextPacket(TSlave* sl, TMessage* r); Get next packet;; A meaningfull difference to TPacketizer is the fact that this; packetizer, for each worker, tries to predict whether the worker; will finish processing it's local files before the end of the query.; If yes, it allocates, to those workers, files from non-slave filenodes; or from slaves that are overloaded. The check is done every time a new; file needs to be assigned. Int_t GetActiveWorkers(); Return the number of workers still processing. Float_t GetCurrentRate(Bool_t& all); Get Estimation of the current rate; just summing the current rate",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TPacketizerAdaptive.html:12588,learn,learnent,12588,root/html530/TPacketizerAdaptive.html,https://root.cern,https://root.cern/root/html530/TPacketizerAdaptive.html,9,['learn'],['learnent']
Usability,"ent* re); virtual voidAddStamp(UChar_t bits); virtual voidTEveElement::Annihilate(); virtual voidTEveElement::AnnihilateElements(); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTEveElement::ApplyVizTag(const TString& tag, const TString& fallback_tag = """"); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElement*TEveElement::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTEveElement::CopyVizParams(const TEveElement* el); virtual voidTEveElement::CopyVizParamsFromDB(); voidTEveElement::CSCApplyMainColorToAllChildren(); voidTEveElement::CSCApplyMainColorToMatchingChildren(); voidTEveElement::CSCApplyMainTransparencyToAllChildren(); voidTEveElement::CSCApplyMainTransparencyToMatchingChildren(); voidTEveElement::CSCImplySelectAllChildren(); voidTEveElement::CSCTakeAnyParentAs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveSceneInfo.html:1972,Clear,ClearStamps,1972,root/html532/TEveSceneInfo.html,https://root.cern,https://root.cern/root/html532/TEveSceneInfo.html,4,['Clear'],['ClearStamps']
Usability,"ent. More...;  ; class  TBufferMerger;  TBufferMerger is a class to facilitate writing data in parallel from multiple threads, while writing to a single output file. More...;  ; class  TBufferMergerFile;  A TBufferMergerFile is similar to a TMemFile, but when data is written to it, it is appended to the TBufferMerger queue. More...;  ; class  TClassAlt;  ; class  TClassRec;  ; class  TExecutorCRTP;  This class defines an interface to execute the same task multiple times, possibly in parallel and with different arguments every time. More...;  ; class  TForNamespace;  ; class  TIOFeatures;  TIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TTree. More...;  ; class  TMapDeclIdToTClass;  ; class  TMapTypeToClassRec;  ; class  TMapTypeToTClass;  ; class  TModuleGenerator;  ; class  TNumSlots;  Defines the number of threads in some of ROOT's interfaces. More...;  ; class  TProcessExecutor;  This class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time. More...;  ; class  TReadLockGuard;  ; class  TReentrantRWLock;  ; class  TRWMutexImp;  ; class  TRWSpinLock;  ; class  TRWSpinLockReadGuard;  ; class  TRWSpinLockWriteGuard;  ; class  TSchemaRule;  ; class  TSeq;  A pseudo container class which is a generator of indices. More...;  ; class  TSequentialExecutor;  ; class  TSpinMutex;  A spin mutex class which respects the STL interface for mutexes. More...;  ; class  TThreadedObject;  A wrapper to make object instances thread private, lazily. More...;  ; class  TThreadExecutor;  This class provides a simple interface to execute the same task multiple times in parallel threads, possibly with different arguments every time. More...;  ; class  TTreeProcessorMP;  This class provides an interface to process a TTree dataset in parallel with multi-process technology. More...;  ; class  TTreeProcessorMT;  A class to process the entries of a TTree in parallel. Mo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v628/namespaceROOT.html:2999,simpl,simple,2999,doc/v628/namespaceROOT.html,https://root.cern,https://root.cern/doc/v628/namespaceROOT.html,1,['simpl'],['simple']
Usability,"ent> Randomize(double alpha, double beta, Double_t& seed); Randomize matrix element values. void TMatrixTBase<Element> Streamer(TBuffer& ); Stream an object of class TMatrixTBase<Element>. template<class Element> Element TMatrixTBase<Element> SetTol(double tol). Element * GetElements(). Int_t GetRowLwb() const; { return fRowLwb; }. Int_t GetRowUpb() const; { return fNrows+fRowLwb-1; }. Int_t GetNrows() const; { return fNrows; }. Int_t GetColLwb() const; { return fColLwb; }. Int_t GetColUpb() const; { return fNcols+fColLwb-1; }. Int_t GetNcols() const; { return fNcols; }. Int_t GetNoElements() const; { return fNelems; }. Element GetTol() const; { return fTol; }. const Element * GetMatrixArray() const. Element * GetMatrixArray(). const Int_t * GetRowIndexArray() const. Int_t * GetRowIndexArray(). const Int_t * GetColIndexArray() const. Int_t * GetColIndexArray(). TMatrixTBase<Element> & SetRowIndexArray(Int_t* data). TMatrixTBase<Element> & SetColIndexArray(Int_t* data). void Clear(Option_t* option = """"). void Invalidate(); { SetBit(kStatus); }. void MakeValid(); { ResetBit(kStatus); }. Bool_t IsValid() const; { return !TestBit(kStatus); }. Bool_t IsOwner() const; { return fIsOwner; }. TMatrixTBase<Element> & GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<double>& target, Option_t* option = ""S"") const. TMatrixTBase<Element> & ResizeTo(Int_t nrows, Int_t ncols, Int_t nr_nonzeros = -1). TMatrixTBase<Element> & ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros = -1). Double_t Determinant() const; { AbstractMethod(""Determinant()""); return 0.; }. void Determinant(Double_t& d1, Double_t& d2) const; { AbstractMethod(""Determinant()""); d1 = 0.; d2 = 0.; }. Element NormInf() const; { return RowNorm(); }. Element Norm1() const; { return ColNorm(); }. Element operator()(Int_t rown, Int_t coln) const. Element & operator()(Int_t rown, Int_t coln). » Last changed: root/matrix:$Id$ » Last generated: 2015-06-30 15:19",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMatrixTBase_double_.html:21912,Clear,Clear,21912,root/html602/TMatrixTBase_double_.html,https://root.cern,https://root.cern/root/html602/TMatrixTBase_double_.html,1,['Clear'],['Clear']
Usability,"ent> Randomize(float alpha, float beta, Double_t& seed); Randomize matrix element values. void TMatrixTBase<Element> Streamer(TBuffer& ); Stream an object of class TMatrixTBase<Element>. template<class Element> Element TMatrixTBase<Element> SetTol(float newTol). Element * GetElements(). Int_t GetRowLwb() const; { return fRowLwb; }. Int_t GetRowUpb() const; { return fNrows+fRowLwb-1; }. Int_t GetNrows() const; { return fNrows; }. Int_t GetColLwb() const; { return fColLwb; }. Int_t GetColUpb() const; { return fNcols+fColLwb-1; }. Int_t GetNcols() const; { return fNcols; }. Int_t GetNoElements() const; { return fNelems; }. Element GetTol() const; { return fTol; }. const Element * GetMatrixArray() const. Element * GetMatrixArray(). const Int_t * GetRowIndexArray() const. Int_t * GetRowIndexArray(). const Int_t * GetColIndexArray() const. Int_t * GetColIndexArray(). TMatrixTBase<Element> & SetRowIndexArray(Int_t* data). TMatrixTBase<Element> & SetColIndexArray(Int_t* data). void Clear(Option_t* option = """"). void Invalidate(); { SetBit(kStatus); }. void MakeValid(); { ResetBit(kStatus); }. Bool_t IsValid() const; { return !TestBit(kStatus); }. Bool_t IsOwner() const; { return fIsOwner; }. TMatrixTBase<Element> & GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<float>& target, Option_t* option = ""S"") const. TMatrixTBase<Element> & ResizeTo(Int_t nrows, Int_t ncols, Int_t nr_nonzeros = -1). TMatrixTBase<Element> & ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros = -1). Double_t Determinant() const; { AbstractMethod(""Determinant()""); return 0.; }. void Determinant(Double_t& d1, Double_t& d2) const; { AbstractMethod(""Determinant()""); d1 = 0.; d2 = 0.; }. Element NormInf() const; { return RowNorm(); }. Element Norm1() const; { return ColNorm(); }. Element operator()(Int_t rown, Int_t coln) const. Element & operator()(Int_t rown, Int_t coln). » Last changed: root/matrix:$Id$ » Last generated: 2015-03-14 16:45;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMatrixTBase_float_.html:21311,Clear,Clear,21311,root/html534/TMatrixTBase_float_.html,https://root.cern,https://root.cern/root/html534/TMatrixTBase_float_.html,1,['Clear'],['Clear']
Usability,"ent> inline TVectorT<Element> &TVectorT<Element> Use(Int_t n, double* data); { return Use(0,n-1,data); }. template<class Element> inline const TVectorT<Element> &TVectorT<Element> Use(Int_t n, const double* data) const; { return Use(0,n-1,data); }. template<class Element> inline TVectorT<Element> &TVectorT<Element> Use(TVectorT<double>& v). template<class Element> inline const TVectorT<Element> &TVectorT<Element> Use(const TVectorT<double>& v) const. template<class Element> inline TVectorT<Element> TVectorT<Element> GetSub(Int_t row_lwb, Int_t row_upb, Option_t* option = ""S"") const. template<class Element> inline const Element &TVectorT<Element> operator()(Int_t ind) const; Access a vector element. template<class Element> inline Element &TVectorT<Element> operator()(Int_t index); Access a vector element. Int_t GetLwb() const; { return fRowLwb; }. Int_t GetUpb() const; { return fNrows+fRowLwb-1; }. Int_t GetNrows() const; { return fNrows; }. Int_t GetNoElements() const; { return fNrows; }. Element * GetMatrixArray(); { return fElements; }. const Element * GetMatrixArray() const; { return fElements; }. void Invalidate(); { SetBit(kStatus); }. void MakeValid(); { ResetBit(kStatus); }. Bool_t IsValid() const; { return !TestBit(kStatus); }. Bool_t IsOwner() const; { return fIsOwner; }. void SetElements(const double* elements). TVectorT<Element> & Shift(Int_t row_shift); { fRowLwb += row_shift; return *this; }. TVectorT<Element> & ResizeTo(Int_t lwb, Int_t upb). TVectorT<Element> & ResizeTo(Int_t n); { return ResizeTo(0,n-1); }. TVectorT<Element> & Use(Int_t lwb, Int_t upb, double* data). const Element & operator[](Int_t index) const; { return (*this)(index); }. Element & operator[](Int_t index); { return (*this)(index); }. void Clear(Option_t* = """"). » Last changed: root/matrix:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TVectorT_double_.html:19138,Clear,Clear,19138,root/html604/TVectorT_double_.html,https://root.cern,https://root.cern/root/html604/TVectorT_double_.html,1,['Clear'],['Clear']
Usability,"ent> inline TVectorT<Element> &TVectorT<Element> Use(Int_t n, double* data); { return Use(0,n-1,data); }. template<class Element> inline const TVectorT<Element> &TVectorT<Element> Use(Int_t n, const double* data) const; { return Use(0,n-1,data); }. template<class Element> inline TVectorT<Element> &TVectorT<Element> Use(TVectorT<double>& v). template<class Element> inline const TVectorT<Element> &TVectorT<Element> Use(const TVectorT<double>& v) const. template<class Element> inline TVectorT<Element> TVectorT<Element> GetSub(Int_t row_lwb, Int_t row_upb, Option_t* option = ""S"") const. template<class Element> inline const Element &TVectorT<Element> operator()(Int_t ind) const; Access a vector element. template<class Element> inline Element &TVectorT<Element> operator()(Int_t index); Access a vector element. Int_t GetLwb() const; { return fRowLwb; }. Int_t GetUpb() const; { return fNrows+fRowLwb-1; }. Int_t GetNrows() const; { return fNrows; }. Int_t GetNoElements() const; { return fNrows; }. Element * GetMatrixArray(); { return fElements; }. const Element * GetMatrixArray() const; { return fElements; }. void Invalidate(); { SetBit(kStatus); }. void MakeValid(); { ResetBit(kStatus); }. Bool_t IsValid() const; { return !TestBit(kStatus); }. Bool_t IsOwner() const; { return fIsOwner; }. void SetElements(const double* elements). TVectorT<Element> & Shift(Int_t row_shift); { fRowLwb += row_shift; return *this; }. TVectorT<Element> & ResizeTo(Int_t lwb, Int_t upb). TVectorT<Element> & ResizeTo(Int_t n); { return ResizeTo(0,n-1); }. TVectorT<Element> & Use(Int_t lwb, Int_t upb, double* data). const Element & operator[](Int_t index) const; { return (*this)(index); }. Element & operator[](Int_t index); { return (*this)(index); }. void Clear(Option_t* = """"). » Last changed: root/matrix:$Id$ » Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVectorT_double_.html:19138,Clear,Clear,19138,root/html602/TVectorT_double_.html,https://root.cern,https://root.cern/root/html602/TVectorT_double_.html,1,['Clear'],['Clear']
Usability,"entQuery (TQueryResult *q) override;  Set current query and save previous value. ;  ; void SetDispatchTimer (Bool_t on=kTRUE) override;  Enable/disable the timer to dispatch pening events while processing. ;  ; void SetDrawFeedbackOption (TDrawFeedback *f, Option_t *opt) override;  Set draw feedback option. ;  ; void SetExitStatus (EExitStatus st) override;  ; void SetInitTime () override;  ; void SetMaxDrawQueries (Int_t max) override;  ; void SetMerging (Bool_t=kTRUE) override;  ; void SetOutputFilePath (const char *fp) override;  ; void SetProcessing (Bool_t on=kTRUE);  Set processing bit according to 'on'. ;  ; void SetStopTimer (Bool_t on=kTRUE, Bool_t abort=kFALSE, Int_t timeout=0) override;  Enable/disable the timer to stop/abort processing. ;  ; virtual void StopFeedback ();  Stop feedback (may not be used in this class). ;  ; void StopProcess (Bool_t abort, Int_t timeout=-1) override;  Stop the process after this event. ;  ; void StoreFeedback (TObject *slave, TList *out) override;  Store feedback list (may not be used in this class). ;  ; void StoreOutput (TList *out) override;  Store output list (may not be used in this class). ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void UpdateAutoBin (const char *name, Double_t &xmin, Double_t &xmax, Double_t &ymin, Double_t &ymax, Double_t &zmin, Double_t &zmax) override;  Update automatic binning parameters for given object ""name"". ;  ; void UpdateProgressInfo () override;  Update fProgressStatus. ;  ;  Public Member Functions inherited from TVirtualProofPlayer;  TVirtualProofPlayer ();  ;  ~TVirtualProofPlayer () override;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayer.html:7721,feedback,feedback,7721,doc/master/classTProofPlayer.html,https://root.cern,https://root.cern/doc/master/classTProofPlayer.html,1,['feedback'],['feedback']
Usability,"entStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTCollection::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTCollection::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTSeqCollection::Changed(); static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTList::DeleteLink(TObjLink* lnk); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; TObjLink**TList::DoSort(TObjLink** head, Int_t n); TObjLink*TList::FindLink(const TObject* obj, Int_t& idx) const; virtual const char*TCollection::GetCollectionEntryName(TObject* entry) const; virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; virtual voidTQCommand::Init(const char* cl, void* object, const char* redo, const char* undo); TObjLink*TList::LinkAt(Int_t idx) const; Bool_tTList::LnkCompare(TObjLink* l1, TObjLink* l2); voidTObject::MakeZombie(); virtual TObjLink*TList::NewLink(TObject* obj, TObjLink* prev = NULL); virtual TObjLink*TList::NewOptLink(TObject* obj, Option_t* opt, TObjLink* prev = NULL); virtual voidPrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; virtual voidTQCommand::PrintCollectionHeader(Option_t* option) const. Data Members; public:. enum TCollection::[unnamed] { kIsOwner; kInitCapacity; kInitHashTableCapacity; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQUndoManager.html:15884,undo,undo,15884,root/html528/TQUndoManager.html,https://root.cern,https://root.cern/root/html528/TQUndoManager.html,6,['undo'],['undo']
Usability,"entation. ; . Function Members (Methods); public:. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); RooObjCacheManager(RooAbsArg* owner = 0, Int_t maxSize = 10, Bool_t clearCacheOnServerRedirect = kTRUE); virtual~RooObjCacheManager(); Int_tRooCacheManager<RooAbsCacheElement>::cacheSize() const; static TClass*Class(); virtual voidfindConstantNodes(const RooArgSet&, RooArgSet&, RooLinkedList&); RooAbsCacheElement*RooCacheManager<RooAbsCacheElement>::getObj(const RooArgSet* nset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); RooAbsCacheElement*RooCacheManager<RooAbsCacheElement>::getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx = 0, const TNamed* isetRangeName = 0); RooAbsCacheElement*RooCacheManager<RooAbsCacheElement>::getObjByIndex(Int_t index) const; virtual voidinsertObjectHook(RooAbsCacheElement&); virtual TClass*IsA() const; Int_tRooCacheManager<RooAbsCacheElement>::lastIndex() const; const RooNameSet*RooCacheManager<RooAbsCacheElement>::nameSet1ByIndex(Int_t index) const; const RooNameSet*RooCacheManager<RooAbsCacheElement>::nameSet2ByIndex(Int_t index) const; RooObjCacheManager&operator=(const RooObjCacheManager&); virtual voidoperModeHook(); virtual voidoptimizeCacheMode(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooCacheManager<RooAbsCacheElement>::reset(); Int_tRooCacheManager<RooAbsCacheElement>::setObj(const RooArgSet* nset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Int_tRooCacheManager<RooAbsCacheElement>::setObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); virtual voidShowMembers(TMemberInspector& insp); voidRooCacheManager<RooAbsCacheElement>::sterilize(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Bool_t_clearOnRedirect;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooObjCacheManager.html:1058,clear,clearCacheOnServerRedirect,1058,root/html528/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html528/RooObjCacheManager.html,1,['clear'],['clearCacheOnServerRedirect']
Usability,"entation. ◆ AddColumn(). void TRobustEstimator::AddColumn ; (; Double_t * ; col). adds a column to the data matrix it is assumed that the column has size fN variable fVarTemp keeps the number of columns l already added ; Definition at line 171 of file TRobustEstimator.cxx. ◆ AddRow(). void TRobustEstimator::AddRow ; (; Double_t * ; row). adds a vector to the data matrix it is supposed that the vector is of size fNvar ; Definition at line 192 of file TRobustEstimator.cxx. ◆ AddToSscp(). void TRobustEstimator::AddToSscp ; (; TMatrixD & ; sscp, . TVectorD & ; vec . ). protected . update the sscp matrix with vector vec ; Definition at line 779 of file TRobustEstimator.cxx. ◆ Classic(). void TRobustEstimator::Classic ; (; ). protected . called when h=n. ; Returns classic covariance matrix and mean ; Definition at line 809 of file TRobustEstimator.cxx. ◆ ClearSscp(). void TRobustEstimator::ClearSscp ; (; TMatrixD & ; sscp). protected . clear the sscp matrix, used for covariance and mean calculation ; Definition at line 796 of file TRobustEstimator.cxx. ◆ Correl(). void TRobustEstimator::Correl ; (; ). protected . transforms covariance matrix into correlation matrix ; Definition at line 850 of file TRobustEstimator.cxx. ◆ Covar(). void TRobustEstimator::Covar ; (; TMatrixD & ; sscp, . TVectorD & ; m, . TMatrixDSym & ; cov, . TVectorD & ; sd, . Int_t ; nvec . ). protected . calculates mean and covariance ; Definition at line 827 of file TRobustEstimator.cxx. ◆ CreateOrtSubset(). void TRobustEstimator::CreateOrtSubset ; (; TMatrixD & ; dat, . Int_t * ; index, . Int_t ; hmerged, . Int_t ; nmerged, . TMatrixD & ; sscp, . Double_t * ; ndist . ). protected . creates a subset of hmerged vectors with smallest orthogonal distances to the hyperplane hyp[1]*(x1-mean[1])+...+hyp[nvar]*(xnvar-mean[nvar])=0 This function is called in case when less than fH samples lie on a hyperplane. ; Definition at line 968 of file TRobustEstimator.cxx. ◆ CreateSubset(). void TRobustEstimator::CreateSu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRobustEstimator.html:21165,clear,clear,21165,doc/master/classTRobustEstimator.html,https://root.cern,https://root.cern/doc/master/classTRobustEstimator.html,1,['clear'],['clear']
Usability,"ented with doxygen comments */; class Undocumented { };; ; /*! Class that is inherited using public inheritance */; class PublicBase : public Truncated { };; ; /*! A template class */; template<class T> class Templ { };; ; /*! Class that is inherited using protected inheritance */; class ProtectedBase { };; ; /*! Class that is inherited using private inheritance */; class PrivateBase { };; ; /*! Class that is used by the Inherited class */; class Used { };; ; /*! Super class that inherits a number of other classes */; class Inherited : public PublicBase,; protected ProtectedBase,; private PrivateBase,; public Undocumented,; public Templ<int>; {; private:; Used *m_usedClass;; };; This will result in the following graph:; This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.The boxes in the above graph have the following meaning: . A filled gray box represents the struct or class for which the graph is generated. . A box with a black border denotes a documented struct or class. . A box with a gray border denotes an undocumented struct or class. . A box with a red border denotes a documented struct or class forwhich not all inheritance/containment relations are shown. A graph is truncated if it does not fit within the specified boundaries. . The arrows have the following meaning: . A blue arrow is used to visualize a public inheritance relation between two classes. . A dark green arrow is used for protected inheritance. . A dark red arrow is used for private inheritance. . A purple dashed arrow is used if a class is contained or used by another class. The arrow is labelled with the variable(s) through which the pointed class or struct is accessible. . A yellow dashed arrow denotes a relation between a template instance and the template class it was instantiated from. The arrow is labelled with the template parameters of the instance. . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:50 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/graph_legend.html:1475,undo,undocumented,1475,doc/master/graph_legend.html,https://root.cern,https://root.cern/doc/master/graph_legend.html,1,['undo'],['undocumented']
Usability,"enter'; 'center' - world position from which dolly/hRotate/vRotate are measured; camera rotates round this, always facing in (in center of viewport); 'hRotate' - horizontal rotation from initial configuration in degrees; 'hRotate' - vertical rotation from initial configuration in degrees. void ReinitializeCurrentCamera(const TGLVector3& hAxis, const TGLVector3& vAxis, Bool_t redraw = kTRUE); Change base-vectors defining the camera-base transformation of current; camera. hAxis and vAxis are the default directions for forward; (inverted) and upwards. TGLAutoRotator* GetAutoRotator(); Get the auto-rotator for this viewer. void SetAutoRotator(TGLAutoRotator* ar); Set the auto-rotator for this viewer. The old rotator is deleted. void GetGuideState(Int_t& axesType, Bool_t& axesDepthTest, Bool_t& referenceOn, Double_t* referencePos) const; Fetch the state of guides (axes & reference markers) into arguments. void SetGuideState(Int_t axesType, Bool_t axesDepthTest, Bool_t referenceOn, const Double_t* referencePos); Set the state of guides (axes & reference markers) from arguments. void SetDrawCameraCenter(Bool_t x); Draw camera look at and rotation point. const TGLPhysicalShape * GetSelected() const; Return selected physical shape. void MouseOver(TGLPhysicalShape* ); Emit MouseOver signal. void MouseOver(TGLPhysicalShape* , UInt_t state); Emit MouseOver signal. void MouseOver(TObject* obj, UInt_t state); Emit MouseOver signal. void ReMouseOver(TObject* obj, UInt_t state); Emit MouseOver signal. void UnMouseOver(TObject* obj, UInt_t state); Emit UnMouseOver signal. void Clicked(TObject* obj); Emit Clicked signal. void Clicked(TObject* obj, UInt_t button, UInt_t state); Emit Clicked signal with button id and modifier state. void ReClicked(TObject* obj, UInt_t button, UInt_t state); Emit ReClicked signal with button id and modifier state. void UnClicked(TObject* obj, UInt_t button, UInt_t state); Emit UnClicked signal with button id and modifier state. void MouseIdle(TGLPhysical",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLViewer.html:34095,guid,guides,34095,root/html534/TGLViewer.html,https://root.cern,https://root.cern/root/html534/TGLViewer.html,4,['guid'],['guides']
Usability,"entry widget; TGNumberFormat Class defining namespace for several enums used by TGNumberEntry; TGObject ROOT GUI base class; TGPack Horizontal or vertical stack of frames.; TGPasswdDialog Dialog for entering passwords; TGPicture Pictures and icons used by the GUI classes; TGPictureButton A picture button widget; TGPicturePool Picture and icon cache; TGPopupMenu Popup menu; TGPosition Position object (x and y are Int_t); TGPrintDialog Print dialog used by TGTextEdit widget; TGProgressBar Progress bar abstract base class; TGQt Interface to Qt GUI; TGRadioButton A radio button widget; TGRecorder GUI class of the event recorder.; TGRectMap Rectangle used in TMap; TGRectangle Rectangle object; TGRedirectOutputGuard Exception safe output redirection; TGRegion Describes a region; TGRegionWithId Region with id, tooltip text and popup menu; TGResourcePool Graphics resource pool; TGRowLayout Row layout manager; TGSFile Read a ROOT file from the Google Storage cloud; TGScrollBar Scrollbar widget; TGScrollBarElement Scrollbar element (head, tail, slider); TGSearchDialog Text search dialog used by TGTextEdit widget; TGSearchType ; TGSelectBox TreeView dialog widget; TGSelectedPicture Selected looking picture; TGShapedFrame Shaped composite frame; TGShutter Shutter widget; TGShutterItem Shutter widget item; TGSimpleTable A simple table that owns it's interface.; TGSimpleTableInterface Interface to data in a 2D array of Double_t; TGSlider Slider widget abstract base class; TGSpeedo Base class for analog meter widget; TGSplitButton a split button widget; TGSplitFrame Splittable composite frame; TGSplitTool Split frame tool utility; TGSplitter A frame splitter abstract base class; TGStatusBar Status bar widget; TGString Graphics string; TGTRA GTRA shape; TGTab Tab widget; TGTabElement Little tab on tab widget; TGTabLayout Layout manager for TGTab widget; TGTable A table used to visualize data from diffent sources.; TGTableCell A single cell in a TGTable.; TGTableFrame A frame used in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ClassIndex.html:85351,simpl,simple,85351,root/html532/ClassIndex.html,https://root.cern,https://root.cern/root/html532/ClassIndex.html,1,['simpl'],['simple']
Usability,"ents TVirtualPad.; Definition at line 163 of file TCanvas.h. ◆ GetXsizeReal(). Size_t TCanvas::GetXsizeReal ; (; ); const. inline . Definition at line 155 of file TCanvas.h. ◆ GetXsizeUser(). Size_t TCanvas::GetXsizeUser ; (; ); const. inline . Definition at line 153 of file TCanvas.h. ◆ GetYsizeReal(). Size_t TCanvas::GetYsizeReal ; (; ); const. inline . Definition at line 156 of file TCanvas.h. ◆ GetYsizeUser(). Size_t TCanvas::GetYsizeUser ; (; ); const. inline . Definition at line 154 of file TCanvas.h. ◆ HandleInput(). void TCanvas::HandleInput ; (; EEventType ; event, . Int_t ; px, . Int_t ; py . ). virtual . Handle Input Events. ; Handle input events, like button up/down in current canvas. ; Definition at line 1232 of file TCanvas.cxx. ◆ HasMenuBar(). Bool_t TCanvas::HasMenuBar ; (; ); const. inline . Definition at line 168 of file TCanvas.h. ◆ HighlightConnect(). void TCanvas::HighlightConnect ; (; const char * ; slot). virtual . This is ""simplification"" for function TCanvas::Connect with Highlighted signal for specific slot. ; Slot has to be defined ""UserFunction(TVirtualPad *pad, TObject *obj, Int_t x, Int_t y)"" all parameters of UserFunction are taken from TCanvas::Highlighted ; Definition at line 1629 of file TCanvas.cxx. ◆ Highlighted(). void TCanvas::Highlighted ; (; TVirtualPad * ; pad, . TObject * ; obj, . Int_t ; x, . Int_t ; y . ). virtual . Emit Highlighted() signal. . pad is pointer to pad with highlighted histogram or graph; obj is pointer to highlighted histogram or graph; x is highlighted x bin for 1D histogram or highlighted x-th point for graph; y is highlighted y bin for 2D histogram (for 1D histogram or graph not in use) . Definition at line 1610 of file TCanvas.cxx. ◆ Iconify(). void TCanvas::Iconify ; (; ). Iconify canvas. ; Definition at line 1477 of file TCanvas.cxx. ◆ Init(). void TCanvas::Init ; (; ). protected . Initialize the TCanvas members. Called by all constructors. ; Definition at line 534 of file TCanvas.cxx. ◆ IsA(). TClass ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTCanvas.html:78191,simpl,simplification,78191,doc/v632/classTCanvas.html,https://root.cern,https://root.cern/doc/v632/classTCanvas.html,1,['simpl'],['simplification']
Usability,"ents TVirtualPad.; Definition at line 163 of file TCanvas.h. ◆ GetXsizeReal(). Size_t TCanvas::GetXsizeReal ; (; ); const. inline . Definition at line 155 of file TCanvas.h. ◆ GetXsizeUser(). Size_t TCanvas::GetXsizeUser ; (; ); const. inline . Definition at line 153 of file TCanvas.h. ◆ GetYsizeReal(). Size_t TCanvas::GetYsizeReal ; (; ); const. inline . Definition at line 156 of file TCanvas.h. ◆ GetYsizeUser(). Size_t TCanvas::GetYsizeUser ; (; ); const. inline . Definition at line 154 of file TCanvas.h. ◆ HandleInput(). void TCanvas::HandleInput ; (; EEventType ; event, . Int_t ; px, . Int_t ; py . ). virtual . Handle Input Events. ; Handle input events, like button up/down in current canvas. ; Definition at line 1234 of file TCanvas.cxx. ◆ HasMenuBar(). Bool_t TCanvas::HasMenuBar ; (; ); const. inline . Definition at line 168 of file TCanvas.h. ◆ HighlightConnect(). void TCanvas::HighlightConnect ; (; const char * ; slot). virtual . This is ""simplification"" for function TCanvas::Connect with Highlighted signal for specific slot. ; Slot has to be defined ""UserFunction(TVirtualPad *pad, TObject *obj, Int_t x, Int_t y)"" all parameters of UserFunction are taken from TCanvas::Highlighted ; Definition at line 1631 of file TCanvas.cxx. ◆ Highlighted(). void TCanvas::Highlighted ; (; TVirtualPad * ; pad, . TObject * ; obj, . Int_t ; x, . Int_t ; y . ). virtual . Emit Highlighted() signal. . pad is pointer to pad with highlighted histogram or graph; obj is pointer to highlighted histogram or graph; x is highlighted x bin for 1D histogram or highlighted x-th point for graph; y is highlighted y bin for 2D histogram (for 1D histogram or graph not in use) . Definition at line 1612 of file TCanvas.cxx. ◆ Iconify(). void TCanvas::Iconify ; (; ). Iconify canvas. ; Definition at line 1479 of file TCanvas.cxx. ◆ Init(). void TCanvas::Init ; (; ). protected . Initialize the TCanvas members. Called by all constructors. ; Definition at line 537 of file TCanvas.cxx. ◆ IsA(). TClass ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCanvas.html:78567,simpl,simplification,78567,doc/master/classTCanvas.html,https://root.cern,https://root.cern/doc/master/classTCanvas.html,1,['simpl'],['simplification']
Usability,"enu-hiding enabled by default. If you dislike this, add the following line to rootrc file (or set corresponding gEnv entry in application initialization): Eve.Viewer.HideMenus: off. Definition at line 30 of file TEveViewer.h. Public Member Functions;  TEveViewer (const char *n=""TEveViewer"", const char *t="""");  Constructor. ;  ;  ~TEveViewer () override;  Destructor. ;  ; virtual void AddScene (TEveScene *scene);  Add 'scene' to the list of scenes. ;  ; TObject * GetEditorObject (const TEveException &eh=""TEveViewer::GetEditorObject "") const override;  Object to be edited when this is selected, returns the TGLViewer. ;  ; TGLViewer * GetGLViewer () const;  ; const TGPicture * GetListTreeIcon (Bool_t open=kFALSE) override;  Return TEveViewer icon. ;  ; Bool_t HandleElementPaste (TEveElement *el) override;  Receive a pasted object. ;  ; TClass * IsA () const override;  ; void PostDock () override;  Virtual function called after a window is docked. ;  ; void PreUndock () override;  Virtual function called before a window is undocked. ;  ; void Redraw (Bool_t resetCameras=kFALSE);  Redraw viewer immediately. ;  ; void RemoveElementLocal (TEveElement *el) override;  Remove element 'el' from the list of children and also remove appropriate GLScene from GLViewer's list of scenes. ;  ; void RemoveElementsLocal () override;  Remove all children, forwarded to GLViewer. ;  ; void SetGLViewer (TGLViewer *viewer, TGFrame *frame);  Set TGLViewer that is represented by this object. ;  ; TGLEmbeddedViewer * SpawnGLEmbeddedViewer (TGedEditor *ged=nullptr, Int_t border=0);  Spawn new GLViewer and adopt it. ;  ; TGLSAViewer * SpawnGLViewer (TGedEditor *ged=nullptr, Bool_t stereo=kFALSE, Bool_t quad_buf=kTRUE);  Spawn new GLViewer and adopt it. ;  ; void Streamer (TBuffer &) override;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void SwitchStereo ();  Switch stereo mode. ;  ;  Public Member Functions inherited from TEveWindowFrame;  TEveWindowFrame (TGFrame *frame, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveViewer.html:1832,undo,undocked,1832,doc/master/classTEveViewer.html,https://root.cern,https://root.cern/doc/master/classTEveViewer.html,1,['undo'],['undocked']
Usability,"enu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TMVA::IFitterTarget&fFitterTargetfitter Target; Int_tfNumParnumber of parameters; vector<Double_t>fParametersvector holding the current parameters. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MinuitWrapper(TMVA::IFitterTarget& target, Int_t maxpar); constructor. Int_t Eval(Int_t , Double_t* , Double_t& , Double_t* , Int_t ); std::vector<Double_t> parameters( npar );. Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs); Execute a fitter command;; command : command string; args : list of nargs command arguments. void Clear(Option_t* = 0); reset the fitter environment. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx); return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc); return current errors for a parameter; ipar : parameter number; eplus : upper error; eminus : lower error; eparab : parabolic error; globcc : global correlation coefficient. Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); set initial values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter. TObject * Clone(const char* ) const; produces a clone of this MinuitWrapper. Minuit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MinuitWrapper.html:19071,Clear,Clear,19071,root/html602/TMVA__MinuitWrapper.html,https://root.cern,https://root.cern/root/html602/TMVA__MinuitWrapper.html,2,['Clear'],['Clear']
Usability,"eoConeSeg(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2); TGeoConeSeg(const char* name, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2); virtual~TGeoConeSeg(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static Double_tCapacity(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2); voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromInsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoConeSeg.html:1610,Clear,ClearThreadData,1610,root/html532/TGeoConeSeg.html,https://root.cern,https://root.cern/root/html532/TGeoConeSeg.html,1,['Clear'],['ClearThreadData']
Usability,"eomData.hxx:244; ROOT::RGeomDescription::SetHighlightedItembool SetHighlightedItem(const std::vector< int > &stack)Definition RGeomData.hxx:405; ROOT::RGeomDescription::SetPreferredOfflinevoid SetPreferredOffline(bool on)Set preference of offline operations.Definition RGeomData.hxx:358; ROOT::RGeomDescription::SelectTopbool SelectTop(const std::vector< std::string > &path)Select top node by path Used by the client to change active node Returns true if selected node was ch...Definition RGeomData.cxx:1946; ROOT::RGeomDescription::GetMaxVisNodesint GetMaxVisNodes() constReturns maximal visible number of nodes, ignored when non-positive.Definition RGeomData.hxx:319; ROOT::RGeomDescription::GetVisLevelint GetVisLevel() constReturns maximal visible level.Definition RGeomData.hxx:329; ROOT::RGeomDescription::GetMaxVisFacesint GetMaxVisFaces() constReturns maximal visible number of faces, ignored when non-positive.Definition RGeomData.hxx:324; ROOT::RGeomDescription::ClearCachevoid ClearCache()Clear cached data, need to be clear when connection broken.Definition RGeomData.cxx:1381; ROOT::RGeomDescription::GetDrawJsonstd::string GetDrawJson() constDefinition RGeomData.hxx:382; ROOT::RGeomDescription::ClearDescriptionvoid ClearDescription()Clear geometry description.Definition RGeomData.cxx:478; ROOT::RGeomDescription::MakeStackByIdsstd::vector< int > MakeStackByIds(const std::vector< int > &ids)Creates stack for given array of ids, first element always should be 0.Definition RGeomData.cxx:1621; ROOT::RGeomDescription::SetMaxVisFacesvoid SetMaxVisFaces(int cnt)Set maximal number of faces which should be selected for drawing.Definition RGeomData.hxx:322; ROOT::RGeomDescription::IsPreferredOfflinebool IsPreferredOffline() constIs offline operations preferred.Definition RGeomData.hxx:361; ROOT::RGeomDescription::fShapesstd::vector< ShapeDescr > fShapes! shapes with created descriptionsDefinition RGeomData.hxx:253; ROOT::RGeomDescription::GetSearchstd::string GetSearch() constDefi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RGeomData_8hxx_source.html:25896,clear,clear,25896,doc/v632/RGeomData_8hxx_source.html,https://root.cern,https://root.cern/doc/v632/RGeomData_8hxx_source.html,1,['clear'],['clear']
Usability,"eomData.hxx:244; ROOT::RGeomDescription::SetHighlightedItembool SetHighlightedItem(const std::vector< int > &stack)Definition RGeomData.hxx:407; ROOT::RGeomDescription::SetPreferredOfflinevoid SetPreferredOffline(bool on)Set preference of offline operations.Definition RGeomData.hxx:358; ROOT::RGeomDescription::SelectTopbool SelectTop(const std::vector< std::string > &path)Select top node by path Used by the client to change active node Returns true if selected node was ch...Definition RGeomData.cxx:1946; ROOT::RGeomDescription::GetMaxVisNodesint GetMaxVisNodes() constReturns maximal visible number of nodes, ignored when non-positive.Definition RGeomData.hxx:319; ROOT::RGeomDescription::GetVisLevelint GetVisLevel() constReturns maximal visible level.Definition RGeomData.hxx:329; ROOT::RGeomDescription::GetMaxVisFacesint GetMaxVisFaces() constReturns maximal visible number of faces, ignored when non-positive.Definition RGeomData.hxx:324; ROOT::RGeomDescription::ClearCachevoid ClearCache()Clear cached data, need to be clear when connection broken.Definition RGeomData.cxx:1381; ROOT::RGeomDescription::GetDrawJsonstd::string GetDrawJson() constDefinition RGeomData.hxx:384; ROOT::RGeomDescription::ClearDescriptionvoid ClearDescription()Clear geometry description.Definition RGeomData.cxx:478; ROOT::RGeomDescription::MakeStackByIdsstd::vector< int > MakeStackByIds(const std::vector< int > &ids)Creates stack for given array of ids, first element always should be 0.Definition RGeomData.cxx:1621; ROOT::RGeomDescription::SetMaxVisFacesvoid SetMaxVisFaces(int cnt)Set maximal number of faces which should be selected for drawing.Definition RGeomData.hxx:322; ROOT::RGeomDescription::IsPreferredOfflinebool IsPreferredOffline() constIs offline operations preferred.Definition RGeomData.hxx:361; ROOT::RGeomDescription::fShapesstd::vector< ShapeDescr > fShapes! shapes with created descriptionsDefinition RGeomData.hxx:253; ROOT::RGeomDescription::GetSearchstd::string GetSearch() constDefi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RGeomData_8hxx_source.html:26147,clear,clear,26147,doc/master/RGeomData_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RGeomData_8hxx_source.html,1,['clear'],['clear']
Usability,"eom_cms.C tutorial. ;  ; file  geom_cms_stereo.C;  Shows CMS geometry in stereo mode. ;  ; file  geom_default.C;  Demonstrates usage of ""Default"" geometry alias. ;  ; file  geom_lhcb.C;  Shows LHCB geometry. ;  ; file  glplot.C;  Preliminary demo for showing Timur's GL plots in EVE. ;  ; file  glplot_geom.C;  Demonstrates how to combine Timur's GL plots with other scene elements. ;  ; file  hierarchical_scene.C;  ; file  histobrowser.C;  Demonstrates how to use EVE as a histogram browser. ;  ; file  jetcone.C;  Demonstrates usage of TEveJetCone class. ;  ; file  lineset.C;  Demonstrates usage of class TEveStraightLineSet. ;  ; file  lineset.C;  Demonstrates usage of class REveStraightLineSet. ;  ; file  MultiView.C;  Multi-view (3d, rphi, rhoz) service class using EVE Window Manager. ;  ; file  overlay_palette.C;  ; file  overlay_test.C;  Demonstrates usage of TEveBox class. ;  ; file  pack.C;  Demonstrates usage of class TGPack. ;  ; file  paramlist.C;  Demonstrates usage of simple configuration via TEveParamList class. ;  ; file  pointset.C;  Demonstrates usage of class TEvePointSet. ;  ; file  projection.C;  Demonstrates usage of automatic 2D projections - class TEveProjectionManager. ;  ; file  projection_prescale.C;  Demonstrates usage pre-scaling for automatic 2D projections. ;  ; file  pythia_display.C;  Demo showing H -> ZZ -> 4 mu generated by Pythia. ;  ; file  quadset.C;  Demonstates usage of 2D digit class TEveQuadSet. ;  ; file  run_alice_esd.C;  Complex example showing ALICE ESD track visualization. ;  ; file  run_alice_esd_split.C;  Complex example showing ALICE ESD visualization in several views. ;  ; file  selection_sigs.C;  Test signals from TEveSelection class. ;  ; file  show_extract.C;  Helper script for showing of extracted / simplified geometries. ;  ; file  SplitGLView.C;  Helper classes for the alice_esd_split.C demo. ;  ; file  text.C;  Demonstrates usage of class TEveText - 2D & 3D text in GL. ;  ; file  track.C;  Demonstrates usage of TEve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__eve.html:3061,simpl,simple,3061,doc/master/group__tutorial__eve.html,https://root.cern,https://root.cern/doc/master/group__tutorial__eve.html,1,['simpl'],['simple']
Usability,"ep ; (; Net_t & ; master, . std::vector< Net_t > & ; nets, . std::vector< TBatch< Architecture_t > > & ; batches . ). inline . Perform multiple optimization steps simultaneously. ; Performs the backprop algorithm on the input batches given in batches on the neural networks given in nets. The forward and backward propagation steps are executed in an interleaving manner in order to exploit potential batch-level parallelism for asynchronous device calls. ; Definition at line 374 of file Minimizers.h. ◆ Step() [2/2]. template<typename Architecture_t > . template<typename Net_t > . void TMVA::DNN::TGradientDescent< Architecture_t >::Step ; (; Net_t & ; net, . Matrix_t & ; input, . const Matrix_t & ; output, . const Matrix_t & ; weights . ). inline . Perform a single optimization step on a given batch. ; Propagates the input matrix forward through the net, evaluates the loss and propagates the gradients backward through the net. The computed gradients are scaled by the learning rate \(\alpha\) and subtracted from the weights and bias values of each layer. ; Definition at line 331 of file Minimizers.h. ◆ StepLoss() [1/2]. template<typename Architecture_t > . template<typename Net_t > . Scalar_t TMVA::DNN::TGradientDescent< Architecture_t >::StepLoss ; (; Net_t & ; net, . Matrix_t & ; input, . const Matrix_t & ; output, . const Matrix_t & ; weights . ). Same as Step(...) but also evaluate the loss on the given training data. ; Note that this requires synchronization between host and device. . ◆ StepLoss() [2/2]. template<typename Architecture_t > . template<typename Net_t > . auto TMVA::DNN::TGradientDescent< Architecture_t >::StepLoss ; (; Net_t & ; net, . Matrix_t & ; input, . const Matrix_t & ; output, . const Matrix_t & ; weights . ); -> Scalar_t. inline . Definition at line 352 of file Minimizers.h. ◆ StepMomentum(). template<typename Architecture_t > . template<typename Net_t > . void TMVA::DNN::TGradientDescent< Architecture_t >::StepMomentum ; (; Net_t & ; master, . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TGradientDescent.html:9938,learn,learning,9938,doc/master/classTMVA_1_1DNN_1_1TGradientDescent.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TGradientDescent.html,1,['learn'],['learning']
Usability,"epresent the link elements in the hierarchy of volumes. Nodes are unique and distinct geometrical objects ONLY from their container point of view. Since volumes can be replicated in the geometry, the same node may be found on different branches. An important observation is that volume objects are owned by the TGeoManager class. This stores a list of all volumes in the geometry, that is cleaned upon destruction.; Let's consider positioning now our wire in the middle of a gas chamber. We need first to define the gas chamber :; TGeoVolume *chamber = gGeoManager->MakeTube(""CHAMBER"", ptrGAS, 0, 1, 1);; Now we can put the wire inside :; chamber->AddNode(wire_co, 1);; TGeoVolume::AddNodevirtual TGeoNode * AddNode(TGeoVolume *vol, Int_t copy_no, TGeoMatrix *mat=nullptr, Option_t *option="""")Add a TGeoNode to the list of nodes.Definition TGeoVolume.cxx:975; If we inspect now the chamber volume in a browser, we will notice that it has one daughter. Of course the gas has some container also, but let's keep it like that for the sake of simplicity. The full prototype of AddNode() is :; TGeoVolume::AddNode(TGeoVolume *daughter, Int_t usernumber,; TGeoMatrix *matrix=gGeoIdentity); gGeoIdentityR__EXTERN TGeoIdentity * gGeoIdentityDefinition TGeoMatrix.h:537; TGeoMatrixGeometrical transformation package.Definition TGeoMatrix.h:38; int; Since we did not supplied the third argument, the wire will be positioned with an identity transformation inside the chamber. One will notice that the inner radii of the wire and chamber are both zero - therefore, aren't the two volumes overlapping ? The answer is no, the modeler is even relaying on the fact that any daughter is fully contained by its mother. On the other hand, neither of the nodes positioned inside a volume should overlap with each other. We will see that there are allowed some exceptions to those rules. Overlapping volumes; Positioning volumes that does not overlap their neighbours nor extrude their container is sometimes quite strong",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVolume.html:6629,simpl,simplicity,6629,doc/master/classTGeoVolume.html,https://root.cern,https://root.cern/doc/master/classTGeoVolume.html,1,['simpl'],['simplicity']
Usability,"er class ;  CTDeviceTDevice ;  CTDLGradientDescent;  CTGradientDescent;  CTLayerGeneric layer class ;  CTNetGeneric neural network class ;  CTReferenceThe reference architecture class ;  CTReshapeLayer;  CTRMSPropRMSProp Optimizer class ;  CTSGDStochastic Batch Gradient Descent Optimizer class ;  CTSharedLayerLayer class width shared weight and bias layers ;  CTTensorBatchTTensorBatch ;  CTTensorBatchIteratorTTensorBatchIterator ;  CTTensorDataLoaderTTensorDataLoader ;  CTTensorDataLoader< AData, TReference< AReal > >;  CVGeneralLayerGeneric General Layer class ;  CVOptimizerGeneric Optimizer class ;  ►NExperimental;  CClassification;  CClassificationResult;  ►NkNN;  CEvent;  CModulekNN;  CNodeThis file contains binary tree and global function template that searches tree for k-nearest neigbors ;  CAbsoluteDeviationLossFunctionAbsolute Deviation Loss Function ;  CAbsoluteDeviationLossFunctionBDTAbsolute Deviation BDT Loss Function ;  CAbsValue;  CBDTEventWrapper;  CBinarySearchTreeA simple Binary search tree including a volume search method ;  CBinarySearchTreeNodeNode for the BinarySearch or Decision Trees ;  CBinaryTreeBase class for BinarySearch and Decision Trees ;  CCCPrunerA helper class to prune a decision tree using the Cost Complexity method (see Classification and Regression Trees by Leo Breiman et al) ;  ►CCCTreeWrapper;  CCCTreeNode;  CClassifierFactoryThis is the MVA factory ;  CClassInfoClass that contains all the information of a class ;  Ccompose_binary_t;  Ccompose_unary_t;  ►CConfigSingleton class for global configuration settings used by TMVA ;  CIONames;  CVariablePlotting;  CConfigurable;  CConvergenceTestCheck for convergence ;  CCostComplexityPruneToolA class to prune a decision tree using the Cost Complexity method ;  CCrossEntropyImplementation of the CrossEntropy as separation criterion ;  CCrossValidationClass to perform cross validation, splitting the dataloader into folds ;  CCrossValidationFoldResult;  CCrossValidationResultClass to save ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:82827,simpl,simple,82827,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,1,['simpl'],['simple']
Usability,"er collection have a size of one, the arguments are always synchronized without checking if they have the same name. . Definition at line 305 of file RooAbsCollection.cxx. ◆ begin(). const_iterator RooAbsCollection::begin ; (; ); const. inline . Definition at line 253 of file RooAbsCollection.h. ◆ canBeAdded(). virtual bool RooAbsCollection::canBeAdded ; (; const RooAbsArg & ; arg, . bool ; silent . ); const. protectedpure virtual . Determine whether it's possible to add a given RooAbsArg to the collection or not. ; Implemented in RooArgSet, and RooArgList. ◆ Class(). static TClass * RooAbsCollection::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooAbsCollection::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooAbsCollection::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 432 of file RooAbsCollection.h. ◆ clear(). void RooAbsCollection::clear ; (; ). inline . Clear contents. If the collection is owning, it will also delete the contents. ; Definition at line 282 of file RooAbsCollection.h. ◆ clearStructureTags(). void RooAbsCollection::clearStructureTags ; (; ). inlineprotected . Definition at line 392 of file RooAbsCollection.h. ◆ clone(). virtual TObject * RooAbsCollection::clone ; (; const char * ; newname); const. pure virtual . Implemented in RooArgList, and RooArgSet. ◆ Clone(). TObject * RooAbsCollection::Clone ; (; const char * ; newname = nullptr); const. inlineoverridevirtual . Make a clone of an object using the Streamer facility. ; If the object derives from TNamed, this function is called by TNamed::Clone. TNamed::Clone uses the optional argument to set a new name to the newly created object.; If the object class has a DirectoryAutoAdd function, it will be called at the end of the function with the parameter gDirectory. This usually means that the object will be appended to the current ROOT directory.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCollection.html:35974,clear,clear,35974,doc/master/classRooAbsCollection.html,https://root.cern,https://root.cern/doc/master/classRooAbsCollection.html,1,['clear'],['clear']
Usability,"er of bytes in the object name. … -> …; | Name; | lName bytes with the name of the object. … -> …; | lTitle; | Number of bytes in the object title. … -> …; | Title; | Title of the object. … -> …; | DATA; | Data bytes associated to the object. You see a reference to TKey. It is explained in detail in the next section.; 11.1.4 The Class Description List (StreamerInfo List); The histogram records are followed by the StreamerInfo list of class descriptions. The list contains the description of each class that has been written to file.; 20010404/092347 At:5854 N=2390 StreamerInfo CX = 3.41; The class description is recursive, because to fully describe a class, its ancestors and object data members have to be described also. In demo.root, the class description list contains the description for:. TH1F; all classes in the TH1F inheritance tree; all classes of the object data members; all classes in the object data members’ inheritance tree. This description is implemented by the TStreamerInfo class, and is often referred to as simply StreamerInfo. You can print a file’s StreamerInfolist with the TFile::ShowStreamerInfo method. Below is an example of the output. Only the first line of each class description is shown. The demo.root example contains only TH1F objects. Here we see the recursive nature of the class description; it contains the StreamerInfoof all the classes needed to describe TH1F.; root[] f.ShowStreamerInfo(); StreamerInfo for class: TH1F, version=1; BASE TH1 offset=0 type= 0 1-Dim histogram base class; BASE TArrayF offset=0 type= 0 Array of floats. StreamerInfo for class: TH1, version=3; BASE TNamed offset=0 type=67 The basis for named object(name,title); BASE TAttLine offset=0 type=0 Line attributes; BASE TAttFill offset=0 type=0 Fill area attributes; BASE TAttMarker offset=0 type=0 Marker attributes; Int_t fNcells offset=0 type=3 number bins(1D),cells(2D)+U/Overflows; TAxis fXaxis offset=0 type=61 X axis descriptor; TAxis fYaxis offset=0 type=61 Y axis descri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:436607,simpl,simply,436607,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simply']
Usability,"er of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; static TCollection::(anonymous)TCollection::kIsOwner. private:. Int_tfInnerLowWaterMarkinner node low water mark; Int_tfInnerMaxIndexmaximum inner node index; Int_tfLeafLowWaterMarkleaf low water mark; Int_tfLeafMaxIndexmaximum leaf index; Int_tfOrderthe order of the tree (should be > 2); Int_tfOrder2order*2+1 (assumes a memory access is; TBtNode*fRootroot node of btree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBtree(int order); Create a B-tree of certain order (by default 3). ~TBtree(); Delete B-tree. Objects are not deleted unless the TBtree is the; owner (set via SetOwner()). void Add(TObject* obj); Add object to B-tree. TObject * After(const TObject* obj) const; Cannot use this method since B-tree decides order. TObject * Before(const TObject* obj) const; May not use this method since B-tree decides order. void Clear(Option_t* option = """"); Remove all objects from B-tree. Does NOT delete objects unless the TBtree; is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Remove all objects from B-tree AND delete all heap based objects. TObject * FindObject(const char* name) const; Find object using its name (see object's GetName()). Requires sequential; search of complete tree till object is found. TObject * FindObject(const TObject* obj) const; Find object using the objects Compare() member function. Int_t IdxAdd(const TObject& obj); Add object and return its index in the tree. void Init(Int_t i); Initialize a B-tree. TIterator * MakeIterator(Bool_t dir = kIterForward) const; Returns a B-tree iterator. Int_t Rank(const TObject* obj) const; Returns the rank of the object in the tree. TObject * Remove(TObject* obj); Remove an object from the tree. void RootIsFull(); The root of the tree is full. Create an InnerNode that; points to it, and then inform the InnerNode that it is full. void RootIsEmpty(); If root",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TBtree.html:17453,Clear,Clear,17453,root/html602/TBtree.html,https://root.cern,https://root.cern/root/html602/TBtree.html,2,['Clear'],['Clear']
Usability,"er offers many options to paint 1D, 2D and 3D histograms.; When the Draw() method of a histogram is called for the first time (TH1::Draw), it creates a THistPainter object and saves a pointer to this ""painter"" as a data member of the histogram. The THistPainter class specializes in the drawing of histograms. It is separated from the histogram so that one can have histograms without the graphics overhead, for example in a batch program. Each histogram having its own painter (rather than a central singleton painter painting all histograms), allows two histograms to be drawn in two threads without overwriting the painter's values.; When a displayed histogram is filled again, there is no need to call the Draw() method again; the image will be refreshed the next time the pad will be updated.; A pad is updated after one of these three actions:. a carriage control on the ROOT command line,; a click inside the pad,; a call to TPad::Update. By default a call to TH1::Draw() clears the pad of all objects before drawing the new image of the histogram. One can use the SAME option to leave the previous display intact and superimpose the new histogram. The same histogram can be drawn with different graphics options in different pads.; When a displayed histogram is deleted, its image is automatically removed from the pad.; To create a copy of the histogram when drawing it, one can use TH1::DrawClone(). This will clone the histogram and allow to change and delete the original one without affecting the clone. Histograms' plotting options; Most options can be concatenated with or without spaces or commas, for example: h->Draw(""E1 SAME"");; The options are not case sensitive: h->Draw(""e1 same"");; The default drawing option can be set with TH1::SetOption and retrieve using TH1::GetOption: root [0] h->Draw(); // Draw ""h"" using the standard histogram representation.; root [1] h->Draw(""E""); // Draw ""h"" using error bars; root [3] h->SetOption(""E""); // Change the default drawing option for ""h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:3934,clear,clears,3934,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,1,['clear'],['clears']
Usability,"er one can browse all ROOT objects.Definition TBrowser.h:37; TTask<div class=""legacybox""><h2>Legacy Code</h2> TTask is a legacy interface: there will be no bug fixes n...Definition TTask.h:35; TTask::TTaskTTask()Default constructor invoked when reading a TTask object from a file.Definition TTask.cxx:98; TTask::Addvirtual void Add(TTask *task)Add TTask to this.Definition TTask.cxx:176; . Definition at line 35 of file TTask.h. Public Member Functions;  TTask ();  Default constructor invoked when reading a TTask object from a file. ;  ;  TTask (const char *name, const char *title);  Standard constructor. ;  ;  TTask (const TTask &task);  Copy constructor. ;  ; virtual ~TTask ();  Delete a task and its subtasks. ;  ; virtual void Abort ();  Abort current tree of tasks. ;  ; virtual void Add (TTask *task);  Add TTask to this. ;  ; void Browse (TBrowser *b) override;  Browse the list of tasks. ;  ; virtual void CleanTasks ();  Reset tasks state: breakpoints and execute flags also invokes the Clear function of each task to clear all data structures created by a previous execution of a task. ;  ; void Clear (Option_t *option="""") override;  Recursively call the Clear function of this task and its subtasks. ;  ; virtual void Continue ();  Resume execution at the current break point. ;  ; virtual void Exec (Option_t *option);  Dummy Execute. ;  ; virtual void ExecuteTask (Option_t *option=""0"");  Execute main task and its subtasks. ;  ; virtual void ExecuteTasks (Option_t *option);  Execute all the subtasks of a task. ;  ; Int_t GetBreakin () const;  ; Int_t GetBreakout () const;  ; TList * GetListOfTasks () const;  ; TClass * IsA () const override;  ; Bool_t IsActive () const;  ; Bool_t IsFolder () const override;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; void ls (Option_t *option=""*"") const override;  List the tree of tasks. ;  ; TTask & operator= (const TTask &tt);  Assignment operator. ;  ; void SetActive (Boo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTask.html:4338,clear,clear,4338,doc/master/classTTask.html,https://root.cern,https://root.cern/doc/master/classTTask.html,1,['clear'],['clear']
Usability,"er redirect is intercepted by the cache manager.; This is the default strategy and should only be overridden when you really understand; what you're doing as properly implementing server redirect in cache elements can get very; complicated, especially if there are (cyclical) reference back to the owning object. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); Copy constructor. ~RooObjCacheManager(); Destructor. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Intercept server redirect calls. If clearOnRedirect was set, sterilize; the cache (i.e. keep the structure but delete all contents). If not; forward serverRedirect to cache elements. void operModeHook(); Intercept changes to cache operation mode and forward to cache elements. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Intercept calls to perform automatic optimization of cache mode operation.; Forward calls to existing cache elements and save configuration of; cache mode optimization so that it can be applied on new cache elements; upon insertion. void sterilize(). void insertObjectHook(RooAbsCacheElement& ); Set owner link on all object inserted into cache.; Also if cache mode optimization was requested, apply; it now to cache element being inserted. void printCompactTreeHook(ostream& , const char* ); Add details on cache contents when printing in tree mode. void findConstantNodes(const RooArgSet& , RooArgSet& , RooLinkedList& ); If clearOnRedirect is false, forward constant term optimization calls to; cache elements. void doClearObsList(Bool_t flag); { _clearObsList = flag ; }. Bool_t clearObsList(); { return _clearObsList ; }. void setClearOnRedirect(Bool_t flag); { _clearOnRedirect = flag ; }. » Last changed: Sat Jun 20 16:42:31 2015 » Last generated: 2015-06-20 16:42; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooObjCacheManager.html:5809,clear,clearOnRedirect,5809,root/html534/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html534/RooObjCacheManager.html,4,['clear'],"['clearObsList', 'clearOnRedirect']"
Usability,"er redirect is intercepted by the cache manager.; This is the default strategy and should only be overridden when you really understand; what you're doing as properly implementing server redirect in cache elements can get very; complicated, especially if there are (cyclical) reference back to the owning object. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); Copy constructor. ~RooObjCacheManager(); Destructor. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Intercept server redirect calls. If clearOnRedirect was set, sterilize; the cache (i.e. keep the structure but delete all contents). If not; forward serverRedirect to cache elements. void operModeHook(); Intercept changes to cache operation mode and forward to cache elements. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Intercept calls to perform automatic optimization of cache mode operation.; Forward calls to existing cache elements and save configuration of; cache mode optimization so that it can be applied on new cache elements; upon insertion. void sterilize(). void insertObjectHook(RooAbsCacheElement& ); Set owner link on all object inserted into cache.; Also if cache mode optimization was requested, apply; it now to cache element being inserted. void printCompactTreeHook(ostream& , const char* ); Add details on cache contents when printing in tree mode. void findConstantNodes(const RooArgSet& , RooArgSet& , RooLinkedList& ); If clearOnRedirect is false, forward constant term optimization calls to; cache elements. void doClearObsList(Bool_t flag); { _clearObsList = flag ; }. Bool_t clearObsList(); { return _clearObsList ; }. void setClearOnRedirect(Bool_t flag); { _clearOnRedirect = flag ; }. » Last changed: Sat Jun 20 17:30:22 2015 » Last generated: 2015-06-20 17:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooObjCacheManager.html:5820,clear,clearOnRedirect,5820,root/html604/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html604/RooObjCacheManager.html,4,['clear'],"['clearObsList', 'clearOnRedirect']"
Usability,"er redirect is intercepted by the cache manager.; This is the default strategy and should only be overridden when you really understand; what you're doing as properly implementing server redirect in cache elements can get very; complicated, especially if there are (cyclical) reference back to the owning object. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); Copy constructor. ~RooObjCacheManager(); Destructor. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Intercept server redirect calls. If clearOnRedirect was set, sterilize; the cache (i.e. keep the structure but delete all contents). If not; forward serverRedirect to cache elements. void operModeHook(); Intercept changes to cache operation mode and forward to cache elements. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Intercept calls to perform automatic optimization of cache mode operation.; Forward calls to existing cache elements and save configuration of; cache mode optimization so that it can be applied on new cache elements; upon insertion. void sterilize(). void insertObjectHook(RooAbsCacheElement& ); Set owner link on all object inserted into cache.; Also if cache mode optimization was requested, apply; it now to cache element being inserted. void printCompactTreeHook(ostream& , const char* ); Add details on cache contents when printing in tree mode. void findConstantNodes(const RooArgSet& , RooArgSet& , RooLinkedList& ); If clearOnRedirect is false, forward constant term optimization calls to; cache elements. void doClearObsList(Bool_t flag); { _clearObsList = flag ; }. Bool_t clearObsList(); { return _clearObsList ; }. void setClearOnRedirect(Bool_t flag); { _clearOnRedirect = flag ; }. » Last changed: Tue Jun 30 14:34:43 2015 » Last generated: 2015-06-30 14:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooObjCacheManager.html:5820,clear,clearOnRedirect,5820,root/html602/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html602/RooObjCacheManager.html,4,['clear'],"['clearObsList', 'clearOnRedirect']"
Usability,"er to array of redo arguments. ; Definition at line 752 of file TQCommand.cxx. ◆ GetRedoName(). const char * TQCommand::GetRedoName ; (; ); const. Returns the name of redo command. ; Definition at line 736 of file TQCommand.cxx. ◆ GetStatus(). Int_t TQCommand::GetStatus ; (; ); const. Returns a number of sequential undo or redo operations. ; Definition at line 792 of file TQCommand.cxx. ◆ GetTitle(). const char * TQCommand::GetTitle ; (; ); const. overridevirtual . Returns command description. ; By default, ""ClassName::RedoName(args)_ClassName::UndoName(args)"" ; Reimplemented from TObject.; Definition at line 713 of file TQCommand.cxx. ◆ GetUndo(). TQConnection * TQCommand::GetUndo ; (; ); const. inline . Definition at line 76 of file TQCommand.h. ◆ GetUndoArgs(). Long_t * TQCommand::GetUndoArgs ; (; ); const. Returns a pointer to array of undo arguments. ; Definition at line 760 of file TQCommand.cxx. ◆ GetUndoName(). const char * TQCommand::GetUndoName ; (; ); const. Returns the name of undo command. ; Definition at line 744 of file TQCommand.cxx. ◆ Init(). void TQCommand::Init ; (; const char * ; cl, . void * ; object, . const char * ; redo, . const char * ; undo . ). protectedvirtual . Common protected method used in several constructors. ; Definition at line 120 of file TQCommand.cxx. ◆ IsA(). TClass * TQCommand::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TList.; Reimplemented in TQUndoManager.; Definition at line 98 of file TQCommand.h. ◆ IsEqual(). Bool_t TQCommand::IsEqual ; (; const TObject * ; obj); const. overridevirtual . Equal comparison. ; The commands are equal if they are applied to the same object and have the same Redo/Undo actions; More complicated commands might want to override this function. ; Reimplemented from TObject.; Definition at line 418 of file TQCommand.cxx. ◆ IsExecuting(). Bool_t TQCommand::IsExecuting ; (; ); const. Returns kTRUE if command execution is in progress. ; Defi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:39213,undo,undo,39213,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['undo'],['undo']
Usability,"er to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete().; When the option starts with ""C+"", eg ""C+xyz"" the objects in the array; are in turn cleared with the option ""xyz"". void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrunk and the allocated space is freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly). void ExpandCreateFast(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrinked but the allocated space is _not_ freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly).; This is a simplified version of ExpandCreate used in the TTree me",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TClonesArray.html:20053,Clear,Clear,20053,root/html532/TClonesArray.html,https://root.cern,https://root.cern/root/html532/TClonesArray.html,4,['Clear'],['Clear']
Usability,"er(const char* par, const char* value); Set input list parameter. If the parameter is already; set it will be set to the new value. void SetParameter(const char* par, Int_t value); Set an input list parameter. void SetParameter(const char* par, Long_t value); Set an input list parameter. void SetParameter(const char* par, Long64_t value); Set an input list parameter. void SetParameter(const char* par, Double_t value); Set an input list parameter. TObject * GetParameter(const char* par) const; Get specified parameter. A parameter set via SetParameter() is either; a TParameter or a TNamed or 0 in case par is not defined. void DeleteParameters(const char* wildcard); Delete the input list parameters specified by a wildcard (e.g. PROOF_*); or exact name (e.g. PROOF_MaxSlavesPerNode). void ShowParameters(const char* wildcard = ""PROOF_*"") const; Show the input list parameters specified by the wildcard.; Default is the special PROOF control parameters (PROOF_*). void AddFeedback(const char* name); Add object to feedback list. void RemoveFeedback(const char* name); Remove object from feedback list. void ClearFeedback(); Clear feedback list. void ShowFeedback() const; Show items in feedback list. TList * GetFeedbackList() const; Return feedback list. TTree * GetTreeHeader(TDSet* tdset); Creates a tree header (a tree with nonexisting files) object for; the DataSet. TDrawFeedback * CreateDrawFeedback(); Draw feedback creation proxy. When accessed via TProof avoids; link dependency on libProofPlayer. void SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); Set draw feedback option. void DeleteDrawFeedback(TDrawFeedback* f); Delete draw feedback object. TList * GetOutputNames(); FIXME: to be written. void Browse(TBrowser* b); Build the PROOF's structure in the browser. void SetPlayer(TVirtualProofPlayer* player); Set a new PROOF player. TVirtualProofPlayer * MakePlayer(const char* player = 0, TSocket* s = 0); Construct a TProofPlayer object. The player string specifies which; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:74571,feedback,feedback,74571,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,10,['feedback'],['feedback']
Usability,"er, using ROOT geometry class. ;  ; file  na49.C;  This file has been generated automatically via the root utility toroot from an interactive version of GEANT (see ROOT class TGeometry header for an example of use) This shows an example of the old geometry package (now obsolete) ;  ; file  na49geomfile.C;  Before executing this macro, the file makegeometry.C must have been executed. ;  ; file  na49view.C;  This macro generates with 2 views of the NA49 detector using the old obsolete geometry package. ;  ; file  parallel_world.C;  Misaligning geometry generate in many cases overlaps, due to the idealization of the design and the fact that in real life movements of the geometry volumes have constraints and are correlated. ;  ; file  RadioNuclides.C;  Macro that demonstrates usage of radioactive elements/materials/mixtures with TGeo package. ;  ; file  robot.C;  Drawing a famous Korean robot, TaekwonV, using ROOT geometry class. ;  ; file  rootgeom.C;  Definition of a simple geometry (the 4 ROOT characters) ;  ; file  runplugin.C;  Creates and runs a simple iterator plugin connected to TGeoPainter iterator. ;  ; file  shapes.C;  The old geometry shapes (see script geodemo.C) ;  ; file  shapesAnim.C;  Macro illustrating how to animate a geometry picture using a Timer. ;  ; file  south_gate.C;  Drawing a famous Korean gate, the South gate, called Namdeamoon in Korean, using ROOT geometry class. ;  ; file  station1.C;  Drawing a space station, using ROOT geometry class. ;  ; file  station2.C;  Drawing a space station (version 2), using ROOT geometry class. ;  ; file  tank.C;  Drawing a fine tank, using ROOT geometry class. ;  ; file  tessellatedNav.C;  Macro allowing to vizualize tessellations from Wavefront's .obj format. ;  ; file  testoptical.C;  Tests importing/exporting optical surfaces from GDML. ;  ; file  visualizeWavefrontObj.C;  Macro allowing to vizualize tessellations from Wavefront's .obj format. ;  ; file  xtruDraw.C;  Draw a ""representative"" TXTRU shape. ;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__geom.html:2148,simpl,simple,2148,doc/master/group__tutorial__geom.html,https://root.cern,https://root.cern/doc/master/group__tutorial__geom.html,1,['simpl'],['simple']
Usability,"er. ; Definition at line 45 of file Adam.h. Public Types; using Matrix_t = typename Architecture_t::Matrix_t;  ; using Scalar_t = typename Architecture_t::Scalar_t;  ;  Public Types inherited from TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >; using Matrix_t = typename Architecture_t::Matrix_t;  ; using Scalar_t = typename Architecture_t::Scalar_t;  . Public Member Functions;  TAdam (DeepNet_t &deepNet, Scalar_t learningRate=0.001, Scalar_t beta1=0.9, Scalar_t beta2=0.999, Scalar_t epsilon=1e-7);  Constructor. ;  ;  ~TAdam ()=default;  Destructor. ;  ; Scalar_t GetBeta1 () const;  Getters. ;  ; Scalar_t GetBeta2 () const;  ; Scalar_t GetEpsilon () const;  ; std::vector< std::vector< Matrix_t > > & GetFirstMomentBiases ();  ; std::vector< Matrix_t > & GetFirstMomentBiasesAt (size_t i);  ; std::vector< std::vector< Matrix_t > > & GetFirstMomentWeights ();  ; std::vector< Matrix_t > & GetFirstMomentWeightsAt (size_t i);  ; std::vector< std::vector< Matrix_t > > & GetSecondMomentBiases ();  ; std::vector< Matrix_t > & GetSecondMomentBiasesAt (size_t i);  ; std::vector< std::vector< Matrix_t > > & GetSecondMomentWeights ();  ; std::vector< Matrix_t > & GetSecondMomentWeightsAt (size_t i);  ;  Public Member Functions inherited from TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >;  VOptimizer (Scalar_t learningRate, DeepNet_t &deepNet);  Constructor. ;  ; virtual ~VOptimizer ()=default;  Virtual Destructor. ;  ; size_t GetGlobalStep () const;  ; Layer_t * GetLayerAt (size_t i);  ; std::vector< Layer_t * > & GetLayers ();  ; Scalar_t GetLearningRate () const;  Getters. ;  ; void IncrementGlobalStep ();  Increments the global step. ;  ; void SetLearningRate (size_t learningRate);  Setters. ;  ; void Step ();  Performs one step of optimization. ;  . Protected Member Functions; void UpdateBiases (size_t layerIndex, std::vector< Matrix_t > &biases, const std::vector< Matrix_t > &biasGradients);  Update the biases, given the current bias gradients. ;  ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdam.html:2001,learn,learningRate,2001,doc/master/classTMVA_1_1DNN_1_1TAdam.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdam.html,1,['learn'],['learningRate']
Usability,"er. In addition, it provides the; possibilities for compiling, executing or interrupting a running; macro. This class can be used in following ways:; - with file name as argument:; new TGTextEditor(""hsimple.C"");; - with a TMacro* as argument:; TMacro *macro = new TMacro(""hsimple.C"");; new TGTextEditor(macro);. Basic Features:. New Document. To create a new blank document, select File menu / New, or click; the New toolbar button. It will create a new instance of; TGTextEditor. Open/Save File. To open a file, select File menu / Open or click on the Open; toolbar button. This will bring up the standard File Dialog for; opening files.; If the current document has not been saved yet, you will be asked; either to save or abandon the changes.; To save the file using the same name, select File menu / Save or; the toolbar Save button. To change the file name use File menu /; Save As... or corresponding SaveAs button on the toolbar. Text Selection. You can move the cursor by simply clicking on the desired location; with the left mouse button. To highlight some text, press the mouse; and drag the mouse while holding the left button pressed.; To select a word, double-click on it;; to select the text line - triple-click on it;; to select all do quadruple-click. Cut, Copy, Paste. After selecting some text, you can cut or copy it to the clipboard.; A subsequent paste operation will insert the contents of the; clipboard at the current cursor location. Text Search. The editor uses a standard Search dialog. You can specify a forward; or backward search direction starting from the current cursor; location according to the selection made of a case sensitive mode; or not. The last search can be repeated by pressing F3. Text Font. You can change the text font by selecting Edit menu / Set Font.; The Font Dialog pops up and shows the Name, Style, and Size of any; available font. The selected font sample is shown in the preview; area. Executing Macros. You can execute the currently loaded m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGTextEditor.html:1447,simpl,simply,1447,root/html528/TGTextEditor.html,https://root.cern,https://root.cern/root/html528/TGTextEditor.html,10,['simpl'],['simply']
Usability,"er.h. ◆ Process() [3/4]. Long64_t TProofPlayerLocal::Process ; (; TDSet * ; set, . TSelector * ; selector, . Option_t * ; option = """", . Long64_t ; nentries = -1, . Long64_t ; firstentry = 0 . ). inlineoverridevirtual . Process specified TDSet on PROOF worker with TSelector object The return value is -1 in case of error and TSelector::GetStatus() in case of success. ; Reimplemented from TProofPlayer.; Definition at line 254 of file TProofPlayer.h. ◆ Process() [4/4]. Long64_t TProofPlayerLocal::Process ; (; TSelector * ; selector, . Long64_t ; nentries = -1, . Option_t * ; option = """" . ). Process the specified TSelector object 'nentries' times. ; Used to test the PROOF interator mechanism for cycle-driven selectors in a local session. The return value is -1 in case of error and TSelector::GetStatus() in case of success. ; Definition at line 1852 of file TProofPlayer.cxx. ◆ SetupFeedback(). void TProofPlayerLocal::SetupFeedback ; (; ). inlineoverrideprotectedvirtual . Set up feedback (may not be used in this class). ; Reimplemented from TProofPlayer.; Definition at line 240 of file TProofPlayer.h. ◆ StopFeedback(). void TProofPlayerLocal::StopFeedback ; (; ). inlineoverrideprotectedvirtual . Stop feedback (may not be used in this class). ; Reimplemented from TProofPlayer.; Definition at line 241 of file TProofPlayer.h. ◆ Streamer(). void TProofPlayerLocal::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TProofPlayer. ◆ StreamerNVirtual(). void TProofPlayerLocal::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 258 of file TProofPlayer.h. Member Data Documentation. ◆ fIsClient. Bool_t TProofPlayerLocal::fIsClient. private . Definition at line 237 of file TProofPlayer.h. proof/proofplayer/inc/TProofPlayer.h; proof/proofplayer/src/TProofPlayer.cxx. TProofPlayerLocal. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:16 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerLocal.html:27469,feedback,feedback,27469,doc/master/classTProofPlayerLocal.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerLocal.html,2,['feedback'],['feedback']
Usability,"er::fToltolerance (absolute); doubleROOT::Math::Minimizer::fUperror scale ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. unsigned intfDimdimension of the function to be minimized ; vector<double>fErrors; ROOT::Minuit2::ModularFunctionMinimizer*fMinimizer; ROOT::Minuit2::FunctionMinimum*fMinimum; ROOT::Minuit2::FCNBase*fMinuitFCN; ROOT::Minuit2::MnUserParameterStatefState; boolfUseFumili; vector<double>fValues. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Minuit2Minimizer(ROOT::Minuit2::EMinimizerType type = ROOT::Minuit2::kMigrad). Default constructor. Minuit2Minimizer(const char* type). Constructor with a char (used by PM). virtual ~Minuit2Minimizer(). Destructor (no operations). Minuit2Minimizer(const ROOT::Minuit2::Minuit2Minimizer& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. void Clear(); clear resources (parameters) for consecutives minimizations. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set gradient the function to minimize. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set free variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set lower limit variable (override if minimizer supports them ). bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set upper limit variable (override if minimizer supports them ). bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set upper/lower limited variable (override if minimizer supports them ). bool SetFixedVariable(unsigned int , const string& , double ); set fixed variable (override if minimizer supports them ). bool SetVariableValue",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Minuit2__Minuit2Minimizer.html:5507,clear,clear,5507,root/html528/ROOT__Minuit2__Minuit2Minimizer.html,https://root.cern,https://root.cern/root/html528/ROOT__Minuit2__Minuit2Minimizer.html,5,"['Clear', 'clear']","['Clear', 'clear']"
Usability,"er; vector<TString>fNewEventCommands; Int_tTEveElement::fNumChildren!; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; list<TEveElement*>TEveElement::fParentsList of parents.; Bool_tTEveElement::fPickable; list<TEveProjected*>TEveProjectable::fProjectedListreferences to projected instances.; Bool_tTEveElement::fRnrChildrenRender children of this element.; Bool_tTEveElement::fRnrSelfRender this element.; Bool_tTEveElement::fSelected!; TRefTEveElement::fSourceExternal object that is represented by this element.; TStringTNamed::fTitleobject title; Int_tTEveElement::fTopItemCnt! Counter for top-level list-tree items that prevent automatic destruction.; void*TEveElement::fUserData! Externally assigned and controlled user data.; TEveElement*TEveElement::fVizModel! Element used as model from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveEventManager(const char* n = ""TEveEventManager"", const char* t = """"); Constructor. void AfterNewEventLoaded(); Virtual function to be called after a new event is loaded.; It iterates over the list of registered commands; (fNewEventCommands) and executes them in given order. void AddNewEventCommand(const TString& cmd); Register a command to be executed on each new event. void RemoveNewEventCommand(const TString& cmd); Remove the first command equal to cmd. void ClearNewEventCommands(); Clear the list of commands to be executed on each new event. virtual ~TEveEventManager(); {}. std::vector<TString>& GetNewEventCommands(); { return fNewEventCommands; }. void Open(); {}. void GotoEvent(Int_t ); {}. void NextEvent(); {}. void PrevEvent(); {}. void Close(); {}. » Last changed: root/eve:$Id$ » Last generated: 2015-03-13 19:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveEventManager.html:20475,Clear,ClearNewEventCommands,20475,root/html534/TEveEventManager.html,https://root.cern,https://root.cern/root/html534/TEveEventManager.html,2,['Clear'],"['Clear', 'ClearNewEventCommands']"
Usability,"erCopy(seedloader, loader);; 2398 ; 2399 // Booking Seed; 2400 BookMethod(seedloader, theMethod, methodTitle, theOption);; 2401 ; 2402 // Train/Test/Evaluation; 2403 TrainAllMethods();; 2404 TestAllMethods();; 2405 EvaluateAllMethods();; 2406 ; 2407 // getting ROC; 2408 SROC = GetROCIntegral(xbitset.to_string(), methodTitle);; 2409 ; 2410 // cleaning information to process sub-seeds; 2411 TMVA::MethodBase *smethod = dynamic_cast<TMVA::MethodBase *>(fMethodsMap[xbitset.to_string().c_str()][0][0]);; 2412 TMVA::ResultsClassification *sresults = (TMVA::ResultsClassification *)smethod->Data()->GetResults(; 2413 smethod->GetMethodName(), Types::kTesting, Types::kClassification);; 2414 delete sresults;; 2415 delete seedloader;; 2416 this->DeleteAllMethods();; 2417 fMethodsMap.clear();; 2418 ; 2419 // removing global result because it is requiring a lot of RAM for all seeds; 2420 ; 2421 for (uint32_t i = 0; i < VIBITS; ++i) {; 2422 if (x & (1 << i)) {; 2423 y = x & ~(uint64_t(1) << i);; 2424 std::bitset<VIBITS> ybitset(y);; 2425 // need at least one variable; 2426 // NOTE: if sub-seed is zero then is the special case; 2427 // that count in xbitset is 1; 2428 uint32_t ny = static_cast<uint32_t>(log(x - y) / 0.693147);; 2429 if (y == 0) {; 2430 importances[ny] = SROC - 0.5;; 2431 continue;; 2432 }; 2433 ; 2434 // creating loader for sub-seed; 2435 TMVA::DataLoader *subseedloader = new TMVA::DataLoader(ybitset.to_string());; 2436 // adding variables from sub-seed; 2437 for (int index = 0; index < nbits; index++) {; 2438 if (ybitset[index]); 2439 subseedloader->AddVariable(varNames[index], 'F');; 2440 }; 2441 ; 2442 // Loading Dataset; 2443 DataLoaderCopy(subseedloader, loader);; 2444 ; 2445 // Booking SubSeed; 2446 BookMethod(subseedloader, theMethod, methodTitle, theOption);; 2447 ; 2448 // Train/Test/Evaluation; 2449 TrainAllMethods();; 2450 TestAllMethods();; 2451 EvaluateAllMethods();; 2452 ; 2453 // getting ROC; 2454 SSROC = GetROCIntegral(ybitset.to_string(), methodTitle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:100782,clear,clear,100782,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['clear'],['clear']
Usability,"erEntry*fMaxSceneDrawTimeLQ; TGNumberEntry*fOLLineWidth; TGNumberEntry*fPointSizeScale; TGCheckButton*fPointSmooth; TGGroupFrame*fRefContainer; TGCheckButton*fReferenceOn; TGNumberEntry*fReferencePosX; TGNumberEntry*fReferencePosY; TGNumberEntry*fReferencePosZ; TGCheckButton*fResetCamerasOnUpdate; TGNumberEntry*fStereoEyeOffsetFac; TGCompositeFrame*fStereoFrame; TGNumberEntry*fStereoFrustumAsymFac; TGNumberEntry*fStereoZeroParallax; TGTextButton*fUpdateScene; TGLViewer*fViewer; TGNumberEntry*fWFLineWidth. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLViewerEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor. ~TGLViewerEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void ViewerRedraw(); Initiate redraw of the viewer. void SetModel(TObject* obj); Sets model or disables/hides viewer. void DoClearColor(Pixel_t color); Clear-color was changed. void DoIgnoreSizesOnUpdate(); ResetCamerasOnUpdate was toggled. void DoResetCamerasOnUpdate(); ResetCamerasOnUpdate was toggled. void DoUpdateScene(); UpdateScene was clicked. void DoCameraHome(); CameraHome was clicked. void UpdateMaxDrawTimes(); Slot for fMaxSceneDrawTimeHQ and fMaxSceneDrawTimeLQ. void UpdatePointLineStuff(); Slot for point-sizes and line-widths. void DoCameraOverlay(); Update viewer with GUI state. void DoCameraCenterExt(); Set external camera center. void DoCaptureCenter(); Capture camera-center via picking. void DoDrawCameraCenter(); Draw camera center. void UpdateCameraCenter(); Update current camera with GUI state. void DoAnnotation(); Create annotation via picking. void UpdateViewerAxes(Int_t id); Update viewer with GUI state. void UpdateViewerReference(); Update viewer with GUI state. TGNumberEntry* MakeLabeledNEntry(TGCompositeFrame* p, const char* name, Int_t labelw, Int_t nd = 7, Int_t s = 5); Helper function to create fixed w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGLViewerEditor.html:22603,Clear,Clear-color,22603,root/html532/TGLViewerEditor.html,https://root.cern,https://root.cern/root/html532/TGLViewerEditor.html,1,['Clear'],['Clear-color']
Usability,"erList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRoo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCategoryLValue.html:2282,clear,clearValueDirty,2282,root/html528/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html528/RooAbsCategoryLValue.html,2,['clear'],['clearValueDirty']
Usability,"erList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*createFundamental(const char* newname = 0) const; Roo1DTable*createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCategory.html:2213,clear,clearValueDirty,2213,root/html528/RooAbsCategory.html,https://root.cern,https://root.cern/root/html528/RooAbsCategory.html,2,['clear'],['clearValueDirty']
Usability,"erList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*createFundamental(const char* newname = 0) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsString.html:2041,clear,clearValueDirty,2041,root/html528/RooAbsString.html,https://root.cern,https://root.cern/root/html528/RooAbsString.html,2,['clear'],['clearValueDirty']
Usability,"erList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dep",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooBinningCategory.html:2052,clear,clearValueDirty,2052,root/html528/RooBinningCategory.html,https://root.cern,https://root.cern/root/html528/RooBinningCategory.html,10,['clear'],['clearValueDirty']
Usability,"erList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsString::createFundamental(const char* newname = 0) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStringVar.html:1936,clear,clearValueDirty,1936,root/html528/RooStringVar.html,https://root.cern,https://root.cern/root/html528/RooStringVar.html,2,['clear'],['clearValueDirty']
Usability,"erMerger;  TBufferMerger is a class to facilitate writing data in parallel from multiple threads, while writing to a single output file. More...;  ; class  TBufferMergerFile;  A TBufferMergerFile is similar to a TMemFile, but when data is written to it, it is appended to the TBufferMerger queue. More...;  ; class  TClassAlt;  ; class  TClassRec;  ; class  TExecutorCRTP;  This class defines an interface to execute the same task multiple times, possibly in parallel and with different arguments every time. More...;  ; class  TForNamespace;  ; class  TGenericClassInfo;  ; class  TIOFeatures;  TIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TTree. More...;  ; class  TMapDeclIdToTClass;  ; class  TMapTypeToClassRec;  ; class  TMapTypeToTClass;  ; class  TModuleGenerator;  ; class  TNumSlots;  Defines the number of threads in some of ROOT's interfaces. More...;  ; class  TProcessExecutor;  This class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time. More...;  ; class  TReadLockGuard;  ; class  TReentrantRWLock;  ; class  TRWMutexImp;  ; class  TRWSpinLock;  ; class  TRWSpinLockReadGuard;  ; class  TRWSpinLockWriteGuard;  ; class  TSchemaRule;  ; class  TSeq;  A pseudo container class which is a generator of indices. More...;  ; class  TSequentialExecutor;  ; class  TSpinMutex;  A spin mutex class which respects the STL interface for mutexes. More...;  ; class  TThreadedObject;  A wrapper to make object instances thread private, lazily. More...;  ; class  TThreadExecutor;  This class provides a simple interface to execute the same task multiple times in parallel threads, possibly with different arguments every time. More...;  ; class  TTreeProcessorMP;  This class provides an interface to process a TTree dataset in parallel with multi-process technology. More...;  ; class  TTreeProcessorMT;  A class to process the entries of a TTree in parallel. Mo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v626/namespaceROOT.html:3041,simpl,simple,3041,doc/v626/namespaceROOT.html,https://root.cern,https://root.cern/doc/v626/namespaceROOT.html,1,['simpl'],['simple']
Usability,"erNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGProgressBar;  TGProgressBar (const TGWindow *p, UInt_t w, UInt_t h, Pixel_t back=GetWhitePixel(), Pixel_t barcolor=GetDefaultSelectedBackground(), GContext_t norm=GetDefaultGC()(), FontStruct_t font=GetDefaultFontStruct(), UInt_t options=kDoubleBorder|kSunkenFrame);  Create progress bar. ;  ;  ~TGProgressBar () override;  ; virtual void Format (const char *format=""%.2f"");  Set format for displaying a value. ;  ; Pixel_t GetBarColor () const;  ; EBarType GetBarType () const;  ; EFillType GetFillType () const;  ; FontStruct_t GetFontStruct () const;  ; TString GetFormat () const;  ; Float_t GetMax () const;  ; Float_t GetMin () const;  ; GContext_t GetNormGC () const;  ; Float_t GetPosition () const;  ; Bool_t GetShowPos () const;  ; const char * GetValueFormat () const;  ; void Increment (Float_t inc);  Increment progress position. ;  ; TClass * IsA () const override;  ; virtual void Percent (Bool_t on);  ; virtual void Reset ();  Reset progress bar (i.e. set pos to 0). ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save progress bar parameters as a C++ statement(s) on output stream out. ;  ; void SetBarColor (const char *color=""blue"");  Set progress bar color. ;  ; virtual void SetBarColor (Pixel_t color);  Set progress bar color. ;  ; void SetBarType (EBarType type);  Set bar type. ;  ; void SetFillType (EFillType type);  Set fill type. ;  ; void SetForegroundColor (Pixel_t pixel) override;  Change text color drawing. ;  ; void SetMax (Float_t max);  ; void SetMin (Float_t min);  ; void SetPosition (Float_t pos);  Set progress position between [min,max]. ;  ; void SetRange (Float_t min, Float_t max);  Set min and max of progress bar. ;  ; virtual void ShowPos (Bool_t on);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Bool_t UsePercent () const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGHProgressBar.html:2591,progress bar,progress bar,2591,doc/master/classTGHProgressBar.html,https://root.cern,https://root.cern/doc/master/classTGHProgressBar.html,1,['progress bar'],['progress bar']
Usability,"eractive painting ;  ; Long64_t fCanvVersion {1};  ! actual canvas version, changed with every new Modified() call ;  ; UInt_t fClientBits {0};  ! latest status bits from client like editor visible or not ;  ; UInt_t fColorsHash {0};  ! last hash of colors/palette ;  ; Long64_t fColorsVersion {0};  ! current colors/palette version, checked every time when new snapshot created ;  ; Bool_t fFixedSize {kFALSE};  ! is canvas size fixed ;  ; std::vector< std::unique_ptr< ROOT::RWebDisplayHandle > > fHelpHandles;  ! array of handles for help widgets ;  ; Int_t fJsonComp {0};  ! compression factor for messages send to the client ;  ; Bool_t fLongerPolling {kFALSE};  ! when true, make longer polling in blocking operations ;  ; ObjectSelectSignal_t fObjSelectSignal;  ! signal emitted when new object selected in the pad ;  ; PadClickedSignal_t fPadClickedSignal;  ! signal emitted when simple mouse click performed on the pad ;  ; PadClickedSignal_t fPadDblClickedSignal;  ! signal emitted when simple mouse click performed on the pad ;  ; std::map< TPad *, PadStatus > fPadsStatus;  ! map of pads in canvas and their status flags ;  ; Int_t fPaletteDelivery {1};  ! colors palette delivery 0:never, 1:once, 2:always, 3:per subpad ;  ; Int_t fPrimitivesMerge {100};  ! number of PS primitives, which will be merged together ;  ; Bool_t fProcessingData {kFALSE};  ! flag used to prevent blocking methods when process data is invoked ;  ; Bool_t fReadOnly {kFALSE};  !< configured display ;  ; Int_t fStyleDelivery {0};  ! gStyle delivery to clients: 0:never, 1:once, 2:always ;  ; UInt_t fStyleHash {0};  ! last hash of gStyle ;  ; Long64_t fStyleVersion {0};  ! current gStyle object version, checked every time when new snapshot created ;  ; Int_t fTF1UseSave {1};  ! use save buffer for TF1/TF2, 0:off, 1:prefer, 2:force ;  ; TWebCanvasTimer * fTimer {nullptr};  ! timer to submit control messages ;  ; UpdatedSignal_t fUpdatedSignal;  ! signal emitted when canvas updated or state is changed ;  ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWebCanvas.html:14963,simpl,simple,14963,doc/master/classTWebCanvas.html,https://root.cern,https://root.cern/doc/master/classTWebCanvas.html,1,['simpl'],['simple']
Usability,"erasOnUpdate(); ResetCamerasOnUpdate was toggled. void DoUpdateScene(); UpdateScene was clicked. void DoCameraHome(); CameraHome was clicked. void UpdateMaxDrawTimes(); Slot for fMaxSceneDrawTimeHQ and fMaxSceneDrawTimeLQ. void UpdatePointLineStuff(); Slot for point-sizes and line-widths. void DoCameraOverlay(); Update viewer with GUI state. void DoCameraCenterExt(); Set external camera center. void DoCaptureCenter(); Capture camera-center via picking. void DoDrawCameraCenter(); Draw camera center. void UpdateCameraCenter(); Update current camera with GUI state. void DoAnnotation(); Create annotation via picking. void UpdateViewerAxes(Int_t id); Update viewer with GUI state. void UpdateViewerReference(); Update viewer with GUI state. TGNumberEntry* MakeLabeledNEntry(TGCompositeFrame* p, const char* name, Int_t labelw, Int_t nd = 7, Int_t s = 5); Helper function to create fixed width TGLabel and TGNumberEntry in same row. void CreateStyleTab(); Creates ""Style"" tab. void CreateGuidesTab(); Create ""Guides"" tab. void CreateClippingTab(); Create GUI controls - clip type (none/plane/box) and plane/box properties. void CreateExtrasTab(); Create Extra Tab controls - camera rotator and stereo. void UpdateReferencePosState(); Enable/disable reference position (x/y/z) number edits based on; reference check box. void SetGuides(); Configuration of guides GUI called from SetModel(). void SetRotatorMode(). void UpdateRotator(); Update rotator related variables. void DoRotatorStart(); Start auto-rotator. void DoRotatorStop(); Stop auto-rotator. void DoASavImageGUIBaseName(const char* t); Update base-name. void DoASavImageGUIOutMode(Int_t m); Update output mode. void DoASavImageStart(); Start auto-rotator image auto-save. void DoASavImageStop(); Stop auto-rotator image auto-save. void UpdateStereo(); Update stereo related variables. TGLViewerEditor(const TGLViewerEditor& ). void DetachFromPad(); {fIsInPad = kFALSE;}. » Author: Alja Mrak-Tadel, Matevz Tadel, Timur Pocheptsov 08/03/200",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLViewerEditor.html:23816,Guid,Guides,23816,root/html534/TGLViewerEditor.html,https://root.cern,https://root.cern/root/html534/TGLViewerEditor.html,3,['Guid'],['Guides']
Usability,"erasOnUpdate(); ResetCamerasOnUpdate was toggled. void DoUpdateScene(); UpdateScene was clicked. void DoCameraHome(); CameraHome was clicked. void UpdateMaxDrawTimes(); Slot for fMaxSceneDrawTimeHQ and fMaxSceneDrawTimeLQ. void UpdatePointLineStuff(); Slot for point-sizes and line-widths. void DoCameraOverlay(); Update viewer with GUI state. void DoCameraCenterExt(); Set external camera center. void DoCaptureCenter(); Capture camera-center via picking. void DoDrawCameraCenter(); Draw camera center. void UpdateCameraCenter(); Update current camera with GUI state. void DoAnnotation(); Create annotation via picking. void UpdateViewerAxes(Int_t id); Update viewer with GUI state. void UpdateViewerReference(); Update viewer with GUI state. TGNumberEntry* MakeLabeledNEntry(TGCompositeFrame* p, const char* name, Int_t labelw, Int_t nd = 7, Int_t s = 5); Helper function to create fixed width TGLabel and TGNumberEntry in same row. void CreateStyleTab(); Creates ""Style"" tab. void CreateGuidesTab(); Create ""Guides"" tab. void CreateClippingTab(); Create GUI controls - clip type (none/plane/box) and plane/box properties. void CreateExtrasTab(); Create Extra Tab controls - camera rotator and stereo. void UpdateReferencePosState(); Enable/disable reference position (x/y/z) number edits based on; reference check box. void SetGuides(); Configuration of guides GUI called from SetModel(). void UpdateRotator(); Update rotator related variables. void DoRotatorStart(); Start auto-rotator. void DoRotatorStop(); Stop auto-rotator. void DoASavImageGUIBaseName(const char* t); Update base-name. void DoASavImageGUIOutMode(Int_t m); Update output mode. void DoASavImageStart(); Start auto-rotator image auto-save. void DoASavImageStop(); Stop auto-rotator image auto-save. void UpdateStereo(); Update stereo related variables. TGLViewerEditor(const TGLViewerEditor& ). void DetachFromPad(); {fIsInPad = kFALSE;}. » Author: Alja Mrak-Tadel, Matevz Tadel, Timur Pocheptsov 08/03/2006 » Copyright (C) 1995-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGLViewerEditor.html:23718,Guid,Guides,23718,root/html532/TGLViewerEditor.html,https://root.cern,https://root.cern/root/html532/TGLViewerEditor.html,1,['Guid'],['Guides']
Usability,"erateToyData(RooArgSet& paramPoint) const; with weight. { return GenerateToyData(paramPoint,*fPdf); }. Double_t EvaluateTestStatistic(RooAbsData& data, RooArgSet& nullPOI, int i); Main interface to evaluate the test statistic on a dataset. Double_t EvaluateTestStatistic(RooAbsData& data, RooArgSet& nullPOI); { return EvaluateTestStatistic( data,nullPOI, 0 ); }. TestStatistic* GetTestStatistic(unsigned int i) const. TestStatistic* GetTestStatistic(unsigned int i) const; { return GetTestStatistic(0); }. Double_t ConfidenceLevel() const; { return 1. - fSize; }. void Initialize(RooAbsArg& , RooArgSet& , RooArgSet& ); { return fNToys; }. void SetNToys(const Int_t ntoy); { fNToys = ntoy; }. void SetNEventsPerToy(const Int_t nevents); Forces n events even for extended PDFs. Set NEvents=0 to; use the Poisson distributed events from the extended PDF. void SetParametersForTestStat(const RooArgSet& nullpoi); Set the Pdf, add to the the workspace if not already there. void SetPdf(RooAbsPdf& pdf); { fPdf = &pdf; ClearCache(); }. void SetPriorNuisance(RooAbsPdf* pdf); How to randomize the prior. Set to NULL to deactivate randomization. void SetNuisanceParameters(const RooArgSet& np); specify the nuisance parameters (eg. the rest of the parameters). { fNuisancePars = &np; }. void SetObservables(const RooArgSet& o); specify the observables in the dataset (needed to evaluate the test statistic). { fObservables = &o; }. void SetGlobalObservables(const RooArgSet& o); specify the conditional observables. { fGlobalObservables = &o; }. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). { fSize = size; }. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). { fSize = 1. - cl; }. void SetTestStatistic(RooStats::TestStatistic* testStatistic, unsigned int i); Set the TestStatistic (want the argument to be a function of the data & parameter points. void ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__ToyMCSampler.html:9173,Clear,ClearCache,9173,root/html534/RooStats__ToyMCSampler.html,https://root.cern,https://root.cern/root/html534/RooStats__ToyMCSampler.html,3,['Clear'],['ClearCache']
Usability,"erations. They take as input argument the name of a column of the dataset to watch for missing values. Like Filter, they will either keep or discard an entire entry based on whether a condition returns true or false. Specifically:. FilterAvailable: the condition is whether the value of the column is present. If so, the entry is kept. Otherwise if the value is missing the entry is discarded.; FilterMissing: the condition is whether the value of the column is missing. If so, the entry is kept. Otherwise if the value is present the entry is discarded. df = ROOT.RDataFrame(dataset); ; # Anytime an entry from ""col"" is missing, the entire entry will be filtered out; df_available = df.FilterAvailable(""col""); df_available = df_available.Define(""twice"", ""col * 2""); ; # Conversely, if we want to select the entries for which the column has missing; # values, we do the following; df_missingcol = df.FilterMissing(""col""); # Following operations in the same branch of the computation graph clearly; # cannot access that same column, since there would be no value to read; df_missingcol = df_missingcol.Define(""observable"", ""othercolumn * 2""); ROOT::RDataFrame df{dataset};; ; // Anytime an entry from ""col"" is missing, the entire entry will be filtered out; auto df_available = df.FilterAvailable(""col"");; auto df_twicecol = df_available.Define(""twice"", ""col * 2"");; ; // Conversely, if we want to select the entries for which the column has missing; // values, we do the following; auto df_missingcol = df.FilterMissing(""col"");; // Following operations in the same branch of the computation graph clearly; // cannot access that same column, since there would be no value to read; auto df_observable = df_missingcol.Define(""observable"", ""othercolumn * 2"");; DefaultValueFor; DefaultValueFor creates a node of the computation graph which just forwards the values of the columns necessary for other downstream nodes, when they are available. In case a value of the input column passed to this function is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDataFrame.html:83121,clear,clearly,83121,doc/master/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDataFrame.html,1,['clear'],['clearly']
Usability,"erator_type. typedef container_type::iterator TMVA::DNN::Net::iterator_type. Definition at line 1066 of file NeuralNet.h. Constructor & Destructor Documentation. ◆ Net() [1/2]. TMVA::DNN::Net::Net ; (; ). inline . c'tor ; Definition at line 1074 of file NeuralNet.h. ◆ Net() [2/2]. TMVA::DNN::Net::Net ; (; const Net & ; other). inline . d'tor ; Definition at line 1085 of file NeuralNet.h. Member Function Documentation. ◆ addLayer() [1/2]. void TMVA::DNN::Net::addLayer ; (; Layer && ; layer). inline . Definition at line 1095 of file NeuralNet.h. ◆ addLayer() [2/2]. void TMVA::DNN::Net::addLayer ; (; Layer & ; layer). inline . add a layer (layout) ; Definition at line 1094 of file NeuralNet.h. ◆ backPropagate(). template<typename Settings > . void TMVA::DNN::Net::backPropagate ; (; std::vector< std::vector< LayerData > > & ; layerPatternData, . const Settings & ; settings, . size_t ; trainFromLayer, . size_t ; totalNumWeights . ); const. Definition at line 1355 of file NeuralNet.icc. ◆ clear(). void TMVA::DNN::Net::clear ; (; ). inline . Definition at line 1251 of file NeuralNet.h. ◆ compute(). template<typename Weights > . std::vector< double > TMVA::DNN::Net::compute ; (; const std::vector< double > & ; input, . const Weights & ; weights . ); const. compute the net with the given input and the given weights ; compute the neural net; Parameters. inputthe input data ; weightsthe weight data . Definition at line 1037 of file NeuralNet.icc. ◆ computeError(). template<typename ItWeight > . std::tuple< double, double > TMVA::DNN::Net::computeError ; (; const Settings & ; settings, . std::vector< LayerData > & ; lastLayerData, . Batch & ; batch, . ItWeight ; itWeightBegin, . ItWeight ; itWeightEnd . ); const. Definition at line 1321 of file NeuralNet.icc. ◆ dE(). void TMVA::DNN::Net::dE ; (; ). ◆ dropOutWeightFactor(). template<typename WeightsType , typename DropProbabilities > . void TMVA::DNN::Net::dropOutWeightFactor ; (; WeightsType & ; weights, . const DropProbabilitie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Net.html:8247,clear,clear,8247,doc/master/classTMVA_1_1DNN_1_1Net.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Net.html,1,['clear'],['clear']
Usability,"erbose = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; virtual Bool_tchangeModel(const RooResolutionModel& newModel); voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); const RooRealVar*convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsAnaConvPdf.html:4756,clear,clearValueAndShapeDirty,4756,root/html534/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html,4,['clear'],['clearValueAndShapeDirty']
Usability,"erceptron. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MLP; » TMultiLayerPerceptron. class TMultiLayerPerceptron: public TObject. TMultiLayerPerceptron. This class describes a neural network.; There are facilities to train the network and use the output. The input layer is made of inactive neurons (returning the; optionaly normalized input) and output neurons are linear.; The type of hidden neurons is free, the default being sigmoids.; (One should still try to pass normalized inputs, e.g. between [0.,1]). The basic input is a TTree and two (training and test) TEventLists.; Input and output neurons are assigned a value computed for each event; with the same possibilities as for TTree::Draw().; Events may be weighted individualy or via TTree::SetWeight().; 6 learning methods are available: kStochastic, kBatch,; kSteepestDescent, kRibierePolak, kFletcherReeves and kBFGS. This implementation, written by C. Delaere, is *inspired* from; the mlpfit package from J.Schwindling et al. with some extensions:; * the algorithms are globally the same; * in TMultilayerPerceptron, there is no limitation on the number of; layers/neurons, while MLPFIT was limited to 2 hidden layers; * TMultilayerPerceptron allows you to save the network in a root file, and; provides more export functionalities; * TMultilayerPerceptron gives more flexibility regarding the normalization of; inputs/outputs; * TMultilayerPerceptron provides, thanks to Andrea Bocci, the possibility to; use cross-entropy errors, which allows to train a network for pattern; classification based on Bayesian posterior probability. . Introduction. Neural Networks are more and more used in various fields for data; analysis and classification, both for research and commercial; institutions. Some randomly choosen examples are:. image analysis; financial mo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiLayerPerceptron.html:960,learn,learning,960,root/html528/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html528/TMultiLayerPerceptron.html,4,['learn'],['learning']
Usability,"erceptron. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MLP; » TMultiLayerPerceptron. class TMultiLayerPerceptron: public TObject. TMultiLayerPerceptron. This class describes a neural network.; There are facilities to train the network and use the output. The input layer is made of inactive neurons (returning the; optionaly normalized input) and output neurons are linear.; The type of hidden neurons is free, the default being sigmoids.; (One should still try to pass normalized inputs, e.g. between [0.,1]). The basic input is a TTree and two (training and test) TEventLists.; Input and output neurons are assigned a value computed for each event; with the same possibilities as for TTree::Draw().; Events may be weighted individualy or via TTree::SetWeight().; 6 learning methods are available: kStochastic, kBatch,; kSteepestDescent, kRibierePolak, kFletcherReeves and kBFGS. This implementation, written by C. Delaere, is *inspired* from; the mlpfit package from J.Schwindling et al. with some extensions:; * the algorithms are globally the same; * in TMultilayerPerceptron, there is no limitation on the number of; layers/neurons, while MLPFIT was limited to 2 hidden layers; * TMultilayerPerceptron allows you to save the network in a root file, and; provides more export functionalities; * TMultilayerPerceptron gives more flexibility regarding the normalization of; inputs/outputs; * TMultilayerPerceptron provides, thanks to Andrea Bocci, the possibility to; use cross-entropy errors, which allows to train a network for pattern; classification based on Bayesian posterior probability. . Introduction. Neural Networks are more and more used in various fields for data; analysis and classification, both for research and commercial; institutions. Some randomly chosen examples are:. image analysis; financial mov",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMultiLayerPerceptron.html:960,learn,learning,960,root/html534/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html534/TMultiLayerPerceptron.html,6,['learn'],['learning']
Usability,ered by TMVA. ;  ; file  TMVA_CNN_Classification.C;   TMVA Classification Example Using a Convolutional Neural Network ;  ; file  TMVA_CNN_Classification.py;   TMVA Classification Example Using a Convolutional Neural Network ;  ; file  TMVA_Higgs_Classification.C;   Classification example of TMVA based on public Higgs UCI dataset ;  ; file  TMVA_Higgs_Classification.py;   Classification example of TMVA based on public Higgs UCI dataset ;  ; file  TMVA_RNN_Classification.C;   TMVA Classification Example Using a Recurrent Neural Network ;  ; file  TMVA_RNN_Classification.py;   TMVA Classification Example Using a Recurrent Neural Network ;  ; file  TMVA_SOFIE_Inference.py;   This macro provides an example of using a trained model with Keras and make inference using SOFIE directly from Numpy This macro uses as input a Keras model generated with the TMVA_Higgs_Classification.C tutorial You need to run that macro before this one. ;  ; file  TMVA_SOFIE_Keras.C;   This macro provides a simple example for the parsing of Keras .h5 file into RModel object and further generating the .hxx header files for inference. ;  ; file  TMVA_SOFIE_Keras_HiggsModel.C;   This macro run the SOFIE parser on the Keras model obtaining running TMVA_Higgs_Classification.C You need to run that macro before this one ;  ; file  TMVA_SOFIE_Models.py;   Example of inference with SOFIE using a set of models trained with Keras. ;  ; file  TMVA_SOFIE_ONNX.C;   This macro provides a simple example for the parsing of ONNX files into RModel object and further generating the .hxx header files for inference. ;  ; file  TMVA_SOFIE_PyTorch.C;   This macro provides a simple example for the parsing of PyTorch .pt file into RModel object and further generating the .hxx header files for inference. ;  ; file  TMVA_SOFIE_RDataFrame.C;   This macro provides an example of using a trained model with Keras and make inference using SOFIE and RDataFrame This macro uses as input a Keras model generated with the TMVA_Higgs_C,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__tmva.html:3122,simpl,simple,3122,doc/master/group__tutorial__tmva.html,https://root.cern,https://root.cern/doc/master/group__tutorial__tmva.html,1,['simpl'],['simple']
Usability,"erence Guide, “How To’s”, a list of publications and example applications.; 1.7.1 Class Reference Guide; The top of any class reference page lets you jump to different parts of the documentation. The first line links to the class index and the index for the current module (a group of classes, often a library). The second line links to the ROOT homepage and the class overviews. The third line links the source information - a HTML version of the source and header file as well as the CVS (the source management system used for the ROOT development) information of the files. The last line links the different parts of the current pages. Example of function documentation, with automatically generated LaTeX-like graphics. Inheritance tree, showing what the current class derives from, and which classes inherit from it. HTML version of the source file linking all types and most functions. 2 Getting Started; We begin by showing you how to use ROOT interactively. There are two examples to click through and learn how to use the GUI. We continue by using the command line, and explaining the coding conventions, global variables and the environment setup. If you have not installed ROOT, you can do so by following the instructions in the appendix, or on the ROOT web site: http://root.cern.ch/root/Availability.html; 2.1 Setting the Environment Variables; Before you can run ROOT you need to set the environment variable ROOTSYS and change your path to include root/bin and library path variables to include root/lib. Please note: the syntax is for bash, if you are running tcsh you will have to use setenv instead of export. Define the variable $ROOTSYS to the directory where you unpacked the ROOT:. $ export ROOTSYS=$HOME/root. Add ROOTSYS/bin to your PATH:. $ export PATH=$PATH:$ROOTSYS/bin. Setting the Library Path. On HP-UX, before executing the interactive module, you must set the library path:; $ export SHLIB_PATH=$SHLIB_PATH:$ROOTSYS/lib; On AIX, before executing the interactive modul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:30196,learn,learn,30196,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['learn'],['learn']
Usability,"erge method invokes redo action. Long64_t Merge(TCollection* , TFileMergeInfo* ); Merge a collection of TQCommand. void Add(TObject* obj, Option_t* opt); Add command to the list of merged commands. Option string can contain substrings:; ""compress"" - try to compress input command; ""radd"" - execute redo action of input command; ""uadd"" - execute undo action of input command. Bool_t CanCompress(TQCommand* c) const; By default, commands can be compressed if they are:. - equal; - setter commands. More complicated commands might want to override this function. void Compress(TQCommand* c); Compress command. Compression is analogous to arithmetic ""addition operation"". Note:; - The compressed command will be deleted.; - Execution Compress method invokes Redo action with new redo arguments; inheritied from compressed command. More complicated commands might want to override this function. Bool_t IsEqual(const TObject* obj) const; Equal comparison. The commands are equal if they are; applied to the same object and have the same Redo/Undo actions. More complicated commands might want to override this function. Bool_t IsSetter() const; Returns kTRUE is command if Redo is the same as Undo function; and is the setter action. By default, all functions with names like ""SetXXX"" or ""setXXX""; considered as setters. Another type of setters are Move, Resize operations. More complicated commands might want to override this function. void SetArgs(Int_t narg, ...); Set do/redo and undo parameters. The format is; SetArgs(number_of_params, redo_params, undo_params). Example:; move_command->SetArgs(2, 100, 100, 200, 200);; 2 params, (100,100) - do/redo position, (200,200) - undo position. void SetRedoArgs(Int_t narg, ...); Set redo parameters. The format is; SetRedoArgs(number_of_params, params). Example:; move_command->SetRedoArgs(2, 100, 100);. void SetUndoArgs(Int_t narg, ...); Set undo parameters. The format is; SetUndoArgs(number_of_params, params). Example:; move_command->SetUndoArgs(2, 2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TQCommand.html:21596,Undo,Undo,21596,root/html532/TQCommand.html,https://root.cern,https://root.cern/root/html532/TQCommand.html,4,['Undo'],['Undo']
Usability,"ergeOutput' limiting the memory; consumption. void NotifyMemory(TObject* obj); Printout the memory record after merging object 'obj'; This record is used by the memory monitor. void SetLastMergingMsg(TObject* obj); Set the message to be notified in case of exception. Int_t Incorporate(TObject* obj, TList* out, Bool_t& merged); Incorporate object 'newobj' in the list 'outlist'.; The object is merged with an object of the same name already existing in; the list, or just added.; The boolean merged is set to kFALSE when the object is just added to 'outlist';; this happens if the Merge() method does not exist or if a object named as 'obj'; is not already in the list. If the obj is not 'merged' than it should not be; deleted, unless outlist is not owner of its objects.; Return 0 on success, -1 on error. TObject * HandleHistogram(TObject* obj); Low statistic histograms need a special treatment when using autobin. void StoreOutput(TList* out); Store received output list. TList * MergeFeedback(); Merge feedback lists. void StoreFeedback(TObject* slave, TList* out); Store feedback results from the specified slave. void SetupFeedback(); Setup reporting of feedback objects. void StopFeedback(); Stop reporting of feedback objects. Bool_t HandleTimer(TTimer* timer); Send feedback objects to client. TDSetElement * GetNextPacket(TSlave* slave, TMessage* r); Get next packet for specified slave. Bool_t IsClient() const; Is the player running on the client?. Long64_t DrawSelect(TDSet* set, const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Draw (support for TChain::Draw()).; Returns -1 in case of error or number of selected events in case of success. void SetInitTime(); Set init time. TVirtualPacketizer * GetPacketizer() const; { return 0; }. void Progress(Long64_t total, Long64_t processed). void Progress(TSlave* , Long64_t total, Long64_t processed); { Progress(total, processed); }. void Progress(Long64_t total, Long64_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofPlayerRemote.html:18772,feedback,feedback,18772,root/html528/TProofPlayerRemote.html,https://root.cern,https://root.cern/root/html528/TProofPlayerRemote.html,1,['feedback'],['feedback']
Usability,"erges normally to a point where no parameter is near one of its limits, then the existence of limits has probably not prevented M from finding the right minimum. On the other hand, if one or more parameters is near its limit at the minimum, this may be because the true minimum is indeed at a limit, or it may be because the minimizer has become “blocked” at a limit. This may normally happen only if the parameter is so close to a limit (internal value at an odd multiple of \(\pm \frac{ \pi}{ 2}\) that M prints a warning to this effect when it prints the parameter values.; The minimizer can become blocked at a limit, because at a limit the derivative seen by the minimizer \(\partial F / \partial P_{\mathrm{int}}\) is zero no matter what the real derivative \(\partial F / \partial P_{\mathrm{ext}}\) is.; \[\frac{\partial F}{\partial P_{\mathrm{int}}} =; \frac{\partial F}{\partial P_{\mathrm{ext}}}; \frac{\partial P_{\mathrm{ext}}}{\partial P_{\mathrm{int}}} =; \frac{\partial F}{\partial P_{\mathrm{ext}}} = 0\]; For a stepping method (like \(\mbox{SIMPLEX}\)) this seldom poses any problem, but a method based on derivatives (\(\mbox{MIGRAD}\)) may become blocked at such a value. If this happens, it may be necessary to move the value of the parameter in question a significant distance from the limit (e.g. with MnMigrad::setValue(…)) and restart the minimization, perhaps with that parameter fixed temporarily.; 6.3.2 Getting the right parameter errors with limits; [answer:right-errors]; In the best case, where the minimum is far from any limits, M will correctly transform the error matrix, and the parameter errors it reports should be accurate and very close to those you would have got without limits. In other cases (which should be more common, since otherwise you wouldn’t need limits), the very meaning of parameter errors becomes problematic. Mathematically, since the limit is an absolute constraint on the parameter, a parameter at its limit has no error, at least in one di",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:70078,SIMPL,SIMPLEX,70078,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,2,['SIMPL'],['SIMPLEX']
Usability,"eritance; Inherited Members; Includes; Libraries. Function documentation; RooMappedCategory(const char* name, const char* title, RooAbsCategory& inputCat, const char* defCatName = ""NotMapped"", Int_t defCatIdx = NoCatIdx); Constructor with input category and name of default output state, which is assigned; to all input category states that do not follow any mapping rule. RooMappedCategory(const RooMappedCategory& other, const char* name = 0). ~RooMappedCategory(); Destructor. Bool_t map(const char* inKeyRegExp, const char* outKeyName, Int_t outKeyNum = NoCatIdx); Add mapping rule: any input category state label matching the 'inKeyRegExp'; wildcard expression will be mapped to an output state with name 'outKey'. Rules are evaluated in the order they were added. In case an input state; matches more than one rule, the first rules output state will be assigned. RooCatType evaluate() const; Calculate the current value of the object. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this mapped category to the specified stream. In addition to the info; from RooAbsCategory::printStream() we add:. Standard : input category; Shape : default value; Verbose : list of mapping rules. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from given stream. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooMappedCategory to more intuitively reflect the contents of the; product operator construction. void writeToStream(ostream& os, Bool_t compact) const; Write object contents to given stream. inline RooMappedCategory(); { }. TObject* clone(const char* newname) const; { return new RooMappedCategory(*this,newname); }. » Last changed: Mon Dec 7 13:48:13 2009 » Last generated: 2009-12-07 13:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMappedCategory.html:22308,intuit,intuitively,22308,root/html526/RooMappedCategory.html,https://root.cern,https://root.cern/root/html526/RooMappedCategory.html,1,['intuit'],['intuitively']
Usability,"eritance; Inherited Members; Includes; Libraries. Function documentation; RooMappedCategory(const char* name, const char* title, RooAbsCategory& inputCat, const char* defCatName = ""NotMapped"", Int_t defCatIdx = NoCatIdx); Constructor with input category and name of default output state, which is assigned; to all input category states that do not follow any mapping rule. RooMappedCategory(const RooMappedCategory& other, const char* name = 0). ~RooMappedCategory(); Destructor. Bool_t map(const char* inKeyRegExp, const char* outKeyName, Int_t outKeyNum = NoCatIdx); Add mapping rule: any input category state label matching the 'inKeyRegExp'; wildcard expression will be mapped to an output state with name 'outKey'. Rules are evaluated in the order they were added. In case an input state; matches more than one rule, the first rules output state will be assigned. RooCatType evaluate() const; Calculate the current value of the object. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this mapped category to the specified stream. In addition to the info; from RooAbsCategory::printStream() we add:. Standard : input category; Shape : default value; Verbose : list of mapping rules. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from given stream. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooMappedCategory to more intuitively reflect the contents of the; product operator construction. void writeToStream(ostream& os, Bool_t compact) const; Write object contents to given stream. inline RooMappedCategory(); { }. TObject* clone(const char* newname) const; { return new RooMappedCategory(*this,newname); }. » Last changed: Mon Jul 4 15:23:19 2011 » Last generated: 2011-07-04 15:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooMappedCategory.html:22558,intuit,intuitively,22558,root/html530/RooMappedCategory.html,https://root.cern,https://root.cern/root/html530/RooMappedCategory.html,1,['intuit'],['intuitively']
Usability,"eritance; Inherited Members; Includes; Libraries. Function documentation; RooMappedCategory(const char* name, const char* title, RooAbsCategory& inputCat, const char* defCatName = ""NotMapped"", Int_t defCatIdx = NoCatIdx); Constructor with input category and name of default output state, which is assigned; to all input category states that do not follow any mapping rule. RooMappedCategory(const RooMappedCategory& other, const char* name = 0). ~RooMappedCategory(); Destructor. Bool_t map(const char* inKeyRegExp, const char* outKeyName, Int_t outKeyNum = NoCatIdx); Add mapping rule: any input category state label matching the 'inKeyRegExp'; wildcard expression will be mapped to an output state with name 'outKey'. Rules are evaluated in the order they were added. In case an input state; matches more than one rule, the first rules output state will be assigned. RooCatType evaluate() const; Calculate the current value of the object. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this mapped category to the specified stream. In addition to the info; from RooAbsCategory::printStream() we add:. Standard : input category; Shape : default value; Verbose : list of mapping rules. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from given stream. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooMappedCategory to more intuitively reflect the contents of the; product operator construction. void writeToStream(ostream& os, Bool_t compact) const; Write object contents to given stream. inline RooMappedCategory(); { }. TObject* clone(const char* newname) const; { return new RooMappedCategory(*this,newname); }. » Last changed: Thu Nov 3 20:08:36 2011 » Last generated: 2011-11-03 20:08; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooMappedCategory.html:22943,intuit,intuitively,22943,root/html532/RooMappedCategory.html,https://root.cern,https://root.cern/root/html532/RooMappedCategory.html,2,['intuit'],['intuitively']
Usability,"eritance; Inherited Members; Includes; Libraries. Function documentation; TGLPlotPainter(TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord, Bool_t xoySelectable, Bool_t xozSelectable, Bool_t yozSelectable); TGLPlotPainter's ctor. TGLPlotPainter(TGL5DDataSet* data, TGLPlotCamera* camera, TGLPlotCoordinates* coord); TGLPlotPainter's ctor. TGLPlotPainter(TGLPlotCamera* camera); TGLPlotPainter's ctor. void Paint(); Draw lego/surf/whatever you can. void PrintPlot() const; Generate PS using gl2ps. Bool_t PlotSelected(Int_t px, Int_t py); Read color buffer content to find selected object. void SetPadColor(const TColor* color); Used in a pad. void SetFrameColor(const TColor* frameColor); Set plot's back box color. void InvalidateSelection(); Selection must be updated. const TColor * GetPadColor() const; Get pad color. void MoveSection(Int_t px, Int_t py); Create dynamic profile using selected plane. void DrawSections() const; Draw sections (if any). void ClearBuffers() const. // Clear buffer.; Float_t rgb[3] = {1.f, 1.f, 1.f};; if (const TColor *color = GetPadColor()); color->GetRGB(rgb[0], rgb[1], rgb[2]);; glClearColor(rgb[0], rgb[1], rgb[2], 1.);; glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);. void DrawPaletteAxis() const; Draw. Palette. Axis. void SaveModelviewMatrix() const. void SaveProjectionMatrix() const. void RestoreModelviewMatrix() const. void RestoreProjectionMatrix() const. TGLPlotPainter(TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord, Bool_t xoySelectable, Bool_t xozSelectable, Bool_t yozSelectable); TGLPlotPainter(TH1 *hist, TGLPlotCamera *camera, TGLPlotCoordinates *coord, Int_t context,; Bool_t xoySelectable, Bool_t xozSelectable, Bool_t yozSelectable);; TGLPlotPainter(TGLPlotCamera *camera, Int_t context);. TGLPlotPainter(TGLPlotCamera* camera). const TGLPlotBox& RefBackBox() const; { return fBackBox; }. void SetPhysicalShapeColor(const Float_t* rgba). void InitGL() const. void DeInitGL() const. void DrawPlot() const. Bool_t In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLPlotPainter.html:4351,Clear,Clear,4351,root/html602/TGLPlotPainter.html,https://root.cern,https://root.cern/root/html602/TGLPlotPainter.html,2,['Clear'],['Clear']
Usability,"erited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions; void ApproximatePosterior () const;  approximate posterior in nbins using a TF1 scan the poi values and evaluate the posterior at each point and save the result in a cloned TF1 For each point the posterior is evaluated by integrating the nuisance parameters ;  ; void ClearAll () const;  clear all cached pdf objects ;  ; void ComputeIntervalFromApproxPosterior (double c1, double c2) const;  compute the interval using the approximate posterior function ;  ; void ComputeIntervalFromCdf (double c1, double c2) const;  internal function compute the interval using Cdf integration ;  ; void ComputeIntervalUsingRooFit (double c1, double c2) const;  internal function compute the interval using RooFit ;  ; void ComputeShortestInterval () const;  compute the shortest interval from the histogram representing the posterior ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Private Attributes; TF1 * fApproxPosterior;  TF1 representing the scanned posterior function. ;  ; double fBrfPrecision;  root finder precision ;  ; RooArgSet fConditionalObs;  conditional observables ;  ; RooAbsData * fData;  data set ;  ; RooArgSet fGlobalObs;  global observables ;  ; RooAbsReal * fIntegratedLikelihood;  integrated likelihood function, i.e - unnormalized posterior function ;  ; TString fIntegrationType;  ; double fLeftSideFraction",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1BayesianCalculator.html:17328,clear,clear,17328,doc/master/classRooStats_1_1BayesianCalculator.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1BayesianCalculator.html,1,['clear'],['clear']
Usability,"erivative type; 82 fFunctions.reserve(2);; 83}; 84 ; 85GSLMultiRootFinder::GSLMultiRootFinder(const char * name) :; 86 fIter(0), fStatus(-1), fPrintLevel(0),; 87 fType(0), fUseDerivAlgo(false),; 88 fSolver(nullptr); 89{; 90 // constructor for a string; 91 fFunctions.reserve(2);; 92 SetType(name);; 93}; 94 ; 95GSLMultiRootFinder::~GSLMultiRootFinder(); 96{; 97 // delete function wrapper; 98 ClearFunctions();; 99 if (fSolver) delete fSolver;; 100}; 101 ; 102void GSLMultiRootFinder::SetType(const char * name) {; 103 // set type using a string; 104 std::pair<bool,int> type = GetType(name);; 105 fUseDerivAlgo = type.first;; 106 fType = type.second;; 107}; 108 ; 109 ; 110int GSLMultiRootFinder::AddFunction(const ROOT::Math::IMultiGenFunction & func) {; 111 // add a new function in the vector; 112 ROOT::Math::IMultiGenFunction * f = func.Clone();; 113 if (!f) return 0;; 114 fFunctions.push_back(f);; 115 return fFunctions.size();; 116}; 117 ; 118void GSLMultiRootFinder::ClearFunctions() {; 119 // clear the function list; 120 for (unsigned int i = 0; i < fFunctions.size(); ++i) {; 121 if (fFunctions[i] != nullptr ) delete fFunctions[i];; 122 fFunctions[i] = nullptr;; 123 }; 124 fFunctions.clear();; 125}; 126 ; 127void GSLMultiRootFinder::Clear() {; 128 // clear the function list and the solver; 129 ClearFunctions();; 130 if (fSolver) Clear();; 131 fSolver = nullptr;; 132}; 133 ; 134 ; 135const double * GSLMultiRootFinder::X() const {; 136 // return x; 137 return (fSolver != nullptr) ? fSolver->X() : nullptr;; 138}; 139const double * GSLMultiRootFinder::Dx() const {; 140 // return x; 141 return (fSolver != nullptr) ? fSolver->Dx() : nullptr;; 142}; 143const double * GSLMultiRootFinder::FVal() const {; 144 // return x; 145 return (fSolver != nullptr) ? fSolver->FVal() : nullptr;; 146}; 147const char * GSLMultiRootFinder::Name() const {; 148 // get GSL name; 149 return (fSolver != nullptr) ? fSolver->Name().c_str() : """";; 150}; 151 ; 152// bool GSLMultiRootFinder::AddFunction( c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GSLMultiRootFinder_8cxx_source.html:3901,clear,clear,3901,doc/master/GSLMultiRootFinder_8cxx_source.html,https://root.cern,https://root.cern/doc/master/GSLMultiRootFinder_8cxx_source.html,1,['clear'],['clear']
Usability,"ern (const LayerContainer& _layers,; 1222 std::vector<LayerData>& layerData) const; 1223 {; 1224 size_t idxLayer = 0, idxLayerEnd = _layers.size ();; 1225 for (; idxLayer < idxLayerEnd; ++idxLayer); 1226 {; 1227 LayerData& prevLayerData = layerData.at (idxLayer);; 1228 LayerData& currLayerData = layerData.at (idxLayer+1);; 1229 ; 1230 forward (prevLayerData, currLayerData);; 1231 ; 1232 applyFunctions (currLayerData.valuesBegin (), currLayerData.valuesEnd (), currLayerData.activationFunction ());; 1233 }; 1234 }; 1235 ; 1236 ; 1237 ; 1238 ; 1239 template <typename LayerContainer, typename LayerPatternContainer>; 1240 void Net::forwardBatch (const LayerContainer& _layers,; 1241 LayerPatternContainer& layerPatternData,; 1242 std::vector<double>& valuesMean,; 1243 std::vector<double>& valuesStdDev,; 1244 size_t trainFromLayer) const; 1245 {; 1246 valuesMean.clear ();; 1247 valuesStdDev.clear ();; 1248 ; 1249 // ---------------------------------- loop over layers and pattern -------------------------------------------------------; 1250 for (size_t idxLayer = 0, idxLayerEnd = layerPatternData.size (); idxLayer < idxLayerEnd-1; ++idxLayer); 1251 {; 1252 bool doTraining = idxLayer >= trainFromLayer;; 1253 ; 1254 // get layer-pattern data for this and the corresponding one from the next layer; 1255 std::vector<LayerData>& prevLayerPatternData = layerPatternData.at (idxLayer);; 1256 std::vector<LayerData>& currLayerPatternData = layerPatternData.at (idxLayer+1);; 1257 ; 1258 size_t numPattern = prevLayerPatternData.size ();; 1259 size_t numNodesLayer = _layers.at (idxLayer).numNodes ();; 1260 ; 1261 std::vector<MeanVariance> means (numNodesLayer);; 1262 // ---------------- loop over layerDatas of pattern compute forward ----------------------------; 1263 for (size_t idxPattern = 0; idxPattern < numPattern; ++idxPattern); 1264 {; 1265 const LayerData& prevLayerData = prevLayerPatternData.at (idxPattern);; 1266 LayerData& currLayerData = currLayerPatternData.at (idxPattern);; 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8icc_source.html:40569,clear,clear,40569,doc/master/NeuralNet_8icc_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8icc_source.html,1,['clear'],['clear']
Usability,"erride;  Get bin name of an outpt bin. ;  ; void RegularizeDistributionRecursive (const TUnfoldBinning *binning, ERegMode regmode, EDensityMode densityMode, const char *distribution, const char *axisSteering);  recursively add regularisation conditions for this node and its children ;  ; void RegularizeOneDistribution (const TUnfoldBinning *binning, ERegMode regmode, EDensityMode densityMode, const char *axisSteering);  regularize the distribution fof the given node ;  ;  Protected Member Functions inherited from TUnfoldSys; void ClearResults (void) override;  Clear all data members which depend on the unfolding results. ;  ; void DoBackgroundSubtraction (void);  perform background subtraction ;  ; void GetEmatrixFromVyy (const TMatrixDSparse *vyy, TH2 *ematrix, const Int_t *binMap, Bool_t clearEmat);  propagate an error matrix on the input vector to the unfolding result ;  ; TMatrixDSparse * GetSummedErrorMatrixXX (void);  determine total error matrix on the vector x ;  ; TMatrixDSparse * GetSummedErrorMatrixYY (void);  determine total error matrix on the vector Ax ;  ; virtual TMatrixDSparse * PrepareCorrEmat (const TMatrixDSparse *m1, const TMatrixDSparse *m2, const TMatrixDSparse *dsys);  propagate correlated systematic shift to an output vector ;  ; virtual void PrepareSysError (void);  Matrix calculations required to propagate systematic errors. ;  ; virtual TMatrixDSparse * PrepareUncorrEmat (const TMatrixDSparse *m1, const TMatrixDSparse *m2);  propagate uncorrelated systematic errors to a covariance matrix ;  ; void ScaleColumnsByVector (TMatrixDSparse *m, const TMatrixTBase< Double_t > *v) const;  scale columns of a matrix by the corresponding rows of a vector ;  ; void VectorMapToHist (TH1 *hist_delta, const TMatrixDSparse *delta, const Int_t *binMap);  map delta to hist_delta, possibly summing up bins ;  ;  Protected Member Functions inherited from TUnfold; void AddMSparse (TMatrixDSparse *dest, Double_t f, const TMatrixDSparse *src) const;  add a sparse ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldDensity.html:32279,clear,clearEmat,32279,doc/master/classTUnfoldDensity.html,https://root.cern,https://root.cern/doc/master/classTUnfoldDensity.html,1,['clear'],['clearEmat']
Usability,"erridevirtual . Handle animation timer. ; Reimplemented from TGWindow.; Definition at line 5011 of file TSessionViewer.cxx. ◆ IsA(). TClass * TSessionViewer::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGMainFrame.; Definition at line 631 of file TSessionViewer.h. ◆ IsAutoSave(). Bool_t TSessionViewer::IsAutoSave ; (; ); const. inline . Definition at line 605 of file TSessionViewer.h. ◆ IsBusy(). Bool_t TSessionViewer::IsBusy ; (; ); const. inline . Definition at line 604 of file TSessionViewer.h. ◆ LogMessage(). void TSessionViewer::LogMessage ; (; const char * ; msg, . Bool_t ; all . ). Load/append a log msg in the log frame. ; Definition at line 5051 of file TSessionViewer.cxx. ◆ MyHandleMenu(). void TSessionViewer::MyHandleMenu ; (; Int_t ; id). Handle session viewer custom popup menus. ; Definition at line 5500 of file TSessionViewer.cxx. ◆ OnCascadeMenu(). void TSessionViewer::OnCascadeMenu ; (; ). Handle feedback histograms configuration menu. ; Definition at line 5564 of file TSessionViewer.cxx. ◆ OnListTreeClicked(). void TSessionViewer::OnListTreeClicked ; (; TGListTreeItem * ; entry, . Int_t ; btn, . Int_t ; x, . Int_t ; y . ). Handle mouse clicks in list tree. ; Definition at line 4635 of file TSessionViewer.cxx. ◆ OnListTreeDoubleClicked(). void TSessionViewer::OnListTreeDoubleClicked ; (; TGListTreeItem * ; entry, . Int_t ; btn . ). Handle mouse double clicks in list tree (connect to server). ; Definition at line 4895 of file TSessionViewer.cxx. ◆ ProcessMessage(). Bool_t TSessionViewer::ProcessMessage ; (; Longptr_t ; msg, . Longptr_t ; parm1, . Longptr_t ;  . ). overridevirtual . Handle messages send to the TSessionViewer object. ; E.g. all menu entries messages. ; Reimplemented from TGCompositeFrame.; Definition at line 5627 of file TSessionViewer.cxx. ◆ QueryResultReady(). void TSessionViewer::QueryResultReady ; (; char * ; query). Handle signal ""query result ready"" coming from Proof sessio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSessionViewer.html:46779,feedback,feedback,46779,doc/master/classTSessionViewer.html,https://root.cern,https://root.cern/doc/master/classTSessionViewer.html,1,['feedback'],['feedback']
Usability,"error propagation). Double_t CLsError() const; Returns an estimate of the error on CLs through combination of the; errors on CLb and CLsplusb:. void UpdatePValue(const RooStats::SamplingDistribution* distr, Double_t& pvalue, Double_t& perror, Bool_t pIsRightTail); updates the pvalue if sufficient data is available. void Print(Option_t* = """") const; Print out some information about the results; Note: use Alt/Null labels for the hypotheses here as the Null; might be the s+b hypothesis. Double_t NullPValue() const; Return p-value for null hypothesis. { return fNullPValue; }. Double_t AlternatePValue() const; Return p-value for alternate hypothesis. { return fAlternatePValue; }. Double_t CLb() const; Convert NullPValue into a ""confidence level"". { return !fBackgroundIsAlt ? NullPValue() : AlternatePValue(); }. Double_t CLsplusb() const; Convert AlternatePValue into a ""confidence level"". { return !fBackgroundIsAlt ? AlternatePValue() : NullPValue(); }. Double_t CLs() const; CLs is simply CLs+b/CLb (not a method, but a quantity). Double_t Significance() const; familiar name for the Null p-value in terms of 1-sided Gaussian significance. {return RooStats::PValueToSignificance( NullPValue() ); }. SamplingDistribution* GetNullDistribution(void); { return fNullDistr; }. SamplingDistribution* GetAltDistribution(void); { return fAltDistr; }. RooDataSet* GetNullDetailedOutput(void); { return fNullDetailedOutput; }. RooDataSet* GetAltDetailedOutput(void); { return fAltDetailedOutput; }. RooDataSet* GetFitInfo(void); { return fFitInfo; }. Double_t GetTestStatisticData(void); { return fTestStatisticData; }. const RooArgList* GetAllTestStatisticsData(void); { return fAllTestStatisticsData; }. void SetAltDetailedOutput(RooDataSet* d); { fAltDetailedOutput = d; }. void SetNullDetailedOutput(RooDataSet* d); { fNullDetailedOutput = d; }. void SetFitInfo(RooDataSet* d); { fFitInfo = d; }. Bool_t GetPValueIsRightTail(void); { return fPValueIsRightTail; }. void SetBackgroundAsAlt(Bool_t l ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HypoTestResult.html:10710,simpl,simply,10710,root/html534/RooStats__HypoTestResult.html,https://root.cern,https://root.cern/root/html534/RooStats__HypoTestResult.html,2,['simpl'],['simply']
Usability,"error. Must only be called directly at the corresponding; 114 * call to Forward(...). */; 115 virtual void Backward(Tensor_t &gradients_backward, const Tensor_t &activations_backward ) = 0;; 116 ///// std::vector<Matrix_t> &inp1, std::vector<Matrix_t> &inp2) = 0;; 117 ; 118 /*! Reset some training flags after a loop on all batches; 119 Some layer (e.g. batchnormalization) might need to implement the function in case some operations; 120 are needed after looping an all batches */; 121 virtual void ResetTraining() {}; 122 ; 123 /*! Updates the weights and biases, given the learning rate */; 124 void Update(const Scalar_t learningRate);; 125 ; 126 /*! Updates the weights, given the gradients and the learning rate, */; 127 void UpdateWeights(const std::vector<Matrix_t> &weightGradients, const Scalar_t learningRate);; 128 ; 129 /*! Updates the biases, given the gradients and the learning rate. */; 130 void UpdateBiases(const std::vector<Matrix_t> &biasGradients, const Scalar_t learningRate);; 131 ; 132 /*! Updates the weight gradients, given some other weight gradients and learning rate. */; 133 void UpdateWeightGradients(const std::vector<Matrix_t> &weightGradients, const Scalar_t learningRate);; 134 ; 135 /*! Updates the bias gradients, given some other weight gradients and learning rate. */; 136 void UpdateBiasGradients(const std::vector<Matrix_t> &biasGradients, const Scalar_t learningRate);; 137 ; 138 /*! Copies the weights provided as an input. */; 139 void CopyWeights(const std::vector<Matrix_t> &otherWeights);; 140 ; 141 /*! Copies the biases provided as an input. */; 142 void CopyBiases(const std::vector<Matrix_t> &otherBiases);; 143 ; 144 /*! Copy all trainable weight and biases from another equivalent layer but with different architecture; 145 The function can copy also extra parameters in addition to weights and biases if they are return; 146 by the function GetExtraLayerParameters */; 147 template <typename Arch>; 148 void CopyParameters(const VGeneralLayer<",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GeneralLayer_8h_source.html:5496,learn,learningRate,5496,doc/master/GeneralLayer_8h_source.html,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html,2,['learn'],"['learning', 'learningRate']"
Usability,"errors; bool fix_position[MAX_NUMBER_OF_PEAKS1]; // logical vector which allows to fix appropriate positions (not fit). However they are present in the estimated functional; double amp_init[MAX_NUMBER_OF_PEAKS1]; // initial values of peaks amplitudes, input parameters; double amp_calc[MAX_NUMBER_OF_PEAKS1]; // calculated values of fitted amplitudes, output parameters; double amp_err[MAX_NUMBER_OF_PEAKS1]; // amplitude errors; bool fix_amp[MAX_NUMBER_OF_PEAKS1]i; // logical vector, which allows to fix appropriate amplitudes (not fit). However they are present in the estimated functional; double area[MAX_NUMBER_OF_PEAKS1]; // calculated areas of peaks; double area_err[MAX_NUMBER_OF_PEAKS1]; // errors of peak areas; double sigma_init; // sigma parameter, see peak shape function; double sigma_calc;; double sigma_err;; bool fix_sigma;; double t_init // t parameter, see peak shape function; double t_calc;; double t_err;; bool fix_t;; double b_init // b parameter, see peak shape function; double b_calc;; double b_err;; bool fix_b;; double s_init; // s parameter, see peak shape function; double s_calc;; double s_err;; bool fix_s;; double a0_init; // background is estimated as a0+a1*x+a2*x*x; double a0_calc;; double a0_err;; bool fix_a0;; double a1_init;; double a1_calc;; double a1_err;; bool fix_a1;; double a2_init;; double a2_calc;; double a2_err;; bool fix_a2;; };; As an example we present a simple 1-dimensional synthetic spectrum with 5 peaks. The fit (obtained using above-given awmi fitting function) is given in Figure 5.1. The chi-square achieved in this fit was 0.76873. The input value of the fit (positions of peaks and their amplitudes) were estimated using peak searching function. Fit obtained using above given awmi fitting function. Let us go to a more complicated fit with a lot of overlapping peaks as in Figure 5.2. The initial positions of peaks were determined from original data, using peak searching function. The fit is not very good, as there are some peaks mis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:41729,simpl,simple,41729,root/htmldoc/guides/spectrum/Spectrum.html,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html,2,['simpl'],['simple']
Usability,"ers (structure); 1247 ; 1248 void removeLayer () { m_layers.pop_back (); } ///< remove one layer; 1249 ; 1250 ; 1251 void clear () ///< clear one layer; 1252 {; 1253 m_layers.clear ();; 1254 m_eErrorFunction = ModeErrorFunction::SUMOFSQUARES;; 1255 }; 1256 ; 1257 ; 1258 template <typename OutIterator>; 1259 void initializeWeights (WeightInitializationStrategy eInitStrategy,; 1260 OutIterator itWeight); ///< initialize the weights with the given strategy; 1261 ; 1262 protected:; 1263 ; 1264 void fillDropContainer (DropContainer& dropContainer, double dropFraction, size_t numNodes) const; ///< prepare the drop-out-container (select the nodes which are to be dropped out); 1265 ; 1266 ; 1267 private:; 1268 ; 1269 ModeErrorFunction m_eErrorFunction; ///< denotes the error function; 1270 size_t m_sizeInput; ///< input size of this DNN; 1271 size_t m_sizeOutput; ///< output size of this DNN; 1272 std::vector<Layer> m_layers; ///< layer-structure-data; 1273 ; 1274 protected:; 1275 // variables for JsMVA (interactive training in jupyter notebook); 1276 IPythonInteractive *fInteractive = nullptr;; 1277 bool * fExitFromTraining = nullptr;; 1278 UInt_t *fIPyMaxIter = nullptr, *fIPyCurrentIter = nullptr;; 1279 ; 1280 public:; 1281 ; 1282 // setup ipython interactive variables; 1283 void SetIpythonInteractive(IPythonInteractive* fI, bool* fE, UInt_t *M, UInt_t *C){; 1284 fInteractive = fI;; 1285 fExitFromTraining = fE;; 1286 fIPyMaxIter = M;; 1287 fIPyCurrentIter = C;; 1288 }; 1289 };; 1290 ; 1291 ; 1292 ; 1293 ; 1294typedef std::tuple<Settings&, Batch&, DropContainer&> pass_through_type;; 1295 ; 1296 ; 1297 ; 1298 ; 1299 ; 1300 ; 1301 ; 1302 } // namespace DNN; 1303} // namespace TMVA; 1304 ; 1305 ; 1306// include the implementations (in header file, because they are templated); 1307#include ""TMVA/NeuralNet.icc""; 1308 ; 1309#endif; 1310 ; Monitoring.h; NeuralNet.icc; Pattern.h; R#define R(a, b, c, d, e, f, g, h, i)Definition RSha256.hxx:110; e#define e(i)Definition RSha256.hxx:10",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:45973,clear,clear,45973,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,1,['clear'],['clear']
Usability,"ers: find the mapping of data members to otuput list entries in the output list and apply it. ; Definition at line 2766 of file TProofPlayer.cxx. ◆ SetupFeedback(). void TProofPlayerRemote::SetupFeedback ; (; ). overrideprotectedvirtual . Setup reporting of feedback objects. ; Reimplemented from TProofPlayer.; Reimplemented in TProofPlayerSuperMaster.; Definition at line 4095 of file TProofPlayer.cxx. ◆ StopFeedback(). void TProofPlayerRemote::StopFeedback ; (; ). overrideprotectedvirtual . Stop reporting of feedback objects. ; Reimplemented from TProofPlayer.; Definition at line 4118 of file TProofPlayer.cxx. ◆ StopProcess(). void TProofPlayerRemote::StopProcess ; (; Bool_t ; abort, . Int_t ; timeout = -1 . ). overridevirtual . Stop process after this event. ; Reimplemented from TProofPlayer.; Definition at line 3325 of file TProofPlayer.cxx. ◆ StoreFeedback(). void TProofPlayerRemote::StoreFeedback ; (; TObject * ; slave, . TList * ; out . ). overridevirtual . Store feedback results from the specified slave. ; Reimplemented from TProofPlayer.; Definition at line 4034 of file TProofPlayer.cxx. ◆ StoreOutput(). void TProofPlayerRemote::StoreOutput ; (; TList * ; out). overridevirtual . Store received output list. ; Reimplemented from TProofPlayer.; Definition at line 3852 of file TProofPlayer.cxx. ◆ Streamer(). void TProofPlayerRemote::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TProofPlayer.; Reimplemented in TProofPlayerSuperMaster. ◆ StreamerNVirtual(). void TProofPlayerRemote::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 366 of file TProofPlayer.h. Member Data Documentation. ◆ fDSet. TDSet* TProofPlayerRemote::fDSet. protected . Definition at line 288 of file TProofPlayer.h. ◆ fErrorHandler. ErrorHandlerFunc_t TProofPlayerRemote::fErrorHandler. protected . tdset for current processing ; Definition at line 289 of file TProofPlayer.h. ◆ fFeedback. TList* TP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerRemote.html:37514,feedback,feedback,37514,doc/master/classTProofPlayerRemote.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerRemote.html,1,['feedback'],['feedback']
Usability,"ers; class charts. ROOT; » HIST; » HIST; » THnT<Long64_t>. class THnT<Long64_t>: public THn. Helper struct to hold one dimension's bin range for THnBinIter. Function Members (Methods); public:. virtual~THnT<Long64_t>(); voidTObject::AbstractMethod(const char* method) const; voidTHnBase::Add(const THnBase* h, Double_t c = 1.); voidTHnBase::Add(const TH1* hist, Double_t c = 1.); voidTHn::AddBinContent(const Int_t* idx, Double_t v = 1.); virtual voidTHn::AddBinContent(Long64_t bin, Double_t v = 1.); virtual voidTHn::AddBinError2(Long64_t bin, Double_t e2); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTHnBase::Browse(TBrowser* b); voidTHnBase::CalculateErrors(Bool_t calc = kTRUE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THn*THn::CreateHn(const char* name, const char* title, const TH1* h1); static THn*THn::CreateHn(const char* name, const char* title, const THnBase* hn); virtual ROOT::THnBaseBinIter*THn::CreateIter(Bool_t respectAxisRange) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THnT_Long64_t_.html:1004,Clear,Clear,1004,root/html602/THnT_Long64_t_.html,https://root.cern,https://root.cern/root/html602/THnT_Long64_t_.html,2,['Clear'],['Clear']
Usability,"ers; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::SimpleLikelihoodRatioTestStat. class RooStats::SimpleLikelihoodRatioTestStat: public RooStats::TestStatistic. ; SimpleLikelihoodRatioTestStat: TestStatistic that returns -log(L[null] / L[alt]) where; L is the likelihood.; . Function Members (Methods); public:. virtual~SimpleLikelihoodRatioTestStat(); static TClass*Class(); virtual voidEnableDetailedOutput(bool e = true); virtual Double_tEvaluate(RooAbsData& data, RooArgSet& nullPOI); virtual const RooArgSet*GetDetailedOutput() const; virtual const TStringGetVarName() const; virtual TClass*IsA() const; RooStats::SimpleLikelihoodRatioTestStat&operator=(const RooStats::SimpleLikelihoodRatioTestStat&); boolParamsAreEqual(); virtual boolRooStats::TestStatistic::PValueIsRightTail() const; voidSetAltParameters(const RooArgSet& altParameters); static voidSetAlwaysReuseNLL(Bool_t flag); virtual voidSetConditionalObservables(const RooArgSet& set); voidSetNullParameters(const RooArgSet& nullParameters); voidSetReuseNLL(Bool_t flag); virtual voidShowMembers(TMemberInspector&); RooStats::SimpleLikelihoodRatioTestStatSimpleLikelihoodRatioTestStat(); RooStats::SimpleLikelihoodRatioTestStatSimpleLikelihoodRatioTestStat(const RooStats::SimpleLikelihoodRatioTestStat&); RooStats::SimpleLikelihoodRatioTestStatSimpleLikelihoodRatioTestStat(RooAbsPdf& nullPdf, RooAbsPdf& altPdf); RooStats::SimpleLikelihoodRatioTestStatSimpleLikelihoodRatioTestStat(RooAbsPdf& nullPdf, RooAbsPdf& altPdf, const RooArgSet& nullParameters, const RooArgSet& altParameters); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; private:. RooArgSet*fAltParameters; RooAbsPdf*fAltPdf; RooArgSetfConditionalObs; RooArgSet*fDetailedOutput!; boolfDetailedOutputEnabled; boolfFirstEval; RooAbsReal*fNllAlt! transient copy of the alt NLL; RooAbsReal*fNllNull! transient copy of the null NLL; RooArgSet*fNullParameters; RooAbsPdf*fNullPdf; Bool_tfReuseNl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__SimpleLikelihoodRatioTestStat.html:535,Simpl,SimpleLikelihoodRatioTestStat,535,root/html534/RooStats__SimpleLikelihoodRatioTestStat.html,https://root.cern,https://root.cern/root/html534/RooStats__SimpleLikelihoodRatioTestStat.html,8,['Simpl'],"['SimpleLikelihoodRatioTestStat', 'SimpleLikelihoodRatioTestStatSimpleLikelihoodRatioTestStat']"
Usability,"ert additional information when printed in the context of a tree structure. ;  ; void printComponentTree (const char *indent="""", const char *namePat=nullptr, Int_t nLevel=999);  Print tree structure of expression tree on given ostream, only branch nodes are printed. ;  ; void printDirty (bool depth=true) const;  Print information about current value dirty state information. ;  ; virtual void printMetaArgs (std::ostream &) const;  ; void printName (std::ostream &os) const override;  Print object name. ;  ; void printTitle (std::ostream &os) const override;  Print object title. ;  ; void printTree (std::ostream &os, TString indent="""") const override;  Print object tree structure. ;  ; bool recursiveCheckObservables (const RooArgSet *nset) const;  Recursively call checkObservables on all nodes in the expression tree. ;  ; void removeStringAttribute (const Text_t *key);  Delete a string attribute with a given key. ;  ; void resetDataToken ();  ; void setAttribute (const Text_t *name, bool value=true);  Set (default) or clear a named boolean attribute of this object. ;  ; void setDataToken (std::size_t index);  Sets the token for retrieving results in the BatchMode. For internal use only. ;  ; void setLocalNoDirtyInhibit (bool flag) const;  ; void SetName (const char *name) override;  Set the name of the TNamed. ;  ; void SetNameTitle (const char *name, const char *title) override;  Set all the TNamed parameters (name and title). ;  ; void setProhibitServerRedirect (bool flag);  ; void setStringAttribute (const Text_t *key, const Text_t *value);  Associate string 'value' to this object under key 'key'. ;  ; void setTransientAttribute (const Text_t *name, bool value=true);  Set (default) or clear a named boolean attribute of this object. ;  ; void setWorkspace (RooWorkspace &ws);  ; const std::map< std::string, std::string > & stringAttributes () const;  ; const std::set< std::string > & transientAttributes () const;  ; RooWorkspace * workspace () const;  ; const RefCountL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCBShape.html:38268,clear,clear,38268,doc/master/classRooCBShape.html,https://root.cern,https://root.cern/doc/master/classRooCBShape.html,29,['clear'],['clear']
Usability,"ert additional information when printed in the context of a tree structure. ;  ; void printComponentTree (const char *indent="""", const char *namePat=nullptr, Int_t nLevel=999);  Print tree structure of expression tree on given ostream, only branch nodes are printed. ;  ; void printDirty (bool depth=true) const;  Print information about current value dirty state information. ;  ; virtual void printMetaArgs (std::ostream &) const;  ; void printName (std::ostream &os) const override;  Print object name. ;  ; void printTitle (std::ostream &os) const override;  Print object title. ;  ; void printTree (std::ostream &os, TString indent="""") const override;  Print object tree structure. ;  ; bool recursiveCheckObservables (const RooArgSet *nset) const;  Recursively call checkObservables on all nodes in the expression tree. ;  ; void removeStringAttribute (const Text_t *key);  Delete a string attribute with a given key. ;  ; void resetDataToken ();  ; void setAttribute (const Text_t *name, bool value=true);  Set (default) or clear a named boolean attribute of this object. ;  ; void setDataToken (std::size_t index);  Sets the token for retrieving results in the BatchMode. For internal use only. ;  ; void setLocalNoDirtyInhibit (bool flag) const;  ; void SetName (const char *name) override;  Set the name of the TNamed. ;  ; void SetNameTitle (const char *name, const char *title) override;  Set all the TNamed parameters (name and title). ;  ; void setProhibitServerRedirect (bool flag);  ; void setStringAttribute (const Text_t *key, const Text_t *value);  Associate string 'value' to this object under key 'key'. ;  ; void setTransientAttribute (const Text_t *name, bool value=true);  Set (default) or clear a named boolean attribute of this object. ;  ; void setWorkspace (RooWorkspace &ws);  ; const std::map< std::string, std::string > & stringAttributes () const;  ; const std::set< std::string > & transientAttributes () const;  ; virtual void translate (RooFit::Detail::CodeSquashCon",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinWidthFunction.html:28006,clear,clear,28006,doc/master/classRooBinWidthFunction.html,https://root.cern,https://root.cern/doc/master/classRooBinWidthFunction.html,102,['clear'],['clear']
Usability,"erverList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; virtual voidchangeBasis(RooFormulaVar* basis); voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidcleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual RooResolutionModel*convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooResolutionModel.html:5012,clear,clearValueDirty,5012,root/html534/RooResolutionModel.html,https://root.cern,https://root.cern/root/html534/RooResolutionModel.html,4,['clear'],['clearValueDirty']
Usability,"es a category object has. In computations, values are expected to change often, while shapes remain mostly constant (unless e.g. a new range is set for an observable).; Nodes of a computation graph are connected using instances of RooAbsProxy. If Node B declares a member RooTemplateProxy<TypeOfNodeA>, Node A will be registered as a server of values to Node B, and Node B will know that it is a client of node A. Using functions like dependsOn(), or getObservables() / getParameters(), the relation of A --> B can be queried. Using graphVizTree(), one can create a visualisation of the expression tree.; An instance of RooAbsArg can have named attributes. It also has flags to indicate that either its value or its shape were changed (= it is dirty). RooAbsArg provides functionality to manage client/server relations in a computation graph (clientServerInterface), and helps propagating value/shape changes through the graph. RooAbsArg implements interfaces for inspecting client/server relationships (clientServerInterface) and setting/clearing/querying named attributes. Caching of values; The values of nodes in the computation graph are cached in RooFit. If a value is used in two nodes of a graph, it doesn't need to be recomputed. If a node acquires a new value, it notifies its consumers (""clients"") that their cached values are dirty. See the functions in optimisationInterface for details. A node uses its isValueDirty() and isShapeDirty() functions to decide if a computation is necessary. Caching can be vetoed globally by setting a bit using setDirtyInhibit(). This will make computations slower, but all the nodes of the computation graph will be evaluated irrespective of whether their state is clean or dirty. Using setOperMode(), caching can also be enabled/disabled for single nodes. ; Definition at line 79 of file RooAbsArg.h. Classes; struct  ProxyListCache;  . Public Types; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeAc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:2291,clear,clearing,2291,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['clear'],['clearing']
Usability,"es a simple example on how to use the trained classifiers (with categories) within an analysis module ;  TMVACrossValidation.C This macro provides an example of how to use TMVA for k-folds cross evaluation ;  TMVACrossValidationApplication.C This macro provides an example of how to use TMVA for k-folds cross evaluation in application ;  TMVACrossValidationRegression.C This macro provides an example of how to use TMVA for k-folds cross evaluation ;  TMVAGAexample.C This exectutable gives an example of a very simple use of the genetic algorithm of TMVA ;  TMVAGAexample2.C This exectutable gives an example of a very simple use of the genetic algorithm of TMVA ;  TMVAMinimalClassification.C Minimal self-contained example for setting up TMVA with binary classification ;  TMVAMulticlass.C This macro provides a simple example for the training and testing of the TMVA multiclass classification ;  TMVAMulticlassApplication.C This macro provides a simple example on how to use the trained multiclass classifiers within an analysis module ;  TMVAMultipleBackgroundExample.C This example shows the training of signal with three different backgrounds Then in the application a tree is created with all signal and background events where the true class ID and the three classifier outputs are added finally with the application tree, the significance is maximized with the help of the TMVA genetic algrorithm ;  TMVARegression.C This macro provides examples for the training and testing of the TMVA classifiers ;  TMVARegressionApplication.C This macro provides a simple example on how to use the trained regression MVAs within an analysis module ;  ► tree;  basic.C Read data from an ascii file and create a root file with an histogram and an ntuple ;  basic2.C Create can ntuple reading data from an ascii file ;  bill.C Benchmark comparing row-wise and column-wise storage performance ;  cernbuild.C Read data (CERN staff) from an ascii file and create a root file with a Tree ;  cernstaff.C Playing",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/files.html:159743,simpl,simple,159743,doc/v614/files.html,https://root.cern,https://root.cern/doc/v614/files.html,2,['simpl'],['simple']
Usability,"es can be accessed from your PC, from the web and from large-scale file delivery systems used e.g. in the GRID. ROOT trees spread over several files can be chained and accessed as a unique object, allowing for loops over huge amounts of data.; Mine data Powerful mathematical and statistical tools are provided to operate on your data. The full power of a C++ application and of parallel processing is available for any kind of data manipulation. Data can also be generated following any statistical distribution and modeled, making it possible to simulate complex systems.; Publish results Results can be displayed with histograms, scatter plots, fitting functions. ROOT graphics may be adjusted real-time by few mouse clicks. Publication-quality figures can be saved in PDF or other formats.; Run interactively or build your own application You can use the Cling C++ interpreter for your interactive sessions and to write macros, or you can compile your program to run at full speed. In both cases, you can also create a graphical user interface.; Use ROOT within other languages ROOT provides a set of bindings in order to seamlessly integrate with existing languages such as Python, R and Mathematica. Save dataAccess dataProcess dataShow resultsInteractive or built applicationIntegration with other languages. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/about-root.html:4191,guid,guidelines,4191,d/about-root.html,https://root.cern,https://root.cern/d/about-root.html,1,['guid'],['guidelines']
Usability,"es for the subsequent evaluation of the; test statistics. RooAbsData* GenerateToyDataImportanceSampling(RooArgSet& paramPoint, double& weight) const; This method generates a toy data set for importance sampling for the given parameter point taking; global observables into account.; The values of the generated global observables remain in the pdf's variables.; They have to have those values for the subsequent evaluation of the; test statistics. RooAbsData* Generate(RooAbsPdf& pdf, RooArgSet& observables, const RooDataSet* protoData = NULL, int forceEvents = 0) const; This is the generate function to use in the context of the ToyMCSampler; instead of the standard RooAbsPdf::generate(...).; It takes into account whether the number of events is given explicitly; or whether it should use the expected number of events. It also takes; into account the option to generate a binned data set (ie RooDataHist). void ClearCache(); clear the cache obtained from the pdf used for speeding the toy and global observables generation; needs to be called every time the model pdf (fPdf) changes. ToyMCSampler(); Proof constructor. Do not use. ToyMCSampler(RooStats::TestStatistic& ts, Int_t ntoys). void SetAlwaysUseMultiGen(Bool_t flag); { fgAlwaysUseMultiGen = flag ; }. void SetUseMultiGen(Bool_t flag); { fUseMultiGen = flag ; }. RooAbsData* GenerateToyData(RooArgSet& paramPoint) const; generates toy data; without weight. SamplingDistribution* AppendSamplingDistribution(RooArgSet& allParameters, RooStats::SamplingDistribution* last, Int_t additionalMC); Extended interface to append to sampling distribution more samples. Double_t EvaluateTestStatistic(RooAbsData& data, RooArgSet& nullPOI); Main interface to evaluate the test statistic on a dataset. TestStatistic* GetTestStatistic() const; { return fTestStat; }. Double_t ConfidenceLevel() const; { return 1. - fSize; }. void Initialize(RooAbsArg& , RooArgSet& , RooArgSet& ); { return fNToys; }. void SetNToys(const Int_t ntoy); { fNToys = ntoy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__ToyMCSampler.html:6660,clear,clear,6660,root/html532/RooStats__ToyMCSampler.html,https://root.cern,https://root.cern/root/html532/RooStats__ToyMCSampler.html,3,"['Clear', 'clear']","['ClearCache', 'clear']"
Usability,"es for using signals/slots mechanism in a standalone executable program do not differ from what was described previously. Let’s remind that. a slot can be any class method with a generated Cling dictionary; a slot can be a function with a dictionary. Detailed information how to generate a dictionary can be found on http://root.cern.ch/root/CintGenerator.html; The following example demonstrates how to use signals/slots mechanism in a standalone executable program on linux platform with the gcc compiler.; tst.C; #include <TQObject.h>; #include <RQ_OBJECT.h>. class A {; RQ_OBJECT(""A""); private:; Int_t fValue;; public:; A() : fValue(0) { }; ~A() { }; void SetValue(Int_t value); // *SIGNAL*; void PrintValue() const { printf(""value = %d\n"", fValue); }; };; void A::SetValue(Int_t value) { // Set new value; // Emit signal ""SetValue(Int_t)"" with a single parameter; if (value != fValue) {; fValue = value;; Emit(""SetValue(Int_t)"", fValue);; }; }; // Main program; #ifdef STANDALONE; int main(int argc, char **argv) {; A* a = new A();; A* b = new A();; a->Connect(""SetValue(Int_t)"", ""A"", b, ""SetValue(Int_t)"");; printf(""n******* Test of SetValue(Int_t) signal *******n"");; b->SetValue(10);; printf(""nt***** b before ******n"");; b->PrintValue();; a->SetValue(20);; printf(""t***** b after a->SetValue(20) ******n"");; b->PrintValue();; return 0;; }; #endif; ACLiC simplifies this procedure and allows the dictionary generation by:; root[] .L tst.C++; It will create the shared library tst_C.so.; The next line will create an executable:; g++ -otst tst.C `root-config --cflags --libs` ./tst_C.so -DSTANDALONE; The library tst_C.so is a dynamically loaded library and should be located in $LD_LIBRARY_PATH. The current working directory should be added to $LD_LIBRARY_PATH via:; export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:./; To run it, you just do:; ./tst; 25.8 Widgets in Detail; 25.8.1 Buttons; Buttons are a popular group of widgets designed to provide specific interfaces for user interaction. TGButton",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1175266,simpl,simplifies,1175266,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simplifies']
Usability,"es in the projection is set to the number of entries of the 2-D histogram, otherwise the number of entries is incremented by 1 for all non empty cells.; The option can also be used to specify the projected profile error type. Values which can be used are 's', 'i', or 'g'. See TProfile::BuildOptions for details ; Definition at line 1389 of file TProfile2D.cxx. ◆ ProjectionXY(). TH2D * TProfile2D::ProjectionXY ; (; const char * ; name = ""_pxy"", . Option_t * ; option = ""e"" . ); const. Project this profile2D into a 2-D histogram along X,Y. ; The projection is always of the type TH2D. if option ""E"" is specified the errors of the projected histogram are computed and set to be equal to the errors of the profile. Option ""E"" is defined as the default one in the header file.; if option """" is specified the histogram errors are simply the sqrt of its content; if option ""B"" is specified, the content of bin of the returned histogram will be equal to the GetBinEntries(bin) of the profile,; if option ""C=E"" the bin contents of the projection are set to the bin errors of the profile; if option ""W"" is specified the bin content of the projected histogram is set to the product of the bin content of the profile and the entries. With this option the returned histogram will be equivalent to the one obtained by filling directly a TH2D using the 3-rd value as a weight. This option makes sense only for profile filled with all weights =1. When the profile is weighted (filled with weights different than 1) the bin error of the projected histogram (obtained using this option ""W"") cannot be correctly computed from the information stored in the profile. In that case the obtained histogram contains as bin error square the weighted sum of the square of the profiled observable (TProfile2D::fSumw2[bin] ) . Definition at line 1287 of file TProfile2D.cxx. ◆ PutStats(). void TProfile2D::PutStats ; (; Double_t * ; stats). overridevirtual . Replace current statistics with the values in array stats. ; Reimp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProfile2D.html:96486,simpl,simply,96486,doc/master/classTProfile2D.html,https://root.cern,https://root.cern/doc/master/classTProfile2D.html,1,['simpl'],['simply']
Usability,"es of the event; int fEventSize; // size (in bytes) of the event; };. The data members of the Particle class describe the particle properties as shown below:; class Particle {; public:; double fPosX,fPosY,fPosZ; // particle position nearest to interaction point; double fMomentum; // particle momentum; double fMomentumPhi; // particle direction (phi); double fMomentumEta; // particle direction (eta); Long64_t fTags[128]; // particle tags; };. The TTree contains a branch event, which in turn contains the branches fParticles and fEventSize. It simply reflects the layout of class EventData. Each TTree entry has one object of type class EventData, which in turn has a collection of particles. Each tree entry can have a different number of particles. There are 200 TTree entries containing a total of 22994 particles.; If you are curious how we generated the TTree: the script is in our git repository.; . ‹ Introductory Tutorials; up; Accessing a TTree With a TBrowser ›. Navigate through this book; Meet a TTree; Accessing a TTree With a TBrowser; Using TTree::Draw() to access a TTree; TTree and Its Data; Using a Macro to Read a TTree; Histogramming; Fit Panel; Compiling Your Code (also known as ACLiC); Accessing a TTree With a TSelector; Histogramming in a Selector; Using a TSelector with PROOF; The End. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/meet-ttree.html:4896,guid,guidelines,4896,d/meet-ttree.html,https://root.cern,https://root.cern/d/meet-ttree.html,1,['guid'],['guidelines']
Usability,"es of the; neighboring triangles can be smoothed (shaded). If desired the display of the; shadow can be painted as well. The function does not apply for; kModeGroupSimple display modes group.; Possible values for shading are:. kNotShaded; kShaded. Possible values for shadow are:. kShadowsNotPainted; kShadowsPainted. Default values:. shading = kShaded; shadow = kShadowsNotPainted. Light modes group, display mode = surface, 64 x 64 channels, not shaded. Light modes group, display mode = surface, 64 x 64 channels, shaded, with; shadow.; Function:; TSpectrum2Painter::SetBezier(Int_t bezier); For kModeGroupSimple display modes group and for kDisplayModeGrid,; kDisplayModeLinesX >and kDisplayModeLinesY display modes one; can smooth data using Bezier smoothing algorithm. The function does not apply; for other display modes groups and display modes. Possible values are:. kNoBezierInterpol; kBezierInterpol. Default value is:. bezier = kNoBezierInterpol. Simple modes group, display mode = linesX, 64 x 64 channels with Bezier; smoothing.; Function:; TSpectrum2Painter::SetContourWidth(Int_t width); This function applies only for kDisplayModeContours display mode.; One can change the width between horizontal slices and thus their density.; Default value: width=50. Simple modes group, display mode = contours, 64 x 64 channels. Width between; slices was set to 30.; Function:; TSpectrum2Painter::SetLightHeightWeight(Double_t weight); For kModeGroupLightHeight display modes group one can change the; weight between both shading algorithm. The function does not apply for other; display modes groups. Default value is: weight=0.5. Light - height modes group, display mode = surface, 64 x 64 channels.; The weight between both shading algorithms is set to 0.7.; Function:; TSpectrum2Painter::SetChanMarks(Int_t enable,Int_t color,Int_t width,Int_t height,Int_t style); In addition to the surface drawn using any above given algorithm one can display; channel marks. One can control the color as",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSpectrum2Painter.html:25258,Simpl,Simple,25258,root/html532/TSpectrum2Painter.html,https://root.cern,https://root.cern/root/html532/TSpectrum2Painter.html,4,['Simpl'],['Simple']
Usability,"es the copy to the histogram. When the histogram is deleted, the copy is deleted also.; When a pad is deleted or cleared, all objects in the pad with the kCanDelete bit set are deleted automatically. Currently the objects created by the DrawCopy methods, have the kCanDelete bit set and are therefore owned by the pad.; 8.4 Ownership by the User; The user owns all objects not described in one of the above cases. TObject has two bits, kCanDelete and kMustCleanup, that influence how an object is managed (in TObject::fBits). These are in an enumeration in TObject.h. To set these bits do:; MyObject->SetBit(kCanDelete); MyObject->SetBit(kMustCleanup); The bits can be reset and tested with the TObject::ResetBit and TObject::TestBit methods.; 8.4.1 The kCanDelete Bit; The gROOT collections (see above) own their members and will delete them regardless of the kCanDelete bit. In all other collections, when the collection Clear method is called (i.e. TList::Clear()), members with the kCanDelete bit set, are deleted and removed from the collection. If the kCanDelete bit is not set, the object is only removed from the collection but not deleted.; If a collection Delete (TList::Delete()) method is called, all objects in the collection are deleted without considering the kCanDelete bit. It is important to realize that deleting the collection (i.e. delete MyCollection), DOES NOT delete the members of the collection.; If the user specified MyCollection->SetOwner() the collection owns the objects and delete MyCollection will delete all its members. Otherwise, you need to:; // delete all member objects in the collection; MyCollection->Delete();. // and delete the collection object; delete MyCollection;; Note that kCanDelete is automatically set by the DrawCopy method and the user can set it for any object. For example, the user must manage all graphics primitives. If you want TCanvas to delete the primitive you created you have to set the kCanDelete bit.; The kCanDelete bit setting is di",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:287061,Clear,Clear,287061,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Clear'],['Clear']
Usability,"es the optional argument to set a new name to the newly created object.; If the object class has a DirectoryAutoAdd function, it will be called at the end of the function with the parameter gDirectory. This usually means that the object will be appended to the current ROOT directory. ; Reimplemented from TObject.; Definition at line 46 of file RooFitResult.h. ◆ conditionalCovarianceMatrix(). TMatrixDSym RooFitResult::conditionalCovarianceMatrix ; (; const RooArgList & ; params); const. Return a reduced covariance matrix, which is calculated as. . \[; V_\mathrm{red} = \bar{V_{22}} = V_{11} - V_{12} \cdot V_{22}^{-1} \cdot V_{21},; \]. where \( V_{11},V_{12},V_{21},V_{22} \) represent a block decomposition of the covariance matrix into observables that are propagated (labeled by index '1') and that are not propagated (labeled by index '2'), and \( \bar{V_{22}} \) is the Shur complement of \( V_{22} \), calculated as shown above.; (Note that \( V_\mathrm{red} \) is not a simple sub-matrix of \( V \)) ; Definition at line 1170 of file RooFitResult.cxx. ◆ constPars(). const RooArgList & RooFitResult::constPars ; (; ); const. inline . Return list of constant parameters. ; Definition at line 103 of file RooFitResult.h. ◆ correlation() [1/5]. const RooArgList * RooFitResult::correlation ; (; const char * ; parname); const. Return the set of correlation coefficients of parameter 'par' with all other floating parameters. ; Definition at line 411 of file RooFitResult.cxx. ◆ correlation() [2/5]. double RooFitResult::correlation ; (; const char * ; parname1, . const char * ; parname2 . ); const. Return the correlation between parameters 'par1' and 'par2'. ; Definition at line 390 of file RooFitResult.cxx. ◆ correlation() [3/5]. const RooArgList * RooFitResult::correlation ; (; const RooAbsArg & ; par); const. inline . Return pointer to list of correlations of all parameters with par. ; Definition at line 122 of file RooFitResult.h. ◆ correlation() [4/5]. double RooFitResult::cor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFitResult.html:24026,simpl,simple,24026,doc/master/classRooFitResult.html,https://root.cern,https://root.cern/doc/master/classRooFitResult.html,1,['simpl'],['simple']
Usability,"es(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual RooResolutionModel*RooResolutionModel::convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&RooResolutionModel::convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooGaussModel.html:3384,clear,clearEvalError,3384,root/html534/RooGaussModel.html,https://root.cern,https://root.cern/root/html534/RooGaussModel.html,18,['clear'],['clearEvalError']
Usability,"es, given the gradients and the learning rate. ; Definition at line 428 of file GeneralLayer.h. ◆ UpdateBiasGradients(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateBiasGradients ; (; const std::vector< Matrix_t > & ; biasGradients, . const Scalar_t ; learningRate . ). Updates the bias gradients, given some other weight gradients and learning rate. ; Definition at line 448 of file GeneralLayer.h. ◆ UpdateWeightGradients(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateWeightGradients ; (; const std::vector< Matrix_t > & ; weightGradients, . const Scalar_t ; learningRate . ). Updates the weight gradients, given some other weight gradients and learning rate. ; Definition at line 438 of file GeneralLayer.h. ◆ UpdateWeights(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateWeights ; (; const std::vector< Matrix_t > & ; weightGradients, . const Scalar_t ; learningRate . ). Updates the weights, given the gradients and the learning rate,. ; Definition at line 418 of file GeneralLayer.h. ◆ WriteMatrixToXML(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::WriteMatrixToXML ; (; void * ; node, . const char * ; name, . const Matrix_t & ; matrix . ). Definition at line 521 of file GeneralLayer.h. ◆ WriteTensorToXML(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::WriteTensorToXML ; (; void * ; node, . const char * ; name, . const std::vector< Matrix_t > & ; tensor . ). helper functions for XML ; Definition at line 496 of file GeneralLayer.h. Member Data Documentation. ◆ fActivationGradients. template<typename Architecture_t > . Tensor_t TMVA::DNN::VGeneralLayer< Architecture_t >::fActivationGradients. protected . Gradients w.r.t. the activations of this layer. ; Definition at line 78 of file GeneralLayer.h. ◆ fBatchSize. template<typename Architecture_t > . size_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html:26625,learn,learningRate,26625,doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html,1,['learn'],['learningRate']
Usability,"es. Bool_t operator==(Int_t index) const; Equality operator with a integer (compares with state index number). Bool_t operator==(const char* label) const; Equality operator with a string (compares with state label string). Bool_t operator==(const RooAbsArg& other); Equality operator with another RooAbsArg. Only functional; is also a RooAbsCategory, will return true if index is the same. Bool_t isValidIndex(Int_t index) const; Check if state with given index is defined. Bool_t isValidLabel(const char* label) const; Check if state with given name is defined. const RooCatType* defineType(const char* label); Define a new state with given name. The lowest available; integer number is assigned as index value. const RooCatType* defineTypeUnchecked(const char* label, Int_t index); Internal version of defineType that does not check if type; already exists. const RooCatType* defineType(const char* label, Int_t index); Define new state with given name and index number. void clearTypes(); Delete all currently defined states. const RooCatType* lookupType(const RooCatType& type, Bool_t printError = kFALSE) const; Find our type that matches the specified type, or return 0 for no match. const RooCatType* lookupType(Int_t index, Bool_t printError = kFALSE) const; Find our type corresponding to the specified index, or return 0 for no match. const RooCatType* lookupType(const char* label, Bool_t printError = kFALSE) const; Find our type corresponding to the specified label, or return 0 for no match. Bool_t isValid() const; Check if current value is a valid state. Bool_t isValid(const RooCatType& value) const; Check if given state is defined for this object. Roo1DTable* createTable(const char* label) const; Create a table matching the shape of this category. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream (dummy for now). void writeToStream(ostream& os, Bool_t compact) const; Write object contents to ostream. void printValue",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCategory.html:21682,clear,clearTypes,21682,root/html528/RooAbsCategory.html,https://root.cern,https://root.cern/root/html528/RooAbsCategory.html,3,['clear'],['clearTypes']
Usability,"es. Function documentation; RooMappedCategory(const char* name, const char* title, RooAbsCategory& inputCat, const char* defCatName = ""NotMapped"", Int_t defCatIdx = NoCatIdx); Constructor with input category and name of default output state, which is assigned; to all input category states that do not follow any mapping rule. RooMappedCategory(const RooMappedCategory& other, const char* name = 0). ~RooMappedCategory(); Destructor. Bool_t map(const char* inKeyRegExp, const char* outKeyName, Int_t outKeyNum = NoCatIdx); Add mapping rule: any input category state label matching the 'inKeyRegExp'; wildcard expression will be mapped to an output state with name 'outKey'. Rules are evaluated in the order they were added. In case an input state; matches more than one rule, the first rules output state will be assigned. RooCatType evaluate() const; Calculate the current value of the object. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this mapped category to the specified stream. In addition to the info; from RooAbsCategory::printStream() we add:. Standard : input category; Shape : default value; Verbose : list of mapping rules. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from given stream. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooMappedCategory to more intuitively reflect the contents of the; product operator construction. void writeToStream(ostream& os, Bool_t compact) const; Write object contents to given stream. inline RooMappedCategory(); { }. TObject* clone(const char* newname) const; { return new RooMappedCategory(*this,newname); }. Entry& operator=(const RooMappedCategory& ). » Last changed: Tue Jun 30 14:33:57 2015 » Last generated: 2015-06-30 14:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMappedCategory.html:25576,intuit,intuitively,25576,root/html602/RooMappedCategory.html,https://root.cern,https://root.cern/root/html602/RooMappedCategory.html,2,['intuit'],['intuitively']
Usability,"es. These; exceptions occur if the outline shape is not a convex polygon.; Both the X3D and OpenGL renderers expect polygons to be convex.; The OpenGL spec specifies that points defining a polygon using the; GL_POLYGON primitive may be rendered as the convex hull of that set. Solid rendering under X3D can also give unexpected artifacts if; the combination of x-y-z offsets and scales for the segments are; chosen in such a manner that they represent a concave shape when; sliced along a plane parallel to the z axis. Choosing sets of point that represent a malformed polygon is; not supported, but testing for such a condition is not implemented; and thus it is left to the user to avoid this mistake. . Function Members (Methods); public:. virtual~TXTRU(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(TObject& xtru) const; virtual voidDefineSection(Int_t secNum, Float_t z, Float_t scale = 1., Float_t x0 = 0., Float_t y0 = 0.); virtual voidDefineVertex(Int_t pointNum, Float_t x, Float_t y); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXTRU.html:2384,Clear,Clear,2384,root/html602/TXTRU.html,https://root.cern,https://root.cern/root/html602/TXTRU.html,2,['Clear'],['Clear']
Usability,"es; # passing the cuts, if any.; b1b2_cut = d.Filter(cutb1b2); minVal = b1b2_cut.Min('b1'); maxVal = b1b2_cut.Max('b1'); meanVal = b1b2_cut.Mean('b1'); nonDefmeanVal = b1b2_cut.Mean(""b2""); print('The mean is always included between the min and the max: {0} <= {1} <= {2}'.format(minVal.GetValue(), meanVal.GetValue(), maxVal.GetValue())); ; # `Histo1D` action; # The `Histo1D` action allows to fill an histogram. It returns a TH1F filled; # with values of the column that passed the filters. For the most common; # types, the type of the values stored in the column is automatically; # guessed.; hist = d.Filter(cutb1).Histo1D('b1'); print('Filled h {0} times, mean: {1}'.format(hist.GetEntries(), hist.GetMean())); ; # Express your chain of operations with clarity!; # We are discussing an example here but it is not hard to imagine much more; # complex pipelines of actions acting on data. Those might require code; # which is well organised, for example allowing to conditionally add filters; # or again to clearly separate filters and actions without the need of; # writing the entire pipeline on one line. This can be easily achieved.; # We'll show this re-working the `Count` example:; cutb1_result = d.Filter(cutb1);; cutb1b2_result = d.Filter(cutb1b2);; cutb1_cutb1b2_result = cutb1_result.Filter(cutb1b2); ; # Now we want to count:; evts_cutb1_result = cutb1_result.Count(); evts_cutb1b2_result = cutb1b2_result.Count(); evts_cutb1_cutb1b2_result = cutb1_cutb1b2_result.Count(); ; print('Events passing cutb1: {}'.format(evts_cutb1_result.GetValue())); print('Events passing cutb1b2: {}'.format(evts_cutb1b2_result.GetValue())); print('Events passing both: {}'.format(evts_cutb1_cutb1b2_result.GetValue())); ; # Calculating quantities starting from existing columns; # Often, operations need to be carried out on quantities calculated starting; # from the ones present in the columns. We'll create in this example a third; # column, the values of which are the sum of the *b1* and *b2* ones, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df001__introduction_8py.html:3401,clear,clearly,3401,doc/master/df001__introduction_8py.html,https://root.cern,https://root.cern/doc/master/df001__introduction_8py.html,1,['clear'],['clearly']
Usability,"es; TObjArray*fShapes-> list of shapes; Int_tfSizePNEIdsize of the array of unique ID's for PN entries; Bool_tfStreamVoxelsflag to allow voxelization I/O; Bool_tfTimeCuttime cut for tracks; Double_tfTmax! upper time limit for tracks drawing; Double_tfTmin! lower time limit for tracks drawing; TGeoNode*fTopNode! top physical node; TGeoVolume*fTopVolume! top level volume in geometry; TObjArray*fTracks-> list of tracks attached to geometry; TObjArray*fUniqueVolumes-> list of unique volumes; Int_t*fValuePNEId[fSizePNEId] array of pointers to PN entries with ID's; Double_tfVisDensitytransparency threshold by density; Int_tfVisLevelmaximum visualization depth; Int_tfVisOptionglobal visualization option; TObjArray*fVolumes-> list of volumes; static Bool_tfgLockNavigators! Lock existing navigators; static Int_tfgNumThreads! Number of registered threads; static map<long,int>fgThreadId! Thread id's map. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ClearThreadData() const. TGeoManager(); Default constructor. TGeoManager(const char* name, const char* title); Constructor. void Init(); Initialize manager class. TGeoManager(const TGeoManager& ); copy constructor. TGeoManager& operator=(const TGeoManager& ); assignment operator. ~TGeoManager(); Destructor. Int_t AddMaterial(const TGeoMaterial* material); Add a material to the list. Returns index of the material in list. Int_t AddOverlap(const TNamed* ovlp); Add an illegal overlap/extrusion to the list. Int_t AddTransformation(const TGeoMatrix* matrix); Add a matrix to the list. Returns index of the matrix in list. Int_t AddShape(const TGeoShape* shape); Add a shape to the list. Returns index of the shape in list. Int_t AddTrack(Int_t id, Int_t pdgcode, TObject* particle = 0); Add a track to the list of tracks. Use this for primaries only. For secondaries,; add them to the parent track. The method create objects that are registered; to the analysis manager but have to be cleaned-up ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoManager.html:36292,Clear,ClearThreadData,36292,root/html532/TGeoManager.html,https://root.cern,https://root.cern/root/html532/TGeoManager.html,1,['Clear'],['ClearThreadData']
Usability,"escribing current object ; Reimplemented from TSelector.; Definition at line 60 of file TSelectorEntries.h. ◆ Notify(). bool TSelectorEntries::Notify ; (; ). overridevirtual . This function is called at the first entry of a new tree in a chain. ; Reimplemented from TSelector.; Definition at line 136 of file TSelectorEntries.cxx. ◆ Process(). bool TSelectorEntries::Process ; (; Long64_t ; entry). overridevirtual . The Process() function is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ; The entry argument specifies which entry in the currently loaded tree is to be processed. It can be passed to either TSelectorEntries::GetEntry() or TBranch::GetEntry() to read either all or the required parts of the data. When processing keyed objects with PROOF, the object is already loaded and is available via the fObject pointer.; This function should contain the ""body"" of the analysis. It can contain simple or elaborate selection criteria, run algorithms on the data of the event and typically fill histograms.; The processing can be stopped by calling Abort().; Use fStatus to set the return value of TTree::Process().; The return value is currently not used. ; Reimplemented from TSelector.; Definition at line 161 of file TSelectorEntries.cxx. ◆ SetObject(). void TSelectorEntries::SetObject ; (; TObject * ; obj). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 54 of file TSelectorEntries.h. ◆ SetOption(). void TSelectorEntries::SetOption ; (; const char * ; option). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 53 of file TSelectorEntries.h. ◆ SetSelection(). void TSelectorEntries::SetSelection ; (; const char * ; selection). virtual . Set the selection expression. ; Definition at line 198 of file TSelectorEntries.cxx. ◆ SlaveBegin(). void TSelectorEntries::SlaveBegin ; (; TTree * ; tree). overridevirtual . The SlaveBegin() function is called after the Begin() function. ; When ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelectorEntries.html:18127,simpl,simple,18127,doc/master/classTSelectorEntries.html,https://root.cern,https://root.cern/doc/master/classTSelectorEntries.html,1,['simpl'],['simple']
Usability,"escription; Write and read STL vectors in a tree. . ; #include <vector>; ; #include ""TFile.h""; #include ""TTree.h""; #include ""TCanvas.h""; #include ""TFrame.h""; #include ""TH1F.h""; #include ""TBenchmark.h""; #include ""TRandom.h""; #include ""TSystem.h""; ; void write(); {; ; TFile *f = TFile::Open(""hvector.root"",""RECREATE"");; ; if (!f) { return; }; ; // Create one histograms; TH1F *hpx = new TH1F(""hpx"",""This is the px distribution"",100,-4,4);; hpx->SetFillColor(48);; ; std::vector<float> vpx;; std::vector<float> vpy;; std::vector<float> vpz;; std::vector<float> vrand;; ; // Create a TTree; TTree *t = new TTree(""tvec"",""Tree with vectors"");; t->Branch(""vpx"",&vpx);; t->Branch(""vpy"",&vpy);; t->Branch(""vpz"",&vpz);; t->Branch(""vrand"",&vrand);; ; // Create a new canvas.; TCanvas *c1 = new TCanvas(""c1"",""Dynamic Filling Example"",200,10,700,500);; ; gRandom->SetSeed();; const Int_t kUPDATE = 1000;; for (Int_t i = 0; i < 25000; i++) {; Int_t npx = (Int_t)(gRandom->Rndm(1)*15);; ; vpx.clear();; vpy.clear();; vpz.clear();; vrand.clear();; ; for (Int_t j = 0; j < npx; ++j) {; ; Float_t px,py,pz;; gRandom->Rannor(px,py);; pz = px*px + py*py;; Float_t random = gRandom->Rndm(1);; ; hpx->Fill(px);; ; vpx.emplace_back(px);; vpy.emplace_back(py);; vpz.emplace_back(pz);; vrand.emplace_back(random);; ; }; if (i && (i%kUPDATE) == 0) {; if (i == kUPDATE) hpx->Draw();; c1->Modified();; c1->Update();; if (gSystem->ProcessEvents()); break;; }; t->Fill();; }; f->Write();; ; delete f;; }; ; ; void read(); {; ; TFile *f = TFile::Open(""hvector.root"",""READ"");; ; if (!f) { return; }; ; TTree *t; f->GetObject(""tvec"",t);; ; std::vector<float> *vpx = nullptr;; ; // Create a new canvas.; TCanvas *c1 = new TCanvas(""c1"",""Dynamic Filling Example"",200,10,700,500);; ; const Int_t kUPDATE = 1000;; ; TBranch *bvpx = nullptr;; t->SetBranchAddress(""vpx"",&vpx,&bvpx);; ; ; // Create one histograms; TH1F *h = new TH1F(""h"",""This is the px distribution"",100,-4,4);; h->SetFillColor(48);; ; for (Int_t i = 0; i < 25000; i++) {;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/hvector_8C.html:1185,clear,clear,1185,doc/master/hvector_8C.html,https://root.cern,https://root.cern/doc/master/hvector_8C.html,1,['clear'],['clear']
Usability,"escription; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooSimWSTool::ObjBuildConfig. class RooSimWSTool::ObjBuildConfig. Class RooSimWSTool is a tool operating on RooWorkspace objects that; can clone p.d.f.s into a series of variations that are joined together; into a RooSimultanous p.d.f. The simplest use case to to take a workspace p.d.f as prototype and; 'split' a parameter of that p.d.f into two specialized parameters; depending on a category in the dataset. For example, given a Gaussian; p.d.f G(x,m,s) we want to construct a G_a(x,m_a,s) and a G_b(x,m_b,s); with different mean parameters to be fit to a dataset with observables; (x,c) where c is a category with states 'a' and 'b'. Using RooSimWSTool one can create a simultaneous p.d.f from G_a and G_b; from G with the following command. RooSimWSTool wst(wspace) ;; wst.build(""G_sim"",""G"",SplitParam(""m"",""c"")) ;. From this simple example one can go to builds of arbitrary complexity; by specifying multiple SplitParam arguments on multiple parameters; involving multiple splitting categories. Splits can also be performed; in the product multiple categories, e.g. SplitParam(""m"",""c,d"")) ;. splits parameter m in the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to bu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooSimWSTool__ObjBuildConfig.html:1102,simpl,simple,1102,root/html526/RooSimWSTool__ObjBuildConfig.html,https://root.cern,https://root.cern/root/html526/RooSimWSTool__ObjBuildConfig.html,5,['simpl'],['simple']
Usability,"esn't load the histogram from the file; right away. Instead, once all such histograms have been supplied,; one should run this method to open all ROOT files and to copy and; save all necessary histograms. Measurement(); Measurement( const Measurement& other ); // Copy. Measurement(const char* Name, const char* Title = """"). void SetOutputFilePrefix(const string& prefix); set output prefix. { fOutputFilePrefix = prefix; }. std::string GetOutputFilePrefix(); retrieve prefix for output files. { return fOutputFilePrefix; }. void SetPOI(const string& POI); insert PoI at beginning of vector of PoIs. { fPOI.insert( fPOI.begin(), POI ); }. void AddPOI(const string& POI); append parameter to vector of PoIs. { fPOI.push_back(POI); }. std::string GetPOI(unsigned int i = 0); get name of PoI at given index. { return fPOI.at(i); }. std::vector<std::string>& GetPOIList(); get vector of PoI names. { return fPOI; }. void ClearConstantParams(); empty vector of constant parameters. { fConstantParams.clear(); }. std::vector< std::string >& GetConstantParams(); get vector of all constant parameters. { return fConstantParams; }. std::map<std::string, double>& GetParamValues(); get map: parameter name <--> parameter value. { return fParamValues; }. void ClearParamValues(); clear map of parameter values. { fParamValues.clear(); }. void AddFunctionObject(const RooStats::HistFactory::PreprocessFunction function); add a preprocess function object. { fFunctionObjects.push_back( function ); }. void SetFunctionObjects(vector<RooStats::HistFactory::PreprocessFunction> objects); get vector of defined function objects. { fFunctionObjects = objects; }. std::vector< RooStats::HistFactory::PreprocessFunction >& GetFunctionObjects(); { return fFunctionObjects; }. std::vector< RooStats::HistFactory::Asimov >& GetAsimovDatasets(); get vector of defined Asimov Datasets. { return fAsimovDatasets; }. void AddAsimovDataset(RooStats::HistFactory::Asimov dataset); add an Asimov Dataset. { fAsimovDatasets.push_ba",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HistFactory__Measurement.html:12565,clear,clear,12565,root/html602/RooStats__HistFactory__Measurement.html,https://root.cern,https://root.cern/root/html602/RooStats__HistFactory__Measurement.html,4,['clear'],['clear']
Usability,"esolutionModel::basis() const; virtual Int_tbasisCode(const char* name) const; const RooRealVar&RooResolutionModel::basisConvVar() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; const RooArgList&coefList() const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual RooResolutionModel*convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&RooResolutionModel::convVar() const; virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAddModel.html:3476,clear,clearEvalErrorLog,3476,root/html526/RooAddModel.html,https://root.cern,https://root.cern/root/html526/RooAddModel.html,1,['clear'],['clearEvalErrorLog']
Usability,"espaces; Using comments to document the code; Source file layout. Header file layout; Implementation file layout. Preferred Coding Style. Indentation; Placing Braces and Spaces. ClangFormat; Astyle; Where to go from here. Naming conventions; For naming conventions we follow the Taligent rules. They have written a very large body of C++ and their rules seem well thought out. No need to invent something new. The only addition/change we made is to append an _t to typedefs and simple structs, e.g.:; typedef int Int_t ; struct Simple_t { ..... } ; ; Addherence to the rules is mandatory. After a while one really gets used to the fact that all class fields start with an f followed by a capitalized word, fEnergy, or that TStreamerInfo is a class. If the convention is sporadically violated debugging becomes a nightmare. The usage of a standard begin letter or token for the different types also makes it easy to parse and search the code using simple tools.; Class definition conventions; Also here the Taligent guide is quite reasonable. Of course, no class data member should ever be public. Make the data fields always private. Or protected, if you want to grant an inherited class direct access.; Inline; Add trivial get or setters directly in the class definition. This improves reading time since one does not have to look for it somewhere else. Add more complex inlines (longer than one line) at the bottom of the .h file. Creating separate .icc files increases the build time, the complexity of the build system and, more importantly, increases the number of files one possibly has to scan to find a piece of code.; Declaration Order; In the class definition we first declare all private data members, followed by the private static members, the private methods and the private static methods. Then the protected members and methods and finally the public methods (no public data members). We put private members first since that is the language default and it gives the developer a quick v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/coding-conventions.html:3021,guid,guide,3021,d/coding-conventions.html,https://root.cern,https://root.cern/d/coding-conventions.html,1,['guid'],['guide']
Usability,"ess (Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti);  Get query progress information. ;  ; void Progress (Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses);  Get query progress information. ;  ; void PutLog (TQueryResult *qr);  Display log of query pq into the log window frame. ;  ; void QueryResultReady (const char *ref);  Notify availability of a query result. ;  ; Int_t Remove (const char *queryref, Bool_t all=kFALSE);  Send remove request for the query specified by ref. ;  ; Int_t Remove (Int_t query, Bool_t all=kFALSE);  Send remove request for the qry-th query in fQueries. ;  ; void RemoveChain (TChain *chain);  Remove chain from data set. ;  ; Int_t RemoveDynamicPath (const char *libpath, Bool_t onClient=kFALSE);  Remove 'libpath' from the lib path search. ;  ; void RemoveFeedback (const char *name);  Remove object from feedback list. ;  ; Int_t RemoveIncludePath (const char *incpath, Bool_t onClient=kFALSE);  Remove 'incpath' from the inc path search. ;  ; void ResetProgressDialog (const char *sel, Int_t sz, Long64_t fst, Long64_t ent);  Reset progress dialog. ;  ; void ResetProgressDialogStatus ();  ; Int_t Retrieve (const char *queryref, const char *path=0);  Send retrieve request for the query specified by ref. ;  ; Int_t Retrieve (Int_t query, const char *path=0);  Send retrieve request for the qry-th query in fQueries. ;  ; Int_t SavePerfTree (const char *pf=0, const char *qref=0);  Save performance information from TPerfStats to file 'pf'. ;  ; void SendDataSetStatus (const char *msg, UInt_t n, UInt_t tot, Bool_t st);  Send or notify data set status. ;  ; Bool_t SendingLogToWindow () const;  ; void SendLogToWindow (Bool_t mode);  ; void SetActive (Bool_t=kTRUE);  ; virtual void SetAlias (const char *alias="""");  Set an alias for this session. ;  ; void SetDataPoolUrl (c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLite.html:15724,feedback,feedback,15724,doc/master/classTProofLite.html,https://root.cern,https://root.cern/doc/master/classTProofLite.html,1,['feedback'],['feedback']
Usability,"essDialog::EQueryStatusfStatus; TGTextButton*fStop; TGTextBuffer*fTextQuery; TGLabel*fTimeLab; TGLabel*fTitleLab; TGraph*fTotSGraph; TGLabel*fTotal; TGTextButton*fUpdtSpeedo; static Bool_tfgKeepDefault; static Bool_tfgLogQueryDefault; static TStringfgTextQueryDefault. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofProgressDialog(TProof* proof, const char* selector, Int_t files, Long64_t first, Long64_t entries); Create PROOF processing progress dialog. void ToggleOdometerInfos(); Toggle information displayed in Analog Meter. void ToggleThreshold(). void ResetProgressDialog(const char* sel, Int_t sz, Long64_t fst, Long64_t ent); Reset dialog box preparing for new query. void Progress(Long64_t total, Long64_t processed); Update progress bar and status labels.; Use ""processed == total"" or ""processed < 0"" to indicate end of processing. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses); Update progress bar and status labels.; Use ""processed == total"" or ""processed < 0"" to indicate end of processing. Float_t AdjustBytes(Float_t mbs, TString& sf); Transform MBs to GBs ot TBs and get the correct suffix. ~TProofProgressDialog(); Cleanup dialog. void CloseWindow(); Called when dialog is closed. void DisableAsyn(); Disable the asyn switch when an external request for going asynchronous is issued. void IndicateStop(Bool_t aborted); Indicate that Cancel or Stop was clicked. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame, if open. void DoClose(); Close dialog. void DoLog(); Ask proof session for logs. void DoKeep(Bool_t on); Handle keep toggle button. void DoSetLogQuery(Bool_t on); Handle log-current-query-only toggle button. void DoStop(); Handle Stop button. void DoAbort(); Handle Cancel button. void DoAsyn(); Handle Asyn button. void DoPlotRateGraph(); Handle Plot Rate",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofProgressDialog.html:3942,progress bar,progress bar,3942,root/html528/TProofProgressDialog.html,https://root.cern,https://root.cern/root/html528/TProofProgressDialog.html,6,['progress bar'],['progress bar']
Usability,"essIDs, fAllocSize, etc given a PID. void Clear(Option_t* = """"); Clear all entries in the table. Int_t Expand(Int_t pid, Int_t newsize); Expand fParentIDs to newsize for ProcessID pid. Int_t ExpandForIID(Int_t iid, Int_t newsize); Expand fParentIDs to newsize for internel ProcessID index iid. void ExpandPIDs(Int_t numpids); Expand the arrays of managed PIDs. void FillBuffer(TBuffer& b); Fill buffer b with the fN elements in fParentdIDs.; This function is called by TBranchRef::FillLeaves. Int_t FindPIDGUID(const char* guid) const; Get fProcessGUIDs' index of the TProcessID with GUID guid. TObject * GetParent(Int_t uid, TProcessID* context = 0) const; Return object corresponding to uid. Int_t GetInternalIdxForPID(TProcessID* procid) const; Get the index for fProcessIDs, fAllocSize, etc given a PID.; Uses fMapPIDtoInternal and the pid's GUID / fProcessGUID. Int_t GetInternalIdxForPID(Int_t pid) const; Get the index for fProcessIDs, fAllocSize, etc given a PID.; Uses fMapPIDtoInternal and the pid's GUID / fProcessGUID. TRefTable * GetRefTable(); Static function returning the current TRefTable. Bool_t Notify(); This function is called by TRef::Streamer or TStreamerInfo::ReadBuffer; when reading a reference.; This function, in turns, notifies the TRefTable owner for action.; eg, when the owner is a TBranchRef, TBranchRef::Notify is called; to read the branch containing the referenced object. void ReadBuffer(TBuffer& b); Fill buffer b with the fN elements in fParentdIDs.; This function is called by TBranchRef::ReadLeaves. void Reset(Option_t* = """"); Clear all entries in the table. Int_t SetParent(const TObject* parent, Int_t branchID); -- Set current parent object, typically a branch of a tree. This function is called by TBranchElement::Fill() and by; TBranchElement::GetEntry(). void SetRefTable(TRefTable* table); Static function setting the current TRefTable. void Streamer(TBuffer& ); Stream an object of class TRefTable. TRefTable(). Int_t GetNumPIDs() const; {return fNumP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TRefTable.html:9746,GUID,GUID,9746,root/html534/TRefTable.html,https://root.cern,https://root.cern/root/html534/TRefTable.html,3,['GUID'],['GUID']
Usability,"essIDs, fAllocSize, etc given a PID. void Clear(Option_t* = """"); Clear all entries in the table. Int_t Expand(Int_t pid, Int_t newsize); Expand fParentIDs to newsize for ProcessID pid. Int_t ExpandForIID(Int_t iid, Int_t newsize); Expand fParentIDs to newsize for internel ProcessID index iid. void ExpandPIDs(Int_t numpids); Expand the arrays of managed PIDs. void FillBuffer(TBuffer& b); Fill buffer b with the fN elements in fParentdIDs.; This function is called by TBranchRef::FillLeaves. Int_t FindPIDGUID(const char* guid) const; Get fProcessGUIDs' index of the TProcessID with GUID guid. TObject * GetParent(Int_t uid, TProcessID* context = 0) const; Return object corresponding to uid. Int_t GetInternalIdxForPID(TProcessID* procid) const; Get the index for fProcessIDs, fAllocSize, etc given a PID.; Uses fMapPIDtoInternal and the pid's GUID / fProcessGUID. Int_t GetInternalIdxForPID(Int_t pid) const; Get the index for fProcessIDs, fAllocSize, etc given a PID.; Uses fMapPIDtoInternal and the pid's GUID / fProcessGUID. TRefTable * GetRefTable(); Static function returning the current TRefTable. Bool_t Notify(); This function is called by TRef::Streamer or TStreamerInfo::ReadBuffer; when reading a reference.; This function, in turns, notifies the TRefTable owner for action.; eg, when the owner is a TBranchRef, TBranchRef::Notify is called; to read the branch containing the referenced object. void ReadBuffer(TBuffer& b); Fill buffer b with the fN elements in fParentdIDs.; This function is called by TBranchRef::ReadLeaves. void Reset(Option_t* = """"); Clear all entries in the table. Int_t SetParent(const TObject* parent, Int_t branchID); -- Set current parent object, typically a branch of a tree. This function is called by TBranchElement::Fill() and by; TBranchElement::GetEntry(). void SetRefTable(TRefTable* table); Static function setting the current TRefTable. void Streamer(TBuffer& b); Stream an object of class TRefTable. TRefTable(). Int_t GetNumPIDs() const; {return fNum",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TRefTable.html:9727,GUID,GUID,9727,root/html532/TRefTable.html,https://root.cern,https://root.cern/root/html532/TRefTable.html,1,['GUID'],['GUID']
Usability,"essed; Long64_tfFirstfirst event/entry to process; TGTextView*fInfoTextViewsummary on current query; TGLabel*fLabInfosinfos on current process; TGLabel*fLabStatusactual process status; Bool_tfModifiedkTRUE if settings have changed; Long64_tfPrevProcessedused for progress bar; Long64_tfPrevTotalused for progress bar; TGLabel*fRaterate of process in events/sec; TCanvas*fStatsCanvasnode statistics canvas; TSessionQueryFrame::EQueryStatusfStatusstatus of actual query; TGTab*fTabmain tab frame; TGLabel*fTotaltotal progress info; TSessionViewer*fViewerpointer on main viewer; TGHProgressBar*frmProgcurrent process progress bar. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionQueryFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionQueryFrame(); Destructor. void Build(TSessionViewer* gui); Build query information frame. void Modified(Bool_t mod = kTRUE); Notify changes in query editor settings. void Feedback(TList* objs); Feedback function connected to Feedback signal.; Used to update feedback histograms. void UpdateHistos(TList* objs); Update feedback histograms. void Progress(Long64_t total, Long64_t processed); Update progress bar and status labels. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses); New version of Progress (just forward to the old version; for the time being). void ProgressLocal(Long64_t total, Long64_t processed); Update progress bar and status labels. void IndicateStop(Bool_t aborted); Indicate that Cancel or Stop was clicked. void ResetProgressDialog(const char* selec, Int_t files, Long64_t first, Long64_t entries); Reset progress frame information fields. void OnBtnFinalize(); Finalize query. void OnBtnStop(); Stop processing query. void OnBtnShowLog(); Show query log. void OnBtnRetrieve(); Retrieve query. void OnBtnAbort(); Abort processing query. void OnBtnSubmit(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSessionQueryFrame.html:21248,Feedback,Feedback,21248,root/html534/TSessionQueryFrame.html,https://root.cern,https://root.cern/root/html534/TSessionQueryFrame.html,3,['Feedback'],['Feedback']
Usability,"ession templates to achieve an high level optimization. Physics Vectors: classes for describing vectors in 2, 3 and 4 dimensions (relativistic vectors) and their rotation and transformation algorithms. Two package exist in ROOT:. Physics: library with the TVector3 and TLorentzVector classes.; GenVector: new library providing generic class templates for modeling the vectors. Unuran: package with universal algorithms for generating non-uniform pseudo-random numbers, from a large classes of continuous or discrete distributions in one or multi-dimensions. ; Foam: multi-dimensional general purpose Monte Carlo event generator (and integrator). It generates randomly points (vectors) according to an arbitrary probability distribution in n dimensions.; FFTW: library with implementation of the fast Fourier transform (FFT) using the FFTW package. It requires a previous installation of (FFTW).; MLP: library with the neural network class, TMultiLayerPerceptron based on the NN algorithm from the mlpfit package.; Quadp: optimization library with linear and quadratic programming methods. It is based on the Matrix package.; Statistic classes for computing limits and confidence levels.; More detailed is provided here. Some of these classes are currently provided by libPhysics. Further information is available at the following links:. ROOT Mathematical Library Web page; ROOT Math doxygen class documentation; The Math chapter in the user guide; The Linear Algebra chapter in the user guide; The Physics Vector chapter in the user guide; Inventory of Math functions and algorithms. Last modified: Thu Mar 5 16:03:07 CET 2009 . ; MATH Modules; FFTW; FOAM; FUMILI; GENETIC; GENVECTOR; MATHCORE; MATHMORE; MATRIX; MINUIT; MINUIT2; MLP; PHYSICS; QUADP; SMATRIX; SPLOT; UNURAN. » Last changed: 2010-12-15 15:10 » Last generated: 2010-12-15 15:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/MATH_Index.html:4353,guid,guide,4353,root/html528/MATH_Index.html,https://root.cern,https://root.cern/root/html528/MATH_Index.html,3,['guid'],['guide']
Usability,"ession templates to achieve an high level optimization. Physics Vectors: classes for describing vectors in 2, 3 and 4 dimensions (relativistic vectors) and their rotation and transformation algorithms. Two package exist in ROOT:. Physics: library with the TVector3 and TLorentzVector classes.; GenVector: new library providing generic class templates for modeling the vectors. Unuran: package with universal algorithms for generating non-uniform pseudo-random numbers, from a large classes of continuous or discrete distributions in one or multi-dimensions. ; Foam: multi-dimensional general purpose Monte Carlo event generator (and integrator). It generates randomly points (vectors) according to an arbitrary probability distribution in n dimensions.; FFTW: library with implementation of the fast Fourier transform (FFT) using the FFTW package. It requires a previous installation of (FFTW).; MLP: library with the neural network class, TMultiLayerPerceptron based on the NN algorithm from the mlpfit package.; Quadp: optimization library with linear and quadratic programming methods. It is based on the Matrix package.; Statistic classes for computing limits and confidence levels.; More detailed is provided here. Some of these classes are currently provided by libPhysics. Further information is available at the following links:. ROOT Mathematical Library Web page; ROOT Math doxygen class documentation; The Math chapter in the user guide; The Linear Algebra chapter in the user guide; The Physics Vector chapter in the user guide; Inventory of Math functions and algorithms. Last modified: Thu Mar 5 16:03:07 CET 2009 . ; MATH Modules; FFTW; FOAM; FUMILI; GENETIC; GENVECTOR; MATHCORE; MATHMORE; MATRIX; MINUIT; MINUIT2; MLP; PHYSICS; QUADP; SMATRIX; SPLOT; UNURAN. » Last changed: 2011-07-04 15:18 » Last generated: 2011-07-04 15:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/MATH_Index.html:4353,guid,guide,4353,root/html530/MATH_Index.html,https://root.cern,https://root.cern/root/html530/MATH_Index.html,3,['guid'],['guide']
Usability,"ession templates to achieve an high level optimization. Physics Vectors: classes for describing vectors in 2, 3 and 4 dimensions (relativistic vectors) and their rotation and transformation algorithms. Two package exist in ROOT:. Physics: library with the TVector3 and TLorentzVector classes.; GenVector: new library providing generic class templates for modeling the vectors. Unuran: package with universal algorithms for generating non-uniform pseudo-random numbers, from a large classes of continuous or discrete distributions in one or multi-dimensions. ; Foam: multi-dimensional general purpose Monte Carlo event generator (and integrator). It generates randomly points (vectors) according to an arbitrary probability distribution in n dimensions.; FFTW: library with implementation of the fast Fourier transform (FFT) using the FFTW package. It requires a previous installation of (FFTW).; MLP: library with the neural network class, TMultiLayerPerceptron based on the NN algorithm from the mlpfit package.; Quadp: optimization library with linear and quadratic programming methods. It is based on the Matrix package.; Statistic classes for computing limits and confidence levels.; More detailed is provided here. Some of these classes are currently provided by libPhysics. Further information is available at the following links:. ROOT Mathematical Library Web page; ROOT Math doxygen class documentation; The Math chapter in the user guide; The Linear Algebra chapter in the user guide; The Physics Vector chapter in the user guide; Inventory of Math functions and algorithms. Last modified: Thu Mar 5 16:03:07 CET 2009 . ; MATH Modules; FFTW; FOAM; FUMILI; GENETIC; GENVECTOR; MATHCORE; MATHMORE; MATRIX; MINUIT; MINUIT2; MLP; PHYSICS; QUADP; SMATRIX; SPLOT; UNURAN. » Last changed: 2011-12-02 14:26 » Last generated: 2011-12-02 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/MATH_Index.html:4353,guid,guide,4353,root/html532/MATH_Index.html,https://root.cern,https://root.cern/root/html532/MATH_Index.html,3,['guid'],['guide']
Usability,"ession templates to achieve an high level optimization. Physics Vectors: classes for describing vectors in 2, 3 and 4 dimensions (relativistic vectors) and their rotation and transformation algorithms. Two package exist in ROOT:. Physics: library with the TVector3 and TLorentzVector classes.; GenVector: new library providing generic class templates for modeling the vectors. Unuran: package with universal algorithms for generating non-uniform pseudo-random numbers, from a large classes of continuous or discrete distributions in one or multi-dimensions. ; Foam: multi-dimensional general purpose Monte Carlo event generator (and integrator). It generates randomly points (vectors) according to an arbitrary probability distribution in n dimensions.; FFTW: library with implementation of the fast Fourier transform (FFT) using the FFTW package. It requires a previous installation of (FFTW).; MLP: library with the neural network class, TMultiLayerPerceptron based on the NN algorithm from the mlpfit package.; Quadp: optimization library with linear and quadratic programming methods. It is based on the Matrix package.; Statistic classes for computing limits and confidence levels.; More detailed is provided here. Some of these classes are currently provided by libPhysics. Further information is available at the following links:. ROOT Mathematical Library Web page; ROOT Math doxygen class documentation; The Math chapter in the user guide; The Linear Algebra chapter in the user guide; The Physics Vector chapter in the user guide; Inventory of Math functions and algorithms. Last modified: Thu Mar 5 16:03:07 CET 2009 . ; MATH Modules; FFTW; FOAM; FUMILI; GENETIC; GENVECTOR; MATHCORE; MATHMORE; MATRIX; MINUIT; MINUIT2; MLP; PHYSICS; QUADP; SMATRIX; SPLOT; UNURAN. » Last changed: 2015-06-30 14:20 » Last generated: 2015-06-30 14:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/MATH_Index.html:4350,guid,guide,4350,root/html602/MATH_Index.html,https://root.cern,https://root.cern/root/html602/MATH_Index.html,6,['guid'],['guide']
Usability,"ession templates to achieve an high level optimization. Physics Vectors: classes for describing vectors in 2, 3 and 4 dimensions (relativistic vectors) and their rotation and transformation algorithms. Two package exist in ROOT:. Physics: library with the TVector3 and TLorentzVector classes.; GenVector: new library providing generic class templates for modeling the vectors. Unuran: package with universal algorithms for generating non-uniform pseudo-random numbers, from a large classes of continuous or discrete distributions in one or multi-dimensions. ; Foam: multi-dimensional general purpose Monte Carlo event generator (and integrator). It generates randomly points (vectors) according to an arbitrary probability distribution in n dimensions.; FFTW: library with implementation of the fast Fourier transform (FFT) using the FFTW package. It requires a previous installation of (FFTW).; MLP: library with the neural network class, TMultiLayerPerceptron based on the NN algorithm from the mlpfit package.; Quadp: optimization library with linear and quadratic programming methods. It is based on the Matrix package.; Statistic classes for computing limits and confidence levels.; More detailed is provided here. Some of these classes are currently provided by libPhysics. Further information is available at the following links:. ROOT Mathematical Library Web page; ROOT Math doxygen class documentation; The Math chapter in the user guide; The Linear Algebra chapter in the user guide; The Physics Vector chapter in the user guide; Inventory of Math functions and algorithms. Last modified: Thu Mar 5 16:03:07 CET 2009 . ; MATH Modules; FFTW; FOAM; FUMILI; GENETIC; GENVECTOR; MATHCORE; MATHMORE; MATRIX; MINUIT; MINUIT2; MLP; PHYSICS; QUADP; SMATRIX; SPLOT; UNURAN. » Last changed: 2015-09-08 16:58 » Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/MATH_Index.html:4353,guid,guide,4353,root/html534/MATH_Index.html,https://root.cern,https://root.cern/root/html534/MATH_Index.html,6,['guid'],['guide']
Usability,"ession templates to achieve an high level optimization. Physics Vectors: classes for describing vectors in 2, 3 and 4 dimensions (relativistic vectors) and their rotation and transformation algorithms. Two package exist in ROOT:. Physics: library with the TVector3 and TLorentzVector classes.; GenVector: new library providing generic class templates for modeling the vectors. Unuran: package with universal algorithms for generating non-uniform pseudo-random numbers, from a large classes of continuous or discrete distributions in one or multi-dimensions. ; Foam: multi-dimensional general purpose Monte Carlo event generator (and integrator). It generates randomly points (vectors) according to an arbitrary probability distribution in n dimensions.; FFTW: library with implementation of the fast Fourier transform (FFT) using the FFTW package. It requires a previous installation of (FFTW).; MLP: library with the neural network class, TMultiLayerPerceptron based on the NN algorithm from the mlpfit package.; Quadp: optimization library with linear and quadratic programming methods. It is based on the Matrix package.; Statistic classes for computing limits and confidence levels.; More detailed is provided here. Some of these classes are currently provided by libPhysics. Further information is available at the following links:. ROOT Mathematical Library Web page; ROOT Math doxygen class documentation; The Math chapter in the user guide; The Linear Algebra chapter in the user guide; The Physics Vector chapter in the user guide; Inventory of Math functions and algorithms. Last modified: Thu Mar 5 16:03:07 CET 2009 . ; MATH Modules; FFTW; FOAM; FUMILI; GENETIC; GENVECTOR; MATHCORE; MATHMORE; MATRIX; MINUIT; MINUIT2; MLP; PHYSICS; QUADP; SMATRIX; SPLOT; UNURAN. » Last changed: 2015-09-08 17:32 » Last generated: 2015-09-08 17:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/MATH_Index.html:4350,guid,guide,4350,root/html604/MATH_Index.html,https://root.cern,https://root.cern/root/html604/MATH_Index.html,6,['guid'],['guide']
Usability,"estBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TQueryDescription*fActQuerycurrent (actual) query; TStringfAddressserver address; Bool_tfAttachedkTRUE if attached; Bool_tfAutoEnableenable packages at session startup time; TStringfConfigFileconfiguration file name; Bool_tfConnectedkTRUE if connected; Bool_tfLocalkTRUE if session is local; Int_tfLogLevellog (debug) level; TStringfNamesession name; Int_tfNbHistosnumber of feedback histos; TList*fPackageslist of packages; Int_tfPortcommunication port; TProof*fProofpointer on TProof used by this session; TProofMgr*fProofMgrProof sessions manager; TList*fQuerieslist of queries in this session; Bool_tfSynckTRUE if in sync mode; TStringfTagsession unique identifier; TStringfUserNameuser name (on server). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const char * GetName() const; { return fQueryName; }. » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id$ » Last generated: 2015-03-14 16:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSessionDescription.html:5655,feedback,feedback,5655,root/html534/TSessionDescription.html,https://root.cern,https://root.cern/root/html534/TSessionDescription.html,2,['feedback'],['feedback']
Usability,"ested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Development ROOT 7. For the first time since 20 year (i.e. ever), the ROOT team plans to break backward compatibility for crucial interfaces - once.; This new major version of ROOT will make ROOT much simpler and safer to use: we want to increase clarity and usability.; If you are a physicist, please read on - this is about your ROOT.; The ROOT team will be releasing parts of ROOT 7 throughout the coming years.; Previews will gradually sneak into the ROOT sources, in the namespace ROOT::Experimental for those parts that are not yet cast in stone, and in the namespace ROOT for those that are.; We will use standard C++ types, standard interface behavior (e.g. with respect to ownership and thread safety), good documentation and tests: we are trying to be nice!; Feedback; The main point of the meeting and this page is to solicit your feedback. Most of it has been taken care of in the code already.; Building ROOT 7; Pre-requisites; Support for the c++14 standard is required. Usage of g++ >= 5 or clang >= 3.4 is recommended.; Relevant cmake variables; The CMAKE_CXX_STANDARD cmake variables must be set to at least 14.; Building from source would look similar to this:; $ mkdir root7_build; $ cd root7_build; $ cmake -DCMAKE_CXX_STANDARD=14 path/to/root/source; $ cmake --build . -- -j4. Examples; See the relevant tutorials, for instance for drawing and styling the new histograms.; The new interfaces are not about shortening your code - but about robustness. Here are a few examples of what can go wrong with the ROOT6 interfaces:; ROOT6 interfaces, showing what can go wrong.; #include ""TFile.h""#include ""TH2.h""#include ""TTreeReader.h""#include ""TTreeReaderArray.h""#include ""TTree.h"" // Another function. Who knows what it does in a month from n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/root-7.html:2685,feedback,feedback,2685,d/root-7.html,https://root.cern,https://root.cern/d/root-7.html,1,['feedback'],['feedback']
Usability,"estingEventVector->end()) < Int_t(cls+1) ) {; 1424 if( ( testingEventVector->end() - itTarget ) < Int_t(cls+1) ) {; 1425 itTarget = testingEventVector->end();; 1426 testingEventVector->insert( itTarget, itEvent, itEventEnd ); // fill in the rest without mixing; 1427 break;; 1428 }else{; 1429 itTarget += cls+1;; 1430 testingEventVector->insert( itTarget, (*itEvent) ); // fill event; 1431 }; 1432 }; 1433 }; 1434 }else{; 1435 for( UInt_t cls = 0; cls < dsi.GetNClasses(); ++cls ){; 1436 trainingEventVector->insert( trainingEventVector->end(), tmpEventVector[Types::kTraining].at(cls).begin(), tmpEventVector[Types::kTraining].at(cls).end() );; 1437 testingEventVector->insert ( testingEventVector->end(), tmpEventVector[Types::kTesting].at(cls).begin(), tmpEventVector[Types::kTesting].at(cls).end() );; 1438 }; 1439 }; 1440 // delete the tmpEventVector (but not the events therein); 1441 tmpEventVector[Types::kTraining].clear();; 1442 tmpEventVector[Types::kTesting].clear();; 1443 ; 1444 tmpEventVector[Types::kMaxTreeType].clear();; 1445 ; 1446 if (mixMode == ""RANDOM"") {; 1447 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""shuffling events""<<Endl;; 1448 ; 1449 std::shuffle(trainingEventVector->begin(), trainingEventVector->end(), rndm);; 1450 std::shuffle(testingEventVector->begin(), testingEventVector->end(), rndm);; 1451 }; 1452 ; 1453 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""trainingEventVector "" << trainingEventVector->size() << Endl;; 1454 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""testingEventVector "" << testingEventVector->size() << Endl;; 1455 ; 1456 // create dataset; 1457 DataSet* ds = new DataSet(dsi);; 1458 ; 1459 // Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << ""Create internal training tree"" << Endl;; 1460 ds->SetEventCollection(trainingEventVector, Types::kTraining );; 1461 // Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << ""Create internal testing tree"" << Endl;; 1462 ds->SetEventCollection(te",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataSetFactory_8cxx_source.html:65618,clear,clear,65618,doc/master/DataSetFactory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html,1,['clear'],['clear']
Usability,"et abstract base class; TGSpeedo Base class for analog meter widget; TGSplitButton a split button widget; TGSplitFrame Splittable composite frame; TGSplitTool Split frame tool utility; TGSplitter A frame splitter abstract base class; TGStatusBar Status bar widget; TGString Graphics string; TGTRA GTRA shape; TGTab Tab widget; TGTabElement Little tab on tab widget; TGTabLayout Layout manager for TGTab widget; TGTable A table used to visualize data from diffent sources.; TGTableCell A single cell in a TGTable.; TGTableFrame A frame used internally by TGTable.; TGTableHeader Header for use in TGTable.; TGTableHeaderFrame A frame used internally by TGTable.; TGTableLayout Table layout manager; TGTableLayoutHints Class describing GUI table layout hints; TGText Text used by TGTextEdit; TGTextBuffer Text buffer used by widgets like TGTextEntry, etc.; TGTextButton A text button widget; TGTextEdit Text edit widget; TGTextEditor Simple text editor using TGTextEdit widget; TGTextEntry The TGTextEntry widget is a simple line editor for inputting text; TGTextLBEntry Text listbox entry; TGTextLayout Keep track of string measurement information.; TGTextLine Line in TGText; TGTextView Non-editable text viewer widget; TGTextViewStreamBuf Specialization of std::streambuf; TGTextViewostream Specialization of TGTextView and std::ostream; TGTileLayout Tile layout manager; TGToolBar A bar containing picture buttons; TGToolTip One or multiple lines help text; TGTransientFrame Frame for dialog (transient) windows; TGTreeLBEntry TGFSComboBox entry; TGTreeTable A TGTable that owns it's TTreeTableIngeface.; TGTripleHSlider Horizontal triple slider widget; TGTripleVSlider Vertical triple slider widget; TGUndockedFrame Undocked frame; TGUnknownWindowHandler Abstract event handler for unknown windows; TGVButtonGroup A button group with one vertical column; TGVFileSplitter A vertical file frame splitter; TGVProgressBar Vertical progress bar widget; TGVScrollBar Vertical scrollbar widget; TGVSlider",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ClassIndex.html:88526,simpl,simple,88526,root/html534/ClassIndex.html,https://root.cern,https://root.cern/root/html534/ClassIndex.html,6,"['Simpl', 'simpl']","['Simple', 'simple']"
Usability,"et abstract base class; TGSpeedo Base class for analog meter widget; TGSplitButton a split button widget; TGSplitFrame Splittable composite frame; TGSplitTool Split frame tool utility; TGSplitter A frame splitter abstract base class; TGStatusBar Status bar widget; TGString Graphics string; TGTRA GTRA shape; TGTab Tab widget; TGTabElement Little tab on tab widget; TGTabLayout Layout manager for TGTab widget; TGTable A table used to visualize data from diffent sources.; TGTableCell A single cell in a TGTable.; TGTableFrame A frame used internally by TGTable.; TGTableHeader Header for use in TGTable.; TGTableHeaderFrame A frame used internally by TGTable.; TGTableLayout Table layout manager; TGTableLayoutHints Class describing GUI table layout hints; TGText Text used by TGTextEdit; TGTextBuffer Text buffer used by widgets like TGTextEntry, etc.; TGTextButton A text button widget; TGTextEdit Text edit widget; TGTextEditor Simple text editor using TGTextEdit widget; TGTextEntry The TGTextEntry widget is a simple line editor for inputting text; TGTextLBEntry Text listbox entry; TGTextLayout Keep track of string measurement information.; TGTextLine Line in TGText; TGTextView Non-editable text viewer widget; TGTileLayout Tile layout manager; TGToolBar A bar containing picture buttons; TGToolTip One or multiple lines help text; TGTransientFrame Frame for dialog (transient) windows; TGTreeLBEntry TGFSComboBox entry; TGTreeTable A TGTable that owns it's TTreeTableIngeface.; TGTripleHSlider Horizontal triple slider widget; TGTripleVSlider Vertical triple slider widget; TGUndockedFrame Undocked frame; TGUnknownWindowHandler Abstract event handler for unknown windows; TGVButtonGroup A button group with one vertical column; TGVFileSplitter A vertical file frame splitter; TGVProgressBar Vertical progress bar widget; TGVScrollBar Vertical scrollbar widget; TGVSlider Vertical slider widget; TGVSplitter A vertical frame splitter; TGVertical3DLine A vertical 3D separator line; TGVertic",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:79374,simpl,simple,79374,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,7,"['Simpl', 'simpl']","['Simple', 'simple']"
Usability,"et abstract base class; TGSpeedo Base class for analog meter widget; TGSplitButton a split button widget; TGSplitFrame Splittable composite frame; TGSplitTool Split frame tool utility; TGSplitter A frame splitter abstract base class; TGStatusBar Status bar widget; TGString Graphics string; TGTRA GTRA shape; TGTab Tab widget; TGTabElement Little tab on tab widget; TGTabLayout Layout manager for TGTab widget; TGTable A table used to visualize data from diffent sources.; TGTableCell A single cell in a TGTable.; TGTableFrame A frame used internally by TGTable.; TGTableHeader Header for use in TGTable.; TGTableHeaderFrame A frame used internally by TGTable.; TGTableLayout Table layout manager; TGTableLayoutHints Class describing GUI table layout hints; TGText Text used by TGTextEdit; TGTextBuffer Text buffer used by widgets like TGTextEntry, etc.; TGTextButton A text button widget; TGTextEdit Text edit widget; TGTextEditor Simple text editor using TGTextEdit widget; TGTextEntry The TGTextEntry widget is a simple line editor for inputting text; TGTextLBEntry Text listbox entry; TGTextLayout Keep track of string measurement information.; TGTextLine Line in TGText; TGTextView Non-editable text viewer widget; TGTileLayout Tile layout manager; TGToolBar A bar containing picture buttons; TGToolTip One or multiple lines help text; TGTransientFrame Frame for dialog (transient) windows; TGTreeLBEntry TGFSComboBox entry; TGTripleHSlider Horizontal triple slider widget; TGTripleVSlider Vertical triple slider widget; TGUndockedFrame Undocked frame; TGUnknownWindowHandler Abstract event handler for unknown windows; TGVButtonGroup A button group with one vertical column; TGVFileSplitter A vertical file frame splitter; TGVProgressBar Vertical progress bar widget; TGVScrollBar Vertical scrollbar widget; TGVSlider Vertical slider widget; TGVSplitter A vertical frame splitter; TGVertical3DLine A vertical 3D separator line; TGVerticalFrame Composite frame with vertical child layout; TGVert",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ClassIndex.html:84288,simpl,simple,84288,root/html528/ClassIndex.html,https://root.cern,https://root.cern/root/html528/ClassIndex.html,1,['simpl'],['simple']
Usability,"et()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; const RooArgList&coefList() const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg::none()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAddPdf.html:3740,clear,clearEvalErrorLog,3740,root/html526/RooAddPdf.html,https://root.cern,https://root.cern/root/html526/RooAddPdf.html,2,['clear'],['clearEvalErrorLog']
Usability,"et()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg::none(), const RooCmdArg arg6 = RooCmdArg:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooProdPdf.html:4186,clear,clearEvalErrorLog,4186,root/html526/RooProdPdf.html,https://root.cern,https://root.cern/root/html526/RooProdPdf.html,1,['clear'],['clearEvalErrorLog']
Usability,et.h:649; TMVA::DNN::LayerData::gradientsBeginconst_iterator_type gradientsBegin() constreturns const iterator to the begin of the gradientsDefinition NeuralNet.h:604; TMVA::DNN::LayerData::inverseActivationFunctionstd::shared_ptr< std::function< double(double)> > inverseActivationFunction() constDefinition NeuralNet.h:608; TMVA::DNN::LayerData::deltasEnditerator_type deltasEnd()returns iterator to the end of the deltas (back-propagation)Definition NeuralNet.h:592; TMVA::DNN::LayerData::m_valueGradientsstd::vector< double > m_valueGradientsstores the gradients of the values (nodes)Definition NeuralNet.h:643; TMVA::DNN::LayerData::m_itConstWeightBeginconst_iterator_type m_itConstWeightBeginconst iterator to the first weight of this layer in the weight vectorDefinition NeuralNet.h:648; TMVA::DNN::LayerData::valueGradientsEnditerator_type valueGradientsEnd()returns iterator to the end of the gradients of the node valuesDefinition NeuralNet.h:598; TMVA::DNN::LayerData::clearvoid clear()clear the values and the deltasDefinition NeuralNet.h:576; TMVA::DNN::LayerData::activationFunctionstd::shared_ptr< std::function< double(double)> > activationFunction() constDefinition NeuralNet.h:607; TMVA::DNN::LayerData::computeProbabilitiescontainer_type computeProbabilities() constcompute the probabilities from the node valuesDefinition NeuralNet.cxx:140; TMVA::DNN::LayerData::deltasEndconst_iterator_type deltasEnd() constreturns const iterator to the end of the deltas (back-propagation)Definition NeuralNet.h:595; TMVA::DNN::LayerData::m_hasDropOutbool m_hasDropOutdropOut is turned on?Definition NeuralNet.h:646; TMVA::DNN::LayerData::m_isInputLayerbool m_isInputLayeris this layer an input layerDefinition NeuralNet.h:654; TMVA::DNN::LayerData::m_sizesize_t m_sizeDefinition NeuralNet.h:637; TMVA::DNN::LayerData::hasDropOutbool hasDropOut() consthas this layer drop-out turned on?Definition NeuralNet.h:622; TMVA::DNN::LayerData::valueGradientsBeginconst_iterator_type valueGradientsBegin,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:58910,clear,clearvoid,58910,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,3,['clear'],"['clear', 'clearvoid']"
Usability,"et<TTree>(""treeName"");; 287 ; 288RDataFrame d1(""treeName"", ""file.root"");; 289RDataFrame d2(""treeName"", f); // same as TTreeReader; 290RDataFrame d3(*t);; 291 ; 292// multiple files -- all constructors are equivalent; 293TChain chain(""myTree"");; 294chain.Add(""file1.root"");; 295chain.Add(""file2.root"");; 296 ; 297RDataFrame d4(""myTree"", {""file1.root"", ""file2.root""});; 298std::vector<std::string> files = {""file1.root"", ""file2.root""};; 299RDataFrame d5(""myTree"", files);; 300RDataFrame d6(""myTree"", ""file*.root""); // the glob is passed as-is to TChain's constructor; 301RDataFrame d7(chain);; 302~~~; 303Additionally, users can construct an RDataFrame with no data source by passing an integer number. This is the number of rows that; 304will be generated by this RDataFrame.; 305~~~{.cpp}; 306RDataFrame d(10); // a RDF with 10 entries (and no columns/branches, for now); 307d.Foreach([] { static int i = 0; std::cout << i++ << std::endl; }); // silly example usage: count to ten; 308~~~; 309This is useful to generate simple datasets on the fly: the contents of each event can be specified with Define() (explained below). For example, we have used this method to generate [Pythia](https://pythia.org/) events and write them to disk in parallel (with the Snapshot action).; 310 ; 311For data sources other than TTrees and TChains, RDataFrame objects are constructed using ad-hoc factory functions (see e.g. FromCSV(), FromSqlite(), FromArrow()):; 312 ; 313~~~{.cpp}; 314auto df = ROOT::RDF::FromCSV(""input.csv"");; 315// use df as usual; 316~~~; 317 ; 318### Filling a histogram; 319Let's now tackle a very common task, filling a histogram:; 320~~~{.cpp}; 321// Fill a TH1D with the ""MET"" branch; 322RDataFrame d(""myTree"", ""file.root"");; 323auto h = d.Histo1D(""MET"");; 324h->Draw();; 325~~~; 326The first line creates an RDataFrame associated to the TTree ""myTree"". This tree has a branch named ""MET"".; 327 ; 328Histo1D() is an *action*; it returns a smart pointer (a ROOT::RDF::RResultPtr, to be pre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:18458,simpl,simple,18458,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['simpl'],['simple']
Usability,"et<TTree>(""treeName"");; 291 ; 292RDataFrame d1(""treeName"", ""file.root"");; 293RDataFrame d2(""treeName"", f); // same as TTreeReader; 294RDataFrame d3(*t);; 295 ; 296// multiple files -- all constructors are equivalent; 297TChain chain(""myTree"");; 298chain.Add(""file1.root"");; 299chain.Add(""file2.root"");; 300 ; 301RDataFrame d4(""myTree"", {""file1.root"", ""file2.root""});; 302std::vector<std::string> files = {""file1.root"", ""file2.root""};; 303RDataFrame d5(""myTree"", files);; 304RDataFrame d6(""myTree"", ""file*.root""); // the glob is passed as-is to TChain's constructor; 305RDataFrame d7(chain);; 306~~~; 307Additionally, users can construct an RDataFrame with no data source by passing an integer number. This is the number of rows that; 308will be generated by this RDataFrame.; 309~~~{.cpp}; 310RDataFrame d(10); // a RDF with 10 entries (and no columns/branches, for now); 311d.Foreach([] { static int i = 0; std::cout << i++ << std::endl; }); // silly example usage: count to ten; 312~~~; 313This is useful to generate simple datasets on the fly: the contents of each event can be specified with Define() (explained below). For example, we have used this method to generate [Pythia](https://pythia.org/) events and write them to disk in parallel (with the Snapshot action).; 314 ; 315For data sources other than TTrees and TChains, RDataFrame objects are constructed using ad-hoc factory functions (see e.g. FromCSV(), FromSqlite(), FromArrow()):; 316 ; 317~~~{.cpp}; 318auto df = ROOT::RDF::FromCSV(""input.csv"");; 319// use df as usual; 320~~~; 321 ; 322### Filling a histogram; 323Let's now tackle a very common task, filling a histogram:; 324~~~{.cpp}; 325// Fill a TH1D with the ""MET"" branch; 326RDataFrame d(""myTree"", ""file.root"");; 327auto h = d.Histo1D(""MET"");; 328h->Draw();; 329~~~; 330The first line creates an RDataFrame associated to the TTree ""myTree"". This tree has a branch named ""MET"".; 331 ; 332Histo1D() is an *action*; it returns a smart pointer (a ROOT::RDF::RResultPtr, to be pre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:18900,simpl,simple,18900,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['simpl'],['simple']
Usability,"et<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearConvolutionWindow(); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); RooNumIntConfig&convIntConfig(); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooNumConvPdf.html:4871,clear,clearShapeDirty,4871,root/html532/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html532/RooNumConvPdf.html,2,['clear'],['clearShapeDirty']
Usability,"et<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearConvolutionWindow(); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); RooNumIntConfig&convIntConfig(); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg::none(), const RooCmdArg arg6 = RooCmdArg::n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooNumConvPdf.html:4871,clear,clearShapeDirty,4871,root/html528/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html528/RooNumConvPdf.html,1,['clear'],['clearShapeDirty']
Usability,"et<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearConvolutionWindow(); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); RooNumIntConfig&convIntConfig(); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooNumConvPdf.html:4871,clear,clearShapeDirty,4871,root/html530/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html530/RooNumConvPdf.html,1,['clear'],['clearShapeDirty']
Usability,"etConeGL&operator=(const TEveJetConeGL&). Data Members; public:. enum TGLLogicalShape::ELODAxes { kLODAxesNone; kLODAxesX; kLODAxesY; kLODAxesZ; kLODAxesAll; };. protected:. TGLBoundingBoxTGLLogicalShape::fBoundingBox! Shape's bounding box.; TEveJetCone*fCModel object.; UInt_tTGLLogicalShape::fDLBase! display-list id base; Bool_tTGLLogicalShape::fDLCache! use display list caching; Int_tTGLLogicalShape::fDLSize! display-list size for different LODs; UShort_tTGLLogicalShape::fDLValid! display-list validity bit-field; TObject*TGLLogicalShape::fExternalObj! Also plays the role of ID.; TGLPhysicalShape*TGLLogicalShape::fFirstPhysical! first replica; Bool_tTGLObject::fMultiColorAre multiple colors used for object rendering.; Bool_tTGLLogicalShape::fOwnExtObj! External object is a fake; vector<TEveVector>fP; UInt_tTGLLogicalShape::fRef! physical instance ref counting; Bool_tTGLLogicalShape::fRefStrong! Strong ref (delete on 0 ref); not in scene; TGLScene*TGLLogicalShape::fScene! scene where object is stored (can be zero!); static Bool_tTGLLogicalShape::fgIgnoreSizeForCameraInterest. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveJetConeGL(); Constructor. Bool_t SetModel(TObject* obj, Option_t* opt = 0); Set model object. void SetBBox(); Set bounding box. void DLCacheClear(); Clear DL cache and reset internal point array. void CalculatePoints() const; Calculate points for drawing. void Draw(TGLRnrCtx& rnrCtx) const; Draw the cone. void DirectDraw(TGLRnrCtx& rnrCtx) const; Render with OpenGL. TEveJetConeGL(const TEveJetConeGL& ). TEveJetConeGL& operator=(const TEveJetConeGL& ). virtual ~TEveJetConeGL(); {}. » Author: Matevz Tadel, Jochen Thaeder 2009 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/eve:$Id$ » Last generated: 2015-03-13 19:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveJetConeGL.html:4353,Clear,Clear,4353,root/html534/TEveJetConeGL.html,https://root.cern,https://root.cern/root/html534/TEveJetConeGL.html,1,['Clear'],['Clear']
Usability,"etElement*GetNextPacket(Long64_t totalEntries = -1); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual voidGetOptions(Int_t* argc, char** argv); const char*GetOrdinal() const; const char*GetPackageDir() const; const char*GetPrefix() const; TProof*GetProof() const; Int_tGetProtocol() const; Int_tGetQuerySeqNum() const; Float_tGetRealTime() const; static Long_tGetResMemMax(); const char*GetService() const; const char*GetSessionDir() const; const char*GetSessionTag() const; TSignalHandler*TApplication::GetSignalHandler() const; TSocket*GetSocket() const; virtual const char*TObject::GetTitle() const; const char*GetTopSessionTag() const; Int_tGetTotSessions() const; virtual UInt_tTObject::GetUniqueID() const; const char*GetUser() const; static Long_tGetVirtMemMax(); const char*GetWorkDir() const; virtual TProofServ::EQueryActionGetWorkers(TList* workers, Int_t& prioritychange, Bool_t resume = kFALSE); virtual voidHandleException(Int_t sig); virtual voidTApplication::HandleIdleTimer()SIGNAL ; virtual voidHandleSigPipe(); virtual voidHandleSocketInput(); virtual Int_tHandleSocketInput(TMessage* mess, Bool_t all); virtual voidHandleTermination(); virtual Bool_tTApplication::HandleTermInput(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual voidHandleUrgentData(); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTObject::Hash() const; virtual voidTApplication::Hide(); virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTApplication::Iconify(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTApplication::Init(); voidTApplication::InitializeGraphics(); TObjArray*TApplication::InputFiles() const; virtual voidTObject::Ins",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofServ.html:7090,resume,resume,7090,root/html534/TProofServ.html,https://root.cern,https://root.cern/root/html534/TProofServ.html,6,['resume'],['resume']
Usability,"etId = -1); virtual~TEveGDoubleValuator(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidBuild(Bool_t connect = kTRUE); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()SIGNAL ; virtual voidTGWindow::DestroySubwindows(); virtual voidTGWindow::DestroyWindow(); Bool_tTQObject::Disconnect(const char* signal = 0, void* receive",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveGDoubleValuator.html:1544,Clear,Clear,1544,root/html532/TEveGDoubleValuator.html,https://root.cern,https://root.cern/root/html532/TEveGDoubleValuator.html,2,['Clear'],['Clear']
Usability,"etMin (const char *name, double value);  Set minimum of name range to given value. ;  ; void setMin (double value);  ; void setRange (const char *name, double min, double max);  Set a fit or plotting range. ;  ; void setRange (const char *name, RooAbsReal &min, RooAbsReal &max);  Set or modify a parameterised range, i.e., a range the varies in dependence of parameters. ;  ; void setRange (double min, double max);  Set the limits of the default range. ;  ; void setRange (RooAbsReal &min, RooAbsReal &max);  Set parameterised limits of the default range. See setRange(const char*, RooAbsReal&, RooAbsReal&). ;  ; void setVal (double value) override;  Set value of variable to 'value'. ;  ; void setVal (double value, const char *rangeName) override;  Set value of variable to value. ;  ; void Streamer (TBuffer &) override;  Stream an object of class RooRealVar. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void translate (RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ; std::size_t valueResetCounter () const;  Returns how many times the value of this RooRealVar was reset. ;  ; void writeToStream (std::ostream &os, bool compact) const override;  Write object contents to given stream. ;  ;  Public Member Functions inherited from RooAbsRealLValue;  RooAbsRealLValue ();  ;  RooAbsRealLValue (const char *name, const char *title, const char *unit="""");  Constructor. ;  ;  RooAbsRealLValue (const RooAbsRealLValue &other, const char *name=nullptr);  Copy constructor. ;  ; TH1F * createHistogram (const char *name, const char *yAxisLabel) const;  Create an empty 1D-histogram with appropriate scale and labels for this variable. ;  ; TH1F * createHistogram (const char *name, const char *yAxisLabel, const RooAbsBinning &bins) const;  Create an empty 1D-histogram with appropriate scale and labels for this variable. ;  ; TH1F * ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealVar.html:6015,simpl,simple,6015,doc/master/classRooRealVar.html,https://root.cern,https://root.cern/doc/master/classRooRealVar.html,1,['simpl'],['simple']
Usability,"etPoint(0, (1*TMath::Pi())/4., 0.05);; 494 grP1->SetPoint(1, (2*TMath::Pi())/4., 0.10);; 495 grP1->SetPoint(2, (3*TMath::Pi())/4., 0.15);; 496 grP1->SetPoint(3, (4*TMath::Pi())/4., 0.20);; 497 grP1->SetPoint(4, (5*TMath::Pi())/4., 0.25);; 498 grP1->SetPoint(5, (6*TMath::Pi())/4., 0.30);; 499 grP1->SetPoint(6, (7*TMath::Pi())/4., 0.35);; 500 grP1->SetPoint(7, (8*TMath::Pi())/4., 0.40);; 501 ; 502 grP1->SetMarkerStyle(20);; 503 grP1->SetMarkerSize(1.);; 504 grP1->SetMarkerColor(4);; 505 grP1->SetLineColor(4);; 506 grP1->Draw(""ALP"");; 507 ; 508 // Update, otherwise GetPolargram returns 0; 509 c46->Update();; 510 grP1->GetPolargram()->SetToRadian();; 511}; 512End_Macro; 513 ; 514\anchor GrP5; 515### Colors automatically picked in palette; 516 ; 517\since **ROOT version 6.09/01**; 518 ; 519When several graphs are painted in the same canvas or when a multi-graph is drawn,; 520it might be useful to have an easy and automatic way to choose; 521their color. The simplest way is to pick colors in the current active color; 522palette. Palette coloring for histogram is activated thanks to the options `PFC`; 523(Palette Fill Color), `PLC` (Palette Line Color) and `PMC` (Palette Marker Color).; 524When one of these options is given to `TGraph::Draw` the graph get its color; 525from the current color palette defined by `gStyle->SetPalette(...)`. The color; 526is determined according to the number of objects having palette coloring in; 527the current pad.; 528 ; 529Begin_Macro(source); 530../../../tutorials/graphs/graphpalettecolor.C; 531End_Macro; 532 ; 533Begin_Macro(source); 534../../../tutorials/graphs/multigraphpalettecolor.C; 535End_Macro; 536 ; 537\anchor GrP6; 538### Reverse graphs' axis; 539 ; 540\since **ROOT version 6.09/03**; 541 ; 542When a TGraph is drawn, the X-axis is drawn with increasing values from left to; 543right and the Y-axis from bottom to top. The two options `RX` and `RY` allow to; 544change this order. The option `RX` allows to draw the X-axis with increa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphPainter_8cxx_source.html:20558,simpl,simplest,20558,doc/master/TGraphPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html,1,['simpl'],['simplest']
Usability,"etROCIntegral(const UInt_t points=41)Calculates the ROC integral (AUC)Definition ROCCurve.cxx:248; TMVA::ROCCurve::GetROCCurveTGraph * GetROCCurve(const UInt_t points=100)Returns a new TGraph containing the ROC curve.Definition ROCCurve.cxx:274; TMVA::RankingRanking for variables in method (implementation)Definition Ranking.h:48; TMVA::Ranking::Printvirtual void Print() constget maximum length of variable namesDefinition Ranking.cxx:111; TMVA::ResultsClassificationClass that is the base-class for a vector of result.Definition ResultsClassification.h:48; TMVA::ResultsMulticlassClass which takes the results of a multiclass classification.Definition ResultsMulticlass.h:55; TMVA::ResultsClass that is the base-class for a vector of result.Definition Results.h:57; TMVA::Tools::FormattedOutputvoid FormattedOutput(const std::vector< Double_t > &, const std::vector< TString > &, const TString titleVars, const TString titleValues, MsgLogger &logger, TString format=""%+1.3f"")formatted output of simple tableDefinition Tools.cxx:887; TMVA::Tools::ROOTVersionMessagevoid ROOTVersionMessage(MsgLogger &logger)prints the ROOT release number and dateDefinition Tools.cxx:1325; TMVA::Tools::UsefulSortDescendingvoid UsefulSortDescending(std::vector< std::vector< Double_t > > &, std::vector< TString > *vs=nullptr)sort 2D vector (AND in parallel a TString vector) in such a way that the ""first vector is sorted"" and...Definition Tools.cxx:564; TMVA::Tools::SplitStringstd::vector< TString > SplitString(const TString &theOpt, const char separator) constsplits the option string at 'separator' and fills the list 'splitV' with the primitive stringsDefinition Tools.cxx:1199; TMVA::Tools::Colorconst TString & Color(const TString &)human readable color stringsDefinition Tools.cxx:828; TMVA::Tools::GetCorrelationMatrixconst TMatrixD * GetCorrelationMatrix(const TMatrixD *covMat)turns covariance into correlation matrixDefinition Tools.cxx:324; TMVA::Tools::kHtmlLink@ kHtmlLinkDefinition Tools.h:212; TMV",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:133241,simpl,simple,133241,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['simpl'],['simple']
Usability,"etRefTable (TRefTable *table);  Static function setting the current TRefTable. ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions; Int_t AddInternalIdxForPID (TProcessID *procid);  Add the internal index for fProcessIDs, fAllocSize, etc given a PID. ;  ; virtual Int_t ExpandForIID (Int_t iid, Int_t newsize);  Expand fParentIDs to newsize for internel ProcessID index iid. ;  ; void ExpandPIDs (Int_t numpids);  Expand the arrays of managed PIDs. ;  ; Int_t FindPIDGUID (const char *guid) const;  Get fProcessGUIDs' index of the TProcessID with GUID guid. ;  ; Int_t GetInternalIdxForPID (Int_t pid) const;  Get the index for fProcessIDs, fAllocSize, etc given a PID. ;  ; Int_t GetInternalIdxForPID (TProcessID *procid) const;  Get the index for fProcessIDs, fAllocSize, etc given a PID. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; Int_t * fAllocSize;  number of known ProcessIDs ;  ; Int_t fDefaultSize;  current parent ID in fParents (latest call to SetParent) ;  ; std::vector< Int_t > fMapPIDtoInternal;  ; Int_t * fN;  [fNumPIDs] allocated size of array fParentIDs for each ProcessID ;  ; Int_t fNumPIDs;  ; TObject * fOwner;  ; Int_t fParentID;  [fNumPIDs][fAllocSize] array of Parent IDs ;  ; Int_t ** fParentIDs;  [fNumPIDs] current maximum number of IDs in array fParentIDs for each ProcessID ;  ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRefTable.html:12734,guid,guid,12734,doc/master/classTRefTable.html,https://root.cern,https://root.cern/doc/master/classTRefTable.html,2,['guid'],['guid']
Usability,"etTime(ms);; 68 }; 69 Bool_t IsSlow() const { return fSlow; }; 70 ; 71 /// timeout handler; 72 /// used to process http requests in main ROOT thread; 73 void Timeout() override; 74 {; 75 Int_t nprocess = fServer.ProcessRequests();; 76 ; 77 if (nprocess > 0) {; 78 fSlowCnt = 0;; 79 if (IsSlow()); 80 SetSlow(kFALSE);; 81 } else if (!IsSlow() && (fSlowCnt++ > 10)) {; 82 SetSlow(kTRUE);; 83 }; 84 }; 85};; 86 ; 87 ; 88/** \class THttpServer; 89\ingroup http; 90 ; 91Online http server for arbitrary ROOT application; 92 ; 93Idea of THttpServer - provide remote http access to running; 94ROOT application and enable HTML/JavaScript user interface.; 95Any registered object can be requested and displayed in the browser.; 96There are many benefits of such approach:; 97 ; 981. standard http interface to ROOT application; 992. no any temporary ROOT files when access data; 1003. user interface running in all browsers; 101 ; 102To start http server simply create instance; 103of the THttpServer class like:; 104 ; 105 serv = new THttpServer(""http:8080"");; 106 ; 107This will starts civetweb-based http server with http port 8080.; 108Than one should be able to open address ""http://localhost:8080""; 109in any modern web browser (Firefox, Chrome, Opera, ...) and browse objects,; 110created in ROOT application. By default, server can access files,; 111canvases and histograms via `gROOT` pointer. All such objects; 112can be displayed with JSROOT graphics.; 113 ; 114At any time one could register other objects with the command:; 115 ; 116 TGraph* gr = new TGraph(10);; 117 gr->SetName(""gr1"");; 118 serv->Register(""graphs/subfolder"", gr);; 119 ; 120If objects content is changing in the application, one could; 121enable monitoring flag in the browser - than objects view; 122will be regularly updated.; 123 ; 124More information: https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html; 125*/; 126 ; 127ClassImp(THttpServer);; 128 ; 129/////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THttpServer_8cxx_source.html:2805,simpl,simply,2805,doc/master/THttpServer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html,1,['simpl'],['simply']
Usability,"etUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute redo method; com->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in first out). 6. Undo manager. TQUndoManager is recorder of undo and redo operations. This is; command history list which can be traversed backwards and upwards; performing undo and redo operations.; To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);. TQUndoManager::Add automatically invokes execution of command's; Redo method. Use TQUndoManager::Undo to undo commands in history list.; Redo is Undo for undo action. Use TQUndoManager::Redo method for that. Function Members (Methods); public:. TQCommand(const TQCommand& com); TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); TQCommand(const char* cl = 0, void* object = 0, const char* redo = 0, const char* undo = 0); virtual~TQCommand(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAdd(TObject* obj, Option_t* opt); virtual voidTList::AddAfter(const TObject* after, TObject* obj); virtual voidTList::AddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidTList::AddAt(TObject* o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQCommand.html:2752,undo,undo,2752,root/html528/TQCommand.html,https://root.cern,https://root.cern/root/html528/TQCommand.html,6,['undo'],['undo']
Usability,"etUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute redo method; com->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in first out). 6. Undo manager. TQUndoManager is recorder of undo and redo operations. This is; command history list which can be traversed backwards and upwards; performing undo and redo operations.; To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);. TQUndoManager::Add automatically invokes execution of command's; Redo method. Use TQUndoManager::Undo to undo commands in history list.; Redo is Undo for undo action. Use TQUndoManager::Redo method for that. Function Members (Methods); public:. TQUndoManager(); virtual~TQUndoManager(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAdd(TObject* obj, Option_t* opt); virtual voidTList::AddAfter(const TObject* after, TObject* obj); virtual voidTList::AddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidTList::AddAt(TObject* obj, Int_t idx); virtual voidTList::AddBefore(const TObject* before, TObject* obj); virtual voidTList::AddBefore(TObjLink* before, TObject* obj); virtual voidTList::AddFirst(T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQUndoManager.html:2751,undo,undo,2751,root/html528/TQUndoManager.html,https://root.cern,https://root.cern/root/html528/TQUndoManager.html,6,['undo'],['undo']
Usability,"etUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute redo method; com->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in first out). 6. Undo manager. TQUndoManager is recorder of undo and redo operations. This is; command history list which can be traversed backwards and upwards; performing undo and redo operations.; To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);. TQUndoManager::Add automatically invokes execution of command's; Redo method. Use TQUndoManager::Undo to undo commands in history list.; Redo is Undo for undo action. Use TQUndoManager::Redo method for that. Function Members (Methods); public:. virtual~TQCommand(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAdd(TObject* obj, Option_t* opt); virtual voidTList::AddAfter(const TObject* after, TObject* obj); virtual voidTList::AddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidTList::AddAt(TObject* obj, Int_t idx); virtual voidTList::AddBefore(const TObject* before, TObject* obj); virtual voidTList::AddBefore(TObjLink* before, TObject* obj); virtual voidTList::AddFirst(TObject* obj); virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQCommand.html:2776,undo,undo,2776,root/html602/TQCommand.html,https://root.cern,https://root.cern/root/html602/TQCommand.html,4,['undo'],['undo']
Usability,"etUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute redo method; com->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in first out). 6. Undo manager. TQUndoManager is recorder of undo and redo operations. This is; command history list which can be traversed backwards and upwards; performing undo and redo operations.; To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);. TQUndoManager::Add automatically invokes execution of command's; Redo method. Use TQUndoManager::Undo to undo commands in history list.; Redo is Undo for undo action. Use TQUndoManager::Redo method for that. Function Members (Methods); public:. virtual~TQUndoManager(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAdd(TObject* obj, Option_t* opt); virtual voidTList::AddAfter(const TObject* after, TObject* obj); virtual voidTList::AddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidTList::AddAt(TObject* obj, Int_t idx); virtual voidTList::AddBefore(const TObject* before, TObject* obj); virtual voidTList::AddBefore(TObjLink* before, TObject* obj); virtual voidTList::AddFirst(TObject* obj); vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQUndoManager.html:2775,undo,undo,2775,root/html602/TQUndoManager.html,https://root.cern,https://root.cern/root/html602/TQUndoManager.html,4,['undo'],['undo']
Usability,"etWeightGradientsAt (size_t i);  ; const Matrix_t & GetWeightGradientsAt (size_t i) const;  ; std::vector< Matrix_t > & GetWeights ();  ; const std::vector< Matrix_t > & GetWeights () const;  ; Matrix_t & GetWeightsAt (size_t i);  ; const Matrix_t & GetWeightsAt (size_t i) const;  ; size_t GetWidth () const;  ; bool IsTraining () const;  ; void ReadMatrixXML (void *node, const char *name, Matrix_t &matrix);  ; void SetBatchSize (size_t batchSize);  Setters. ;  ; void SetDepth (size_t depth);  ; virtual void SetDropoutProbability (Scalar_t);  Set Dropout probability. ;  ; void SetHeight (size_t height);  ; void SetInputDepth (size_t inputDepth);  ; void SetInputHeight (size_t inputHeight);  ; void SetInputWidth (size_t inputWidth);  ; void SetIsTraining (bool isTraining);  ; void SetWidth (size_t width);  ; void Update (const Scalar_t learningRate);  Updates the weights and biases, given the learning rate. ;  ; void UpdateBiases (const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate);  Updates the biases, given the gradients and the learning rate. ;  ; void UpdateBiasGradients (const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate);  Updates the bias gradients, given some other weight gradients and learning rate. ;  ; void UpdateWeightGradients (const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate);  Updates the weight gradients, given some other weight gradients and learning rate. ;  ; void UpdateWeights (const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate);  Updates the weights, given the gradients and the learning rate,. ;  ; void WriteMatrixToXML (void *node, const char *name, const Matrix_t &matrix);  ; void WriteTensorToXML (void *node, const char *name, const std::vector< Matrix_t > &tensor);  helper functions for XML ;  . Static Protected Member Functions; static size_t CalculateNormDim (int axis, size_t c, size_t h, size_t w);  . Private Attributes; Tensor_t fDerivatives; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TBatchNormLayer.html:7455,learn,learningRate,7455,doc/master/classTMVA_1_1DNN_1_1TBatchNormLayer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TBatchNormLayer.html,2,['learn'],"['learning', 'learningRate']"
Usability,"etYError(int index) const; doubleGetYValue(int index) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; RooStats::HypoTestInverterResultHypoTestInverterResult(const char* name = 0); RooStats::HypoTestInverterResultHypoTestInverterResult(const RooStats::HypoTestInverterResult&); RooStats::HypoTestInverterResultHypoTestInverterResult(const RooStats::HypoTestInverterResult& other, const char* name); RooStats::HypoTestInverterResultHypoTestInverterResult(const char* name, const RooRealVar& scannedVariable, double cl); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooStats::SimpleInterval::IsInInterval(const RooArgSet&) const; boolIsOneSided() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; boolIsTwoSided() const; Bool_tTObject::IsZombie() const; virtual Double_tLowerLimit(); Double_tLowerLimitEstimatedError(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooStats::HypoTestInverterResult&operator=(const RooStats::HypoTestInverterResult& other); virtual voidTObject::Paint(Option_t* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HypoTestInverterResult.html:5026,Simpl,SimpleInterval,5026,root/html602/RooStats__HypoTestInverterResult.html,https://root.cern,https://root.cern/root/html602/RooStats__HypoTestInverterResult.html,2,['Simpl'],['SimpleInterval']
Usability,"eta, phi);; 234 auto particle = new TParticle(0, 0, 0, 0, 0, 0,; 235 px, py, pz, std::sqrt(px*px + py*py + pz*pz + 80*80),; 236 0, 0, 0, 0 );; 237 ; 238 int pdg = 11 * (r.Integer(2) > 0 ? 1 : -1);; 239 particle->SetPdgCode(pdg);; 240 ; 241 list->Add(particle);; 242 }; 243 fListData.push_back(list);; 244 }; 245 ; 246 void MakeRecHits(int N); 247 {; 248 TRandom &r = *gRandom;; 249 r.SetSeed(0);; 250 TList* list = new TList();; 251 list->SetName(""RecHits"");; 252 ; 253 for (int i = 1; i <= N; ++i); 254 {; 255 float pt = r.Uniform(0.5, 10);; 256 float x = r.Uniform(-200, 200);; 257 float y = r.Uniform(-200, 200);; 258 float z = r.Uniform(-500, 500);; 259 auto rechit = new RecHit(pt, x, y, z);; 260 list->Add(rechit);; 261 }; 262 fListData.push_back(list);; 263 }; 264 ; 265 void Clear(); 266 {; 267 for (auto &l : fListData); 268 delete l;; 269 fListData.clear();; 270 }; 271 ; 272 void Create(); 273 {; 274 Clear();; 275 MakeJets(4);; 276 MakeParticles(100);; 277 MakeRecHits(20);; 278 ; 279 // refill calo data from jet list; 280 TList* jlist = fListData[0];; 281 TList* elist = new TList();; 282 elist->SetName(""ECAL"");; 283 fListData.push_back(elist);; 284 TList* hlist = new TList();; 285 hlist->SetName(""HCAL"");; 286 fListData.push_back(hlist);; 287 for (int i = 0; i <= jlist->GetLast(); ++i) {; 288 const Jet* j = (Jet*)jlist->At(i);; 289 float offX = j->Eta();; 290 float offY = j->Phi() > TMath::Pi() ? j->Phi() - TMath::TwoPi() : j->Phi();; 291 for (int k=0; k<20; ++k) {; 292 double x, y, v;; 293 x = gRandom->Uniform(-j->GetEtaSize(), j->GetEtaSize());; 294 y = gRandom->Uniform(-j->GetPhiSize(),j->GetPhiSize());; 295 v = j->Pt();; 296 auto etower = new RCaloTower(offX + x, offY + y, v + gRandom->Uniform(2,3));; 297 elist->Add(etower);; 298 auto htower = new RCaloTower(offX + x, offY + y, v + gRandom->Uniform(1,2));; 299 hlist->Add(htower);; 300 }; 301 }; 302 fCaloData->DataChanged();; 303 eventId++;; 304 }; 305};; 306 ; 307 ; 308//=============================================",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/collection__proxies_8C_source.html:8751,clear,clear,8751,doc/master/collection__proxies_8C_source.html,https://root.cern,https://root.cern/doc/master/collection__proxies_8C_source.html,1,['clear'],['clear']
Usability,"etail described in [4], [5]. It allows to identify automatically the peaks in a spectrum with the presence of the continuous background and statistical fluctuations - noise. The algorithm is based on smoothed second differences that are compared to its standard deviations. Therefore it is necessary to pass a parameter of sigma to the peak searching function. The algorithm is selective to the peaks with the given sigma. The form of the basic peak searching function is; Int-t Search1(const float *spectrum,; int size,; double sigma);; This function searches for peaks in source spectrum. The number of found peaks and their positions are written into structure pointed by one_dim_peak structure pointer.; Function parameters:. source pointer to the vector of source spectrum; p pointer to the one_dim_peak structure pointer; size length of source spectrum; sigma sigma of searched peaks. The structure one_dim_peak has the form:; struct one_dim_peak{; int number_of_peaks;; double position[MAX_NUMBER_OF_PEAKS1];; };; An example of simple one-dimensional spectrum with identified peaks is given in Figure 3.1. Simple one-dimensional spectrum with identified peaks. An example of 1-dimensional experimental spectrum with many identified peaks is given in Figure 3.2. 1-dimensional experimental spectrum with many identified peaks. However when we have noisy data the number of peaks can be enormous. One such an example is given in Figure 3.3. Therefore it can be useful to have possibility to set a threshold value and to consider only the peaks higher than this threshold (see Figure 3.4, only three peaks were identified, threshold=50.) The value in the center of the peak value[i] minus the average value in two symmetrically positioned channels (channels i-3*sigma, i+3*sigma) must be greater than threshold. Otherwise the peak is ignored. With noisy data the number of peaks can be enormous. Iwth threshold=50, only three peaks were identified. An alternative approach was proposed in [6].. T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/spectrum/Spectrum.html:16471,simpl,simple,16471,root/html534/guides/spectrum/Spectrum.html,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html,2,['simpl'],['simple']
Usability,"eteParameters(const char* wildcard); Delete the input list parameters specified by a wildcard (e.g. PROOF_*); or exact name (e.g. PROOF_MaxSlavesPerNode). void ShowParameters(const char* wildcard = ""PROOF_*"") const; Show the input list parameters specified by the wildcard.; Default is the special PROOF control parameters (PROOF_*). void AddFeedback(const char* name); Add object to feedback list. void RemoveFeedback(const char* name); Remove object from feedback list. void ClearFeedback(); Clear feedback list. void ShowFeedback() const; Show items in feedback list. TList * GetFeedbackList() const; Return feedback list. TTree * GetTreeHeader(TDSet* tdset); Creates a tree header (a tree with nonexisting files) object for; the DataSet. TDrawFeedback * CreateDrawFeedback(); Draw feedback creation proxy. When accessed via TProof avoids; link dependency on libProofPlayer. void SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); Set draw feedback option. void DeleteDrawFeedback(TDrawFeedback* f); Delete draw feedback object. TList * GetOutputNames(); FIXME: to be written. void Browse(TBrowser* b); Build the PROOF's structure in the browser. void SetPlayer(TVirtualProofPlayer* player); Set a new PROOF player. TVirtualProofPlayer * MakePlayer(const char* player = 0, TSocket* s = 0); Construct a TProofPlayer object. The player string specifies which; player should be created: remote, slave, sm (supermaster) or base.; Default is remote. Socket is needed in case a slave player is created. void AddChain(TChain* chain); Add chain to data set. void RemoveChain(TChain* chain); Remove chain from data set. void GetLog(Int_t start = -1, Int_t end = -1); Ask for remote logs in the range [start, end]. If start == -1 all the; messages not yet received are sent back. TMacro * GetLastLog(); Fill a TMacro with the log lines since the last reading (fLogFileR); Return (TMacro *)0 if no line was logged.; The returned TMacro must be deleted by the caller. void PutLog(TQueryResult* qr); Displ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:75207,feedback,feedback,75207,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,10,['feedback'],['feedback']
Usability,"ethod Interface; TMVA::Interval Interval definition, continous and discrete; TMVA::KDEKernel Kernel density estimator for PDF smoothing; TMVA::MCFitter Fitter using Monte Carlo sampling of parameters ; TMVA::MethodANNBase Base class for TMVA ANNs; TMVA::MethodBDT Analysis of Boosted Decision Trees; TMVA::MethodBase Virtual base class for all TMVA method; TMVA::MethodBayesClassifier Friedman's BayesClassifier method ; TMVA::MethodBoost ; TMVA::MethodCFMlpANN Interface for Clermond-Ferrand artificial neural network; TMVA::MethodCFMlpANN_Utils Implementation of Clermond-Ferrand artificial neural network; TMVA::MethodCategory ; TMVA::MethodCommittee Analysis of Boosted MVA methods; TMVA::MethodCompositeBase ; TMVA::MethodCuts Multivariate optimisation of signal efficiency; TMVA::MethodDT Analysis of Decision Trees ; TMVA::MethodFDA Function Discriminant Analysis; TMVA::MethodFisher Analysis of Fisher discriminant (Fisher or Mahalanobis approach) ; TMVA::MethodHMatrix H-Matrix method, a simple comparison of chi-squared estimators for signal and background; TMVA::MethodKNN k Nearest Neighbour classifier; TMVA::MethodLD Linear discriminant analysis; TMVA::MethodLikelihood Likelihood analysis (""non-parametric approach"") ; TMVA::MethodMLP Multi-layer perceptron implemented specifically for TMVA; TMVA::MethodPDEFoam Analysis of PDEFoam discriminant (PDEFoam or Mahalanobis approach); TMVA::MethodPDERS Multi-dimensional probability density estimator range search (PDERS) method; TMVA::MethodRuleFit Friedman's RuleFit method; TMVA::MethodSVM Support Vector Machine; TMVA::MethodTMlpANN Implementation of interface for TMultiLayerPerceptron; TMVA::MinuitFitter Fitter using a Genetic Algorithm; TMVA::MinuitWrapper Wrapper around TMinuit; TMVA::MisClassificationError Implementation of the MisClassificationError as separation criterion; TMVA::MsgLogger Ostringstream derivative to redirect and format logging output; TMVA::Node Node for the BinarySearch or Decision Trees; TMVA::OptimizeCo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ClassIndex.html:100783,simpl,simple,100783,root/html528/ClassIndex.html,https://root.cern,https://root.cern/root/html528/ClassIndex.html,2,['simpl'],['simple']
Usability,"ethod Interface; TMVA::Interval Interval definition, continous and discrete; TMVA::KDEKernel Kernel density estimator for PDF smoothing; TMVA::MCFitter Fitter using Monte Carlo sampling of parameters ; TMVA::MethodANNBase Base class for TMVA ANNs; TMVA::MethodBDT Analysis of Boosted Decision Trees; TMVA::MethodBase Virtual base class for all TMVA method; TMVA::MethodBayesClassifier Friedman's BayesClassifier method ; TMVA::MethodBoost ; TMVA::MethodCFMlpANN Interface for Clermond-Ferrand artificial neural network; TMVA::MethodCFMlpANN_Utils Implementation of Clermond-Ferrand artificial neural network; TMVA::MethodCategory ; TMVA::MethodCommittee Analysis of Boosted MVA methods; TMVA::MethodCompositeBase ; TMVA::MethodCuts Multivariate optimisation of signal efficiency; TMVA::MethodDT Analysis of Decision Trees ; TMVA::MethodFDA Function Discriminant Analysis; TMVA::MethodFisher Analysis of Fisher discriminant (Fisher or Mahalanobis approach) ; TMVA::MethodHMatrix H-Matrix method, a simple comparison of chi-squared estimators for signal and background; TMVA::MethodKNN k Nearest Neighbour classifier; TMVA::MethodLD Linear discriminant analysis; TMVA::MethodLikelihood Likelihood analysis (""non-parametric approach"") ; TMVA::MethodMLP Multi-layer perceptron implemented specifically for TMVA; TMVA::MethodPDEFoam Multi-dimensional probability density estimator using TFoam (PDE-Foam); TMVA::MethodPDERS Multi-dimensional probability density estimator range search (PDERS) method; TMVA::MethodRuleFit Friedman's RuleFit method; TMVA::MethodSVM Support Vector Machine; TMVA::MethodTMlpANN Implementation of interface for TMultiLayerPerceptron; TMVA::MinuitFitter Fitter using a Genetic Algorithm; TMVA::MinuitWrapper Wrapper around TMinuit; TMVA::MisClassificationError Implementation of the MisClassificationError as separation criterion; TMVA::MsgLogger Ostringstream derivative to redirect and format logging output; TMVA::Node Node for the BinarySearch or Decision Trees; TMVA::Optimi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ClassIndex.html:101971,simpl,simple,101971,root/html530/ClassIndex.html,https://root.cern,https://root.cern/root/html530/ClassIndex.html,5,['simpl'],['simple']
Usability,"ethod for taking into account the statistical uncertainty of a Monte-Carlo fit template. ;  ; file  rf709_BarlowBeeston.py;   Implementing the Barlow-Beeston method for taking into account the statistical uncertainty of a Monte-Carlo fit template. ;  ; file  rf710_roopoly.C;   Taylor expansion of RooFit functions using the taylorExpand function with RooPolyFunc ;  ; file  rf710_roopoly.py;   Taylor expansion of RooFit functions using the taylorExpand function ;  ; file  rf711_lagrangianmorph.C;   Morphing effective field theory distributions with RooLagrangianMorphFunc A morphing function as a function of one coefficient is setup and can be used to obtain the distribution for any value of the coefficient. ;  ; file  rf711_lagrangianmorph.py;   Morphing effective field theory distributions with RooLagrangianMorphFunc. ;  ; file  rf712_lagrangianmorphfit.C;   Performing a simple fit with RooLagrangianMorphFunc. ;  ; file  rf712_lagrangianmorphfit.py;   Performing a simple fit with RooLagrangianMorphFunc ;  ; file  rf801_mcstudy.C;   Validation and MC studies: toy Monte Carlo study that perform cycles of event generation and fitting ;  ; file  rf801_mcstudy.py;   Validation and MC studies: toy Monte Carlo study that perform cycles of event generation and fitting ;  ; file  rf802_mcstudy_addons.C;   Validation and MC studies: RooMCStudy - using separate fit and generator models, using the chi^2 calculator model Running a biased fit model against an optimal fit. ;  ; file  rf803_mcstudy_addons2.C;   Validation and MC studies: RooMCStudy - Using the randomizer and profile likelihood add-on models ;  ; file  rf804_mcstudy_constr.C;   Validation and MC studies: using RooMCStudy on models with constrains ;  ; file  rf901_numintconfig.C;   Numeric algorithm tuning: configuration and customization of how numeric (partial) integrals are executed ;  ; file  rf901_numintconfig.py;   Numeric algorithm tuning: configuration and customization of how numeric (partial) integrals are ex",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__roofit.html:22768,simpl,simple,22768,doc/master/group__tutorial__roofit.html,https://root.cern,https://root.cern/doc/master/group__tutorial__roofit.html,1,['simpl'],['simple']
Usability,"ethod"", ""ROOT::Internal::TCheckHashRecursiveRemoveConsistency"",; 7352 ""TCheckHashRecursiveRemoveConsistency"", ""TGWindow"",; 7353 ""TDirectory"", ""TDirectoryFile"", ""TObject"", ""TH1"",; 7354 ""TQClass"", ""TGlobal"" };; 7355 ; 7356 if (cname && cname[0]) {; 7357 for (auto cursor : handVerified) {; 7358 if (strcmp(cname, cursor) == 0); 7359 return true;; 7360 }; 7361 }; 7362 return false;; 7363}; 7364 ; 7365////////////////////////////////////////////////////////////////////////////////; 7366/// Return true is the Hash/RecursiveRemove setup is consistent, i.e. when all; 7367/// classes in the class hierarchy that overload TObject::Hash do call; 7368/// ROOT::CallRecursiveRemoveIfNeeded in their destructor.; 7369/// i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation.; 7370 ; 7371Bool_t ROOT::Internal::HasConsistentHashMember(TClass &clRef); 7372{; 7373 return clRef.HasConsistentHashMember();; 7374}; 7375 ; 7376////////////////////////////////////////////////////////////////////////////////; 7377/// Return true if we have access to a constructor usable for I/O. This is; 7378/// typically the default constructor but can also be a constructor specifically; 7379/// marked for I/O (for example a constructor taking a TRootIOCtor* as an; 7380/// argument). In other words, if this routine returns true, TClass::New is; 7381/// guarantee to succeed.; 7382/// To know if the class described by this TClass has a default constructor; 7383/// (public or not), use; 7384/// \code{.cpp}; 7385/// cl->GetProperty() & kClassHasDefaultCtor; 7386/// \endcode; 7387/// To know if the class described by this TClass has a public default; 7388/// constructor use:; 7389/// \code{.cpp}; 7390/// gInterpreter->ClassInfo_HasDefaultConstructor(aClass->GetClassInfo());; 7391/// \endcode; 7392 ; 7393Bool_t TClass::HasDefaultConstructor(Bool_t testio) const; 7394{; 7395 ; 7396 if (fNew) return kTRUE;; 7397 ; 7398 if (HasInterpreterInfo()) {; 7399 R__LOCKGUARD(gInterpreterMutex);;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:283369,usab,usable,283369,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['usab'],['usable']
Usability,"ethod"", ""ROOT::Internal::TCheckHashRecursiveRemoveConsistency"",; 7419 ""TCheckHashRecursiveRemoveConsistency"", ""TGWindow"",; 7420 ""TDirectory"", ""TDirectoryFile"", ""TObject"", ""TH1"",; 7421 ""TQClass"", ""TGlobal"" };; 7422 ; 7423 if (cname && cname[0]) {; 7424 for (auto cursor : handVerified) {; 7425 if (strcmp(cname, cursor) == 0); 7426 return true;; 7427 }; 7428 }; 7429 return false;; 7430}; 7431 ; 7432////////////////////////////////////////////////////////////////////////////////; 7433/// Return true is the Hash/RecursiveRemove setup is consistent, i.e. when all; 7434/// classes in the class hierarchy that overload TObject::Hash do call; 7435/// ROOT::CallRecursiveRemoveIfNeeded in their destructor.; 7436/// i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation.; 7437 ; 7438Bool_t ROOT::Internal::HasConsistentHashMember(TClass &clRef); 7439{; 7440 return clRef.HasConsistentHashMember();; 7441}; 7442 ; 7443////////////////////////////////////////////////////////////////////////////////; 7444/// Return true if we have access to a constructor usable for I/O. This is; 7445/// typically the default constructor but can also be a constructor specifically; 7446/// marked for I/O (for example a constructor taking a TRootIOCtor* as an; 7447/// argument). In other words, if this routine returns true, TClass::New is; 7448/// guarantee to succeed.; 7449/// To know if the class described by this TClass has a default constructor; 7450/// (public or not), use; 7451/// \code{.cpp}; 7452/// cl->GetProperty() & kClassHasDefaultCtor; 7453/// \endcode; 7454/// To know if the class described by this TClass has a public default; 7455/// constructor use:; 7456/// \code{.cpp}; 7457/// gInterpreter->ClassInfo_HasDefaultConstructor(aClass->GetClassInfo());; 7458/// \endcode; 7459 ; 7460Bool_t TClass::HasDefaultConstructor(Bool_t testio) const; 7461{; 7462 ; 7463 if (fNew) return kTRUE;; 7464 ; 7465 if (HasInterpreterInfo()) {; 7466 R__LOCKGUARD(gInterpreterMutex);;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:286120,usab,usable,286120,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['usab'],['usable']
Usability,"ethod(const char* method) const; virtual Bool_tTGedFrame::AcceptModel(TObject*); virtual voidTGFrame::Activate(Bool_t); virtual voidActivateBaseClassEditors(TClass*); virtual voidTGedFrame::AddExtraTab(TGedFrame::TGedSubFrame* sf); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual TGVerticalFrame*TGedFrame::CreateEditorTabSubFrame(const char* name); virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()SIGNAL ; virtual voidTGWindow::DestroySubwindows(); virtual voidTGWindow::Des",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TPieEditor.html:1613,Clear,Clear,1613,root/html532/TPieEditor.html,https://root.cern,https://root.cern/root/html532/TPieEditor.html,4,['Clear'],['Clear']
Usability,"ethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); voidvector<long>::assign(initializer_list<vector<long>::value_type> __l); voidvector<long>::assign(vector<bool>::size_type __n, const vector<long>::value_type& __val); vector<long>::referencevector<long>::at(vector<bool>::size_type __n); vector<long>::const_referencevector<long>::at(vector<bool>::size_type __n) const; vector<long>::referencevector<long>::back(); vector<long>::const_referencevector<long>::back() const; TTable::iteratorBegin(); TTable::iteratorBegin() const; vector<long>::iteratorvector<long>::begin(); vector<long>::const_iteratorvector<long>::begin() const; virtual voidTObject::Browse(TBrowser* b); vector<bool>::size_typevector<long>::capacity() const; vector<long>::const_iteratorvector<long>::cbegin() const; vector<long>::const_iteratorvector<long>::cend() const; static TClass*Class(); virtual const char*TObject::ClassName() const; voidvector<long>::clear(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; vector<long>::const_reverse_iteratorvector<long>::crbegin() const; vector<long>::const_reverse_iteratorvector<long>::crend() const; long*vector<long>::data(); const long*vector<long>::data() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; boolvector<long>::empty() const; TTable::iteratorEnd(); TTable::iteratorEnd() const; vector<long>::iteratorvector<long>::end(); vector<long>::const_iteratorvector<long>::end() const; vector<long>::iteratorvector<long>::erase(vector<long>::iterator __position); vector<long>::iteratorvec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTableMap.html:2472,Clear,Clear,2472,root/html602/TTableMap.html,https://root.cern,https://root.cern/root/html602/TTableMap.html,1,['Clear'],['Clear']
Usability,"ethod) const; virtual voidTH1::Add(const TH1* h1, Double_t c1 = 1); virtual voidTH1::Add(TF1* h1, Double_t c1 = 1, Option_t* option = """"); virtual voidTH1::Add(const TH1* h, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1)MENU ; voidTArrayD::AddAt(Double_t c, Int_t i); virtual voidAddBinContent(Int_t bin); virtual voidAddBinContent(Int_t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDirectoryStatus(); voidTArrayD::Adopt(Int_t n, Double_t* array); virtual voidTObject::AppendPad(Option_t* option = """"); Double_tTArrayD::At(Int_t i) const; virtual voidTH1::Browse(TBrowser* b); virtual Int_tTH1::BufferEmpty(Int_t action = 0); virtual Double_tTH1::Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(); virtual voidCopy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TH1D.html:1767,Clear,Clear,1767,root/html532/TH1D.html,https://root.cern,https://root.cern/root/html532/TH1D.html,1,['Clear'],['Clear']
Usability,"ethod) const; virtual voidTH1::Add(const TH1* h1, Double_t c1 = 1); virtual voidTH1::Add(TF1* h1, Double_t c1 = 1, Option_t* option = """"); virtual voidTH1::Add(const TH1* h, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1)MENU ; voidTArrayD::AddAt(Double_t c, Int_t i); virtual voidAddBinContent(Int_t bin); virtual voidAddBinContent(Int_t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDirectoryStatus(); voidTArrayD::Adopt(Int_t n, Double_t* array); virtual voidTObject::AppendPad(Option_t* option = """"); Double_tTArrayD::At(Int_t i) const; virtual voidTH1::Browse(TBrowser* b); virtual Int_tTH2::BufferEmpty(Int_t action = 0); virtual Double_tTH1::Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(); virtual voidCopy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TH2D.html:2114,Clear,Clear,2114,root/html532/TH2D.html,https://root.cern,https://root.cern/root/html532/TH2D.html,1,['Clear'],['Clear']
Usability,"ethod) const; virtual voidTH1::Add(const TH1* h1, Double_t c1 = 1); virtual voidTH1::Add(TF1* h1, Double_t c1 = 1, Option_t* option = """"); virtual voidTH1::Add(const TH1* h, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1)MENU ; voidTArrayD::AddAt(Double_t c, Int_t i); virtual voidAddBinContent(Int_t bin); virtual voidAddBinContent(Int_t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDirectoryStatus(); voidTArrayD::Adopt(Int_t n, Double_t* array); virtual voidTObject::AppendPad(Option_t* option = """"); Double_tTArrayD::At(Int_t i) const; virtual voidTH1::Browse(TBrowser* b); virtual Int_tTH3::BufferEmpty(Int_t action = 0); virtual Double_tTH1::Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(); virtual voidCopy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TH3D.html:1955,Clear,Clear,1955,root/html532/TH3D.html,https://root.cern,https://root.cern/root/html532/TH3D.html,1,['Clear'],['Clear']
Usability,"ethod. A virtual initGenerator() method is also called just before the; first call to generateEvent(). void initGenerator(const RooArgSet& theEvent); Interface function to initialize context for generation for given; set of observables. void printName(ostream& os) const; Print name of context. void printTitle(ostream& os) const; Print title of context. void printClassName(ostream& os) const; Print class name of context. void printArgs(ostream& os) const; Print arguments of context, i.e. the observables being generated in this context. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Interface for multi-line printing. void setProtoDataOrder(Int_t* lut); Set the traversal order of prototype data to that in the lookup tables; passed as argument. The LUT must be an array of integers with the same; size as the number of entries in the prototype dataset and must contain; integer values in the range [0,Nevt-1]. void resampleData(Double_t& ratio); Rescale existing output buffer with given ratio. Int_t defaultPrintContents(Option_t* opt) const; Define default contents when printing. RooPrintable::StyleOption defaultPrintStyle(Option_t* opt) const; Define default print style. RooAbsGenContext(const RooAbsPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t _verbose = kFALSE). Bool_t isValid() const; If true generator context is in a valid state. void setVerbose(Bool_t verbose = kTRUE); Set/clear verbose messaging. Bool_t isVerbose() const; If true verbose messaging is active. void Print(Option_t* options = 0) const; Print context information on stdout. void setExpectedData(Bool_t ); {}. void generateEvent(RooArgSet& theEvent, Int_t remaining). » Last changed: Tue Jun 30 14:30:07 2015 » Last generated: 2015-06-30 14:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsGenContext.html:12108,clear,clear,12108,root/html602/RooAbsGenContext.html,https://root.cern,https://root.cern/root/html602/RooAbsGenContext.html,2,['clear'],['clear']
Usability,ethods); public:. TGeoIterator(TGeoVolume* top); TGeoIterator(const TGeoIterator& iter); virtual~TGeoIterator(); static TClass*Class(); const TGeoMatrix*GetCurrentMatrix() const; Int_tGetIndex(Int_t i) const; Int_tGetLevel() const; TGeoNode*GetNode(Int_t level) const; voidGetPath(TString& path) const; TGeoVolume*GetTopVolume() const; Int_tGetType() const; TGeoIteratorPlugin*GetUserPlugin() const; virtual TClass*IsA() const; TGeoNode*Next(); TGeoNode*operator()(); TGeoIterator&operator=(const TGeoIterator& iter); voidReset(TGeoVolume* top = 0); voidSetPluginAutoexec(Bool_t mode); voidSetTopName(const char* name); voidSetType(Int_t type); voidSetUserPlugin(TGeoIteratorPlugin* plugin); virtual voidShowMembers(TMemberInspector& insp); voidSkip(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. TGeoIterator(). private:. voidIncreaseArray(). Data Members; private:. Int_t*fArrayArray of node indices for the current path; Int_tfLevelCurrent level in the tree; TGeoHMatrix*fMatrixCurrent global matrix; Bool_tfMustResumePrivate flag to resume from current node.; Bool_tfMustStopPrivate flag to signal that the iterator has finished.; TGeoIteratorPlugin*fPluginUser iterator plugin; Bool_tfPluginAutoexecPlugin automatically executed during next() ; TGeoVolume*fTopTop volume of the iterated branch; TStringfTopNameUser name for top; Int_tfTypeType of iteration. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoIterator(TGeoVolume* top); Geometry iterator for a branch starting with a TOP node. TGeoIterator(const TGeoIterator& iter); Copy ctor. ~TGeoIterator(); Destructor. TGeoIterator & operator=(const TGeoIterator& iter); Assignment. TGeoNode * Next(); Returns next node. TGeoNode * operator()(); Returns next node. const TGeoMatrix * GetCurrentMatrix() const; Returns global matrix for current node. TGeoNode * GetNode(Int_t level) const; Returns current node at a given level. void GetPath(TString& path) const;,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoIterator.html:4319,resume,resume,4319,root/html528/TGeoIterator.html,https://root.cern,https://root.cern/root/html528/TGeoIterator.html,4,['resume'],['resume']
Usability,"ethods); public:. virtual~RooCmdConfig(); voidTObject::AbstractMethod(const char* method) const; voidallowUndefined(Bool_t flag = kTRUE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static Int_tdecodeIntOnTheFly(const char* callerID, const char* cmdArgName, Int_t intIdx, Int_t defVal, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg()); static TObject*decodeObjOnTheFly(const char* callerID, const char* cmdArgName, Int_t objIdx, TObject* defVal, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg()); static const char*decodeStringOnTheFly(const char* callerID, const char* cmdArgName, Int_t intIdx, const char* defVal, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg()); voiddefineDependency(const char* refArgName, const char* neededArgName); Bool_tdefineDouble(const char* name, const char* argName, Int_t doubleNum, Double_t defValue = 0.); Bool_tdefineIn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCmdConfig.html:1042,Clear,Clear,1042,root/html602/RooCmdConfig.html,https://root.cern,https://root.cern/root/html602/RooCmdConfig.html,2,['Clear'],['Clear']
Usability,"eturn a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Static Public Attributes; static constexpr value_type NoCatIdx = std::numeric_limits<value_type>::min();  . Protected Member Functions; value_type evaluate () const override;  Evaluate the category state and return. ;  ; const RooMappedCategoryCache * getOrCreateCache () const;  ; void recomputeShape () override;  When the input category changes states, the cached state mappings are invalidated. ;  ;  Protected Member Functions inherited from RooAbsCategory; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach the category index and label as branches to the given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  Attach the category index and label to as branches to the given vector store. ;  ; void clearTypes ();  Delete all currently defined states. ;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValueDirty=true) override;  Copy the cached value from given source and raise dirty flag. ;  ; virtual const std::map< std::string, RooAbsCategory::value_type >::value_type & defineState (const std::string &label);  Define a new state with given label. ;  ; virtual const std::map< std::string, RooAbsCategory::value_type >::value_type & defineState (const std::string &label, value_type index);  Define new state with given name and index number. ;  ; void defineStateUnchecked (const std::string &label, value_type index);  Internal version of defineState() that does not check if type already exists. ;  ; void fillTreeBranch (TTree &t) override;  Fill tree branches associated with current object with current value. ;  ; bool isValid () const override;  WVE (08/21/01) Probably obsolete now. ;  ; value_type nextAvailableStateIndex () const;  ; RooCatType * retrieveLegacyState (value_ty",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMappedCategory.html:35627,clear,clearTypes,35627,doc/master/classRooMappedCategory.html,https://root.cern,https://root.cern/doc/master/classRooMappedCategory.html,1,['clear'],['clearTypes']
Usability,"eturn an asymmetric and non-zero lower; error for the case b1=b2. The function return kFALSE if the divide operation failed. void Draw(Option_t* option = """"); Draw this histogram with options. Histograms are drawn via the THistPainter class. Each histogram has; a pointer to its own painter (to be usable in a multithreaded program).; The same histogram can be drawn with different options in different pads.; When an histogram drawn in a pad is deleted, the histogram is; automatically removed from the pad or pads where it was drawn.; If an histogram is drawn in a pad, then filled again, the new status; of the histogram will be automatically shown in the pad next time; the pad is updated. One does not need to redraw the histogram.; To draw the current version of an histogram in a pad, one can use; h->DrawCopy();; This makes a clone of the histogram. Once the clone is drawn, the original; histogram may be modified or deleted without affecting the aspect of the; clone.; By default, TH1::Draw clears the current pad. One can use TH1::SetMaximum and TH1::SetMinimum to force a particular; value for the maximum or the minimum scale on the plot. TH1::UseCurrentStyle can be used to change all histogram graphics; attributes to correspond to the current selected style.; This function must be called for each histogram.; In case one reads and draws many histograms from a file, one can force; the histograms to inherit automatically the current graphics style; by calling before gROOT->ForceStyle();. See the THistPainter class for a description of all the drawing options. TH1 * DrawCopy(Option_t* option = """") const; -*-*-*-*-*Copy this histogram and Draw in the current pad*-*-*-*-*-*-*-*. Once the histogram is drawn into the pad, any further modification; using graphics input will be made on the copy of the histogram,; and not to the original object. See Draw for the list of options. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. TH1 * DrawNormalized(Option_t*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH1.html:65438,clear,clears,65438,root/html534/TH1.html,https://root.cern,https://root.cern/root/html534/TH1.html,2,['clear'],['clears']
Usability,"eturn an asymmetric and non-zero lower; error for the case b1=b2. The function return kFALSE if the divide operation failed. void Draw(Option_t* option = """"); Draw this histogram with options. Histograms are drawn via the THistPainter class. Each histogram has; a pointer to its own painter (to be usable in a multithreaded program).; The same histogram can be drawn with different options in different pads.; When an histogram drawn in a pad is deleted, the histogram is; automatically removed from the pad or pads where it was drawn.; If an histogram is drawn in a pad, then filled again, the new status; of the histogram will be automatically shown in the pad next time; the pad is updated. One does not need to redraw the histogram.; To draw the current version of an histogram in a pad, one can use; h->DrawCopy();; This makes a clone of the histogram. Once the clone is drawn, the original; histogram may be modified or deleted without affecting the aspect of the; clone.; By default, TH1::Draw clears the current pad. One can use TH1::SetMaximum and TH1::SetMinimum to force a particular; value for the maximum or the minimum scale on the plot. TH1::UseCurrentStyle can be used to change all histogram graphics; attributes to correspond to the current selected style.; This function must be called for each histogram.; In case one reads and draws many histograms from a file, one can force; the histograms to inherit automatically the current graphics style; by calling before gROOT->ForceStyle();. See the THistPainter class for a description of all the drawing options. TH1 * DrawCopy(Option_t* option = """", const char* name_postfix = ""_copy"") const; Copy this histogram and Draw in the current pad. Once the histogram is drawn into the pad, any further modification; using graphics input will be made on the copy of the histogram,; and not to the original object.; By default a postfix ""_copy"" is added to the histogram name. Pass an empty postfix in case; you want to draw an histogram with",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH1.html:66608,clear,clears,66608,root/html602/TH1.html,https://root.cern,https://root.cern/root/html602/TH1.html,4,['clear'],['clears']
Usability,"eturn default color for nodes. Bool_t GetLinksVisibility() const; Returns true if links are visible, otherwise return false. TStructNode* GetNodePtr() const; Returns top node pointer. void GLWidgetProcessedEventSlot(Event_t* event); Handle events. Sets fMouseX and fMouseY when user move a mouse over viewer and hides ToolTip. void LevelDistValueSetSlot(Long_t dist); Emmited when user changes distance between levels. void MouseOverSlot(TGLPhysicalShape* shape); MouseOver slot. Activated when user out mouse over object on scene.; Sets ToolTip and updates labels. void RedoButtonSlot(); Activated when user click Redo button. Repeat last Undo action. void ResetButtonSlot(); Resets camera. void Scale(TStructNode* parent); Recursive method to scaling all modes on scene. We have to scale nodes to get real ratio between nodes.; Uses fMaxRatio. void SetNodePtr(TStructNode* val); Sets top node pointer and updates view. void SetLinksVisibility(Bool_t val); Sets links visibility to ""visible"". void SetPointerButtonSlot(); Sets pointer given in fPointerTestEntry to the main pointer. void ShowLinksToggled(Bool_t on); Changes links visibility and refresh view. void UnCheckMaxObjects(); Shows hidden nodes. void Update(Bool_t resetCamera = false); Updates view. Clear all the nodes, call draw function and update scene. Doesn't reset camera. void UpdateButtonSlot(); Update button slot. Updates scene. void UpdateLabels(TStructNode* node); Refresh information in labels when user put mouse over object. void UndoButtonSlot(); UndoButton Slot. Activated when user press Undo button. Restore last top node pointer. void ScaleByChangedSlot(); Activated when user press radio button. » Author: Tomasz Sosnicki 18/09/09 » Copyright (C) 1995-2009, Rene Brun and Fons Rademakers. *; » Last changed: root/gviz3d:$Id$ » Last generated: 2015-03-14 16:50; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TStructViewerGUI.html:28207,Clear,Clear,28207,root/html534/TStructViewerGUI.html,https://root.cern,https://root.cern/root/html534/TStructViewerGUI.html,4,"['Clear', 'Undo']","['Clear', 'Undo', 'UndoButton', 'UndoButtonSlot']"
Usability,eturn fCanEditMainTrans; }. Bool_t HasMainTrans() const; { return fMainTrans != 0; }. TRef& GetSource(); { return fSource; }. TObject* GetSourceObject() const; { return fSource.GetObject(); }. void SetSourceObject(TObject* o). void DumpSourceObject(); // *MENU*; void InspectSourceObject(); // *MENU*. { fSource = o; }. void* GetUserData() const; { return fUserData; }. void SetUserData(void* ud); { fUserData = ud; }. Bool_t IsPickable() const; { return fPickable; }. void SetPickable(Bool_t p); { fPickable = p; }. void SetCSCBits(UChar_t f); { fCSCBits |= f; }. void ResetCSCBits(UChar_t f); { fCSCBits &= ~f; }. Bool_t TestCSCBits(UChar_t f) const; { return (fCSCBits & f) != 0; }. void ResetAllCSCBits(); { fCSCBits = 0; }. void CSCImplySelectAllChildren(); { fCSCBits |= kCSCBImplySelectAllChildren; }. void CSCTakeAnyParentAsMaster(); { fCSCBits |= kCSCBTakeAnyParentAsMaster; }. void CSCApplyMainColorToAllChildren(); { fCSCBits |= kCSCBApplyMainColorToAllChildren; }. void CSCApplyMainColorToMatchingChildren(); { fCSCBits |= kCSCBApplyMainColorToMatchingChildren; }. void CSCApplyMainTransparencyToAllChildren(); { fCSCBits |= kCSCBApplyMainTransparencyToAllChildren; }. void CSCApplyMainTransparencyToMatchingChildren(); { fCSCBits |= kCSCBApplyMainTransparencyToMatchingChildren; }. void StampColorSelection(); { AddStamp(kCBColorSelection); }. void StampTransBBox(); { AddStamp(kCBTransBBox); }. void StampObjProps(); { AddStamp(kCBObjProps); }. void StampVisibility(); void StampElementAdded() { AddStamp(kCBElementAdded); }; void StampElementRemoved() { AddStamp(kCBElementRemoved); }. { AddStamp(kCBVisibility); }. void ClearStamps(); { fChangeBits = 0; }. UChar_t GetChangeBits() const; { return fChangeBits; }. » Last changed: root/eve:$Id: TEveElement.h 36374 2010-10-19 17:50:23Z matevz $ » Last generated: 2011-11-03 20:11; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveElement.html:36395,Clear,ClearStamps,36395,root/html532/TEveElement.html,https://root.cern,https://root.cern/root/html532/TEveElement.html,1,['Clear'],['ClearStamps']
Usability,"eturns the previous block status. ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static Bool_t Connect (const char *sender_class, const char *signal, const char *receiver_class, void *receiver, const char *slot);  This method allows to make a connection from any object of the same class to a single slot. ;  ; static Bool_t Connect (TQObject *sender, const char *signal, const char *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  ; static const char * DeclFileName ();  ; static Bool_t Disconnect (const char *class_name, const char *signal, void *receiver=nullptr, const char *slot=nullptr);  Disconnects ""class signal"". ;  ; static Bool_t Disconnect (TQObject *sender, const char *signal=nullptr, void *receiver=nullptr, const char *slot=nullptr);  Disconnects signal in object sender from slot_method in object receiver. ;  . Protected Member Functions; void DoRedraw () override;  Draw horizontal progress bar. ;  ;  Protected Member Functions inherited from TGFrame; virtual void Draw3dRectangle (UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h);  Draw 3D rectangle on the frame border. ;  ; TString GetOptionString () const;  Returns a frame option string - used in SavePrimitive(). ;  ; const TGResourcePool * GetResourcePool () const;  ; void * GetSender () override;  ; virtual void StartGuiBuilding (Bool_t on=kTRUE);  Go into GUI building mode. ;  ;  Protected Member Functions inherited from TGWindow;  TGWindow (const TGWindow &tgw);  ;  TGWindow (Window_t id);  ; TGWindow & operator= (const TGWindow &tgw);  ;  Protected Member Functions inherited from TGObject; TGObject & operator= (const TGObject &tgo);  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inher",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGHProgressBar.html:24201,progress bar,progress bar,24201,doc/master/classTGHProgressBar.html,https://root.cern,https://root.cern/doc/master/classTGHProgressBar.html,1,['progress bar'],['progress bar']
Usability,"etween; buttons and drawnbuttons (let's say icons) and assign to them his; own actions (let's say ROOT or C++ commands). The macro belows shows an example of controlbar.; To execute an item, click with the left mouse button.; To see the HELP of a button, click on the right mouse button. You have access to the last clicked button via the method; GetClicked(). For example, bar->GetClicked()->GetName(); will return the name of the last clicked button. {; gROOT.Reset(""a"");; TControlBar bar(""vertical"");; bar.AddButton(""Help to run demos"","".x demoshelp.C"",; ""Explains how to run the demos"");; bar.AddButton(""framework"", "".x framework.C"",; ""An Example of Object Oriented User Interface"");; bar.AddButton(""hsimple"", "".x hsimple.C"",; ""An Example Creating Histograms/Ntuples on File"");; bar.AddButton(""hsum"", "".x hsum.C"",; ""Filling histograms and some graphics options"");; bar.AddButton(""canvas"", "".x canvas.C"",; ""Canvas and Pad Management"");; bar.AddButton(""formula1"", "".x formula1.C"",; ""Simple Formula and Functions"");; bar.AddButton(""fillrandom"", "".x fillrandom.C"",; ""Histograms with Random Numbers from a Function"");; bar.AddButton(""fit1"", "".x fit1.C"",; ""A Simple Fitting Example"");; bar.AddButton(""h1draw"", "".x h1draw.C"",; ""Drawing Options for 1D Histograms"");; bar.AddButton(""graph"", "".x graph.C"",; ""Examples of a simple graph"");; bar.AddButton(""tornado"", "".x tornado.C"",; ""Examples of 3-D PolyMarkers"");; bar.AddButton(""shapes"", "".x shapes.C"",; ""The Geometry Shapes"");; bar.AddButton(""atlasna49"", "".x atlasna49.C"",; ""Creating and Viewing Geometries"");; bar.AddButton(""file_layout"", "".x file.C"",; ""The ROOT file format"");; bar.AddButton(""tree_layout"", "".x tree.C"",; ""The Tree Data Structure"");; bar.AddButton(""ntuple1"", "".x ntuple1.C"",; ""Ntuples and Selections"");; bar.AddButton(""run benchmarks"", "".x benchmarks.C"",; ""Runs all the ROOT benchmarks"");; bar.AddButton(""rootmarks"", "".x rootmarks.C"",; ""Prints an estimated ROOTMARKS for your machine"");; bar.AddButton(""edit_hsimple"", "".!ved hsimple.C &"",",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TControlBar.html:1410,Simpl,Simple,1410,root/html532/TControlBar.html,https://root.cern,https://root.cern/root/html532/TControlBar.html,2,['Simpl'],['Simple']
Usability,"euron, separated by comas. Hidden layers are just described; by the number of neurons. The layers are separated by colons.; In addition, input/output layer formulas can be preceded by '@' (e.g ""@out""); if one wants to also normalize the data from the TTree.; Input and outputs are taken from the TTree given as second argument.; Expressions are evaluated as for TTree::Draw(), arrays are expended in; distinct neurons, one for each index.; This can only be done for fixed-size arrays.; If the formula ends with ""!"", softmax functions are used for the output layer.; One defines the training and test datasets by TEventLists. Example:; TMultiLayerPerceptron(""x,y:10:5:f"",inputTree);; Both the TTree and the TEventLists can be defined in; the constructor, or later with the suited setter method. The lists; used for training and test can be defined either explicitly, or via; a string containing the formula to be used to define them, exactly as; for a TCut.; The learning method is defined using the; TMultiLayerPerceptron::SetLearningMethod() . Learning methods are :; TMultiLayerPerceptron::kStochastic, ; TMultiLayerPerceptron::kBatch,; TMultiLayerPerceptron::kSteepestDescent,; TMultiLayerPerceptron::kRibierePolak,; TMultiLayerPerceptron::kFletcherReeves,; TMultiLayerPerceptron::kBFGS; A weight can be assigned to events, either in the constructor, either; with TMultiLayerPerceptron::SetEventWeight(). In addition, the TTree weight; is taken into account.; Finally, one starts the training with; TMultiLayerPerceptron::Train(Int_t nepoch, Option_t* options). The; first argument is the number of epochs while option is a string that; can contain: ""text"" (simple text output) , ""graph""; (evoluting graphical training curves), ""update=X"" (step for; the text/graph output update) or ""+"" (will skip the; randomisation and start from the previous values). All combinations; are available. . Example:; net.Train(100,""text, graph, update=10"").; When the neural net is trained, it can be used; directly",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMultiLayerPerceptron.html:7355,learn,learning,7355,root/html534/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html534/TMultiLayerPerceptron.html,6,['learn'],['learning']
Usability,"evel combination. Int_t activeStream(const RooAbsArg* self, RooFit::MsgTopic topic, RooFit::MsgLevel level); Find appropriate logging stream for message from given object with given topic and message level. Int_t activeStream(const TObject* self, RooFit::MsgTopic topic, RooFit::MsgLevel level); Find appropriate logging stream for message from given object with given topic and message level. ostream& log(const RooAbsArg* self, RooFit::MsgLevel level, RooFit::MsgTopic topic, Bool_t skipPrefix); Log error message associated with RooAbsArg object self at given level and topic. If skipPrefix; is true the standard RooMsgService prefix is not added. ostream& log(const TObject* self, RooFit::MsgLevel level, RooFit::MsgTopic topic, Bool_t skipPrefix); Log error message associated with TObject object self at given level and topic. If skipPrefix; is true the standard RooMsgService prefix is not added. void Print(Option_t* options = 0) const; Print configuration of message service. If ""v"" option is given also; inactive streams are listed. StreamConfig& getStream(Int_t id); { return _streams[id] ; }. Int_t numStreams() const; { return _streams.size() ; }. void reset(); { cleanup() ; }. void setGlobalKillBelow(RooFit::MsgLevel level); { _globMinLevel = level ; }. RooFit::MsgLevel globalKillBelow() const; { return _globMinLevel ; }. void showPid(Bool_t flag); { _showPid = flag ; }. Bool_t silentMode() const; Print level support for RooFit-related messages that are not routed through RooMsgService (such as Minuit printouts). { return _silentMode ; }. void setSilentMode(Bool_t flag); { _silentMode = flag ; }. Int_t errorCount() const; { return _errorCount ; }. void clearErrorCount(); { _errorCount = 0 ; }. RooMsgService(); Private ctor -- singleton class. » Last changed: Mon Dec 7 13:48:17 2009 » Last generated: 2009-12-07 13:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMsgService.html:12194,clear,clearErrorCount,12194,root/html526/RooMsgService.html,https://root.cern,https://root.cern/root/html526/RooMsgService.html,1,['clear'],['clearErrorCount']
Usability,"evel=99);  Add a new branch, and infer the data type from the array addobj being passed. ;  ; template<class T > ; TBranch * Branch (const char *name, T *obj, Int_t bufsize=32000, Int_t splitlevel=99);  Add a new branch, and infer the data type from the type of obj being passed. ;  ; virtual TBranch * BranchRef ();  Build the optional branch supporting the TRefTable. ;  ; void Browse (TBrowser *) override;  Browse content of the TTree. ;  ; virtual Int_t BuildIndex (const char *majorname, const char *minorname=""0"");  Build a Tree Index (default is TTreeIndex). ;  ; TStreamerInfo * BuildStreamerInfo (TClass *cl, void *pointer=nullptr, bool canOptimize=true);  Build StreamerInfo for class cl. ;  ; virtual TFile * ChangeFile (TFile *file);  Called by TTree::Fill() when file has reached its maximum fgMaxTreeSize. ;  ; virtual TTree * CloneTree (Long64_t nentries=-1, Option_t *option="""");  Create a clone of this tree and copy nentries. ;  ; virtual void CopyAddresses (TTree *, bool undo=false);  Set branch addresses of passed tree equal to ours. ;  ; virtual Long64_t CopyEntries (TTree *tree, Long64_t nentries=-1, Option_t *option="""", bool needCopyAddresses=false);  Copy nentries from given tree to this tree. ;  ; virtual TTree * CopyTree (const char *selection, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Copy a tree with selection. ;  ; Int_t Debug () const;  ; void Delete (Option_t *option="""") override;  Delete this tree from memory or/and disk. ;  ; virtual void DirectoryAutoAdd (TDirectory *);  Called by TKey and TObject::Clone to automatically add us to a directory when we are read from a file. ;  ; virtual Long64_t Draw (const char *varexp, const char *selection, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Draw expression varexp for entries and objects that pass a (optional) selection. ;  ; virtual Long64_t Draw (const char *varexp, const TCut &selection, Option_t *option="""", Long64_t nentries=kMaxEn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeSQL.html:6095,undo,undo,6095,doc/master/classTTreeSQL.html,https://root.cern,https://root.cern/doc/master/classTTreeSQL.html,1,['undo'],['undo']
Usability,"eventn;; 316 ; 317 // Create a ROOT Tree; 318 TTree tree(""T"",""An example of ROOT tree with a few branches"");; 319 tree.Branch(""point"",&point,""x:y:z"");; 320 tree.Branch(""eventn"",&eventn,""ntrack/I:nseg:nvertex:flag/i:temperature/F"");; 321 tree.Branch(""hpx"",""TH1F"",&hpx,128000,0);; 322 ; 323 Float_t px,py,pz;; 324 ; 325 // Here we start a loop on 1000 events; 326 for ( Int_t i=0; i<1000; i++) {; 327 gRandom->Rannor(px,py);; 328 pz = px*px + py*py;; 329 const auto random = gRandom->::Rndm(1);; 330 ; 331 // Fill histograms; 332 hpx.Fill(px);; 333 hpxpy.Fill(px,py,1);; 334 hprof.Fill(px,pz,1);; 335 ; 336 // Fill structures; 337 point.x = 10*(random-1);; 338 point.y = 5*random;; 339 point.z = 20*random;; 340 eventn.ntrack = Int_t(100*random);; 341 eventn.nseg = Int_t(2*eventn.ntrack);; 342 eventn.nvertex = 1;; 343 eventn.flag = Int_t(random+0.5);; 344 eventn.temperature = 20+random;; 345 ; 346 // Fill the tree. For each event, save the 2 structures and 3 objects; 347 // In this simple example, the objects hpx, hprof and hpxpy are slightly; 348 // different from event to event. We expect a big compression factor!; 349 tree->Fill();; 350 }; 351 // End of the loop; 352 ; 353 tree.Print();; 354 ; 355 // Save all objects in this file; 356 hfile.Write();; 357 ; 358 // Close the file. Note that this is automatically done when you leave; 359 // the application upon file destruction.; 360 hfile.Close();; 361 ; 362 return 0;; 363}; 364~~~; 365*/; 366 ; 367#include <ROOT/RConfig.hxx>; 368#include ""TTree.h""; 369 ; 370#include ""ROOT/TIOFeatures.hxx""; 371#include ""TArrayC.h""; 372#include ""TBufferFile.h""; 373#include ""TBaseClass.h""; 374#include ""TBasket.h""; 375#include ""TBranchClones.h""; 376#include ""TBranchElement.h""; 377#include ""TBranchObject.h""; 378#include ""TBranchRef.h""; 379#include ""TBrowser.h""; 380#include ""TClass.h""; 381#include ""TClassEdit.h""; 382#include ""TClonesArray.h""; 383#include ""TCut.h""; 384#include ""TDataMember.h""; 385#include ""TDataType.h""; 386#include ""TDirectory.h""; 38",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:15573,simpl,simple,15573,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['simpl'],['simple']
Usability,"evious block status. ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static Bool_t Connect (const char *sender_class, const char *signal, const char *receiver_class, void *receiver, const char *slot);  This method allows to make a connection from any object of the same class to a single slot. ;  ; static Bool_t Connect (TQObject *sender, const char *signal, const char *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  ; static const char * DeclFileName ();  ; static Bool_t Disconnect (const char *class_name, const char *signal, void *receiver=nullptr, const char *slot=nullptr);  Disconnects ""class signal"". ;  ; static Bool_t Disconnect (TQObject *sender, const char *signal=nullptr, void *receiver=nullptr, const char *slot=nullptr);  Disconnects signal in object sender from slot_method in object receiver. ;  . Protected Member Functions; Bool_t HandleTimer (TTimer *timer) override;  Send progress and feedback to client. ;  ; void SetupFeedback () override;  Setup reporting of feedback objects and progress messages. ;  ;  Protected Member Functions inherited from TProofPlayerRemote; TProof * GetProof () const;  ; Int_t InitPacketizer (TDSet *dset, Long64_t nentries, Long64_t first, const char *defpackunit, const char *defpackdata);  Init the packetizer Return 0 on success (fPacketizer is correctly initialized), -1 on failure. ;  ; TList * MergeFeedback ();  Merge feedback lists. ;  ; Bool_t MergeOutputFiles ();  Merge output in files. ;  ; void NotifyMemory (TObject *obj);  Printout the memory record after merging object 'obj' This record is used by the memory monitor. ;  ; virtual Bool_t SendSelector (const char *selector_file);  Send the selector file(s) to master or worker nodes. ;  ; void SetLastMergingMsg (TObject *obj);  Set the message to be notified in case of exception. ;  ; void SetSelectorDataMembersFromOutputList ();  Set the selector",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerSuperMaster.html:19894,feedback,feedback,19894,doc/master/classTProofPlayerSuperMaster.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerSuperMaster.html,1,['feedback'],['feedback']
Usability,"ew TH1F(""hst12"", """", 20, -10, 10);; hst12->FillRandom(""gaus"", 500);; hst12->SetFillColor(kBlue);; hst12->SetLineColor(kBlue);. THStack st1(""st1"", ""st1"");; st1.Add(hst11);; st1.Add(hst12);. cst1->cd(1); st1.Draw();; cst1->cd(2); st1.Draw(""hist"");. return cst1;; }; Drawing of 3D implicit functions; 3D implicit functions (TF3) can be drawn as iso-surfaces.; The implicit function f(x,y,z) = 0 is drawn in cartesian coordinates.; In the following example the options ""FB"" and ""BB"" suppress the ; ""Front Box"" and ""Back Box"" around the plot. Picture; Source. {; TCanvas *c2 = new TCanvas(""c2"",""c2"",600,400);; TF3 *f3 = new TF3(""f3"",""sin(x*x+y*y+z*z-36)"",-2,2,-2,2,-2,2);; f3->SetClippingBoxOn(0,0,0);; f3->SetFillColor(30);; f3->SetLineColor(15);; f3->Draw(""FBBB"");; return c2;; }; Associated functions drawing; An associated function is created by TH1::Fit. More than on fitted; function can be associated with one histogram (see TH1::Fit).; A TF1 object f1 can be added to the list of associated; functions of an histogram h without calling TH1::Fit; simply doing:. h->GetListOfFunctions()->Add(f1);. or. h->GetListOfFunctions()->Add(f1,someoption);. To retrieve a function by name from this list, do:. TF1 *f1 = (TF1*)h->GetListOfFunctions()->FindObject(name);. or. TF1 *f1 = h->GetFunction(name);. Associated functions are automatically painted when an histogram is drawn.; To avoid the painting of the associated functions the option HIST; should be added to the list of the options used to paint the histogram.; Drawing using OpenGL; The class TGLHistPainter allows to paint data set using the OpenGL 3D; graphics library. The plotting options start with GL keyword.; In addition, in order to inform canvases that OpenGL should be used to render; 3D representations, the following option should be set:. gStyle->SetCanvasPreferGL(true);. General information: plot types and supported options; The following types of plots are provided:; For lego plots the supported options are:. ""GLLEGO""; Draw a l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/THistPainter.html:69632,simpl,simply,69632,root/html530/THistPainter.html,https://root.cern,https://root.cern/root/html530/THistPainter.html,1,['simpl'],['simply']
Usability,"ew TObjArray();; a1->SetName(""a1"");; l->Add(a1);; TH1F *ha1a = new TH1F(""ha1a"",""ha1"",100,0,1);; TH1F *ha1b = new TH1F(""ha1b"",""ha1"",100,0,1);; a1->Add(ha1a);; a1->Add(ha1b);; TObjArray *b1 = new TObjArray();; b1->SetName(""b1"");; l->Add(b1);; TH1F *hb1a = new TH1F(""hb1a"",""hb1"",100,0,1);; TH1F *hb1b = new TH1F(""hb1b"",""hb1"",100,0,1);; b1->Add(hb1a);; b1->Add(hb1b);. TObjArray *a2 = new TObjArray();; a2->SetName(""a2"");; l->Add(a2);; TH1S *ha2a = new TH1S(""ha2a"",""ha2"",100,0,1);; TH1S *ha2b = new TH1S(""ha2b"",""ha2"",100,0,1);; a2->Add(ha2a);; a2->Add(ha2b);. T.Branch(l,16000,2);; T.Print();; }. Int_t Branch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99); Create one branch for each element in the folder.; Returns the total number of branches created. TBranch* Branch(const char* name, void* address, const char* leaflist, Int_t bufsize = 32000); Create a new TTree Branch. This Branch constructor is provided to support non-objects in; a Tree. The variables described in leaflist may be simple; variables or structures. // See the two following; constructors for writing objects in a Tree. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. * address is the address of the first item of a structure.; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a slash (/).; The variable type may be 0,1 or 2 characters. If no type is given,; the type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is assumed; of type F by default. The list of currently supported types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:44037,simpl,simple,44037,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,2,['simpl'],['simple']
Usability,"ew dimensions. It relies heavily on ROOT package, borrowing persistency of classes from ROOT. mFOAM can be easily used from the ROOT shell. For more difficult problems the full FOAM may be better. How to run application programs ?; The application program can be run in two modes: it can be simply interpreted by CLING or compiled. The first method is simpler but results in slower execution. The second method employs ACLiC - The Automatic Compiler of Libraries, which automatizes the process of compilation and linking.; In /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master.build/tutorials there are 3 demonstration programs:; foam_kanwa.C; is a simple example how to run FOAM in interactive mode. To run this macro issue the following simple command from the Linux shell:; root foam_kanwa.C; or from CLING:; root [0] .x foam_kanwa.C; Simulation will start and graphical canvas with plot of the distribution function appear. In this example we defined the distribution function simply as a global function function Camel2.; foam_demo.C; shows usage of FOAM in compiled mode, which is the preferred method. The integrand function is defined now as a Density method from class TFDISTR inheriting from abstract class TFoamIntegrand. User can modify interface to integrand function according to their needs but they should always remember to define Density method which provides the density distribution. Enter CLING interpreter and type:; root [0] gSystem->Load(""libFoam.so""); root [1] .x foam_demo.C+; to load FOAM library, compile and execute macro foam_demo.C. A shared object foam_demo_C.so is created in the current directory. At the end of exploration phase FOAM object including distribution function will be written to disk.; foam_demopers.C; demonstrates persistency of FOAM classes. To run this macro type:; root [0] .x foam_demopers.C; Program reads the FOAM object from disk, checks its consistency and prints geometry of cells. Next starts the the generation. It ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__FOAM.html:1467,simpl,simply,1467,doc/master/group__tutorial__FOAM.html,https://root.cern,https://root.cern/doc/master/group__tutorial__FOAM.html,1,['simpl'],['simply']
Usability,"ewer - ignore return cannot do more; viewer->AddObject(buffer);; }; }; TBuffer3DSphereSphere description class - see TBuffer3DTypes for producer classes Supports hollow and cut spheres.Definition TBuffer3D.h:130; TBuffer3D::kNone@ kNoneDefinition TBuffer3D.h:49; TBuffer3D::kRaw@ kRawDefinition TBuffer3D.h:54; TBuffer3D::kRawSizes@ kRawSizesDefinition TBuffer3D.h:53; int; ShapeSpecific: If the viewer can directly display the buffer without filling of the kRaw/kRawSizes section it will not need to request client side tessellation. Currently we provide the following various shape specific classes, which the OpenGL viewer can take advantage of (see TBuffer3D.h and TBuffer3DTypes.h). TBuffer3DSphere - solid, hollow and cut spheres*; TBuffer3DTubeSeg - angle tube segment; TBuffer3DCutTube - angle tube segment with plane cut ends. OpenGL only supports solid spheres at present - cut/hollow ones will be requested tessellated.; Anyone is free to add new TBuffer3D classes, but it should be clear that the viewers require updating to be able to take advantage of them. The number of native shapes in OpenGL will be expanded over time.; BoundingBox: You are not obliged to complete this, as any viewer requiring one internally (OpenGL) will build one for you if you do not provide. However to do this the viewer will force you to provide the raw tessellation, and the resulting box will be axis aligned with the overall scene, which is non-ideal for rotated shapes.; As we need to support orientated (rotated) bounding boxes, TBuffer3D requires the 6 vertices of the box. We also provide a convenience function, SetAABoundingBox(), for simpler case of setting an axis aligned bounding box. Master/Local Reference Frames; The Core section of TBuffer3D contains two members relating to reference frames: fLocalFrame & fLocalMaster. fLocalFrame indicates if any positions in the buffer (bounding box and tessellation vertexes) are in local or master (world frame). fLocalMaster is a standard 4x4 transl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualViewer3D.html:5892,clear,clear,5892,doc/master/classTVirtualViewer3D.html,https://root.cern,https://root.cern/doc/master/classTVirtualViewer3D.html,1,['clear'],['clear']
Usability,"ewer to suspend redraws etc, and after; the EndScene the viewer will reset the camera to frame the new scene and redraw.; [x3d viewer does not support changing of scenes - objects added after the; first Open/CloseScene pair will be ignored.]; Filling TBuffer3D and Adding to Viewer; The viewers behind the TVirtualViewer3D interface differ greatly in their; capabilities e.g. Some know how to draw certain shapes natively (e.g. spheres/tubes in; OpenGL) - others always require a raw tessellation description of points/lines/segments.; Some; need the 3D object positions in the global frame, others can cope with; local frames + a translation matrix - which can give considerable performance; benefits. To cope with these situations the object buffer is filled out in negotiation; with the viewer. TBuffer3D classes are conceptually divided into enumerated; sections Core, BoundingBox, Raw etc (see TBuffer3D.h for more details). . The SectionsValid() / SetSectionsValid / ClearSectionsValid() methods of TBuffer3D; are used to test/set/clear these section valid flags.; The sections found in TBuffer3D (Core/BoundingBox/Raw Sizes/Raw); are sufficient to describe any tessellated shape in a generic fashion. An additional ShapeSpecific section; in derived shape specific classes allows a more abstract shape description; (""a sphere of inner radius x, outer radius y""). This enables a viewer; which knows how to draw (tessellate) the shape itself to do so, which can bring; considerable performance and quality benefits, while providing a generic fallback; suitable for all viewers.; The rules for client negotiation with the viewer are:. If suitable specialized TBuffer3D class exists, use it, otherwise use; TBuffer3D.; Complete the mandatory Core section.; Complete the ShapeSpecific section; if applicable.; Complete the BoundingBox if you can.; Pass this buffer to the viewer using; one of the AddObject() methods - see below. If the viewer requires more sections to be completed (Raw/RawSizes) A",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualViewer3D.html:3229,clear,clear,3229,root/html528/TVirtualViewer3D.html,https://root.cern,https://root.cern/root/html528/TVirtualViewer3D.html,14,"['Clear', 'clear']","['ClearSectionsValid', 'clear']"
Usability,"ewtopic.php?f=3&t=13299; 1215 if (e1sq) w1 = 1./ e1sq;; 1216 else if (h1->fSumw2.fN) {; 1217 w1 = 1.E200; // use an arbitrary huge value; 1218 if (y1 == 0 ) { // use an estimated error from the global histogram scale; 1219 double sf = (s1[0] != 0) ? s1[1]/s1[0] : 1;; 1220 w1 = 1./(sf*sf);; 1221 }; 1222 }; 1223 if (e2sq) w2 = 1./ e2sq;; 1224 else if (h2->fSumw2.fN) {; 1225 w2 = 1.E200; // use an arbitrary huge value; 1226 if (y2 == 0) { // use an estimated error from the global histogram scale; 1227 double sf = (s2[0] != 0) ? s2[1]/s2[0] : 1;; 1228 w2 = 1./(sf*sf);; 1229 }; 1230 }; 1231 ; 1232 double y = (w1*y1 + w2*y2)/(w1 + w2);; 1233 UpdateBinContent(i, y);; 1234 if (fSumw2.fN) {; 1235 double err2 = 1./(w1 + w2);; 1236 if (err2 < 1.E-200) err2 = 0; // to remove arbitrary value when e1=0 AND e2=0; 1237 fSumw2.fArray[i] = err2;; 1238 }; 1239 }; 1240 } else { // case of simple histogram addition; 1241 Double_t c1sq = c1 * c1;; 1242 Double_t c2sq = c2 * c2;; 1243 for (Int_t i = 0; i < fNcells; ++i) { // Loop on cells (bins including underflows/overflows); 1244 UpdateBinContent(i, c1 * h1->RetrieveBinContent(i) + c2 * h2->RetrieveBinContent(i));; 1245 if (fSumw2.fN) {; 1246 fSumw2.fArray[i] = c1sq * h1->GetBinErrorSqUnchecked(i) + c2sq * h2->GetBinErrorSqUnchecked(i);; 1247 }; 1248 }; 1249 }; 1250 ; 1251 if (resetStats) {; 1252 // statistics need to be reset in case coefficient are negative; 1253 ResetStats();; 1254 }; 1255 else {; 1256 // update statistics (do here to avoid changes by SetBinContent) FIXME remove???; 1257 PutStats(s3);; 1258 SetEntries(nEntries);; 1259 }; 1260 ; 1261 return kTRUE;; 1262}; 1263 ; 1264////////////////////////////////////////////////////////////////////////////////; 1265/// Increment bin content by 1.; 1266/// Passing an out-of-range bin leads to undefined behavior; 1267 ; 1268void TH1::AddBinContent(Int_t); 1269{; 1270 AbstractMethod(""AddBinContent"");; 1271}; 1272 ; 1273////////////////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:49262,simpl,simple,49262,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['simpl'],['simple']
Usability,"ex();; tree.SetTreeIndex(newIndex);; tree.Draw();; tree.SetTreeIndex(oldIndex);; tree.Draw(); etc. void SetWeight(Double_t w = 1, Option_t* option = """"); Set tree weight. The weight is used by TTree::Draw to automatically weight each; selected entry in the resulting histogram. For example the equivalent of:. T.Draw(""x"", ""w""). is:. T.SetWeight(w);; T.Draw(""x"");. This function is redefined by TChain::SetWeight. In case of a; TChain, an option ""global"" may be specified to set the same weight; for all trees in the TChain instead of the default behaviour; using the weights of each tree in the chain (see TChain::SetWeight). void Show(Long64_t entry = -1, Int_t lenmax = 20); Print values of all active leaves for entry. if entry==-1, print current entry (default); if a leaf is an array, a maximum of lenmax elements is printed. void StartViewer(); Start the TTreeViewer on this tree. ww is the width of the canvas in pixels; wh is the height of the canvas in pixels. void StopCacheLearningPhase(); stop the cache learning phase. void Streamer(TBuffer& ); Stream a class object. Int_t UnbinnedFit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Unbinned fit of one or more variable(s) from a tree. funcname is a TF1 function. See TTree::Draw for explanations of the other parameters. Fit the variable varexp using the function funcname using the; selection cuts given by selection. The list of fit options is given in parameter option.; option = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""M"" More. Improve fit results. You can specify boundary limits for some or all parameters via; func->SetParLimits(p_number, parmin, parmax);; if parmin>=parmax, the parameter is fixed; Note that you are not forced to fix the limits for all parameters.; For example, if you fit a function with 6 parame",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:137656,learn,learning,137656,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,4,['learn'],['learning']
Usability,"ex();; tree.SetTreeIndex(newIndex);; tree.Draw();; tree.SetTreeIndex(oldIndex);; tree.Draw(); etc. void SetWeight(Double_t w = 1, Option_t* option = """"); Set tree weight. The weight is used by TTree::Draw to automatically weight each; selected entry in the resulting histogram. For example the equivalent of:. T.Draw(""x"", ""w""). is:. T.SetWeight(w);; T.Draw(""x"");. This function is redefined by TChain::SetWeight. In case of a; TChain, an option ""global"" may be specified to set the same weight; for all trees in the TChain instead of the default behaviour; using the weights of each tree in the chain (see TChain::SetWeight). void Show(Long64_t entry = -1, Int_t lenmax = 20); Print values of all active leaves for entry. if entry==-1, print current entry (default); if a leaf is an array, a maximum of lenmax elements is printed. void StartViewer(); Start the TTreeViewer on this tree. ww is the width of the canvas in pixels; wh is the height of the canvas in pixels. void StopCacheLearningPhase(); stop the cache learning phase. void Streamer(TBuffer& b); Stream a class object. Int_t UnbinnedFit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Unbinned fit of one or more variable(s) from a tree. funcname is a TF1 function. See TTree::Draw for explanations of the other parameters. Fit the variable varexp using the function funcname using the; selection cuts given by selection. The list of fit options is given in parameter option.; option = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""M"" More. Improve fit results. You can specify boundary limits for some or all parameters via; func->SetParLimits(p_number, parmin, parmax);; if parmin>=parmax, the parameter is fixed; Note that you are not forced to fix the limits for all parameters.; For example, if you fit a function with 6 param",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:125403,learn,learning,125403,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,4,['learn'],['learning']
Usability,"ex);; tree.Draw();; tree.SetTreeIndex(oldIndex);; tree.Draw(); etc. void SetWeight(Double_t w = 1, Option_t* option = """"); Set tree weight. The weight is used by TTree::Draw to automatically weight each; selected entry in the resulting histogram. For example the equivalent of:. T.Draw(""x"", ""w""). is:. T.SetWeight(w);; T.Draw(""x"");. This function is redefined by TChain::SetWeight. In case of a; TChain, an option ""global"" may be specified to set the same weight; for all trees in the TChain instead of the default behaviour; using the weights of each tree in the chain (see TChain::SetWeight). void Show(Long64_t entry = -1, Int_t lenmax = 20); Print values of all active leaves for entry. if entry==-1, print current entry (default); if a leaf is an array, a maximum of lenmax elements is printed. void StartViewer(); Start the TTreeViewer on this tree. ww is the width of the canvas in pixels; wh is the height of the canvas in pixels. Int_t StopCacheLearningPhase(); stop the cache learning phase; Returns 0 learning phase stopped or not active; -1 on error. void Streamer(TBuffer& ); Stream a class object. Int_t UnbinnedFit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Unbinned fit of one or more variable(s) from a tree. funcname is a TF1 function. See TTree::Draw for explanations of the other parameters. Fit the variable varexp using the function funcname using the; selection cuts given by selection. The list of fit options is given in parameter option.; option = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""M"" More. Improve fit results. You can specify boundary limits for some or all parameters via; func->SetParLimits(p_number, parmin, parmax);; if parmin>=parmax, the parameter is fixed; Note that you are not forced to fix the limits for all parameters.; For example, if y",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTree.html:139670,learn,learning,139670,root/html604/TTree.html,https://root.cern,https://root.cern/root/html604/TTree.html,4,['learn'],['learning']
Usability,"example, if the formula; TFormula old(sin(x*(x<0.5 || x>1))) one can assign a name to the formula. By default; the name of the object = title = formula itself.; old.SetName(""old"").; then, old can be reused in a new expression.; TFormula new(""x*old"") is equivalent to:; TFormula new(""x*sin(x*(x<0.5 || x>1))""). Up to 4 dimensions are supported (indicated by x, y, z, t); An expression may have 0 parameters or a list of parameters; indicated by the sequence [par_number]. A graph showing the logic to compile and analyze a formula; is shown in TFormula::Compile and TFormula::Analyze.; Once a formula has been compiled, it can be evaluated for a given; set of parameters. see graph in TFormula::EvalPar. This class is the base class for the function classes TF1,TF2 and TF3.; It is also used by the ntuple selection mechanism TNtupleFormula. In version 7 of TFormula, the usage of fOper has been changed; to improve the performance of TFormula::EvalPar.; Conceptually, fOper was changed from a simple array of Int_t; to an array of composite values.; For example a 'ylandau(5)' operation used to be encoded as 4105;; it is now encoded as (klandau >> kTFOperShit) + 5; Any class inheriting from TFormula and using directly fOper (which; is now a private data member), needs to be updated to take this; in consideration. The member functions recommended to set and; access fOper are: SetAction, GetAction, GetActionParam; For more performant access to the information, see the implementation; TFormula::EvalPar. CHANGING DEFAULT SETTINGS. When creating complex formula , it may be necessary to increase; some default parameters. see static function TFormula::SetMaxima. WHY TFormula CANNOT ACCEPT A CLASS MEMBER FUNCTION ?. This is a frequently asked question.; C++ is a strongly typed language. There is no way for TFormula (without; recompiling this class) to know about all possible user defined data types.; This also apply to the case of a static class function.; Because TMath is a special and fre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFormula.html:2234,simpl,simple,2234,root/html534/TFormula.html,https://root.cern,https://root.cern/root/html534/TFormula.html,6,['simpl'],['simple']
Usability,"examples for the training and testing of the TMVA classifiers. ;  ; file  TMVAClassificationApplication.C;   This macro provides a simple example on how to use the trained classifiers within an analysis module ;  ; file  TMVAClassificationCategory.C;   This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode. ;  ; file  TMVAClassificationCategoryApplication.C;   This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ;  ; file  TMVACrossValidation.C;   This macro provides an example of how to use TMVA for k-folds cross evaluation. ;  ; file  TMVACrossValidationApplication.C;   This macro provides an example of how to use TMVA for k-folds cross evaluation in application. ;  ; file  TMVACrossValidationRegression.C;   This macro provides an example of how to use TMVA for k-folds cross evaluation. ;  ; file  TMVAGAexample.C;   This executable gives an example of a very simple use of the genetic algorithm of TMVA ;  ; file  TMVAGAexample2.C;   This executable gives an example of a very simple use of the genetic algorithm of TMVA. ;  ; file  TMVAMinimalClassification.C;   Minimal self-contained example for setting up TMVA with binary classification. ;  ; file  TMVAMulticlass.C;   This macro provides a simple example for the training and testing of the TMVA multiclass classification ;  ; file  TMVAMulticlassApplication.C;   This macro provides a simple example on how to use the trained multiclass classifiers within an analysis module ;  ; file  TMVAMultipleBackgroundExample.C;   This example shows the training of signal with three different backgrounds Then in the application a tree is created with all signal and background events where the true class ID and the three classifier outputs are added finally with the application tree, the significance is maximized with the help of the TMVA genetic algorithm. ;  ; file  TMVARegression.C;   This macro provides examples ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__tmva.html:6127,simpl,simple,6127,doc/master/group__tutorial__tmva.html,https://root.cern,https://root.cern/doc/master/group__tutorial__tmva.html,1,['simpl'],['simple']
Usability,"exible Object; Oriented implementation has been choosen over a faster but more; difficult to maintain code. Nevertheless, the time penalty does not; exceed a factor 2. The; MLP. The multilayer perceptron is a simple feed-forward network with; the following structure:. It is made of neurons characterized by a bias and weighted links; between them (let's call those links synapses). The input neurons; receive the inputs, normalize them and forward them to the first; hidden layer. Each neuron in any subsequent layer first computes a linear; combination of the outputs of the previous layer. The output of the; neuron is then function of that combination with f being; linear for output neurons or a sigmoid for hidden layers. This is; useful because of two theorems:. A linear combination of sigmoids can approximate any; continuous function.; Trained with output = 1 for the signal and 0 for the; background, the approximated function of inputs X is the probability; of signal, knowing X. Learning; methods. The aim of all learning methods is to minimize the total error on; a set of weighted examples. The error is defined as the sum in; quadrature, devided by two, of the error on each individual output; neuron.; In all methods implemented, one needs to compute; the first derivative of that error with respect to the weights.; Exploiting the well-known properties of the derivative, especialy the; derivative of compound functions, one can write:. for a neuton: product of the local derivative with the; weighted sum on the outputs of the derivatives.; for a synapse: product of the input with the local derivative; of the output neuron. This computation is called back-propagation of the errors. A; loop over all examples is called an epoch.; Six learning methods are implemented.; Stochastic minimization: This; is the most trivial learning method. This is the Robbins-Monro; stochastic approximation applied to multilayer perceptrons. The; weights are updated after each example according to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMultiLayerPerceptron.html:3512,Learn,Learning,3512,root/html532/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html532/TMultiLayerPerceptron.html,1,['Learn'],['Learning']
Usability,"exist. For example in the case of Minuit, we have Migrad, Simplex or Minimize. The minimizer and its corresponding algorithm, when available, can be set by using the function FitConfig::SetMinimizer(""minimizerName"") or by using directly the ROOT:Math::MinimizerOptions class.; If the requested minimizer is not available in ROOT, the default one is used. The default minimizer type and algorithm can be specified by using the static function ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""minimizerName""); 5.7.4 Minimizer Libraries and Algorithms; The list of available minimizer libraries currently available in ROOT, with their corresponding available algorithms is the following one. Some minimizers (e.g. Minuit) contain several algorithms that the user can choose. Others are based on a single algorithm (e.g. Fumili). Minuit (library libMinuit). Old version of Minuit, based on the TMinuit class. The list of possible algorithms are:. Migrad (default one); Simplex; Minimize (it is a combination of Migrad and Simplex); MigradImproved; Scan; Seek. Minuit2 (library libMinuit2). New C++ version of Minuit. The list of possible algorithm is :. Migrad (default); Simplex; Minimize; Scan; Fumili . This is the same algorithm of TFumili, but implemented in the Minuit2 library. Fumili. Implement a dedicated minimization algorithm for least-square and likelihood fits. It has requirements on the type of method function to be used. No specific algorithm exists; GSLMultiMin (library libMathMore). Minimizer based on the Multidimensional Minimization routines of the Gnu Scientific Library (GSL). The list of available algorithms is. BFGS2 (default) : second version of the vector Broyden-Fletcher-Goldfarb-Shanno (BFGS) algorithm;; BFGS : old version of the vector Broyden-Fletcher-Goldfarb-Shanno (BFGS) algorithm;; ConjugateFR : Fletcher-Reeves conjugate gradient algorithm;; ConjugatePR : Polak-Ribiere conjugate gradient algorithm;; SteepestDescent: steepest descent algorithm;. GSLMultiFit (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:202561,Simpl,Simplex,202561,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['Simpl'],['Simplex']
Usability,"experiment's data. You don't need a library with these classes (though ROOT will print ""Warning in : no dictionary for class EventData/Particle is available"") because a TTree knows what data is stored inside. The EventData class contains a vector (std::vector) of particles represented by a ""Particle"" class and the total size (in bytes) of the event itself:; class EventData {; public:; std::vector<Particle> fParticles; // particles of the event; int fEventSize; // size (in bytes) of the event; };. The data members of the Particle class describe the particle properties as shown below:; class Particle {; public:; double fPosX,fPosY,fPosZ; // particle position nearest to interaction point; double fMomentum; // particle momentum; double fMomentumPhi; // particle direction (phi); double fMomentumEta; // particle direction (eta); Long64_t fTags[128]; // particle tags; };. The TTree contains a branch event, which in turn contains the branches fParticles and fEventSize. It simply reflects the layout of class EventData. Each TTree entry has one object of type class EventData, which in turn has a collection of particles. Each tree entry can have a different number of particles. There are 200 TTree entries containing a total of 22994 particles.; If you are curious how we generated the TTree: the script is in our git repository.; . ‹ Introductory Tutorials; up; Accessing a TTree With a TBrowser ›. Navigate through this book; Meet a TTree; Accessing a TTree With a TBrowser; Using TTree::Draw() to access a TTree; TTree and Its Data; Using a Macro to Read a TTree; Histogramming; Fit Panel; Compiling Your Code (also known as ACLiC); Accessing a TTree With a TSelector; Histogramming in a Selector; Using a TSelector with PROOF; The End. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Subm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/meet-ttree.html:3891,simpl,simply,3891,d/meet-ttree.html,https://root.cern,https://root.cern/d/meet-ttree.html,1,['simpl'],['simply']
Usability,"expr Version_t TBinomialEfficiencyFitter::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 73 of file TBinomialEfficiencyFitter.h. ◆ ComputeFCN(). void TBinomialEfficiencyFitter::ComputeFCN ; (; Double_t & ; f, . const Double_t * ; par . ). private . Compute the likelihood. ; Definition at line 329 of file TBinomialEfficiencyFitter.cxx. ◆ DeclFileName(). static const char * TBinomialEfficiencyFitter::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 73 of file TBinomialEfficiencyFitter.h. ◆ EvaluateFCN(). Double_t TBinomialEfficiencyFitter::EvaluateFCN ; (; const Double_t * ; par). inline . Definition at line 67 of file TBinomialEfficiencyFitter.h. ◆ Fit(). TFitResultPtr TBinomialEfficiencyFitter::Fit ; (; TF1 * ; f1, . Option_t * ; option = """" . ). Carry out the fit of the given function to the given histograms. ; If option ""I"" is used, the fit function will be averaged over the bin (the default is to evaluate it simply at the bin center).; If option ""R"" is used, the fit range will be taken from the fit function (the default is to use the entire histogram).; If option ""S"" a TFitResult object is returned and it can be used to obtain additional fit information, like covariance or correlation matrix.; Note that all parameter values, limits, and step sizes are copied from the input fit function f1 (so they should be set before calling this method. This is particularly relevant for the step sizes, taken to be the ""error"" set on input, as a null step size usually fixes the corresponding parameter. That is protected against, but in such cases an arbitrary starting step size will be used, and the reliability of the fit should be questioned). If parameters are to be fixed, this should be done by specifying non-null parameter limits, with lower limits larger than upper limits.; On output, f1 contains the fitted parameters and errors, as well as the number of degrees",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBinomialEfficiencyFitter.html:17221,simpl,simply,17221,doc/master/classTBinomialEfficiencyFitter.html,https://root.cern,https://root.cern/doc/master/classTBinomialEfficiencyFitter.html,1,['simpl'],['simply']
Usability,"expression). and write your own constructor. MyClass::MyClass(const char *name,const char *expression) : TFormula(). which has to call the TFormula default constructor and whose implementation; should be similar to the implementation of the normal TFormula constructor. This is necessary because the normal TFormula constructor call indirectly; the virtual member functions Analyze, DefaultString, DefaultValue; and DefaultVariable. Bool_t CheckOperands(Int_t operation, Int_t& err); Check whether the operand at 'oper-1' is compatible with the operation; at 'oper'. Bool_t CheckOperands(Int_t leftoperand, Int_t rightoperartion, Int_t& err); Check whether the operands at 'leftoper' and 'oper-1' are compatible with; the operation at 'oper'. Bool_t StringToNumber(Int_t code); Try to 'demote' a string into an array bytes. If this is not possible,; return false. void Clear(Option_t* option = """"); Resets the objects. Resets the object to its state before compilation. void ClearFormula(Option_t* option = """"); Resets the objects. Resets the object to its state before compilation. Int_t Compile(const char* expression = """"); Compile expression already stored in fTitle. Loop on all subexpressions of formula stored in fTitle. If you overload this member function, you also HAVE TO; never call the constructor:. TFormula::TFormula(const char *name,const char *expression). and write your own constructor. MyClass::MyClass(const char *name,const char *expression) : TFormula(). which has to call the TFormula default constructor and whose implementation; should be similar to the implementation of the normal TFormula constructor. This is necessary because the normal TFormula constructor call indirectly; the virtual member functions Analyze, DefaultString, DefaultValue; and DefaultVariable. /*; ; */. void Copy(TObject& formula) const; Copy this formula. char * DefinedString(Int_t code); Return address of string corresponding to special code. This member function is inactive in the TFormula cla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFormula.html:20008,Clear,ClearFormula,20008,root/html534/TFormula.html,https://root.cern,https://root.cern/root/html534/TFormula.html,3,['Clear'],['ClearFormula']
Usability,"ext*RooAbsPdf::binnedGenContext(const RooArgSet& vars, Bool_t verbose = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCFunction1PdfBinding_double_double_.html:3326,clear,clearValueAndShapeDirty,3326,root/html534/RooCFunction1PdfBinding_double_double_.html,https://root.cern,https://root.cern/root/html534/RooCFunction1PdfBinding_double_double_.html,64,['clear'],['clearValueAndShapeDirty']
Usability,"ext*binnedGenContext(const RooArgSet& vars, Bool_t verbose = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tcanBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidclearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsPdf.html:6988,clear,clearValueDirty,6988,root/html534/RooAbsPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html,4,['clear'],['clearValueDirty']
Usability,"ext::PopExpiredMargins ; (; SHtmlMargin_t ** ; ppMarginStack, . int ; y . ). protected . Pop all expired margins from the stack. ; An expired margin is one with a non-negative bottom parameter that is less than the value ""y"". ""y"" is the Y-coordinate of the top edge the next line of text to by positioned. What this function does is check to see if we have cleared any obstacles (an obstacle is an <IMG ALIGN=left> or <IMG ALIGN=right>) and expands the margins if we have. ; Definition at line 152 of file TGHtmlLayout.cxx. ◆ PopIndent(). void TGHtmlLayoutContext::PopIndent ; (; ). Adjust (pop) ident. ; Definition at line 1168 of file TGHtmlLayout.cxx. ◆ PopMargin(). void TGHtmlLayoutContext::PopMargin ; (; SHtmlMargin_t ** ; ppMargin, . int ; tag . ). protected . Pop as many margins as necessary until the margin that was created with ""tag"" is popped off. ; Update the layout context to move past obstacles, if necessary.; If there are some margins on the stack that contain non-negative bottom fields, that means there are some obstacles that we have not yet cleared. If these margins get popped off the stack, then we have to be careful to advance the 'bottom' value so that the next line of text will clear the obstacle. ; Definition at line 119 of file TGHtmlLayout.cxx. ◆ PopOneMargin(). void TGHtmlLayoutContext::PopOneMargin ; (; SHtmlMargin_t ** ; ppMargin). protected . Pop one margin off of the given margin stack. ; Definition at line 99 of file TGHtmlLayout.cxx. ◆ PushIndent(). void TGHtmlLayoutContext::PushIndent ; (; ). Adjust (push) ident. ; Definition at line 1156 of file TGHtmlLayout.cxx. ◆ PushMargin(). void TGHtmlLayoutContext::PushMargin ; (; SHtmlMargin_t ** ; ppMargin, . int ; indent, . int ; mbottom, . int ; tag . ). protected . Push a new margin onto the given margin stack. ; If the ""bottom"" parameter is non-negative, then this margin will automatically expire for all text that is placed below the y-coordinate given by ""bottom"". This feature is used for <IMG AL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGHtmlLayoutContext.html:18878,clear,cleared,18878,doc/master/classTGHtmlLayoutContext.html,https://root.cern,https://root.cern/doc/master/classTGHtmlLayoutContext.html,1,['clear'],['cleared']
Usability,"extMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t indexDefinition TGWin32VirtualXProxy.cxx:168; x2Option_t Option_t TPoint TPoint const char x2Definition TGWin32VirtualXProxy.cxx:70; x1Option_t Option_t TPoint TPoint const char x1Definition TGWin32VirtualXProxy.cxx:70; namechar name[80]Definition TGX11.cxx:110; nentriesint nentriesDefinition THbookFile.cxx:91; TLeaf.h; TNtuple.h; TTree.h; TreeUtils.h; TBranchA TTree is a list of TBranches.Definition TBranch.h:93; TBranch::SetAddressvirtual void SetAddress(void *add)Set address of this branch.Definition TBranch.cxx:2682; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TCollection::Browsevoid Browse(TBrowser *b) overrideBrowse this collection (called by TBrowser).Definition TCollection.cxx:248; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TNtuple::ReadStreamLong64_t ReadStream(std::istream &inputStream, const char *branchDescriptor="""", char delimiter=' ') overrideRead from filename as many columns as variables in the ntuple the function returns the number of rows...Definition TNtuple.cxx:220; TNtuple::~TNtuple~TNtuple() overrideDefault destructor for an Ntuple.Definition TNtuple.cxx:103; TNtuple::IsATClass * IsA() const overrideDefinition TNtuple.h:61; TNtuple::ResetBranchAddressesvoid ResetBranchAddresses() overrideReset the branch addresses to the internal fArgs array.Definition TNtuple.cxx:147; TNtuple::fNvarInt_t fNvarNumber of columns.Definition TNtuple.h:31; TNtuple::ResetBranchAddressvoid ResetBranchAddress(TBranch *) overrideReset the branch addresses to the internal fArgs array.Definition TNtuple.cxx:133; TNtuple::Classstatic TClass * Class(); TNtuple::Browsevoid Browse(TBrowser *b) overrideBrowse content of the ntuple.Definition TNtuple.cxx:158; TN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TNtuple_8cxx_source.html:9837,simpl,simple,9837,doc/master/TNtuple_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TNtuple_8cxx_source.html,1,['simpl'],['simple']
Usability,"extMagnitude() const; Delegate to gVirtualX. void SetTextAlign(Short_t align); Delegate to gVirtualX. void SetTextAngle(Float_t tangle); Delegate to gVirtualX. void SetTextColor(Color_t tcolor); Delegate to gVirtualX. void SetTextFont(Font_t tfont); Delegate to gVirtualX. void SetTextSize(Float_t tsize); Delegate to gVirtualX. void SetTextSizePixels(Int_t npixels); Delegate to gVirtualX. Int_t CreateDrawable(UInt_t w, UInt_t h); Create a gVirtualX Pixmap. void ClearDrawable(); Clear the current gVirtualX window. void CopyDrawable(Int_t id, Int_t px, Int_t py); Copy a gVirtualX pixmap. void DestroyDrawable(); Close the current gVirtualX pixmap. void SelectDrawable(Int_t device); Select the window in which the graphics will go. void DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Paint a simple line. void DrawLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2); Paint a simple line in normalized coordinates. void DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, TVirtualPadPainter::EBoxMode mode); Paint a simple box. void DrawFillArea(Int_t n, const Double_t* x, const Double_t* y); Paint filled area. void DrawFillArea(Int_t n, const Float_t* x, const Float_t* y); Paint filled area. void DrawPolyLine(Int_t n, const Double_t* x, const Double_t* y); Paint polyline. void DrawPolyLine(Int_t n, const Float_t* x, const Float_t* y); Paint polyline. void DrawPolyLineNDC(Int_t n, const Double_t* u, const Double_t* v); Paint polyline in normalized coordinates. void DrawPolyMarker(Int_t n, const Double_t* x, const Double_t* y); Paint polymarker. void DrawPolyMarker(Int_t n, const Float_t* x, const Float_t* y); Paint polymarker. void DrawText(Double_t x, Double_t y, const char* text, TVirtualPadPainter::ETextMode mode); Paint text. void DrawTextNDC(Double_t u, Double_t v, const char* text, TVirtualPadPainter::ETextMode mode); Paint text in normalized coordinates. void SaveImage(TVirtualPad* pad, const char* fileName, Int_t type) const; Save the image ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPadPainter.html:5348,simpl,simple,5348,root/html528/TPadPainter.html,https://root.cern,https://root.cern/root/html528/TPadPainter.html,4,['simpl'],['simple']
Usability,"ey.cxx. ◆ ReadKeyBuffer(). void TKey::ReadKeyBuffer ; (; char *& ; buffer). Decode input buffer. ; Definition at line 1231 of file TKey.cxx. ◆ ReadObj(). TObject * TKey::ReadObj ; (; ). virtual . To read a TObject* from the file. ; The object associated to this key is read from the file into memory Once the key structure is read (via Streamer) the class identifier of the object is known. Using the class identifier we find the TClass object for this class. A TClass object contains a full description (i.e. dictionary) of the associated class. In particular the TClass object can create a new object of the class type it describes. This new object now calls its Streamer function to rebuilt itself.; Use TKey::ReadObjectAny to read any object non-derived from TObject. Note; A C style cast can only be used in the case where the final class of this object derives from TObject as a first inheritance, otherwise one must use a dynamic_cast.; Example1: simplified case; class MyClass : public TObject, public AnotherClass; TObjectMother of all ROOT objects.Definition TObject.h:41; then on return, one get away with using: MyClass *obj = (MyClass*)key->ReadObj();; Example2: Usual case (recommended unless performance is critical); MyClass *obj = dynamic_cast<MyClass*>(key->ReadObj());; which support also the more complex inheritance like: class MyClass : public AnotherClass, public TObject; Of course, dynamic_cast<> can also be used in the example 1. ; Reimplemented in TKeySQL, and TKeyXML.; Definition at line 759 of file TKey.cxx. ◆ ReadObject(). template<typename T > . T * TKey::ReadObject ; (; ). inline . To read an object (non deriving from TObject) from the file. ; This is more user friendly version of TKey::ReadObjectAny. See TKey::ReadObjectAny for more details. ; Definition at line 103 of file TKey.h. ◆ ReadObjectAny(). void * TKey::ReadObjectAny ; (; const TClass * ; expectedClass). virtual . To read an object (non deriving from TObject) from the file. ; If expectedClass is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTKey.html:28547,simpl,simplified,28547,doc/master/classTKey.html,https://root.cern,https://root.cern/doc/master/classTKey.html,1,['simpl'],['simplified']
Usability,"eycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); static TGFrame*BuildCanvas(); static TGFrame*BuildComboBox(); static TGFrame*BuildH3DLine(); static TGFrame*BuildHProgressBar(); static TGFrame*BuildHScrollBar(); static TGFrame*BuildListBox(); static TGFrame*BuildListTree(); static TGFrame*BuildShutter(); static TGFrame*BuildTab(); static TGFrame*BuildTextEdit(); static TGFrame*BuildV3DLine(); static TGFrame*BuildVProgressBar(); static TGFrame*BuildVScrollBar(); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidChangeSelected(TGFrame* f); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; static TGPopupMenu*CreatePopup(); virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()SIGNAL ; virtual voidTGWindow::DestroySubwindows(); virtual voidTGWindow::DestroyWindow(); Boo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TRootGuiBuilder.html:4324,Clear,Clear,4324,root/html532/TRootGuiBuilder.html,https://root.cern,https://root.cern/root/html532/TRootGuiBuilder.html,4,['Clear'],['Clear']
Usability,"e . ). overridevirtual . Read object contents from given stream. ; Reimplemented from RooAbsReal.; Definition at line 186 of file RooGenericPdf.cxx. ◆ redirectServersHook(). bool RooGenericPdf::redirectServersHook ; (; const RooAbsCollection & ; newServerList, . bool ; mustReplaceAll, . bool ; nameChange, . bool ; isRecursive . ). overrideprotectedvirtual . Propagate server changes to embedded formula object. ; Reimplemented from RooAbsPdf.; Definition at line 147 of file RooGenericPdf.cxx. ◆ Streamer(). void RooGenericPdf::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsPdf. ◆ StreamerNVirtual(). void RooGenericPdf::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 80 of file RooGenericPdf.h. ◆ translate(). void RooGenericPdf::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overrideprotectedvirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 205 of file RooGenericPdf.cxx. ◆ writeToStream(). void RooGenericPdf::writeToStream ; (; std::ostream & ; os, . bool ; compact . ); const. overridevirtual . Write object contents to given stream. ; Reimplemented from RooAbsReal.; Definition at line 196 of file RooGenericPdf.cxx. Member Data Documentation. ◆ _actualVars. RooListProxy RooGenericPdf::_actualVars. protected . Definition at line 67 of file RooGenericPdf.h. ◆ _formE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooGenericPdf.html:80859,simpl,simple,80859,doc/master/classRooGenericPdf.html,https://root.cern,https://root.cern/doc/master/classRooGenericPdf.html,1,['simpl'],['simple']
Usability,"f (IsGoodForAutoParseMap(*cxxRcd)){; 3247 headersDeclsMap[autoParseKey] = headers;; 3248 headersDeclsMap[annotatedRcd.GetRequestedName()] = headers;; 3249 } else {; 3250 ROOT::TMetaUtils::Info(nullptr, ""Class %s is not included in the set of autoparse keys.\n"", autoParseKey.c_str());; 3251 }; 3252 ; 3253 // Propagate to the classes map only if this is not a template.; 3254 // The header is then used as autoload key and we want to avoid duplicates.; 3255 if (!llvm::isa<clang::ClassTemplateSpecializationDecl>(cxxRcd)){; 3256 headersClassesMap[autoParseKey] = headersDeclsMap[autoParseKey];; 3257 headersClassesMap[annotatedRcd.GetRequestedName()] = headersDeclsMap[annotatedRcd.GetRequestedName()];; 3258 }; 3259 }; 3260 }; 3261 ; 3262 // The same for the typedefs:; 3263 for (auto & tDef : tDefDecls) {; 3264 if (clang::CXXRecordDecl *cxxRcd = tDef->getUnderlyingType()->getAsCXXRecordDecl()) {; 3265 autoParseKey = """";; 3266 visitedDecls.clear();; 3267 std::list<std::string> headers(RecordDecl2Headers(*cxxRcd, interp, visitedDecls));; 3268 headers.push_back(ROOT::TMetaUtils::GetFileName(*tDef, interp));; 3269 // remove duplicates, also if not subsequent; 3270 buffer.clear();; 3271 headers.remove_if([&buffer](const std::string & s) {; 3272 return !buffer.insert(s).second;; 3273 });; 3274 GetMostExternalEnclosingClassNameFromDecl(*tDef, autoParseKey, interp);; 3275 if (autoParseKey.empty()) autoParseKey = tDef->getQualifiedNameAsString();; 3276 headersDeclsMap[autoParseKey] = headers;; 3277 }; 3278 }; 3279 ; 3280 // The same for the functions:; 3281 for (auto & func : funcDecls) {; 3282 std::list<std::string> headers = {ROOT::TMetaUtils::GetFileName(*func, interp)};; 3283 headersDeclsMap[ROOT::TMetaUtils::GetQualifiedName(*func)] = headers;; 3284 }; 3285 ; 3286 // The same for the variables:; 3287 for (auto & var : varDecls) {; 3288 std::list<std::string> headers = {ROOT::TMetaUtils::GetFileName(*var, interp)};; 3289 headersDeclsMap[ROOT::TMetaUtils::GetQualifiedName(*var)] =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:129926,clear,clear,129926,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['clear'],['clear']
Usability,"f TObjArray and its base classes are not supported.; 16.8.1 The Idea Behind TClonesArray; To reduce the very large number of new and delete calls in large loops like this (O(100000) x O(10000) times new/delete):; TObjArray a(10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000); for (int i = 0; i < ev->Ntracks; i++) { // O(10000); a[i] = new TTrack(x,y,z,...);; ...; }; ...; a.Delete();; }; You better use a TClonesArray which reduces the number of new/delete calls to only O(10000):; TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000); for (int i = 0; i < ev->Ntracks; i++) { // O(10000); TTrack *track = (Track*)a.ConstructedAt(i);; track->Set(x,y,z,...);; ...; }; ...; a.Clear(); // Or Clear(""C"") if the track objects must be returned (via Track::Clear) to a default state.; }; Considering that a pair of new/delete calls on average cost about 70 ms, O(109) new/deletes will save about 19 hours. For the other collections, see the class reference guide on the web and the test program $ROOTSYS/test/tcollex.cxx.; 16.9 Template Containers and STL; Some people dislike polymorphic containers because they are not truly “type safe”. In the end, the compiler leaves it the user to ensure that the types are correct. This only leaves the other alternative: creating a new class each time a new (container organization) / (contained object) combination is needed. To say the least this could be very tedious. Most people faced with this choice would, for each type of container:; Define the class leaving a dummy name for the contained object type. When a particular container was needed, copy the code and then do a global search and replace for the contained class. C++ has a built in template scheme that effectively does just this. For example:; template<class T>; class ArrayContainer {; private:; T *member[10];; ...; };; This is an array container with a 10-element array of pointers to T, it could hold up to 10 T objects. This array is flawed becau",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:855465,guid,guide,855465,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['guid'],['guide']
Usability,"f a new minimum is found, the best parameter values are retained as start values for future scans or minimizations. The curve resulting from each scan can be plotted on the output terminal using MnPlot [api:plot] in order to show the approximate behaviour of the function.; 5.10.2 ScanMinimizer; Although the \(\mbox{SCAN}\) method is not intended for minimization it can be used as a minimizer in its most primitive form.; 5.11 MnSimplex and SimplexMinimizer; [api:simplex]; \(\mbox{SIMPLEX}\) is a function minimization method using the simplex method of Nelder and Mead. MnSimplex provides minimization of the function by the method of \(\mbox{SIMPLEX}\) and the functionality for parameters interaction. It also retains the result from the last minimization in case the user may want to do subsequent minimization steps with parameter interactions in between the minimization requests. The minimization is done by the SimplexMinimizer. Minimization of the function can be done by directly using the SimplexMinimizer if no parameters interaction is required. As \(\mbox{SIMPLEX}\) is a stepping method it does not produce a covariance matrix.; 5.11.1 MnSimplex(const FCNBase&, const std::vector\(<\)double\(>\)&,. const std::vector\(<\)double\(>\)&, unsigned int) ###; Constructor for the minimal required interface: \(\mbox{FCN}\) and starting values for parameters and uncertainties. Optional the strategy level in MnStrategy can be specified.; 5.11.2 MnSimplex(const FCNBase&, const MnUserParameters&,. unsigned int) ###; Constructor for high level parameters interface. Optional the strategy level in MnStrategy can be specified.; 5.11.3 MnSimplex(const FCNBase&, const MnUserParameterState&,. const MnStrategy&) ###; Constructor from a full state (parameters + covariance) as starting input plus the desired strategy.; 5.11.4 operator(); MnSimplex::operator()(unsigned int maxfcn, double tolerance) causes minimization of the \(\mbox{FCN}\) and returns the result in form of a FunctionMinimum",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:50094,Simpl,SimplexMinimizer,50094,root/htmldoc/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html,1,['Simpl'],['SimplexMinimizer']
Usability,"f a new minimum is found, the best parameter values are retained as start values for future scans or minimizations. The curve resulting from each scan can be plotted on the output terminal using MnPlot [api:plot] in order to show the approximate behaviour of the function.; 5.10.2 ScanMinimizer; Although the \(\mbox{SCAN}\) method is not intended for minimization it can be used as a minimizer in its most primitive form.; 5.11 MnSimplex and SimplexMinimizer; [api:simplex]; \(\mbox{SIMPLEX}\) is a function minimization method using the simplex method of Nelder and Mead. MnSimplex provides minimization of the function by the method of \(\mbox{SIMPLEX}\) and the functionality for parameters interaction. It also retains the result from the last minimization in case the user may want to do subsequent minimization steps with parameter interactions in between the minimization requests. The minimization is done by the SimplexMinimizer. Minimization of the function can be done by directly using the SimplexMinimizer if no parameters interaction is required. As \(\mbox{SIMPLEX}\) is a stepping method it does not produce a covariance matrix.; 5.11.1 MnSimplex(const FCNBase&, const std::vector\(<\)double\(>\)&,; const std::vector\(<\)double\(>\)&, unsigned int); Constructor for the minimal required interface: \(\mbox{FCN}\) and starting values for parameters and uncertainties. Optional the strategy level in MnStrategy can be specified.; 5.11.2 MnSimplex(const FCNBase&, const MnUserParameters&,; unsigned int); Constructor for high level parameters interface. Optional the strategy level in MnStrategy can be specified.; 5.11.3 MnSimplex(const FCNBase&, const MnUserParameterState&,; const MnStrategy&); Constructor from a full state (parameters + covariance) as starting input plus the desired strategy.; 5.11.4 operator(); MnSimplex::operator()(unsigned int maxfcn, double tolerance) causes minimization of the \(\mbox{FCN}\) and returns the result in form of a FunctionMinimum. Minimizati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:54099,Simpl,SimplexMinimizer,54099,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,1,['Simpl'],['SimplexMinimizer']
Usability,"f any (matching 'dataset', if defined). ;  ; void ClearFeedback ();  Clear feedback list. ;  ; void ClearInput ();  Clear input object list. ;  ; void ClearInputData (const char *name);  Remove obj 'name' form the input data list;. ;  ; void ClearInputData (TObject *obj=0);  Remove obj form the input data list; if obj is null (default), clear the input data info. ;  ; Int_t ClearPackage (const char *package);  Remove a specific package. ;  ; Int_t ClearPackages ();  Remove all packages. ;  ; void Close (Option_t *option="""");  Close all open slave servers. ;  ; void CloseProgressDialog ();  Close progress dialog. ;  ; TDrawFeedback * CreateDrawFeedback ();  Draw feedback creation proxy. ;  ; void DataSetStatus (const char *msg, Bool_t status, Int_t done, Int_t total);  Send dataset preparation status. ;  ; Int_t DeactivateWorker (const char *ord, Bool_t save=kTRUE);  Remove the worker identified by the ordinal number 'ord' from the the active list. ;  ; void DeleteDrawFeedback (TDrawFeedback *f);  Delete draw feedback object. ;  ; void DeleteParameters (const char *wildcard);  Delete the input list parameters specified by a wildcard (e.g. ;  ; void Detach (Option_t *opt="""");  Detach this instance to its proofserv. ;  ; void DisableGoAsyn ();  Signal to disable related switches. ;  ; Int_t DownloadPackage (const char *par, const char *dstdir=0);  Download a PROOF archive (PAR file) from the master package repository. ;  ; Long64_t DrawSelect (const char *dsetname, const char *varexp, const char *selection="""", Option_t *option="""", Long64_t nentries=-1, Long64_t firstentry=0, TObject *enl=0);  Execute the specified drawing action on a data set which is stored on the master with name 'dsetname'. ;  ; virtual Long64_t DrawSelect (TDSet *dset, const char *varexp, const char *selection="""", Option_t *option="""", Long64_t nentries=-1, Long64_t firstentry=0);  Execute the specified drawing action on a data set (TDSet). ;  ; virtual Int_t Echo (const char *str);  Sends a string t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:5532,feedback,feedback,5532,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,3,['feedback'],['feedback']
Usability,"f blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; he is going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree, Bool_t owner = kFALSE); Update pointer to current Tree and recompute pointers to the branches in the cache. TTreeCache(const TTreeCache& ). TTreeCache& operator=(const TTreeCache& ). Bool_t IsLearning() const; {return fIsLearning;}. » Author: Rene Brun 04/06/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TTreeCache.h 39275 2011-05-19 18:17:3",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTreeCache.html:22291,learn,learning,22291,root/html530/TTreeCache.html,https://root.cern,https://root.cern/root/html530/TTreeCache.html,1,['learn'],['learning']
Usability,"f entries of the whole distribution). Candle plots like these are usually called ""notched candle plots"".; In case the significance of the median is greater that the size of the box, the box will have an unnatural shape. Usually it means the chart has not enough data, or that representing this uncertainty is not useful; The Mean; The mean can be drawn as a dashed line or as a circle or not drawn at all. The mean is the arithmetic average of the values in the distribution. It is calculated using GetMean(). Because histograms are binned data, the mean value can differ from a calculation on the raw-data. If the distribution is large enough and gaussian shaped the mean will be exactly the median.; The Whiskers; The whiskers represent the part of the distribution not covered by the box. The upper 25% and the lower 25% of the distribution are located within the whiskers. Two representations are available. A simple one (using w=1) defining the lower whisker from the lowest data value to the bottom of the box, and the upper whisker from the top of the box to the highest data value. In this representation the whisker-lines are dashed.; A more complex one having a further restriction. The whiskers are still connected to the box but their length cannot exceed \( 1.5\times iqr \). So it might be that the outermost part of the underlying distribution will not be covered by the whiskers. Usually these missing parts will be represented by the outliers (see points). Of course the upper and the lower whisker may differ in length. In this representation the whiskers are drawn as solid lines. SinceROOT version 6.11/01; Using the static function TCandle::SetWhiskerRange(double) the whisker definition w=1 will be overwritten. E.g. using a whisker-range of 0.95 and w=1 will redefine the area of the lower whisker to the upper whisker in order to cover 95% of the distribution inside that candle. The static function will affect all candle-charts in the running program. Default is 1.; If the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:61710,simpl,simple,61710,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,1,['simpl'],['simple']
Usability,"f events from a ROOT dataset into a basic PyTorch workflow. ;  ; file  RBatchGenerator_TensorFlow.py;   Example of getting batches of events from a ROOT dataset into a basic TensorFlow workflow. ;  ; file  tmva001_RTensor.C;   This tutorial illustrates the basic features of the RTensor class, RTensor is a std::vector-like container with additional shape information. ;  ; file  tmva002_RDataFrameAsTensor.C;   This tutorial shows how the content of an RDataFrame can be converted to an RTensor object. ;  ; file  tmva003_RReader.C;   This tutorial shows how to apply with the modern interfaces models saved in TMVA XML files. ;  ; file  tmva004_RStandardScaler.C;   This tutorial illustrates the usage of the standard scaler as preprocessing method. ;  ; file  tmva100_DataPreparation.py;   This tutorial illustrates how to prepare ROOT datasets to be nicely readable by most machine learning methods. ;  ; file  tmva101_Training.py;   This tutorial show how you can train a machine learning model with any package reading the training data directly from ROOT files. ;  ; file  tmva102_Testing.py;   This tutorial illustrates how you can test a trained BDT model using the fast tree inference engine offered by TMVA and external tools such as scikit-learn. ;  ; file  tmva103_Application.C;   This tutorial illustrates how you can conveniently apply BDTs in C++ using the fast tree inference engine offered by TMVA. ;  ; file  TMVA_CNN_Classification.C;   TMVA Classification Example Using a Convolutional Neural Network ;  ; file  TMVA_CNN_Classification.py;   TMVA Classification Example Using a Convolutional Neural Network ;  ; file  TMVA_Higgs_Classification.C;   Classification example of TMVA based on public Higgs UCI dataset ;  ; file  TMVA_Higgs_Classification.py;   Classification example of TMVA based on public Higgs UCI dataset ;  ; file  TMVA_RNN_Classification.C;   TMVA Classification Example Using a Recurrent Neural Network ;  ; file  TMVA_RNN_Classification.py;   TMVA Classific",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__tmva.html:1710,learn,learning,1710,doc/master/group__tutorial__tmva.html,https://root.cern,https://root.cern/doc/master/group__tutorial__tmva.html,1,['learn'],['learning']
Usability,"f file NeuralNet.h. ◆ convergenceCount(). size_t TMVA::DNN::Settings::convergenceCount ; (; ); const. inline . returns the current convergence count ; Definition at line 827 of file NeuralNet.h. ◆ convergenceSteps(). size_t TMVA::DNN::Settings::convergenceSteps ; (; ); const. inline . how many steps until training is deemed to have converged ; Definition at line 766 of file NeuralNet.h. ◆ create() [1/2]. void TMVA::DNN::Settings::create ; (; std::string ; histoName, . int ; bins, . double ; min, . double ; max . ). inline . for monitoring ; Definition at line 819 of file NeuralNet.h. ◆ create() [2/2]. void TMVA::DNN::Settings::create ; (; std::string ; histoName, . int ; bins, . double ; min, . double ; max, . int ; bins2, . double ; min2, . double ; max2 . ). inline . for monitoring ; Definition at line 820 of file NeuralNet.h. ◆ cycle(). virtual void TMVA::DNN::Settings::cycle ; (; double ; progress, . TString ; text . ). inlinevirtual . Parameters. textadvance on the progress bar; progressthe new value; texta label . Definition at line 799 of file NeuralNet.h. ◆ drawSample(). virtual void TMVA::DNN::Settings::drawSample ; (; const std::vector< double > & ; , . const std::vector< double > & ; , . const std::vector< double > & ; , . double ;  . ). inlinevirtual . callback for monitoring and logging ; Definition at line 807 of file NeuralNet.h. ◆ dropFractions(). const std::vector< double > & TMVA::DNN::Settings::dropFractions ; (; ); const. inline . Definition at line 762 of file NeuralNet.h. ◆ dropRepetitions(). size_t TMVA::DNN::Settings::dropRepetitions ; (; ); const. inline . Definition at line 761 of file NeuralNet.h. ◆ endTestCycle(). virtual void TMVA::DNN::Settings::endTestCycle ; (; ). inlinevirtual . callback for monitoring and loggging ; Reimplemented in TMVA::DNN::ClassificationSettings.; Definition at line 805 of file NeuralNet.h. ◆ endTrainCycle(). virtual void TMVA::DNN::Settings::endTrainCycle ; (; double ; ). inlinevirtual . callback for monitoring",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html:7357,progress bar,progress bar,7357,doc/master/classTMVA_1_1DNN_1_1Settings.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html,1,['progress bar'],['progress bar']
Usability,"f file TGFont.h. ◆ DistanceToText(). Int_t TGTextLayout::DistanceToText ; (; Int_t ; x, . Int_t ; y . ); const. Computes the distance in pixels from the given point to the given text layout. ; Non-displaying space characters that occur at the end of individual lines in the text layout are ignored for hit detection purposes.; The return value is 0 if the point (x, y) is inside the text layout. If the point isn't inside the text layout then the return value is the distance in pixels from the point to the text item.; x, y – Coordinates of point to check, with respect to the upper-left corner of the text layout (in pixels). ; Definition at line 1191 of file TGFont.cxx. ◆ DrawText(). void TGTextLayout::DrawText ; (; Drawable_t ; dst, . GContext_t ; gc, . Int_t ; x, . Int_t ; y, . Int_t ; firstChar, . Int_t ; lastChar . ); const. Use the information in the TGTextLayout object to display a multi-line, justified string of text. ; This procedure is useful for simple widgets that need to display single-font, multi-line text and want TGFont to handle the details.; dst – Window or pixmap in which to draw. gc – Graphics context to use for drawing text. x, y – Upper-left hand corner of rectangle in which to draw (pixels). firstChar – The index of the first character to draw from the given text item. 0 specfies the beginning. lastChar – The index just after the last character to draw from the given text item. A number < 0 means to draw all characters. ; Definition at line 923 of file TGFont.cxx. ◆ IntersectText(). Int_t TGTextLayout::IntersectText ; (; Int_t ; x, . Int_t ; y, . Int_t ; w, . Int_t ; h . ); const. Determines whether a text layout lies entirely inside, entirely outside, or overlaps a given rectangle. ; Non-displaying space characters that occur at the end of individual lines in the text layout are ignored for intersection calculations.; The return value is -1 if the text layout is entirely outside of the rectangle, 0 if it overlaps, and 1 if it is entirely inside of t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGTextLayout.html:15343,simpl,simple,15343,doc/master/classTGTextLayout.html,https://root.cern,https://root.cern/doc/master/classTGTextLayout.html,1,['simpl'],['simple']
Usability,"f file TGProgressBar.h. ◆ DeclFileName(). static const char * TGHProgressBar::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 118 of file TGProgressBar.h. ◆ DoRedraw(). void TGHProgressBar::DoRedraw ; (; ). overrideprotectedvirtual . Draw horizontal progress bar. ; Implements TGProgressBar.; Definition at line 265 of file TGProgressBar.cxx. ◆ GetDefaultSize(). TGDimension TGHProgressBar::GetDefaultSize ; (; ); const. inlineoverridevirtual . std::cout << fWidth << ""x"" << fHeight << std::endl; ; Reimplemented from TGFrame.; Definition at line 110 of file TGProgressBar.h. ◆ IsA(). TClass * TGHProgressBar::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGFrame.; Definition at line 118 of file TGProgressBar.h. ◆ SavePrimitive(). void TGHProgressBar::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a horizontal progress bar as a C++ statement(s) on output stream out. ; Reimplemented from TGFrame.; Definition at line 464 of file TGProgressBar.cxx. ◆ ShowPosition(). void TGHProgressBar::ShowPosition ; (; Bool_t ; set = kTRUE, . Bool_t ; percent = kTRUE, . const char * ; format = ""%.2f"" . ). Show postion text, either in percent or formatted according format. ; Definition at line 253 of file TGProgressBar.cxx. ◆ Streamer(). void TGHProgressBar::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TGFrame. ◆ StreamerNVirtual(). void TGHProgressBar::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 118 of file TGProgressBar.h. Libraries for TGHProgressBar:. [legend]; The documentation for this class was generated from the following files:; gui/gui/inc/TGProgressBar.h; gui/gui/src/TGProgressBar.cxx. TGHProgressBar. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:43:16 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGHProgressBar.html:33775,progress bar,progress bar,33775,doc/master/classTGHProgressBar.html,https://root.cern,https://root.cern/doc/master/classTGHProgressBar.html,1,['progress bar'],['progress bar']
Usability,"f file TGSplitFrame.cxx. ◆ Undocked(). void TGSplitFrame::Undocked ; (; TGFrame * ; frame). Emit Undocked() signal. ; Definition at line 711 of file TGSplitFrame.cxx. ◆ UnSplit(). void TGSplitFrame::UnSplit ; (; const char * ; which). Close (unmap and remove from the list of frames) the frame contained in this split frame. ; Definition at line 720 of file TGSplitFrame.cxx. ◆ VSplit(). void TGSplitFrame::VSplit ; (; UInt_t ; w = 0). virtual . Vertically split the frame. ; Definition at line 452 of file TGSplitFrame.cxx. Member Data Documentation. ◆ fFirst. TGSplitFrame* TGSplitFrame::fFirst. protected . Pointer to the first child (if any) ; Definition at line 87 of file TGSplitFrame.h. ◆ fFrame. TGFrame* TGSplitFrame::fFrame. protected . Pointer to the embedded frame (if any) ; Definition at line 84 of file TGSplitFrame.h. ◆ fHRatio. Float_t TGSplitFrame::fHRatio. protected . Height ratio between the first child and this. ; Definition at line 91 of file TGSplitFrame.h. ◆ fSecond. TGSplitFrame* TGSplitFrame::fSecond. protected . Pointer to the second child (if any) ; Definition at line 88 of file TGSplitFrame.h. ◆ fSplitter. TGSplitter* TGSplitFrame::fSplitter. protected . Pointer to the (H/V) Splitter (if any) ; Definition at line 86 of file TGSplitFrame.h. ◆ fSplitTool. TGSplitTool* TGSplitFrame::fSplitTool. protected . SplitFrame Tool. ; Definition at line 89 of file TGSplitFrame.h. ◆ fUndocked. TGTransientFrame* TGSplitFrame::fUndocked. protected . Main frame used when ""undocking"" frame. ; Definition at line 85 of file TGSplitFrame.h. ◆ fWRatio. Float_t TGSplitFrame::fWRatio. protected . Width ratio between the first child and this. ; Definition at line 90 of file TGSplitFrame.h. Libraries for TGSplitFrame:. [legend]; The documentation for this class was generated from the following files:; gui/gui/inc/TGSplitFrame.h; gui/gui/src/TGSplitFrame.cxx. TGSplitFrame. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:43:35 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGSplitFrame.html:42447,undo,undocking,42447,doc/master/classTGSplitFrame.html,https://root.cern,https://root.cern/doc/master/classTGSplitFrame.html,1,['undo'],['undocking']
Usability,"f file TUnfoldSys.cxx. ◆ GetDeltaSysTau(). Bool_t TUnfoldSys::GetDeltaSysTau ; (; TH1 * ; hist_delta, . const Int_t * ; binMap = nullptr . ). correlated one-sigma shifts from shifting tau ; Parameters. [out]hist_deltahistogram to store shifts ; [in]sourceidentifier of the background source ; [in]binMap(default=nullptr) remapping of histogram bins. returns true if the background source was found. ; This method returns the shifts of the unfolding result induced by varying the normalisation of the identified background by one sigma. ; the array binMap is explained with the method GetOutput(). ; Definition at line 1086 of file TUnfoldSys.cxx. ◆ GetEmatrixFromVyy(). void TUnfoldSys::GetEmatrixFromVyy ; (; const TMatrixDSparse * ; vyy, . TH2 * ; ematrix, . const Int_t * ; binMap, . Bool_t ; clearEmat . ). protected . propagate an error matrix on the input vector to the unfolding result ; Parameters. [in]vyyinput error matrix ; [in,out]ematrixhistogram to be updated ; [in]binMapmapping of histogram bins ; [in]clearEmatif set, clear histogram before adding this covariance contribution . Definition at line 1250 of file TUnfoldSys.cxx. ◆ GetEmatrixInput(). void TUnfoldSys::GetEmatrixInput ; (; TH2 * ; ematrix, . const Int_t * ; binMap = nullptr, . Bool_t ; clearEmat = kTRUE . ). covariance matrix contribution from input measurement uncertainties ; Parameters. [in,out]ematrixoutput histogram ; [in]binMap(default=nullptr) remapping of histogram bins ; [in]clearEmat(default=true) if true, clear the histogram. this method returns the covariance contributions to the unfolding result from the uncertainties or covariance of the input data. In many cases, these are the ""statistical uncertainties"". ; The array binMap is explained with the method GetOutput(). The flag clearEmat may be used to add covariance matrices from several uncertainty sources. ; Definition at line 1207 of file TUnfoldSys.cxx. ◆ GetEmatrixSysBackgroundScale(). void TUnfoldSys::GetEmatrixSysBackgroundScale ; (; TH2 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldSys.html:37381,clear,clearEmatif,37381,doc/master/classTUnfoldSys.html,https://root.cern,https://root.cern/doc/master/classTUnfoldSys.html,2,['clear'],"['clear', 'clearEmatif']"
Usability,"f file Timer.h. ◆ Reset(). void TMVA::Timer::Reset ; (; void ; ). resets timer ; Definition at line 127 of file Timer.cxx. ◆ SecToText(). TString TMVA::Timer::SecToText ; (; Double_t ; seconds, . Bool_t ; Scientific . ); const. private . pretty string output ; Definition at line 262 of file Timer.cxx. ◆ Streamer(). virtual void TMVA::Timer::Streamer ; (; TBuffer & ; R__b). virtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TMVA::Timer::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 99 of file Timer.h. Member Data Documentation. ◆ fColourfulOutput. Bool_t TMVA::Timer::fColourfulOutput. private . flag for use of colors ; Definition at line 84 of file Timer.h. ◆ fgClassName. const TString TMVA::Timer::fgClassName = ""Timer"". staticprivate . used for output ; Definition at line 93 of file Timer.h. ◆ fgNbins. const Int_t TMVA::Timer::fgNbins = 16. staticprivate . number of bins in progress bar ; Definition at line 94 of file Timer.h. ◆ fLogger. MsgLogger* TMVA::Timer::fLogger. mutableprivate . ! the output logger ; Definition at line 96 of file Timer.h. ◆ fNcounts. Int_t TMVA::Timer::fNcounts. private . reference number of ""counts"" ; Definition at line 82 of file Timer.h. ◆ fOutputToFile. Bool_t TMVA::Timer::fOutputToFile. private . Definition at line 89 of file Timer.h. ◆ fPrefix. TString TMVA::Timer::fPrefix. private . prefix for outputs ; Definition at line 83 of file Timer.h. ◆ fPreviousProgress. Int_t TMVA::Timer::fPreviousProgress. private . Definition at line 87 of file Timer.h. ◆ fPreviousTimeEstimate. TString TMVA::Timer::fPreviousTimeEstimate. private . Definition at line 88 of file Timer.h. ◆ fProgressBarStringLength. Int_t TMVA::Timer::fProgressBarStringLength. private . Definition at line 91 of file Timer.h. Libraries for TMVA::Timer:. [legend]; The documentation for this class was generated from the following files:; tmva/tmva/inc/TMVA/Timer.h; tmva/tmva/src/Timer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Timer.html:17355,progress bar,progress bar,17355,doc/master/classTMVA_1_1Timer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Timer.html,1,['progress bar'],['progress bar']
Usability,"f getting batches of events from a ROOT dataset as Python generators of numpy arrays. ;  ; file  RBatchGenerator_PyTorch.py;   Example of getting batches of events from a ROOT dataset into a basic PyTorch workflow. ;  ; file  RBatchGenerator_TensorFlow.py;   Example of getting batches of events from a ROOT dataset into a basic TensorFlow workflow. ;  ; file  tmva001_RTensor.C;   This tutorial illustrates the basic features of the RTensor class, RTensor is a std::vector-like container with additional shape information. ;  ; file  tmva002_RDataFrameAsTensor.C;   This tutorial shows how the content of an RDataFrame can be converted to an RTensor object. ;  ; file  tmva003_RReader.C;   This tutorial shows how to apply with the modern interfaces models saved in TMVA XML files. ;  ; file  tmva004_RStandardScaler.C;   This tutorial illustrates the usage of the standard scaler as preprocessing method. ;  ; file  tmva100_DataPreparation.py;   This tutorial illustrates how to prepare ROOT datasets to be nicely readable by most machine learning methods. ;  ; file  tmva101_Training.py;   This tutorial show how you can train a machine learning model with any package reading the training data directly from ROOT files. ;  ; file  tmva102_Testing.py;   This tutorial illustrates how you can test a trained BDT model using the fast tree inference engine offered by TMVA and external tools such as scikit-learn. ;  ; file  tmva103_Application.C;   This tutorial illustrates how you can conveniently apply BDTs in C++ using the fast tree inference engine offered by TMVA. ;  ; file  TMVA_CNN_Classification.C;   TMVA Classification Example Using a Convolutional Neural Network ;  ; file  TMVA_CNN_Classification.py;   TMVA Classification Example Using a Convolutional Neural Network ;  ; file  TMVA_Higgs_Classification.C;   Classification example of TMVA based on public Higgs UCI dataset ;  ; file  TMVA_Higgs_Classification.py;   Classification example of TMVA based on public Higgs UCI dataset ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__tmva.html:1611,learn,learning,1611,doc/master/group__tutorial__tmva.html,https://root.cern,https://root.cern/doc/master/group__tutorial__tmva.html,1,['learn'],['learning']
Usability,"f index is not in the list range. Int_t GetIndex(Long64_t entry) const; Return index in the list of element with value entry; array is supposed to be sorted prior to this call.; If match is found, function returns position of element.; If no match found, function returns -1. void Intersect(const TEventList* list); Remove elements from this list that are NOT present in alist. Int_t Merge(TCollection* list); Merge entries in all the TEventList in the collection in this event list. void Print(Option_t* option = """") const; Print contents of this list. void Reset(Option_t* option = """"); Reset number of entries in event list. void Resize(Int_t delta = 0); Resize list by delta entries. void SetDirectory(TDirectory* dir); Remove reference to this EventList from current directory and add; reference to new directory dir. dir can be 0 in which case the list; does not belong to any directory. void SetName(const char* name); Change the name of this TEventList. void Sort(); Sort list entries in increasing order. void Streamer(TBuffer& b); Stream an object of class TEventList. void Subtract(const TEventList* list); Remove elements from this list that are present in alist. TEventList& operator=(const TEventList& list); Assingment. void Clear(Option_t* option = """"); {Reset(option);}. TDirectory * GetDirectory() const; {return fDirectory;}. Long64_t * GetList() const; { return fList; }. Int_t GetN() const; { return fN; }. Bool_t GetReapplyCut() const; { return fReapply; }. Int_t GetSize() const; { return fSize; }. void SetDelta(Int_t delta = 100); {fDelta = delta;}. void SetReapplyCut(Bool_t apply = kFALSE); {fReapply = apply;}. » Author: Rene Brun 11/02/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TEventList.h 22992 2008-04-05 09:43:01Z pcanal $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEventList.html:10091,Clear,Clear,10091,root/html532/TEventList.html,https://root.cern,https://root.cern/root/html532/TEventList.html,1,['Clear'],['Clear']
Usability,"f parameters for a polynom. ; Definition at line 1679 of file TGraph.cxx. ◆ InsertPoint(). Int_t TGraph::InsertPoint ; (; ). virtual . Insert a new point at the mouse position. ; Definition at line 1699 of file TGraph.cxx. ◆ InsertPointBefore(). void TGraph::InsertPointBefore ; (; Int_t ; ipoint, . Double_t ; x, . Double_t ; y . ). virtual . Insert a new point with coordinates (x,y) before the point number ipoint. ; Definition at line 1749 of file TGraph.cxx. ◆ Integral(). Double_t TGraph::Integral ; (; Int_t ; first = 0, . Int_t ; last = -1 . ); const. virtual . Integrate the TGraph data within a given (index) range. ; Note that this function computes the area of the polygon enclosed by the points of the TGraph. The polygon segments, which are defined by the points of the TGraph, do not need to form a closed polygon, since the last polygon segment, which closes the polygon, is taken as the line connecting the last TGraph point with the first one. It is clear that the order of the point is essential in defining the polygon. Also note that the segments should not intersect.; NB:; if last=-1 (default) last is set to the last point.; if (first <0) the first point (0) is taken. Method:; There are many ways to calculate the surface of a polygon. It all depends on what kind of data you have to deal with. The most evident solution would be to divide the polygon in triangles and calculate the surface of them. But this can quickly become complicated as you will have to test every segments of every triangles and check if they are intersecting with a current polygon's segment or if it goes outside the polygon. Many calculations that would lead to many problems... The solution (implemented by R.Brun); Fortunately for us, there is a simple way to solve this problem, as long as the polygon's segments don't intersect. It takes the x coordinate of the current vertex and multiply it by the y coordinate of the next vertex. Then it subtracts from it the result of the y coordinate of t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraph.html:61350,clear,clear,61350,doc/master/classTGraph.html,https://root.cern,https://root.cern/doc/master/classTGraph.html,1,['clear'],['clear']
Usability,"f parameters. void setCovarianceMatrix(TMatrixDSym& V); Store externally provided correlation matrix in this RooFitResult ;. TH2* correlationHist(const char* name = ""correlation_matrix"") const; Return TH2D of correlation matrix. const TMatrixDSym& covarianceMatrix() const; Return covariance matrix. TMatrixDSym reducedCovarianceMatrix(const RooArgList& params) const; Return a reduced covariance matrix (Note that Vred _is_ a simple sub-matrix of V,; row/columns are ordered to matched the convention given in input argument 'params'. TMatrixDSym conditionalCovarianceMatrix(const RooArgList& params) const; Return a reduced covariance matrix, which is calculated as; ___ -1; Vred = V22 = V11 - V12 * V22 * V21. Where V11,V12,V21,V22 represent a block decomposition of the covariance matrix into observables that; are propagated (labeled by index '1') and that are not propagated (labeled by index '2'), and V22bar; is the Shur complement of V22, calculated as shown above. (Note that Vred is _not_ a simple sub-matrix of V). const TMatrixDSym& correlationMatrix() const; Return correlation matrix ;. RooAbsPdf* createHessePdf(const RooArgSet& params) const; Return a p.d.f that represents the fit result as a multi-variate probability densisty; function on the floating fit parameters, including correlations. void SetName(const char* name); Change name of RooFitResult object. void SetNameTitle(const char* name, const char* title); Change name and title of RooFitResult object. void printName(ostream& os) const; Print name of fit result. void printTitle(ostream& os) const; Print title of fit result. void printClassName(ostream& os) const; Print class name of fit result. void printArgs(ostream& os) const; Print arguments of fit result, i.e. the parameters of the fit. void printValue(ostream& os) const; Print the value of the fit result, i.e.g the status, minimized FCN, edm and covariance quality code. Int_t defaultPrintContents(Option_t* opt) const; Configure default contents to be print",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFitResult.html:16540,simpl,simple,16540,root/html602/RooFitResult.html,https://root.cern,https://root.cern/root/html602/RooFitResult.html,4,['simpl'],['simple']
Usability,"f selected branches, and recheck if pos is now in the list. Returns:; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache. This function overloads TFileCacheRead::ReadBuffer. . Reimplemented from TFileCacheRead.; Definition at line 2027 of file TTreeCache.cxx. ◆ ReadBufferNormal(). Int_t TTreeCache::ReadBufferNormal ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). virtual . Old method ReadBuffer before the addition of the prefetch mechanism. ; Definition at line 1927 of file TTreeCache.cxx. ◆ ReadBufferPrefetch(). Int_t TTreeCache::ReadBufferPrefetch ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). virtual . Used to read a chunk from a block previously fetched. ; It will call FillBuffer even if the cache lookup succeeds, because it will try to prefetch the next block as soon as we start reading from the current block. ; Definition at line 1986 of file TTreeCache.cxx. ◆ ResetCache(). void TTreeCache::ResetCache ; (; ). virtual . This will simply clear the cache. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2040 of file TTreeCache.cxx. ◆ ResetMissCache(). void TTreeCache::ResetMissCache ; (; ). Reset all the miss cache training. ; The contents of the miss cache will be emptied as well as the list of branches used. ; Definition at line 697 of file TTreeCache.cxx. ◆ SetAutoCreated(). void TTreeCache::SetAutoCreated ; (; bool ; val). inline . Definition at line 164 of file TTreeCache.h. ◆ SetBufferSize(). Int_t TTreeCache::SetBufferSize ; (; Int_t ; buffersize). overridevirtual . Change the underlying buffer size of the cache. ; If the change of size means some cache content is lost, or if the buffer is now larger, setup for a cache refill the next time there is a read Returns:; 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 2072 of file TTreeCache.cxx. ◆",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:47673,simpl,simply,47673,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,"['clear', 'simpl']","['clear', 'simply']"
Usability,"f selected branches, and recheck if pos is now in the list. Returns:; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache. This function overloads TFileCacheRead::ReadBuffer. . Reimplemented from TFileCacheRead.; Definition at line 2027 of file TTreeCache.cxx. ◆ ReadBufferNormal(). Int_t TTreeCache::ReadBufferNormal ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). virtual . Old method ReadBuffer before the addition of the prefetch mechanism. ; Definition at line 1927 of file TTreeCache.cxx. ◆ ReadBufferPrefetch(). Int_t TTreeCache::ReadBufferPrefetch ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). virtual . Used to read a chunk from a block previously fetched. ; It will call FillBuffer even if the cache lookup succeeds, because it will try to prefetch the next block as soon as we start reading from the current block. ; Definition at line 1986 of file TTreeCache.cxx. ◆ ResetCache(). void TTreeCache::ResetCache ; (; ). virtual . This will simply clear the cache. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2040 of file TTreeCache.cxx. ◆ ResetMissCache(). void TTreeCache::ResetMissCache ; (; ). Reset all the miss cache training. ; The contents of the miss cache will be emptied as well as the list of branches used. ; Definition at line 697 of file TTreeCache.cxx. ◆ SetAutoCreated(). void TTreeCache::SetAutoCreated ; (; bool ; val). inline . Definition at line 164 of file TTreeCache.h. ◆ SetBufferSize(). Int_t TTreeCache::SetBufferSize ; (; Long64_t ; buffersize). overridevirtual . Change the underlying buffer size of the cache. ; If the change of size means some cache content is lost, or if the buffer is now larger, setup for a cache refill the next time there is a read Buffersize might be clamped, see TFileCacheRead::SetBufferSize Returns:; 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error . Reimplemented from TFileCacheRead.; Reimplemented in T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:47677,simpl,simply,47677,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,2,"['clear', 'simpl']","['clear', 'simply']"
Usability,"f struct SSL SSL; /* dummy for SSL argument to push/pull */; 1739typedef struct SSL_CTX SSL_CTX;; 1740 ; 1741#elif defined(NO_SSL_DL); 1742/* OpenSSL without dynamic loading */; 1743#include <openssl/bn.h>; 1744#include <openssl/conf.h>; 1745#include <openssl/crypto.h>; 1746#include <openssl/dh.h>; 1747#include <openssl/err.h>; 1748#include <openssl/opensslv.h>; 1749#include <openssl/pem.h>; 1750#include <openssl/ssl.h>; 1751#include <openssl/tls1.h>; 1752#include <openssl/x509.h>; 1753 ; 1754#if defined(WOLFSSL_VERSION); 1755/* Additional defines for WolfSSL, see; 1756 * https://github.com/civetweb/civetweb/issues/583 */; 1757#include ""wolfssl_extras.inl""; 1758#endif; 1759 ; 1760#if defined(OPENSSL_IS_BORINGSSL); 1761/* From boringssl/src/include/openssl/mem.h:; 1762 *; 1763 * OpenSSL has, historically, had a complex set of malloc debugging options.; 1764 * However, that was written in a time before Valgrind and ASAN. Since we now; 1765 * have those tools, the OpenSSL allocation functions are simply macros around; 1766 * the standard memory functions.; 1767 *; 1768 * #define OPENSSL_free free */; 1769#define free free; 1770// disable for boringssl; 1771#define CONF_modules_unload(a) ((void)0); 1772#define ENGINE_cleanup() ((void)0); 1773#endif; 1774 ; 1775/* If OpenSSL headers are included, automatically select the API version */; 1776#if (OPENSSL_VERSION_NUMBER >= 0x30000000L); 1777#if !defined(OPENSSL_API_3_0); 1778#define OPENSSL_API_3_0; 1779#endif; 1780#define OPENSSL_REMOVE_THREAD_STATE(); 1781#else; 1782#if (OPENSSL_VERSION_NUMBER >= 0x10100000L); 1783#if !defined(OPENSSL_API_1_1); 1784#define OPENSSL_API_1_1; 1785#endif; 1786#define OPENSSL_REMOVE_THREAD_STATE(); 1787#else; 1788#if !defined(OPENSSL_API_1_0); 1789#define OPENSSL_API_1_0; 1790#endif; 1791#define OPENSSL_REMOVE_THREAD_STATE() ERR_remove_thread_state(NULL); 1792#endif; 1793#endif; 1794 ; 1795 ; 1796#else; 1797/* SSL loaded dynamically from DLL / shared object */; 1798/* Add all prototypes here,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:54194,simpl,simply,54194,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['simpl'],['simply']
Usability,"f the file.; 829///; 830/// - The buffer is written to the file.; 831///; 832/// Bufsize can be given to force a given buffer size to write this object.; 833/// By default, the buffersize will be taken from the average buffer size; 834/// of all objects written to the current file so far.; 835///; 836/// If a name is specified, it will be the name of the key.; 837/// If name is not given, the name of the key will be the name as returned; 838/// by GetName().; 839///; 840/// The option can be a combination of: kSingleKey, kOverwrite or kWriteDelete; 841/// Using the kOverwrite option a previous key with the same name is; 842/// overwritten. The previous key is deleted before writing the new object.; 843/// Using the kWriteDelete option a previous key with the same name is; 844/// deleted only after the new object has been written. This option; 845/// is safer than kOverwrite but it is slower.; 846/// NOTE: Neither kOverwrite nor kWriteDelete reduces the size of a TFile--; 847/// the space is simply freed up to be overwritten; in the case of a TTree,; 848/// it is more complicated. If one opens a TTree, appends some entries,; 849/// then writes it out, the behaviour is effectively the same. If, however,; 850/// one creates a new TTree and writes it out in this way,; 851/// only the metadata is replaced, effectively making the old data invisible; 852/// without deleting it. TTree::Delete() can be used to mark all disk space; 853/// occupied by a TTree as free before overwriting its metadata this way.; 854/// The kSingleKey option is only used by TCollection::Write() to write; 855/// a container with a single key instead of each object in the container; 856/// with its own key.; 857///; 858/// An object is read from the file into memory via TKey::Read() or; 859/// via TObject::Read().; 860///; 861/// The function returns the total number of bytes written to the file.; 862/// It returns 0 if the object cannot be written.; 863 ; 864Int_t TObject::Write(const char *name, I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TObject_8cxx_source.html:30885,simpl,simply,30885,doc/master/TObject_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html,1,['simpl'],['simply']
Usability,"f the ged-editor; TGeoTabManager*TGeoGedFrame::fTabMgrtab manager corresponding to ged-editor; TGTextButton*TGeoTubeEditor::fUndoUndo-Button; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTubeSegEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for tube segment editor. ~TGeoTubeSegEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. void DoPhi1(); Slot for phi1. void DoPhi2(); Slot for phi2. void DoPhi(); Slot for phi slider. void DoApply(); Slot for applying modifications. void DoUndo(); Slot for undoing last operation. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTubeSegEditor.html:21938,undo,undoing,21938,root/html534/TGeoTubeSegEditor.html,https://root.cern,https://root.cern/root/html534/TGeoTubeSegEditor.html,2,['undo'],['undoing']
Usability,"f the same class to a single slot. ;  ; static Bool_t Connect (TQObject *sender, const char *signal, const char *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  ; static const char * DeclFileName ();  ; static Bool_t Disconnect (const char *class_name, const char *signal, void *receiver=nullptr, const char *slot=nullptr);  Disconnects ""class signal"". ;  ; static Bool_t Disconnect (TQObject *sender, const char *signal=nullptr, void *receiver=nullptr, const char *slot=nullptr);  Disconnects signal in object sender from slot_method in object receiver. ;  . Protected Member Functions; TProof * GetProof () const;  ; Bool_t HandleTimer (TTimer *timer) override;  Send feedback objects to client. ;  ; Int_t InitPacketizer (TDSet *dset, Long64_t nentries, Long64_t first, const char *defpackunit, const char *defpackdata);  Init the packetizer Return 0 on success (fPacketizer is correctly initialized), -1 on failure. ;  ; TList * MergeFeedback ();  Merge feedback lists. ;  ; Bool_t MergeOutputFiles ();  Merge output in files. ;  ; void NotifyMemory (TObject *obj);  Printout the memory record after merging object 'obj' This record is used by the memory monitor. ;  ; virtual Bool_t SendSelector (const char *selector_file);  Send the selector file(s) to master or worker nodes. ;  ; void SetLastMergingMsg (TObject *obj);  Set the message to be notified in case of exception. ;  ; void SetSelectorDataMembersFromOutputList ();  Set the selector's data members: find the mapping of data members to otuput list entries in the output list and apply it. ;  ; void SetupFeedback () override;  Setup reporting of feedback objects. ;  ; void StopFeedback () override;  Stop reporting of feedback objects. ;  ;  Protected Member Functions inherited from TProofPlayer; Int_t AssertSelector (const char *selector_file);  Make sure that a valid selector object Return -1 in case of problems, 0 otherwise. ;  ; Bool_t CheckMemUsage (Long64_t &mfreq, Bo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerRemote.html:19690,feedback,feedback,19690,doc/master/classTProofPlayerRemote.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerRemote.html,1,['feedback'],['feedback']
Usability,"f the values in the first line do not use the /[type] syntax, all variables are assumed to be of type ""F"". If the filename ends with extensions .csv or .CSV and a delimiter is not specified (besides ' '), the delimiter is automatically set to ','.; Lines in the input file starting with ""#"" are ignored. Leading whitespace for each column data is skipped. Empty lines are skipped.; A TBranch object is created for each variable in the expression. The total number of rows read from the file is returned. FILLING a TTree WITH MULTIPLE INPUT TEXT FILES; To fill a TTree with multiple input text files, proceed as indicated above for the first input file and omit the second argument for subsequent calls T.ReadFile(""file1.dat"",""branch descriptor"");; T.ReadFile(""file2.dat"");. Definition at line 7564 of file TTree.cxx. ◆ ReadStream(). Long64_t TTree::ReadStream ; (; std::istream & ; inputStream, . const char * ; branchDescriptor = """", . char ; delimiter = ' ' . ). virtual . Create or simply read branches from an input stream. ; See alsoreference information for TTree::ReadFile ; Reimplemented in TNtuple, and TNtupleD.; Definition at line 7615 of file TTree.cxx. ◆ RecursiveRemove(). void TTree::RecursiveRemove ; (; TObject * ; obj). overridevirtual . Make sure that obj (which is being deleted or will soon be) is no longer referenced by this TTree. ; Reimplemented from TObject.; Definition at line 7881 of file TTree.cxx. ◆ Refresh(). void TTree::Refresh ; (; ). virtual . Refresh contents of this tree and its branches from the current status on disk. ; One can call this function in case the tree file is being updated by another process. ; Reimplemented in TTreeSQL.; Definition at line 7916 of file TTree.cxx. ◆ RegisterExternalFriend(). void TTree::RegisterExternalFriend ; (; TFriendElement * ; fe). virtual . Record a TFriendElement that we need to warn when the chain switches to a new file (typically this is because this chain is a friend of another TChain) ; Definition at line 7957 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:195157,simpl,simply,195157,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['simpl'],['simply']
Usability,"f undo method Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");; For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color; ; com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);; Color_tshort Color_tDefinition RtypesCore.h:85; TQCommand::SetRedoArgsvirtual void SetRedoArgs(Int_t nargs,...)Set redo parameters.Definition TQCommand.cxx:508; TQCommand::SetUndoArgsvirtual void SetUndoArgs(Int_t nargs,...)Set undo parameters.Definition TQCommand.cxx:542; 1st argument - the number of undo, redo parameters the other arguments - undo, redo values Since the number of undo,redo parameters is the same one can use com->SetArgs(1, new_color, old_color);; TQCommand::SetArgsvirtual void SetArgs(Int_t nargs,...)Set do/redo and undo parameters.Definition TQCommand.cxx:465. Undo, redo method execution com->Redo(); // execute redo method; com->Undo(); // execute undo method; TQCommand::Undovirtual void Undo(Option_t *option="""")Un-execute all merged commands and the command.Definition TQCommand.cxx:626; TQCommand::Redovirtual void Redo(Option_t *option="""")Execute command and then merge commands.Definition TQCommand.cxx:588. Merged commands It possible to group several commands together so an end user can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);; updatestatic void update(gsl_integration_workspace *workspace, double a1, double b1, double area1, double error1, double a2, double b2, double area2, double error2)Definition RooAdaptiveGaussKronrodIntegrator1D.cxx:633; gPad#define gPadDefinition TVirtualPad.h:308; TQCommand::Addvoid Add(TObject *obj, Option_t *opt) overrideAdd command to the list of merged commands.Definition TQCommand.cxx:360. Macro ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:2493,undo,undo,2493,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['undo'],['undo']
Usability,"f which the integral is requested. ; For certain operator p.d.f it is useful to overload this function rather than analyticalIntegralWN() as the additional normalization information may be useful in determining a more efficient decomposition of the requested integral. ; Reimplemented from RooAbsReal.; Definition at line 2361 of file RooProdPdf.cxx. ◆ initialize(). void RooFixedProdPdf::initialize ; (; ). inlineprivate . Definition at line 2380 of file RooProdPdf.cxx. ◆ selfNormalized(). bool RooFixedProdPdf::selfNormalized ; (; ); const. inlineoverridevirtual . Shows if a PDF is self-normalized, which means that no attempt is made to add a normalization term. ; Always returns false, unless a PDF overrides this function. ; Reimplemented from RooAbsPdf.; Definition at line 2334 of file RooProdPdf.cxx. ◆ translate(). void RooFixedProdPdf::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. inlineoverridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 2343 of file RooProdPdf.cxx. Member Data Documentation. ◆ _cache. std::unique_ptr<RooProdPdf::CacheElem> RooFixedProdPdf::_cache. private . Definition at line 2401 of file RooProdPdf.cxx. ◆ _normSet. RooArgSet RooFixedProdPdf::_normSet. private . Definition at line 2400 of file RooProdPdf.cxx. ◆ _prodPdf. std::unique_ptr<RooProdPdf> RooFixedProdPdf::_prodPdf. private . Definition at line 2403 of file RooProdPdf.cxx. ◆ _servers",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFixedProdPdf.html:79305,simpl,simple,79305,doc/master/classRooFixedProdPdf.html,https://root.cern,https://root.cern/doc/master/classRooFixedProdPdf.html,1,['simpl'],['simple']
Usability,"f with cache-and-track. ; Reimplemented from RooAbsArg.; Definition at line 680 of file RooRealSumPdf.cxx. ◆ setExtended(). void RooRealSumPdf::setExtended ; (; bool ; extended). inlineprivate . Definition at line 136 of file RooRealSumPdf.h. ◆ setFloor(). void RooRealSumPdf::setFloor ; (; bool ; flag). inline . Definition at line 62 of file RooRealSumPdf.h. ◆ setFloorGlobal(). static void RooRealSumPdf::setFloorGlobal ; (; bool ; flag). inlinestatic . Definition at line 64 of file RooRealSumPdf.h. ◆ Streamer(). void RooRealSumPdf::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsPdf. ◆ StreamerNVirtual(). void RooRealSumPdf::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 138 of file RooRealSumPdf.h. ◆ translate(). void RooRealSumPdf::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 331 of file RooRealSumPdf.cxx. ◆ translateImpl(). std::string RooRealSumPdf::translateImpl ; (; RooFit::Detail::CodeSquashContext & ; ctx, . RooAbsArg const * ; klass, . RooArgList const & ; funcList, . RooArgList const & ; coefList, . bool ; normalize = false . ). staticprivate . Definition at line 300 of file RooRealSumPdf.cxx. Friends And Related Symbol Documentation. ◆ RooAddition. friend class RooAddition. friend . Defini",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealSumPdf.html:91025,simpl,simple,91025,doc/master/classRooRealSumPdf.html,https://root.cern,https://root.cern/doc/master/classRooRealSumPdf.html,1,['simpl'],['simple']
Usability,"f with cache-and-track. ; Reimplemented from RooAbsArg.; Definition at line 687 of file RooRealSumPdf.cxx. ◆ setExtended(). void RooRealSumPdf::setExtended ; (; bool ; extended). inlineprivate . Definition at line 136 of file RooRealSumPdf.h. ◆ setFloor(). void RooRealSumPdf::setFloor ; (; bool ; flag). inline . Definition at line 62 of file RooRealSumPdf.h. ◆ setFloorGlobal(). static void RooRealSumPdf::setFloorGlobal ; (; bool ; flag). inlinestatic . Definition at line 64 of file RooRealSumPdf.h. ◆ Streamer(). void RooRealSumPdf::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsPdf. ◆ StreamerNVirtual(). void RooRealSumPdf::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 138 of file RooRealSumPdf.h. ◆ translate(). void RooRealSumPdf::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 333 of file RooRealSumPdf.cxx. ◆ translateImpl(). std::string RooRealSumPdf::translateImpl ; (; RooFit::Detail::CodeSquashContext & ; ctx, . RooAbsArg const * ; klass, . RooArgList const & ; funcList, . RooArgList const & ; coefList, . bool ; normalize = false . ). staticprivate . Definition at line 302 of file RooRealSumPdf.cxx. Friends And Related Symbol Documentation. ◆ RooAddition. friend class RooAddition. friend . Defini",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooRealSumPdf.html:92146,simpl,simple,92146,doc/v632/classRooRealSumPdf.html,https://root.cern,https://root.cern/doc/v632/classRooRealSumPdf.html,1,['simpl'],['simple']
Usability,"f""Gaussian::gauss(x[-5,15], mu[0,4], {sigma})""); ws.factory(""Uniform::uniform(x)""); ws[""mu""].setVal(mu_observed); ws.Print(""v""); obs_data = ws[""gauss""].generate(ws[""x""], 1000); obs_data.SetName(""obs_data""); ws.Import(obs_data, Silence=True); ; return ws; ; ; # The ""observed"" data; mu_observed = 2.5; sigma = 1.5; workspace = build_ws(mu_observed, sigma); x_var = workspace[""x""]; mu_var = workspace[""mu""]; gauss = workspace[""gauss""]; uniform = workspace[""uniform""]; obs_data = workspace[""obs_data""]; ; # Training the model; model = SBI(workspace); model.model_data(""gauss"", ""x"", ""mu"", n_samples_train); model.reference_data(""uniform"", ""x"", n_samples_train); model.preprocessing(); model.train_classifier(); sbi_model = model; ; ; # Compute the likelihood ratio of the classifier for analysis purposes; def learned_likelihood_ratio(x, mu):; n = max(len(x), len(mu)); X = np.zeros((n, 2)); X[:, 0] = x; X[:, 1] = mu; prob = sbi_model.classifier.predict_proba(X)[:, 1]; return prob / (1 - prob); ; ; # Compute the learned likelihood ratio; llhr_learned = ROOT.RooFit.bindFunction(""MyBinFunc"", learned_likelihood_ratio, x_var, mu_var); ; # Compute the real likelihood ratio; llhr_calc = ROOT.RooFormulaVar(""llhr_calc"", ""x[0] / x[1]"", [gauss, uniform]); ; # Create the exact negative log likelihood functions for Gaussian model; nll_gauss = gauss.createNLL(obs_data); ROOT.SetOwnership(nll_gauss, True); ; # Create the learned pdf and NLL sum based on the learned likelihood ratio; pdf_learned = ROOT.RooWrapperPdf(""learned_pdf"", ""learned_pdf"", llhr_learned, True); ; nllr_learned = pdf_learned.createNLL(obs_data); ROOT.SetOwnership(nllr_learned, True); ; # Compute the morphed nll; morphing(ROOT.RooMomentMorphFuncND.Linear); nll_morph = workspace[""morph""].createNLL(obs_data); ROOT.SetOwnership(nll_morph, True); ; # Plot the negative logarithmic summed likelihood; frame1 = mu_var.frame(Title=""NLL of SBI vs. Morphing;mu;NLL"", Range=(2.2, 2.8)); nllr_learned.plotOn(frame1, LineColor=""kP6Blue"", ShiftT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf615__simulation__based__inference_8py.html:6561,learn,learned,6561,doc/master/rf615__simulation__based__inference_8py.html,https://root.cern,https://root.cern/doc/master/rf615__simulation__based__inference_8py.html,1,['learn'],['learned']
Usability,"f& other, const char* name) :; 261 RooAbsReal(other,name),; 262 _normMgr(other._normMgr,this), _selectComp(other._selectComp), _normRange(other._normRange); 263{; 264 resetErrorCounters() ;; 265 setTraceCounter(other._traceCount) ;; 266 ; 267 if (other._specGeneratorConfig) {; 268 _specGeneratorConfig = std::make_unique<RooNumGenConfig>(*other._specGeneratorConfig);; 269 }; 270}; 271 ; 272 ; 273 ; 274////////////////////////////////////////////////////////////////////////////////; 275/// Destructor; 276 ; 277RooAbsPdf::~RooAbsPdf(); 278{; 279}; 280 ; 281 ; 282double RooAbsPdf::normalizeWithNaNPacking(double rawVal, double normVal) const {; 283 ; 284 if (normVal < 0. || (normVal == 0. && rawVal != 0)) {; 285 //Unreasonable normalisations. A zero integral can be tolerated if the function vanishes, though.; 286 const std::string msg = ""p.d.f normalization integral is zero or negative: "" + std::to_string(normVal);; 287 logEvalError(msg.c_str());; 288 clearValueAndShapeDirty();; 289 return RooNaNPacker::packFloatIntoNaN(-normVal + (rawVal < 0. ? -rawVal : 0.));; 290 }; 291 ; 292 if (rawVal < 0.) {; 293 logEvalError(Form(""p.d.f value is less than zero (%f), trying to recover"", rawVal));; 294 clearValueAndShapeDirty();; 295 return RooNaNPacker::packFloatIntoNaN(-rawVal);; 296 }; 297 ; 298 if (TMath::IsNaN(rawVal)) {; 299 logEvalError(""p.d.f value is Not-a-Number"");; 300 clearValueAndShapeDirty();; 301 return rawVal;; 302 }; 303 ; 304 return (rawVal == 0. && normVal == 0.) ? 0. : rawVal / normVal;; 305}; 306 ; 307 ; 308////////////////////////////////////////////////////////////////////////////////; 309/// Return current value, normalized by integrating over; 310/// the observables in `nset`. If `nset` is 0, the unnormalized value; 311/// is returned. All elements of `nset` must be lvalues.; 312///; 313/// Unnormalized values are not cached.; 314/// Doing so would be complicated as `_norm->getVal()` could; 315/// spoil the cache and interfere with returning the cached; 316/",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:10952,clear,clearValueAndShapeDirty,10952,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['clear'],['clearValueAndShapeDirty']
Usability,"f("" Fn+Arrow_Right : move cursor to end of line [Ctrl+E]"");; 1310 #else; 1311 Printf("" End : move cursor to end of line [Ctrl+E]"");; 1312 #endif; 1313 Printf("" Ctrl+Arrow_Left : jump to previous word [Esc,B] [Alt,B]"" FOOTNOTE);; 1314 Printf("" Ctrl+Arrow_Right : jump to next word [Esc,F] [Alt,F]"" FOOTNOTE);; 1315 ; 1316 Printf("" Backspace : delete previous character [Ctrl+H]"");; 1317 Printf("" Del : delete next character [Ctrl+D]"");; 1318 Printf("" Esc,Backspace : delete previous word [Ctrl+W] [Esc,Ctrl+H] [Alt+Backspace] [Esc,Del] [Esc,Ctrl+Del]"" FOOTNOTE);// Del is 0x7F on macOS; 1319 Printf("" Ctrl+Del : delete next word [Esc,D] [Alt,D]"" FOOTNOTE);; 1320 Printf("" Ctrl+U : cut all characters between cursor and start of line"");; 1321 Printf("" Ctrl+K : cut all characters between cursor and end of line"");; 1322 ; 1323 Printf("" Ctrl+T : transpose characters"");; 1324 Printf("" Esc,C : character to upper and jump to next word"");; 1325 Printf("" Esc,L : word to lower case and jump to its end"");; 1326 Printf("" Esc,U : word to upper case and jump to its end"");; 1327 Printf("" Ctrl+Shift+C : copy clipboard content"");; 1328 Printf("" Ctrl+Shift+V : paste clipboard content [Ctrl+Y] [Alt+Y]"");; 1329 #ifdef R__MACOSX; 1330 Printf("" Fn+Enter : toggle overwrite mode"");; 1331 #else; 1332 Printf("" Ins : toggle overwrite mode"");; 1333 #endif; 1334 ; 1335 Printf("" Ctrl+_ : undo last keypress action"");; 1336 Printf("" Tab : autocomplete command or print suggestions [Ctrl+I] [Esc,Tab]"");; 1337 Printf("" Enter : execute command [Ctrl+J] [Ctrl+M]"");; 1338 Printf("" Ctrl+L : clear prompt screen"");; 1339 Printf("" Ctrl+D : quit ROOT (if empty line)"");; 1340 Printf("" Ctrl+C : send kSigInt interrupt signal"");; 1341 Printf("" Ctrl+Z : send kSigStop pause job signal"");; 1342 ; 1343 Printf("" Arrow_Down : navigate downwards in command history [Ctrl+N]"");; 1344 Printf("" Arrow_Up : navigate upwards in command history [Ctrl+P]"");; 1345 Printf("" Ctrl+R ; Ctrl+S : search command in your history by typing a string.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:53790,undo,undo,53790,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,3,"['clear', 'pause', 'undo']","['clear', 'pause', 'undo']"
Usability,"f);; ROOT::RDF::Experimental::AddProgressBarvoid AddProgressBar(ROOT::RDF::RNode df)Add ProgressBar to a ROOT::RDF::RNode.Definition RDFHelpers.cxx:373; Alternatively, RDataFrame can be cast to an RNode first, giving the user more flexibility For example, it can be called at any computational node, such as Filter or Define, not only the head node, with no change to the ProgressBar function itself (please see the Efficient analysis in Python section for appropriate usage in Python): ROOT::RDataFrame df(""tree"", ""file.root"");; auto df_1 = ROOT::RDF::RNode(df.Filter(""x>1""));; ROOT::RDF::Experimental::AddProgressBar(df_1);; ROOT::RDF::RNodeRInterface<::ROOT::Detail::RDF::RNodeBase, void > RNodeDefinition InterfaceUtils.hxx:57; Examples of implemented progress bars can be seen by running Higgs to Four Lepton tutorial and Dimuon tutorial. Efficient analysis in Python; You can use RDataFrame in Python thanks to the dynamic Python/C++ translation of PyROOT. In general, the interface is the same as for C++, a simple example follows.; df = ROOT.RDataFrame(""myTree"", ""myFile.root""); sum = df.Filter(""x > 10"").Sum(""y""); print(sum.GetValue()). User code in the RDataFrame workflow; C++ code; In the simple example that was shown above, a C++ expression is passed to the Filter() operation as a string (""x > 0""), even if we call the method from Python. Indeed, under the hood, the analysis computations run in C++, while Python is just the interface language.; To perform more complex operations that don't fit into a simple expression string, you can just-in-time compile C++ functions - via the C++ interpreter cling - and use those functions in an expression. See the following snippet for an example:; # JIT a C++ function from Python; ROOT.gInterpreter.Declare(""""""; bool myFilter(float x) {; return x > 10;; }; """"""); ; df = ROOT.RDataFrame(""myTree"", ""myFile.root""); # Use the function in an RDF operation; sum = df.Filter(""myFilter(x)"").Sum(""y""); print(sum.GetValue()); To increase the performa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:79831,simpl,simple,79831,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,1,['simpl'],['simple']
Usability,"f->IsA() == TLeafD::Class()) {; 9433 ltype = 5;; 9434 }; 9435 if (leaf->IsA() == TLeafC::Class()) {; 9436 len = 1;; 9437 ltype = 5;; 9438 };; 9439 printf("" %-15s = "", leaf->GetName());; 9440 for (Int_t l = 0; l < len; l++) {; 9441 leaf->PrintValue(l);; 9442 if (l == (len - 1)) {; 9443 printf(""\n"");; 9444 continue;; 9445 }; 9446 printf("", "");; 9447 if ((l % ltype) == 0) {; 9448 printf(""\n "");; 9449 }; 9450 }; 9451 }; 9452}; 9453 ; 9454////////////////////////////////////////////////////////////////////////////////; 9455/// Start the TTreeViewer on this tree.; 9456///; 9457/// - ww is the width of the canvas in pixels; 9458/// - wh is the height of the canvas in pixels; 9459 ; 9460void TTree::StartViewer(); 9461{; 9462 GetPlayer();; 9463 if (fPlayer) {; 9464 fPlayer->StartViewer(600, 400);; 9465 }; 9466}; 9467 ; 9468////////////////////////////////////////////////////////////////////////////////; 9469/// Stop the cache learning phase; 9470///; 9471/// Returns:; 9472/// - 0 learning phase stopped or not active; 9473/// - -1 on error; 9474 ; 9475Int_t TTree::StopCacheLearningPhase(); 9476{; 9477 if (!GetTree()) {; 9478 if (LoadTree(0)<0) {; 9479 Error(""StopCacheLearningPhase"",""Could not load a tree"");; 9480 return -1;; 9481 }; 9482 }; 9483 if (GetTree()) {; 9484 if (GetTree() != this) {; 9485 return GetTree()->StopCacheLearningPhase();; 9486 }; 9487 } else {; 9488 Error(""StopCacheLearningPhase"", ""No tree is available. Could not stop cache learning phase"");; 9489 return -1;; 9490 }; 9491 ; 9492 TFile *f = GetCurrentFile();; 9493 if (!f) {; 9494 Error(""StopCacheLearningPhase"", ""No file is available. Could not stop cache learning phase"");; 9495 return -1;; 9496 }; 9497 TTreeCache *tc = GetReadCache(f,true);; 9498 if (!tc) {; 9499 Error(""StopCacheLearningPhase"", ""No cache is available. Could not stop learning phase"");; 9500 return -1;; 9501 }; 9502 tc->StopLearningPhase();; 9503 return 0;; 9504}; 9505 ; 9506///////////////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:364499,learn,learning,364499,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,2,['learn'],['learning']
Usability,"f->_args[idx].c_str()) ; }. RooCategory& as_CAT(UInt_t idx); { checkIndex(idx) ; return _of->asCAT(_of->_args[idx].c_str()) ; }. RooAbsCategoryLValue& as_CATLV(UInt_t idx); { checkIndex(idx) ; return _of->asCATLV(_of->_args[idx].c_str()) ; }. RooAbsCategory& as_CATFUNC(UInt_t idx); { checkIndex(idx) ; return _of->asCATFUNC(_of->_args[idx].c_str()) ; }. RooArgSet as_SET(UInt_t idx); { checkIndex(idx) ; return _of->asSET(_of->_args[idx].c_str()) ; }. RooArgList as_LIST(UInt_t idx); { checkIndex(idx) ; return _of->asLIST(_of->_args[idx].c_str()) ; }. RooAbsData& as_DATA(UInt_t idx); { checkIndex(idx) ; return _of->asDATA(_of->_args[idx].c_str()) ; }. RooDataHist& as_DHIST(UInt_t idx); { checkIndex(idx) ; return _of->asDHIST(_of->_args[idx].c_str()) ; }. RooDataSet& as_DSET(UInt_t idx); { checkIndex(idx) ; return _of->asDSET(_of->_args[idx].c_str()) ; }. TObject& as_OBJ(UInt_t idx); { checkIndex(idx) ; return _of->asOBJ(_of->_args[idx].c_str()) ; }. const char* as_STRING(UInt_t idx); { checkIndex(idx) ; return _of->asSTRING(_of->_args[idx].c_str()) ; }. Int_t as_INT(UInt_t idx); { checkIndex(idx) ; return _of->asINT(_of->_args[idx].c_str()) ; }. Double_t as_DOUBLE(UInt_t idx); { checkIndex(idx) ; return _of->asDOUBLE(_of->_args[idx].c_str()) ; }. Int_t as_INT(UInt_t idx, Int_t defVal); { checkIndex(idx) ; if (idx>_of->_args.size()-1) return defVal ; return _of->asINT(_of->_args[idx].c_str()) ; }. Double_t as_DOUBLE(UInt_t idx, Double_t defVal); { checkIndex(idx) ; if (idx>_of->_args.size()-1) return defVal ; return _of->asDOUBLE(_of->_args[idx].c_str()) ; }. void logError(); { _errorCount++ ; }. std::map<std::string,IFace*>& hooks(); Hooks for other tools. void clearError(); { _errorCount = 0 ; }. Int_t errorCount(); { return _errorCount ; }. » Last changed: Mon Dec 7 13:47:37 2009 » Last generated: 2009-12-07 13:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFactoryWSTool.html:24128,clear,clearError,24128,root/html526/RooFactoryWSTool.html,https://root.cern,https://root.cern/root/html526/RooFactoryWSTool.html,1,['clear'],['clearError']
Usability,"f->_args[idx].c_str()) ; }. RooCategory& as_CAT(UInt_t idx); { checkIndex(idx) ; return _of->asCAT(_of->_args[idx].c_str()) ; }. RooAbsCategoryLValue& as_CATLV(UInt_t idx); { checkIndex(idx) ; return _of->asCATLV(_of->_args[idx].c_str()) ; }. RooAbsCategory& as_CATFUNC(UInt_t idx); { checkIndex(idx) ; return _of->asCATFUNC(_of->_args[idx].c_str()) ; }. RooArgSet as_SET(UInt_t idx); { checkIndex(idx) ; return _of->asSET(_of->_args[idx].c_str()) ; }. RooArgList as_LIST(UInt_t idx); { checkIndex(idx) ; return _of->asLIST(_of->_args[idx].c_str()) ; }. RooAbsData& as_DATA(UInt_t idx); { checkIndex(idx) ; return _of->asDATA(_of->_args[idx].c_str()) ; }. RooDataHist& as_DHIST(UInt_t idx); { checkIndex(idx) ; return _of->asDHIST(_of->_args[idx].c_str()) ; }. RooDataSet& as_DSET(UInt_t idx); { checkIndex(idx) ; return _of->asDSET(_of->_args[idx].c_str()) ; }. TObject& as_OBJ(UInt_t idx); { checkIndex(idx) ; return _of->asOBJ(_of->_args[idx].c_str()) ; }. const char* as_STRING(UInt_t idx); { checkIndex(idx) ; return _of->asSTRING(_of->_args[idx].c_str()) ; }. Int_t as_INT(UInt_t idx); { checkIndex(idx) ; return _of->asINT(_of->_args[idx].c_str()) ; }. Double_t as_DOUBLE(UInt_t idx); { checkIndex(idx) ; return _of->asDOUBLE(_of->_args[idx].c_str()) ; }. Int_t as_INT(UInt_t idx, Int_t defVal); { checkIndex(idx) ; if (idx>_of->_args.size()-1) return defVal ; return _of->asINT(_of->_args[idx].c_str()) ; }. Double_t as_DOUBLE(UInt_t idx, Double_t defVal); { checkIndex(idx) ; if (idx>_of->_args.size()-1) return defVal ; return _of->asDOUBLE(_of->_args[idx].c_str()) ; }. void logError(); { _errorCount++ ; }. std::map<std::string,IFace*>& hooks(); Hooks for other tools. void clearError(); { _errorCount = 0 ; }. Int_t errorCount(); { return _errorCount ; }. » Last changed: Thu Dec 2 14:53:26 2010 » Last generated: 2010-12-02 14:53; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooFactoryWSTool.html:24286,clear,clearError,24286,root/html528/RooFactoryWSTool.html,https://root.cern,https://root.cern/root/html528/RooFactoryWSTool.html,1,['clear'],['clearError']
Usability,"f...Definition TSystem.cxx:4194; The user may sometimes try to compile a script before it has loaded all the needed shared libraries. In this case we want to be helpful and output a list of the unresolved symbols. So if the loading of the created shared library fails, we will try to build a executable that contains the script. The linker should then output a list of missing symbols.; To support this we provide a TSystem::SetMakeExe() function, that sets the directive telling how to create an executable. The loader will need to be informed of all the libraries available. The information about the libraries that has been loaded by .L and TSystem::Load() is accessible to the script compiler. However, the information about the libraries that have been selected at link time by the application builder (like the root libraries for root.exe) are not available and need to be explicitly listed in fLinkedLibs (either by default or by a call to TSystem::SetLinkedLibs()).; To simplify customization we could also add to the .rootrc support for the variables Unix.*.Root.IncludePath: -I$ROOTSYS/include; WinNT.*.Root.IncludePath: -I%ROOTSYS%/include; ; Unix.*.Root.LinkedLibs: -L$ROOTSYS/lib -lBase ....; WinNT.*.Root.LinkedLibs: %ROOTSYS%/lib/*.lib msvcrt.lib ....; I#define I(x, y, z); And also support for MakeSharedLibs() and MakeExe().; (the ... have to be replaced by the actual values and are here only to shorten this comment).; Note that the default behavior is to remove libraries when closing ROOT, ie TSystem::CleanCompiledMacros() is called in the TROOT destructor. The default behavior of .L script.C+ is the opposite one, leaving things after closing, without removing. In other words, .L always passes the 'k' option behind the scenes. ; Definition at line 2836 of file TSystem.cxx. ◆ ConcatFileName(). char * TSystem::ConcatFileName ; (; const char * ; dir, . const char * ; name . ). virtual . Concatenate a directory and a file name. User must delete returned string. ; Definition",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:45747,simpl,simplify,45747,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,1,['simpl'],['simplify']
Usability,"f.C and StressProof.cxx in conjunction with ProcFileElements and ProofEventProc ;  finalizeProof.CMacro to finalize queries run with the macro tutorials/runProof ;  getProof.CAttaches to a PROOF session, possibly at the indicated URL ;  ProcFileElements.CClass to hold information about the processed elements of a file ;  ProcFileElements.hClass to hold information about the processed elements of a file ;  ProofAux.CSelector used for auxiliary actions in the PROOF tutorials ;  ProofAux.hSelector used for auxiliary actions in the PROOF tutorials ;  ProofEvent.CSelector for generic processing with Event ;  ProofEvent.hSelector for generic processing with Event ;  ProofEventProc.CSelector to process trees containing Event structures ;  ProofEventProc.hSelector to process trees containing Event structures ;  ProofFriends.CSelector to process tree friends ;  ProofFriends.hSelector to process tree friends ;  ProofNtuple.CSelector to fill a simple ntuple ;  ProofNtuple.hSelector to fill a simple ntuple ;  ProofPythia.CSelector to generate Monte Carlo events with Pythia8 ;  ProofPythia.hSelector to generate Monte Carlo events with Pythia8 ;  ProofSimple.CSelector to fill a set of histograms ;  ProofSimple.hSelector to fill a set of histograms ;  ProofSimpleFile.CSelector to fill a set of histograms and merging via file ;  ProofSimpleFile.hSelector to fill a set of histograms and merging via file ;  ProofStdVect.CSelector for generic processing with stdlib collections ;  ProofStdVect.hSelector for generic processing with stdlib collections ;  ProofTests.CAuxilliary selector used to test PROOF functionality ;  ProofTests.hAuxilliary selector used to test PROOF functionality ;  runProof.CMacro to run examples of analysis on PROOF, corresponding to the TSelector implementations found under <ROOTSYS>/tutorials/proof ;  ► pyroot;  benchmarks.pyRun benchmarks macros ;  demo.pyTo run, do an ""execfile( '<path-to>/demo.py' )"" or ""python <path-to>/demo.py"" ;  demoshelp.py Display demo h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:136514,simpl,simple,136514,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,5,['simpl'],['simple']
Usability,"f2(myf1);. // wrapping a class member function; ROOT::Math::Functor1D f3(&myf1,&MyFunction1D::Eval);. cout << f1(2) << endl;; cout << f2(2) << endl;; cout << f3(2) << endl;. return 0;; }; 13.7.4.2 Wrapping One Dimensional Gradient Functions; The ROOT::Math::GradFunctor1D class is used to wrap one-dimensional gradient functions. It can be constructed in three different ways: * Any object implementing both double operator()( double) for the function evaluation and double Derivative(double) for the function derivative. * Any object implementing any member function like Foo::XXX(double ) for the function evaluation and any other member function like Foo::YYY(double ) for the derivative. * Any two function objects implementing double operator()( double ) . One object provides the function evaluation, the other the derivative. One or both function object can be a free C function of type double ()(double ).; 13.7.4.3 Wrapping Multi-dimensional Functions; The class ROOT::Math::Functor is used to wrap in a very simple and convenient way multi-dimensional function objects. It can wrap all the following types: * Any C++ callable object implementing double operator()( const double * ). * A free C function of type double ()(const double * ). * A member function with the correct signature like Foo::Eval(const double * ). In this case one pass the object pointer and a pointer to the member function (&Foo::Eval).; The function dimension is required when constructing the functor.; Example of using Functor:; #include ""Math/Functor.h"". class MyFunction {. public:; double operator()(const double *x) const {; return x[0]+x[1];; }. double Eval(const double * x) const { return x[0]+x[1]; }; };. double freeFunction(const double * x ); {; return x[0]+x[1];; }. int main(); {; // test directly calling the function object; MyFunction myf;. // test from a free function pointer; ROOT::Math::Functor f1(&freeFunction,2);. // test from function object; ROOT::Math::Functor f2(myf,2);. // test from a ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:696378,simpl,simple,696378,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"f::AddIncludePath(const char* incpath, Bool_t onClient = kFALSE, TList* wrks = 0, Bool_t doCollect = kTRUE); voidTProof::AddInput(TObject* obj); voidTProof::AddInputData(TObject* obj, Bool_t push = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); Int_tTProof::Archive(Int_t query, const char* url); Int_tTProof::Archive(const char* queryref, const char* url = 0); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTProof::Browse(TBrowser* b); virtual Bool_tTProof::CancelStagingDataSet(const char* dataset); voidTProof::cd(Int_t id = -1); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; Int_tTProof::CleanupSession(const char* sessiontag); virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTProof::ClearCache(const char* file = 0); voidTProof::ClearData(UInt_t what = kUnregistered, const char* dsname = 0); virtual voidTProof::ClearDataSetCache(const char* dataset = 0); voidTProof::ClearFeedback(); voidTProof::ClearInput(); voidTProof::ClearInputData(TObject* obj = 0); voidTProof::ClearInputData(const char* name); Int_tTProof::ClearPackage(const char* package); Int_tTProof::ClearPackages(); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTProof::Close(Option_t* option = """"); voidTProof::CloseProgressDialog()SIGNAL ; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofCondor.html:2187,Clear,ClearData,2187,root/html534/TProofCondor.html,https://root.cern,https://root.cern/root/html534/TProofCondor.html,6,['Clear'],['ClearData']
Usability,"f::AddInput(TObject* obj); voidTProof::AddInputData(TObject* obj, Bool_t push = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); Int_tTProof::Archive(Int_t query, const char* url); Int_tTProof::Archive(const char* queryref, const char* url = 0); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTProof::Browse(TBrowser* b); virtual Bool_tCancelStagingDataSet(const char* dataset); voidTProof::cd(Int_t id = -1); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; Int_tTProof::CleanupSession(const char* sessiontag); virtual voidTNamed::Clear(Option_t* option = """"); virtual voidClearCache(const char* file = 0); voidTProof::ClearData(UInt_t what = kUnregistered, const char* dsname = 0); virtual voidClearDataSetCache(const char* dataset = 0); voidTProof::ClearFeedback(); voidTProof::ClearInput(); voidTProof::ClearInputData(TObject* obj = 0); voidTProof::ClearInputData(const char* name); Int_tTProof::ClearPackage(const char* package); Int_tTProof::ClearPackages(); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTProof::Close(Option_t* option = """"); voidTProof::CloseProgressDialog()SIGNAL ; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual voidTNamed::Copy(TObject& named) const; TDrawFeedback*TProof::CreateDrawFeedback(); voidTProo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofLite.html:2294,Clear,ClearFeedback,2294,root/html534/TProofLite.html,https://root.cern,https://root.cern/root/html534/TProofLite.html,3,['Clear'],['ClearFeedback']
Usability,"f; inputs/outputs; * TMultilayerPerceptron provides, thanks to Andrea Bocci, the possibility to; use cross-entropy errors, which allows to train a network for pattern; classification based on Bayesian posterior probability. . Introduction. Neural Networks are more and more used in various fields for data; analysis and classification, both for research and commercial; institutions. Some randomly choosen examples are:. image analysis; financial movements predictions and analysis; sales forecast and product shipping optimisation; in particles physics: mainly for classification tasks (signal; over background discrimination). More than 50% of neural networks are multilayer perceptrons. This; implementation of multilayer perceptrons is inspired from the; MLPfit; package originaly written by Jerome Schwindling. MLPfit remains; one of the fastest tool for neural networks studies, and this ROOT; add-on will not try to compete on that. A clear and flexible Object; Oriented implementation has been choosen over a faster but more; difficult to maintain code. Nevertheless, the time penalty does not; exceed a factor 2. The; MLP. The multilayer perceptron is a simple feed-forward network with; the following structure:. It is made of neurons characterized by a bias and weighted links; between them (let's call those links synapses). The input neurons; receive the inputs, normalize them and forward them to the first; hidden layer. Each neuron in any subsequent layer first computes a linear; combination of the outputs of the previous layer. The output of the; neuron is then function of that combination with f being; linear for output neurons or a sigmoid for hidden layers. This is; useful because of two theorems:. A linear combination of sigmoids can approximate any; continuous function.; Trained with output = 1 for the signal and 0 for the; background, the approximated function of inputs X is the probability; of signal, knowing X. Learning; methods. The aim of all learning methods is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiLayerPerceptron.html:2508,clear,clear,2508,root/html528/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html528/TMultiLayerPerceptron.html,4,['clear'],['clear']
Usability,"fCollectFunc(collect_func),; 562 fCreateEnv(create_env),; 563 fCreateIterators(getIterators),fCopyIterator(copyIterator),fNext(next),; 564 fDeleteSingleIterator(deleteSingleIterator),fDeleteTwoIterators(deleteTwoIterators); 565 {; 566 }; 567 ; 568 /// Generate proxy from template; 569 template <class T> static TCollectionProxyInfo* Generate(const T&) {; 570 // Generate a TCollectionProxyInfo given a TCollectionProxyInfo::Type; 571 // template (used to described the behavior of the stl collection.; 572 // Typical use looks like:; 573 // ::ROOT::Detail::TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< std::vector<string> >()));; 574 ; 575 PairHolder<TYPENAME T::Value_t, TYPENAME T::Value_t>* p =; 576 (PairHolder<TYPENAME T::Value_t, TYPENAME T::Value_t>*)0x1000;; 577 return new TCollectionProxyInfo(typeid(TYPENAME T::Cont_t),; 578 sizeof(TYPENAME T::Iter_t),; 579 (((char*)&p->second)-((char*)&p->first)),; 580 T::value_offset(),; 581 T::size,; 582 T::resize,; 583 T::clear,; 584 T::first,; 585 T::next,; 586 T::construct,; 587 T::destruct,; 588 T::feed,; 589 T::collect,; 590 T::Env_t::Create,; 591 T::Iterators_t::create,; 592 T::Iterators_t::copy,; 593 T::Iterators_t::next,; 594 T::Iterators_t::destruct1,; 595 T::Iterators_t::destruct2);; 596 }; 597 ; 598 template <class T> static TCollectionProxyInfo Get(const T&) {; 599 ; 600 // Generate a TCollectionProxyInfo given a TCollectionProxyInfo::Type; 601 // template (used to described the behavior of the stl collection.; 602 // Typical use looks like:; 603 // ::ROOT::Detail::TCollectionProxyInfo::Get(TCollectionProxyInfo::Pushback< std::vector<string> >()));; 604 ; 605 PairHolder<TYPENAME T::Value_t, TYPENAME T::Value_t>* p =; 606 (PairHolder<TYPENAME T::Value_t, TYPENAME T::Value_t>*)0x1000;; 607 return TCollectionProxyInfo(typeid(TYPENAME T::Cont_t),; 608 sizeof(TYPENAME T::Iter_t),; 609 (((char*)&p->second)-((char*)&p->first)),; 610 T::value_offset(),; 611 T::size,; 612 T::resize,; 613 T::clear,; 614 T::firs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:20434,clear,clear,20434,doc/master/TCollectionProxyInfo_8h_source.html,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html,1,['clear'],['clear']
Usability,"fDisplay, fScreenNumber);; 819 ; 820 if (!fVisual) {; 821 fDepth = DefaultDepth((Display*)fDisplay, fScreenNumber);; 822 fVisual = (RVisual*)DefaultVisual((Display*)fDisplay, fScreenNumber);; 823 fVisRootWin = fRootWin;; 824 if (fDepth > 1); 825 fColormap = DefaultColormap((Display*)fDisplay, fScreenNumber);; 826 fBlackPixel = BlackPixel((Display*)fDisplay, fScreenNumber);; 827 fWhitePixel = WhitePixel((Display*)fDisplay, fScreenNumber);; 828 }; 829 if (gDebug > 1); 830 Printf(""Selected visual 0x%lx: depth %d, class %d, colormap: %s"",; 831 fVisual->visualid, fDepth, fVisual->c_class,; 832 fColormap == DefaultColormap((Display*)fDisplay, fScreenNumber) ? ""default"" :; 833 ""custom"");; 834}; 835 ; 836////////////////////////////////////////////////////////////////////////////////; 837/// Dummy error handler for X11. Used by FindUsableVisual().; 838 ; 839static Int_t DummyX11ErrorHandler(Display *, XErrorEvent *); 840{; 841 return 0;; 842}; 843 ; 844////////////////////////////////////////////////////////////////////////////////; 845/// Check if visual is usable, if so set fVisual, fDepth, fColormap,; 846/// fBlackPixel and fWhitePixel.; 847 ; 848void TGX11::FindUsableVisual(RXVisualInfo *vlist, Int_t nitems); 849{; 850 Int_t (*oldErrorHandler)(Display *, XErrorEvent *) =; 851 XSetErrorHandler(DummyX11ErrorHandler);; 852 ; 853 XSetWindowAttributes attr;; 854 memset(&attr, 0, sizeof(attr));; 855 ; 856 Window root = RootWindow((Display*)fDisplay, fScreenNumber);; 857 ; 858 for (Int_t i = 0; i < nitems; i++) {; 859 Window w = None, wjunk;; 860 UInt_t width, height, ujunk;; 861 Int_t junk;; 862 ; 863 // try and use default colormap when possible; 864 if (vlist[i].visual == DefaultVisual((Display*)fDisplay, fScreenNumber)) {; 865 attr.colormap = DefaultColormap((Display*)fDisplay, fScreenNumber);; 866 } else {; 867 attr.colormap = XCreateColormap((Display*)fDisplay, root, vlist[i].visual, AllocNone);; 868 }; 869 ; 870 static XColor black_xcol = { 0, 0x0000, 0x0000, 0x0000, Do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGX11_8cxx_source.html:27289,usab,usable,27289,doc/master/TGX11_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html,1,['usab'],['usable']
Usability,"fNRargsnumber of redo arguments; Int_tfNUargsnumber of undo arguments; TStringfNamecommand name. Default is ""ClassName::RedoName(args)""; TStringTCollection::fNamename of the collection; Bool_tfNewDeletekTRUE if Redo/Undo methods are new/delete; void*fObjectobject to which undo/redo actions applied; TQConnection*fRedodo/redo action; Long_t*fRedoArgsredo values; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; Int_tfState-1 undoing on, 1 redoing on, 0 nothing in progress; Int_tfStatusfStatus++ after Redo(), fStatus-- after Undo(); TStringfTitlecommand description; TQConnection*fUndoundo action; Long_t*fUndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Init(const char* cl, void* object, const char* redo, const char* undo); common protected method used in several constructors. TQCommand(const char* cl = 0, void* object = 0, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. clname - class name.; 2. obj - an object; 3. redo - method or function to do/redo operation; 4. undo - method or function to undo operation. Comments:; - if either clname or obj is NULL that means that redo/undo is function; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(""TPad"", gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case undo parameter; can be omitted. Example:; TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. obj - an object; 2. redo - method or function to do/redo operation; 3. undo - method or function to undo operation. Comments:; - to specify",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQCommand.html:17786,undo,undo,17786,root/html528/TQCommand.html,https://root.cern,https://root.cern/root/html528/TQCommand.html,6,['undo'],['undo']
Usability,"fParentIDs![fNumPIDs][fAllocSize] array of Parent IDs; TObjArray*fParentsarray of Parent objects (eg TTree branch) holding the referenced objects; vector<string>fProcessGUIDsUUIDs of TProcessIDs used in fParentIDs; Int_tfSizedummy for backward compatibility; UInt_tfUID!Current uid (set by TRef::GetObject); TProcessID*fUIDContext!TProcessID the current uid is referring to; static TRefTable*fgRefTablePointer to current TRefTable. Class Charts. Inheritance Chart:. TObject. ←; TRefTable. Function documentation; TRefTable(); Default constructor for I/O. TRefTable(TObject* owner, Int_t size); Create a TRefTable with initial size. ~TRefTable(); Destructor. Int_t Add(Int_t uid, TProcessID* context = 0); Add a new uid to the table.; we add a new pair (uid,fparent) to the map; This function is called by TObject::Streamer or TStreamerInfo::WriteBuffer. Int_t AddInternalIdxForPID(TProcessID* procid); Add the internal index for fProcessIDs, fAllocSize, etc given a PID. void Clear(Option_t* = """"); Clear all entries in the table. Int_t Expand(Int_t pid, Int_t newsize); Expand fParentIDs to newsize for ProcessID pid. Int_t ExpandForIID(Int_t iid, Int_t newsize); Expand fParentIDs to newsize for internel ProcessID index iid. void ExpandPIDs(Int_t numpids); Expand the arrays of managed PIDs. void FillBuffer(TBuffer& b); Fill buffer b with the fN elements in fParentdIDs.; This function is called by TBranchRef::FillLeaves. Int_t FindPIDGUID(const char* guid) const; Get fProcessGUIDs' index of the TProcessID with GUID guid. TObject * GetParent(Int_t uid, TProcessID* context = 0) const; Return object corresponding to uid. Int_t GetInternalIdxForPID(TProcessID* procid) const; Get the index for fProcessIDs, fAllocSize, etc given a PID.; Uses fMapPIDtoInternal and the pid's GUID / fProcessGUID. Int_t GetInternalIdxForPID(Int_t pid) const; Get the index for fProcessIDs, fAllocSize, etc given a PID.; Uses fMapPIDtoInternal and the pid's GUID / fProcessGUID. TRefTable * GetRefTable(); Static f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRefTable.html:9266,Clear,Clear,9266,root/html602/TRefTable.html,https://root.cern,https://root.cern/root/html602/TRefTable.html,4,['Clear'],['Clear']
Usability,"fStatus++ after Redo(), fStatus-- after Undo(); TStringfTitlecommand description; TQConnection*fUndoundo action; Long_t*fUndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Init(const char* cl, void* object, const char* redo, const char* undo); common protected method used in several constructors. TQCommand(const char* cl = 0, void* object = 0, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. clname - class name.; 2. obj - an object; 3. redo - method or function to do/redo operation; 4. undo - method or function to undo operation. Comments:; - if either clname or obj is NULL that means that redo/undo is function; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(""TPad"", gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case undo parameter; can be omitted. Example:; TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. obj - an object; 2. redo - method or function to do/redo operation; 3. undo - method or function to undo operation. Comments:; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case ""undo""; can parameter be omitted. Example:; TQCommand(gPad, ""SetFillStyle(Style_t)"");. TQCommand(const TQCommand& com); Copy constructor. ~TQCommand(); dtor. TQCommand * GetCommand(); Return a command which is doing redo/undo action. This static method allows to set undo parameters dynamically, i.e.; during execution of Redo function. Example:; For redo actions like TGTextEdit::DelChar() it is not possible to; know",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQCommand.html:18383,undo,undo,18383,root/html528/TQCommand.html,https://root.cern,https://root.cern/root/html528/TQCommand.html,6,['undo'],['undo']
Usability,"fTabMgrtab manager corresponding to ged-editor; Double_tTGeoTrapEditor::fThetaiInitial theta; Double_tTGeoTrapEditor::fTl1iInitial half length in x at low z and y high edge; Double_tfTwistiInitial twist angle; TGTextButton*TGeoTrapEditor::fUndoUndo-Button; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoGtraEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for gtra editor. ~TGeoGtraEditor(); Destructor. void SetModel(TObject* obj); Connect to a given twisted trapezoid. void DoApply(); Slot for applying current settings. void DoUndo(); Slot for undoing last operation. void DoTwist(); Change the twist angle. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoGtraEditor.html:22534,undo,undoing,22534,root/html534/TGeoGtraEditor.html,https://root.cern,https://root.cern/root/html534/TGeoGtraEditor.html,2,['undo'],['undoing']
Usability,"fTitleobject title; static TPythia6*fgInstance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPythia6(); TPythia6 constructor: creates a TClonesArray in which it will store all; particles. Note that there may be only one functional TPythia6 object; at a time, so it's not use to create more than one instance of it. TPythia6(const TPythia6& ); { }. ~TPythia6(); Destroys the object, deletes and disposes all TMCParticles currently on list. TPythia6* Instance(); model of automatic memory cleanup suggested by Jim Kowalkovski:; destructor for local static variable `cleaner' is always called in the end; of the job thus deleting the only TPythia6 instance. void GenerateEvent(); generate event and copy the information from /HEPEVT/ to fPrimaries. void OpenFortranFile(int lun, char* name); interface with fortran i/o. void CloseFortranFile(int lun); interface with fortran i/o. TObjArray * ImportParticles(Option_t* option = """"); Fills TObjArray fParticles list with particles from common LUJETS; Old contents of a list are cleared. This function should be called after; any change in common LUJETS, however GetParticles() method calls it; automatically - user don't need to care about it. In case you make a call; to LuExec() you must call this method yourself to transfer new data from; common LUJETS to the fParticles list. Int_t ImportParticles(TClonesArray* particles, Option_t* option = """"); Default primary creation method. It reads the /HEPEVT/ common block which; has been filled by the GenerateEvent method. If the event generator does; not use the HEPEVT common block, This routine has to be overloaded by; the subclasses.; The function loops on the generated particles and store them in; the TClonesArray pointed by the argument particles.; The default action is to store only the stable particles (ISTHEP = 1); This can be demanded explicitly by setting the option = ""Final""; If the option = ""All"", all the particles are stored. void Initiali",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPythia6.html:12978,clear,cleared,12978,root/html528/TPythia6.html,https://root.cern,https://root.cern/root/html528/TPythia6.html,4,['clear'],['cleared']
Usability,"fUseRegulatorzjh; TRandom3*TMVA::MethodANNBase::frgenrandom number generator for various uses. private:. TMVA::MethodMLP::EBPTrainingModefBPModebackprop learning mode (sequential or batch); Int_tfBatchSizebatch size, only matters if in batch learning mode; TStringfBpModeSbackprop learning mode option string (sequential or batch); boolfCalculateErrorscompute inverse hessian matrix at the end of the training; Double_tfDecayRatedecay rate for above learning rate; vector<pair<Float_t,Float_t> >*fDeviationsFromTargetsdeviation from the targets, event weight; Bool_tfEpochMoncreate and fill epoch-wise monitoring histograms (makes outputfile big!); Double_tfGA_SC_factorGA settings: SC_factor; Int_tfGA_SC_rateGA settings: SC_rate; Int_tfGA_SC_stepsGA settings: SC_steps; Int_tfGA_nstepsGA settings: number of steps; Int_tfGA_preCalcGA settings: number of pre-calc steps; Double_tfLastAlphaline search variable; Double_tfLearnRatelearning rate for synapse weight adjustments; Double_tfPriorzjh; vector<Double_t>fPriorDevzjh; Int_tfResetStepreset time (how often we clear hessian matrix); Float_tfSamplingEpochfraction of epochs where sampling is used; Float_tfSamplingFractionfraction of events which is sampled for training; Bool_tfSamplingTestingThe testing sample is sampled; Bool_tfSamplingTrainingThe training sample is sampled; Float_tfSamplingWeightchanging factor for event weights when sampling is turned on; Double_tfTauline search variable; Int_tfTestRatetest for overtraining performed at each #th epochs; TStringfTrainMethodStraining method option param; TMVA::MethodMLP::ETrainingMethodfTrainingMethodmethod of training, BP or GA; Int_tfUpdateLimitzjh; boolfUseRegulatorzjh; Float_tfWeightRangesuppress outliers for the estimator calculation; static const Bool_tfgPRINT_BATCHdebug flags; static const Int_tfgPRINT_ESTIMATOR_INCdebug flags; static const Bool_tfgPRINT_SEQdebug flags. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodMLP(co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodMLP.html:23506,learn,learning,23506,root/html602/TMVA__MethodMLP.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodMLP.html,20,"['clear', 'learn']","['clear', 'learning']"
Usability,"fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. private:. TPieSlice*fPieSlice. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPieSliceEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); TPieSliceEditor constructor. ~TPieSliceEditor(); TPieSliceEditor destructor. void SetModel(TObject* ); Set model. void ConnectSignals2Slots(); Connect signals to slots. void DoTitle(const char* ); Slot for setting the graph title. void DoValue(); Slot for setting the graph title. void DoOffset(); Slot for setting the graph title. TPieSliceEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: Guido Volpi 05/18/2008 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: Tue Jun 30 15:25:15 2015 » Last generated: 2015-06-30 15:25; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPieSliceEditor.html:21433,Guid,Guido,21433,root/html602/TPieSliceEditor.html,https://root.cern,https://root.cern/root/html602/TPieSliceEditor.html,1,['Guid'],['Guido']
Usability,"failure. Bool_t AllocColor(Colormap cmap, RXColor* color); Allocate color in colormap. If we are on an <= 8 plane machine; we will use XAllocColor. If we are on a >= 15 (15, 16 or 24) plane; true color machine we will calculate the pixel value using:; for 15 and 16 bit true colors have 6 bits precision per color however; only the 5 most significant bits are used in the color index.; Except for 16 bits where green uses all 6 bits. I.e.:; 15 bits = rrrrrgggggbbbbb; 16 bits = rrrrrggggggbbbbb; for 24 bits each r, g and b are represented by 8 bits. Since all colors are set with a max of 65535 (16 bits) per r, g, b; we just right shift them by 10, 11 and 10 bits for 16 planes, and; (10, 10, 10 for 15 planes) and by 8 bits for 24 planes.; Returns kFALSE in case color allocation failed. void QueryColors(Colormap cmap, RXColor* colors, Int_t ncolors); Returns the current RGB value for the pixel in the XColor structure. void ClearPixmap(Drawable* pix); Clear the pixmap pix. void ClearWindow(); Clear current window. void ClosePixmap(); Delete current pixmap. void CloseWindow(); Delete current window. void CloseWindow1(); Delete current window. void CopyPixmap(Int_t wid, Int_t xpos, Int_t ypos); Copy the pixmap wid at the position xpos, ypos in the current window. void CopyWindowtoPixmap(Drawable* pix, Int_t xpos, Int_t ypos); Copy area of current window in the pixmap pix. void DrawBox(Int_t x1, Int_t y1, Int_t x2, Int_t y2, TVirtualX::EBoxMode mode); Draw a box.; mode=0 hollow (kHollow); mode=1 solid (kSolid). void DrawCellArray(Int_t x1, Int_t y1, Int_t x2, Int_t y2, Int_t nx, Int_t ny, Int_t* ic); Draw a cell array.; x1,y1 : left down corner; x2,y2 : right up corner; nx,ny : array size; ic : array. Draw a cell array. The drawing is done with the pixel presicion; if (X2-X1)/NX (or Y) is not a exact pixel number the position of; the top rigth corner may be wrong. void DrawFillArea(Int_t n, TPoint* xy); Fill area described by polygon.; n : number of points; xy(2,n) : list of p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGX11.html:27617,Clear,ClearWindow,27617,root/html602/TGX11.html,https://root.cern,https://root.cern/root/html602/TGX11.html,4,['Clear'],"['Clear', 'ClearWindow']"
Usability,"fault kIndexesBasic); Normally these functions should be called immidiately after TSQLFile constructor. When objects data written to database, by default START TRANSACTION/COMMIT; SQL commands are used before and after data storage. If TSQLFile detects; any problems, ROLLBACK command will be used to restore; previous state of data base. If transactions not supported by SQL server,; they can be disabled by SetUseTransactions(kTransactionsOff). Or user; can take responsibility to use transactions function to hime. By default only indexes for basic tables are created.; In most cases usage of indexes increase perfomance to data reading,; but it also can increase time of writing data to database.; There are several modes of index usage available in SetUseIndexes() method. There is MakeSelectQuery(TClass*) method, which; produces SELECT statement to get objects data of specified class.; Difference from simple statement like:; mysql> SELECT * FROM TH1I_ver1; that not only data for that class, but also data from parent classes; will be extracted from other tables and combined in single result table.; Such select query can be usufull for external access to objects data. Up to now MySQL 4.1 and Oracle 9i were tested.; Some extra work is required for other SQL databases.; Hopefully, this should be straigthforward. Known problems and open questions.; 1) TTree is not supported by TSQLFile. There is independent development; of TTreeSQL class, which allows to store trees directly in SQL database; 2) TClonesArray is store objects in raw format,; which can not be accessed outside ROOT.; This will be changed later.; 3) TDirectory cannot work. Hopefully, will (changes in ROOT basic I/O is required); 4) Streamer infos are not written to file, therefore schema evolution; is not yet supported. All eforts are done to enable this feature in; the near future. Example how TSQLFile can be used:. example of a session saving data to a SQL data base. const char* dbname = ""mysql://host.domain:330",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSQLFile.html:5030,simpl,simple,5030,root/html530/TSQLFile.html,https://root.cern,https://root.cern/root/html530/TSQLFile.html,9,['simpl'],['simple']
Usability,"fault), ReadBuffer automatically; delete objects when a data member is a pointer to an object.; If your constructor is not presetting pointers to 0, you must; call this static function TStreamerInfo::SetCanDelete(kFALSE);. void SetFactory(TVirtualStreamerInfo* factory); static function: Set the StreamerInfo factory. Bool_t SetStreamMemberWise(Bool_t enable = kTRUE); Set whether the TStreamerInfos will save the collections in; ""member-wise"" order whenever possible. The default is to store member-wise.; kTRUE indicates member-wise storing; kFALSE inddicates object-wise storing; This function returns the previous value of fgStreamMemberWise. void Streamer(TBuffer& ); Stream an object of class TVirtualStreamerInfo. void ResetIsCompiled(). void SetIsCompiled(). void Build(). void BuildCheck(TFile* file = 0). void BuildEmulated(TFile* file). void BuildOld(). Bool_t BuildFor(const TClass* cl). void CallShowMembers(const void* obj, TMemberInspector& insp, Bool_t isTransient) const. void Clear(Option_t* ). Bool_t CompareContent(TClass* cl, TVirtualStreamerInfo* info, Bool_t warn, Bool_t complete, TFile* file). void Compile(). void ForceWriteInfo(TFile* file, Bool_t force = kFALSE). Int_t GenerateHeaderFile(const char* dirname, const TList* subClasses = 0, const TList* extrainfos = 0). TClass * GetActualClass(const void* obj) const. TClass * GetClass() const. UInt_t GetCheckSum() const. Int_t GetClassVersion() const. TStreamerElement * GetElem(Int_t id) const. TStreamerElement * GetElement(Int_t id) const. TObjArray * GetElements() const. Int_t GetOffset(const char* ) const. Int_t GetOffset(Int_t id) const. Int_t GetElementOffset(Int_t id) const. Version_t GetOldVersion() const. Int_t GetOnFileClassVersion() const. Int_t GetNumber() const. Int_t GetSize() const. TStreamerElement * GetStreamerElement(const char* datamember, Int_t& offset) const. Bool_t IsBuilt() const; { return fIsBuilt; }. Bool_t IsCompiled() const; { return fIsCompiled; }. Bool_t IsOptimized() const; { retur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualStreamerInfo.html:15277,Clear,Clear,15277,root/html602/TVirtualStreamerInfo.html,https://root.cern,https://root.cern/root/html602/TVirtualStreamerInfo.html,2,['Clear'],['Clear']
Usability,"faultFrameBackground()); virtual~TGButtonGroup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidButtonClicked(); virtual voidButtonPressed(); virtual voidButtonReleased(); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual voidClicked(Int_t id)SIGNAL ; virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()SIGNAL ; virtual voidTGWindow::DestroySubwindows(); virtual voidTGWindow::DestroyWindow(); Bool_tTQObject::Disconnect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGButtonGroup.html:4247,Clear,Clear,4247,root/html532/TGButtonGroup.html,https://root.cern,https://root.cern/root/html532/TGButtonGroup.html,2,['Clear'],['Clear']
Usability,"fer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTerminate(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofDrawListOfPolyMarkers3D(); TProofDrawListOfPolyMarkers3D(TProofDrawListOfPolyMarkers3D&&); TProofDrawListOfPolyMarkers3D(const TProofDrawListOfPolyMarkers3D&); virtual voidTObject::UseCurrentStyle(); virtual intTProofDraw::Version() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTProofDraw::ClearFormula(); virtual Bool_tTProofDraw::CompileVariables(); virtual voidDefVar(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidDoFill(Long64_t entry, Double_t w, const Double_t* v); voidTProofDraw::FillWeight(); voidTObject::MakeZombie(); virtual Bool_tTProofDraw::ProcessSingle(Long64_t, Int_t); voidTProofDraw::SetCanvas(const char* objname); voidTProofDraw::SetDrawAtt(TObject* o); voidTProofDraw::SetError(const char* sub, const char* mesg). Data Members; public:. static TSelector::EAbortTSelector::kAbortFile; static TSelector::EAbortTSelector::kAbortProcess; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TSelector::EAbortTSelector::kContinue; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofDrawListOfPolyMarkers3D.html:6107,Clear,ClearFormula,6107,root/html602/TProofDrawListOfPolyMarkers3D.html,https://root.cern,https://root.cern/root/html602/TProofDrawListOfPolyMarkers3D.html,2,['Clear'],['ClearFormula']
Usability,"fer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Bool_t_clearOnRedirect; Int_tRooCacheManager<RooAbsCacheElement>::_lastIndexLast slot accessed; Int_tRooCacheManager<RooAbsCacheElement>::_maxSizeMaximum size; RooNormSetCache*RooCacheManager<RooAbsCacheElement>::_nsetCache! Normalization/Integration set manager; RooAbsCacheElement**RooCacheManager<RooAbsCacheElement>::_object! Payload; Bool_t_optCacheModeSeen; list<RooArgSet*>_optCacheObsList! list of all optCacheObservables owned; RooArgSet*_optCacheObservables! current optCacheObservables ; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_tRooCacheManager<RooAbsCacheElement>::_sizeActual use. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooObjCacheManager(RooAbsArg* owner = 0, Int_t maxSize = 10, Bool_t clearCacheOnServerRedirect = kTRUE); Constructor of object cache manager for given owner. If clearCacheOnServerRedirect is true; all cache elements will be cleared when a server redirect is intercepted by the cache manager.; This is the default strategy and should only be overridden when you really understand; what you're doing as properly implementing server redirect in cache elements can get very; complicated, especially if there are (cyclical) reference back to the owning object. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); Copy constructor. ~RooObjCacheManager(); Destructor. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Intercept server redirect calls. If clearOnRedirect was set, sterilize; the cache (i.e. keep the structure but delete all contents). If not; forward serverRedirect to cache elements. void operModeHook(); Intercept changes to cache operation mode and forward to cache elements. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Intercept calls to perform automatic optimization of cache mode operation.; Forward calls to existing cache e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooObjCacheManager.html:3724,clear,clearCacheOnServerRedirect,3724,root/html526/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html526/RooObjCacheManager.html,4,['clear'],"['clearCacheOnServerRedirect', 'cleared']"
Usability,"fer, Long64_t size, Option_t* option = """", const char* ftitle = """", Int_t compress = 1); virtual~TMemFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidTDirectoryFile::Append(TObject* obj, Bool_t replace = kFALSE); virtual Int_tTDirectoryFile::AppendKey(TKey* key); virtual voidTObject::AppendPad(Option_t* option = """"); static TFileOpenHandle*TFile::AsyncOpen(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); virtual voidTDirectoryFile::Browse(TBrowser* b); virtual voidTDirectoryFile::Build(TFile* motherFile = 0, TDirectory* motherDir = 0); virtual Bool_tTDirectoryFile::cd(const char* path = 0); static Bool_tTDirectory::Cd(const char* path); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTDirectory::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TObject*TDirectoryFile::CloneObject(const TObject* obj, Bool_t autoadd = kTRUE); virtual voidTFile::Close(Option_t* option = """")MENU ; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTFile::Copy(TObject&) const; virtual voidCopyTo(TBuffer& tobuf) const; virtual Long64_tCopyTo(void* to, Long64_t maxsize) const; virtual Bool_tTFile::Cp(const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); static Bool_tTFile::Cp(const char* src, const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); virtual TKey*TFile::CreateKey(TDirectory* mother, const TObject* obj, const char* name, Int_t bufsize); virtual TKey*TFile::CreateKey(TDirectory* mother, const void* obj, const TClass* cl, const char* name, Int_t bufsize); static TDirectory*&TDirectory::CurrentDirectory(); static TFile*&TFile::CurrentFile(); static voidTDirectory::DecodeNameCycle(const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMemFile.html:1572,Clear,Clear,1572,root/html532/TMemFile.html,https://root.cern,https://root.cern/root/html532/TMemFile.html,2,['Clear'],['Clear']
Usability,"fer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafD(); Default constructor for LeafD*-*-*-*-*-*-*-*-; *-* ============================. TLeafD(TBranch* parent, const char* name, const char* type); Create a LeafD*-*-; *-* ==============; -. ~TLeafD(); Default destructor for a LeafD*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ====================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements in Basket output buffer; *-* ==========================================. void Import(TClonesArray* list, Int_t n); -*Import element from ClonesArray into local leaf buffer; *-* ======================================================. void PrintValue(Int_t i = 0) const; Prints leaf value. void ReadBasket(TBuffer& b); -*-*-*-*-*Read leaf elements from Basket input buffer; *-* ===========================================. void ReadBasketExport(TBuffer& b, TClonesArray* list, Int_t n); -*-*-*-*-*Read leaf elements from Basket input buffer; and export buffer to TClonesArray objects. void ReadValue(istream& s, Char_t delim = ' '); read a double from istream s and store it into the branch buffer. void SetAddress(void* add = 0); -*-*-*-*-*Set leaf buffer data address; *-* ============================. Double_t GetValue(Int_t i = 0) const; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. { return fValue[i]; }. TLeafD(). const char * GetTypeName() const; {return ""Double_t"";}. void * GetValuePointer() const; {return fValue;}. » Author: Rene Brun 12/01/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-03-14 16:42; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TLeafD.html:9236,simpl,simple,9236,root/html534/TLeafD.html,https://root.cern,https://root.cern/root/html534/TLeafD.html,2,['simpl'],['simple']
Usability,"ference Manual . ; User's Guides . ; HowTo . ; Courses . ; Building ROOT . ; Tutorials . ; Javascript Root . ; ROOT and Spark . ; Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Documentation » Courses » Introductory Tutorials Histogramming in a Selector. Preparation; As previously, we provide a ready-made TSelector derived class in a simple source file. So please download also the following source file and save it where you can find it: EventDataSelector.C (or wget http://root-mirror.github.io/training/intro/EventDataSelector.C).; This selector contains all the necessary steps to read the data from the tree branches, like the number of particles, the X position of each particle PosX[nparticles], and the absolute momentum of each particle Momentum[nparticles].; Now quit and restart ROOT (to make sure everybody starts from the same point). Then open the file again:; root[0] TFile::Open(""http://root.cern/files/introtutorials/eventdata.root"");. Adding a Data Member; Just like for the sum of event sizes, you need to add a data member to the class. As in Histogramming, we want to histogram the particles' fPosX; the type of the data member should thus be TH1F*. Don't forget to initialize the histogram pointer to 0 in the constructor, again just like for the event size sum.; Creating the Hist",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/histogramming-selector.html:2023,simpl,simple,2023,d/histogramming-selector.html,https://root.cern,https://root.cern/d/histogramming-selector.html,1,['simpl'],['simple']
Usability,"ference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Protected Member Functions |; Protected Attributes |; List of all members ; TMVA::DNN::TAdagrad< Architecture_t, Layer_t, DeepNet_t > Class Template Reference. ; template<typename Architecture_t, typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>>; class TMVA::DNN::TAdagrad< Architecture_t, Layer_t, DeepNet_t >Adagrad Optimizer class. ; This class represents the Adagrad Optimizer. ; Definition at line 45 of file Adagrad.h. Public Types; using Matrix_t = typename Architecture_t::Matrix_t;  ; using Scalar_t = typename Architecture_t::Scalar_t;  ;  Public Types inherited from TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >; using Matrix_t = typename Architecture_t::Matrix_t;  ; using Scalar_t = typename Architecture_t::Scalar_t;  . Public Member Functions;  TAdagrad (DeepNet_t &deepNet, Scalar_t learningRate=0.01, Scalar_t epsilon=1e-8);  Constructor. ;  ;  ~TAdagrad ()=default;  Destructor. ;  ; Scalar_t GetEpsilon () const;  Getters. ;  ; std::vector< std::vector< Matrix_t > > & GetPastSquaredBiasGradients ();  ; std::vector< Matrix_t > & GetPastSquaredBiasGradientsAt (size_t i);  ; std::vector< std::vector< Matrix_t > > & GetPastSquaredWeightGradients ();  ; std::vector< Matrix_t > & GetPastSquaredWeightGradientsAt (size_t i);  ;  Public Member Functions inherited from TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >;  VOptimizer (Scalar_t learningRate, DeepNet_t &deepNet);  Constructor. ;  ; virtual ~VOptimizer ()=default;  Virtual Destructor. ;  ; size_t GetGlobalStep () const;  ; Layer_t * GetLayerAt (size_t i);  ; std::vector< Layer_t * > & GetLayers ();  ; Scalar_t GetLearningRate () const;  Getters. ;  ; void IncrementGlobalStep ();  Increments the global step. ;  ; void SetLearningRate (size_t learningRate);  Setters. ;  ; void Ste",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdagrad.html:1109,learn,learningRate,1109,doc/master/classTMVA_1_1DNN_1_1TAdagrad.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdagrad.html,1,['learn'],['learningRate']
Usability,"ferent data (used by MethodCategory::GetMvaValues)Definition MethodBase.h:448; TMVA::MethodDLDefinition MethodDL.h:89; TMVA::MethodDL::TensorImpl_ttypename ArchitectureImpl_t::Tensor_t TensorImpl_tDefinition MethodDL.h:108; TMVA::MethodDL::fBatchHeightsize_t fBatchHeightThe height of the batch used to train the deep net.Definition MethodDL.h:183; TMVA::MethodDL::GetHelpMessagevoid GetHelpMessage() constDefinition MethodDL.cxx:2342; TMVA::MethodDL::fLossFunctionDNN::ELossFunction fLossFunctionThe loss function.Definition MethodDL.h:190; TMVA::MethodDL::fInputShapestd::vector< size_t > fInputShapeContains the batch size (no.Definition MethodDL.h:178; TMVA::MethodDL::fLayoutStringTString fLayoutStringThe string defining the layout of the deep net.Definition MethodDL.h:194; TMVA::MethodDL::SetInputDepthvoid SetInputDepth(int inputDepth)Setters.Definition MethodDL.h:286; TMVA::MethodDL::fYHatstd::unique_ptr< MatrixImpl_t > fYHatDefinition MethodDL.h:208; TMVA::MethodDL::Trainvoid Train()Methods for training the deep learning network.Definition MethodDL.cxx:1659; TMVA::MethodDL::GetBatchHeightsize_t GetBatchHeight() constDefinition MethodDL.h:263; TMVA::MethodDL::GetMvaValuesvirtual std::vector< Double_t > GetMvaValues(Long64_t firstEvt, Long64_t lastEvt, Bool_t logProgress)Evaluate the DeepNet on a vector of input values stored in the TMVA Event class Here we will evaluate...Definition MethodDL.cxx:2022; TMVA::MethodDL::fWeightInitializationStringTString fWeightInitializationStringThe string defining the weight initialization method.Definition MethodDL.h:197; TMVA::MethodDL::ParseMaxPoolLayervoid ParseMaxPoolLayer(DNN::TDeepNet< Architecture_t, Layer_t > &deepNet, std::vector< DNN::TDeepNet< Architecture_t, Layer_t > > &nets, TString layerString, TString delim)Pases the layer string and creates the appropriate max pool layer.Definition MethodDL.cxx:768; TMVA::MethodDL::fXInputTensorImpl_t fXInputDefinition MethodDL.h:206; TMVA::MethodDL::fRandomSeedsize_t fRandomSeedThe r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:103509,learn,learning,103509,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['learn'],['learning']
Usability,"ffect.; “NOL” No OutLine: do not draw the slices’ outlines; any property over the slices’ line is ignored. The method SetLabelFormat() is used to customize the label format. The format string must contain one of these modifiers:. %txt : to print the text label associated with the slice. %val : to print the numeric value of the slice. %frac : to print the relative fraction of this slice. %perc : to print the % of this slice. mypie->SetLabelFormat(""%txt (%frac)"");; See the macro $ROOTSYS/tutorials/graphics/piechart.C . The picture generated by tutorial macro piechart.C. 3.21 The User Interface for Histograms; The classes T H1 Editor and T H2 Editor provides the user interface for setting histogram’s attributes and rebinning interactively.; 3.21.1 TH1Editor. 3.21.1.1 The Style Tab; 3.21.1.1.1 Title; sets the title of the histogram.; 3.21.1.1.2 Plot; draw a 2D or 3D plot; according to the dimension, different drawing possibilities can be set.; 3.21.1.1.3 Error; add different error bars to the histogram (no errors, simple, etc.).; 3.21.1.1.4 Add; further things which can be added to the histogram (None, simple/smooth line, fill area, etc.); 3.21.1.2 2-D Plot; 3.21.1.2.1 Simple Drawing; draw a simple histogram without errors (= “HIST” draw option). In combination with some other draw options an outer line is drawn on top of the histogram; 3.21.1.2.2 Show markers; draw a marker on to of each bin (=“P” draw option).; 3.21.1.2.3 Draw bar chart; draw a bar chart (=“B” draw option).; 3.21.1.2.4 Bar option; draw a bar chart (=“BAR” draw option); if selected, it will show an additional interface elements for bars: width, offset, percentage and the possibility to draw horizontal bars.; 3.21.1.3 3-D Plot; 3.21.1.3.1 Add; set histogram type Lego-Plot or Surface draw (Lego, Lego1.2, Surf, Surf1…5).; 3.21.1.3.2 Coords; set the coordinate system (Cartesian, Spheric, etc.).; 3.21.1.3.3 Error; same as for 2D plot.; 3.21.1.3.4 Bar; set the bar attributes: width and offset.; 3.21.1.3.5 Hor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:135531,simpl,simple,135531,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"ffer : "", char_buffer). # However, you can turn the buffer into a string very easily with as_string():; print(""struct.char_buffer.as_string(): "", char_buffer.as_string()); The output of this script with ROOT 6.32:; struct.char_buffer : <cppyy.LowLevelView object at 0x74c7a2682fb0>; struct.char_buffer.as_string(): foo; Deprecate the attribute pythonization of TDirectory in favor of item-getting syntax; The new recommended way to get objects from a TFile or any TDirectory in general is now via __getitem__:; tree = my_file[""my_tree""] # instead of my_file.my_tree; This is more consistent with other Python collections (like dictionaries), makes sure that member functions can’t be confused with branch names, and easily allows you to use string variables as keys.; With the new dictionary-like syntax, you can also get objects with names that don’t qualify as a Python variable. Here is a short demo:; import ROOT. with ROOT.TFile.Open(""my_file.root"", ""RECREATE"") as my_file:. # Populate the TFile with simple objects.; my_file.WriteObject(ROOT.std.string(""hello world""), ""my_string""); my_file.WriteObject(ROOT.vector[""int""]([1, 2, 3]), ""my vector""). print(my_file[""my_string""]) # new syntax; print(my_file.my_string) # old deprecated syntax. # With the dictionary syntax, you can also use names that don't qualify as; # a Python variable:; print(my_file[""my vector""]); # print(my_file.my vector) # the old syntax would not work here!; The old pythonization with the __getattr__ syntax still works, but emits a deprecation warning and will be removed from ROOT 6.34.; Removal of Python 2 support; ROOT does no longer support Python 2. The minimum Python version necessary to use ROOT in a Python application is 3.8. As a consequence, any reference to Python 2 in ROOT code was removed and certain configuration options are no longer usable, e.g. root-config --python2-version; cmake -Dpyroot-python2. The cmake build system now looks for the standard Python3 package and previously custom Python-r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:21873,simpl,simple,21873,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,1,['simpl'],['simple']
Usability,"ffer an option to be drawn in NDC. For instance, a line (TLine) may be drawn in NDC by using DrawLineNDC(). A latex formula or a text may use TText::SetNDC() to be drawn in NDC coordinates.; 9.3.3 Converting between Coordinate Systems; There are a few utility functions in TPad to convert from one system of coordinates to another. In the following table, a point is defined by (px,py) in pixel coordinates, (ux,uy) in user coordinates, (ndcx,ndcy) in normalized coordinates, (apx, apy) are in absolute pixel coordinates. Conversion; TPad’s Methods; Returns. NDC to Pixel; UtoPixel(ndcx); VtoPixel(ndcy); Int_t; Int_t. Pixel to User; PixeltoX(px); PixeltoY(py); PixeltoXY(px,py,&ux,&uy); Double_t; Double_t; Double_t ux,uy. User to Pixel; XtoPixel(ux); YtoPixel(uy); XYtoPixel(ux,uy,&px,&py); Int_t; Int_t; Int_t px,py. User to absolute pixel; XtoAbsPixel(ux); YtoAbsPixel(uy); XYtoAbsPixel(ux,uy,&apx,&apy); Int_t; Int_t; Int_t apx,apy. Absolute pixel to user; AbsPixeltoX(apx); AbsPixeltoY(apy); AbsPixeltoXY(apx,apy,&ux,&uy); Double_t; Double_t; Double_t ux,uy. Note: all the pixel conversion functions along the Y axis consider that py=0 is at the top of the pad except PixeltoY() which assume that the position py=0 is at the bottom of the pad. To make PixeltoY() converting the same way as the other conversion functions, it should be used the following way (p is a pointer to a TPad):; p->PixeltoY(py - p->GetWh());; 9.3.4 Dividing a Pad into Sub-pads; Dividing a pad into sub pads in order for instance to draw a few histograms, may be done in two ways. The first is to build pad objects and to draw them into a parent pad, which may be a canvas. The second is to automatically divide a pad into horizontal and vertical sub pads.; 9.3.4.1 Creating a Single Sub-pad; The simplest way to divide a pad is to build sub-pads in it. However, this forces the user to explicitly indicate the size and position of those sub-pads. Suppose we want to build a sub-pad in the active pad (pointed by gPad). ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:311160,ux,ux,311160,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['ux'],['ux']
Usability,"ffer. ;  ; virtual Bool_t CanExtendAllAxes () const;  Returns true if all axes are extendable. ;  ; virtual Double_t Chi2Test (const TH1 *h2, Option_t *option=""UU"", Double_t *res=nullptr) const;  \( \chi^{2} \) test for comparing weighted and unweighted histograms. ;  ; virtual Double_t Chi2TestX (const TH1 *h2, Double_t &chi2, Int_t &ndf, Int_t &igood, Option_t *option=""UU"", Double_t *res=nullptr) const;  The computation routine of the Chisquare test. ;  ; virtual Double_t Chisquare (TF1 *f1, Option_t *option="""") const;  Compute and return the chisquare of this histogram with respect to a function The chisquare is computed by weighting each histogram point by the bin error By default the full range of the histogram is used. ;  ; virtual void ClearUnderflowAndOverflow ();  Remove all the content from the underflow and overflow bins, without changing the number of entries After calling this method, every undeflow and overflow bins will have content 0.0 The Sumw2 is also cleared, since there is no more content in the bins. ;  ; TObject * Clone (const char *newname="""") const override;  Make a complete copy of the underlying object. ;  ; virtual Double_t ComputeIntegral (Bool_t onlyPositive=false);  Compute integral (normalized cumulative sum of bins) w/o under/overflows The result is stored in fIntegral and used by the GetRandom functions. ;  ; virtual void DirectoryAutoAdd (TDirectory *);  Perform the automatic addition of the histogram to the given directory. ;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Compute distance from point px,py to a line. ;  ; virtual Bool_t Divide (const TH1 *h1);  Divide this histogram by h1. ;  ; virtual Bool_t Divide (const TH1 *h1, const TH1 *h2, Double_t c1=1, Double_t c2=1, Option_t *option="""");  Replace contents of this histogram by the division of h1 by h2. ;  ; virtual Bool_t Divide (TF1 *f1, Double_t c1=1);  Performs the operation: this = this/(c1*f1) if errors are defined (see TH1::Sumw2), errors are also recalc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1C.html:3940,clear,cleared,3940,doc/master/classTH1C.html,https://root.cern,https://root.cern/doc/master/classTH1C.html,7,['clear'],['cleared']
Usability,"ffer. ;  ; virtual Bool_t CanExtendAllAxes () const;  Returns true if all axes are extendable. ;  ; virtual Double_t Chi2Test (const TH1 *h2, Option_t *option=""UU"", Double_t *res=nullptr) const;  \( \chi^{2} \) test for comparing weighted and unweighted histograms. ;  ; virtual Double_t Chi2TestX (const TH1 *h2, Double_t &chi2, Int_t &ndf, Int_t &igood, Option_t *option=""UU"", Double_t *res=nullptr) const;  The computation routine of the Chisquare test. ;  ; virtual Double_t Chisquare (TF1 *f1, Option_t *option="""") const;  Compute and return the chisquare of this histogram with respect to a function The chisquare is computed by weighting each histogram point by the bin error By default the full range of the histogram is used. ;  ; virtual void ClearUnderflowAndOverflow ();  Remove all the content from the underflow and overflow bins, without changing the number of entries After calling this method, every undeflow and overflow bins will have content 0.0 The Sumw2 is also cleared, since there is no more content in the bins. ;  ; TObject * Clone (const char *newname="""") const override;  Make a complete copy of the underlying object. ;  ; virtual Double_t ComputeIntegral (Bool_t onlyPositive=false);  Compute integral (normalized cumulative sum of bins) w/o under/overflows The result is stored in fIntegral and used by the GetRandom functions. ;  ; void Copy (TObject &hnew) const override;  Copy this histogram structure to newth1. ;  ; virtual void DirectoryAutoAdd (TDirectory *);  Perform the automatic addition of the histogram to the given directory. ;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Compute distance from point px,py to a line. ;  ; virtual Bool_t Divide (const TH1 *h1);  Divide this histogram by h1. ;  ; virtual Bool_t Divide (const TH1 *h1, const TH1 *h2, Double_t c1=1, Double_t c2=1, Option_t *option="""");  Replace contents of this histogram by the division of h1 by h2. ;  ; virtual Bool_t Divide (TF1 *f1, Double_t c1=1);  Performs the oper",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:26640,clear,cleared,26640,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['clear'],['cleared']
Usability,"fference_type = ptrdiff_t;  ; using iterator = T *;  ; using pointer = T *;  ; using reference = T &;  ; using reverse_iterator = std::reverse_iterator< iterator >;  ; using size_type = size_t;  ; using value_type = T;  ;  Public Types inherited from ROOT::Internal::VecOps::SmallVectorBase; using Size_T = int32_t;  . Public Member Functions;  RVecImpl (const RVecImpl &)=delete;  ;  ~RVecImpl ();  ; template<typename in_iter , typename = typename std::enable_if<std::is_convertible< typename std::iterator_traits<in_iter>::iterator_category, std::input_iterator_tag>::value>::type> ; void append (in_iter in_start, in_iter in_end);  Add the specified range to the end of the SmallVector. ;  ; void append (size_type NumInputs, const T &Elt);  Append NumInputs copies of Elt to the end. ;  ; void append (std::initializer_list< T > IL);  ; template<typename in_iter , typename = typename std::enable_if<std::is_convertible< typename std::iterator_traits<in_iter>::iterator_category, std::input_iterator_tag>::value>::type> ; void assign (in_iter in_start, in_iter in_end);  ; void assign (size_type NumElts, const T &Elt);  ; void assign (std::initializer_list< T > IL);  ; void clear ();  ; template<typename... ArgTypes> ; reference emplace_back (ArgTypes &&...Args);  ; iterator erase (const_iterator CI);  ; iterator erase (const_iterator CS, const_iterator CE);  ; iterator insert (iterator I, const T &Elt);  ; template<typename ItTy , typename = typename std::enable_if<std::is_convertible< typename std::iterator_traits<ItTy>::iterator_category, std::input_iterator_tag>::value>::type> ; iterator insert (iterator I, ItTy From, ItTy To);  ; iterator insert (iterator I, size_type NumToInsert, const T &Elt);  ; void insert (iterator I, std::initializer_list< T > IL);  ; iterator insert (iterator I, T &&Elt);  ; RVecImpl & operator= (const RVecImpl &RHS);  ; RVecImpl & operator= (RVecImpl &&RHS);  ; void pop_back_n (size_type NumItems);  ; T pop_back_val ();  ; void reserve (size_type N",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Detail_1_1VecOps_1_1RVecImpl.html:2299,clear,clear,2299,doc/master/classROOT_1_1Detail_1_1VecOps_1_1RVecImpl.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Detail_1_1VecOps_1_1RVecImpl.html,1,['clear'],['clear']
Usability,"fferent sequences..); 137 Bool_t color = kFALSE;; 138 Bool_t drawProgressBar = kFALSE;; 139#else; 140 Bool_t color = !gROOT->IsBatch();; 141 Bool_t drawProgressBar = kTRUE;; 142#endif; 143 DeclareOptionRef(fVerbose, ""V"", ""Verbose flag"");; 144 DeclareOptionRef(fVerboseLevel = TString(""Info""), ""VerboseLevel"", ""VerboseLevel (Debug/Verbose/Info)"");; 145 AddPreDefVal(TString(""Debug""));; 146 AddPreDefVal(TString(""Verbose""));; 147 AddPreDefVal(TString(""Info""));; 148 DeclareOptionRef(color, ""Color"", ""Flag for coloured screen output (default: True, if in batch mode: False)"");; 149 DeclareOptionRef(; 150 fTransformations, ""Transformations"",; 151 ""List of transformations to test; formatting example: \""Transformations=I;D;P;U;G,D\"", for identity, ""; 152 ""decorrelation, PCA, Uniform and Gaussianisation followed by decorrelation transformations"");; 153 DeclareOptionRef(fCorrelations, ""Correlations"", ""boolean to show correlation in output"");; 154 DeclareOptionRef(fROC, ""ROC"", ""boolean to show ROC in output"");; 155 DeclareOptionRef(silent, ""Silent"",; 156 ""Batch mode: boolean silent flag inhibiting any output from TMVA after the creation of the factory ""; 157 ""class object (default: False)"");; 158 DeclareOptionRef(drawProgressBar, ""DrawProgressBar"",; 159 ""Draw progress bar to display training, testing and evaluation schedule (default: True)"");; 160 DeclareOptionRef(fModelPersistence, ""ModelPersistence"",; 161 ""Option to save the trained model in xml file or using serialization"");; 162 ; 163 TString analysisType(""Auto"");; 164 DeclareOptionRef(analysisType, ""AnalysisType"",; 165 ""Set the analysis type (Classification, Regression, Multiclass, Auto) (default: Auto)"");; 166 AddPreDefVal(TString(""Classification""));; 167 AddPreDefVal(TString(""Regression""));; 168 AddPreDefVal(TString(""Multiclass""));; 169 AddPreDefVal(TString(""Auto""));; 170 ; 171 ParseOptions();; 172 CheckForUnusedOptions();; 173 ; 174 if (Verbose()); 175 fLogger->SetMinType(kVERBOSE);; 176 if (fVerboseLevel.CompareTo(""Debug"") ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:6325,progress bar,progress bar,6325,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['progress bar'],['progress bar']
Usability,"fferent sequences..); 227 Bool_t color = kFALSE;; 228 Bool_t drawProgressBar = kFALSE;; 229#else; 230 Bool_t color = !gROOT->IsBatch();; 231 Bool_t drawProgressBar = kTRUE;; 232#endif; 233 DeclareOptionRef(fVerbose, ""V"", ""Verbose flag"");; 234 DeclareOptionRef(fVerboseLevel = TString(""Info""), ""VerboseLevel"", ""VerboseLevel (Debug/Verbose/Info)"");; 235 AddPreDefVal(TString(""Debug""));; 236 AddPreDefVal(TString(""Verbose""));; 237 AddPreDefVal(TString(""Info""));; 238 DeclareOptionRef(color, ""Color"", ""Flag for coloured screen output (default: True, if in batch mode: False)"");; 239 DeclareOptionRef(; 240 fTransformations, ""Transformations"",; 241 ""List of transformations to test; formatting example: \""Transformations=I;D;P;U;G,D\"", for identity, ""; 242 ""decorrelation, PCA, Uniform and Gaussianisation followed by decorrelation transformations"");; 243 DeclareOptionRef(fCorrelations, ""Correlations"", ""boolean to show correlation in output"");; 244 DeclareOptionRef(fROC, ""ROC"", ""boolean to show ROC in output"");; 245 DeclareOptionRef(silent, ""Silent"",; 246 ""Batch mode: boolean silent flag inhibiting any output from TMVA after the creation of the factory ""; 247 ""class object (default: False)"");; 248 DeclareOptionRef(drawProgressBar, ""DrawProgressBar"",; 249 ""Draw progress bar to display training, testing and evaluation schedule (default: True)"");; 250 DeclareOptionRef(fModelPersistence, ""ModelPersistence"",; 251 ""Option to save the trained model in xml file or using serialization"");; 252 ; 253 TString analysisType(""Auto"");; 254 DeclareOptionRef(analysisType, ""AnalysisType"",; 255 ""Set the analysis type (Classification, Regression, Multiclass, Auto) (default: Auto)"");; 256 AddPreDefVal(TString(""Classification""));; 257 AddPreDefVal(TString(""Regression""));; 258 AddPreDefVal(TString(""Multiclass""));; 259 AddPreDefVal(TString(""Auto""));; 260 ; 261 ParseOptions();; 262 CheckForUnusedOptions();; 263 ; 264 if (Verbose()); 265 fLogger->SetMinType(kVERBOSE);; 266 if (fVerboseLevel.CompareTo(""Debug"") ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:10235,progress bar,progress bar,10235,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['progress bar'],['progress bar']
Usability,"fficiency object does not; belong to any directory and will not be written to file during the; next TFile::Write() command. void SetName(const char* name); sets the name. Note: The names of the internal histograms are set to ""name + _total"" and; ""name + _passed"" respectively. Bool_t SetPassedEvents(Int_t bin, Int_t events); sets the number of passed events in the given global bin. returns ""true"" if the number of passed events has been updated; otherwise ""false"" ist returned. Note: - requires: 0 <= events <= fTotalHistogram->GetBinContent(bin). Bool_t SetPassedHistogram(const TH1& rPassed, Option_t* opt); sets the histogram containing the passed events. The given histogram is cloned and stored internally as histogram containing; the passed events. The given histogram has to be consistent with the current; fTotalHistogram (see CheckConsistency(const TH1&,const TH1&)).; The method returns whether the fPassedHistogram has been replaced (true) or; not (false). Note: The list of associated functions fFunctions is cleared. Option: - ""f"": force the replacement without checking the consistency; This can lead to inconsistent histograms and useless results; or unexpected behaviour. But sometimes it might be the only; way to change the histograms. If you use this option, you; should ensure that the fTotalHistogram is replaced by a; consistent one (with respect to rPassed) as well. void SetStatisticOption(TEfficiency::EStatOption option); sets the statistic option which affects the calculation of the confidence interval. Options:; - kFCP (=0)(default): using the Clopper-Pearson interval (recommended by PDG); sets kIsBayesian = false; see also ClopperPearson; - kFNormal (=1) : using the normal approximation; sets kIsBayesian = false; see also Normal; - kFWilson (=2) : using the Wilson interval; sets kIsBayesian = false; see also Wilson; - kFAC (=3) : using the Agresti-Coull interval; sets kIsBayesian = false; see also AgrestiCoull; - kFFC (=4) : using the Feldman-Cousins frequent",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEfficiency.html:63101,clear,cleared,63101,root/html532/TEfficiency.html,https://root.cern,https://root.cern/root/html532/TEfficiency.html,8,['clear'],['cleared']
Usability,"ffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearRange(const char* name, Bool_t silent); voidRooAbsArg::clearShapeDirty() const; voidclearTypes(); voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCategory.html:2190,clear,clearValueAndShapeDirty,2190,root/html534/RooCategory.html,https://root.cern,https://root.cern/root/html534/RooCategory.html,2,['clear'],['clearValueAndShapeDirty']
Usability,"ffset(UInt_t offset, Int_t column); {((tableDescriptor_st *)At(column))->fOffset = offset;}. void SetSize(UInt_t size, Int_t column); {((tableDescriptor_st *)At(column))->fSize = size; }. void SetTypeSize(UInt_t size, Int_t column); {((tableDescriptor_st *)At(column))->fTypeSize = size; }. void SetDimensions(UInt_t dim, Int_t column); {((tableDescriptor_st *)At(column))->fDimensions = dim; }. void SetColumnType(TTable::EColumnType type, Int_t column); {((tableDescriptor_st *)At(column))->fType = type; }. void Init(TClass* classPtr). void SetCommentsSetName(const char* name = "".comments""). TTableDescriptor(const TTable* parentTable). TTableDescriptor(TClass* classPtr). TTableDescriptor(const TTableDescriptor& dsc); {}. virtual ~TTableDescriptor(). Int_t AddAt(const void* c). void AddAt(const void* c, Int_t i). void AddAt(const tableDescriptor_st& element, const char* comment, Int_t indx). void AddAt(TDataSet* dataset, Int_t idx = 0). TString CreateLeafList() const. void LearnTable(const TTable* parentTable). void LearnTable(TClass* classPtr). Int_t ColumnByName(const Char_t* columnName = 0) const. UInt_t Offset(Int_t column) const. UInt_t ColumnSize(Int_t column) const. UInt_t TypeSize(Int_t column) const. UInt_t Dimensions(Int_t column) const. Int_t Sizeof() const. Int_t UpdateOffsets(const TTableDescriptor* newDesciptor). TTableDescriptor * MakeDescriptor(const char* structName). TDataSet * MakeCommentField(Bool_t createFlag = kTRUE). TTableDescriptor * GetDescriptorPointer() const. void SetDescriptorPointer(TTableDescriptor* list). TTableDescriptor(); {SetType(""tableDescriptor_st"");}. TTableDescriptor(const char* name); {SetType(""tableDescriptor_st"");}. TTableDescriptor(Int_t n); {SetType(""tableDescriptor_st"");}. TTableDescriptor(const char* name, Int_t n); {SetType(""tableDescriptor_st"");}. tableDescriptor_st * GetTable(Int_t i = 0) const; { return ((tableDescriptor_st *)GetArray())+i;}. tableDescriptor_st & operator[](Int_t i); { assert(i>=0 && i < GetNRows()); r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTableDescriptor.html:17447,Learn,LearnTable,17447,root/html532/TTableDescriptor.html,https://root.cern,https://root.cern/root/html532/TTableDescriptor.html,1,['Learn'],['LearnTable']
Usability,"ffset=452, len=8, method=0; i=10, fContour type= 62, offset=516, len=1, method=1081287804; i=11, fSumw2 type= 62, offset=528, len=1, method=1081287924; i=12, fOption type= 65, offset=540, len=1, method=1081288044; i=13, fFunctions type= 63, offset=548, len=1, method=1081288164; 11.5.4 Optimized StreamerInfo; The entries starting with “i = 0” is the optimized format of the StreamerInfo. Consecutive data members of the same simple type and size are collapsed and read at once into an array for performance optimization.; i= 0, TNamed type= 67, offset= 0, len=1, method=0; i= 1, TAttLine type= 0, offset= 28, len=1, method=142484480; i= 2, TAttFill type= 0, offset= 40, len=1, method=142496992; i= 3, TAttMarker type= 0, offset= 48, len=1, method=142509704; For example, the five data members beginning with fEntiesand the three data members beginning with fMaximum, are put into an array called fEntries (i = 9) with the length 8.; i= 9, fEntries type= 28, offset=452, len=8, method=0; Only simple type data members are combined, object data members are not combined. For example the three axis data members remain separate. The “method” is a handle to the method that reads the object.; 11.5.5 Automatic Schema Evolution; When a class is defined in ROOT, it must include the ClassDef macro as the last line in the header file inside the class definition. The syntax is:; ClassDef(<ClassName>,<VersionNumber>); The version number identifies this particular version of the class. When a class has version 0 it is not stored in a root file but its base class(es) is(are). The reason can be that this class has no data members worth saving or all real info is in the base classes. The version number is written to the file in the Streamer by the call TBuffer::WriteVersion. You, as the designer of the class, do not need to do any manual modification in the Streamer. ROOT schema evolution mechanism is automatic and handled by the StreamerInfo.; 11.5.6 Manual Data Model Evolution Capabilities; The au",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:497135,simpl,simple,497135,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled; static TGMainFrame::(anonymous)TGMainFrame::kDontCallClose. private:. TGTextButton*fCloseOK button; TGLayoutHints*fL1layout of TGTextEdit; TGLayoutHints*fL2layout of OK button; TGTextView*fTextViewText view widget; TSessionViewer*fViewerpointer on main viewer. Class Charts. Inheritance Chart:. TObject. ←; TGObject. ←; TGWindow. TQObject. ←; TGFrame. ←; TGCompositeFrame. ←; TGMainFrame. ←; TGTransientFrame. ←; TSessionLogView. Function documentation; TSessionLogView(TSessionViewer* viewer, UInt_t w, UInt_t h); Create an editor in a dialog. ~TSessionLogView(). void SetTitle(); Set title in editor window. void Popup(); Show editor. void AddBuffer(const char* buffer); Load a text buffer in the editor. void ClearLogView(); Clear log window. void LoadBuffer(const char* buffer); Load a text buffer in the editor. void LoadFile(const char* file); Load a file in the editor. void CloseWindow(); Called when closed via window manager action. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process OK button. TSessionLogView(TSessionViewer* viewer, UInt_t w, UInt_t h). » Author: Bertrand Bellenot, Gerri Ganis 15/09/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id$ » Last generated: 2015-06-02 16:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TSessionLogView.html:23862,Clear,ClearLogView,23862,root/html604/TSessionLogView.html,https://root.cern,https://root.cern/root/html604/TSessionLogView.html,2,['Clear'],"['Clear', 'ClearLogView']"
Usability,"fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled; static TGMainFrame::(anonymous)TGMainFrame::kDontCallClose. private:. TGTextButton*fCloseOK button; TGLayoutHints*fL1layout of TGTextEdit; TGLayoutHints*fL2layout of OK button; TGTextView*fTextViewText view widget; TSessionViewer*fViewerpointer on main viewer. Class Charts. Inheritance Chart:. TObject. ←; TGObject. ←; TGWindow. TQObject. ←; TGFrame. ←; TGCompositeFrame. ←; TGMainFrame. ←; TGTransientFrame. ←; TSessionLogView. Function documentation; TSessionLogView(TSessionViewer* viewer, UInt_t w, UInt_t h); Create an editor in a dialog. ~TSessionLogView(). void SetTitle(); Set title in editor window. void Popup(); Show editor. void AddBuffer(const char* buffer); Load a text buffer in the editor. void ClearLogView(); Clear log window. void LoadBuffer(const char* buffer); Load a text buffer in the editor. void LoadFile(const char* file); Load a file in the editor. void CloseWindow(); Called when closed via window manager action. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process OK button. TSessionLogView(TSessionViewer* viewer, UInt_t w, UInt_t h). » Author: Bertrand Bellenot, Gerri Ganis 15/09/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id$ » Last generated: 2015-06-30 15:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSessionLogView.html:23862,Clear,ClearLogView,23862,root/html602/TSessionLogView.html,https://root.cern,https://root.cern/root/html602/TSessionLogView.html,2,['Clear'],"['Clear', 'ClearLogView']"
Usability,"fgInit = kFALSE;  ; static UInt_t fgLastButton = 0;  ; static Time_t fgLastClick = 0;  ; static const TGGC * fgShadowGC = nullptr;  ; static UInt_t fgUserColor = 0;  ; static const TGGC * fgWhiteGC = nullptr;  ; static Pixel_t fgWhitePixel = 0;  ;  Static Protected Attributes inherited from TGWindow; static Int_t fgCounter = 0;  counter of created windows in SavePrimitive ;  ;  Static Protected Attributes inherited from TQObject; static Bool_t fgAllSignalsBlocked = kFALSE;  flag used for suppression of signals ;  . #include <TGDockableFrame.h>. Inheritance diagram for TGUndockedFrame:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGUndockedFrame() [1/2]. TGUndockedFrame::TGUndockedFrame ; (; const TGUndockedFrame & ; ). privatedelete . ◆ TGUndockedFrame() [2/2]. TGUndockedFrame::TGUndockedFrame ; (; const TGWindow * ; p = nullptr, . TGDockableFrame * ; dockable = nullptr . ). Create the undocked (transient) frame. ; Definition at line 176 of file TGDockableFrame.cxx. ◆ ~TGUndockedFrame(). TGUndockedFrame::~TGUndockedFrame ; (; ). override . Delete undocked frame. Puts back dockable frame in its original container. ; Definition at line 193 of file TGDockableFrame.cxx. Member Function Documentation. ◆ Class(). static TClass * TGUndockedFrame::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGUndockedFrame::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGUndockedFrame::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 78 of file TGDockableFrame.h. ◆ CloseWindow(). void TGUndockedFrame::CloseWindow ; (; ). overridevirtual . Close undocked frame (called via WM close button). ; Reimplemented from TGMainFrame.; Definition at line 213 of file TGDockableFrame.cxx. ◆ DeclFileName(). static const char * TGUndockedFrame::DeclFileName ; (; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGUndockedFrame.html:36688,undo,undocked,36688,doc/master/classTGUndockedFrame.html,https://root.cern,https://root.cern/doc/master/classTGUndockedFrame.html,1,['undo'],['undocked']
Usability,"fication based on Bayesian posterior probability. . Introduction. Neural Networks are more and more used in various fields for data; analysis and classification, both for research and commercial; institutions. Some randomly chosen examples are:. image analysis; financial movements predictions and analysis; sales forecast and product shipping optimisation; in particles physics: mainly for classification tasks (signal; over background discrimination). More than 50% of neural networks are multilayer perceptrons. This; implementation of multilayer perceptrons is inspired from the; MLPfit; package originaly written by Jerome Schwindling. MLPfit remains; one of the fastest tool for neural networks studies, and this ROOT; add-on will not try to compete on that. A clear and flexible Object; Oriented implementation has been chosen over a faster but more; difficult to maintain code. Nevertheless, the time penalty does not; exceed a factor 2. The; MLP. The multilayer perceptron is a simple feed-forward network with; the following structure:. It is made of neurons characterized by a bias and weighted links; between them (let's call those links synapses). The input neurons; receive the inputs, normalize them and forward them to the first; hidden layer. Each neuron in any subsequent layer first computes a linear; combination of the outputs of the previous layer. The output of the; neuron is then function of that combination with f being; linear for output neurons or a sigmoid for hidden layers. This is; useful because of two theorems:. A linear combination of sigmoids can approximate any; continuous function.; Trained with output = 1 for the signal and 0 for the; background, the approximated function of inputs X is the probability; of signal, knowing X. Learning; methods. The aim of all learning methods is to minimize the total error on; a set of weighted examples. The error is defined as the sum in; quadrature, devided by two, of the error on each individual output; neuron.; In a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMultiLayerPerceptron.html:2727,simpl,simple,2727,root/html534/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html534/TMultiLayerPerceptron.html,6,['simpl'],['simple']
Usability,"fied connection. ; Parameters. connidconnection id, when 0 - data will be send to all connections ; datapointer to binary data ; lennumber of bytes in data . Definition at line 1630 of file RWebWindow.cxx. ◆ SendBinary() [2/2]. void RWebWindow::SendBinary ; (; unsigned ; connid, . std::string && ; data . ). Send binary data to specified connection. ; Parameters. connidconnection id, when 0 - data will be send to all connections ; datadata to be std-moved to SubmitData function . Definition at line 1619 of file RWebWindow.cxx. ◆ SetCallBacks(). void RWebWindow::SetCallBacks ; (; WebWindowConnectCallback_t ; conn, . WebWindowDataCallback_t ; data, . WebWindowConnectCallback_t ; disconn = nullptr . ). Set call-backs function for connect, data and disconnect events. ; Definition at line 1772 of file RWebWindow.cxx. ◆ SetClearOnClose(). void RWebWindow::SetClearOnClose ; (; const std::shared_ptr< void > & ; handle = nullptr). Set handle which is cleared when last active connection is closed Typically can be used to destroy web-based widget at such moment. ; Definition at line 1764 of file RWebWindow.cxx. ◆ SetClientVersion(). void RWebWindow::SetClientVersion ; (; const std::string & ; vers). Set client version, used as prefix in scripts URL When changed, web browser will reload all related JS files while full URL will be different Default is empty value - no extra string in URL Version should be string like ""1.2"" or ""ver1.subv2"" and not contain any special symbols. ; Definition at line 1289 of file RWebWindow.cxx. ◆ SetConnectCallBack(). void RWebWindow::SetConnectCallBack ; (; WebWindowConnectCallback_t ; func). Set call-back function for new connection. ; Definition at line 1743 of file RWebWindow.cxx. ◆ SetConnLimit(). void RWebWindow::SetConnLimit ; (; unsigned ; lmt = 0). Configure maximal number of allowed connections - 0 is unlimited Will not affect already existing connections Default is 1 - the only client is allowed. ; Definition at line 693 of file RWebWindow",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:42565,clear,cleared,42565,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,1,['clear'],['cleared']
Usability,"fied connection. ; Parameters. connidconnection id, when 0 - data will be send to all connections ; datapointer to binary data ; lennumber of bytes in data . Definition at line 1672 of file RWebWindow.cxx. ◆ SendBinary() [2/2]. void RWebWindow::SendBinary ; (; unsigned ; connid, . std::string && ; data . ). Send binary data to specified connection. ; Parameters. connidconnection id, when 0 - data will be send to all connections ; datadata to be std-moved to SubmitData function . Definition at line 1661 of file RWebWindow.cxx. ◆ SetCallBacks(). void RWebWindow::SetCallBacks ; (; WebWindowConnectCallback_t ; conn, . WebWindowDataCallback_t ; data, . WebWindowConnectCallback_t ; disconn = nullptr . ). Set call-backs function for connect, data and disconnect events. ; Definition at line 1814 of file RWebWindow.cxx. ◆ SetClearOnClose(). void RWebWindow::SetClearOnClose ; (; const std::shared_ptr< void > & ; handle = nullptr). Set handle which is cleared when last active connection is closed Typically can be used to destroy web-based widget at such moment. ; Definition at line 1806 of file RWebWindow.cxx. ◆ SetClientVersion(). void RWebWindow::SetClientVersion ; (; const std::string & ; vers). Set client version, used as prefix in scripts URL When changed, web browser will reload all related JS files while full URL will be different Default is empty value - no extra string in URL Version should be string like ""1.2"" or ""ver1.subv2"" and not contain any special symbols. ; Definition at line 1331 of file RWebWindow.cxx. ◆ SetConnectCallBack(). void RWebWindow::SetConnectCallBack ; (; WebWindowConnectCallback_t ; func). Set call-back function for new connection. ; Definition at line 1785 of file RWebWindow.cxx. ◆ SetConnLimit(). void RWebWindow::SetConnLimit ; (; unsigned ; lmt = 0). Configure maximal number of allowed connections - 0 is unlimited Will not affect already existing connections Default is 1 - the only client is allowed. ; Definition at line 694 of file RWebWindow",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindow.html:41449,clear,cleared,41449,doc/master/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindow.html,1,['clear'],['cleared']
Usability,"fiers:. %txt : to print the text label associated with the slice. %val : to print the numeric value of the slice. %frac : to print the relative fraction of this slice. %perc : to print the % of this slice. mypie->SetLabelFormat(""%txt (%frac)"");; See the macro $ROOTSYS/tutorials/graphics/piechart.C . The picture generated by tutorial macro piechart.C. 3.21 The User Interface for Histograms; The classes T H1 Editor and T H2 Editor provides the user interface for setting histogram’s attributes and rebinning interactively.; 3.21.1 TH1Editor. 3.21.1.1 The Style Tab; 3.21.1.1.1 Title; sets the title of the histogram.; 3.21.1.1.2 Plot; draw a 2D or 3D plot; according to the dimension, different drawing possibilities can be set.; 3.21.1.1.3 Error; add different error bars to the histogram (no errors, simple, etc.).; 3.21.1.1.4 Add; further things which can be added to the histogram (None, simple/smooth line, fill area, etc.); 3.21.1.2 2-D Plot; 3.21.1.2.1 Simple Drawing; draw a simple histogram without errors (= “HIST” draw option). In combination with some other draw options an outer line is drawn on top of the histogram; 3.21.1.2.2 Show markers; draw a marker on to of each bin (=“P” draw option).; 3.21.1.2.3 Draw bar chart; draw a bar chart (=“B” draw option).; 3.21.1.2.4 Bar option; draw a bar chart (=“BAR” draw option); if selected, it will show an additional interface elements for bars: width, offset, percentage and the possibility to draw horizontal bars.; 3.21.1.3 3-D Plot; 3.21.1.3.1 Add; set histogram type Lego-Plot or Surface draw (Lego, Lego1.2, Surf, Surf1…5).; 3.21.1.3.2 Coords; set the coordinate system (Cartesian, Spheric, etc.).; 3.21.1.3.3 Error; same as for 2D plot.; 3.21.1.3.4 Bar; set the bar attributes: width and offset.; 3.21.1.3.5 Horizontal Bar; draw a horizontal bar chart.; 3.21.1.4 The Binning tab; The binning tab has two different layouts. One is for a histogram, which is not drawn from an ntuple. The other one is available for a histogram, which ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:135712,simpl,simple,135712,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,3,"['Simpl', 'simpl']","['Simple', 'simple']"
Usability,file NeuralNet.h. ◆ endTestCycle(). virtual void TMVA::DNN::Settings::endTestCycle ; (; ). inlinevirtual . callback for monitoring and loggging ; Reimplemented in TMVA::DNN::ClassificationSettings.; Definition at line 805 of file NeuralNet.h. ◆ endTrainCycle(). virtual void TMVA::DNN::Settings::endTrainCycle ; (; double ; ). inlinevirtual . callback for monitoring and logging ; Reimplemented in TMVA::DNN::ClassificationSettings.; Definition at line 788 of file NeuralNet.h. ◆ exists(). bool TMVA::DNN::Settings::exists ; (; std::string ; histoName). inline . for monitoring ; Definition at line 825 of file NeuralNet.h. ◆ factorWeightDecay(). double TMVA::DNN::Settings::factorWeightDecay ; (; ); const. inline . get the weight-decay factor ; Definition at line 769 of file NeuralNet.h. ◆ hasConverged(). bool TMVA::DNN::Settings::hasConverged ; (; double ; testError). virtual . has this training converged already? ; check for convergence; Definition at line 485 of file NeuralNet.cxx. ◆ learningRate(). double TMVA::DNN::Settings::learningRate ; (; ); const. inline . get the learning rate ; Definition at line 771 of file NeuralNet.h. ◆ maxConvergenceCount(). size_t TMVA::DNN::Settings::maxConvergenceCount ; (; ); const. inline . returns the max convergence count so far ; Definition at line 828 of file NeuralNet.h. ◆ minError(). size_t TMVA::DNN::Settings::minError ; (; ); const. inline . returns the smallest error so far ; Definition at line 829 of file NeuralNet.h. ◆ minimizerType(). MinimizerType TMVA::DNN::Settings::minimizerType ; (; ); const. inline . which minimizer shall be used (e.g. SGD) ; Definition at line 774 of file NeuralNet.h. ◆ momentum(). double TMVA::DNN::Settings::momentum ; (; ); const. inline . get the momentum (e.g. for SGD) ; Definition at line 772 of file NeuralNet.h. ◆ pads(). void TMVA::DNN::Settings::pads ; (; int ; numPads). inline . preparation for monitoring ; Definition at line 818 of file NeuralNet.h. ◆ plot(). void TMVA::DNN::Settings::plot ;,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html:9000,learn,learningRate,9000,doc/master/classTMVA_1_1DNN_1_1Settings.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html,1,['learn'],['learningRate']
Usability,"file RWebWindow.hxx. Constructor & Destructor Documentation. ◆ RWebWindow(). RWebWindow::RWebWindow ; (; ). RWebWindow constructor Should be defined here because of std::unique_ptr<RWebWindowWSHandler> ; Definition at line 76 of file RWebWindow.cxx. ◆ ~RWebWindow(). RWebWindow::~RWebWindow ; (; ). RWebWindow destructor Closes all connections and remove window from manager. ; Definition at line 85 of file RWebWindow.cxx. Member Function Documentation. ◆ _CanTrustIn(). bool RWebWindow::_CanTrustIn ; (; std::shared_ptr< WebConn > & ; conn, . const std::string & ; hash, . const std::string & ; ntry, . bool ; remote, . bool ; test_first_time . ). private . Check if provided hash, ntry parameters from the connection request could be accepted. ; Parameters. hash- provided hash value which should match with HMAC hash for generated before connection key ; ntry- connection attempt number provided together with request, must come in increasing order ; remote- boolean flag indicating if request comming from remote (via real http), for local displays like Qt5 or CEF simpler connection rules are applied ; test_first_time- true if hash/ntry tested for the first time, false appears only with websocket when connection accepted by server . Definition at line 513 of file RWebWindow.cxx. ◆ _MakeSendHeader(). std::string RWebWindow::_MakeSendHeader ; (; std::shared_ptr< WebConn > & ; conn, . bool ; txt, . const std::string & ; data, . int ; chid . ). private . Internal method to prepare text part of send data Should be called under locked connection mutex. ; Definition at line 1107 of file RWebWindow.cxx. ◆ AddDisplayHandle(). unsigned RWebWindow::AddDisplayHandle ; (; bool ; headless_mode, . const std::string & ; key, . std::unique_ptr< RWebDisplayHandle > & ; handle . ). private . Add display handle and associated key Key is large random string generated when starting new window When client is connected, key should be supplied to correctly identify it. ; Definition at line 482 of file ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:23318,simpl,simpler,23318,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,1,['simpl'],['simpler']
Usability,"file RWebWindow.hxx. Constructor & Destructor Documentation. ◆ RWebWindow(). RWebWindow::RWebWindow ; (; ). RWebWindow constructor Should be defined here because of std::unique_ptr<RWebWindowWSHandler> ; Definition at line 76 of file RWebWindow.cxx. ◆ ~RWebWindow(). RWebWindow::~RWebWindow ; (; ). RWebWindow destructor Closes all connections and remove window from manager. ; Definition at line 85 of file RWebWindow.cxx. Member Function Documentation. ◆ _CanTrustIn(). bool RWebWindow::_CanTrustIn ; (; std::shared_ptr< WebConn > & ; conn, . const std::string & ; hash, . const std::string & ; ntry, . bool ; remote, . bool ; test_first_time . ). private . Check if provided hash, ntry parameters from the connection request could be accepted. ; Parameters. hash- provided hash value which should match with HMAC hash for generated before connection key ; ntry- connection attempt number provided together with request, must come in increasing order ; remote- boolean flag indicating if request comming from remote (via real http), for local displays like Qt5 or CEF simpler connection rules are applied ; test_first_time- true if hash/ntry tested for the first time, false appears only with websocket when connection accepted by server . Definition at line 514 of file RWebWindow.cxx. ◆ _MakeSendHeader(). std::string RWebWindow::_MakeSendHeader ; (; std::shared_ptr< WebConn > & ; conn, . bool ; txt, . const std::string & ; data, . int ; chid . ). private . Internal method to prepare text part of send data Should be called under locked connection mutex. ; Definition at line 1140 of file RWebWindow.cxx. ◆ AddDisplayHandle(). unsigned RWebWindow::AddDisplayHandle ; (; bool ; headless_mode, . const std::string & ; key, . std::unique_ptr< RWebDisplayHandle > & ; handle . ). private . Add display handle and associated key Key is large random string generated when starting new window When client is connected, key should be supplied to correctly identify it. ; Definition at line 483 of file ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindow.html:22921,simpl,simpler,22921,doc/master/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindow.html,1,['simpl'],['simpler']
Usability,"file RooTreeDataStore.cxx. ◆ attachBuffers(). void RooTreeDataStore::attachBuffers ; (; const RooArgSet & ; extObs). overridevirtual . Implements RooAbsDataStore.; Definition at line 1036 of file RooTreeDataStore.cxx. ◆ attachCache(). void RooTreeDataStore::attachCache ; (; const RooAbsArg * ; newOwner, . const RooArgSet & ; cachedVars . ). overrideprivatevirtual . Initialize cache of dataset: attach variables of cache ArgSet to the corresponding TTree branches. ; Implements RooAbsDataStore.; Definition at line 229 of file RooTreeDataStore.cxx. ◆ cacheArgs(). void RooTreeDataStore::cacheArgs ; (; const RooAbsArg * ; owner, . RooArgSet & ; newVarSet, . const RooArgSet * ; nset = nullptr, . bool ; skipZeroWeights = false . ). overridevirtual . Cache given RooAbsArgs with this tree: The tree is given direct write access of the args internal cache the args values is pre-calculated for all data points in this data collection. ; Upon a get() call, the internal cache of 'newVar' will be loaded with the precalculated value and it's dirty flag will be cleared. ; Implements RooAbsDataStore.; Definition at line 950 of file RooTreeDataStore.cxx. ◆ cacheOwner(). const RooAbsArg * RooTreeDataStore::cacheOwner ; (; ). inlineoverridevirtual . Implements RooAbsDataStore.; Definition at line 121 of file RooTreeDataStore.h. ◆ changeObservableName(). bool RooTreeDataStore::changeObservableName ; (; const char * ; from, . const char * ; to . ). overridevirtual . Change name of internal observable named 'from' into 'to'. ; Implements RooAbsDataStore.; Definition at line 712 of file RooTreeDataStore.cxx. ◆ checkInit(). void RooTreeDataStore::checkInit ; (; ); const. overridevirtual . Reimplemented from RooAbsDataStore.; Definition at line 1080 of file RooTreeDataStore.cxx. ◆ Class(). static TClass * RooTreeDataStore::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooTreeDataStore::Class_Name ; (; ). static . ReturnsName of this class . ◆ Cl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooTreeDataStore.html:28357,clear,cleared,28357,doc/master/classRooTreeDataStore.html,https://root.cern,https://root.cern/doc/master/classRooTreeDataStore.html,1,['clear'],['cleared']
Usability,"file RooVectorDataStore.cxx. ◆ weight() [1/3]. double RooVectorDataStore::weight ; (; ); const. inlineoverridevirtual . Return the weight of the last-retrieved data point. ; Implements RooAbsDataStore.; Definition at line 111 of file RooVectorDataStore.h. ◆ weight() [2/3]. virtual double RooAbsDataStore::weight ; (; ); const. virtual . Implements RooAbsDataStore. ◆ weight() [3/3]. double RooAbsDataStore::weight ; (; Int_t ; index); const. inline . Definition at line 66 of file RooAbsDataStore.h. ◆ weightError() [1/2]. void RooVectorDataStore::weightError ; (; double & ; lo, . double & ; hi, . RooAbsData::ErrorType ; etype = RooAbsData::Poisson . ); const. overridevirtual . Implements RooAbsDataStore.; Definition at line 425 of file RooVectorDataStore.cxx. ◆ weightError() [2/2]. double RooVectorDataStore::weightError ; (; RooAbsData::ErrorType ; etype = RooAbsData::Poisson); const. overridevirtual . Return the error of the current weight. ; Parameters. [in]etypeSwitch between simple Poisson or sum-of-weights statistics . Implements RooAbsDataStore.; Definition at line 390 of file RooVectorDataStore.cxx. ◆ weightVar(). RooRealVar * RooVectorDataStore::weightVar ; (; const RooArgSet & ; allVars, . const char * ; wgtName . ). private . Utility function for constructors Return pointer to weight variable if it is defined. ; Definition at line 125 of file RooVectorDataStore.cxx. Friends And Related Symbol Documentation. ◆ RooAbsCategory. friend class RooAbsCategory. friend . Definition at line 547 of file RooVectorDataStore.h. ◆ RooAbsReal. friend class RooAbsReal. friend . Definition at line 546 of file RooVectorDataStore.h. ◆ RooRealVar. friend class RooRealVar. friend . Definition at line 548 of file RooVectorDataStore.h. Member Data Documentation. ◆ _cache. RooVectorDataStore* RooVectorDataStore::_cache = nullptr. private . ! Optimization cache ; Definition at line 586 of file RooVectorDataStore.h. ◆ _cacheOwner. RooAbsArg* RooVectorDataStore::_cacheOwner = nullptr. pr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooVectorDataStore.html:38936,simpl,simple,38936,doc/master/classRooVectorDataStore.html,https://root.cern,https://root.cern/doc/master/classRooVectorDataStore.html,1,['simpl'],['simple']
Usability,file TH1Editor.h. ◆ fDim. TGRadioButton* TH1Editor::fDim. protected . 2D-Plot RadioButton ; Definition at line 42 of file TH1Editor.h. ◆ fDim0. TGRadioButton* TH1Editor::fDim0. protected . 3D-Plot RadioButton ; Definition at line 43 of file TH1Editor.h. ◆ fDim0lh. TGLayoutHints* TH1Editor::fDim0lh. protected . layout hints for 3D-Plot RadioButton ; Definition at line 45 of file TH1Editor.h. ◆ fDimGroup. TGHButtonGroup* TH1Editor::fDimGroup. protected . Radiobuttongroup to change 2D <-> 3D-Plot. ; Definition at line 41 of file TH1Editor.h. ◆ fDimlh. TGLayoutHints* TH1Editor::fDimlh. protected . layout hints for 2D-Plot RadioButton ; Definition at line 44 of file TH1Editor.h. ◆ fErrorCombo. TGComboBox* TH1Editor::fErrorCombo. protected . Error combo box. ; Definition at line 48 of file TH1Editor.h. ◆ fHist. TH1* TH1Editor::fHist. protected . histogram object ; Definition at line 36 of file TH1Editor.h. ◆ fHistOnOff. TGCheckButton* TH1Editor::fHistOnOff. protected . Draw a simple histogram with default options. ; Definition at line 49 of file TH1Editor.h. ◆ fMake. Bool_t TH1Editor::fMake. private . Definition at line 95 of file TH1Editor.h. ◆ fMakeB. Bool_t TH1Editor::fMakeB. private . Definition at line 96 of file TH1Editor.h. ◆ fMakeHBar. TGCheckButton* TH1Editor::fMakeHBar. protected . Draw Horizontal Bar Chart. ; Definition at line 54 of file TH1Editor.h. ◆ fOffsetNumberEntry. TGNumberEntryField* TH1Editor::fOffsetNumberEntry. protected . Shows the offset to the origin of the histogram. ; Definition at line 76 of file TH1Editor.h. ◆ fOldOffset. Double_t TH1Editor::fOldOffset. private . Definition at line 114 of file TH1Editor.h. ◆ fP1NDCold. Float_t TH1Editor::fP1NDCold[3]. private . Definition at line 101 of file TH1Editor.h. ◆ fP1old. Float_t TH1Editor::fP1old[3]. private . Definition at line 105 of file TH1Editor.h. ◆ fP2NDCold. Float_t TH1Editor::fP2NDCold[3]. private . Definition at line 102 of file TH1Editor.h. ◆ fP2old. Float_t TH1Editor::fP2old[3]. private ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1Editor.html:59226,simpl,simple,59226,doc/master/classTH1Editor.html,https://root.cern,https://root.cern/doc/master/classTH1Editor.html,1,['simpl'],['simple']
Usability,"file and the path; and name of the histogram within that file. When providing these; in a script, HistFactory doesn't load the histogram from the file; right away. Instead, once all such histograms have been supplied,; one should run this method to open all ROOT files and to copy and; save all necessary histograms. Measurement(); Measurement( const Measurement& other ); // Copy. void SetOutputFilePrefix(const string& prefix); set output prefix. { fOutputFilePrefix = prefix; }. std::string GetOutputFilePrefix(); retrieve prefix for output files. { return fOutputFilePrefix; }. void SetPOI(const string& POI); insert PoI at beginning of vector of PoIs. { fPOI.insert( fPOI.begin(), POI ); }. void AddPOI(const string& POI); append parameter to vector of PoIs. { fPOI.push_back(POI); }. std::string GetPOI(unsigned int i = 0); get name of PoI at given index. { return fPOI.at(i); }. std::vector<std::string>& GetPOIList(); get vector of PoI names. { return fPOI; }. void ClearConstantParams(); empty vector of constant parameters. { fConstantParams.clear(); }. std::vector< std::string >& GetConstantParams(); get vector of all constant parameters. { return fConstantParams; }. std::map<std::string, double>& GetParamValues(); get map: parameter name <--> parameter value. { return fParamValues; }. void ClearParamValues(); clear map of parameter values. { fParamValues.clear(); }. void AddFunctionObject(const RooStats::HistFactory::PreprocessFunction function); add a preprocess function object. { fFunctionObjects.push_back( function ); }. void SetFunctionObjects(vector<RooStats::HistFactory::PreprocessFunction> objects); get vector of defined function objects. { fFunctionObjects = objects; }. std::vector< RooStats::HistFactory::PreprocessFunction >& GetFunctionObjects(); { return fFunctionObjects; }. std::vector< RooStats::HistFactory::Asimov >& GetAsimovDatasets(); get vector of defined Asimov Datasets. { return fAsimovDatasets; }. void AddAsimovDataset(RooStats::HistFactory::Asimov d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HistFactory__Measurement.html:11870,Clear,ClearConstantParams,11870,root/html534/RooStats__HistFactory__Measurement.html,https://root.cern,https://root.cern/root/html534/RooStats__HistFactory__Measurement.html,1,['Clear'],['ClearConstantParams']
Usability,"file containing the SWAN usage statistics during July 2017 ;  timeSeriesFromCSV.py This macro illustrates the use of the time axis on a TGraph with data read from a text file containing the SWAN usage statistics during July 2017 ;  timeSeriesFromCSV_TDF.C This macro illustrates the use of the time axis on a TGraph with data read from a text file containing the SWAN usage statistics during July 2017 ;  waves.C Hint: Spherical waves ;  zdemo.C This macro is an example of graphs in log scales with annotations ;  zones.C Example of script showing how to divide a canvas into adjacent subpads + axis labels on the top and right side of the pads ;  zones.py Example of script showing how to divide a canvas into adjacent subpads + axis labels on the top and right side of the pads ;  ► gui;  buttonChangelabel.CThis macro gives an example for changing text button labels anytime the Start or Pause buttons are clicked ;  buttongroupState.CA simple example that shows the enabled and disabled state of a button group with radio and check buttons ;  buttonsLayout.CThis macro gives an example of different buttons' layout ;  buttonTest.CThis macro gives an example of how to set/change text button attributes ;  calendar.CThis macro gives an example of how to use html widget to display tabular data ;  CPUMeter.CSimple macro showing capabilities of the TGSpeedo widget ;  customContextMenu.CExample showing how to add a function to the class context menu ;  customTH1Fmenu.CExample showing how to customize a context menu for a class ;  drag_and_drop.CThis tutorial illustrates how to use drag and drop within ROOT ;  exec3.CExample of using signal/slot in TCanvas/TPad to get feedback about processed events ;  exec_macro.CThis utility macro executes the macro ""macro"" given as first argument and save a capture in a png file ;  games.CThis macro runs three ""games"" that each nicely illustrate the graphics capabilities of ROOT ;  gtreeTableTest.CThis TableTest class is a simple example of how to us",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:117377,simpl,simple,117377,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,3,['simpl'],['simple']
Usability,"file. When providing these; in a script, HistFactory doesn't load the histogram from the file; right away. Instead, once all such histograms have been supplied,; one should run this method to open all ROOT files and to copy and; save all necessary histograms. Measurement(); Measurement( const Measurement& other ); // Copy. void SetOutputFilePrefix(const string& prefix); set output prefix. { fOutputFilePrefix = prefix; }. std::string GetOutputFilePrefix(); retrieve prefix for output files. { return fOutputFilePrefix; }. void SetPOI(const string& POI); insert PoI at beginning of vector of PoIs. { fPOI.insert( fPOI.begin(), POI ); }. void AddPOI(const string& POI); append parameter to vector of PoIs. { fPOI.push_back(POI); }. std::string GetPOI(unsigned int i = 0); get name of PoI at given index. { return fPOI.at(i); }. std::vector<std::string>& GetPOIList(); get vector of PoI names. { return fPOI; }. void ClearConstantParams(); empty vector of constant parameters. { fConstantParams.clear(); }. std::vector< std::string >& GetConstantParams(); get vector of all constant parameters. { return fConstantParams; }. std::map<std::string, double>& GetParamValues(); get map: parameter name <--> parameter value. { return fParamValues; }. void ClearParamValues(); clear map of parameter values. { fParamValues.clear(); }. void AddFunctionObject(const RooStats::HistFactory::PreprocessFunction function); add a preprocess function object. { fFunctionObjects.push_back( function ); }. void SetFunctionObjects(vector<RooStats::HistFactory::PreprocessFunction> objects); get vector of defined function objects. { fFunctionObjects = objects; }. std::vector< RooStats::HistFactory::PreprocessFunction >& GetFunctionObjects(); { return fFunctionObjects; }. std::vector< RooStats::HistFactory::Asimov >& GetAsimovDatasets(); get vector of defined Asimov Datasets. { return fAsimovDatasets; }. void AddAsimovDataset(RooStats::HistFactory::Asimov dataset); add an Asimov Dataset. { fAsimovDatasets.push_ba",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HistFactory__Measurement.html:11948,clear,clear,11948,root/html534/RooStats__HistFactory__Measurement.html,https://root.cern,https://root.cern/root/html534/RooStats__HistFactory__Measurement.html,2,['clear'],['clear']
Usability,"file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GVIZ3D; » TStructViewer. class TStructViewer: public TObject. TStructViewer viewer represents class, struct or other type as an object in 3D space.; At the top of the scene we can see objects which is our pointer. Under it we see; pointers and collection elements. Collection must inherit from TCollection; or be STL collecion. We can change the number of visible levels or objects on the scene with the GUI or; methods. The size of geometry objects is proportional to the memory taken by this object; or to the number of members inside this object. An easy way to find some class in the viewer is to change the color of the type.; We can connect for example a TF2 class with red color or connect all classes; inheriting from TF2 by adding plus to name. For example typename ""TF2+"" tells us; that all classes inheriting from TF2 will be red. Navigation in viewer is very simple like in usual GLViewer. When you put the mouse over; some object you can see some information about it (e.g. name, size, actual level).; When you double click this object, it becames top object on scene.; Undo and redo operation are supported. In this picture we can see TStructViewer with pointer to TList which contains; other collections and objects of various classes. Other screenshot presents opened TStructNodeEditor. Function Members (Methods); public:. TStructViewer(void* ptr = NULL, const char* clname = NULL); virtual~TStructViewer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TStructViewer.html:1113,simpl,simple,1113,root/html530/TStructViewer.html,https://root.cern,https://root.cern/root/html530/TStructViewer.html,5,['simpl'],['simple']
Usability,"fileLL::RooProfileLL ; (; const RooProfileLL & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definition at line 73 of file RooProfileLL.cxx. Member Function Documentation. ◆ alwaysStartFromMin(). bool RooProfileLL::alwaysStartFromMin ; (; ); const. inline . Definition at line 31 of file RooProfileLL.h. ◆ bestFitObs(). const RooArgSet & RooProfileLL::bestFitObs ; (; ); const. Definition at line 98 of file RooProfileLL.cxx. ◆ bestFitParams(). const RooArgSet & RooProfileLL::bestFitParams ; (; ); const. Definition at line 89 of file RooProfileLL.cxx. ◆ Class(). static TClass * RooProfileLL::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooProfileLL::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooProfileLL::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 70 of file RooProfileLL.h. ◆ clearAbsMin(). void RooProfileLL::clearAbsMin ; (; ). inline . Definition at line 42 of file RooProfileLL.h. ◆ clone(). TObject * RooProfileLL::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 28 of file RooProfileLL.h. ◆ createProfile(). RooFit::OwningPtr< RooAbsReal > RooProfileLL::createProfile ; (; const RooArgSet & ; paramsOfInterest). overridevirtual . Optimized implementation of createProfile for profile likelihoods. ; Return profile of original function in terms of stated parameters of interest rather than profiling recursively. ; Reimplemented from RooAbsReal.; Definition at line 112 of file RooProfileLL.cxx. ◆ DeclFileName(). static const char * RooProfileLL::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 70 of file RooProfileLL.h. ◆ evaluate(). double RooProfileLL::evaluate ; (; ); const. overrideprotectedvirtual . Evaluate profile likelihood by minimizing likelihood w.r.t. ; all par",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProfileLL.html:63034,clear,clearAbsMin,63034,doc/master/classRooProfileLL.html,https://root.cern,https://root.cern/doc/master/classRooProfileLL.html,1,['clear'],['clearAbsMin']
Usability,"fineSlot() works just as well with single-thread execution: in that case slot will always be 0. . DefineSlotEntry() Same as DefineSlot(), but the entry number is passed in addition to the slot number. This is meant as a helper in case the expression depends on the entry number. For details about entry numbers in multi-threaded runs, see here. . Filter() Filter rows based on user-defined conditions. . Range() Filter rows based on entry number (single-thread only). . Redefine() Overwrite the value and/or type of an existing column. See Define() for more information. . RedefineSlot() Overwrite the value and/or type of an existing column. See DefineSlot() for more information. . RedefineSlotEntry() Overwrite the value and/or type of an existing column. See DefineSlotEntry() for more information. . Vary() Register systematic variations for an existing column. Varied results are then extracted via VariationsFor(). . Actions; Actions aggregate data into a result. Each one is described in more detail in the reference guide.; In the following, whenever we say an action ""returns"" something, we always mean it returns a smart pointer to it. Actions only act on events that pass all preceding filters.; Lazy actions only trigger the event loop when one of the results is accessed for the first time, making it easy to produce many different results in one event loop. Instant actions trigger the event loop instantly. Lazy action Description . Aggregate() Execute a user-defined accumulation operation on the processed column values. . Book() Book execution of a custom action using a user-defined helper object. . Cache() Cache column values in memory. Custom columns can be cached as well, filtered entries are not cached. Users can specify which columns to save (default is all). . Count() Return the number of events processed. Useful e.g. to get a quick count of the number of events passing a Filter. . Display() Provides a printable representation of the dataset contents. The method retur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:4571,guid,guide,4571,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,1,['guid'],['guide']
Usability,"finition FitConfig.h:109; ROOT::Fit::FitResultclass containing the result of the fit and all the related information (fitted parameter values,...Definition FitResult.h:47; ROOT::Fit::FitterFitter class, entry point for performing all type of fits.Definition Fitter.h:77; ROOT::Fit::Fitter::LikelihoodFitbool LikelihoodFit(const std::shared_ptr< UnBinData > &data, bool extended=false, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Un-binned Likelihood fit using a shared_ptr for NOT copying the input data.Definition Fitter.h:229; ROOT::Fit::Fitter::LinearFitbool LinearFit(const BinData &data)Do a linear fit copying the input data.Definition Fitter.h:247; ROOT::Fit::Fitter::LeastSquareFitbool LeastSquareFit(const std::shared_ptr< BinData > &data, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Fit a binned data set using a least square fit NOT copying the input data.Definition Fitter.h:179; ROOT::Fit::Fitter::EvalFCNbool EvalFCN()Perform a simple FCN evaluation.Definition Fitter.cxx:288; ROOT::Fit::Fitter::fExtObjFunctionconst ROOT::Math::IMultiGenFunction * fExtObjFunction! pointer to an external FCNDefinition Fitter.h:576; ROOT::Fit::Fitter::operator=Fitter & operator=(const Fitter &)=deleteAssignment operator (disabled, class is not copyable); ROOT::Fit::Fitter::FitFCNbool FitFCN()Perform a fit with the previously set FCN function.Definition Fitter.cxx:269; ROOT::Fit::Fitter::DoUpdateFitConfigvoid DoUpdateFitConfig()Definition Fitter.cxx:860; ROOT::Fit::Fitter::DoMinimizationbool DoMinimization(std::unique_ptr< ObjFunc_t > f, const ROOT::Math::IMultiGenFunction *chifunc=nullptr)do minimizationDefinition Fitter.cxx:836; ROOT::Fit::Fitter::DoSetFCNbool DoSetFCN(bool useExtFCN, const ROOT::Math::IMultiGenFunction &fcn, const double *params, unsigned int dataSize, int fitType)Set Objective function.Definition Fitter.cxx:137; ROOT::Fit::Fitter::fDataSizeint fDataSizesize of data sets (need for Fumili or LM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Fitter_8h_source.html:30027,simpl,simple,30027,doc/master/Fitter_8h_source.html,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html,1,['simpl'],['simple']
Usability,"finition TDataType.h:44; TEnvThe TEnv class reads config files, by default named .rootrc.Definition TEnv.h:124; TFileHandlerDefinition TSysEvtHandler.h:65; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TGX11This class is the basic interface to the X11 (Xlib) graphics system.Definition TGX11.h:80; TGaxisThe axis painter class.Definition TGaxis.h:24; TGeometryTGeometry description.Definition TGeometry.h:39; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; THashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject...Definition THashList.h:34; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; THtmlLegacy ROOT documentation system.Definition THtml.h:40; TKeyBook space in a file, create I/O buffers, to fill them, (un)compress them.Definition TKey.h:28; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TLinkSpecial TText object used to show hyperlinks.Definition TLink.h:17; TListA doubly linked list.Definition TList.h:38; TMethodArgEach ROOT method (see TMethod) has a linked list of its arguments.Definition TMethodArg.h:36; TMethodEach ROOT class (see TClass) has a linked list of methods.Definition TMethod.h:38; TMinuitDefinition TMinuit.h:27; TObjectTableThis class registers all instances of TObject and its derived classes in a hash table.Definition TObjectTable.h:35; TObjectMother of all ROOT objects.Definition TObject.h:41; TOrdCollectionOrdered collection.Definition TOrdCollection.h:32; TPadThe most important graphics class in the ROOT system.Definition TPad.h:28; TPaveLabelA Pave (see TPave) with a text centered in the Pave.Definition TPaveLabel.h:20; TPaveTextA Pave (see TPave) with text, lines or/and boxes inside.Definition TPaveText.h:21; TPaveA TBox with a bordersize and a shadow option.Definition TPave.h:19; TPostScriptIn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTObjectTable.html:5157,simpl,simple,5157,doc/master/classTObjectTable.html,https://root.cern,https://root.cern/doc/master/classTObjectTable.html,1,['simpl'],['simple']
Usability,"finition TGeoVolume.cxx:1812; TGeoVolume::UnmarkSavedvoid UnmarkSaved()Reset SavePrimitive bits.Definition TGeoVolume.cxx:1699; TGeoVolume::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideExecute mouse actions on this volume.Definition TGeoVolume.cxx:1710; TGeoVolume::CloneVolumevirtual TGeoVolume * CloneVolume() constClone this volume.Definition TGeoVolume.cxx:1831; TGeoVolume::SetFindervoid SetFinder(TGeoPatternFinder *finder)Definition TGeoVolume.h:244; TGeoVolume::GetNdaughtersInt_t GetNdaughters() constDefinition TGeoVolume.h:362; TGeoVolume::IsValidBool_t IsValid() constDefinition TGeoVolume.h:154; TGeoVolume::Grabvoid Grab()Definition TGeoVolume.h:136; TGeoVolume::CheckGeometryvoid CheckGeometry(Int_t nrays=1, Double_t startx=0, Double_t starty=0, Double_t startz=0) constShoot nrays with random directions from starting point (startx, starty, startz) in the reference fram...Definition TGeoVolume.cxx:588; TGeoVolume::SelectVolumevoid SelectVolume(Bool_t clear=kFALSE)Select this volume as matching an arbitrary criteria.Definition TGeoVolume.cxx:2325; TGeoVolume::GetPointerNameconst char * GetPointerName() constProvide a pointer name containing uid.Definition TGeoVolume.cxx:1792; TGeoVolume::Classstatic TClass * Class(); TGeoVolume::GetNodesTObjArray * GetNodes()Definition TGeoVolume.h:169; TGeoVolume::ClearShapevoid ClearShape()Clear the shape of this volume from the list held by the current manager.Definition TGeoVolume.cxx:668; TGeoVolume::SetFWExtensionvoid SetFWExtension(TGeoExtension *ext)Connect framework defined extension to the volume.Definition TGeoVolume.cxx:1498; TGeoVolume::VisibleDaughtersvoid VisibleDaughters(Bool_t vis=kTRUE)set visibility for daughtersDefinition TGeoVolume.cxx:2453; TGeoVolume::FindOverlapsvoid FindOverlaps() constloop all nodes marked as overlaps and find overlapping brothersDefinition TGeoVolume.cxx:2227; TGeoVolume::AddNodeOverlapvirtual void AddNodeOverlap(TGeoVolume *vol, Int_t copy_no, TGeoMatrix *mat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoVolume_8cxx_source.html:146400,clear,clear,146400,doc/master/TGeoVolume_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html,1,['clear'],['clear']
Usability,"finition TGeoVolume.cxx:1812; TGeoVolume::UnmarkSavedvoid UnmarkSaved()Reset SavePrimitive bits.Definition TGeoVolume.cxx:1699; TGeoVolume::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideExecute mouse actions on this volume.Definition TGeoVolume.cxx:1710; TGeoVolume::CloneVolumevirtual TGeoVolume * CloneVolume() constClone this volume.Definition TGeoVolume.cxx:1831; TGeoVolume::SetFindervoid SetFinder(TGeoPatternFinder *finder)Definition TGeoVolume.h:244; TGeoVolume::GetNdaughtersInt_t GetNdaughters() constDefinition TGeoVolume.h:362; TGeoVolume::IsValidBool_t IsValid() constDefinition TGeoVolume.h:154; TGeoVolume::Grabvoid Grab()Definition TGeoVolume.h:136; TGeoVolume::CheckGeometryvoid CheckGeometry(Int_t nrays=1, Double_t startx=0, Double_t starty=0, Double_t startz=0) constShoot nrays with random directions from starting point (startx, starty, startz) in the reference fram...Definition TGeoVolume.cxx:588; TGeoVolume::SelectVolumevoid SelectVolume(Bool_t clear=kFALSE)Select this volume as matching an arbitrary criteria.Definition TGeoVolume.cxx:2325; TGeoVolume::GetPointerNameconst char * GetPointerName() constProvide a pointer name containing uid.Definition TGeoVolume.cxx:1792; TGeoVolume::GetNodesTObjArray * GetNodes()Definition TGeoVolume.h:169; TGeoVolume::SetTransparencyvoid SetTransparency(Char_t transparency=0)Definition TGeoVolume.h:376; TGeoVolume::ClearShapevoid ClearShape()Clear the shape of this volume from the list held by the current manager.Definition TGeoVolume.cxx:668; TGeoVolume::SetFWExtensionvoid SetFWExtension(TGeoExtension *ext)Connect framework defined extension to the volume.Definition TGeoVolume.cxx:1498; TGeoVolume::VisibleDaughtersvoid VisibleDaughters(Bool_t vis=kTRUE)set visibility for daughtersDefinition TGeoVolume.cxx:2453; TGeoVolume::Releasevoid Release()Definition TGeoVolume.h:137; TGeoVolume::FindOverlapsvoid FindOverlaps() constloop all nodes marked as overlaps and find overlapping brothersDefinition TGe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoVolume_8h_source.html:38888,clear,clear,38888,doc/master/TGeoVolume_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoVolume_8h_source.html,1,['clear'],['clear']
Usability,"finition at line 105 of file TSelectorDraw.cxx. ◆ Class(). static TClass * TSelectorDraw::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TSelectorDraw::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TSelectorDraw::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 121 of file TSelectorDraw.h. ◆ ClearFormula(). void TSelectorDraw::ClearFormula ; (; ). protectedvirtual . Delete internal buffers. ; Definition at line 941 of file TSelectorDraw.cxx. ◆ CompileVariables(). bool TSelectorDraw::CompileVariables ; (; const char * ; varexp = """", . const char * ; selection = """" . ). protectedvirtual . Compile input variables and selection expression. ; varexp is an expression of the general form e1:e2:e3 where e1,etc is a formula referencing a combination of the columns; Example: varexp = x simplest case: draw a 1-Dim distribution of column named x; = sqrt(x) : draw distribution of sqrt(x); = x*y/z; = y:sqrt(x) 2-Dim distribution of y versus sqrt(x); selection is an expression with a combination of the columns; Example: selection = ""x<y && sqrt(z)>3.2""; in a selection all the C++ operators are authorized; Return false if any of the variable is not compilable. ; Definition at line 976 of file TSelectorDraw.cxx. ◆ DeclFileName(). static const char * TSelectorDraw::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 121 of file TSelectorDraw.h. ◆ GetAction(). virtual Int_t TSelectorDraw::GetAction ; (; ); const. inlinevirtual . Definition at line 80 of file TSelectorDraw.h. ◆ GetCleanElist(). virtual bool TSelectorDraw::GetCleanElist ; (; ); const. inlinevirtual . Definition at line 81 of file TSelectorDraw.h. ◆ GetDimension(). virtual Int_t TSelectorDraw::GetDimension ; (; ); const. inlinevirtual . Definition at line 82 of file TSelectorDraw.h. ◆ GetDrawFlag(). virtual Lo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelectorDraw.html:18695,simpl,simplest,18695,doc/master/classTSelectorDraw.html,https://root.cern,https://root.cern/doc/master/classTSelectorDraw.html,1,['simpl'],['simplest']
Usability,"finition at line 428 of file GeneralLayer.h. ◆ UpdateBiasGradients(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateBiasGradients ; (; const std::vector< Matrix_t > & ; biasGradients, . const Scalar_t ; learningRate . ). Updates the bias gradients, given some other weight gradients and learning rate. ; Definition at line 448 of file GeneralLayer.h. ◆ UpdateWeightGradients(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateWeightGradients ; (; const std::vector< Matrix_t > & ; weightGradients, . const Scalar_t ; learningRate . ). Updates the weight gradients, given some other weight gradients and learning rate. ; Definition at line 438 of file GeneralLayer.h. ◆ UpdateWeights(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateWeights ; (; const std::vector< Matrix_t > & ; weightGradients, . const Scalar_t ; learningRate . ). Updates the weights, given the gradients and the learning rate,. ; Definition at line 418 of file GeneralLayer.h. ◆ WriteMatrixToXML(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::WriteMatrixToXML ; (; void * ; node, . const char * ; name, . const Matrix_t & ; matrix . ). Definition at line 521 of file GeneralLayer.h. ◆ WriteTensorToXML(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::WriteTensorToXML ; (; void * ; node, . const char * ; name, . const std::vector< Matrix_t > & ; tensor . ). helper functions for XML ; Definition at line 496 of file GeneralLayer.h. Member Data Documentation. ◆ fActivationGradients. template<typename Architecture_t > . Tensor_t TMVA::DNN::VGeneralLayer< Architecture_t >::fActivationGradients. protected . Gradients w.r.t. the activations of this layer. ; Definition at line 78 of file GeneralLayer.h. ◆ fBatchSize. template<typename Architecture_t > . size_t TMVA::DNN::VGeneralLayer< Architecture_t >::fBatchS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html:26692,learn,learning,26692,doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html,1,['learn'],['learning']
Usability,"finition at line 730 of file TEventIter.cxx. Member Function Documentation. ◆ Class(). static TClass * TEventIterTree::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TEventIterTree::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TEventIterTree::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 188 of file TEventIter.h. ◆ DeclFileName(). static const char * TEventIterTree::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 188 of file TEventIter.h. ◆ GetCacheSize(). Long64_t TEventIterTree::GetCacheSize ; (; ). overridevirtual . Return the size in bytes of the cache, if any Return -1 if not used. ; Implements TEventIter.; Definition at line 742 of file TEventIter.cxx. ◆ GetLearnEntries(). Int_t TEventIterTree::GetLearnEntries ; (; ). overridevirtual . Return the number of entries in the learning phase. ; Implements TEventIter.; Definition at line 751 of file TEventIter.cxx. ◆ GetNextEvent(). Long64_t TEventIterTree::GetNextEvent ; (; ). overridevirtual . Get next event. ; Implements TEventIter.; Definition at line 1189 of file TEventIter.cxx. ◆ GetNextPacket(). Int_t TEventIterTree::GetNextPacket ; (; Long64_t & ; first, . Long64_t & ; num . ). overridevirtual . Get loop range. ; Implements TEventIter.; Definition at line 1009 of file TEventIter.cxx. ◆ GetTrees(). TTree * TEventIterTree::GetTrees ; (; TDSetElement * ; elem). private . Create a Tree for the main TDSetElement and for all the friends. ; Returns the main tree or 0 in case of an error. ; Definition at line 760 of file TEventIter.cxx. ◆ IsA(). TClass * TEventIterTree::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TEventIter.; Definition at line 188 of file TEventIter.h. ◆ Load(). TTree * TEventIterTree::Load ; (; TDSetElement * ; elem, . B",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEventIterTree.html:14371,learn,learning,14371,doc/master/classTEventIterTree.html,https://root.cern,https://root.cern/doc/master/classTEventIterTree.html,1,['learn'],['learning']
Usability,"finition of a method; 76 // that will discern whether a Box is included into another one; 77 class BoxContainer; 78 {; 79 private:; 80 const Box& fBox;; 81 public:; 82 //Constructs the BoxContainer object with a Box that is meant; 83 //to include another one that will be provided later; 84 BoxContainer(const Box& b): fBox(b) {}; 85 ; 86 bool operator() (const Box& b1); 87 { return operator()(fBox, b1); }; 88 ; 89 // Looks if b2 is included in b1; 90 bool operator() (const Box& b1, const Box& b2); 91 {; 92 bool isIn = true;; 93 vector<double>::const_iterator boxit = b2.fMin.begin();; 94 vector<double>::const_iterator bigit = b1.fMax.begin();; 95 while ( isIn && boxit != b2.fMin.end() ); 96 {; 97 if ( (*boxit) >= (*bigit) ) isIn = false;; 98 ++boxit;; 99 ++bigit;; 100 }; 101 ; 102 boxit = b2.fMax.begin();; 103 bigit = b1.fMin.begin();; 104 while ( isIn && boxit != b2.fMax.end() ); 105 {; 106 if ( (*boxit) <= (*bigit) ) isIn = false;; 107 ++boxit;; 108 ++bigit;; 109 }; 110 ; 111 return isIn;; 112 }; 113 };; 114 ; 115 // Another helper class to be used in std::for_each to simplify; 116 // the code later. It implements the operator() to know if a; 117 // specified Box is big enough to contain any 'space' inside.; 118 class AreaComparer; 119 {; 120 public:; 121 AreaComparer(vector<double>::iterator iter):; 122 fThereIsArea(true),; 123 fIter(iter),; 124 fLimit(8 * std::numeric_limits<double>::epsilon()); 125 {};; 126 ; 127 void operator() (double value); 128 {; 129 if ( fabs(value- (*fIter)) < fLimit ); 130// if ( TMath::AreEqualRel(value, (*fIter), fLimit) ); 131 fThereIsArea = false;; 132 ; 133 ++fIter;; 134 }; 135 ; 136 bool IsThereArea() { return fThereIsArea; }; 137 ; 138 private:; 139 bool fThereIsArea;; 140 vector<double>::iterator fIter;; 141 double fLimit;; 142 };; 143 ; 144 ; 145 // This is the key of the SparseData structure. This method; 146 // will, by recursion, divide the area passed as an argument in; 147 // min and max into pieces to insert the Box defined",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/SparseData_8cxx_source.html:3545,simpl,simplify,3545,doc/master/SparseData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/SparseData_8cxx_source.html,1,['simpl'],['simplify']
Usability,"fit panel!; First, we draw the distribution of the vertex position along X for all muons. Do that into a histogram that has 20 bins and runs from -10 to +10. Now open the fit panel and click the histogram. We want to fit a Gaussian distribution - and hat's already selected by default. Se just press ""Fit"". Looks good, right?; Fit Parameters; As mentioned before, fitting means finding the optimal set of parameters. In the menu, select ""Options"", ""Fit Parameters"" (and resize the statistics box to make its content readable). You will see the values that the minimizer has found optimal, for instance it chose 1.2 as the mean of the Gaussian and 1.041 as the width.; These values are the crucial ones for physicists: they reduce the large amount of data into just a few parameters, describing the distribution even better than the original histogram. Fitting (or ""parametrization"") is thus a cornerstone of any physics analysis.; . ‹ 3. Examining a TTree's data; up; 6. Multivariate Analysis ›. Navigate through this book; 0. Setting up ROOT; 1. Extracting an object from a TFile; 2. Running code in ROOT; 4. Histogramming; 3. Examining a TTree's data; 5. Fitting; 6. Multivariate Analysis; 7. Using the TTreeReader; 8. Efficiency Calculation; 9. Fitting By Coding; 10. Go Parallel!; TutorialSelector.C; 11. Done!. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/5-fitting.html:4273,guid,guidelines,4273,d/5-fitting.html,https://root.cern,https://root.cern/d/5-fitting.html,1,['guid'],['guidelines']
Usability,"fixed params; Double_t*TMinuit::fXt[fMaxpar] Internal parameters values X saved as Xt; Double_t*TMinuit::fXts[fMaxpar] Internal parameters values X saved as Xt for fixed params; Double_tTMinuit::fYdircr; Double_tTMinuit::fYmidcr; Double_t*TMinuit::fYpt[fMaxcpt] Y array of points for contours. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TMVA::IFitterTarget&fFitterTargetfitter Target; Int_tfNumParnumber of parameters; vector<Double_t>fParametersvector holding the current parameters . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MinuitWrapper(TMVA::IFitterTarget& target, Int_t maxpar); constructor. Int_t Eval(Int_t , Double_t* , Double_t& , Double_t* , Int_t ); std::vector<Double_t> parameters( npar );. Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs); Execute a fitter command;; command : command string; args : list of nargs command arguments. void Clear(Option_t* = 0); reset the fitter environment. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx); return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc); return current errors for a parameter; ipar : parameter number; eplus : upper error; eminus : lower error; eparab : parabolic error; globcc : global correlation coefficient. Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); set initial values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter. TObject * Clone(const char* ) const; produces a clone of this MinuitWrapper. virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__MinuitWrapper.html:18488,Clear,Clear,18488,root/html532/TMVA__MinuitWrapper.html,https://root.cern,https://root.cern/root/html532/TMVA__MinuitWrapper.html,2,['Clear'],['Clear']
Usability,"fixing shapes with negative parameters (run-...Definition TGeoManager.cxx:1480; Now we are really done with geometry building stage, but we would like to see our simple world:; root[] top->SetLineColor(kMagenta);; root[] gGeoManager->SetTopVisible(); // the TOP is invisible; root[] top->Draw();; kMagenta@ kMagentaDefinition Rtypes.h:66; TGeoManager::SetTopVisiblevoid SetTopVisible(Bool_t vis=kTRUE)make top volume visible on screenDefinition TGeoManager.cxx:2396. Example 2: A Geometrical Hierarchy Look and Feel; Before going further, let us get a look and feel of interacting with the modeller. For this, we will use one of the examples illustrating the geometry package. To get an idea on the geometry structure created in this example, just look at rootgeom.C. You will notice that this is a bit more complex that just creating the ""world"" since several other volumes are created and put together in a hierarchy. The purpose here is just to learn how to interact with a geometry that is already built, but just few hints on the building steps in this example might be useful. The geometry here represents the word ROOT that is replicated in some symmetric manner. You might for instance ask some questions after having a first look:; Q: ""OK, I understand the first lines that load the libGeom library and create; a geometry manager object. I also recognize from the previous example the following; lines creating some materials and media, but what about the geometrical transformations below?""; A: As explained before, the model that we are trying to create is a hierarchy of volumes based on ""containment"". This is accomplished by ""positioning"" some volumes ""inside"" others. Any volume is an un-positioned object in the sense that it defines only a ""local frame"" (matching the one of its ""shape""). In order to fully define the mother-daughter relationship between two volumes one has to specify how the daughter will be positioned inside. This is accomplished by defining a ""local geometrical ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:7842,learn,learn,7842,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['learn'],['learn']
Usability,"fo);; 3636 ; 3637 if (ID == remark_module_build && !isByproductModule) {; 3638 ROOT::TMetaUtils::Error(nullptr,; 3639 ""Building module '%s' implicitly. If '%s' requires a \n""; 3640 ""dictionary please specify build dependency: '%s' depends on '%s'.\n""; 3641 ""Otherwise, specify '-mByproduct %s' to disable this diagnostic.\n"",; 3642 moduleName.c_str(), moduleName.c_str(), gOptDictionaryFileName.c_str(),; 3643 moduleName.c_str(), moduleName.c_str());; 3644 }; 3645 }; 3646 ; 3647 // All methods below just forward to the child and the default method.; 3648 virtual void clear() override; 3649 {; 3650 fChild->clear();; 3651 DiagnosticConsumer::clear();; 3652 }; 3653 ; 3654 virtual void BeginSourceFile(const clang::LangOptions &LangOpts, const clang::Preprocessor *PP) override; 3655 {; 3656 fChild->BeginSourceFile(LangOpts, PP);; 3657 DiagnosticConsumer::BeginSourceFile(LangOpts, PP);; 3658 }; 3659 ; 3660 virtual void EndSourceFile() override; 3661 {; 3662 fChild->EndSourceFile();; 3663 DiagnosticConsumer::EndSourceFile();; 3664 }; 3665 ; 3666 virtual void finish() override; 3667 {; 3668 fChild->finish();; 3669 DiagnosticConsumer::finish();; 3670 }; 3671 ; 3672 virtual bool IncludeInDiagnosticCounts() const override { return fChild->IncludeInDiagnosticCounts(); }; 3673};; 3674 ; 3675static void MaybeSuppressWin32CrashDialogs() {; 3676#if defined(_WIN32) && defined(_MSC_VER); 3677 // Suppress error dialogs to avoid hangs on build nodes.; 3678 // One can use an environment variable (Cling_GuiOnAssert) to enable; 3679 // the error dialogs.; 3680 const char *EnablePopups = getenv(""Cling_GuiOnAssert"");; 3681 if (EnablePopups == nullptr || EnablePopups[0] == '0') {; 3682 ::_set_error_mode(_OUT_TO_STDERR);; 3683 _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);; 3684 _CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDERR);; 3685 _CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);; 3686 _CrtSetReportFile(_CRT_ERROR, _CRTDBG_FILE_STDERR);; 3687 _CrtSe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:145866,clear,clear,145866,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,3,['clear'],['clear']
Usability,"fo::fLastStyleLast combined viewer/scene style (set in scene::pre-draw).; Float_tTGLSceneInfo::fLastWFLineWLast combined viewer/scene wire-frame line-width (set in scene::pre-draw).; Float_tTGLSceneInfo::fOLLineWOptional override of scene outline line-width; TGLSceneBase*TGLSceneInfo::fScene; UInt_tTGLSceneInfo::fSceneStampScene's time-stamp on last update.; Short_tTGLSceneInfo::fStyleOptional override of scene style; TGLBoundingBoxTGLSceneInfo::fTransformedBBox; Bool_tTGLSceneInfo::fUpdateTimeoutedSet if update was interrupted.; Bool_tTGLSceneInfo::fViewCheckViewer side check if render is necessary.; TGLViewerBase*TGLSceneInfo::fViewer; Float_tTGLSceneInfo::fWFLineWOptional override of scene wire-frame line-width. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSceneInfo(TGLViewerBase* view = 0, TGLScene* scene = 0); Constructor. ~TSceneInfo(); Destructor. void ClearDrawElementVec(TGLScene::DrawElementVec_t& vec, Int_t maxSize); Clear given vec and if it grew too large compared to the size of; shape-of-interest also resize it. void ClearDrawElementPtrVec(TGLScene::DrawElementPtrVec_t& vec, Int_t maxSize); Clear given vec and if it grew too large compared to the size of; shape-of-interest also resize it. void ClearAfterRebuild(); Clear DrawElementVector fVisibleElement and optionally resize it; so that it doesn't take more space then required by all the; elements in the scene's draw-list. void ClearAfterUpdate(); Clear DrawElementPtrVectors and optionally resize them so that; they don't take more space then required by all the elements in; the scene's draw-list. void Lodify(TGLRnrCtx& ctx); Quantize LODs for gice render-context. void PreDraw(); Prepare for drawing - fill DrawElementPtrVectors from the; contents of fVisibleElements if there was some change. void PostDraw(); Clean-up after drawing, nothing to be done here. void ResetDrawStats(); Reset draw statistics. void UpdateDrawStats(const TGLPhysicalShape& shape, Short",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLScene__TSceneInfo.html:6261,Clear,ClearDrawElementVec,6261,root/html602/TGLScene__TSceneInfo.html,https://root.cern,https://root.cern/root/html602/TGLScene__TSceneInfo.html,4,['Clear'],"['Clear', 'ClearDrawElementVec']"
Usability,"foldSys ;  testUnfold5a.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold5b.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold5c.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold5d.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold6.C Test program for the class TUnfoldBinning ;  testUnfold7a.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold7b.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold7c.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  ► unuran;  unuranDemo.CExample macro to show unuran capabilities The results are compared with what is obtained using TRandom or TF1::GetRandom The macro is divided in 3 parts: ;  unuranFoamTest.CThis program must be compiled and executed with Aclic as follows ;  ► v7;  concurrentfill.cxx;  draw.cxx;  histops.cxx;  histspeedtest.cxx;  perf.cxx;  perfcomp.cxx;  simple.cxx;  ► xml;  DOMParsePerson.C ROOT implementation of a XML DOM Parser ;  DOMRecursive.C ROOT implementation of a XML DOM Parser ;  SAXHandler.C ROOT implementation of a simple SAX Handler ;  xmlnewfile.C Example to create a new xml file with the TXMLEngine class ;  xmlreadfile.C Example to read and parse any xml file, supported by TXMLEngine class The input file, produced by xmlnewfile.C macro is used If you need full xml syntax support, use TXMLParser instead ;  benchmarks.CThis macro run several tests and produces an benchmark report ;  demos.CThis macro shows a control bar to run some of the ROOT tutorials ;  demoshelp.CThis macro shows help on running the Demos ;  geant3tasks.CThis script is a representation using TTasks of the Geant3 simulation program This example uses directly TTask objects ;  hsimple.C This program creates : ;  htmlex.CThis file demonstrates how THtml can document sources ;  MyTasks.cxxA set of classes deriving from TTask ;  regexp.CA regular expression,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/files.html:160827,simpl,simple,160827,doc/v610/files.html,https://root.cern,https://root.cern/doc/v610/files.html,1,['simpl'],['simple']
Usability,"for defining the placement of a volume with respect to its container reference frame. This frame will be called 'master' and the frame of the positioned volume - 'local'. If T is a transformation used for positioning volume daughters, then: MASTER = T * LOCAL; Therefore Tis used to perform a local to master conversion, while T-1 for a master to local conversion. The second use case is the computation of the global transformation of a given object in the geometry. Since the geometry is built as 'volumes-inside-volumes', the global transformation represents the pile-up of all local transformations in the corresponding branch. Once a given object in the hierarchy becomes the current one, the conversion from master to local coordinates or the other way around can be done from the manager class.; A general homogenous transformation is defined as a 4x4 matrix embedding a rotation, a translation and a scale. The advantage of this description is that each basic transformation can be represented as a homogenous matrix, composition being performed as simple matrix multiplication.; Rotation:. \[; \left|\begin{array}{cccc}; r_{11} & r_{12} & r_{13} & 0 \\; r_{21} & r_{22} & r_{23} & 0 \\; r_{31} & r_{32} & r_{33} & 0 \\; 0 & 0 & 0 & 1; \end{array}; \right|; \]. Translation:. \[; \left|\begin{array}{cccc}; 1 & 0 & 0 & 0 \\; 0 & 1 & 0 & 0 \\; 0 & 0 & 1 & 0 \\; t_x & t_y & t_z & 1; \end{array}; \right|; \]. Scale:. \[; \left|\begin{array}{cccc}; s_x & 0 & 0 & 0 \\; 0 & s_y & 0 & 0 \\; 0 & 0 & s_z & 0 \\; 0 & 0 & 0 & 1; \end{array}; \right|; \]. Inverse rotation:. \[; \left|\begin{array}{cccc}; r_{11} & r_{21} & r_{31} & 0 \\; r_{12} & r_{22} & r_{32} & 0 \\; r_{13} & r_{23} & r_{33} & 0 \\; 0 & 0 & 0 & 1; \end{array}; \right|; \]. Inverse translation:. \[; \left|\begin{array}{cccc}; 1 & 0 & 0 & 0 \\; 0 & 1 & 0 & 0 \\; 0 & 0 & 1 & 0 \\; -t_x & -t_y & -t_z & 1; \end{array}; \right|; \]. Inverse scale:. \[; \left|\begin{array}{cccc}; \frac{1}{s_x} & 0 & 0 & 0 \\; 0 & \frac{1}{s_y} & ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:54657,simpl,simple,54657,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['simpl'],['simple']
Usability,"for defining the placement of a volume with respect to its container reference frame. This frame will be called ‘master’ and the frame of the positioned volume - ‘local’. If T is a transformation used for positioning volume daughters, then: MASTER = T * LOCAL; Therefore Tis used to perform a local to master conversion, while T-1 for a master to local conversion. The second use case is the computation of the global transformation of a given object in the geometry. Since the geometry is built as ‘volumes-inside-volumes’, the global transformation represents the pile-up of all local transformations in the corresponding branch. Once a given object in the hierarchy becomes the current one, the conversion from master to local coordinates or the other way around can be done from the manager class.; A general homogenous transformation is defined as a 4x4 matrix embedding a rotation, a translation and a scale. The advantage of this description is that each basic transformation can be represented as a homogenous matrix, composition being performed as simple matrix multiplication.; Rotation: \(\left|\begin{array}{cccc} r_{11} & r_{12} & r_{13} & 0 \\ r_{21} & r_{22} & r_{23} & 0 \\ r_{31} & r_{32} & r_{33} & 0 \\ 0 & 0 & 0 & 1 \end{array} \right|\) Translation: \(\left|\begin{array}{cccc} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ t_x & t_y & t_z & 1 \end{array} \right|\) Scale: \(\left|\begin{array}{cccc} s_x & 0 & 0 & 0 \\ 0 & s_y & 0 & 0 \\ 0 & 0 & s_z & 0 \\ 0 & 0 & 0 & 1 \end{array} \right|\); Inverse rotation: \(\left|\begin{array}{cccc} r_{11} & r_{21} & r_{31} & 0 \\ r_{12} & r_{22} & r_{32} & 0 \\ r_{13} & r_{23} & r_{33} & 0 \\ 0 & 0 & 0 & 1 \end{array} \right|\) Inverse translation: \(\left|\begin{array}{cccc} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ -t_x & -t_y & -t_z & 1 \end{array} \right|\) Inverse scale: \(\left|\begin{array}{cccc} \frac{1}{s_x} & 0 & 0 & 0 \\ 0 & \frac{1}{s_y} & 0 & 0 \\ 0 & 0 & \frac{1}{s_z} & 0 \\ 0 & 0 & 0 & 1 \end{array} ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:962310,simpl,simple,962310,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"for extended likelihood calculation, which is the sum of all coefficients. ;  ; ExtendMode extendMode () const override;  Returns ability of PDF to provide extended likelihood terms. ;  ; bool forceAnalyticalInt (const RooAbsArg &arg) const override;  ; const RooArgList & funcList () const;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &numVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Advertise that all integrals can be handled internally. ;  ; bool getFloor () const;  ; TClass * IsA () const override;  ; bool isBinnedDistribution (const RooArgSet &obs) const override;  Check if all components that depend on obs are binned. ;  ; std::list< double > * plotSamplingHint (RooAbsRealLValue &, double, double) const override;  Interface for returning an optional hint for initial sampling points when constructing a curve projected on observable obs. ;  ; void printMetaArgs (std::ostream &os) const override;  Customized printing of arguments of a RooRealSumPdf to more intuitively reflect the contents of the product operator construction. ;  ; bool selfNormalized () const override;  Shows if a PDF is self-normalized, which means that no attempt is made to add a normalization term. ;  ; void setCacheAndTrackHints (RooArgSet &) override;  Label OK'ed components of a RooRealSumPdf with cache-and-track. ;  ; void setFloor (bool flag);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void translate (RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ;  Public Member Functions inherited from RooAbsPdf;  RooAbsPdf ();  Default constructor. ;  ;  RooAbsPdf (const char *name, const char *title, double minVal, double maxVal);  Constructor with name, title, and plot range. ;  ;  RooAbsPdf (const char *name, c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooRealSumPdf.html:5150,intuit,intuitively,5150,doc/v632/classRooRealSumPdf.html,https://root.cern,https://root.cern/doc/v632/classRooRealSumPdf.html,2,['intuit'],['intuitively']
Usability,"for pattern classification based on Bayesian posterior probability. Introduction; Neural Networks are more and more used in various fields for data analysis and classification, both for research and commercial institutions. Some randomly chosen examples are:. image analysis; financial movements predictions and analysis; sales forecast and product shipping optimisation; in particles physics: mainly for classification tasks (signal over background discrimination). More than 50% of neural networks are multilayer perceptrons. This implementation of multilayer perceptrons is inspired from the MLPfit package originally written by Jerome Schwindling. MLPfit remains one of the fastest tool for neural networks studies, and this ROOT add-on will not try to compete on that. A clear and flexible Object Oriented implementation has been chosen over a faster but more difficult to maintain code. Nevertheless, the time penalty does not exceed a factor 2. The MLP; The multilayer perceptron is a simple feed-forward network with the following structure:. It is made of neurons characterized by a bias and weighted links between them (let's call those links synapses). The input neurons receive the inputs, normalize them and forward them to the first hidden layer.; Each neuron in any subsequent layer first computes a linear combination of the outputs of the previous layer. The output of the neuron is then function of that combination with f being linear for output neurons or a sigmoid for hidden layers. This is useful because of two theorems:. A linear combination of sigmoids can approximate any continuous function.; Trained with output = 1 for the signal and 0 for the background, the approximated function of inputs X is the probability of signal, knowing X. Learning methods; The aim of all learning methods is to minimize the total error on a set of weighted examples. The error is defined as the sum in quadrature, divided by two, of the error on each individual output neuron. In all methods",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiLayerPerceptron.html:2729,simpl,simple,2729,doc/master/classTMultiLayerPerceptron.html,https://root.cern,https://root.cern/doc/master/classTMultiLayerPerceptron.html,1,['simpl'],['simple']
Usability,"for repetitive data analysis tasks, where in a loop many times the same objects, are created and deleted. The only supported way to add objects to a TClonesArray is via the new with placement method. The different Add() methods of TObjArray and its base classes are not supported.; 16.8.1 The Idea Behind TClonesArray; To reduce the very large number of new and delete calls in large loops like this (O(100000) x O(10000) times new/delete):; TObjArray a(10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000); for (int i = 0; i < ev->Ntracks; i++) { // O(10000); a[i] = new TTrack(x,y,z,...);; ...; }; ...; a.Delete();; }; You better use a TClonesArray which reduces the number of new/delete calls to only O(10000):; TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000); for (int i = 0; i < ev->Ntracks; i++) { // O(10000); TTrack *track = (Track*)a.ConstructedAt(i);; track->Set(x,y,z,...);; ...; }; ...; a.Clear(); // Or Clear(""C"") if the track objects must be returned (via Track::Clear) to a default state.; }; Considering that a pair of new/delete calls on average cost about 70 ms, O(109) new/deletes will save about 19 hours. For the other collections, see the class reference guide on the web and the test program $ROOTSYS/test/tcollex.cxx.; 16.9 Template Containers and STL; Some people dislike polymorphic containers because they are not truly “type safe”. In the end, the compiler leaves it the user to ensure that the types are correct. This only leaves the other alternative: creating a new class each time a new (container organization) / (contained object) combination is needed. To say the least this could be very tedious. Most people faced with this choice would, for each type of container:; Define the class leaving a dummy name for the contained object type. When a particular container was needed, copy the code and then do a global search and replace for the contained class. C++ has a built in template scheme that effectively does jus",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:855189,Clear,Clear,855189,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,3,['Clear'],['Clear']
Usability,"for the coordinates of the point, where the function is measured; Second parameter - the value being fitted; Third parameter - weight(measurement error) of this point (=1 by default). void AssignData(Int_t npoints, Int_t xncols, Double_t* x, Double_t* y, Double_t* e = 0); This function is to use when you already have all the data in arrays; and don't want to copy them into the fitter. In this function, the Use() method; of TVectorD and TMatrixD is used, so no bytes are physically moved around.; First parameter - number of points to fit; Second parameter - number of variables in the model; Third parameter - the variables of the model, stored in the following way:; (x0(0), x1(0), x2(0), x3(0), x0(1), x1(1), x2(1), x3(1),... void AddToDesign(Double_t* x, Double_t y, Double_t e); Add a point to the AtA matrix and to the Atb vector. void AddTempMatrices(). void Clear(Option_t* option = """"); Clears everything. Used in TH1::Fit and TGraph::Fit(). void ClearPoints(); To be used when different sets of points are fitted with the same formula. void Chisquare(); Calculates the chisquare. void ComputeTValues(); Computes parameters' t-values and significance. Int_t Eval(); Perform the fit and evaluate the parameters; Returns 0 if the fit is ok, 1 if there are errors. void FixParameter(Int_t ipar); Fixes paramter #ipar at its current value. void FixParameter(Int_t ipar, Double_t parvalue); Fixes parameter #ipar at value parvalue. void ReleaseParameter(Int_t ipar); Releases parameter #ipar. void GetAtbVector(TVectorD& v); Get the Atb vector - a vector, used for internal computations. Double_t GetChisquare(); Get the Chisquare. void GetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.94999999999999996); Computes point-by-point confidence intervals for the fitted function; Parameters:; n - number of points; ndim - dimensions of points; x - points, at which to compute the intervals, for ndim > 1; should be in order: (x0,y0, x1, y1, ... xn, yn); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TLinearFitter.html:23169,Clear,ClearPoints,23169,root/html602/TLinearFitter.html,https://root.cern,https://root.cern/root/html602/TLinearFitter.html,2,['Clear'],['ClearPoints']
Usability,"for the coordinates of the point, where the function is measured; Second parameter - the value being fitted; Third parameter - weight(measurement error) of this point (=1 by default). void AssignData(Int_t npoints, Int_t xncols, Double_t* x, Double_t* y, Double_t* e = 0); This function is to use when you already have all the data in arrays; and don't want to copy them into the fitter. In this function, the Use() method; of TVectorD and TMatrixD is used, so no bytes are physically moved around.; First parameter - number of points to fit; Second parameter - number of variables in the model; Third parameter - the variables of the model, stored in the following way:; (x0(0), x1(0), x2(0), x3(0), x0(1), x1(1), x2(1), x3(1),... void AddToDesign(Double_t* x, Double_t y, Double_t e); Add a point to the AtA matrix and to the Atb vector. void AddTempMatrices(). void Clear(Option_t* option = """"); Clears everything. Used in TH1::Fit and TGraph::Fit(). void ClearPoints(); To be used when different sets of points are fitted with the same formula. void Chisquare(); Calculates the chisquare. void ComputeTValues(); Computes parameters' t-values and significance. Int_t Eval(); Perform the fit and evaluate the parameters; Returns 0 if the fit is ok, 1 if there are errors. void FixParameter(Int_t ipar); Fixes paramter #ipar at its current value. void FixParameter(Int_t ipar, Double_t parvalue); Fixes parameter #ipar at value parvalue. void ReleaseParameter(Int_t ipar); Releases parameter #ipar. void GetAtbVector(TVectorD& v); Get the Atb vector - a vector, used for internal computations. Double_t GetChisquare(); Get the Chisquare. void GetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.95); Computes point-by-point confidence intervals for the fitted function; Parameters:; n - number of points; ndim - dimensions of points; x - points, at which to compute the intervals, for ndim > 1; should be in order: (x0,y0, x1, y1, ... xn, yn); ci - computed i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TLinearFitter.html:22601,Clear,ClearPoints,22601,root/html532/TLinearFitter.html,https://root.cern,https://root.cern/root/html532/TLinearFitter.html,2,['Clear'],['ClearPoints']
Usability,"for the maximum number of calls to be registered in the Tree.; The default value is 5000000.; The 3 arguments can be set in $ROOTSYS/etc/system.rootrc; Root.TMemStat.system gnubuiltin; Root.TMemStat.buffersize 100000; Root.TMemStat.maxcalls 5000000. TMemStat::Show creates 3 canvases.; -In canvas1 it displays a dynamic histogram showing for pages (10 kbytes by default); the percentage of the page used.; A summary pave shows the total memory still in use when the TMemStat object; goes out of scope and the average occupancy of the pages.; The average occupancy gives a good indication of the memory fragmentation. -In canvas2 it displays the histogram of memory leaks in decreasing order.; when moving the mouse on this canvas, a tooltip shows the backtrace for the leak; in the bin below the mouse. -In canvas3 it displays the histogram of the nbigleaks largest leaks (default is 20); for each leak, the number of allocs and average alloc size is shown. Simply do:; root > TMemStat::Show(); or specifying arguments; root > TMemStat::Show(0.1,20,""mydir/mymemstat.root"");. The first argument to Show is the percentage of the time of the original job; that produced the file after which the display is updated. By default update=0.1,; ie 10 time intervals will be shown.; The second argument is nbigleaks.; The third argument is the imput file name (result of TMemStat).; If this argument is omitted, Show will take the most recent file; generated by TMemStat. You can restrict the address range to be analyzed via TMemStatShow::SetAddressRange; You can restrict the entry range to be analyzed via TMemStatShow::SetEntryRange. Function Members (Methods); public:. TMemStat(const TMemStat&); TMemStat(Option_t* option = ""read"", Int_t buffersize = 10000, Int_t maxcalls = 5000000); virtual~TMemStat(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMemStat.html:2798,Simpl,Simply,2798,root/html532/TMemStat.html,https://root.cern,https://root.cern/root/html532/TMemStat.html,2,['Simpl'],['Simply']
Usability,"for the maximum number of calls to be registered in the Tree.; The default value is 5000000.; The 3 arguments can be set in $ROOTSYS/etc/system.rootrc; Root.TMemStat.system gnubuiltin; Root.TMemStat.buffersize 100000; Root.TMemStat.maxcalls 5000000. TMemStat::Show creates 3 canvases.; -In canvas1 it displays a dynamic histogram showing for pages (10 kbytes by default); the percentage of the page used.; A summary pave shows the total memory still in use when the TMemStat object; goes out of scope and the average occupancy of the pages.; The average occupancy gives a good indication of the memory fragmentation. -In canvas2 it displays the histogram of memory leaks in decreasing order.; when moving the mouse on this canvas, a tooltip shows the backtrace for the leak; in the bin below the mouse. -In canvas3 it displays the histogram of the nbigleaks largest leaks (default is 20); for each leak, the number of allocs and average alloc size is shown. Simply do:; root > TMemStat::Show(); or specifying arguments; root > TMemStat::Show(0.1,20,""mydir/mymemstat.root"");. The first argument to Show is the percentage of the time of the original job; that produced the file after which the display is updated. By default update=0.1,; ie 10 time intervals will be shown.; The second argument is nbigleaks.; The third argument is the imput file name (result of TMemStat).; If this argument is omitted, Show will take the most recent file; generated by TMemStat. You can restrict the address range to be analyzed via TMemStatShow::SetAddressRange; You can restrict the entry range to be analyzed via TMemStatShow::SetEntryRange. Function Members (Methods); public:. virtual~TMemStat(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMemStat.html:2798,Simpl,Simply,2798,root/html602/TMemStat.html,https://root.cern,https://root.cern/root/html602/TMemStat.html,2,['Simpl'],['Simply']
Usability,"frame to contain the table; TGMainFrame* mainframe = new TGMainFrame(0, 400, 200);; mainframe->SetCleanup(kDeepCleanup) ;; ; // Create the table; TGTable *table = new TGTable(mainframe, 999, iface, 10, 6);; ; // Add the table to the main frame; mainframe->AddFrame(table, new TGLayoutHints(kLHintsExpandX | kLHintsExpandY));; ; // Set a selection; iface->SetSelection(""px > 0."");; // Add a column; iface->AddColumn(""(px+py)/(px-py)"", 0);; //update the table view; table->Update();; ; // Layout and map the main frame; mainframe->SetWindowName(""Tree Table Test"") ;; mainframe->MapSubwindows() ;; mainframe->Layout();; mainframe->Resize() ;; mainframe->MapWindow() ;; ; return mainframe;; }; TDirectoryFile::GetTObject * Get(const char *namecycle) overrideReturn pointer to object identified by namecycle.Definition TDirectoryFile.cxx:937; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TTreeTableInterfaceTTreeTableInterface is used to interface to data that is stored in a TTree.Definition TTreeTableInterface.h:25; TTreeTableInterface::SetSelectionvirtual void SetSelection(const char *selection)Set the selection expression.Definition TTreeTableInterface.cxx:140; TTreeTableInterface::AddColumnvirtual void AddColumn(const char *expression, UInt_t position)Add column according ot expression at position, TGTable->Update() is needed afterwards to apply the c...Definition TTreeTableInterface.cxx:378. Definition at line 34 of file TGTable.h. Public Member Functions;  TGTable (const TGWindow *p=nullptr, Int_t id=0, TVirtualTableInterface *interface=nullptr, UInt_t nrows=50, UInt_t ncolumns=20);  TGTable constuctor. ;  ;  ~TGTable () override;  TGTable destructor. ;  ; virtual TGTableCell * FindCell (TGString label);  Find the TGTableCell with label. ;  ; virtual const TGTableCell * FindCell (TGString label) const;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGTable.html:5833,simpl,simple,5833,doc/master/classTGTable.html,https://root.cern,https://root.cern/doc/master/classTGTable.html,1,['simpl'],['simple']
Usability,"frame width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGLVEntry*fEntryTmpused to transfer to feedback; TGLVContainer*fLVContaineroutput list view; TSessionViewer*fViewerpointer on the main viewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionOutputFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionOutputFrame(); Destructor. void Build(TSessionViewer* gui); Build query output information frame. void OnElementClicked(TGLVEntry* entry, Int_t btn, Int_t x, Int_t y); Handle mouse clicks on list view items. void OnElementDblClicked(TGLVEntry* entry, Int_t btn, Int_t x, Int_t y); Handle double-clicks on list view items. void AddObject(TObject* obj); Add object to output list view. TGLVContainer * GetLVContainer(); { return fLVContainer; }. void RemoveAll(); { fLVContainer->RemoveAll(); }. » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id$ » Last generated: 2015-03-14 16:49; This page has been automatically generated. For comments ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSessionOutputFrame.html:18902,feedback,feedback,18902,root/html534/TSessionOutputFrame.html,https://root.cern,https://root.cern/root/html534/TSessionOutputFrame.html,2,['feedback'],['feedback']
Usability,"frame width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGLVEntry*fEntryTmpused to transfer to feedback; TGLVContainer*fLVContaineroutput list view; TSessionViewer*fViewerpointer on the main viewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionOutputFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionOutputFrame(); Destructor. void Build(TSessionViewer* gui); Build query output information frame. void OnElementClicked(TGLVEntry* entry, Int_t btn, Int_t x, Int_t y); Handle mouse clicks on list view items. void OnElementDblClicked(TGLVEntry* entry, Int_t btn, Int_t x, Int_t y); Handle double-clicks on list view items. void AddObject(TObject* obj); Add object to output list view. TGLVContainer * GetLVContainer(); { return fLVContainer; }. void RemoveAll(); { fLVContainer->RemoveAll(); }. » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: TSessionViewer.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:20; This pa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSessionOutputFrame.html:18783,feedback,feedback,18783,root/html528/TSessionOutputFrame.html,https://root.cern,https://root.cern/root/html528/TSessionOutputFrame.html,1,['feedback'],['feedback']
Usability,"frame width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGLVEntry*fEntryTmpused to transfer to feedback; TGLVContainer*fLVContaineroutput list view; TSessionViewer*fViewerpointer on the main viewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionOutputFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionOutputFrame(); Destructor. void Build(TSessionViewer* gui); Build query output information frame. void OnElementClicked(TGLVEntry* entry, Int_t btn, Int_t x, Int_t y); Handle mouse clicks on list view items. void OnElementDblClicked(TGLVEntry* entry, Int_t btn, Int_t x, Int_t y); Handle double-clicks on list view items. void AddObject(TObject* obj); Add object to output list view. TGLVContainer * GetLVContainer(); { return fLVContainer; }. void RemoveAll(); { fLVContainer->RemoveAll(); }. » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: TSessionViewer.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:37; This pa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSessionOutputFrame.html:18883,feedback,feedback,18883,root/html530/TSessionOutputFrame.html,https://root.cern,https://root.cern/root/html530/TSessionOutputFrame.html,1,['feedback'],['feedback']
Usability,"frame width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGLVEntry*fEntryTmpused to transfer to feedback; TGLVContainer*fLVContaineroutput list view; TSessionViewer*fViewerpointer on the main viewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionOutputFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionOutputFrame(); Destructor. void Build(TSessionViewer* gui); Build query output information frame. void OnElementClicked(TGLVEntry* entry, Int_t btn, Int_t x, Int_t y); Handle mouse clicks on list view items. void OnElementDblClicked(TGLVEntry* entry, Int_t btn, Int_t x, Int_t y); Handle double-clicks on list view items. void AddObject(TObject* obj); Add object to output list view. TGLVContainer * GetLVContainer(); { return fLVContainer; }. void RemoveAll(); { fLVContainer->RemoveAll(); }. » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: TSessionViewer.h 40088 2011-06-30 15:10:06Z bellenot $ » Last generated: 2011-11-03 20:22; Th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSessionOutputFrame.html:18883,feedback,feedback,18883,root/html532/TSessionOutputFrame.html,https://root.cern,https://root.cern/root/html532/TSessionOutputFrame.html,2,['feedback'],['feedback']
Usability,"freeze choice of observables; for interpretation of fraction coefficients. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of range; for interpretation of fraction coefficients. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Return specialized context to efficiently generate toy events from RooAddPdfs. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Direct generation is safe if all components say so. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; Return pseud-code that indicates if all components can do internal generation (1) or not (0). void generateEvent(Int_t code); This function should never be called as RooAddModel implements a custom generator context. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooAddModel to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooAddModel(*this,newname) ; }. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force RooRealIntegral to offer all observables for internal integration. Bool_t selfNormalized() const; Model is self normalized when used as p.d.f. ExtendMode extendMode() const; Return extended mode capabilities. Double_t expectedEvents(const RooArgSet* nset) const. const RooArgList& pdfList() const; Return list of component p.d.fs. const RooArgList& coefList() const; Return list of coefficients of component p.d.f.s. CacheElem* getProjCache(const RooArgSet* nset, const RooArgSet* iset = 0, const char* rangeName = 0) const. » Last changed: Tue Jun 30 14:30:45 2015 » Last generated: 2015-06-30 14:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAddModel.html:53171,intuit,intuitively,53171,root/html602/RooAddModel.html,https://root.cern,https://root.cern/root/html602/RooAddModel.html,2,['intuit'],['intuitively']
Usability,"freeze choice of observables; for interpretation of fraction coefficients. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of range; for interpretation of fraction coefficients. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Return specialized context to efficiently generate toy events from RooAddPdfs. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Direct generation is safe if all components say so. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; Return pseud-code that indicates if all components can do internal generation (1) or not (0). void generateEvent(Int_t code); This function should never be called as RooAddModel implements a custom generator context. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooAddModel to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooAddModel(*this,newname) ; }. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force RooRealIntegral to offer all observables for internal integration. Bool_t selfNormalized() const; Model is self normalized when used as p.d.f. ExtendMode extendMode() const; Return extended mode capabilities. Double_t expectedEvents(const RooArgSet* nset) const. const RooArgList& pdfList() const; Return list of component p.d.fs. const RooArgList& coefList() const; Return list of coefficients of component p.d.f.s. CacheElem* getProjCache(const RooArgSet* nset, const RooArgSet* iset = 0, const char* rangeName = 0) const. » Last changed: Tue Mar 10 17:14:23 2015 » Last generated: 2015-03-10 17:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAddModel.html:51514,intuit,intuitively,51514,root/html534/RooAddModel.html,https://root.cern,https://root.cern/root/html534/RooAddModel.html,2,['intuit'],['intuitively']
Usability,"from fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long64_t pos, Int_t len);  Old method ReadBuffer before the addition of the prefetch mechanism. ;  ; virtual Int_t ReadBufferPrefetch (char *buf, Long64_t pos, Int_t len);  Used to read a chunk from a block previously fetched. ;  ; virtual void ResetCache ();  This will simply clear the cache. ;  ; void ResetMissCache ();  Reset all the miss cache training. ;  ; void SetAutoCreated (bool val);  ; Int_t SetBufferSize (Int_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; virtual void SetEntryRange (Long64_t emin, Long64_t emax);  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetFile (TFile *file, TFile::ECacheAction action=TFile::kDisconnect) override;  Change the file that is being cached. ;  ; virtual void SetLearnPrefill (EPrefillType type=kNoPrefill);  Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ;  ; void SetOptimizeMisses (bool opt);  Start of methods for the miss cache. ;  ; void StartLearningPhase ();  The name should be enough to explain the method. ;  ; virtual void StopLearningPhase ();  This is the counterpart of StartLearningPhase() and can be used to stop the learning phase. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void UpdateBranches (TTree *tree);  Update pointer to current Tree and recompute pointers to the branches in the cache. ;  ;  Public Member Functions inherited from TFileCacheRead;  TFileCacheRead ();  Default Constructor. ;  ;  TFileCacheRead (TFile *file, Int_t buffersize, TObject *tree=nullptr);  Creates a TFileCacheRead data structure. ;  ;  ~TFileCacheRead () override;  Destructor. ;  ; virtual void AddNoCacheBytesRead (Long64_t len);  ; virtual void A",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:15886,learn,learning,15886,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,1,['learn'],['learning']
Usability,"fsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidAdjustPos(); static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidCopy(TObject&) const; virtual voidCursorOff(); virtual voidCursorOn(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidTGView::DoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidDrawCursor(Int_t mode); static const TGGC&GetCursor0GC(); static const TGGC&GetCursor1GC(); static FontStruct_tTGTextView::GetDefaultFontStruct(); static const TGGC&TGTextView::GetDefaultGC(); static const TGGC&TGTextView::GetDefaultSelectedBackgroundGC(); static const TGGC&TGTextView::GetDefaultSelectedGC(); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; virtual voidTGTextView::HLayout(); voidInit(); virtual Bool_tTGView::ItemLayout(); voidTObject::MakeZombie(); virtual voidTGTextView::Mark(Long_t xPos, Long_t yPos); Int_tTGWidget::SetFlags(Int_t flags); virtual voidSetMenuState(); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE); virtual voidTGTextView::UnMark(); virtual voidTGView::UpdateRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidTGTextView::VLayout(). private:. TGTextEdit(const TGTextEdit&); TGTextEdit&operator=(const TGTextEdit&). Data Members; public:. enum EInser",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGTextEdit.html:19431,Clear,ClearFlags,19431,root/html532/TGTextEdit.html,https://root.cern,https://root.cern/root/html532/TGTextEdit.html,2,['Clear'],['ClearFlags']
Usability,"fter a loop on all batches Some layer (e.g. ;  ; void SetBatchSize (size_t batchSize);  Setters. ;  ; void SetDepth (size_t depth);  ; virtual void SetExtraLayerParameters (const std::vector< Matrix_t > &);  ; void SetHeight (size_t height);  ; void SetInputDepth (size_t inputDepth);  ; void SetInputHeight (size_t inputHeight);  ; void SetInputWidth (size_t inputWidth);  ; void SetIsTraining (bool isTraining);  ; void SetWidth (size_t width);  ; void Update (const Scalar_t learningRate);  Updates the weights and biases, given the learning rate. ;  ; void UpdateBiases (const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate);  Updates the biases, given the gradients and the learning rate. ;  ; void UpdateBiasGradients (const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate);  Updates the bias gradients, given some other weight gradients and learning rate. ;  ; void UpdateWeightGradients (const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate);  Updates the weight gradients, given some other weight gradients and learning rate. ;  ; void UpdateWeights (const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate);  Updates the weights, given the gradients and the learning rate,. ;  ; void WriteMatrixToXML (void *node, const char *name, const Matrix_t &matrix);  ; void WriteTensorToXML (void *node, const char *name, const std::vector< Matrix_t > &tensor);  helper functions for XML ;  . Private Attributes; Architecture_t::ActivationDescriptor_t fActivationDesc;  ; Tensor_t fDerivatives;  activation function gradient ;  ; Scalar_t fDropoutProbability;  Probability that an input is active. ;  ; EActivationFunction fF;  Activation function of the layer. ;  ; Tensor_t fInputActivation;  output of GEMM and input to activation function ;  ; ERegularization fReg;  The regularization method. ;  ; Scalar_t fWeightDecay;  The weight decay. ;  . Additional Inherited Members;  Protected Attributes inherited from",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDenseLayer.html:7093,learn,learningRate,7093,doc/master/classTMVA_1_1DNN_1_1TDenseLayer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDenseLayer.html,2,['learn'],"['learning', 'learningRate']"
Usability,"fter, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidTList::AddAt(TObject* obj, Int_t idx); virtual voidTList::AddBefore(const TObject* before, TObject* obj); virtual voidTList::AddBefore(TObjLink* before, TObject* obj); virtual voidTList::AddFirst(TObject* obj); virtual voidTList::AddFirst(TObject* obj, Option_t* opt); virtual voidTList::AddLast(TObject* obj); virtual voidTList::AddLast(TObject* obj, Option_t* opt); voidTCollection::AddVector(TObject* obj1); virtual TObject*TList::After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*TList::At(Int_t idx) const; voidAttachList(TList* alist); virtual TObject*TList::Before(const TObject* obj) const; TIterTCollection::begin() const; virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTList::Clear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTList::Delete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); TIterTCollection::end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofOutputList.html:1743,Clear,Clear,1743,root/html602/TProofOutputList.html,https://root.cern,https://root.cern/root/html602/TProofOutputList.html,2,['Clear'],['Clear']
Usability,"ful application of the log view is interactive cherry-picking: just press 'C' to cherry-pick currently selected commit into your current branch.; Blame view; Blame view is extremely useful to see which lines were committed by whom. It is an improved version of the standard git blame command with a much clearer and interactive output.; Each line can be selected to display the associated full commit log and diff. Usage:; tig blame path/to/file.cxx. Interactive staging and current status; tig status opens an interactive display to quickly select files to be staged. Move over the file and press 'u' to (un)stage it. The .gitconfig file; This file contains global (~/.gitconfig) or repository-local configuration settings. You can (eg):. Set user and email information to label commits usefully:; git config --global user.name ""Chris Green"" ; git config --global user.email <email-address>. Set colors for various types of command output.; Set which local branches track which remote branches.; Set pull behavior for branches to be rebase rather than merge.; Define aliases as shortcuts for internal or external commands. See the attached .gitconfig example. Have fun!; Reproduced with permission from the following page: https://cdcvs.fnal.gov/redmine/projects/cet-is-public/wiki/GitTipsAndTri... by Chris Green. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/git-tips-and-tricks.html:19044,guid,guidelines,19044,d/git-tips-and-tricks.html,https://root.cern,https://root.cern/d/git-tips-and-tricks.html,1,['guid'],['guidelines']
Usability,"function ;  CMCMCIntervalMCMCInterval is a concrete implementation of the RooStats::ConfInterval interface ;  CMCMCIntervalPlotThis class provides simple and straightforward utilities to plot a MCMCInterval object ;  CMetropolisHastingsThis class uses the Metropolis-Hastings algorithm to construct a Markov Chain of data points using Monte Carlo ;  CMinNLLTestStatMinNLLTestStat is an implementation of the TestStatistic interface that calculates the minimum value of the negative log likelihood function and returns it as a test statistic ;  CModelConfigModelConfig is a simple class that holds configuration information specifying how a model should be used in the context of various RooStats tools ;  CNeymanConstructionNeymanConstruction is a concrete implementation of the NeymanConstruction interface that, as the name suggests, performs a NeymanConstruction ;  CNuisanceParametersSamplerHelper class for ToyMCSampler ;  CNumberCountingPdfFactory;  CNumEventsTestStatNumEventsTestStat is a simple implementation of the TestStatistic interface used for simple number counting ;  CPdfProposalPdfProposal is a concrete implementation of the ProposalFunction interface ;  CPointSetIntervalPointSetInterval is a concrete implementation of the ConfInterval interface ;  CProfileInspector;  CProfileLikelihoodCalculatorProfileLikelihoodCalculator is a concrete implementation of CombinedCalculator (the interface class for a tools which can produce both RooStats HypoTestResults and ConfIntervals) ;  CProfileLikelihoodTestStatProfileLikelihoodTestStat is an implementation of the TestStatistic interface that calculates the profile likelihood ratio at a particular parameter point given a dataset ;  CProofConfigHolds configuration options for proof and proof-lite ;  CProposalFunctionProposalFunction is an interface for all proposal functions that would be used with a Markov Chain Monte Carlo algorithm ;  CProposalHelper;  CRatioOfProfiledLikelihoodsTestStatTestStatistic that returns the ratio o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:7581,simpl,simple,7581,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,1,['simpl'],['simple']
Usability,"function should copy the subset of dependents it can analytically integrate to anaIntSet and return a unique identification code for this integration configuration. If no integration can be performed, zero should be returned. ; Reimplemented from RooAbsReal.; Definition at line 80 of file RooBifurGauss.cxx. ◆ IsA(). TClass * RooBifurGauss::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 49 of file RooBifurGauss.h. ◆ Streamer(). void RooBifurGauss::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsPdf. ◆ StreamerNVirtual(). void RooBifurGauss::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 49 of file RooBifurGauss.h. ◆ translate(). void RooBifurGauss::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 65 of file RooBifurGauss.cxx. Member Data Documentation. ◆ mean. RooRealProxy RooBifurGauss::mean. protected . Definition at line 40 of file RooBifurGauss.h. ◆ sigmaL. RooRealProxy RooBifurGauss::sigmaL. protected . Definition at line 41 of file RooBifurGauss.h. ◆ sigmaR. RooRealProxy RooBifurGauss::sigmaR. protected . Definition at line 42 of file RooBifurGauss.h. ◆ x. RooRealProxy RooBifurGauss::x. protected . Definition at ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBifurGauss.html:77941,simpl,simple,77941,doc/master/classRooBifurGauss.html,https://root.cern,https://root.cern/doc/master/classRooBifurGauss.html,1,['simpl'],['simple']
Usability,"function should copy the subset of dependents it can analytically integrate to anaIntSet and return a unique identification code for this integration configuration. If no integration can be performed, zero should be returned. ; Reimplemented from RooAbsReal.; Definition at line 80 of file RooEfficiency.cxx. ◆ IsA(). TClass * RooEfficiency::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 48 of file RooEfficiency.h. ◆ Streamer(). void RooEfficiency::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsPdf. ◆ StreamerNVirtual(). void RooEfficiency::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 48 of file RooEfficiency.h. ◆ translate(). void RooEfficiency::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 90 of file RooEfficiency.cxx. Member Data Documentation. ◆ _cat. RooCategoryProxy RooEfficiency::_cat. protected . Accept/reject categort. ; Definition at line 44 of file RooEfficiency.h. ◆ _effFunc. RooRealProxy RooEfficiency::_effFunc. protected . Efficiency modeling function. ; Definition at line 45 of file RooEfficiency.h. ◆ _sigCatName. TString RooEfficiency::_sigCatName. protected . Name of accept state of accept/reject ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooEfficiency.html:78465,simpl,simple,78465,doc/master/classRooEfficiency.html,https://root.cern,https://root.cern/doc/master/classRooEfficiency.html,1,['simpl'],['simple']
Usability,"g = """"); Float_t*TAttBBox::AssertBBox(); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; static voidCheckAndFixBoxOrientationEv(TEveVector[8] box); static voidCheckAndFixBoxOrientationFv(Float_t[8][3] box); virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElementList*TEveElementList::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTAttBBox::ComputeBBox(); virtual voidTNamed::Copy(TObject& named) const; virtual voidCopyVizParams(const TEveElement* el); virtual voidTEveElement::CopyVizParamsFromDB(); voidTEveElement::CSCApplyMainColorToAllChildren(); voidTEveElement::CSCApplyMainColorToMatchingChildren(); voidTEveElement::CSCApplyMainTransparencyToAllChildren(); voidTEveElement::CSCApplyMainTransparencyToMatchingChildren(); voidTEveElement::CSCImplySelectAllChildren(); voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveShape.html:2735,Clear,ClearStamps,2735,root/html602/TEveShape.html,https://root.cern,https://root.cern/root/html602/TEveShape.html,2,['Clear'],['ClearStamps']
Usability,"g > var, bool silent=false);  Add an argument and transfer the ownership to the collection from a std::unique_ptr. ;  ; template<class Arg_t > ; bool addTyped (const RooAbsCollection &list, bool silent=false);  Adds elements of a given RooAbsCollection to the container if they match the specified type. ;  ; bool allInRange (const char *rangeSpec) const;  Return true if all contained object report to have their value inside the specified range. ;  ; void assign (const RooAbsCollection &other) const;  Sets the value, cache and constant attribute of any argument in our set that also appears in the other set. ;  ; void assignFast (const RooAbsCollection &other, bool setValDirty=true) const;  Functional equivalent of assign() but assumes this and other collection have same layout. ;  ; RooAbsCollection & assignValueOnly (const RooAbsCollection &other, bool forceIfSizeOne=false);  Sets the value of any argument in our set that also appears in the other set. ;  ; const_iterator begin () const;  ; void clear ();  Clear contents. If the collection is owning, it will also delete the contents. ;  ; TObject * Clone (const char *newname=nullptr) const override;  Make a clone of an object using the Streamer facility. ;  ; bool contains (const RooAbsArg &var) const;  Check if collection contains an argument with the same name as var. ;  ; std::string contentsString () const;  Return comma separated list of contained object names as STL string. ;  ; Int_t defaultPrintContents (Option_t *opt) const override;  Define default RooPrinable print options for given Print() flag string For inline printing only show value of objects, for default print show name,class name value and extras of each object. ;  ; void dump () const;  Base contents dumper for debugging purposes. ;  ; bool empty () const;  ; const_iterator end () const;  ; bool equals (const RooAbsCollection &otherColl) const;  Check if this and other collection have identically-named contents. ;  ; RooAbsArg * find (const char *n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooArgSet.html:8743,clear,clear,8743,doc/master/classRooArgSet.html,https://root.cern,https://root.cern/doc/master/classRooArgSet.html,1,['clear'],['clear']
Usability,"g > var, bool silent=false);  Add an argument and transfer the ownership to the collection from a std::unique_ptr. ;  ; template<class Arg_t > ; bool addTyped (const RooAbsCollection &list, bool silent=false);  Adds elements of a given RooAbsCollection to the container if they match the specified type. ;  ; bool allInRange (const char *rangeSpec) const;  Return true if all contained object report to have their value inside the specified range. ;  ; void assign (const RooAbsCollection &other) const;  Sets the value, cache and constant attribute of any argument in our set that also appears in the other set. ;  ; void assignFast (const RooAbsCollection &other, bool setValDirty=true) const;  Functional equivalent of assign() but assumes this and other collection have same layout. ;  ; RooAbsCollection & assignValueOnly (const RooAbsCollection &other, bool forceIfSizeOne=false);  Sets the value of any argument in our set that also appears in the other set. ;  ; const_iterator begin () const;  ; void clear ();  Clear contents. If the collection is owning, it will also delete the contents. ;  ; TObject * Clone (const char *newname=nullptr) const override;  Make a clone of an object using the Streamer facility. ;  ; bool contains (const RooAbsArg &var) const;  Check if collection contains an argument with the same name as var. ;  ; virtual bool containsInstance (const RooAbsArg &var) const;  Check if this exact instance is in this collection. ;  ; std::string contentsString () const;  Return comma separated list of contained object names as STL string. ;  ; Int_t defaultPrintContents (Option_t *opt) const override;  Define default RooPrinable print options for given Print() flag string For inline printing only show value of objects, for default print show name,class name value and extras of each object. ;  ; void dump () const;  Base contents dumper for debugging purposes. ;  ; bool empty () const;  ; const_iterator end () const;  ; bool equals (const RooAbsCollection &other",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooArgList.html:6159,clear,clear,6159,doc/master/classRooArgList.html,https://root.cern,https://root.cern/doc/master/classRooArgList.html,1,['clear'],['clear']
Usability,"g > var, bool silent=false);  Add an argument and transfer the ownership to the collection from a std::unique_ptr. ;  ; template<class Arg_t > ; bool addTyped (const RooAbsCollection &list, bool silent=false);  Adds elements of a given RooAbsCollection to the container if they match the specified type. ;  ; bool allInRange (const char *rangeSpec) const;  Return true if all contained object report to have their value inside the specified range. ;  ; void assign (const RooAbsCollection &other) const;  Sets the value, cache and constant attribute of any argument in our set that also appears in the other set. ;  ; void assignFast (const RooAbsCollection &other, bool setValDirty=true) const;  Functional equivalent of assign() but assumes this and other collection have same layout. ;  ; RooAbsCollection & assignValueOnly (const RooAbsCollection &other, bool forceIfSizeOne=false);  Sets the value of any argument in our set that also appears in the other set. ;  ; const_iterator begin () const;  ; void clear ();  Clear contents. If the collection is owning, it will also delete the contents. ;  ; virtual TObject * clone (const char *newname) const =0;  ; TObject * Clone (const char *newname=nullptr) const override;  Make a clone of an object using the Streamer facility. ;  ; bool contains (const RooAbsArg &var) const;  Check if collection contains an argument with the same name as var. ;  ; virtual bool containsInstance (const RooAbsArg &var) const;  Check if this exact instance is in this collection. ;  ; std::string contentsString () const;  Return comma separated list of contained object names as STL string. ;  ; virtual TObject * create (const char *newname) const =0;  ; Int_t defaultPrintContents (Option_t *opt) const override;  Define default RooPrinable print options for given Print() flag string For inline printing only show value of objects, for default print show name,class name value and extras of each object. ;  ; void dump () const;  Base contents dumper for debu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCollection.html:5154,clear,clear,5154,doc/master/classRooAbsCollection.html,https://root.cern,https://root.cern/doc/master/classRooAbsCollection.html,1,['clear'],['clear']
Usability,g Contours From TH2D ;  peaks2.C Example to illustrate the 2-d peak finder (class TSpectrum2) ;  SearchHR1.C Example to illustrate high resolution peak searching function (class TSpectrum) ;  SearchHR3.C Example to illustrate the influence of number of iterations in deconvolution in high resolution peak searching function (class TSpectrum) ;  Smoothing.C Example to illustrate smoothing using Markov algorithm (class TSpectrum) ;  spectrumpainter.C Examples showing how to use TSpectrum2Painter (the SPEC option) ;  ► splot;  TestSPlot.CThis tutorial illustrates the use of class TSPlot and of the sPlots method ;  ► sql;  sqlcanvas.CThis is slight modification of ntuple1.C example ;  sqlcreatedb.CCreate a runcatalog table in a MySQL test database ;  sqlfilldb.CFill run catalog with nfiles entries ;  sqlselect.C;  sqltables.CThis is an example illustrating how the TSQLFile class can be used ;  ► thread;  stressThreadPool.CUsage: ;  threadPool.CUsage: ;  threads.CExample of a simple script creating 3 threads ;  threadsh1.CExample of a simple script creating 3 threads ;  threadsh2.CExample of a simple script creating 2 threads each with one canvas ;  ► tmva;  ► envelope;  classification.C;  ► keras;  ApplicationClassificationKeras.py;  ApplicationRegressionKeras.py;  ClassificationKeras.py;  GenerateModel.py;  LaunchClasGUI.C;  LaunchMultiGUI.C;  LaunchRegGUI.C;  MulticlassKeras.py;  RegressionKeras.py;  createData.CPlot the variables ;  TMVAClassification.C This macro provides examples for the training and testing of the TMVA classifiers ;  TMVAClassificationApplication.C This macro provides a simple example on how to use the trained classifiers within an analysis module ;  TMVAClassificationCategory.C This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode ;  TMVAClassificationCategoryApplication.C This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ;  TMVAC,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:155139,simpl,simple,155139,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,1,['simpl'],['simple']
Usability,g Contours From TH2D ;  peaks2.C Example to illustrate the 2-d peak finder (class TSpectrum2) ;  SearchHR1.C Example to illustrate high resolution peak searching function (class TSpectrum) ;  SearchHR3.C Example to illustrate the influence of number of iterations in deconvolution in high resolution peak searching function (class TSpectrum) ;  Smoothing.C Example to illustrate smoothing using Markov algorithm (class TSpectrum) ;  spectrumpainter.C Examples showing how to use TSpectrum2Painter (the SPEC option) ;  ► splot;  TestSPlot.CThis tutorial illustrates the use of class TSPlot and of the sPlots method ;  ► sql;  sqlcanvas.CThis is slight modification of ntuple1.C example ;  sqlcreatedb.CCreate a runcatalog table in a MySQL test database ;  sqlfilldb.CFill run catalog with nfiles entries ;  sqlselect.C;  sqltables.CThis is an example illustrating how the TSQLFile class can be used ;  ► thread;  stressThreadPool.CUsage: ;  threadPool.CUsage: ;  threads.CExample of a simple script creating 3 threads ;  threadsh1.CExample of a simple script creating 3 threads ;  threadsh2.CExample of a simple script creating 2 threads each with one canvas ;  ► tmva;  ► keras;  ApplicationClassificationKeras.py;  ApplicationRegressionKeras.py;  ClassificationKeras.py;  GenerateModel.py;  LaunchClasGUI.C;  LaunchMultiGUI.C;  LaunchRegGUI.C;  MulticlassKeras.py;  RegressionKeras.py;  createData.CPlot the variables ;  TMVAClassification.C This macro provides examples for the training and testing of the TMVA classifiers ;  TMVAClassificationApplication.C This macro provides a simple example on how to use the trained classifiers within an analysis module ;  TMVAClassificationCategory.C This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode ;  TMVAClassificationCategoryApplication.C This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ;  TMVACrossValidation.C This example ex,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/files.html:154345,simpl,simple,154345,doc/v610/files.html,https://root.cern,https://root.cern/doc/v610/files.html,1,['simpl'],['simple']
Usability,"g Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Development Run the tests. Running the ROOT battery of tests; Running all ROOT tests on at least a platform before sending a PR or before pushing anything to the ROOT repository is mandatory.; The ROOT continuous integration infrastructure allows to automatically check the PR also on a battery of platform, for example including macos and linux boxes.; In order to be able to run all tests, the simple steps below need to be followed; Prepare your development area and build ROOT; mkdir RootDevelopment; cd RootDevelopment; git clone https://github.com/root-project/root; git clone https://github.com/root-project/roottest; mkdir build; cd build; echo Note the cmake options; cmake -DCMAKE_BUILD_TYPE=Debug -Dtesting=ON -Droottest=ON ../root. Inspect and run the tests; From within the build directory. List all tests: ctest -N; List all test matching a regex: ctest -N -R myregex; Run all tests on N cores: ctest -j N. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/run-tests.html:3007,guid,guidelines,3007,d/run-tests.html,https://root.cern,https://root.cern/d/run-tests.html,1,['guid'],['guidelines']
Usability,"g from the compilation.; static atomic<Int_t>fgCountNumber of TStreamerInfo instances. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TVirtualStreamerInfo. ←; TStreamerInfo. Function documentation; TStreamerInfo(); Default ctor. TStreamerInfo(TClass* cl); Create a TStreamerInfo object. ~TStreamerInfo(); TStreamerInfo dtor. void Build(); Build the I/O data structure for the current class version.; A list of TStreamerElement derived classes is built by scanning; one by one the list of data members of the analyzed class. void BuildCheck(TFile* file = 0); Check if built and consistent with the class dictionary.; This method is called by TFile::ReadStreamerInfo. void BuildEmulated(TFile* file); Create an Emulation TStreamerInfo object. Bool_t BuildFor(const TClass* cl). Check if we can build this for foreign class - do we have some rules; to do that. void BuildOld(); rebuild the TStreamerInfo structure. void Clear(Option_t* ); If opt cointains 'built', reset this StreamerInfo as if Build or BuildOld; was never called on it (usefull to force their re-running). void CallShowMembers(const void* obj, TMemberInspector& insp, Bool_t isTransient) const; Emulated a call ShowMembers() on the obj of this class type, passing insp and parent. TObject * Clone(const char* newname = """") const; Make a clone of an object using the Streamer facility.; If newname is specified, this will be the name of the new object. Bool_t CompareContent(TClass* cl, TVirtualStreamerInfo* info, Bool_t warn, Bool_t complete, TFile* file); Return True if the current StreamerInfo in cl or info is equivalent to this TStreamerInfo.; 'Equivalent' means the same number of persistent data member which the same actual C++ type and; the same name.; if 'warn' is true, Warning message are printed to explicit the differences.; if 'complete' is false, stop at the first error, otherwise continue until all members have been checked. void ComputeSize(); Compute total size of all persistent elements of the class. v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TStreamerInfo.html:22705,Clear,Clear,22705,root/html602/TStreamerInfo.html,https://root.cern,https://root.cern/root/html602/TStreamerInfo.html,1,['Clear'],['Clear']
Usability,"g in; the list, or just added.; The boolean merged is set to kFALSE when the object is just added to 'outlist';; this happens if the Merge() method does not exist or if a object named as 'obj'; is not already in the list. If the obj is not 'merged' than it should not be; deleted, unless outlist is not owner of its objects.; Return 0 on success, -1 on error. TObject * HandleHistogram(TObject* obj); Low statistic histograms need a special treatment when using autobin. Bool_t HistoSameAxis(TH1* h0, TH1* h1); Return kTRUE is the histograms 'h0' and 'h1' have the same binning and ranges; on the axis (i.e. if they can be just Add-ed for merging). void StoreOutput(TList* out); Store received output list. TList * MergeFeedback(); Merge feedback lists. void StoreFeedback(TObject* slave, TList* out); Store feedback results from the specified slave. void SetupFeedback(); Setup reporting of feedback objects. void StopFeedback(); Stop reporting of feedback objects. Bool_t HandleTimer(TTimer* timer); Send feedback objects to client. TDSetElement * GetNextPacket(TSlave* slave, TMessage* r); Get next packet for specified slave. Bool_t IsClient() const; Is the player running on the client?. Long64_t DrawSelect(TDSet* set, const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Draw (support for TChain::Draw()).; Returns -1 in case of error or number of selected events in case of success. void SetInitTime(); Set init time. TVirtualPacketizer * GetPacketizer() const; { return 0; }. void Progress(Long64_t total, Long64_t processed). void Progress(TSlave* , Long64_t total, Long64_t processed); { Progress(total, processed); }. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti). TProof * GetProof() const; { return fProof; }. TProofPlayerRemote(TProof* proof = 0); { fProgressStatus = new TProofProgressStatus(); }. » Author: Maarten Ballintijn 07/",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofPlayerRemote.html:19447,feedback,feedback,19447,root/html530/TProofPlayerRemote.html,https://root.cern,https://root.cern/root/html530/TProofPlayerRemote.html,1,['feedback'],['feedback']
Usability,"g multiple values of a RooAbsReal. ;  ; const std::vector< double > & high () const;  ; const std::vector< int > & interpolationCodes () const;  ; TClass * IsA () const override;  ; const std::vector< double > & low () const;  ; double nominal () const;  ; void printAllInterpCodes ();  ; virtual void printFlexibleInterpVars (std::ostream &os) const;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Interface for detailed printing of object. ;  ; void setAllInterpCodes (int code);  ; void setGlobalBoundary (double boundary);  ; void setHigh (RooAbsReal &param, double newHigh);  ; void setInterpCode (RooAbsReal &param, int code);  ; void setLow (RooAbsReal &param, double newLow);  ; void setNominal (double newNominal);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void translate (RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ; const RooListProxy & variables () const;  ;  Public Member Functions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooAbsReal () override;  Destructor. ;  ; virtual double analyticalIntegral (Int_t code, const char *rangeName=nullptr) const;  Implements the actual analytical integral(s) advertised by getAnalyticalIntegral. ;  ; virtual double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const;  Implements the actua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1HistFactory_1_1FlexibleInterpVar.html:2384,simpl,simple,2384,doc/master/classRooStats_1_1HistFactory_1_1FlexibleInterpVar.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1HistFactory_1_1FlexibleInterpVar.html,1,['simpl'],['simple']
Usability,"g none. Their proper usage is for setting attributes, properties or values; also for data or choices that are discrete, small and fixed in number, not easily remembered. With check boxes all alternatives are visible: it is easy to access and compare choices because they can all be seen together. Each option acts as a switch and can be either “on” or “off”. It is never changed in contents. Checkboxes differ from radio buttons in that they permit selection of more than one alternative. Each box can be switched on or off independently. These buttons can be used alone or grouped in sets. It is good practice to provide default settings for check boxes whenever it is possible. This can be done by:; SetState(EButtonState state); The parameter state can be one of kButtonUp, kButtonDown, kButtonEngaged, kButtonDisabled.; Check boxes can be used to affect other controls. The contents of a list can, for example, be filtered by setting a check box. In any case, use a check box only when both states of a choice are clearly opposite and unambiguous. If opposite states are not clear, it is better to use two radio buttons.; Choice description, i.e. check box label, must be clear, meaningful, fully spelled out, and displayed in mixed-type text. Whenever the use of a given button is inappropriate, for whatever reason, that button should be disabled:; button->SetState(kButtonDisabled);; Never make a button appear and disappear.; In general, option buttons should not offer more than eight choices. If the number of choices exceeds this maximum, it is better to use a multiple selection list box.; The method IsToggleButton() gives the information whether a radio button or a check button is selected. An option button can be set or unset via its method PSetState(EButtonState state).; The method HandleKey(event) is called when the defined hotkey is hit for any button. It sets the selected option button or clicks the selected text button and invokes its defined action.; 25.8.2 Text Entries; A ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1184393,clear,clearly,1184393,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['clear'],['clearly']
Usability,"g on the type of FCN function passesd and on the objects used for the parameters ;  CMPIProcess;  CMPITerminate;  CNegativeG2LineSearchIn case that one of the components of the second derivative g2 calculated by the numerical Gradient calculator is negative, a 1dim line search in the direction of that component is done in order to find a better position where g2 is again positive ;  CNumerical2PGradientCalculatorClass performing the numerical gradient calculation ;  CParametricFunctionFunction which has parameters ;  CScanBuilderPerforms a minimization using the simplex method of Nelder and Mead (ref ;  CScanMinimizerClass implementing the required methods for a minimization using SCAN API is provided in the upper ROOT::Minuit2::ModularFunctionMinimizer class ;  CSimplexBuilderPerforms a minimization using the simplex method of Nelder and Mead (ref ;  CSimplexMinimizerClass implementing the required methods for a minimization using Simplex ;  CSimplexParametersClass describing the simplex set of points (f(x), x ) which evolve during the minimization iteration process ;  CSimplexSeedGeneratorGenerate Simplex starting point (state) ;  CSinParameterTransformationClass for the transformation for double-limited parameter Using a sin function one goes from a double-limited parameter range to an unlimited one ;  CSqrtLowParameterTransformationTransformation from external to internal Parameter based on sqrt(1 + x**2) ;  CSqrtUpParameterTransformationTransformation from external to internal Parameter based on sqrt(1 + x**2) ;  CStackAllocatorStackAllocator controls the memory allocation/deallocation of Minuit ;  CStackAllocatorHolder;  CStackError;  CStackOverflowDefine stack allocator symbol ;  Csym;  CVariableMetricBuilderBuild (find) function minimum using the Variable Metric method (MIGRAD) ;  CVariableMetricEDMEstimator;  CVariableMetricMinimizerInstantiates the SeedGenerator and MinimumBuilder for Variable Metric Minimization method ;  Cvec;  CVectorOuterProduct;  ►NQu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:70320,simpl,simplex,70320,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,1,['simpl'],['simplex']
Usability,"g on the type of FCN function passesd and on the objects used for the parameters ;  CMPIProcess;  CMPITerminate;  CNegativeG2LineSearchIn case that one of the components of the second derivative g2 calculated by the numerical Gradient calculator is negative, a 1dim line search in the direction of that component is done in order to find a better position where g2 is again positive ;  CNumerical2PGradientCalculatorClass performing the numerical gradient calculation ;  CParametricFunctionFunction which has parameters ;  CScanBuilderPerforms a minimization using the simplex method of Nelder and Mead (ref ;  CScanMinimizerClass implementing the required methods for a minimization using SCAN API is provided in the upper ROOT::Minuit2::ModularFunctionMinimizer class ;  CSimplexBuilderPerforms a minimization using the simplex method of Nelder and Mead (ref ;  CSimplexMinimizerClass implementing the required methods for a minimization using Simplex ;  CSimplexParametersClass describing the simplex set of points (f(x), x ) which evolve during the minimization iteration process ;  CSimplexSeedGeneratorGenerate Simplex starting point (state) ;  CSinParameterTransformationClass for the transformation for double-limited parameter Using a sin function one goes from a double-limited parameter range to an unlimited one ;  CSqrtLowParameterTransformationTransformation from external to internal Parameter based on sqrt(1 + x**2) ;  CSqrtUpParameterTransformationTransformation from external to internal Parameter based on sqrt(1 + x**2) ;  CStackAllocatorStackAllocator controls the memory allocation/deallocation of Minuit ;  CStackAllocatorHolder;  CStackError;  CStackOverflowDefine stack allocator symbol ;  Csym;  CVariableMetricBuilderBuild (find) function minimum using the Variable Metric method (MIGRAD) Two possible error updators can be choosen ;  CVariableMetricEDMEstimator;  ►CVariableMetricMinimizerInstantiates the SeedGenerator and MinimumBuilder for Variable Metric Minimization",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/annotated.html:71570,simpl,simplex,71570,doc/v614/annotated.html,https://root.cern,https://root.cern/doc/v614/annotated.html,3,['simpl'],['simplex']
Usability,"g routines.; 14 ; 15This file defines a number of global error handling routines:; 16Warning(), Error(), SysError() and Fatal(). They all take a; 17location string (where the error happened) and a printf style format; 18string plus vararg's. In the end these functions call an; 19errorhandler function. Initially the MinimalErrorHandler, which is supposed; 20to be replaced by the proper DefaultErrorHandler(); 21*/; 22 ; 23#include ""TError.h""; 24 ; 25#include <cstdarg>; 26#include <cstdio>; 27#include <cstdlib>; 28#include <cerrno>; 29#include <string>; 30 ; 31Int_t gErrorIgnoreLevel = kUnset;; 32Int_t gErrorAbortLevel = kSysError+1;; 33Bool_t gPrintViaErrorHandler = kFALSE;; 34 ; 35const char *kAssertMsg = ""%s violated at line %d of `%s'"";; 36const char *kCheckMsg = ""%s not true at line %d of `%s'"";; 37 ; 38static ErrorHandlerFunc_t gErrorHandler = ROOT::Internal::MinimalErrorHandler;; 39 ; 40 ; 41static ROOT::Internal::ErrorSystemMsgHandlerFunc_t &GetErrorSystemMsgHandlerRef(); 42{; 43 static ROOT::Internal::ErrorSystemMsgHandlerFunc_t h;; 44 return h;; 45}; 46 ; 47 ; 48namespace ROOT {; 49namespace Internal {; 50 ; 51ErrorSystemMsgHandlerFunc_t GetErrorSystemMsgHandler(); 52{; 53 return GetErrorSystemMsgHandlerRef();; 54}; 55 ; 56ErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystemMsgHandlerFunc_t h); 57{; 58 auto oldHandler = GetErrorSystemMsgHandlerRef();; 59 GetErrorSystemMsgHandlerRef() = h;; 60 return oldHandler;; 61}; 62 ; 63/// A very simple error handler that is usually replaced by the TROOT default error handler.; 64/// The minimal error handler is not serialized across threads, so that output of multi-threaded programs; 65/// can get scrambled; 66/// @note `abort()` is only called if `abort_bool` is `true` and `level >= gErrorIgnoreLevel`; 67void MinimalErrorHandler(Int_t level, Bool_t abort_bool, const char *location, const char *msg); 68{; 69 if (level < gErrorIgnoreLevel); 70 return;; 71 ; 72 if (level >= kBreak); 73 fprintf(stderr, ""\n *** ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TError_8cxx_source.html:2126,simpl,simple,2126,doc/master/TError_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html,1,['simpl'],['simple']
Usability,"g terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TTreeViewer; 13A graphic user interface designed to handle ROOT trees and to take advantage of; 14TTree class features.; 15 ; 16It uses ROOT native GUI widgets adapted for ""drag and drop"" functionality.; 17in the same session.; 18 ; 19### The following capabilities are making the viewer a helpful tool for analysis:; 20 ; 21 - several trees may be opened in the same session;; 22 - branches and leaves can be easily browsed or scanned;; 23 - fast drawing of branch expressions by double-clicking;; 24 - new variables/selections easy to compose with the built-in editor;; 25 - histograms can be composed by dragging leaves or user-defined expressions; 26 to X, Y and Z axis items;; 27 - the tree entries to be processed can be selected with a double slider;; 28 - selections can be defined and activated by dragging them to the 'Cut' item;; 29 - all expressions can be aliased and aliases can be used in composing others;; 30 - input/output event lists easy to handle;; 31 - menu with histogram drawing options;; 32 - user commands may be executed within the viewer and the current command; 33 can be echoed;; 34 - current 'Draw' event loop is reflected by a progress bar and may be; 35 interrupted by the user;; 36 - all widgets have self-explaining tool tips and/or context menus;; 37 - expressions/leaves can be dragged to a 'scan box' and scanned by; 38 double-clicking this item. The result can be redirected to an ASCII file;; 39 ; 40### The layout has the following items:; 41 ; 42 - a menu bar with entries : File, Edit, Run, Options and Help;; 43 - a toolbar in the upper part where you can issue user commands, change; 44 the drawing option and the histogram name, three check buttons Hist, Rec; 45 and Scan.HIST toggles histogram drawing mode, REC enables recording of the; 46 last command issu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeViewer_8cxx_source.html:1855,progress bar,progress bar,1855,doc/master/TTreeViewer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html,1,['progress bar'],['progress bar']
Usability,"g this class . ◆ Class_Name(). static const char * RooChangeTracker::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooChangeTracker::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 49 of file RooChangeTracker.h. ◆ clone(). TObject * RooChangeTracker::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 30 of file RooChangeTracker.h. ◆ DeclFileName(). static const char * RooChangeTracker::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 49 of file RooChangeTracker.h. ◆ evaluate(). double RooChangeTracker::evaluate ; (; ); const. inlineoverrideprotectedvirtual . Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ; Implements RooAbsReal.; Definition at line 47 of file RooChangeTracker.h. ◆ hasChanged(). bool RooChangeTracker::hasChanged ; (; bool ; clearState). Returns true if state has changed since last call with clearState=true. ; If clearState is true, changeState flag will be cleared. ; Definition at line 104 of file RooChangeTracker.cxx. ◆ IsA(). TClass * RooChangeTracker::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsReal.; Definition at line 49 of file RooChangeTracker.h. ◆ parameters(). RooArgSet RooChangeTracker::parameters ; (; ); const. Definition at line 188 of file RooChangeTracker.cxx. ◆ Streamer(). void RooChangeTracker::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsReal. ◆ StreamerNVirtual(). void RooChangeTracker::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 49 of file RooChangeTracker.h. Member Data Documentation. ◆ _catRef. std::vector<Int_t> RooChangeTracker::_catRef. protected . Reference values for categories. ; Def",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChangeTracker.html:62728,clear,clearState,62728,doc/master/classRooChangeTracker.html,https://root.cern,https://root.cern/doc/master/classRooChangeTracker.html,1,['clear'],['clearState']
Usability,"g weight file: datasetcv/weights/TMVACrossValidation_Fisher_fold2.weights.xml; : Booked classifier ""Fisher"" of type: ""CrossValidation""; : Rebuilding Dataset Default; (int) 0; ; #include <cstdlib>; #include <iostream>; #include <map>; #include <string>; ; #include ""TChain.h""; #include ""TFile.h""; #include ""TTree.h""; #include ""TString.h""; #include ""TObjString.h""; #include ""TSystem.h""; #include ""TROOT.h""; ; #include ""TMVA/Factory.h""; #include ""TMVA/DataLoader.h""; #include ""TMVA/Tools.h""; #include ""TMVA/TMVAGui.h""; ; // Helper function to load data into TTrees.; TTree *fillTree(TTree * tree, Int_t nPoints, Double_t offset, Double_t scale, UInt_t seed = 100); {; TRandom3 rng(seed);; Float_t x = 0;; Float_t y = 0;; Int_t eventID = 0;; ; tree->SetBranchAddress(""x"", &x);; tree->SetBranchAddress(""y"", &y);; tree->SetBranchAddress(""eventID"", &eventID);; ; for (Int_t n = 0; n < nPoints; ++n) {; x = rng.Gaus(offset, scale);; y = rng.Gaus(offset, scale);; ; // For our simple example it is enough that the id's are uniformly; // distributed and independent of the data.; ++eventID;; ; tree->Fill();; }; ; // Important: Disconnects the tree from the memory locations of x and y.; tree->ResetBranchAddresses();; return tree;; }; ; int TMVACrossValidationApplication(); {; // This loads the library; TMVA::Tools::Instance();; ; // Set up the TMVA::Reader; TMVA::Reader *reader = new TMVA::Reader(""!Color:!Silent:!V"");; ; Float_t x;; Float_t y;; Int_t eventID;; ; reader->AddVariable(""x"", &x);; reader->AddVariable(""y"", &y);; reader->AddSpectator(""eventID"", &eventID);; ; // Book the serialised methods; TString jobname(""TMVACrossValidation"");; {; TString methodName = ""BDTG"";; TString weightfile = TString(""datasetcv/weights/"") + jobname + ""_"" + methodName + TString("".weights.xml"");; ; Bool_t weightfileExists = (gSystem->AccessPathName(weightfile) == kFALSE);; if (weightfileExists) {; reader->BookMVA(methodName, weightfile);; } else {; std::cout << ""Weightfile for method "" << methodName << "" not foun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVACrossValidationApplication_8C.html:2735,simpl,simple,2735,doc/master/TMVACrossValidationApplication_8C.html,https://root.cern,https://root.cern/doc/master/TMVACrossValidationApplication_8C.html,1,['simpl'],['simple']
Usability,"g& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearConvolutionWindow(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); RooNumIntConfig&convIntConfig(); const RooNumIntConfig&convIntConfig() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooNumConvolution.html:5646,clear,clearValueAndShapeDirty,5646,root/html532/RooNumConvolution.html,https://root.cern,https://root.cern/root/html532/RooNumConvolution.html,2,['clear'],['clearValueAndShapeDirty']
Usability,"g& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearConvolutionWindow(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); RooNumIntConfig&convIntConfig(); const RooNumIntConfig&convIntConfig() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNumConvolution.html:5805,clear,clearValueAndShapeDirty,5805,root/html534/RooNumConvolution.html,https://root.cern,https://root.cern/root/html534/RooNumConvolution.html,6,['clear'],['clearValueAndShapeDirty']
Usability,"g(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. stringchannel; pair<double,double>dummyForRoot; vector<TH1F*>highHistsx pb per jet bin for + variations over list of systematics; vector<TH1F*>lowHistsx pb per jet bin for - variations over list of systematics; stringname; TH1F*nominalx pb per jet bin. all histograms need index of binning to be consistent; vector<NormFactor>normFactor; stringnormName; map<std::string,std::pair<double,double> >overallSyst""acceptance""->(0.8,1.2); vector<std::string>systSourceForHist. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; EstimateSummary(). ~EstimateSummary(); {}. void Print(const char* opt = 0) const. void AddSyst(const string& sname, TH1F* low, TH1F* high). bool operator==(const RooStats::HistFactory::EstimateSummary& other) const; Comparator for two Estimate summary objects. Useful to make sure two analyses are the same. bool CompareHisto(const TH1* one, const TH1* two) const. EstimateSummary(); simple structure to hold necessary information about each channel. » Author: Kyle Cranmer, Akira Shibata » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: cranmer $ » Last generated: 2010-12-08 11:25; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__HistFactory__EstimateSummary.html:6334,simpl,simple,6334,root/html528/RooStats__HistFactory__EstimateSummary.html,https://root.cern,https://root.cern/root/html528/RooStats__HistFactory__EstimateSummary.html,1,['simpl'],['simple']
Usability,"g(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. stringchannel; pair<double,double>dummyForRoot; vector<TH1F*>highHistsx pb per jet bin for + variations over list of systematics; vector<TH1F*>lowHistsx pb per jet bin for - variations over list of systematics; stringname; TH1F*nominalx pb per jet bin. all histograms need index of binning to be consistent; vector<NormFactor>normFactor; stringnormName; map<std::string,std::pair<double,double> >overallSyst""acceptance""->(0.8,1.2); vector<std::string>systSourceForHist. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; EstimateSummary(). ~EstimateSummary(); {}. void Print(const char* opt = 0) const. void AddSyst(const string& sname, TH1F* low, TH1F* high). bool operator==(const RooStats::HistFactory::EstimateSummary& other) const; Comparator for two Estimate summary objects. Useful to make sure two analyses are the same. bool CompareHisto(const TH1* one, const TH1* two) const. EstimateSummary(); simple structure to hold necessary information about each channel. » Author: Kyle Cranmer, Akira Shibata » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: cranmer $ » Last generated: 2011-07-04 15:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__HistFactory__EstimateSummary.html:6403,simpl,simple,6403,root/html530/RooStats__HistFactory__EstimateSummary.html,https://root.cern,https://root.cern/root/html530/RooStats__HistFactory__EstimateSummary.html,1,['simpl'],['simple']
Usability,"g** subnames = 0, UInt_t options = kChildFrame, Pixel_t back = GetWhitePixel()); TGLVEntry(const TGWindow* p = 0, const TGPicture* bigpic = 0, const TGPicture* smallpic = 0, TGString* name = 0, TGString** subnames = 0, EListViewMode ViewMode = kLVDetails, UInt_t options = kChildFrame, Pixel_t back = GetWhitePixel()); virtual~TGLVEntry(); voidTObject::AbstractMethod(const char* method) const; virtual voidActivate(Bool_t a); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()SIGNAL ; virtual voidTGWindow::DestroySubwindows(); virtual voidTGWindow::DestroyWindow(); Bool_tTQObject::Disconnect(const char* signal = 0, void* receive",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGLVEntry.html:1925,Clear,Clear,1925,root/html532/TGLVEntry.html,https://root.cern,https://root.cern/root/html532/TGLVEntry.html,2,['Clear'],['Clear']
Usability,"g*>_floatParamVec; RooAbsReal*_funct; RooArgList*_initConstParamList; RooArgList*_initFloatParamList; ofstream*_logfile; double_maxFCN; int_nDim; int_numBadNLL; int_printEvalErrors; bool_verbose. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooMinimizerFcn(RooAbsReal* funct, RooMinimizer* context, bool verbose = false). virtual ~RooMinimizerFcn(). ROOT::Math::IBaseFunctionMultiDim* Clone() const. unsigned int NDim() const; { return _nDim; }. RooArgList* GetFloatParamList(); { return _floatParamList; }. RooArgList* GetConstParamList(); { return _constParamList; }. RooArgList* GetInitFloatParamList(); { return _initFloatParamList; }. RooArgList* GetInitConstParamList(); { return _initConstParamList; }. void SetEvalErrorWall(Bool_t flag); { _doEvalErrorWall = flag ; }. void SetPrintEvalErrors(Int_t numEvalErrors); { _printEvalErrors = numEvalErrors ; }. Bool_t SetLogFile(const char* inLogfile). std::ofstream* GetLogFile(); { return _logfile; }. void SetVerbose(Bool_t flag = kTRUE); { _verbose = flag ; }. Double_t& GetMaxFCN(); { return _maxFCN; }. Int_t GetNumInvalidNLL(); { return _numBadNLL; }. Bool_t Synchronize(vector<ROOT::Fit::ParameterSettings>& parameters, Bool_t optConst, Bool_t verbose). void ApplyCovarianceMatrix(TMatrixDSym& V). Int_t evalCounter() const; { return _evalCounter ; }. void zeroEvalCount(); { _evalCounter = 0 ; }. Double_t GetPdfParamVal(Int_t index). Double_t GetPdfParamErr(Int_t index). void SetPdfParamErr(Int_t index, Double_t value). void ClearPdfParamAsymErr(Int_t index). void SetPdfParamErr(Int_t index, Double_t loVal, Double_t hiVal). Bool_t SetPdfParamVal(const Int_t& index, const Double_t& value) const. double DoEval(const double* x) const. void updateFloatVec(). » Last changed: Tue Sep 8 17:03:10 2015 » Last generated: 2015-09-08 17:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooMinimizerFcn.html:3404,Clear,ClearPdfParamAsymErr,3404,root/html534/RooMinimizerFcn.html,https://root.cern,https://root.cern/root/html534/RooMinimizerFcn.html,1,['Clear'],['ClearPdfParamAsymErr']
Usability,"g, TEventList* test, TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are the two TEventLists defining events; to be used during the neural net training.; Both the TTree and the TEventLists can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, const char* weight, TTree* data, TEventList* training, TEventList* test, TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are the two TEventLists defining events; to be used during the neural net training.; Both the TTree and the TEventLists can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, TTree* data = 0, const char* training = ""Entry$%2==0"", const char* test = """", TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiLayerPerceptron.html:19947,simpl,simple,19947,root/html528/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html528/TMultiLayerPerceptron.html,10,['simpl'],['simple']
Usability,"g->SetTitle(""Simple Graph"");; 554 ; 555 g->SetPoint(0,-4,-3);; 556 g->SetPoint(1,1,1);; 557 g->SetPoint(2,2,1);; 558 g->SetPoint(3,3,4);; 559 g->SetPoint(4,5,5);; 560 ; 561 g->SetPointError(0,1.,2.);; 562 g->SetPointError(1,2,1);; 563 g->SetPointError(2,2,3);; 564 g->SetPointError(3,3,2);; 565 g->SetPointError(4,4,5);; 566 ; 567 g->GetXaxis()->SetNdivisions(520);; 568 ; 569 g->SetMarkerStyle(21);; 570 c->cd(1); gPad->SetGrid(1,1);; 571 g->Draw(""APL"");; 572 ; 573 c->cd(2); gPad->SetGrid(1,1);; 574 g->Draw(""A RX RY PL"");; 575}; 576End_Macro; 577 ; 578\anchor GrP7; 579### Graphs in logarithmic scale; 580 ; 581Like histograms, graphs can be drawn in logarithmic scale along X and Y. When; 582a pad is set to logarithmic scale with TPad::SetLogx() and/or with TPad::SetLogy(); 583the points building the graph are converted into logarithmic scale. But **only** the; 584points not the lines connecting them which stay linear. This can be clearly seen; 585on the following example:; 586 ; 587Begin_Macro(source); 588{; 589 // A graph with 3 points; 590 Double_t xmin = 750.;; 591 Double_t xmax = 1000;; 592 auto g = new TGraph(3);; 593 g->SetPoint(0,xmin,0.1);; 594 g->SetPoint(1,845,0.06504);; 595 g->SetPoint(2,xmax,0.008);; 596 ; 597 // The same graph with n points; 598 Int_t n = 10000;; 599 Double_t dx = (xmax-xmin)/n;; 600 Double_t x = xmin;; 601 auto g2 = new TGraph();; 602 for (Int_t i=0; i<n; i++) {; 603 g2->SetPoint(i, x, g->Eval(x));; 604 x = x + dx;; 605 }; 606 ; 607 auto cv = new TCanvas(""cv"",""cv"",800,600);; 608 cv->SetLogy();; 609 cv->SetGridx();; 610 cv->SetGridy();; 611 g->Draw(""AL*"");; 612 ; 613 g2->SetMarkerColor(kRed);; 614 g2->SetMarkerStyle(1);; 615 g2->Draw(""P"");; 616}; 617 ; 618End_Macro; 619 ; 620\anchor GrP8; 621#### Highlight mode for graph; 622 ; 623\since **ROOT version 6.15/01**; 624 ; 625\image html hlGraph1.gif ""Highlight mode""; 626 ; 627Highlight mode is implemented for `TGraph` (and for `TH1`) class. When; 628highlight mode is on, mouse movement over the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphPainter_8cxx_source.html:22843,clear,clearly,22843,doc/master/TGraphPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html,1,['clear'],['clearly']
Usability,"g. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; bool canBeAdded (const RooAbsArg &arg, bool silent) const override;  Determine whether it's possible to add a given RooAbsArg to the collection or not. ;  ; bool checkForDup (const RooAbsArg &arg, bool silent) const;  Check if element with var's name is already in set. ;  ;  Protected Member Functions inherited from RooAbsCollection; void clearStructureTags ();  ; void deleteList ();  Delete contents of the list. ;  ; void makeStructureTag ();  ; void makeTypedStructureTag ();  ; TNamed * structureTag ();  ; TNamed * typedStructureTag ();  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Private Member Functions; template<class Arg_t > ; void processArg (Arg_t &&arg);  ; void processArg (const char *name);  ; void processArg (const RooAbsArg &arg);  ; void processArg (const RooAbsArg *arg);  ; void processArg (const RooAbsCollection &coll);  ; void processArg (const RooArgList &list);  ; void processArg (double value);  ; void processArg (RooAbsArg *var);  ; void processArg (RooAbsCollection &&coll);  ; template<typename... Args_t> ; void processArgs (Args_t &&... args);  . Additional Inherited Members;  Public Types inherited from RooAbsCollection; using const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooArgSet.html:27370,clear,clearStructureTags,27370,doc/master/classRooArgSet.html,https://root.cern,https://root.cern/doc/master/classRooArgSet.html,1,['clear'],['clearStructureTags']
Usability,"g64_tTSelector::fStatusSelector status; TTree*fTreePointer to current Tree; TObject*fTreeElistpointer to Tree Event list; TEntryListArray*fTreeElistArray! pointer to Tree Event list array; Double_t**fVal![fSelectedRows][fDimension] Local buffer for the variables; Int_tfValSize; TTreeFormula**fVar![fDimension] Array of pointers to variables formula; Bool_t*fVarMultiple![fDimension] true if fVar[i] has a variable index; Double_t*fVmax![fDimension] Maxima of varexp columns; Double_t*fVmin![fDimension] Minima of varexp columns; Double_t*fW![fSelectedRows]Local buffer for weights; Double_tfWeightTree weight (see TTree::SetWeight); static TSelectorDraw::(anonymous)kWarn. Class Charts. Inheritance Chart:. TObject. ←; TSelector. ←; TSelectorDraw. ←. TEvePointSelector. TEveSelectorToEventList. Function documentation; TSelectorDraw(); Default selector constructor. ~TSelectorDraw(); Selector destructor. void Begin(TTree* tree); Called everytime a loop on the tree(s) starts. void ClearFormula(); Delete internal buffers. Bool_t CompileVariables(const char* varexp = """", const char* selection = """"); Compile input variables and selection expression. varexp is an expression of the general form e1:e2:e3; where e1,etc is a formula referencing a combination of the columns; Example:; varexp = x simplest case: draw a 1-Dim distribution of column named x; = sqrt(x) : draw distribution of sqrt(x); = x*y/z; = y:sqrt(x) 2-Dim dsitribution of y versus sqrt(x). selection is an expression with a combination of the columns; Example:; selection = ""x<y && sqrt(z)>3.2""; in a selection all the C++ operators are authorized. Return kFALSE if any of the variable is not compilable. Double_t* GetVal(Int_t i) const; Return the last values corresponding to the i-th component; of the formula being processed (where the component are ':' separated).; The actual number of entries is:; GetSelectedRows() % tree->GetEstimate(); Note GetSelectedRows currently returns the actual number of values plotted; and thus i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSelectorDraw.html:10194,Clear,ClearFormula,10194,root/html602/TSelectorDraw.html,https://root.cern,https://root.cern/root/html602/TSelectorDraw.html,2,['Clear'],['ClearFormula']
Usability,"g::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsSelfCachedPdf.html:3099,clear,clearEvalError,3099,root/html532/RooAbsSelfCachedPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsSelfCachedPdf.html,1,['clear'],['clearEvalError']
Usability,"g::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tRooAbsAnaConvPdf::coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*RooAbsAnaConvPdf::coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooDecay.html:2588,clear,clearEvalError,2588,root/html532/RooDecay.html,https://root.cern,https://root.cern/root/html532/RooDecay.html,2,['clear'],['clearEvalError']
Usability,"g::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*RooAbsAnaConvPdf::coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooBCPEffDecay.html:2890,clear,clearEvalError,2890,root/html532/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html532/RooBCPEffDecay.html,5,['clear'],['clearEvalError']
Usability,"g::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooBDecay.html:2788,clear,clearEvalError,2788,root/html532/RooBDecay.html,https://root.cern,https://root.cern/root/html532/RooBDecay.html,1,['clear'],['clearEvalError']
Usability,"g::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooArgusBG.html:2612,clear,clearEvalError,2612,root/html532/RooArgusBG.html,https://root.cern,https://root.cern/root/html532/RooArgusBG.html,74,['clear'],['clearEvalError']
Usability,"g::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::crea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsAnaConvPdf.html:4084,clear,clearEvalError,4084,root/html528/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsAnaConvPdf.html,2,['clear'],['clearEvalError']
Usability,"g::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCachedPdf.html:3184,clear,clearEvalError,3184,root/html528/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsCachedPdf.html,2,['clear'],['clearEvalError']
Usability,"g::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsCachedPdf.html:3184,clear,clearEvalError,3184,root/html530/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html,2,['clear'],['clearEvalError']
Usability,"g::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tRooAbsAnaConvPdf::coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*RooAbsAnaConvPdf::coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooDecay.html:2588,clear,clearEvalError,2588,root/html528/RooDecay.html,https://root.cern,https://root.cern/root/html528/RooDecay.html,2,['clear'],['clearEvalError']
Usability,"g::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*RooAbsAnaConvPdf::coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooBCPEffDecay.html:2890,clear,clearEvalError,2890,root/html528/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html528/RooBCPEffDecay.html,8,['clear'],['clearEvalError']
Usability,"g::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooBDecay.html:2788,clear,clearEvalError,2788,root/html528/RooBDecay.html,https://root.cern,https://root.cern/root/html528/RooBDecay.html,2,['clear'],['clearEvalError']
Usability,"g::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooArgusBG.html:2612,clear,clearEvalError,2612,root/html528/RooArgusBG.html,https://root.cern,https://root.cern/root/html528/RooArgusBG.html,46,['clear'],['clearEvalError']
Usability,"g::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooExtendPdf.html:3137,clear,clearEvalError,3137,root/html528/RooExtendPdf.html,https://root.cern,https://root.cern/root/html528/RooExtendPdf.html,60,['clear'],['clearEvalError']
Usability,"g; 957should be preferred for performance-critical applications.; 958 ; 959Python applications cannot easily specify template parameters or pass C++ callables to RDataFrame.; 960See [Efficient analysis in Python](#python) for possible ways to speed up hot paths in this case.; 961 ; 962Just-in-time compilation happens once, right before starting an event loop. To reduce the runtime cost of this step, make sure to book all operations *for all RDataFrame computation graphs*; 963before the first event loop is triggered: just-in-time compilation will happen once for all code required to be generated up to that point, also across different computation graphs.; 964 ; 965Also make sure not to count the just-in-time compilation time (which happens once before the event loop and does not depend on the size of the dataset) as part of the event loop runtime (which scales with the size of the dataset). RDataFrame has an experimental logging feature that simplifies measuring the time spent in just-in-time compilation and in the event loop (as well as providing some more interesting information). See [Activating RDataFrame execution logs](\ref rdf-logging).; 966 ; 967### Memory usage; 968 ; 969There are two reasons why RDataFrame may consume more memory than expected. Firstly, each result is duplicated for each worker thread, which e.g. in case of many (possibly multi-dimensional) histograms with fine binning can result in visible memory consumption during the event loop. The thread-local copies of the results are destroyed when the final result is produced. Reducing the number of threads or using coarser binning will reduce the memory usage.; 970 ; 971Secondly, just-in-time compilation of string expressions or non-templated actions (see the previous paragraph) causes Cling, ROOT's C++ interpreter, to allocate some memory for the generated code that is only released at the end of the application. This commonly results in memory usage creep in long-running applications that create ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:56069,simpl,simplifies,56069,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['simpl'],['simplifies']
Usability,"g; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; he is going to use.; For the moment it's just a call to FillBuffer() since that method; will creat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:25233,learn,learning,25233,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,2,['learn'],['learning']
Usability,"g>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Double_tbufferFraction() const; RooFFTConvPdf::BufStratbufferStrategy() const; const RooArgSet&cacheObservables() const; virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooFFTConvPdf.html:7247,clear,clearEvalError,7247,root/html532/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html532/RooFFTConvPdf.html,2,['clear'],['clearEvalError']
Usability,"g>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Double_tbufferFraction() const; RooFFTConvPdf::BufStratbufferStrategy() const; const RooArgSet&cacheObservables() const; virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooFFTConvPdf.html:7247,clear,clearEvalError,7247,root/html528/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html528/RooFFTConvPdf.html,1,['clear'],['clearEvalError']
Usability,"g>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Double_tbufferFraction() const; RooFFTConvPdf::BufStratbufferStrategy() const; const RooArgSet&cacheObservables() const; virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooFFTConvPdf.html:7247,clear,clearEvalError,7247,root/html530/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html530/RooFFTConvPdf.html,1,['clear'],['clearEvalError']
Usability,"gDbx; static Int_tTGFrame::fgDby; static const TGFont*TGProgressBar::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGGC*TGProgressBar::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGVProgressBar(const TGWindow* p = 0, UInt_t w = kProgressBarTextWidth, UInt_t h = 4, Pixel_t back = GetWhitePixel(), Pixel_t barcolor = GetDefaultSelectedBackground(), GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t options = kDoubleBorder|kSunkenFrame); cconstructor. TGVProgressBar(const TGWindow* p, TGProgressBar::EBarType type, UInt_t h); Simple constructor allow you to create either a standard progress; bar, or a more fancy progress bar (fancy means: double sized border,; white background and a bit wider to allow for text to be printed; in the bar. void DoRedraw(); Draw vertical progress bar. void SavePrimitive(ostream& out, Option_t* option = """"); Save a vertical progress bar as a C++ statement(s) on output stream out. void Percent(Bool_t ); { fPercent = on; fClient->NeedRedraw(this); }. void ShowPos(Bool_t ); { fShowPos = on; fClient->NeedRedraw(this); }. TGDimension GetDefaultSize() const; { return TGDimension(fWidth, fBarWidth); }. virtual ~TGVProgressBar(); { }. » Author: Fons Rademakers 10/10/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGProgressBar.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2010-09-23 20:08; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGVProgressBar.html:20421,progress bar,progress bar,20421,root/html528/TGVProgressBar.html,https://root.cern,https://root.cern/root/html528/TGVProgressBar.html,3,['progress bar'],['progress bar']
Usability,"gDbx; static Int_tTGFrame::fgDby; static const TGFont*TGProgressBar::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGGC*TGProgressBar::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGVProgressBar(const TGWindow* p = 0, UInt_t w = kProgressBarTextWidth, UInt_t h = 4, Pixel_t back = GetWhitePixel(), Pixel_t barcolor = GetDefaultSelectedBackground(), GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t options = kDoubleBorder|kSunkenFrame); cconstructor. TGVProgressBar(const TGWindow* p, TGProgressBar::EBarType type, UInt_t h); Simple constructor allow you to create either a standard progress; bar, or a more fancy progress bar (fancy means: double sized border,; white background and a bit wider to allow for text to be printed; in the bar. void DoRedraw(); Draw vertical progress bar. void SavePrimitive(ostream& out, Option_t* option = """"); Save a vertical progress bar as a C++ statement(s) on output stream out. void Percent(Bool_t ); { fPercent = on; fClient->NeedRedraw(this); }. void ShowPos(Bool_t ); { fShowPos = on; fClient->NeedRedraw(this); }. TGDimension GetDefaultSize() const; { return TGDimension(fWidth, fBarWidth); }. virtual ~TGVProgressBar(); { }. » Author: Fons Rademakers 10/10/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGProgressBar.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2011-07-04 15:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGVProgressBar.html:20521,progress bar,progress bar,20521,root/html530/TGVProgressBar.html,https://root.cern,https://root.cern/root/html530/TGVProgressBar.html,3,['progress bar'],['progress bar']
Usability,"gDbx; static Int_tTGFrame::fgDby; static const TGFont*TGProgressBar::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGGC*TGProgressBar::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGVProgressBar(const TGWindow* p = 0, UInt_t w = kProgressBarTextWidth, UInt_t h = 4, Pixel_t back = GetWhitePixel(), Pixel_t barcolor = GetDefaultSelectedBackground(), GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t options = kDoubleBorder|kSunkenFrame); cconstructor. TGVProgressBar(const TGWindow* p, TGProgressBar::EBarType type, UInt_t h); Simple constructor allow you to create either a standard progress; bar, or a more fancy progress bar (fancy means: double sized border,; white background and a bit wider to allow for text to be printed; in the bar. void DoRedraw(); Draw vertical progress bar. void SavePrimitive(ostream& out, Option_t* option = """"); Save a vertical progress bar as a C++ statement(s) on output stream out. void Percent(Bool_t ); { fPercent = on; fClient->NeedRedraw(this); }. void ShowPos(Bool_t ); { fShowPos = on; fClient->NeedRedraw(this); }. TGDimension GetDefaultSize() const; { return TGDimension(fWidth, fBarWidth); }. virtual ~TGVProgressBar(); { }. » Author: Fons Rademakers 10/10/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGProgressBar.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2011-11-03 20:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGVProgressBar.html:20521,progress bar,progress bar,20521,root/html532/TGVProgressBar.html,https://root.cern,https://root.cern/root/html532/TGVProgressBar.html,7,"['Simpl', 'progress bar']","['Simple', 'progress bar']"
Usability,"gDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*fgDefaultSelectedBackgroundGC; static const TGGC*fgDefaultSelectedGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGTextEntry(const TGWindow* p, TGTextBuffer* text, Int_t id = -1, GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t option = kSunkenFrame | kDoubleBorder, Pixel_t back = GetWhitePixel()); Create a text entry widget. It will adopt the TGTextBuffer object; (i.e. the text buffer will be deleted by the text entry widget). TGTextEntry(const TGWindow* parent = 0, const char* text = 0, Int_t id = -1); Simple text entry constructor. TGTextEntry(const TString& contents, const TGWindow* parent, Int_t id = -1); Simple test entry constructor. Notice TString argument comes before the; parent argument (to make this ctor different from the first one taking a; const char*). ~TGTextEntry(); Delete a text entry widget. void Init(); Do default initialization. TGDimension GetDefaultSize() const; Return the default / minimal size of the widget. void SetDefaultSize(UInt_t w, UInt_t h); Set the default / minimal size of the widget. void ReturnPressed(); This signal is emitted when the return or enter key is pressed. void ShiftTabPressed(); This signal is emitted when <SHIFT> and <TAB> keys are pressed. void TabPressed(); This signal is emitted when the <TAB> key is pressed. void TextChanged(const char* text = 0); This signal is emitted every time the text has changed. void CursorOutLeft(); This signal is emitted when cursor is going out of left side. void CursorOutRight(); T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGTextEntry.html:27544,Simpl,Simple,27544,root/html602/TGTextEntry.html,https://root.cern,https://root.cern/root/html602/TGTextEntry.html,2,['Simpl'],['Simple']
Usability,"gLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGHProgressBar(const TGWindow* p = 0, UInt_t w = 4, UInt_t h = kProgressBarTextWidth, Pixel_t back = GetWhitePixel(), Pixel_t barcolor = GetDefaultSelectedBackground(), GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t options = kDoubleBorder | kSunkenFrame); Horizontal progress bar constructor. TGHProgressBar(const TGWindow* p, TGProgressBar::EBarType type, UInt_t w); Simple constructor allow you to create either a standard progress; bar, or a more fancy progress bar (fancy means: double sized border,; white background and a bit wider to allow for text to be printed; in the bar. void ShowPosition(Bool_t set = kTRUE, Bool_t percent = kTRUE, const char* format = ""%.2f""); Show postion text, either in percent or formatted according format. void DoRedraw(); Draw horizontal progress bar. void SavePrimitive(ostream& out, Option_t* option = """"); Save a horizontal progress bar as a C++ statement(s) on output stream out. TGHProgressBar(const TGWindow* p = 0, UInt_t w = 4, UInt_t h = kProgressBarTextWidth, Pixel_t back = GetWhitePixel(), Pixel_t barcolor = GetDefaultSelectedBackground(), GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t options = kDoubleBorder | kSunkenFrame). virtual ~TGHProgressBar(); { }. TGDimension GetDefaultSize() const; { return TGDimension(fWidth, fBarWidth); }. » Author: Fons Rademakers 10/10/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-02 15:50; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGHProgressBar.html:22168,progress bar,progress bar,22168,root/html604/TGHProgressBar.html,https://root.cern,https://root.cern/root/html604/TGHProgressBar.html,4,['progress bar'],['progress bar']
Usability,"gLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGHProgressBar(const TGWindow* p = 0, UInt_t w = 4, UInt_t h = kProgressBarTextWidth, Pixel_t back = GetWhitePixel(), Pixel_t barcolor = GetDefaultSelectedBackground(), GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t options = kDoubleBorder | kSunkenFrame); Horizontal progress bar constructor. TGHProgressBar(const TGWindow* p, TGProgressBar::EBarType type, UInt_t w); Simple constructor allow you to create either a standard progress; bar, or a more fancy progress bar (fancy means: double sized border,; white background and a bit wider to allow for text to be printed; in the bar. void ShowPosition(Bool_t set = kTRUE, Bool_t percent = kTRUE, const char* format = ""%.2f""); Show postion text, either in percent or formatted according format. void DoRedraw(); Draw horizontal progress bar. void SavePrimitive(ostream& out, Option_t* option = """"); Save a horizontal progress bar as a C++ statement(s) on output stream out. TGHProgressBar(const TGWindow* p = 0, UInt_t w = 4, UInt_t h = kProgressBarTextWidth, Pixel_t back = GetWhitePixel(), Pixel_t barcolor = GetDefaultSelectedBackground(), GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t options = kDoubleBorder | kSunkenFrame). virtual ~TGHProgressBar(); { }. TGDimension GetDefaultSize() const; { return TGDimension(fWidth, fBarWidth); }. » Author: Fons Rademakers 10/10/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 14:51; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGHProgressBar.html:22168,progress bar,progress bar,22168,root/html602/TGHProgressBar.html,https://root.cern,https://root.cern/root/html602/TGHProgressBar.html,4,['progress bar'],['progress bar']
Usability,"gLearnEntriesnumber of entries used for learning mode. Class Charts. Inheritance Chart:. TObject. ←; TFileCacheRead. ←; TTreeCache. ←. TTreeCacheUnzip. Function documentation; TTreeCache(); Default Constructor. TTreeCache(TTree* tree, Int_t buffersize = 0); Constructor. ~TTreeCache(); destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subgbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); Add a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expressions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. void DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeCache.html:22668,learn,learning,22668,root/html602/TTreeCache.html,https://root.cern,https://root.cern/root/html602/TTreeCache.html,2,['learn'],['learning']
Usability,"gPad->PadtoX(gPad->AbsPixeltoX(x[i]+dpx));; 1012 if (!y.empty()) theY[i] = gPad->PadtoY(gPad->AbsPixeltoY(y[i]+dpy));; 1013 }; 1014 } else {; 1015 pxold = px;; 1016 pxold = TMath::Max(pxold, px1);; 1017 pxold = TMath::Min(pxold, px2);; 1018 pyold = py;; 1019 pyold = TMath::Max(pyold, py2);; 1020 pyold = TMath::Min(pyold, py1);; 1021 theX[ipoint] = gPad->PadtoX(gPad->AbsPixeltoX(pxold));; 1022 theY[ipoint] = gPad->PadtoY(gPad->AbsPixeltoY(pyold));; 1023 if (theGraph->InheritsFrom(""TCutG"")) {; 1024 //make sure first and last point are the same; 1025 if (ipoint == 0) {; 1026 theX[theNpoints-1] = theX[0];; 1027 theY[theNpoints-1] = theY[0];; 1028 }; 1029 if (ipoint == theNpoints-1) {; 1030 theX[0] = theX[theNpoints-1];; 1031 theY[0] = theY[theNpoints-1];; 1032 }; 1033 }; 1034 }; 1035 badcase = kFALSE;; 1036 gPad->Modified(kTRUE);; 1037 //gPad->Update();; 1038 }; 1039 break;; 1040 ; 1041 case kButton1Up:; 1042 ; 1043 if (gROOT->IsEscaped()) {; 1044 gROOT->SetEscape(kFALSE);; 1045 x.clear();; 1046 y.clear();; 1047 break;; 1048 }; 1049 ; 1050 // Compute x,y range; 1051 xmin = gPad->GetUxmin();; 1052 xmax = gPad->GetUxmax();; 1053 ymin = gPad->GetUymin();; 1054 ymax = gPad->GetUymax();; 1055 dx = xmax-xmin;; 1056 dy = ymax-ymin;; 1057 dxr = dx/(1 - gPad->GetLeftMargin() - gPad->GetRightMargin());; 1058 dyr = dy/(1 - gPad->GetBottomMargin() - gPad->GetTopMargin());; 1059 ; 1060 if (theGraph->GetHistogram()) {; 1061 // Range() could change the size of the pad pixmap and therefore should; 1062 // be called before the other paint routines; 1063 gPad->Range(xmin - dxr*gPad->GetLeftMargin(),; 1064 ymin - dyr*gPad->GetBottomMargin(),; 1065 xmax + dxr*gPad->GetRightMargin(),; 1066 ymax + dyr*gPad->GetTopMargin());; 1067 gPad->RangeAxis(xmin, ymin, xmax, ymax);; 1068 }; 1069 if (middle) {; 1070 for(i=0;i<theNpoints;i++) {; 1071 if (badcase) continue; //do not update if big zoom and points moved; 1072 if (!x.empty()) theX[i] = gPad->PadtoX(gPad->AbsPixeltoX(x[i]+dpx));; 1073 if (!y.em",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphPainter_8cxx_source.html:38508,clear,clear,38508,doc/master/TGraphPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html,1,['clear'],['clear']
Usability,"gPath;; 174 path.insert(path.end(), request.path.begin(), request.path.end());; 175 ; 176 if ((path != fLastPath) || !fLastElement) {; 177 ; 178 auto elem = GetSubElement(path);; 179 if (!elem) return false;; 180 ; 181 ResetLastRequestData(true);; 182 ; 183 fLastPath = path;; 184 fLastElement = std::move(elem);; 185 ; 186 fLastElement->cd(); // set element active; 187 } else if (request.reload) {; 188 // only reload items from element, not need to reset element itself; 189 ResetLastRequestData(false);; 190 }; 191 ; 192 // when request childs, always try to make elements; 193 if (fLastItems.empty()) {; 194 ; 195 auto iter = fLastElement->GetChildsIter();; 196 ; 197 if (!iter) return false;; 198 int id = 0;; 199 fLastAllChilds = true;; 200 ; 201 while (iter->Next() && fLastAllChilds) {; 202 fLastItems.emplace_back(iter->CreateItem());; 203 if (id++ > 10000); 204 fLastAllChilds = false;; 205 }; 206 ; 207 fLastSortedItems.clear();; 208 fLastSortMethod.clear();; 209 }; 210 ; 211 // create sorted array; 212 if ((fLastSortedItems.size() != fLastItems.size()) ||; 213 (fLastSortMethod != request.sort) ||; 214 (fLastSortReverse != request.reverse)) {; 215 fLastSortedItems.resize(fLastItems.size(), nullptr);; 216 int id = 0;; 217 if (request.sort.empty()) {; 218 // no sorting, just move all folders up; 219 for (auto &item : fLastItems); 220 if (item->IsFolder()); 221 fLastSortedItems[id++] = item.get();; 222 for (auto &item : fLastItems); 223 if (!item->IsFolder()); 224 fLastSortedItems[id++] = item.get();; 225 } else {; 226 // copy items; 227 for (auto &item : fLastItems); 228 fLastSortedItems[id++] = item.get();; 229 ; 230 if (request.sort != ""unsorted""); 231 std::sort(fLastSortedItems.begin(), fLastSortedItems.end(),; 232 [request](const Browsable::RItem *a, const Browsable::RItem *b) { return a ? a->Compare(b, request.sort) : !b; });; 233 }; 234 ; 235 if (request.reverse); 236 std::reverse(fLastSortedItems.begin(), fLastSortedItems.end());; 237 ; 238 fLastSortMethod = reque",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RBrowserData_8cxx_source.html:6576,clear,clear,6576,doc/master/RBrowserData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RBrowserData_8cxx_source.html,2,['clear'],['clear']
Usability,"gSet &numVars, const char *rangeName=nullptr) const override;  Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ;  ; TClass * IsA () const override;  ; bool isBinnedDistribution (const RooArgSet &obs) const override;  Tests if the distribution is binned. Unless overridden by derived classes, this always returns false. ;  ; const RooArgList & list () const;  ; const RooArgList & list1 () const;  ; std::list< double > * plotSamplingHint (RooAbsRealLValue &, double, double) const override;  Interface for returning an optional hint for initial sampling points when constructing a curve projected on observable obs. ;  ; void printMetaArgs (std::ostream &os) const override;  ; bool setData (RooAbsData &data, bool cloneData=true) override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void translate (RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ;  Public Member Functions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooAbsReal () override;  Destructor. ;  ; virtual double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const;  Implements the actual analytical integral(s) advertised by getAnalyticalIntegral. ;  ; TF1 * asTF (const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) const;  Return a ROOT TF1,2,3 object bound ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddition.html:2902,simpl,simple,2902,doc/master/classRooAddition.html,https://root.cern,https://root.cern/doc/master/classRooAddition.html,1,['simpl'],['simple']
Usability,"gSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearConvolutionWindow(); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); RooNumIntConfig&convIntConfig(); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNumConvPdf.html:4679,clear,clearEvalError,4679,root/html526/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html526/RooNumConvPdf.html,1,['clear'],['clearEvalError']
Usability,"gTNamed::fTitleobject title; Long64_tTBranch::fTotBytesTotal number of bytes in all leaves before compression; TTree*TBranch::fTree! Pointer to Tree header; Int_tTBranch::fWriteBasketLast basket number written; Long64_tTBranch::fZipBytesTotal number of bytes in all leaves after compression; static Int_tTBranch::fgCount! branch counter. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchRef(); Default constructor. TBranchRef(TTree* tree); Main constructor called by TTree::BranchRef. ~TBranchRef(); Typical destructor. void Clear(Option_t* option = """"); Clear entries in the TRefTable. Int_t Fill(); Fill the branch basket with the referenced objects parent numbers. void FillLeaves(TBuffer& b); This function called by TBranch::Fill overloads TBranch::FillLeaves. Bool_t Notify(); This function is called by TRefTable::Notify, itself called by; TRef::GetObject.; The function reads the branch containing the object referenced; by the TRef. void Print(Option_t* option = """") const; Print the TRefTable branch. void ReadLeavesImpl(TBuffer& b); This function called by TBranch::GetEntry overloads TBranch::ReadLeaves. void Reset(Option_t* option = """"); Existing buffers are deleted; Entries, max and min are reset; TRefTable is cleared. Int_t SetParent(const TObject* obj, Int_t branchID); -- Set the current parent branch. This function is called by TBranchElement::GetEntry(); and TBranchElement::Fill() when reading or writing; branches that may contain referenced objects. TRefTable * GetRefTable() const; {return fRefTable;}. void SetReadEntry(Long64_t entry); {fReadEntry = entry;}. » Author: Rene Brun 19/08/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TBranchRef.h 37275 2010-12-04 21:32:11Z pcanal $ » Last generated: 2010-12-04 22:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TBranchRef.html:13918,clear,cleared,13918,root/html528/TBranchRef.html,https://root.cern,https://root.cern/root/html528/TBranchRef.html,1,['clear'],['cleared']
Usability,"gWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetRange(Float_t min, Float_t max); Set min and max of progress bar. void SetPosition(Float_t pos); Set progress position between [min,max]. void Increment(Float_t inc); Increment progress position. void Reset(); Reset progress bar (i.e. set pos to 0). void SetFillType(TGProgressBar::EFillType type); Set fill type. void SetBarType(TGProgressBar::EBarType type); Set bar type. void SetBarColor(ULong_t color); Set progress bar color. void SetBarColor(const char* color = ""blue""); Set progress bar color. void Format(const char* format = ""%.2f""); Set format for displaying a value. FontStruct_t GetDefaultFontStruct(); Return default font structure in use. const TGGC & GetDefaultGC(); Return default graphics context in use. void SetForegroundColor(Pixel_t pixel); Change text color drawing. void SavePrimitive(ostream& out, Option_t* option = """"); Save progress bar parameters as a C++ statement(s) on output stream out. Bool_t fDrawBar; // if true draw only bar in DoRedraw(). virtual ~TGProgressBar(); { }. Float_t GetMin() const; { return fMin; }. Float_t GetMax() const; { return fMax; }. Float_t GetPosition() const; { return fPos; }. EFillType GetFillType() const; { return fFillType; }. EBarType GetBarType() const; { return fBarType; }. Bool_t GetShowPos() const; { return fShowPos; }. TString GetFormat() const; { return fFormat; }. const char* GetValueFormat() const; { return fFormat.Data(); }. Bool_t UsePercent() const; { return fPercent; }. Pixel_t GetBarColor() const; { return fBarColorGC.GetForeground(); }. GContext_t GetNormGC() const; { return fNormGC; }. FontStruct_t GetFontStruct() const; { return fFontStruct; }. void Percent(Bool_t on); { fPercent = on; fClient->NeedRedraw(this); }. void ShowPos(Bool_t on); { fShowPos = on; fClient->NeedRedraw(this); }. void SetMin(Float_t min); { fMin = min; }. void SetMax(Float_t max); { fMa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGProgressBar.html:19918,progress bar,progress bar,19918,root/html528/TGProgressBar.html,https://root.cern,https://root.cern/root/html528/TGProgressBar.html,6,['progress bar'],['progress bar']
Usability,"ge of (see TBuffer3D.h and TBuffer3DTypes.h). TBuffer3DSphere - solid, hollow and cut spheres*; TBuffer3DTubeSeg - angle tube segment; TBuffer3DCutTube - angle tube segment with plane cut ends. *OpenGL only supports solid spheres at present - cut/hollow ones will be; requested tessellated.; Anyone is free to add new TBuffer3D classes, but it should be clear that the; viewers require updating to be able to take advantage of them. The number of; native shapes in OpenGL will be expanded over time.; BoundingBox: You are not obliged to complete this, as any viewer; requiring one internally (OpenGL) will build one for you if you do not provide.; However; to do this the viewer will force you to provide the raw tessellation, and the; resulting box will be axis aligned with the overall scene, which is non-ideal; for rotated shapes.; As we need to support orientated (rotated) bounding boxes, TBuffer3D requires; the 6 vertices of the box. We also provide a convenience function, SetAABoundingBox(),; for simpler case of setting an axis aligned bounding box. Master/Local Reference Frames; The Core section of TBuffer3D contains two members relating to reference; frames:; fLocalFrame & fLocalMaster. fLocalFrame indicates; if any positions in the buffer (bounding box and tessellation vertexes) are; in local or master (world; frame). fLocalMaster is a standard 4x4 translation matrix (OpenGL; colum major ordering) for placing the object into the 3D master frame.; If fLocalFrame is kFALSE, fLocalMaster should contain an; identity matrix. This is set by default, and can be reset using SetLocalMasterIdentity() function.; Logical & Physical Objects; There are two cases of object addition:. Add this object as a single independent entity in the world reference; frame.; Add; a physical placement (copy) of this logical object (described in local; reference frame). The second case is very typical in geometry packages, GEANT4, where we have; very large number repeated placements of relatively fe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBuffer3D.html:4075,simpl,simpler,4075,root/html526/TBuffer3D.html,https://root.cern,https://root.cern/root/html526/TBuffer3D.html,21,['simpl'],['simpler']
Usability,"ge of the histogram is used. ; Use option ""R"" for restricting the chisquare calculation to the given range of the function Use option ""L"" for using the chisquare based on the poisson likelihood (Baker-Cousins Chisquare) Use option ""P"" for using the Pearson chisquare based on the expected bin errors ; Definition at line 2496 of file TH1.cxx. ◆ Class(). static TClass * TH1::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TH1::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TH1::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 444 of file TH1.h. ◆ ClearUnderflowAndOverflow(). void TH1::ClearUnderflowAndOverflow ; (; ). virtual . Remove all the content from the underflow and overflow bins, without changing the number of entries After calling this method, every undeflow and overflow bins will have content 0.0 The Sumw2 is also cleared, since there is no more content in the bins. ; Definition at line 2517 of file TH1.cxx. ◆ Clone(). TObject * TH1::Clone ; (; const char * ; newname = """"); const. overridevirtual . Make a complete copy of the underlying object. ; If 'newname' is set, the copy's name will be set to that name. ; Reimplemented from TObject.; Reimplemented in TH2Poly.; Definition at line 2752 of file TH1.cxx. ◆ ComputeIntegral(). Double_t TH1::ComputeIntegral ; (; Bool_t ; onlyPositive = false). virtual . Compute integral (normalized cumulative sum of bins) w/o under/overflows The result is stored in fIntegral and used by the GetRandom functions. ; This function is automatically called by GetRandom when the fIntegral array does not exist or when the number of entries in the histogram has changed since the previous call to GetRandom. The resulting integral is normalized to 1. If the routine is called with the onlyPositive flag set an error will be produced in case of negative bin content and a NaN value returned Ret",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:102039,clear,cleared,102039,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['clear'],['cleared']
Usability,"ge the size of the cache with the TTree::SetCacheSize method (by default the size is 30 Megabytes). This feature can be controlled with the environment variable ROOT_TTREECACHE_SIZE or the TTreeCache.Size option. The entry range for which the cache is active can also be set with the SetEntryRange method. Changes of behavior when using TChain and TEventList; The usage of TChain or TEventList have influence on the behaviour of the cache:. Special case of a TChain Once the training is done on the first Tree, the list of branches in the cache is kept for the following files.; Special case of a TEventlist if the Tree or TChain has a TEventlist, only the buffers referenced by the list are put in the cache. The learning phase is started or restarted when:; TTree automatically creates a cache.; TTree::SetCacheSize is called with a non-zero size and a cache did not previously exist; TTreeCache::StartLearningPhase is called.; TTreeCache::SetEntryRange is called and the learning is not yet finished and has not been set to manual and the new minimun entry is different. The learning period is stopped (and prefetching is started) when:; TTreeCache::StopLearningPhase is called.; An entry outside the 'learning' range is requested The 'learning range is from fEntryMin (default to 0) to fEntryMin + fgLearnEntries.; A 'cached' TChain switches over to a new file. Self-optimization in presence of cache misses; The TTreeCache can optimize its behavior on a cache miss. When miss optimization is enabled (see the SetOptimizeMisses method), it tracks all branches utilized after the learning phase which caused a cache miss. When one cache miss occurs, all the utilized branches are be prefetched for that event. This optimization utilizes the observation that infrequently accessed branches are often accessed together. An example scenario where such behavior is desirable, is an analysis where a set of collections are read only for a few events in which a certain condition is respected, e.g. a tri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:3961,learn,learning,3961,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,['learn'],['learning']
Usability,"ge() [2/2]. void RooCategory::addToRange ; (; const char * ; name, . RooAbsCategory::value_type ; stateIndex . ). Add the given state to the given range. ; NoteThis creates or accesses a shared map with allowed ranges. All copies of this category will share this range such that a category inside a dataset and its counterpart on the outside will both see a modification of the range. ; Definition at line 348 of file RooCategory.cxx. ◆ Class(). static TClass * RooCategory::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooCategory::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooCategory::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 141 of file RooCategory.h. ◆ clear(). void RooCategory::clear ; (; ). inline . Clear all defined category states. ; Definition at line 69 of file RooCategory.h. ◆ clearRange(). void RooCategory::clearRange ; (; const char * ; name, . bool ; silent . ). Clear the named range. ; NoteThis affects all copies of this category, because they are sharing range definitions. This ensures that categories inside a dataset and their counterparts on the outside will both see a modification of the range. ; Definition at line 321 of file RooCategory.cxx. ◆ clone(). TObject * RooCategory::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 37 of file RooCategory.h. ◆ DeclFileName(). static const char * RooCategory::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 141 of file RooCategory.h. ◆ defineType() [1/2]. bool RooCategory::defineType ; (; const std::string & ; label). Define a state with given name. ; The lowest available positive integer is assigned as index. Category state labels may not contain semicolons. ReturnsTrue in case of an error. ; Definition at line 209 of file Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCategory.html:55191,clear,clearRange,55191,doc/master/classRooCategory.html,https://root.cern,https://root.cern/doc/master/classRooCategory.html,1,['clear'],['clearRange']
Usability,"ge(Long64_t first, Long64_t last); 8833{; 8834 if (!GetTree()) {; 8835 if (LoadTree(0)<0) {; 8836 Error(""SetCacheEntryRange"",""Could not load a tree"");; 8837 return -1;; 8838 }; 8839 }; 8840 if (GetTree()) {; 8841 if (GetTree() != this) {; 8842 return GetTree()->SetCacheEntryRange(first, last);; 8843 }; 8844 } else {; 8845 Error(""SetCacheEntryRange"", ""No tree is available. Could not set cache entry range"");; 8846 return -1;; 8847 }; 8848 ; 8849 TFile *f = GetCurrentFile();; 8850 if (!f) {; 8851 Error(""SetCacheEntryRange"", ""No file is available. Could not set cache entry range"");; 8852 return -1;; 8853 }; 8854 TTreeCache *tc = GetReadCache(f,true);; 8855 if (!tc) {; 8856 Error(""SetCacheEntryRange"", ""No cache is available. Could not set entry range"");; 8857 return -1;; 8858 }; 8859 tc->SetEntryRange(first,last);; 8860 return 0;; 8861}; 8862 ; 8863////////////////////////////////////////////////////////////////////////////////; 8864/// Interface to TTreeCache to set the number of entries for the learning phase; 8865 ; 8866void TTree::SetCacheLearnEntries(Int_t n); 8867{; 8868 TTreeCache::SetLearnEntries(n);; 8869}; 8870 ; 8871////////////////////////////////////////////////////////////////////////////////; 8872/// Enable/Disable circularity for this tree.; 8873///; 8874/// if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; 8875/// per branch in memory.; 8876/// Note that when this function is called (maxEntries>0) the Tree; 8877/// must be empty or having only one basket per branch.; 8878/// if maxEntries <= 0 the tree circularity is disabled.; 8879///; 8880/// #### NOTE 1:; 8881/// Circular Trees are interesting in online real time environments; 8882/// to store the results of the last maxEntries events.; 8883/// #### NOTE 2:; 8884/// Calling SetCircular with maxEntries <= 0 is necessary before; 8885/// merging circular Trees that have been saved on files.; 8886/// #### NOTE 3:; 8887/// SetCircular with maxEntries <= 0 is automatically called; 8888",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:343901,learn,learning,343901,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['learn'],['learning']
Usability,"ge; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOMBUILDER; » TGeoVolumeEditor. class TGeoVolumeEditor: public TGeoGedFrame. TGeoVolumeEditor. Editor for geometry volumes and assemblies of volumes. Besides the volume; name and line attributes, a TGeoVolume has the following editable categories; split vertically by a shutter:; - Properties: one can edit the shape and medium components from here. It is; also possible to change the existing ones.; - Daughters: the main category allowing defining, editing, removing or; positioning daughter volumes inside the current edited volume. To add a; daughter, one needs to select first a volume and a matrix. Currently no check; is performed if the daughter volume creates an extrusion (illegal for tracking).; To remove or change the position of an existing daughter, one should simply; select the desired daughter from the combo box with the existing ones, then; simply click the appropriate button.; - Visualization: One can set the visibility of the volume and of its daughters,; set the visibility depth and the view type. Selecting ""All"" will draw the; volume and all visible daughters down to the selected level starting from the; edited volume. Selecting ""Leaves"" will draw just the deepest daughters within; the selected visibility level, without displaying the containers, while ""Only""; will just draw the edited volume.; - Division: The category becomes active only if there are no daughters of the; edited volume added by normal positioning (e.g. from <Daughters> category). The; minimum allowed starting value for the selected division axis is automatically; selected, while the dslicing step is set to 0 - meaning that only the number; of slices matter. Function Members (Methods); public:. TGeoVolumeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoVolumeEditor.html:1020,simpl,simply,1020,root/html534/TGeoVolumeEditor.html,https://root.cern,https://root.cern/root/html534/TGeoVolumeEditor.html,4,['simpl'],['simply']
Usability,"ge; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOMBUILDER; » TGeoVolumeEditor. class TGeoVolumeEditor: public TGeoGedFrame. TGeoVolumeEditor. Editor for geometry volumes and assemblies of volumes. Besides the volume; name and line attributes, a TGeoVolume has the following editable categories; split vertically by a shutter:; - Properties: one can edit the shape and medium components from here. It is; also possible to change the existing ones.; - Daughters: the main category allowing defining, editing, removing or; positioning daughter volumes inside the current edited volume. To add a; daughter, one needs to select first a volume and a matrix. Currently no check; is performed if the daughter volume creates an extrusion (illegal for tracking).; To remove or change the position of an existing daughter, one should simply; select the desired daughter from the combo box with the existing ones, then; simply click the appropriate button.; - Visualization: One can set the visibility of the volume and of its daughters,; set the visibility depth and the view type. Selecting ""All"" will draw the; volume and all visible daughters down to the selected level starting from the; edited volume. Selecting ""Leaves"" will draw just the deepest daughters within; the selected visibility level, without displaying the containers, while ""Only""; will just draw the edited volume.; - Division: The category becomes active only if there are no daughters of the; edited volume added by normal positioning (e.g. from <Daughters> category). The; minimum allowed starting value for the selected division axis is automatically; selected, while the dslicing step is set to 0 - meaning that only the number; of slices matter. Function Members (Methods); public:. virtual~TGeoVolumeEditor(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tTGe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoVolumeEditor.html:1020,simpl,simply,1020,root/html602/TGeoVolumeEditor.html,https://root.cern,https://root.cern/root/html602/TGeoVolumeEditor.html,8,['simpl'],['simply']
Usability,"genreflex Use genreflex rather than rootcint to generate the dictionary. . par Create a PAR file with the minimal set of code needed to read the content of the ROOT file. The name of the PAR file is basename(dirname), with extension '.par' enforced; the PAR file will be created at dirname(dirname). . If, in addition to one of the 3 above options, the option ""+"" is specified, the function will generate:; a script called MAKEP to build the shared lib; a dirnameLinkDef.h file; rootcint will be run to generate a dirnameProjectDict.cxx file; dirnameProjectDict.cxx will be compiled with the current options in compiledata.h; a shared lib dirname.so will be created. If the option ""++"" is specified, the generated shared lib is dynamically linked with the current executable module. If the option ""+"" and ""nocompile"" are specified, the utility files are generated as in the option ""+"" but they are not executed. Example: file.MakeProject(""demo"",""*"",""recreate++"");; creates a new directory demo unless it already exist; clear the previous directory content; generate the xxx.h files for all classes xxx found in this file and not yet known to the CINT dictionary.; creates the build script MAKEP; creates a LinkDef.h file; runs rootcint generating demoProjectDict.cxx; compiles demoProjectDict.cxx into demoProjectDict.o; generates a shared lib demo.so; dynamically links the shared lib demo.so to the executable If only the option ""+"" had been specified, one can still link the shared lib to the current executable module with: gSystem->load(""demo/demo.so"");; The following feature is not yet enabled: One can restrict the list of classes to be generated by using expressions like: classes = ""Ali*"" generate code only for classes starting with Ali; classes = ""myClass"" generate code for class MyClass only.; . Reimplemented from TFile.; Definition at line 232 of file TSQLFile.h. ◆ MakeSelectQuery(). TString TSQLFile::MakeSelectQuery ; (; TClass * ; cl). Produce SELECT statement which can be used t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:77624,clear,clear,77624,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,1,['clear'],['clear']
Usability,"genreflex Use genreflex rather than rootcint to generate the dictionary. . par Create a PAR file with the minimal set of code needed to read the content of the ROOT file. The name of the PAR file is basename(dirname), with extension '.par' enforced; the PAR file will be created at dirname(dirname). . If, in addition to one of the 3 above options, the option ""+"" is specified, the function will generate:; a script called MAKEP to build the shared lib; a dirnameLinkDef.h file; rootcint will be run to generate a dirnameProjectDict.cxx file; dirnameProjectDict.cxx will be compiled with the current options in compiledata.h; a shared lib dirname.so will be created. If the option ""++"" is specified, the generated shared lib is dynamically linked with the current executable module. If the option ""+"" and ""nocompile"" are specified, the utility files are generated as in the option ""+"" but they are not executed. Example: file.MakeProject(""demo"",""*"",""recreate++"");; creates a new directory demo unless it already exist; clear the previous directory content; generate the xxx.h files for all classes xxx found in this file and not yet known to the CINT dictionary.; creates the build script MAKEP; creates a LinkDef.h file; runs rootcint generating demoProjectDict.cxx; compiles demoProjectDict.cxx into demoProjectDict.o; generates a shared lib demo.so; dynamically links the shared lib demo.so to the executable If only the option ""+"" had been specified, one can still link the shared lib to the current executable module with: gSystem->load(""demo/demo.so"");; The following feature is not yet enabled: One can restrict the list of classes to be generated by using expressions like: classes = ""Ali*"" generate code only for classes starting with Ali; classes = ""myClass"" generate code for class MyClass only.; . Reimplemented from TFile.; Definition at line 78 of file TXMLFile.h. ◆ Map() [1/2]. void TXMLFile::Map ; (; ). inlinefinalvirtual . Reimplemented from TFile.; Definition at line 80 of file T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLFile.html:60098,clear,clear,60098,doc/master/classTXMLFile.html,https://root.cern,https://root.cern/doc/master/classTXMLFile.html,1,['clear'],['clear']
Usability,"genreflex Use genreflex rather than rootcint to generate the dictionary. . par Create a PAR file with the minimal set of code needed to read the content of the ROOT file. The name of the PAR file is basename(dirname), with extension '.par' enforced; the PAR file will be created at dirname(dirname). . If, in addition to one of the 3 above options, the option ""+"" is specified, the function will generate:; a script called MAKEP to build the shared lib; a dirnameLinkDef.h file; rootcint will be run to generate a dirnameProjectDict.cxx file; dirnameProjectDict.cxx will be compiled with the current options in compiledata.h; a shared lib dirname.so will be created. If the option ""++"" is specified, the generated shared lib is dynamically linked with the current executable module. If the option ""+"" and ""nocompile"" are specified, the utility files are generated as in the option ""+"" but they are not executed. Example: file.MakeProject(""demo"",""*"",""recreate++"");; creates a new directory demo unless it already exist; clear the previous directory content; generate the xxx.h files for all classes xxx found in this file and not yet known to the CINT dictionary.; creates the build script MAKEP; creates a LinkDef.h file; runs rootcint generating demoProjectDict.cxx; compiles demoProjectDict.cxx into demoProjectDict.o; generates a shared lib demo.so; dynamically links the shared lib demo.so to the executable If only the option ""+"" had been specified, one can still link the shared lib to the current executable module with: gSystem->load(""demo/demo.so"");; The following feature is not yet enabled: One can restrict the list of classes to be generated by using expressions like: classes = ""Ali*"" generate code only for classes starting with Ali; classes = ""myClass"" generate code for class MyClass only.; . Reimplemented in TSQLFile, and TXMLFile.; Definition at line 2726 of file TFile.cxx. ◆ MakeProjectParMake(). Int_t TFile::MakeProjectParMake ; (; const char * ; pack, . const char * ; filema",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:76979,clear,clear,76979,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['clear'],['clear']
Usability,"geometry of ALICE TPC ;  geom_atlas.CShows ATLAS geometry ;  geom_atlas_playback.CPlays back event-recording of a root session running geom_atlas.C tutorial ;  geom_cms.CShows CMS geometry ;  geom_cms_playback.CPlays back event-recording of a root session running geom_cms.C tutorial ;  geom_cms_stereo.CShows CMS geometry in stereo mode ;  geom_default.CDemonstrates usage of ""Default"" geometry alias ;  geom_lhcb.CShows LHCB geometry ;  glplot.CPreliminary demo for showing Timur's GL plots in EVE ;  glplot_geom.CDemonstrates how to combine Timur's GL plots with other scene elements ;  hierarchical_scene.C;  histobrowser.CDemonstates how to use EVE as a histogram browser ;  jetcone.CDemonstrates usage of TEveJetCone class ;  lineset.CDemonstrates usage of class TEveStraightLineSet ;  lineset.py;  MultiView.CMulti-view (3d, rphi, rhoz) service class using EVE Window Manager ;  overlay_palette.C;  pack.CDemonstrates usage of class TGPack ;  paramlist.CDemonstrates usage of simple configuration via TEveParamList class ;  pointset.CDemonstrates usage of class TEvePointSet ;  projection.CDemonstrates usage of automatic 2D projections - class TEveProjectionManager ;  projection_prescale.CDemonstrates usage pre-scaling for automatic 2D projections ;  pythia_display.CDemo showing H -> ZZ -> 4 mu generated by Pythia ;  quadset.CDemonstates usage of 2D digit class TEveQuadSet ;  selection_sigs.CTest signals from TEveSelection class ;  show_extract.CHelper script for showing of extracted / simplified geometries ;  SplitGLView.CHelper classes for the alice_esd_split.C demo ;  text.CDemonstrates usage of class TEveText - 2D & 3D text in GL ;  track.CDemonstrates usage of TEveTrackPRopagator with different magnetic field configurations ;  triangleset.CDemonstrates usage of class TEveTriangleSet ;  view3ds.CLoading and display of basic 3DS models ;  window_manager.CDemonstrates usage of EVE window-manager ;  ► eve7;  collection.CThis example display collection of ??? in web browser ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:104969,simpl,simple,104969,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['simpl'],['simple']
Usability,"ger::MakeTube() method, we would have been able to create our wire with a single line :; TGeoVolume *wire_co = gGeoManager->MakeTube(""WIRE_CO"", ptrCOPPER, 0, 0.01, 1);; gGeoManagerR__EXTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; TGeoManager::MakeTubeTGeoVolume * MakeTube(const char *name, TGeoMedium *medium, Double_t rmin, Double_t rmax, Double_t dz)Make in one step a volume pointing to a tube shape with given medium.Definition TGeoManager.cxx:3204; The same applies for all primitive shapes, for which there can be found corresponding MakeSHAPE() methods. Their usage is much more convenient unless a shape has to be shared between more volumes. Let's make now an aluminium wire having the same shape, supposing that we have created the copper wire with the line above :; TGeoVolume *wire_al = new TGeoVolume(""WIRE_AL"", wire_co->GetShape(), ptrAL);; TGeoVolume::GetShapeTGeoShape * GetShape() constDefinition TGeoVolume.h:190; Now that we have learned how to create elementary volumes, let's see how we can create a geometrical hierarchy. Positioning volumes; When creating a volume one does not specify if this will contain or not other volumes. Adding daughters to a volume implies creating those and adding them one by one to the list of daughters. Since the volume has to know the position of all its daughters, we will have to supply at the same time a geometrical transformation with respect to its local reference frame for each of them. The objects referencing a volume and a transformation are called NODES and their creation is fully handled by the modeler. They represent the link elements in the hierarchy of volumes. Nodes are unique and distinct geometrical objects ONLY from their container point of view. Since volumes can be replicated in the geometry, the same node may be found on different branches. An important observation is that volume objects are owned by the TGeoManager class. This stores a list of all volumes in the geometry, that is cleaned upon des",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVolume.html:4960,learn,learned,4960,doc/master/classTGeoVolume.html,https://root.cern,https://root.cern/doc/master/classTGeoVolume.html,1,['learn'],['learned']
Usability,"ges to bring the edited object back to its previous; state. As long as the application only uses command objects to; change the state of the edited object, it is possible to undo; a sequence of commands by traversing the command stack downwards and; calling the ""undo"" method of each command in turn. It is also; possible to redo a sequence of commands by traversing the command; stack upwards and calling the ""redo"" method of each command. Examples:. 1. Create a new command. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)""; ""SetFillColor(Color_t)"");. 1st parameter - the name of class; 2nd parameter - object; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute redo method; com->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in firs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQCommand.html:1578,undo,undo,1578,root/html528/TQCommand.html,https://root.cern,https://root.cern/root/html528/TQCommand.html,20,['undo'],['undo']
Usability,"gested work-flow, with an explanation of its motivation and details.; Some pertinent Git details; It is assumed at this point that you have a passing familiarity with CVS and/or Subversion; and that you have at least obtained a local copy (cloned) of a remote repository. Unlike CVS and SVN, every local working area is also a repository.; Unlike CVS and SVN, repositories are not sub-divisible: in the former systems, one can easily check out only a subsection of a package; with git, it's all-or-nothing.; A repository may have zero or more remote repositories to which items may be pushed (or from which they may be retrieved): Git is a truly distributed system.; Branches are easy to create, merge and destroy.; The, ""unit of change"" is a commit, labeled by its SHA1 hash. A tree's, ""state"" is a collection of commits. Merging branches multiple times is therefore trivial because it consists of comparing commit lists.; Git commit trees do not record history: they record changes. A simple change has one parent. Creating a branch creates another child of the parent commit; and a non-trivial merge joins two branches -- the resulting commit has two parents. Git (very) basics; Getting help. man git; git help <command>; man git-<command>; The git community book; Pragmatic Guide to Git; Google. Glossary. Add: put a file (or particular changes thereto) into the index ready for a commit operation. Optional for modifications to tracked files; mandatory for hitherto un-tracked files.; Alias shorthand for a git (or external) command, stored in a .gitconfig file.; Branch: a divergent change tree (eg a patch branch) which can me merged either wholesale or piecemeal with the master tree.; Commit: save the current state of the index and/or other specified files to the local repository.; Commit object: an object which contains the information about a particular revision, such as parents, committer, author, date and the tree object which corresponds to the top directory of the stored revision",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/git-tips-and-tricks.html:2975,simpl,simple,2975,d/git-tips-and-tricks.html,https://root.cern,https://root.cern/d/git-tips-and-tricks.html,1,['simpl'],['simple']
Usability,"getPlotLabel() const; Double_tRooAbsReal::getPropagatedError(const RooFitResult& fr); const Text_t*RooAbsArg::getStringAttribute(const Text_t* key) const; virtual const char*TNamed::GetTitle() const; TStringRooAbsReal::getTitle(Bool_t appendUnit = kFALSE) const; Bool_tRooAbsArg::getTransientAttribute(const Text_t* name) const; virtual UInt_tTObject::GetUniqueID() const; const Text_t*RooAbsReal::getUnit() const; Double_tRooAbsReal::getVal(const RooArgSet* set = 0) const; Double_tRooAbsReal::getVal(const RooArgSet& set) const; virtual Double_tRooAbsReal::getValV(const RooArgSet* set = 0) const; RooArgSet*RooAbsArg::getVariables(Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); voidRooAbsArg::graphVizTree(ostream& os, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_thasChanged(Bool_t clearState); Bool_tRooAbsArg::hasClients() const; virtual ULong_tTNamed::Hash() const; virtual Bool_tRooAbsArg::hasRange(const char*) const; static Bool_tRooAbsReal::hideOffset(); RooGenFunction*RooAbsReal::iGenFunction(RooRealVar& x, const RooArgSet& nset = RooArgSet()); RooMultiGenFunction*RooAbsReal::iGenFunction(const RooArgSet& observables, const RooArgSet& nset = RooArgSet()); virtual Bool_tRooAbsArg::importWorkspaceHook(RooWorkspace&); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual Bool_tRooAbsArg::inRange(const char*) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual voidRooAbsArg::ioStreamerPass2(); static voidRooAbsArg::ioStreamerPass2Finalize(); virtual TClass*IsA() const; virtual Bool_tRooAbsReal::isBinnedDistribution(const RooArgSet&) const; Bool_tRooAbsArg::isCloneOf(const RooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooChangeTracker.html:15811,clear,clearState,15811,root/html534/RooChangeTracker.html,https://root.cern,https://root.cern/root/html534/RooChangeTracker.html,6,['clear'],['clearState']
Usability,"getValV(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Double_t evaluate() const; Perform the integration and return the result. Double_t jacobianProduct() const; Return product of jacobian terms originating from analytical integration. Double_t sum() const; Perform summation of list of category dependents to be integrated. Double_t integrate() const; Perform hybrid numerical/analytical integration over all real-valued dependents. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Intercept server redirects and reconfigure internal object accordingly. const RooArgSet& parameters() const. void operModeHook(); Dummy. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Check if current value is valid. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print the state of this object to the specified output stream. void setCacheAllNumeric(Int_t ndim); Global switch to cache all integral values that integrate at least ndim dimensions numerically. Int_t getCacheAllNumeric(); Return minimum dimensions of numeric integration for which values are cached. TObject* clone(const char* newname) const; { return new RooRealIntegral(*this,newname); }. Bool_t isValid() const; { return _valid; }. const RooArgSet& numIntCatVars() const; { return _sumList ; }. const RooArgSet& numIntRealVars() const; { return _intList ; }. const RooArgSet& anaIntVars() const; { return _anaList ; }. RooArgSet intVars() const; { RooArgSet tmp(_sumList) ; tmp.add(_intList) ; tmp.add(_anaList) ; tmp.add(_facList) ; return tmp ; }. const char* intRange(); { return _rangeName ? _rangeName->Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooRealIntegral.html:38011,intuit,intuitively,38011,root/html532/RooRealIntegral.html,https://root.cern,https://root.cern/root/html532/RooRealIntegral.html,8,['intuit'],['intuitively']
Usability,"gger than 100 (TTree::kSplitCollectionOfPointers); then the collection will be written in split mode, e.g. if it contains objects of; any types deriving from TTrack this function will sort the objects; based on their type and store them in separate branches in split; mode. ==> branch->SetAddress(Void *address); In case of dynamic structures changing with each entry for example, one must; redefine the branch address before filling the branch again.; This is done via the TBranch::SetAddress member function. ==> tree->Fill(); loops on all defined branches and for each branch invokes the Fill function. See also the class TNtuple (a simple Tree with branches of floats). Adding a Branch to an Existing Tree. You may want to add a branch to an existing tree. For example,; if one variable in the tree was computed with a certain algorithm,; you may want to try another algorithm and compare the results.; One solution is to add a new branch, fill it, and save the tree.; The code below adds a simple branch to an existing tree.; Note the kOverwrite option in the Write method, it overwrites the; existing tree. If it is not specified, two copies of the tree headers; are saved. void tree3AddBranch(){; TFile f(""tree3.root"", ""update"");. Float_t new_v;; TTree *t3 = (TTree*)f->Get(""t3"");; TBranch *newBranch = t3->Branch(""new_v"", &new_v, ""new_v/F"");. //read the number of entries in the t3; Long64_t nentries = t3->GetEntries();. for (Long64_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0, 1);; newBranch->Fill();; }; // save only the new version of the tree; t3->Write("""", TObject::kOverwrite);; }; Adding a branch is often not possible because the tree is in a read-only; file and you do not have permission to save the modified tree with the; new branch. Even if you do have the permission, you risk losing the; original tree with an unsuccessful attempt to save the modification.; Since trees are usually large, adding a branch could extend it over the; 2GB limit. In this case, the attempt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTree.html:7458,simpl,simple,7458,root/html532/TTree.html,https://root.cern,https://root.cern/root/html532/TTree.html,2,['simpl'],['simple']
Usability,"gger than 100 (TTree::kSplitCollectionOfPointers); then the collection will be written in split mode. Ie. if it contains objects of; any types deriving from TTrack this function will sort the objects; basing on their type and store them in separate branches in split; mode. ==> branch->SetAddress(Void *address); In case of dynamic structures changing with each entry for example, one must; redefine the branch address before filling the branch again.; This is done via the TBranch::SetAddress member function. ==> tree->Fill(); loops on all defined branches and for each branch invokes the Fill function. See also the class TNtuple (a simple Tree with branches of floats). Adding a Branch to an Existing Tree. You may want to add a branch to an existing tree. For example,; if one variable in the tree was computed with a certain algorithm,; you may want to try another algorithm and compare the results.; One solution is to add a new branch, fill it, and save the tree.; The code below adds a simple branch to an existing tree.; Note the kOverwrite option in the Write method, it overwrites the; existing tree. If it is not specified, two copies of the tree headers; are saved. void tree3AddBranch(){; TFile f(""tree3.root"", ""update"");. Float_t new_v;; TTree *t3 = (TTree*)f->Get(""t3"");; TBranch *newBranch = t3->Branch(""new_v"", &new_v, ""new_v/F"");. //read the number of entries in the t3; Long64_t nentries = t3->GetEntries();. for (Long64_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0, 1);; newBranch->Fill();; }; // save only the new version of the tree; t3->Write("""", TObject::kOverwrite);; }; Adding a branch is often not possible because the tree is in a read-only; file and you do not have permission to save the modified tree with the; new branch. Even if you do have the permission, you risk losing the; original tree with an unsuccessful attempt to save the modification.; Since trees are usually large, adding a branch could extend it over the; 2GB limit. In this case, the attempt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:7069,simpl,simple,7069,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,2,['simpl'],['simple']
Usability,"gh); Scans the value of the user function by varying parameter number \(\mbox{par}\), leaving all other parameters fixed at the current value. If \(\mbox{par}\) is not specified, all variable parameters are scanned in sequence. The number of points \(\mbox{npoints}\) in the scan is 40 by default, and cannot exceed 100. The range of the scan is by default 2 standard deviations on each side of the current best value, but can be specified as from \(\mbox{low}\) to \(\mbox{high}\). After each scan, if a new minimum is found, the best parameter values are retained as start values for future scans or minimizations. The curve resulting from each scan can be plotted on the output terminal using MnPlot [api:plot] in order to show the approximate behaviour of the function.; 5.10.2 ScanMinimizer; Although the \(\mbox{SCAN}\) method is not intended for minimization it can be used as a minimizer in its most primitive form.; 5.11 MnSimplex and SimplexMinimizer; [api:simplex]; \(\mbox{SIMPLEX}\) is a function minimization method using the simplex method of Nelder and Mead. MnSimplex provides minimization of the function by the method of \(\mbox{SIMPLEX}\) and the functionality for parameters interaction. It also retains the result from the last minimization in case the user may want to do subsequent minimization steps with parameter interactions in between the minimization requests. The minimization is done by the SimplexMinimizer. Minimization of the function can be done by directly using the SimplexMinimizer if no parameters interaction is required. As \(\mbox{SIMPLEX}\) is a stepping method it does not produce a covariance matrix.; 5.11.1 MnSimplex(const FCNBase&, const std::vector\(<\)double\(>\)&,. const std::vector\(<\)double\(>\)&, unsigned int) ###; Constructor for the minimal required interface: \(\mbox{FCN}\) and starting values for parameters and uncertainties. Optional the strategy level in MnStrategy can be specified.; 5.11.2 MnSimplex(const FCNBase&, const MnUserParam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:49557,simpl,simplex,49557,root/htmldoc/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html,6,"['SIMPL', 'Simpl', 'simpl']","['SIMPLEX', 'SimplexMinimizer', 'simplex']"
Usability,"gh); Scans the value of the user function by varying parameter number \(\mbox{par}\), leaving all other parameters fixed at the current value. If \(\mbox{par}\) is not specified, all variable parameters are scanned in sequence. The number of points \(\mbox{npoints}\) in the scan is 40 by default, and cannot exceed 100. The range of the scan is by default 2 standard deviations on each side of the current best value, but can be specified as from \(\mbox{low}\) to \(\mbox{high}\). After each scan, if a new minimum is found, the best parameter values are retained as start values for future scans or minimizations. The curve resulting from each scan can be plotted on the output terminal using MnPlot [api:plot] in order to show the approximate behaviour of the function.; 5.10.2 ScanMinimizer; Although the \(\mbox{SCAN}\) method is not intended for minimization it can be used as a minimizer in its most primitive form.; 5.11 MnSimplex and SimplexMinimizer; [api:simplex]; \(\mbox{SIMPLEX}\) is a function minimization method using the simplex method of Nelder and Mead. MnSimplex provides minimization of the function by the method of \(\mbox{SIMPLEX}\) and the functionality for parameters interaction. It also retains the result from the last minimization in case the user may want to do subsequent minimization steps with parameter interactions in between the minimization requests. The minimization is done by the SimplexMinimizer. Minimization of the function can be done by directly using the SimplexMinimizer if no parameters interaction is required. As \(\mbox{SIMPLEX}\) is a stepping method it does not produce a covariance matrix.; 5.11.1 MnSimplex(const FCNBase&, const std::vector\(<\)double\(>\)&,; const std::vector\(<\)double\(>\)&, unsigned int); Constructor for the minimal required interface: \(\mbox{FCN}\) and starting values for parameters and uncertainties. Optional the strategy level in MnStrategy can be specified.; 5.11.2 MnSimplex(const FCNBase&, const MnUserParameter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:53562,simpl,simplex,53562,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,6,"['SIMPL', 'Simpl', 'simpl']","['SIMPLEX', 'SimplexMinimizer', 'simplex']"
Usability,"ghts () const;  ; Matrix_t & GetWeightsAt (size_t i);  ; const Matrix_t & GetWeightsAt (size_t i) const;  ; size_t GetWidth () const;  ; bool IsTraining () const;  ; void ReadMatrixXML (void *node, const char *name, Matrix_t &matrix);  ; void SetBatchSize (size_t batchSize);  Setters. ;  ; void SetDepth (size_t depth);  ; virtual void SetDropoutProbability (Scalar_t);  Set Dropout probability. ;  ; void SetHeight (size_t height);  ; void SetInputDepth (size_t inputDepth);  ; void SetInputHeight (size_t inputHeight);  ; void SetInputWidth (size_t inputWidth);  ; void SetIsTraining (bool isTraining);  ; void SetWidth (size_t width);  ; void Update (const Scalar_t learningRate);  Updates the weights and biases, given the learning rate. ;  ; void UpdateBiases (const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate);  Updates the biases, given the gradients and the learning rate. ;  ; void UpdateBiasGradients (const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate);  Updates the bias gradients, given some other weight gradients and learning rate. ;  ; void UpdateWeightGradients (const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate);  Updates the weight gradients, given some other weight gradients and learning rate. ;  ; void UpdateWeights (const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate);  Updates the weights, given the gradients and the learning rate,. ;  ; void WriteMatrixToXML (void *node, const char *name, const Matrix_t &matrix);  ; void WriteTensorToXML (void *node, const char *name, const std::vector< Matrix_t > &tensor);  helper functions for XML ;  . Static Protected Member Functions; static size_t CalculateNormDim (int axis, size_t c, size_t h, size_t w);  . Private Attributes; Tensor_t fDerivatives;  First fDerivatives of the activations of this layer. ;  ; TDescriptors * fDescriptors = nullptr;  ; Scalar_t fEpsilon;  ; Matrix_t fIVar;  ; Scalar_t fMomentum;  The weight dec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TBatchNormLayer.html:7626,learn,learningRate,7626,doc/master/classTMVA_1_1DNN_1_1TBatchNormLayer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TBatchNormLayer.html,2,['learn'],"['learning', 'learningRate']"
Usability,"ging (Bool_t on=kTRUE) override;  Switch on/off merge timer. ;  ; void StopProcess (Bool_t abort, Int_t timeout=-1) override;  Stop process after this event. ;  ; void StoreFeedback (TObject *slave, TList *out) override;  Store feedback results from the specified slave. ;  ; void StoreOutput (TList *out) override;  Store received output list. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TProofPlayer;  TProofPlayer (TProof *proof=0);  Default ctor. ;  ;  ~TProofPlayer () override;  Destructor. ;  ; void AddEventsProcessed (Long64_t ev) override;  ; void AddInput (TObject *inp) override;  Add object to input list. ;  ; void AddQueryResult (TQueryResult *q) override;  Add query result to the list, making sure that there are no duplicates. ;  ; void ClearInput () override;  Clear input list. ;  ; TDrawFeedback * CreateDrawFeedback (TProof *p) override;  Draw feedback creation proxy. ;  ; void DeleteDrawFeedback (TDrawFeedback *f) override;  Delete draw feedback object. ;  ; void FeedBackCanvas (const char *name, Bool_t create);  Create/destroy a named canvas for feedback. ;  ; Long64_t GetCacheSize () override;  Return the size in bytes of the cache. ;  ; TQueryResult * GetCurrentQuery () const override;  ; Int_t GetDrawArgs (const char *var, const char *sel, Option_t *opt, TString &selector, TString &objname) override;  Parse the arguments from var, sel and opt and fill the selector and object name accordingly. ;  ; Long64_t GetEventsProcessed () const override;  ; EExitStatus GetExitStatus () const override;  ; TList * GetInputList () const override;  ; Int_t GetLearnEntries () override;  Return the number of entries in the learning phase. ;  ; TList * GetListOfResults () const override;  ; TObject * GetOutput (const char *name) const override;  Get output object by name. ;  ; TList * GetOutputList () const override;  Get output list. ;  ; TProofProgressStatus * GetProgressStatus () const override;  ; TQ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerSuperMaster.html:4635,feedback,feedback,4635,doc/master/classTProofPlayerSuperMaster.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerSuperMaster.html,1,['feedback'],['feedback']
Usability,"given by 'enum StyleOption'. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static EvalErrorIter evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error on the given ostream. ;  ; static void setEvalErrorLoggingMode (ErrorLoggingMode m);  Set evaluation error logging mode. ;  ; static void setHideOffset (bool flag);  ;  Static Public Member Functions inherited from RooAbsArg; static void setDirtyInhibit (bool flag);  Control global dirty inhibit mode. ;  ; static void verboseDirty (bool flag);  Activate verbose messaging related to dirty flag propagation. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:49248,clear,clearing,49248,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['clear'],['clearing']
Usability,"given. For example, if the formula; TFormula old(sin(x*(x<0.5 || x>1))) one can assign a name to the formula. By default the name of the object = title = formula itself. old.SetName(""old""). then, old can be reused in a new expression. TFormula new(""x*old"") is equivalent to: TFormula new(""x*sin(x*(x<0.5 || x>1))""); Up to 4 dimensions are supported (indicated by x, y, z, t) An expression may have 0 parameters or a list of parameters indicated by the sequence [par_number]; A graph showing the logic to compile and analyze a formula is shown in TFormula::Compile and TFormula::Analyze. Once a formula has been compiled, it can be evaluated for a given set of parameters. see graph in TFormula::EvalPar.; This class is the base class for the function classes TF1,TF2 and TF3. It is also used by the ntuple selection mechanism TNtupleFormula.; In version 7 of TFormula, the usage of fOper has been changed to improve the performance of TFormula::EvalPar. Conceptually, fOper was changed from a simple array of Int_t to an array of composite values. For example a 'ylandau(5)' operation used to be encoded as 4105; it is now encoded as (klandau >> kTFOperShift) + 5 Any class inheriting from TFormula and using directly fOper (which is now a private data member), needs to be updated to take this in consideration. The member functions recommended to set and access fOper are: SetAction, GetAction, GetActionParam For more performant access to the information, see the implementation TFormula::EvalPar. CHANGING DEFAULT SETTINGS; When creating complex formula , it may be necessary to increase some default parameters. see static function TFormula::SetMaxima. WHY TFormula CANNOT ACCEPT A CLASS MEMBER FUNCTION ?; This is a frequently asked question. C++ is a strongly typed language. There is no way for TFormula (without recompiling this class) to know about all possible user defined data types. This also apply to the case of a static class function. Because TMath is a special and frequent case, T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1v5_1_1TFormula.html:2322,simpl,simple,2322,doc/master/classROOT_1_1v5_1_1TFormula.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1v5_1_1TFormula.html,1,['simpl'],['simple']
Usability,"gleKey; kOverwrite; kWriteDelete; };. protected:. TStringfFilenameEvents file name. private:. TRecorderState*fRecorderState! Current state of recorder. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRecorder(); Creates initial INACTIVE state for the recorder. TRecorder(const char* filename, Option_t* option = ""READ""); Creates a recorder with filename to replay or to record,; depending on option (NEW or RECREATE will start recording,; READ will start replaying). ~TRecorder(); Destructor. void Browse(TBrowser* ); Browse the recorder from a ROOT file. This allows to replay a; session from the browser. void Start(const char* filename, Option_t* option = ""RECREATE"", Window_t* w = 0, Int_t winCount = 0); Starts recording events. void Stop(Bool_t guiCommand = kFALSE); Stopps recording events. Bool_t Replay(const char* filename, Bool_t showMouseCursor = kTRUE, TRecorder::EReplayModes mode = kRealtime); Replays events from 'filename'. void Pause(); Pauses replaying. void Resume(); Resumes replaying. void ReplayStop(); Cancells replaying. void ListCmd(const char* filename); Prints out recorded commandline events. void ListGui(const char* filename); Prints out recorded GUI events. void ChangeState(TRecorderState* newstate, Bool_t deletePreviousState = kTRUE); Changes state from the current to the passed one (newstate); Deletes the old state if delPreviousState = KTRUE. void PrevCanvases(const char* filename, Option_t* option); Save previous canvases in a .root file. TRecorder(); Creates recorder and sets its state as INACTIVE. Bool_t Replay(const char* filename, Bool_t showMouseCursor = kTRUE, TRecorder::EReplayModes mode = kRealtime); Replays recorded events from given file. TRecorder::ERecorderState GetState() const; Gets current state of recorder. » Author: Katerina Opocenska 11/09/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TRecorder.h 35206 2010-09-08 14:01:27Z bellenot $ » La",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TRecorder.html:9078,Pause,Pause,9078,root/html532/TRecorder.html,https://root.cern,https://root.cern/root/html532/TRecorder.html,2,['Pause'],"['Pause', 'Pauses']"
Usability,"gleKey; kOverwrite; kWriteDelete; };. protected:. TStringfFilenameEvents file name. private:. TRecorderState*fRecorderState! Current state of recorder. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRecorder(); Creates initial INACTIVE state for the recorder. TRecorder(const char* filename, Option_t* option = ""READ""); Creates a recorder with filename to replay or to record,; depending on option (NEW or RECREATE will start recording,; READ will start replaying). ~TRecorder(); Destructor. void Browse(TBrowser* ); Browse the recorder from a ROOT file. This allows to replay a; session from the browser. void Start(const char* filename, Option_t* option = ""RECREATE"", Window_t* w = 0, Int_t winCount = 0); Starts recording events. void Stop(Bool_t guiCommand = kFALSE); Stopps recording events. Bool_t Replay(const char* filename, Bool_t showMouseCursor = kTRUE, TRecorder::EReplayModes mode = kRealtime); Replays events from 'filename'. void Pause(); Pauses replaying. void Resume(); Resumes replaying. void ReplayStop(); Cancells replaying. void ListCmd(const char* filename); Prints out recorded commandline events. void ListGui(const char* filename); Prints out recorded GUI events. void ChangeState(TRecorderState* newstate, Bool_t deletePreviousState = kTRUE); Changes state from the current to the passed one (newstate); Deletes the old state if delPreviousState = KTRUE. void PrevCanvases(const char* filename, Option_t* option); Save previous canvases in a .root file. TRecorder(const TRecorder& ). TRecorder & operator=(const TRecorder& ). Bool_t Replay(const char* filename, Bool_t showMouseCursor = kTRUE, TRecorder::EReplayModes mode = kRealtime); Replays recorded events from given file. TRecorder::ERecorderState GetState() const; Gets current state of recorder. » Author: Katerina Opocenska 11/09/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-05 16:41; This pag",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TRecorder.html:9107,Pause,Pause,9107,root/html534/TRecorder.html,https://root.cern,https://root.cern/root/html534/TRecorder.html,2,['Pause'],"['Pause', 'Pauses']"
Usability,"gleton editor dialog; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGedEditor* GetFrameCreator(); Returns TGedEditor that currently creates TGedFrames. void SetFrameCreator(TGedEditor* e); Set the TGedEditor that currently creates TGedFrames. TGedEditor(TCanvas* canvas = 0, UInt_t width = 175, UInt_t height = 20); Constructor of graphics editor. ~TGedEditor(); Editor destructor. void Update(TGedFrame* frame = 0); Virtual method that is called on any change in the dependent frames.; This implementation simply calls fPad Modified()/Update(). TGCompositeFrame* GetEditorTab(const char* name); Find or create tab with name. TGedTabInfo* GetEditorTabInfo(const char* name); Find or create tab with name. void CloseWindow(); Called when closed via WM close button. Calls Hide(). void ReinitWorkspace(); Clears windows in editor tab.; Unmap and withdraw currently shown frames and thus prepare for; construction of a new class layout or destruction. void SetGlobal(Bool_t global); Set editor global. void GlobalClosed(); Delete global editor if no canvas exists. void GlobalSetModel(TVirtualPad* , TObject* , Int_t ); Set canvas to global editor. void ConnectToCanvas(TCanvas* c); Connect this editor to the Selected signal of canvas 'c'. void DisconnectFromCanvas(); Disconnect this editor from the Selected signal of fCanvas. void SetCanvas(TCanvas* c); Change connection to another canvas. void SetModel(TVirtualPad* pad, TObject* obj, Int_t event); Activate object editors according to the selected object. void Show(); Show editor. void Hide(); Hide editor. The editor is put into non-active state. void RecursiveRemove(TObject* obj); Remove references to fModel in case the fModel is being deleted.; Deactivate attribute frames if they point to obj. void ActivateEditor(TClass* cl, Bool_t recurse); S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGedEditor.html:27088,Clear,Clears,27088,root/html532/TGedEditor.html,https://root.cern,https://root.cern/root/html532/TGedEditor.html,2,['Clear'],['Clears']
Usability,"gnal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); Int_tTProof::EnablePackage(const char* package, Bool_t notOnClient = kFALSE); Int_tTProof::EnablePackage(const char* package, const char* loadopts, Bool_t notOnClient = kFALSE); Int_tTProof::EnablePackage(const char* package, TList* loadopts, Bool_t notOnClient = kFALSE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; Int_tTProof::Exec(const char* cmd, Bool_t plusMaster = kFALSE); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Bool_tTProof::ExistsDataSet(const char* dataset); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTProof::Feedback(TList* objs)SIGNAL ; virtual voidTNamed::FillBuffer(char*& buffer); Long64_tTProof::Finalize(Int_t query = -1, Bool_t force = kFALSE); Long64_tTProof::Finalize(const char* queryref, Bool_t force = kFALSE); TList*TProof::FindDataSets(const char* searchString, const char* optStr = """"); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tTProof::GetBytesRead() const; Int_tTProof::GetClientProtocol() const; const char*TProof::GetConfDir() const; const char*TProof::GetConfFile() const; Float_tTProof::GetCpuTime() const; const char*TProof::GetDataPoolUrl() const; virtual TFileCollection*TProof::GetDataSet(const char* dataset, const char* optStr = """"); TMap*TProof::GetDataSetQuota(const char* optStr = """"); virtual TMap*TProof::GetDataSets(const char* uri = """", const char* optStr = """"); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static const TList*TProof::GetEnvVars();",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofCondor.html:6512,Feedback,Feedback,6512,root/html532/TProofCondor.html,https://root.cern,https://root.cern/root/html532/TProofCondor.html,2,['Feedback'],['Feedback']
Usability,gradientsBegin () { assert (m_hasGradients); return m_itGradientBegin; } ///< returns iterator to the begin of the gradients; 604 const_iterator_type gradientsBegin () const { assert (m_hasGradients); return m_itGradientBegin; } ///< returns const iterator to the begin of the gradients; 605 const_iterator_type weightsBegin () const { assert (m_hasWeights); return m_itConstWeightBegin; } ///< returns const iterator to the begin of the weights for this layer; 606 ; 607 std::shared_ptr<std::function<double(double)>> activationFunction () const { return m_activationFunction; }; 608 std::shared_ptr<std::function<double(double)>> inverseActivationFunction () const { return m_inverseActivationFunction; }; 609 ; 610 /*! \brief set the drop-out info for this layer; 611 *; 612 */; 613 template <typename Iterator>; 614 void setDropOut (Iterator itDrop) { m_itDropOut = itDrop; m_hasDropOut = true; }; 615 ; 616 /*! \brief clear the drop-out-data for this layer; 617 *; 618 *; 619 */; 620 void clearDropOut () { m_hasDropOut = false; }; 621 ; 622 bool hasDropOut () const { return m_hasDropOut; } ///< has this layer drop-out turned on?; 623 const_dropout_iterator dropOut () const { assert (m_hasDropOut); return m_itDropOut; } ///< return the begin of the drop-out information; 624 ; 625 size_t size () const { return m_size; } ///< return the size of the layer; 626 ; 627 private:; 628 ; 629 /*! \brief compute the probabilities from the node values; 630 *; 631 *; 632 */; 633 container_type computeProbabilities () const;; 634 ; 635 private:; 636 ; 637 size_t m_size; ////< layer size; 638 ; 639 const_iterator_type m_itInputBegin; ///< iterator to the first of the nodes in the input node vector; 640 const_iterator_type m_itInputEnd; ///< iterator to the end of the nodes in the input node vector; 641 ; 642 std::vector<double> m_deltas; ///< stores the deltas for the DNN training; 643 std::vector<double> m_valueGradients; ///< stores the gradients of the values (nodes); 644 std::vector<doubl,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:21205,clear,clearDropOut,21205,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,1,['clear'],['clearDropOut']
Usability,"grams; When you call the Draw method of a histogram ( TH1::Draw ) for the first time, it creates a THistPainter object and saves a pointer to painter as a data member of the histogram. The THistPainter class specializes in the drawing of histograms. It allows logarithmic axes (x, y, z) when the CONT drawing option is using. The THistPainter class is separated from the histogram so that one can have histograms without the graphics overhead, for example in a batch program. The choice to give each histogram has its own painter rather than a central singleton painter, allows two histograms to be drawn in two threads without overwriting the painter’s values. When a displayed histogram is filled again, you do not have to call the Draw method again. The image is refreshed the next time the pad is updated. A pad is updated after one of these three actions:. A carriage control on the ROOT command line; A click inside the pad; A call to TPad::Update(). By default, the TH1::Draw clears the pad before drawing the new image of the histogram. You can use the ""SAME"" option to leave the previous display intact and superimpose the new histogram. The same histogram can be drawn with different graphics options in different pads. When a displayed histogram is deleted, its image is automatically removed from the pad. To create a copy of the histogram when drawing it, you can use TH1::DrawClone(). This will clone the histogram and allow you to change and delete the original one without affecting the clone. You can use TH1::DrawNormalized() to draw a normalized copy of a histogram.; TH1 *TH1::DrawNormalized(Option_t *option,Double_t norm) const; A clone of this histogram is normalized to norm and drawn with option. A pointer to the normalized histogram is returned. The contents of the histogram copy are scaled such that the new sum of weights (excluding under and overflow) is equal to norm .; Note that the returned normalized histogram is not added to the list of histograms in the current",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:82469,clear,clears,82469,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['clear'],['clears']
Usability,"grator2D(const RooAbsFunc& function, RooIntegrator1D::SummationRule rule = RooIntegrator1D::Trapezoid, Int_t maxSteps = 0, Double_t eps = 0); RooIntegrator2D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, const RooNumIntConfig& config); RooIntegrator2D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, RooIntegrator1D::SummationRule rule = Trapezoid, Int_t maxSteps = 0, Double_t eps = 0); virtual~RooIntegrator2D(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Double_tRooAbsIntegrator::calculate(const Double_t* yvec = 0); virtual Bool_tcanIntegrate1D() const; virtual Bool_tcanIntegrate2D() const; virtual Bool_tcanIntegrateND() const; virtual Bool_tcanIntegrateOpenEnded() const; virtual Bool_tcheckLimits() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual RooAbsIntegrator*clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooIntegrator2D.html:1621,Clear,Clear,1621,root/html532/RooIntegrator2D.html,https://root.cern,https://root.cern/root/html532/RooIntegrator2D.html,2,['Clear'],['Clear']
Usability,"gregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearRange(const char* name, Bool_t silent); voidRooAbsArg::clearShapeDirty() const; voidclearTypes(); voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; Bool_tdefineType(const char* label); Bool_tdefineType(const char* label, Int_t index); virtual voidTObject::Delete(Option_t* option = """")MENU ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCategory.html:2174,clear,clearValueDirty,2174,root/html532/RooCategory.html,https://root.cern,https://root.cern/root/html532/RooCategory.html,1,['clear'],['clearValueDirty']
Usability,"gressBar::fFillType. protected . OPTION={GetMethod=""GetFillType"";SetMethod=""SetFillType"";Items=(kSolidFill=Solid"",kBlockFill=""Block"")} ; Definition at line 33 of file TGProgressBar.h. ◆ fFontStruct. FontStruct_t TGProgressBar::fFontStruct. protected . font used to draw position text ; Definition at line 41 of file TGProgressBar.h. ◆ fFormat. TString TGProgressBar::fFormat. protected . format used to show position not in percent ; Definition at line 35 of file TGProgressBar.h. ◆ fgDefaultFont. const TGFont * TGProgressBar::fgDefaultFont = nullptr. staticprotected . Definition at line 45 of file TGProgressBar.h. ◆ fgDefaultGC. TGGC * TGProgressBar::fgDefaultGC = nullptr. staticprotected . Definition at line 46 of file TGProgressBar.h. ◆ fMax. Float_t TGProgressBar::fMax. protected . logical maximum value (default 100) ; Definition at line 29 of file TGProgressBar.h. ◆ fMin. Float_t TGProgressBar::fMin. protected . logical minimum value (default 0) ; Definition at line 28 of file TGProgressBar.h. ◆ fNormGC. GContext_t TGProgressBar::fNormGC. protected . text drawing graphics context ; Definition at line 40 of file TGProgressBar.h. ◆ fPercent. Bool_t TGProgressBar::fPercent. protected . show position in percent (default true) ; Definition at line 37 of file TGProgressBar.h. ◆ fPos. Float_t TGProgressBar::fPos. protected . logical position [fMin,fMax] ; Definition at line 30 of file TGProgressBar.h. ◆ fPosPix. Int_t TGProgressBar::fPosPix. protected . position of progress bar in pixel coordinates ; Definition at line 31 of file TGProgressBar.h. ◆ fShowPos. Bool_t TGProgressBar::fShowPos. protected . show position value (default false) ; Definition at line 36 of file TGProgressBar.h. Libraries for TGProgressBar:. [legend]; The documentation for this class was generated from the following files:; gui/gui/inc/TGProgressBar.h; gui/gui/src/TGProgressBar.cxx. TGProgressBar. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:43:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGProgressBar.html:39111,progress bar,progress bar,39111,doc/master/classTGProgressBar.html,https://root.cern,https://root.cern/doc/master/classTGProgressBar.html,1,['progress bar'],['progress bar']
Usability,"ground events from the training sample. Boosting:; The idea behind adaptive boosting (AdaBoost) is, that signal events from the training sample, that end up in a background node (and vice versa) are given a larger weight than events that are in the correct leave node. This results in a re-weighed training event sample, with which then a new decision tree can be developed. The boosting can be applied several times (typically 100-500 times) and one ends up with a set of decision trees (a forest). Gradient boosting works more like a function expansion approach, where each tree corresponds to a summand. The parameters for each summand (tree) are determined by the minimization of a error function (binomial log- likelihood for classification and Huber loss for regression). A greedy algorithm is used, which means, that only one tree is modified at a time, while the other trees stay fixed. Bagging:; In this particular variant of the Boosted Decision Trees the boosting is not done on the basis of previous training results, but by a simple stochastic re-sampling of the initial training event sample. Random Trees:; Similar to the ""Random Forests"" from Leo Breiman and Adele Cutler, it uses the bagging algorithm together and bases the determination of the best node-split during the training on a random subset of variables only which is individually chosen for each split. Analysis:; Applying an individual decision tree to a test event results in a classification of the event as either signal or background. For the boosted decision tree selection, an event is successively subjected to the whole set of decision trees and depending on how often it is classified as signal, a ""likelihood"" estimator is constructed for the event being signal or background. The value of this estimator is the one which is then used to select the events from an event sample, and the cut value on this estimator defines the efficiency and purity of the selection. ; Definition at line 63 of file MethodBDT.h. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html:3150,simpl,simple,3150,doc/master/classTMVA_1_1MethodBDT.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html,1,['simpl'],['simple']
Usability,"grouping with calls to; RegularizeBins() specify a 1-dimensional group of bins; RegularizeBins2D() specify a 2-dimensional group of bins. Note, the class TUnfoldDensity provides an automatic setup of complex; regularisation schemes. For ultimate flexibility, the regularisation condition can be set on each; bin individually; -> give kRegModeNone in the constructor and use; RegularizeSize() regularize one bin; RegularizeDerivative() regularize the slope given by two bins; RegularizeCurvature() regularize the curvature given by three bins; AddRegularisationCondition(); define an arbitrary regulatisation condition. Function Members (Methods); public:. virtual~TUnfold(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDoUnfold(Double_t tau); Double_tDoUnfold(Double_t tau, const TH1* hist_y, Double_t scaleBias = 0.); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TUnfold.html:8725,Clear,Clear,8725,root/html602/TUnfold.html,https://root.cern,https://root.cern/root/html602/TUnfold.html,2,['Clear'],['Clear']
Usability,"gs and perform raytracing in the pad. ;  ; void RegisterYourself (Option_t *option="""");  Register the volume and all materials/media/matrices/shapes to the manager. ;  ; void Release ();  ; void RemoveNode (TGeoNode *node);  Remove an existing daughter. ;  ; TGeoNode * ReplaceNode (TGeoNode *nodeorig, TGeoShape *newshape=nullptr, TGeoMatrix *newpos=nullptr, TGeoMedium *newmed=nullptr);  Replace an existing daughter with a new volume having the same name but possibly a new shape, position or medium. ;  ; void ReplayCreation (const TGeoVolume *other);  Recreate the content of the other volume without pointer copying. ;  ; void ResetTransparency (Char_t transparency=-1);  ; void SaveAs (const char *filename="""", Option_t *option="""") const override;  Save geometry having this as top volume as a C++ macro. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SelectVolume (Bool_t clear=kFALSE);  Select this volume as matching an arbitrary criteria. ;  ; void SetActiveDaughters (Bool_t flag=kTRUE);  ; void SetActivity (Bool_t flag=kTRUE);  ; void SetAdded ();  ; void SetAsTopVolume ();  Set this volume as the TOP one (the whole geometry starts from here) ;  ; void SetAttVisibility (Bool_t vis);  ; void SetCurrentPoint (Double_t x, Double_t y, Double_t z);  Set the current tracking point. ;  ; void SetCylVoxels (Bool_t flag=kTRUE);  ; void SetField (TObject *field);  ; void SetFinder (TGeoPatternFinder *finder);  ; void SetFWExtension (TGeoExtension *ext);  Connect framework defined extension to the volume. ;  ; void SetInvisible ();  ; void SetLineColor (Color_t lcolor) override;  Set the line color. ;  ; void SetLineStyle (Style_t lstyle) override;  Set the line style. ;  ; void SetLineWidth (Width_t lwidth) override;  Set the line width. ;  ; virtual void SetMedium (TGeoMedium *medium);  ; void SetNodes (TObjArray *nodes);  ; void SetNtotal (Int_t ntotal);  ; void SetNumber (Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVolume.html:22110,clear,clear,22110,doc/master/classTGeoVolume.html,https://root.cern,https://root.cern/doc/master/classTGeoVolume.html,2,['clear'],['clear']
Usability,"gs and perform raytracing in the pad. ;  ; void RegisterYourself (Option_t *option="""");  Register the volume and all materials/media/matrices/shapes to the manager. ;  ; void Release ();  ; void RemoveNode (TGeoNode *node);  Remove an existing daughter. ;  ; TGeoNode * ReplaceNode (TGeoNode *nodeorig, TGeoShape *newshape=nullptr, TGeoMatrix *newpos=nullptr, TGeoMedium *newmed=nullptr);  Replace an existing daughter with a new volume having the same name but possibly a new shape, position or medium. ;  ; void ReplayCreation (const TGeoVolume *other);  Recreate the content of the other volume without pointer copying. ;  ; void ResetTransparency (Char_t transparency=-1);  ; void SaveAs (const char *filename="""", Option_t *option="""") const override;  Save geometry having this as top volume as a C++ macro. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SelectVolume (Bool_t clear=kFALSE);  Select this volume as matching an arbitrary criteria. ;  ; void SetActiveDaughters (Bool_t flag=kTRUE);  ; void SetActivity (Bool_t flag=kTRUE);  ; void SetAdded ();  ; void SetAsTopVolume ();  Set this volume as the TOP one (the whole geometry starts from here) ;  ; void SetAttVisibility (Bool_t vis);  ; void SetCurrentPoint (Double_t x, Double_t y, Double_t z);  Set the current tracking point. ;  ; void SetCylVoxels (Bool_t flag=kTRUE);  ; void SetField (TObject *field);  ; void SetFinder (TGeoPatternFinder *finder);  ; void SetFWExtension (TGeoExtension *ext);  Connect framework defined extension to the volume. ;  ; void SetInvisible ();  ; void SetNodes (TObjArray *nodes);  ; void SetNtotal (Int_t ntotal);  ; void SetNumber (Int_t number);  ; void SetOption (const char *option);  Set the current options (none implemented) ;  ; void SetOverlappingCandidate (Bool_t flag);  ; void SetReplicated ();  ; void SetShape (const TGeoShape *shape);  set the shape associated with this volume ;  ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVolumeMulti.html:18583,clear,clear,18583,doc/master/classTGeoVolumeMulti.html,https://root.cern,https://root.cern/doc/master/classTGeoVolumeMulti.html,1,['clear'],['clear']
Usability,"gs)""; TStringTCollection::fNamename of the collection; Bool_tfNewDeletekTRUE if Redo/Undo methods are new/delete; void*fObjectobject to which undo/redo actions applied; TQConnection*fRedodo/redo action; Long_t*fRedoArgsredo values; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; Int_tfState-1 undoing on, 1 redoing on, 0 nothing in progress; Int_tfStatusfStatus++ after Redo(), fStatus-- after Undo(); TStringfTitlecommand description; TQConnection*fUndoundo action; Long_t*fUndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Init(const char* cl, void* object, const char* redo, const char* undo); common protected method used in several constructors. TQCommand(const char* cl = 0, void* object = 0, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. clname - class name.; 2. obj - an object; 3. redo - method or function to do/redo operation; 4. undo - method or function to undo operation. Comments:; - if either clname or obj is NULL that means that redo/undo is function; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(""TPad"", gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case undo parameter; can be omitted. Example:; TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. obj - an object; 2. redo - method or function to do/redo operation; 3. undo - method or function to undo operation. Comments:; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(gPad, ""SetEditable(=kTRU",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQCommand.html:17929,undo,undo,17929,root/html528/TQCommand.html,https://root.cern,https://root.cern/root/html528/TQCommand.html,6,['undo'],['undo']
Usability,"gs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); Int_tTProof::EnablePackage(const char* package, Bool_t notOnClient = kFALSE, TList* workers = 0); Int_tTProof::EnablePackage(const char* package, const char* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); Int_tTProof::EnablePackage(const char* package, TList* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); virtual voidTObject::Error(const char* method, const char* msgfmt) const; Int_tTProof::Exec(const char* cmd, Bool_t plusMaster = kFALSE); Int_tTProof::Exec(const char* cmd, const char* ord, Bool_t logtomacro = kFALSE); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Bool_tExistsDataSet(const char* uri); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTProof::Feedback(TList* objs)SIGNAL ; virtual voidTNamed::FillBuffer(char*& buffer); Long64_tTProof::Finalize(Int_t query = -1, Bool_t force = kFALSE); Long64_tTProof::Finalize(const char* queryref, Bool_t force = kFALSE); TList*TProof::FindDataSets(const char* searchString, const char* optStr = """"); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tTProof::GetBytesRead() const; Int_tTProof::GetClientProtocol() const; const char*TProof::GetConfDir() const; const char*TProof::GetConfFile() const; Float_tTProof::GetCpuTime() const; const char*TProof::GetDataPoolUrl() const; virtual TFileCollection*GetDataSet(const char* uri, const char* = 0); TMap*TProof::GetDataSetQuota(const char* optStr = """"); virtual TMap*GetDataSets(const char* uri = """", const char* = 0); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TStringTProof::Getenv(const char* env, const char* ord = ""0""); static const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofLite.html:6662,Feedback,Feedback,6662,root/html534/TProofLite.html,https://root.cern,https://root.cern/root/html534/TProofLite.html,1,['Feedback'],['Feedback']
Usability,"gs. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodMLP(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption, TDirectory* theTargetDir = 0); standard constructor. MethodMLP(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = 0); constructor from a weight file. ~MethodMLP(); destructor; nothing to be done. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); MLP can handle classification with 2 classes and regression with one regression-target. void Init(); default initializations. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; TrainingMethod <string> Training method; available values are: BP Back-Propagation <default>; GA Genetic Algorithm (takes a LONG time). LearningRate <float> NN learning rate parameter; DecayRate <float> Decay rate for learning parameter; TestRate <int> Test for overtraining performed at each #th epochs. BPMode <string> Back-propagation learning mode; available values are: sequential <default>; batch. BatchSize <int> Batch size: number of events/batch, only set if in Batch Mode,; -1 for BatchSize=number_of_events. void ProcessOptions(); process user options. void InitializeLearningRates(); initialize learning rates of synapses, used only by backpropagation. Double_t CalculateEstimator(TMVA::Types::ETreeType treeType = Types::kTraining, Int_t iEpoch = -1); calculate the estimator that training is attempting to minimize. void Train(Int_t nEpochs). void BFGSMinimize(Int_t nEpochs); train network with BFGS algorithm. void SetGammaDelta(TMatrixD& Gamma, TMatrixD& Delta, vector<Double_t>& Buffer). void ComputeDEDw(). void SimulateEvent(const TMVA::Event* ev). void SteepestDir(TMatrixD& Dir). Bool_t GetHessian(TMatrixD& Hessian, TMatrixD& Gamma, TMatrixD& Delta). void SetDir(TMatrixD& Hessian, TMatrixD& Dir).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodMLP.html:22589,learn,learning,22589,root/html528/TMVA__MethodMLP.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodMLP.html,24,"['Learn', 'learn']","['LearningRate', 'learning']"
Usability,"gs; }; 87 ; 88 /**; 89 get the vector of parameter settings (non-const method); 90 */; 91 std::vector<ROOT::Fit::ParameterSettings> & ParamsSettings() { return fSettings; }; 92 ; 93 /**; 94 number of parameters settings; 95 */; 96 unsigned int NPar() const { return fSettings.size(); }; 97 ; 98 /**; 99 return a vector of stored parameter values (i.e initial fit parameters); 100 */; 101 std::vector<double> ParamsValues() const;; 102 ; 103 ; 104 /**; 105 set the parameter settings from a model function.; 106 Create always new parameter setting list from a given model function; 107 */; 108 template <class T>; 109 void CreateParamsSettings(const ROOT::Math::IParamMultiFunctionTempl<T> &func) {; 110 // initialize from model function; 111 // set the parameters values from the function; 112 unsigned int npar = func.NPar();; 113 const double *begin = func.Parameters();; 114 if (!begin) {; 115 fSettings = std::vector<ParameterSettings>(npar);; 116 return;; 117 }; 118 ; 119 fSettings.clear();; 120 fSettings.reserve(npar);; 121 const double *end = begin + npar;; 122 unsigned int i = 0;; 123 for (const double *ipar = begin; ipar != end; ++ipar) {; 124 double val = *ipar;; 125 double step = 0.3 * fabs(val); // step size is 30% of par value; 126 // double step = 2.0*fabs(val); // step size is 30% of par value; 127 if (val == 0) step = 0.3;; 128 ; 129 fSettings.push_back(ParameterSettings(func.ParameterName(i), val, step));; 130#ifdef DEBUG; 131 std::cout << ""FitConfig: add parameter "" << func.ParameterName(i) << "" val = "" << val << std::endl;; 132#endif; 133 i++;; 134 }; 135 }; 136 ; 137 /**; 138 set the parameter settings from number of parameters and a vector of values and optionally step values. If there are not existing or number of parameters does not match existing one, create a new parameter setting list.; 139 */; 140 void SetParamsSettings(unsigned int npar, const double * params, const double * vstep = nullptr);; 141 ; 142 /*; 143 Set the parameter settings from a vector ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/FitConfig_8h_source.html:3104,clear,clear,3104,doc/master/FitConfig_8h_source.html,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html,1,['clear'],['clear']
Usability,"gth()-2) = '*';; 1036 type.erase(type.length()-1);; 1037 }; 1038 prototype += type;; 1039 }; 1040 ; 1041 prototype = ""("" + prototype + "")"";; 1042 return true;; 1043 }; 1044 else {; 1045 ShowWarning(""can't convert Decl to FunctionDecl"","""");; 1046 return false;; 1047 }; 1048}; 1049 ; 1050////////////////////////////////////////////////////////////////////////////////; 1051 ; 1052void RScanner::Scan(const clang::ASTContext &C); 1053{; 1054 fSourceManager = &C.getSourceManager();; 1055 ; 1056// if (fVerboseLevel >= 3) fSelectionRules.PrintSelectionRules();; 1057 ; 1058 if (fVerboseLevel > 0 && fSelectionRules.GetHasFileNameRule()) {; 1059 std::cout<<""File name detected""<<std::endl;; 1060 }; 1061 ; 1062 if (fScanType == EScanType::kTwoPasses); 1063 TraverseDecl(C.getTranslationUnitDecl());; 1064 ; 1065 fFirstPass=false;; 1066 fselectedRecordDecls.clear();; 1067 fSelectedEnums.clear();; 1068 fSelectedTypedefs.clear();; 1069 fSelectedVariables.clear();; 1070 fSelectedFunctions.clear();; 1071 TraverseDecl(C.getTranslationUnitDecl());; 1072 ; 1073 // The RecursiveASTVisitor uses range-based for; we must not modify the AST; 1074 // during iteration / visitation. Instead, buffer the lookups that could; 1075 // potentially create new template specializations, and handle them here:; 1076 AddDelayedAnnotatedRecordDecls();; 1077}; 1078 ; 1079 ; 1080////////////////////////////////////////////////////////////////////////////////; 1081/// Set the callback to the RecordDecl and return the previous one.; 1082 ; 1083RScanner::DeclCallback RScanner::SetRecordDeclCallback(RScanner::DeclCallback callback); 1084{; 1085 DeclCallback old = fRecordDeclCallback;; 1086 fRecordDeclCallback = callback;; 1087 return old;; 1088}; IntToStrstd::string IntToStr(int num)Definition Scanner.cxx:161; APIntToLonglong APIntToLong(const llvm::APInt &num)Definition Scanner.cxx:147; gInterpcling::Interpreter * gInterp; AddSpacestd::string AddSpace(const std::string &txt)Definition Scanner.cxx:266; APIntToSizes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Scanner_8cxx_source.html:36883,clear,clear,36883,doc/master/Scanner_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Scanner_8cxx_source.html,1,['clear'],['clear']
Usability,"gth; Double_tTGeoBBox::fDZZ half-length; Double_tTGeoPcon::fDphiphi range; Bool_tTGeoPcon::fFullPhi! Full phi range flag; TStringTNamed::fNameobject identifier; Int_tfNedgesnumber of edges (at least one) ; Int_tTGeoPcon::fNznumber of z planes (at least two); Double_tTGeoBBox::fOrigin[3]box origin; Double_tTGeoPcon::fPhi1lower phi limit (converted to [0,2*pi); Double_t*TGeoPcon::fRmax[fNz] pointer to array of outer radii ; Double_t*TGeoPcon::fRmin[fNz] pointer to array of inner radii ; Double_tTGeoPcon::fS1! Sine of phi1; Double_tTGeoPcon::fS2! Sine of phi1+dphi; UInt_tTGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; Double_tTGeoPcon::fSm! Sine of (phi1+phi2)/2; vector<ThreadData_t*>fThreadData! Navigation data per thread; Int_tfThreadSize! Size for the navigation data array; TStringTNamed::fTitleobject title; Double_t*TGeoPcon::fZ[fNz] pointer to array of Z planes positions . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ClearThreadData() const. void CreateThreadData(Int_t nthreads); Create thread data for n threads max. TGeoPgon(); dummy ctor. TGeoPgon(Double_t phi, Double_t dphi, Int_t nedges, Int_t nz); Default constructor. TGeoPgon(const char* name, Double_t phi, Double_t dphi, Int_t nedges, Int_t nz); Default constructor. TGeoPgon(Double_t* params); Default constructor in GEANT3 style; param[0] = phi1; param[1] = dphi; param[2] = nedges; param[3] = nz. param[4] = z1; param[5] = Rmin1; param[6] = Rmax1. ~TGeoPgon(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box for a polygone; Check if the sections are in increasing Z order. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this shape; check total z range. Double_t DistFromInside(const Double_t* point, const Double_t* dir, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoPgon.html:15323,Clear,ClearThreadData,15323,root/html534/TGeoPgon.html,https://root.cern,https://root.cern/root/html534/TGeoPgon.html,1,['Clear'],['ClearThreadData']
Usability,"gxwork[1] = xhigh;; 1638 gywork[1] = yhigh;; 1639 ComputeLogs(2, optionZ);; 1640 if (gyworkl[0] < gPad->GetUymin()) gyworkl[0] = gPad->GetUymin();; 1641 if (gyworkl[1] < gPad->GetUymin()) continue;; 1642 if (gyworkl[1] > gPad->GetUymax()) gyworkl[1] = gPad->GetUymax();; 1643 if (gyworkl[0] > gPad->GetUymax()) continue;; 1644 ; 1645 gPad->PaintBox(gxworkl[0],gyworkl[0],gxworkl[1],gyworkl[1]);; 1646 }; 1647 } else {; 1648 for (i=1;i<=npoints;i++) {; 1649 xhigh = x[i-1];; 1650 ylow = y[i-1] - dbar;; 1651 yhigh = y[i-1] + dbar;; 1652 xlow = TMath::Max((Double_t)0, gPad->GetUxmin());; 1653 gxwork[0] = xlow;; 1654 gywork[0] = ylow;; 1655 gxwork[1] = xhigh;; 1656 gywork[1] = yhigh;; 1657 ComputeLogs(2, optionZ);; 1658 gPad->PaintBox(gxworkl[0],gyworkl[0],gxworkl[1],gyworkl[1]);; 1659 }; 1660 }; 1661 theGraph->SetFillColor(FillSave);; 1662 theGraph->TAttFill::Modify();; 1663 }; 1664 gPad->ResetBit(TGraph::kClipFrame);; 1665 ; 1666 gxwork.clear();; 1667 gywork.clear();; 1668 gxworkl.clear();; 1669 gyworkl.clear();; 1670}; 1671 ; 1672 ; 1673////////////////////////////////////////////////////////////////////////////////; 1674/// This is a service method used by `THistPainter`; 1675/// to paint 1D histograms. It is not used to paint TGraph.; 1676///; 1677/// Input parameters:; 1678///; 1679/// - npoints : Number of points in X or in Y.; 1680/// - x[npoints] or x[0] : x coordinates or (xmin,xmax).; 1681/// - y[npoints] or y[0] : y coordinates or (ymin,ymax).; 1682/// - chopt : Option.; 1683///; 1684/// The aspect of the histogram is done according to the value of the chopt.; 1685///; 1686/// | Option | Description |; 1687/// |--------|-----------------------------------------------------------------|; 1688/// |""R"" | Graph is drawn horizontally, parallel to X axis. (default is vertically, parallel to Y axis).If option R is selected the user must give 2 values for Y (y[0]=YMIN and y[1]=YMAX) or N values for X, one for each channel. Otherwise the user must give, N values for Y, one",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphPainter_8cxx_source.html:60424,clear,clear,60424,doc/master/TGraphPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html,1,['clear'],['clear']
Usability,"h as the coordinates of a point, it is most efficient to create one branch with both coordinates on it. A variable on a TBranch is called a leaf (yes - TLeaf). Another point to keep in mind when designing trees is that branches of the same TTree can be written to separate files. To add a TBranch to a TTree we call the method TTree::Branch(). Note that we DO NOT use the TBranch constructor.; The TTree::Branch method has several signatures. The branch type differs by what is stored in it. A branch can hold an entire object, a list of simple variables, contents of a folder, contents of a TList, or an array of objects. Let’s see some examples. To follow along you will need the shared library libEvent.so. First, check if it is in $ROOTSYS/test. If it is, copy it to your own area. If it is not there, you have to build it by typing make in $ROOTSYS/test.; 12.9 Adding a Branch to Hold a List of Variables; As in the very first example (cernstaff.root.root) the data we want to save is a list of simple variables, such as integers or floats. In this case, we use the following TTree::Branch signature:; tree->Branch(""Ev_Branch"",&event,; ""temp/F:ntrack/I:nseg:nvtex:flag/i"");; The first parameter is the branch name.; The second parameter is the address from which the first variable is to be read. In the code above, “event” is a structure with one float and three integers and one unsigned integer. You should not assume that the compiler aligns the elements of a structure without gaps. To avoid alignment problems, you need to use structures with same length members. If your structure does not qualify, you need to create one branch for each element of the structure.; The leaf name is NOT used to pick the variable out of the structure, but is only used as the name for the leaf. This means that the list of variables needs to be in a structure in the order described in the third parameter.; This third parameter is a string describing the leaf list. Each leaf has a name and a type separate",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:537702,simpl,simple,537702,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"h boost.python (with pyste; standalone it is a non-starter) and SWIG is that you need to run a separate tool to create and compile bindings. On top, these bindings are compiled against a specific version of Python, making for a distribution headache (just see the non-pickup of Python3 because of this problem). Compare: dictionaries are already available for all the most important classes in experiments, the EDM, because they are generated for I/O needs. They also do not depend on Python, and thus not on any specific version (only PyROOT does). Besides the obvious ease of use, there is also the benefit of lower memory footprints by not replicating structures. (For that matter, PyROOT creates bindings lazily, the others do not.); Other problems we've had, are that boost.python is very, very slow and only in ""keeping alive"" mode since 2004 or so. Pyste is based on gccxml, so no C++11 there, and has seen no major updates since 2005. SWIG is much, much better in both regards, but not up to snuff: it plain and simply can not parse our header files. The way around that, is to write .i files, but as you can imagine, that duplication is not nice for maintenance. Worse, the developers of individual packages need to do this work, and not every C++ developer has Python, let alone SWIG, experience.; Then there's PyPy. All existing binding generator tools (including PyROOT) rely on CPython internals, or at least on the Python C-API. That does not jive with PyPy as it has for example a garbage collector instead of reference counting. Through some heroics, it does expose a Python C-API, but it's slow as it interferes (blocks, really) the just-in-time compiler. Therefore, within PyPy, there are two new approaches: cffi for C and cppyy for C++. Both are part of the standard PyPy releases. There is also already a PyROOT version for the latter (see: http://root.cern.ch/drupal/content/pypyroot).; Cheers,; Wim. Submitted by Anonymous (not verified) on Thu, 07/23/2015 - 21:49 Permalink . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html:7738,simpl,simply,7738,d/blog/do-we-need-yet-another-custom-c-interpreter.html,https://root.cern,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html,1,['simpl'],['simply']
Usability,"h command. Examples:. 1. Create a new command. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)""; ""SetFillColor(Color_t)"");. 1st parameter - the name of class; 2nd parameter - object; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute redo method; com->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in first out). 6. Undo manager. TQUndoManager is recorder of undo and redo operations. This is; command history list which can be traversed backwards and upwards; performing undo and redo operations.; To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);. TQUndoManager::Add automatically invokes execution of command's; Redo method. Use TQUndoManager::Undo t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQCommand.html:2039,undo,undo,2039,root/html528/TQCommand.html,https://root.cern,https://root.cern/root/html528/TQCommand.html,28,"['Undo', 'undo']","['Undo', 'undo']"
Usability,"h input objects; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTProofPlayer::fMaxDrawQueriesMax number of Draw queries kept; TList*TProofPlayer::fOutputlist with output objects; TQueryResult*TProofPlayer::fPreviousQueryPrevious instance of TQueryResult processed; TProofProgressStatus*TProofPlayer::fProgressStatusthe progress status object;; TQueryResult*TProofPlayer::fQueryInstance of TQueryResult currently processed; TList*TProofPlayer::fQueryResultsList of TQueryResult; TStatus*TProofPlayer::fSelStatus! status of query in progress; TSelector*TProofPlayer::fSelector! the latest selector; TClass*TProofPlayer::fSelectorClass! class of the latest selector; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TTimer*TProofPlayer::fStopTimerTimer associated with a stop request; TMutex*TProofPlayer::fStopTimerMtxTo protect the stop timer; Long64_tTProofPlayer::fTotalEventsnumber of events requested; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static THashList*TProofPlayer::fgDrawInputParsList of input parameters to be kept on drawing actions. private:. TList*fFeedbackList of objects to send updates of; TSocket*fSocket. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetupFeedback(); Setup feedback. void StopFeedback(); Stop feedback. Bool_t HandleTimer(TTimer* timer); Handle timer event. void HandleGetTreeHeader(TMessage* mess); Handle tree header request. TProofPlayerSlave(TSocket* socket = 0); { }. » Author: Maarten Ballintijn 07/01/02 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id: TProofPlayer.h 36592 2010-11-11 10:43:17Z ganis $ » Last generated: 2010-12-08 16:57; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofPlayerSlave.html:15039,feedback,feedback,15039,root/html528/TProofPlayerSlave.html,https://root.cern,https://root.cern/root/html528/TProofPlayerSlave.html,2,['feedback'],['feedback']
Usability,"h input objects; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTProofPlayer::fMaxDrawQueriesMax number of Draw queries kept; TList*TProofPlayer::fOutputlist with output objects; TQueryResult*TProofPlayer::fPreviousQueryPrevious instance of TQueryResult processed; TProofProgressStatus*TProofPlayer::fProgressStatusthe progress status object;; TQueryResult*TProofPlayer::fQueryInstance of TQueryResult currently processed; TList*TProofPlayer::fQueryResultsList of TQueryResult; TStatus*TProofPlayer::fSelStatus! status of query in progress; TSelector*TProofPlayer::fSelector! the latest selector; TClass*TProofPlayer::fSelectorClass! class of the latest selector; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TTimer*TProofPlayer::fStopTimerTimer associated with a stop request; TMutex*TProofPlayer::fStopTimerMtxTo protect the stop timer; Long64_tTProofPlayer::fTotalEventsnumber of events requested; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static THashList*TProofPlayer::fgDrawInputParsList of input parameters to be kept on drawing actions. private:. TList*fFeedbackList of objects to send updates of; TSocket*fSocket. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetupFeedback(); Setup feedback. void StopFeedback(); Stop feedback. Bool_t HandleTimer(TTimer* timer); Handle timer event. void HandleGetTreeHeader(TMessage* mess); Handle tree header request. TProofPlayerSlave(TSocket* socket = 0); { }. » Author: Maarten Ballintijn 07/01/02 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id: TProofPlayer.h 39442 2011-05-27 09:13:25Z ganis $ » Last generated: 2011-07-04 15:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofPlayerSlave.html:15166,feedback,feedback,15166,root/html530/TProofPlayerSlave.html,https://root.cern,https://root.cern/root/html530/TProofPlayerSlave.html,2,['feedback'],['feedback']
Usability,"h input objects; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTProofPlayer::fMaxDrawQueriesMax number of Draw queries kept; TList*TProofPlayer::fOutputlist with output objects; TQueryResult*TProofPlayer::fPreviousQueryPrevious instance of TQueryResult processed; TProofProgressStatus*TProofPlayer::fProgressStatusthe progress status object;; TQueryResult*TProofPlayer::fQueryInstance of TQueryResult currently processed; TList*TProofPlayer::fQueryResultsList of TQueryResult; TStatus*TProofPlayer::fSelStatus! status of query in progress; TSelector*TProofPlayer::fSelector! the latest selector; TClass*TProofPlayer::fSelectorClass! class of the latest selector; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TTimer*TProofPlayer::fStopTimerTimer associated with a stop request; TMutex*TProofPlayer::fStopTimerMtxTo protect the stop timer; Long64_tTProofPlayer::fTotalEventsnumber of events requested; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static THashList*TProofPlayer::fgDrawInputParsList of input parameters to be kept on drawing actions. private:. TList*fFeedbackList of objects to send updates of; TSocket*fSocket. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetupFeedback(); Setup feedback. void StopFeedback(); Stop feedback. Bool_t HandleTimer(TTimer* timer); Handle timer event. void HandleGetTreeHeader(TMessage* mess); Handle tree header request. TProofPlayerSlave(TSocket* socket = 0); { }. » Author: Maarten Ballintijn 07/01/02 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id: TProofPlayer.h 40186 2011-07-11 12:00:50Z ganis $ » Last generated: 2011-11-03 20:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofPlayerSlave.html:15166,feedback,feedback,15166,root/html532/TProofPlayerSlave.html,https://root.cern,https://root.cern/root/html532/TProofPlayerSlave.html,4,['feedback'],['feedback']
Usability,"h mode. ; Reimplemented from RooAbsReal.; Definition at line 121 of file RooRatio.cxx. ◆ evaluate(). double RooRatio::evaluate ; (; ); const. overrideprotectedvirtual . Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ; Implements RooAbsReal.; Definition at line 114 of file RooRatio.cxx. ◆ IsA(). TClass * RooRatio::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsReal.; Definition at line 44 of file RooRatio.h. ◆ Streamer(). void RooRatio::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsReal. ◆ StreamerNVirtual(). void RooRatio::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 44 of file RooRatio.h. ◆ translate(). void RooRatio::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overrideprotectedvirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 127 of file RooRatio.cxx. Member Data Documentation. ◆ _denominator. RooRealProxy RooRatio::_denominator. protected . Definition at line 42 of file RooRatio.h. ◆ _numerator. RooRealProxy RooRatio::_numerator. protected . Definition at line 41 of file RooRatio.h. Libraries for RooRatio:. [legend]; The documentation for this class was generated from the following files:; roofit/roofitcore/inc/RooRatio.h; roofit/roofitcore/src/Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRatio.html:63534,simpl,simple,63534,doc/master/classRooRatio.html,https://root.cern,https://root.cern/doc/master/classRooRatio.html,1,['simpl'],['simple']
Usability,"h neuron calculate its delta by back propagation ; Definition at line 1328 of file MethodMLP.cxx. ◆ Class(). static TClass * TMVA::MethodMLP::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TMVA::MethodMLP::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMVA::MethodMLP::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 219 of file MethodMLP.h. ◆ ComputeDEDw(). void TMVA::MethodMLP::ComputeDEDw ; (; ). private . Definition at line 697 of file MethodMLP.cxx. ◆ ComputeEstimator(). Double_t TMVA::MethodMLP::ComputeEstimator ; (; std::vector< Double_t > & ; parameters). this function is called by GeneticANN for GA optimization ; Definition at line 1393 of file MethodMLP.cxx. ◆ DecaySynapseWeights(). void TMVA::MethodMLP::DecaySynapseWeights ; (; Bool_t ; lateEpoch). private . decay synapse weights in last 10 epochs, lower learning rate even more to find a good minimum ; Definition at line 1208 of file MethodMLP.cxx. ◆ DeclareOptions(). void TMVA::MethodMLP::DeclareOptions ; (; ). privatevirtual . define the options (their key words) that can be set in the option string ; know options:. TrainingMethod <string> Training method available values are:; BP Back-Propagation <default>; GA Genetic Algorithm (takes a LONG time). LearningRate <float> NN learning rate parameter; DecayRate <float> Decay rate for learning parameter; TestRate <int> Test for overtraining performed at each #th epochs; BPMode <string> Back-propagation learning mode available values are:; sequential <default>; batch. BatchSize <int> Batch size: number of events/batch, only set if in Batch Mode,; -1 for BatchSize=number_of_events . Reimplemented from TMVA::MethodANNBase.; Definition at line 195 of file MethodMLP.cxx. ◆ DeclFileName(). static const char * TMVA::MethodMLP::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaratio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodMLP.html:41348,learn,learning,41348,doc/master/classTMVA_1_1MethodMLP.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodMLP.html,1,['learn'],['learning']
Usability,"h object; is found return a null pointer. TObject* FindObject(const TObject* obj) const; Find object in list. If list contains object return; (same) pointer to object, otherwise return null pointer. void Clear(Option_t* o = 0); Remove all elements from collection. void Delete(Option_t* o = 0); Remove all elements in collection and delete all elements; NB: Collection does not own elements, this function should; be used judiciously by caller. TObject* find(const char* name) const; Return pointer to object with given name in collection.; If no such object is found, return null pointer. Int_t IndexOf(const TObject* arg) const; Return position of given object in list. If object; is not contained in list, return -1. Int_t IndexOf(const char* name) const; Return position of given object in list. If object; is not contained in list, return -1. void Print(const char* opt) const; Print contents of list, defers to Print() function; of contained objects. TIterator* MakeIterator(Bool_t dir = kTRUE) const; Return an iterator over this list. RooLinkedListIter iterator(Bool_t dir = kTRUE) const; Return an iterator over this list. void Sort(Bool_t ascend = kTRUE); Sort elements of this list according to their; TObject::Compare() ranking via a simple; bubble sort algorithm. void swapWithNext(RooLinkedListElem* elem); Swap given to elements in the linked list. Auxiliary function for Sort(). void Streamer(TBuffer& b); Custom streaming handling schema evolution w.r.t past implementations. Int_t getHashTableSize() const; Return size of hash table. Int_t GetSize() const; { return _size ; }. void Add(TObject* arg); { Add(arg,1) ; }. TObject* First() const. const char* GetName() const; { return _name.Data() ; }. void SetName(const char* name); { _name = name ; }. » Last changed: Sat Oct 9 06:58:32 2010 » Last generated: 2010-10-09 06:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooLinkedList.html:8806,simpl,simple,8806,root/html528/RooLinkedList.html,https://root.cern,https://root.cern/root/html528/RooLinkedList.html,1,['simpl'],['simple']
Usability,"h of; the mark is w, height is h and the type of the mark is determined by the; parameter type. void Slice(Double_t xr, Double_t yr, Double_t xs, Double_t ys, TLine* line); Calculates screen coordinates of the line given by two; nodes for contours display mode. The line is given by two points; xr, yr, xs, ys. Finally it draws the line. void CopyEnvelope(Double_t xr, Double_t xs, Double_t yr, Double_t ys); Copies envelope vector, which ensures hidden surface removal for the; contours display mode. void Paint(Option_t* option); Paints histogram according to preset parameters. ; Visualization; Goal: to present 2-dimensional spectra in suitable visual form; This package has several display mode groups and display modes, which can be; employed for the presentation of 2-dimensional histograms; Display modes groups:. kModeGroupSimple - it covers simple display modes using one; color only; kModeGroupLight - in this group the shading is carried out; according to the position of the fictive; light source; kModeGroupHeight - in this group the shading is carried out; according to the channel contents; kModeGroupLightHeight - combination of two previous shading; algorithms. One can control the weight; between both algorithms. Display modes:. kDisplayModePoints, ; kDisplayModeGrid, ; kDisplayModeContours,; kDisplayModeBars,; kDisplayModeLinesX,; kDisplayModeLinesY,; kDisplayModeBarsX,; kDisplayModeBarsY,; kDisplayModeNeedles,; kDisplayModeSurface,; kDisplayModeTriangles. one can combine the above given modes groups and display modes. The meaningful; combinations (denoted by x) are given in the next table. SimpleLightHeightLight-Height. Points XXXX; Grid XXXX; Contours X-X-; Bars X-X-; LinesX XXXX; LinesY XXXX; BarsX X-X-; BarsY X-X-; Needles X---; Surface -XXX; TrianglesXXXX. Function:; void TSpectrum2Painter::SetDisplayMode (Int_t modeGroup, Int_t displayMode). This function controls the display mode group and display mode of the; histogram drawing. To illustrate the possible ef",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrum2Painter.html:16454,simpl,simple,16454,root/html528/TSpectrum2Painter.html,https://root.cern,https://root.cern/root/html528/TSpectrum2Painter.html,10,['simpl'],['simple']
Usability,"h performance, but sometimes it gets in the way of writing simple code that manages RDF objects. Luckily, every RDF object can be converted to the generic RNode type. This tutorial shows how to take advantage of RNode to easily manipulate RDataFrames.; ; /// A generic function that takes an RDF object and applies a string filter; ROOT::RDF::RNode AddFilter(ROOT::RDF::RNode node, string_view filterStr); {; return node.Filter(filterStr);; }; ; void df025_RNode(); {; ROOT::RDataFrame df(8);; ; // Using the generic AddFilter helper function defined above: RNode in, RNode out; auto f1 = AddFilter(df, ""rdfentry_ > 0"");; auto f2 = f1.Filter([](ULong64_t e) { return e > 1; }, {""rdfentry_""});; ; // Conditionally applying a filter is simple with ROOT::RDF::RNode; bool someCondition = true;; auto maybe_filtered = ROOT::RDF::RNode(f2);; if (someCondition); maybe_filtered = maybe_filtered.Filter(""rdfentry_ > 3"");; ; // Adding new columns with Define in a loop is simple thanks to ROOT::RDF::RNode; auto with_columns = ROOT::RDF::RNode(maybe_filtered);; for (auto i = 0; i < 3; ++i); with_columns = with_columns.Define(""x"" + std::to_string(i), ""42"");; ; // RNodes can be used exactly like any other RDF object; std::cout << ""Entries passing the selection: "" << with_columns.Count().GetValue() << std::endl;; }; e#define e(i)Definition RSha256.hxx:103; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; ROOT::RDF::RInterfaceThe public interface to the RDataFrame federation of classes.Definition RInterface.hxx:113; ROOT::RDF::RInterface::FilterRInterface< RDFDetail::RFilter< F, Proxied >, DS_t > Filter(F f, const ColumnNames_t &columns={}, std::string_view name="""")Append a filter to the call graph.Definition RInterface.hxx:219; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; f1TF1 * f1Definition legend1.C:11; ROOT::RDF::RNodeRInterface<::ROOT::Detail::RDF::RNodeBase, void > RNodeDefin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df025__RNode_8C.html:1310,simpl,simple,1310,doc/master/df025__RNode_8C.html,https://root.cern,https://root.cern/doc/master/df025__RNode_8C.html,1,['simpl'],['simple']
Usability,"h reference ref. ;  ; Long64_t Finalize (Int_t query=-1, Bool_t force=kFALSE);  Finalize the qry-th query in fQueries. ;  ; TList * FindDataSets (const char *searchString, const char *optStr="""");  Find datasets, returns in a TList all found datasets. ;  ; Long64_t GetBytesRead () const;  ; Int_t GetClientProtocol () const;  ; const char * GetConfDir () const;  ; const char * GetConfFile () const;  ; Float_t GetCpuTime () const;  ; const char * GetDataPoolUrl () const;  ; virtual TFileCollection * GetDataSet (const char *dataset, const char *optStr="""");  Get a list of TFileInfo objects describing the files of the specified dataset. ;  ; TMap * GetDataSetQuota (const char *optStr="""");  returns a map of the quotas of all groups ;  ; virtual TMap * GetDataSets (const char *uri="""", const char *optStr="""");  Lists all datasets that match given uri. ;  ; TString Getenv (const char *env, const char *ord=""0"");  Get value of environment variable 'env' on node 'ord'. ;  ; TList * GetFeedbackList () const;  Return feedback list. ;  ; const char * GetGroup () const;  ; const char * GetImage () const;  ; TList * GetInputList ();  Get input list. ;  ; TMacro * GetLastLog ();  Fill a TMacro with the log lines since the last reading (fLogFileR) Return (TMacro *)0 if no line was logged. ;  ; TList * GetListOfEnabledPackages ();  Get from the master the list of names of the packages enabled. ;  ; TList * GetListOfPackages ();  Get from the master the list of names of the packages available. ;  ; virtual TList * GetListOfQueries (Option_t *opt="""");  Ask the master for the list of queries. ;  ; TList * GetListOfSlaveInfos ();  Returns list of TSlaveInfo's. In case of error return 0. ;  ; TList * GetLoadedMacros () const;  ; void GetLog (Int_t start=-1, Int_t end=-1);  Ask for remote logs in the range [start, end]. ;  ; Int_t GetLogLevel () const;  ; TMacro * GetMacroLog ();  ; TProofMgr * GetManager ();  ; const char * GetMaster () const;  ; void GetMaxQueries ();  Get max number of quer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:8714,feedback,feedback,8714,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,3,['feedback'],['feedback']
Usability,"h that a category inside a dataset and its counterpart on the outside will both see a modification of the range. ; Definition at line 372 of file RooCategory.cxx. ◆ addToRange() [2/2]. void RooCategory::addToRange ; (; const char * ; name, . RooAbsCategory::value_type ; stateIndex . ). Add the given state to the given range. ; NoteThis creates or accesses a shared map with allowed ranges. All copies of this category will share this range such that a category inside a dataset and its counterpart on the outside will both see a modification of the range. ; Definition at line 348 of file RooCategory.cxx. ◆ Class(). static TClass * RooCategory::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooCategory::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooCategory::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 141 of file RooCategory.h. ◆ clear(). void RooCategory::clear ; (; ). inline . Clear all defined category states. ; Definition at line 69 of file RooCategory.h. ◆ clearRange(). void RooCategory::clearRange ; (; const char * ; name, . bool ; silent . ). Clear the named range. ; NoteThis affects all copies of this category, because they are sharing range definitions. This ensures that categories inside a dataset and their counterparts on the outside will both see a modification of the range. ; Definition at line 321 of file RooCategory.cxx. ◆ clone(). TObject * RooCategory::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 37 of file RooCategory.h. ◆ DeclFileName(). static const char * RooCategory::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 141 of file RooCategory.h. ◆ defineType() [1/2]. bool RooCategory::defineType ; (; const std::string & ; label). Define a state with given name. ; The lo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCategory.html:55025,clear,clear,55025,doc/master/classRooCategory.html,https://root.cern,https://root.cern/doc/master/classRooCategory.html,1,['clear'],['clear']
Usability,"h the prior to obtain the posterior function ;  CMCMCIntervalPlotThis class provides simple and straightforward utilities to plot a MCMCInterval object ;  CMetropolisHastingsThis class uses the Metropolis-Hastings algorithm to construct a Markov Chain of data points using Monte Carlo ;  CMinNLLTestStatMinNLLTestStat is an implementation of the TestStatistic interface that calculates the minimum value of the negative log likelihood function and returns it as a test statistic ;  CModelConfigModelConfig is a simple class that holds configuration information specifying how a model should be used in the context of various RooStats tools ;  CNeymanConstructionNeymanConstruction is a concrete implementation of the NeymanConstruction interface that, as the name suggests, performs a NeymanConstruction ;  CNuisanceParametersSamplerHelper class for ToyMCSampler ;  CNumberCountingPdfFactory;  CNumEventsTestStatNumEventsTestStat is a simple implementation of the TestStatistic interface used for simple number counting ;  CPdfProposalPdfProposal is a concrete implementation of the ProposalFunction interface ;  CPointSetIntervalPointSetInterval is a concrete implementation of the ConfInterval interface ;  CProfileInspector;  CProfileLikelihoodCalculatorProfileLikelihoodCalculator is a concrete implementation of CombinedCalculator (the interface class for a tools which can produce both RooStats HypoTestResults and ConfIntervals) ;  CProfileLikelihoodTestStatProfileLikelihoodTestStat is an implementation of the TestStatistic interface that calculates the profile likelihood ratio at a particular parameter point given a dataset ;  CProofConfigHolds configuration options for proof and proof-lite ;  CProposalFunctionProposalFunction is an interface for all proposal functions that would be used with a Markov Chain Monte Carlo algorithm ;  CProposalHelper;  CRatioOfProfiledLikelihoodsTestStatTestStatistic that returns the ratio of profiled likelihoods ;  CSamplingDistPlotThis class provides",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:7992,simpl,simple,7992,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,2,['simpl'],['simple']
Usability,"h(TList* list, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual Int_tBranch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual Int_tBranch(TCollection* list, Int_t bufsize = 32000, Int_t splitlevel = 99, const char* name = """"); virtual TBranch*Branch(const char* name, void* address, const char* leaflist, Int_t bufsize); virtual TBranch*BranchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); virtual TBranch*TTree::BranchRef(); virtual TBranch*Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual voidTTree::Browse(TBrowser*); virtual Int_tTTree::BuildIndex(const char* majorname, const char* minorname = ""0""); TStreamerInfo*TTree::BuildStreamerInfo(TClass* cl, void* pointer = 0, Bool_t canOptimize = kTRUE); virtual TFile*TTree::ChangeFile(TFile* file); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TTree*TTree::CloneTree(Long64_t nentries = -1, Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTTree::CopyAddresses(TTree*, Bool_t undo = kFALSE); virtual Long64_tTTree::CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); virtual TTree*TTree::CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Int_tTTree::Debug() const; virtual voidTTree::Delete(Option_t* option = """")MENU ; virtual voidTTree::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTree::Draw(Option_t* opt); virtual Long64_tTTree::Draw(const char* varexp, const TCut& selection, Option_t* option = """,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreeSQL.html:2143,Clear,Clear,2143,root/html532/TTreeSQL.html,https://root.cern,https://root.cern/root/html532/TTreeSQL.html,2,['Clear'],['Clear']
Usability,"h, Pixel_t back=GetWhitePixel(), Pixel_t barcolor=GetDefaultSelectedBackground(), GContext_t norm=GetDefaultGC()(), FontStruct_t font=GetDefaultFontStruct(), UInt_t options=kDoubleBorder|kSunkenFrame);  Horizontal progress bar constructor. ;  ;  ~TGHProgressBar () override;  ; TGDimension GetDefaultSize () const override;  std::cout << fWidth << ""x"" << fHeight << std::endl; ;  ; TClass * IsA () const override;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a horizontal progress bar as a C++ statement(s) on output stream out. ;  ; void ShowPosition (Bool_t set=kTRUE, Bool_t percent=kTRUE, const char *format=""%.2f"");  Show postion text, either in percent or formatted according format. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGProgressBar;  TGProgressBar (const TGWindow *p, UInt_t w, UInt_t h, Pixel_t back=GetWhitePixel(), Pixel_t barcolor=GetDefaultSelectedBackground(), GContext_t norm=GetDefaultGC()(), FontStruct_t font=GetDefaultFontStruct(), UInt_t options=kDoubleBorder|kSunkenFrame);  Create progress bar. ;  ;  ~TGProgressBar () override;  ; virtual void Format (const char *format=""%.2f"");  Set format for displaying a value. ;  ; Pixel_t GetBarColor () const;  ; EBarType GetBarType () const;  ; EFillType GetFillType () const;  ; FontStruct_t GetFontStruct () const;  ; TString GetFormat () const;  ; Float_t GetMax () const;  ; Float_t GetMin () const;  ; GContext_t GetNormGC () const;  ; Float_t GetPosition () const;  ; Bool_t GetShowPos () const;  ; const char * GetValueFormat () const;  ; void Increment (Float_t inc);  Increment progress position. ;  ; TClass * IsA () const override;  ; virtual void Percent (Bool_t on);  ; virtual void Reset ();  Reset progress bar (i.e. set pos to 0). ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save progress bar parameters",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGHProgressBar.html:1916,progress bar,progress bar,1916,doc/master/classTGHProgressBar.html,https://root.cern,https://root.cern/doc/master/classTGHProgressBar.html,1,['progress bar'],['progress bar']
Usability,"h. ◆ stringAttributes(). const std::map< std::string, std::string > & RooAbsArg::stringAttributes ; (; ); const. inline . Definition at line 321 of file RooAbsArg.h. ◆ substituteServer(). void RooAbsArg::substituteServer ; (; RooAbsArg * ; oldServer, . RooAbsArg * ; newServer . ). private . Set by the RooFitDriver for this arg to retrieve its result in the run context. ; Private helper function for RooAbsArg::redirectServers().; *‍/ ; Definition at line 1116 of file RooAbsArg.cxx. ◆ syncCache(). virtual void RooAbsArg::syncCache ; (; const RooArgSet * ; nset = nullptr). protectedpure virtual . Implemented in RooStringVar, RooAbsCategory, RooAbsReal, and RooErrorVar. ◆ transientAttributes(). const std::set< std::string > & RooAbsArg::transientAttributes ; (; ); const. inline . Definition at line 329 of file RooAbsArg.h. ◆ translate(). void RooAbsArg::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. virtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented in RooStats::HistFactory::FlexibleInterpVar, ParamHistFunc, PiecewiseInterpolation, RooBernstein, RooBifurGauss, RooCBShape, RooChebychev, RooExponential, RooGamma, RooGaussian, RooLandau, RooLognormal, RooParamHistFunc, RooPoisson, RooPolynomial, RooUniform, RooAddition, RooAddPdf, RooConstraintSum, RooConstVar, RooEfficiency, RooEffProd, RooExtendPdf, RooFormulaVar, RooGenericPdf, RooHistFunc, RooHistPdf, RooPolyVar, RooProduct, RooRatio, RooRealIntegral, RooR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:102126,simpl,simple,102126,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['simpl'],['simple']
Usability,"h.cxx;  markerStyle.cxx;  pad.cxx;  perf.cxx;  perfcomp.cxx;  simple.cxx;  text.cxx;  ► vecops;  vo001_AdoptOrOwnMemory.C In this tutorial we learn how the RVec class can be used to adopt existing memory or allocate some ;  vo001_AdoptOrOwnMemory.py In this tutorial we learn how the RVec class can be used to adopt existing memory or allocate some ;  vo002_VectorCalculations.C In this tutorial we learn how the RVec class can be used to express easily mathematical operations involving arrays and scalars ;  vo003_LogicalOperations.C In this tutorial we learn how the RVec class can be used to express logical operations ;  vo004_SortAndSelect.C In this tutorial we learn how elements of an RVec can be easily sorted and selected ;  vo004_SortAndSelect.py In this tutorial we learn how elements of an RVec can be easily sorted and selected ;  vo005_Combinations.C In this tutorial we learn how combinations of RVecs can be build ;  vo005_Combinations.py In this tutorial we learn how combinations of RVecs can be build ;  vo006_IndexManipulation.C In this tutorial we demonstrate RVec helpers for index manipulation ;  ► xml;  DOMParsePerson.C ROOT implementation of a XML DOM Parser ;  DOMRecursive.C ROOT implementation of a XML DOM Parser ;  SAXHandler.C ROOT implementation of a simple SAX Handler ;  xmlmodifyfile.C Example to read, modify and store xml file, using TXMLEngine class The input file, produced by xmlnewfile.C macro is used If you need full xml syntax support, use TXMLParser instead ;  xmlnewfile.C Example to create a new xml file with the TXMLEngine class ;  xmlreadfile.C Example to read and parse any xml file, supported by TXMLEngine class The input file, produced by xmlnewfile.C macro is used If you need full xml syntax support, use TXMLParser instead ;  benchmarks.CThis macro run several tests and produces an benchmark report ;  demos.CThis macro shows a control bar to run some of the ROOT tutorials ;  demoshelp.CThis macro shows help on running the Demos ;  geant3t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:172919,learn,learn,172919,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['learn'],['learn']
Usability,"h1*-*-; *-* =============================. this = this*h1. void Multiply(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """"); -*-*-*Replace contents of this profile by multiplication of h1 by h2; *-* ================================================================. this = (c1*h1)*(c2*h2). TH1D * ProjectionX(const char* name = ""_px"", Option_t* option = ""e"") const; Project this profile into a 1-D histogram along X*-*-; *-* =================================================. The projection is always of the type TH1D. if option ""E"" is specified the errors of the projected histogram are computed and set; to be equal to the errors of the profile.; Option ""E"" is defined as the default one in the header file.; if option """" is specified the histogram errors are simply the sqrt of its content; if option ""B"" is specified, the content of bin of the returned histogram; will be equal to the GetBinEntries(bin) of the profile,; otherwise (default) it will be equal to GetBinContent(bin); if option ""C=E"" the bin contents of the projection are set to the; bin errors of the profile; if option ""W"" is specified the bin content of the projected histogram is set to the; product of the bin content of the profile and the entries.; With this option the returned histogram will be equivalent to the one obtained by; filling directly a TH1D using the 2-nd value as a weight.; This makes sense only for profile filled with weights =1. If not, the error of the; projected histogram obtained with this option will not be correct. void PutStats(Double_t* stats); Replace current statistics with the values in array stats. TH1 * Rebin(Int_t ngroup = 2, const char* newname = """", const Double_t* xbins = 0); Rebin this profile grouping ngroup bins together*-*-*-*-; *-* ================================================; -case 1 xbins=0; if newname is not blank a new temporary profile hnew is created.; else the current profile is modified (default); The parameter ngroup indicates ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProfile.html:38819,simpl,simply,38819,root/html528/TProfile.html,https://root.cern,https://root.cern/root/html528/TProfile.html,4,['simpl'],['simply']
Usability,"hDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsAnaConvPdf.html:4086,clear,clearValueDirty,4086,root/html526/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsAnaConvPdf.html,1,['clear'],['clearValueDirty']
Usability,"hDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg::none(), const RooCmdArg arg6 = RooCmdArg::none(), const RooCmdArg arg7 = RooCmdArg::none(), const RooCmdA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCachedPdf.html:3186,clear,clearValueDirty,3186,root/html526/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsCachedPdf.html,2,['clear'],['clearValueDirty']
Usability,"hDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tRooAbsAnaConvPdf::coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*RooAbsAnaConvPdf::coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(),",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooDecay.html:2590,clear,clearValueDirty,2590,root/html526/RooDecay.html,https://root.cern,https://root.cern/root/html526/RooDecay.html,1,['clear'],['clearValueDirty']
Usability,"hDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*RooAbsAnaConvPdf::coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooBCPEffDecay.html:2892,clear,clearValueDirty,2892,root/html526/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html526/RooBCPEffDecay.html,4,['clear'],['clearValueDirty']
Usability,"hDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooBDecay.html:2790,clear,clearValueDirty,2790,root/html526/RooBDecay.html,https://root.cern,https://root.cern/root/html526/RooBDecay.html,1,['clear'],['clearValueDirty']
Usability,"hDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg::none(), const RooCmdArg arg6 = RooCmdArg::none(), const RooCmdArg arg7 = RooCmdArg::none(), const RooCmdArg arg8 = R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooArgusBG.html:2614,clear,clearValueDirty,2614,root/html526/RooArgusBG.html,https://root.cern,https://root.cern/root/html526/RooArgusBG.html,49,['clear'],['clearValueDirty']
Usability,"hNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; virtual Bool_tchangeModel(const RooResolutionModel& newModel); voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); const RooRealVar*convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsAnaConvPdf.html:4804,clear,clearValueDirty,4804,root/html534/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html,4,['clear'],['clearValueDirty']
Usability,"hPolargram::Initvoid Init()Initialize some of the fields of TGraphPolargram.Definition TGraphPolargram.cxx:327; TGraphPolargram::fRadialTextSizeDouble_t fRadialTextSizeDefinition TGraphPolargram.h:34; TGraphPolargram::GetTickpolarSizeDouble_t GetTickpolarSize()Definition TGraphPolargram.h:79; TGraphPolargram::SetPolarOffsetvoid SetPolarOffset(Double_t PolarOffset=0.04)Set the labels offset.Definition TGraphPolargram.cxx:832; TGraphPolargram::fGradBool_t fGradDefinition TGraphPolargram.h:25; TGraphPolargram::SetTwoPivoid SetTwoPi()Set range from 0 to 2*pi.Definition TGraphPolargram.cxx:947; TGraphPolargram::FindTextAngleDouble_t FindTextAngle(Double_t theta)Determine the orientation of the polar labels according to their angle.Definition TGraphPolargram.cxx:307; TGraphPolargram::SetRadialLabelColorvoid SetRadialLabelColor(Color_t tcolorradial=1)Set radial labels color.Definition TGraphPolargram.cxx:841; TGraphPolargram::PaintCirclevoid PaintCircle(Double_t x, Double_t y, Double_t r, Double_t phimin, Double_t phimax, Double_t theta)This is simplified from TEllipse::PaintEllipse.Definition TGraphPolargram.cxx:373; TGraphPolargram::SetRangeRadialvoid SetRangeRadial(Double_t rmin, Double_t rmax)Set the radial range.Definition TGraphPolargram.cxx:894; TGraphPolargram::fRadianBool_t fRadianDefinition TGraphPolargram.h:23; TGraphPolargram::SetTickpolarSizevoid SetTickpolarSize(Double_t tickpolarsize=0.02)Set polar ticks size.Definition TGraphPolargram.cxx:906; TGraphPolargram::SetAxisAnglevoid SetAxisAngle(Double_t angle=0)Set axis angle.Definition TGraphPolargram.cxx:765; TGraphPolargram::SetToDegreevoid SetToDegree()The Polar circle is labelled using degree.Definition TGraphPolargram.cxx:914; TGraphPolargram::SetNdivPolarvoid SetNdivPolar(Int_t Ndiv=508)Set the number of Polar divisions: enter a number ij with 0<i<99 and 0<j<99.Definition TGraphPolargram.cxx:775; TGraphPolargram::fNdivRadInt_t fNdivRadNumber of radial divisions.Definition TGraphPolargram.h:46; TGraphPolar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphPolargram_8cxx_source.html:37248,simpl,simplified,37248,doc/master/TGraphPolargram_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphPolargram_8cxx_source.html,1,['simpl'],['simplified']
Usability,"hading according to channels counts-; // PICTURE2_MODE_GROUP_HEIGHT, modes of combination of; // shading according to light and to channels counts-; // PICTURE2_MODE_GROUP_LIGHT_HEIGHT); int display_mode; // spectrum display mode (points, grid, contours, bars, x_lines,; // y_lines, bars_x, bars_y, needles, surface, triangles); int z_scale; // z scale (linear, log, sqrt); int nodesx; // number of nodes in x dimension of grid; int nodesy; // number of nodes in y dimension of grid; int count_reg; // width between contours, applies only for contours display mode; int alfa; // angles of display,alfa+beta must be less or equal to 90, alpha- angle; // between base line of Canvas and left lower edge of picture picture; // base plane; int beta; // angle between base line of Canvas and right lower edge of picture base plane; int view_angle; // rotation angle of the view, it can be 0, 90, 180, 270 degrees; int levels; // # of color levels for rainbowed display modes, it does not apply for; // simple display modes algorithm group; float rainbow1_step; // determines the first component step for neighboring color; // levels, applies only for rainbowed display modes, it does not apply; // for simple display modes algorithm group; float rainbow2_step; // determines the second component step for neighboring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; float rainbow3_step; // determines the third component step for neighboring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; int color_alg; // applies only for rainbowed display modes (rgb smooth algorithm,; // rgb modulo color component, cmy smooth algorithm, cmy modulo; // color component, cie smooth algorithm, cie modulo color component,; // yiq smooth algorithm, yiq modulo color component, hsv smooth; // algorithm, hsv modulo color component, it does not apply for simple; // displa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:73014,simpl,simple,73014,root/htmldoc/guides/spectrum/Spectrum.html,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html,2,['simpl'],['simple']
Usability,"hading according to channels counts-; // PICTURE2_MODE_GROUP_HEIGHT, modes of combination of; // shading according to light and to channels counts-; // PICTURE2_MODE_GROUP_LIGHT_HEIGHT); int display_mode; // spectrum display mode (points, grid, contours, bars, x_lines,; // y_lines, bars_x, bars_y, needles, surface, triangles); int z_scale; // z scale (linear, log, sqrt); int nodesx; // number of nodes in x dimension of grid; int nodesy; // number of nodes in y dimension of grid; int count_reg; // width between contours, applies only for contours display mode; int alfa; // angles of display,alfa+beta must be less or equal to 90, alpha- angle; // between base line of Canvas and left lower edge of picture picture; // base plane; int beta; // angle between base line of Canvas and right lower edge of picture base plane; int view_angle; // rotation angle of the view, it can be 0, 90, 180, 270 degrees; int levels; // # of color levels for rainbowed display modes, it does not apply for; // simple display modes algorithm group; float rainbow1_step; // determines the first component step for neighbouring color; // levels, applies only for rainbowed display modes, it does not apply; // for simple display modes algorithm group; float rainbow2_step; // determines the second component step for neighbouring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; float rainbow3_step; // determines the third component step for neighbouring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; int color_alg; // applies only for rainbowed display modes (rgb smooth algorithm,; // rgb modulo color component, cmy smooth algorithm, cmy modulo; // color component, cie smooth algorithm, cie modulo color component,; // yiq smooth algorithm, yiq modulo color component, hsv smooth; // algorithm, hsv modulo color component, it does not apply for simple; // dis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/spectrum/Spectrum.html:72022,simpl,simple,72022,root/html534/guides/spectrum/Spectrum.html,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html,2,['simpl'],['simple']
Usability,"hange both values simultaneously press the mouse button near to the slider center. To change pointer value press the mouse on the pointer and drag it to the desired position.; fSlider = new TGTripleHSlider(parent,100,kDoubleScaleBoth,kSLD_ID,; kHorizontalFrame);; parent->AddFrame(fSlider,new TGLayoutHints(kLHintsExpandX,5,5,5,5));; fSlider->SetConstrained(kTRUE);; fSlider->SetRange(rmin, rmax);; fSlider->SetPosition(pmin, pmax);; fSlider ->SetPointerPosition(pvalue);; 25.8.10 Progress Bars; A progress bar is a widget that shows that an operation is in progress and how much time is left. It is a long rectangular bar, initially empty, that fills with a color as a process is being performed. The filled-in area indicates the percentage of the process that has been completed. You should use this widget for waits exceeding one minute. For a very time consuming operation it is better to break the operation into subtasks and provide a progress bar for each of them. A progress bar may be oriented horizontally or vertically. The horizontally oriented progress bar fills with a color from left to right; the vertically oriented - from bottom to top. A percent complete message provides an indication of the completed part of the process. It is a good practice to include some descriptive text of the process to keep users informed and entertained while they are waiting for process completion.; The picture below shows the progress bars you can create using the classes TGProgressBar, TGHProgressBar, and TGHProgressBar.; // vertical frame with three horizontal progressive bars; TGVerticalFrame *vframe = new TGVerticalFrame(fMain, 10, 10);; fHProg1 = new TGHProgressBar(vframe,TGProgressBar::kStandard,300);; fHProg1->ShowPosition();; fHProg1->SetBarColor(""yellow"");; fHProg2 = new TGHProgressBar(vframe,TGProgressBar::kFancy,300);; fHProg2->SetBarColor(""lightblue"");; fHProg2->ShowPosition(kTRUE,kFALSE,""%.0f events"");; fHProg3 = new TGHProgressBar(vframe,TGProgressBar::kStandard,300);; fHPro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1208165,progress bar,progress bar,1208165,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['progress bar'],['progress bar']
Usability,"hanism to inform interested parties when it switches to a new sub-tree. ; Reimplemented from TSelector. ◆ Print(). void TSelEventGen::Print ; (; Option_t * ; option = """"); const. overridevirtual . This method must be overridden when a class wants to print itself. ; Reimplemented from TObject.; Definition at line 486 of file TSelEventGen.cxx. ◆ Process(). Bool_t TSelEventGen::Process ; (; Long64_t ; entry). overridevirtual . The Process() function is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ; The entry argument specifies which entry in the currently loaded tree is to be processed. It can be passed to either TTree::GetEntry() or TBranch::GetEntry() to read either all or the required parts of the data. When processing keyed objects with PROOF, the object is already loaded and is available via the fObject pointer.; This function should contain the ""body"" of the analysis. It can contain simple or elaborate selection criteria, run algorithms on the data of the event and typically fill histograms. ; Reimplemented from TSelector.; Definition at line 326 of file TSelEventGen.cxx. ◆ SetInputList(). void TSelEventGen::SetInputList ; (; TList * ; input). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 68 of file TSelEventGen.h. ◆ SetObject(). void TSelEventGen::SetObject ; (; TObject * ; obj). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 67 of file TSelEventGen.h. ◆ SetOption(). void TSelEventGen::SetOption ; (; const char * ; option). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 66 of file TSelEventGen.h. ◆ SlaveBegin(). void TSelEventGen::SlaveBegin ; (; TTree * ; tree). overridevirtual . The SlaveBegin() function is called after the Begin() function. ; When running with PROOF SlaveBegin() is called on each slave server. The tree argument is deprecated (on PROOF 0 is passed). ; Reimplemented from TSelector.; Definition at line 89 of fil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelEventGen.html:17599,simpl,simple,17599,doc/master/classTSelEventGen.html,https://root.cern,https://root.cern/doc/master/classTSelEventGen.html,1,['simpl'],['simple']
Usability,"hanism. `TCanvas::Highlighted()` is similar; 3094`TCanvas::Picked()`; 3095 ; 3096- when selected object (histogram as a whole) is different from previous; 3097then emit `Picked()` signal; 3098- when selected (highlighted) bin from histogram is different from previous; 3099then emit `Highlighted()` signal; 3100 ; 3101Any user function (or functions) has to be defined; 3102`UserFunction(TVirtualPad *pad, TObject *obj, Int_t x, Int_t y)`.; 3103In example (see below) has name `PrintInfo()`. All parameters of user; 3104function are taken from; 3105 ; 3106 void TCanvas::Highlighted(TVirtualPad *pad, TObject *obj, Int_t x, Int_t y); 3107 ; 3108- `pad` is pointer to pad with highlighted histogram; 3109- `obj` is pointer to highlighted histogram; 3110- `x` is highlighted x bin for 1D histogram; 3111- `y` is highlighted y bin for 2D histogram (for 1D histogram not in use); 3112 ; 3113Example how to create a connection from any `TCanvas` object to a user; 3114`UserFunction()` slot (see also `TQObject::Connect()` for additional info); 3115 ; 3116 TQObject::Connect(""TCanvas"", ""Highlighted(TVirtualPad*,TObject*,Int_t,Int_t)"",; 3117 0, 0, ""UserFunction(TVirtualPad*,TObject*,Int_t,Int_t)"");; 3118 ; 3119or use non-static ""simplified"" function; 3120`TCanvas::HighlightConnect(const char *slot)`; 3121 ; 3122 c1->HighlightConnect(""UserFunction(TVirtualPad*,TObject*,Int_t,Int_t)"");; 3123 ; 3124NOTE the signal and slot string must have a form; 3125""(TVirtualPad*,TObject*,Int_t,Int_t)""; 3126 ; 3127 root [0] .x $ROOTSYS/tutorials/hsimple.C; 3128 root [1] hpx->SetHighlight(kTRUE); 3129 root [2] .x hlprint.C; 3130 ; 3131file `hlprint.C`; 3132~~~ {.cpp}; 3133void PrintInfo(TVirtualPad *pad, TObject *obj, Int_t x, Int_t y); 3134{; 3135 auto h = (TH1F *)obj;; 3136 if (!h->IsHighlight()) // after highlight disabled; 3137 h->SetTitle(""highlight disable"");; 3138 else; 3139 h->SetTitle(TString::Format(""bin[%03d] (%5.2f) content %g"", x,; 3140 h->GetBinCenter(x), h->GetBinContent(x)));; 3141 pad->Updat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:123630,simpl,simplified,123630,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['simpl'],['simplified']
Usability,"hanisms of ROOT are activated by a single call: ROOT::EnableThreadSafety() which is the successor of the existing TThread::Initialize. This call must take place if ROOT needs to be used in a thread safe manner.; The implementation of TSemaphore was redone based on C++11 thread primitive in order to prevent cases where some of request post were lost.; TDirectory::TContext; We added a default constructor to TDirectory::TContext which record the current directory and will restore it at destruction time and does not change the current directory.; The constructor for TDirectory::TContext that takes a single TDirectory pointer as an argument was changed to set gDirectory to zero when being passed a null pointer; previously it was interpreting a null pointer as a request to not change the current directory - this behavior is now implement by the default constructor.; Collections; In THashList and THashTable, GetListForObject now returns a pointer to const as modifying the returned list (in particular adding to it) can break invariant of THashTable so we need to clearly mark the list as not being allowed to be modified.; In TSeqCollection::Merge, we no longer delete the object in the case where the original collection is marked as a owner.; Global resources.; Several tweaks to if and when, resources held by the global ROOT object (TROOT, TApplication) are deleted. When the default TApplication is replaced by a user provide TApplication, do not call EndOfProcessCleanups and co. and thus do not delete TFiles, TSockets or TColors that have already been created. In EndOfProcessCleanups, we now delete the objects held in TROOT’s TDirectory part. If the libCling library is unloaded, this now induces an immediate tear down of the ROOT resources; consequently objects might be deleted sooner in the process tear down process on some platforms.; TObject instances allocated as part of an array and made part of a collection, as for example the TCanvas instances into the global list of i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:4941,clear,clearly,4941,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,1,['clear'],['clearly']
Usability,"har *cl=nullptr, void *object=nullptr, const char *redo=nullptr, const char *undo=nullptr);  Constructor. ;  ;  TQCommand (const TQCommand &com);  Copy constructor. ;  ;  TQCommand (TObject *obj, const char *redo=nullptr, const char *undo=nullptr);  Constructor. ;  ; virtual ~TQCommand ();  dtor. ;  ; virtual Bool_t CanCompress (TQCommand *c) const;  By default, commands can be compressed if they are: ;  ; virtual Bool_t CanMerge (TQCommand *c) const;  Two commands can be merged if they can be composed into a single command (Macro command). ;  ; virtual void Compress (TQCommand *c);  Compress command. ;  ; void Delete (Option_t *option="""") override;  If ""opt"" is not zero delete every merged command which option string is equal to ""opt"". ;  ; const char * GetName () const override;  Returns the command name. ;  ; Int_t GetNRargs () const;  Returns a number of redo arguments. ;  ; Int_t GetNUargs () const;  Returns a number of undo arguments. ;  ; void * GetObject () const;  Returns an object for which undo redo actions are applied. ;  ; TQConnection * GetRedo () const;  ; Long_t * GetRedoArgs () const;  Returns a pointer to array of redo arguments. ;  ; const char * GetRedoName () const;  Returns the name of redo command. ;  ; Int_t GetStatus () const;  Returns a number of sequential undo or redo operations. ;  ; const char * GetTitle () const override;  Returns command description. ;  ; TQConnection * GetUndo () const;  ; Long_t * GetUndoArgs () const;  Returns a pointer to array of undo arguments. ;  ; const char * GetUndoName () const;  Returns the name of undo command. ;  ; Bool_t IsEqual (const TObject *obj) const override;  Equal comparison. ;  ; Bool_t IsExecuting () const;  Returns kTRUE if command execution is in progress. ;  ; Bool_t IsMacro () const;  Returns kTRUE if neither redo nor undo action specified. ;  ; Bool_t IsRedoing () const;  Redo action is in progress. ;  ; virtual Bool_t IsSetter () const;  Returns kTRUE is command if Redo is the same as Un",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQUndoManager.html:3003,undo,undo,3003,doc/master/classTQUndoManager.html,https://root.cern,https://root.cern/doc/master/classTQUndoManager.html,1,['undo'],['undo']
Usability,"har *distribution=nullptr, const char *projectionMode=nullptr, TGraph **lCurvePlot=nullptr, TSpline **logTauXPlot=nullptr, TSpline **logTauYPlot=nullptr);  scan a function wrt tau and determine the minimum ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TUnfoldSys;  TUnfoldSys (const TH2 *hist_A, EHistMap histmap, ERegMode regmode=kRegModeSize, EConstraint constraint=kEConstraintArea);  set up response matrix A, uncorrelated uncertainties of A and regularisation scheme ;  ;  TUnfoldSys (void);  only for use by root streamer or derived classes ;  ;  ~TUnfoldSys (void) override;  ; void AddSysError (const TH2 *sysError, const char *name, EHistMap histmap, ESysErrMode mode);  Specify a correlated systematic uncertainty. ;  ; void GetBackground (TH1 *bgr, const char *bgrSource=nullptr, const Int_t *binMap=nullptr, Int_t includeError=3, Bool_t clearHist=kTRUE) const;  get background into a histogram ;  ; TSortedList * GetBgrSources (void) const;  Get a new list of all background sources. ;  ; Double_t GetChi2Sys (void);  calculate total chi**2 including all systematic errors ;  ; Bool_t GetDeltaSysBackgroundScale (TH1 *delta, const char *source, const Int_t *binMap=nullptr);  correlated one-sigma shifts from background normalisation uncertainty ;  ; Bool_t GetDeltaSysSource (TH1 *hist_delta, const char *source, const Int_t *binMap=nullptr);  correlated one-sigma shifts correspinding to a given systematic uncertainty ;  ; Bool_t GetDeltaSysTau (TH1 *delta, const Int_t *binMap=nullptr);  correlated one-sigma shifts from shifting tau ;  ; void GetEmatrixInput (TH2 *ematrix, const Int_t *binMap=nullptr, Bool_t clearEmat=kTRUE);  covariance matrix contribution from input measurement uncertainties ;  ; void GetEmatrixSysBackgroundScale (TH2 *ematrix, const char *source, const Int_t *binMap=nullptr, Bool_t clearEmat=kTRUE);  covariance contri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldDensity.html:14732,clear,clearHist,14732,doc/master/classTUnfoldDensity.html,https://root.cern,https://root.cern/doc/master/classTUnfoldDensity.html,1,['clear'],['clearHist']
Usability,"har *name,const char *expression); -; *-* and write your own constructor; -; *-* MyClass::MyClass(const char *name,const char *expression) : TFormula(); -; *-* which has to call the TFormula default constructor and whose implementation; *-* should be similar to the implementation of the normal TFormula constructor; -; *-* This is necessary because the normal TFormula constructor call indirectly; *-* the virtual member functions Analyze, DefaultString, DefaultValue; *-* and DefaultVariable.; -; -. Bool_t CheckOperands(Int_t operation, Int_t& err); Check whether the operand at 'oper-1' is compatible with the operation at 'oper'. Bool_t CheckOperands(Int_t leftoperand, Int_t rightoperartion, Int_t& err); Check whether the operands at 'leftoper' and 'oper-1' are compatible with the operation at 'oper'. Bool_t StringToNumber(Int_t code); Try to 'demote' a string into an array bytes. If this is not possible,; return false. void Clear(Option_t* option = """"); Resets the objects*-*-; *-* ==================; -; *-* Resets the object to its state before compilation.; -. void ClearFormula(Option_t* option = """"); Resets the objects*-*-; *-* ==================; -; *-* Resets the object to its state before compilation.; -. Int_t Compile(const char* expression = """"); -*-*-*-*-*Compile expression already stored in fTitle; *-* ===========================================; -; *-* Loop on all subexpressions of formula stored in fTitle; -; *-* If you overload this member function, you also HAVE TO; *-* never call the constructor:; -; *-* TFormula::TFormula(const char *name,const char *expression); -; *-* and write your own constructor; -; *-* MyClass::MyClass(const char *name,const char *expression) : TFormula(); -; *-* which has to call the TFormula default constructor and whose implementation; *-* should be similar to the implementation of the normal TFormula constructor; -; *-* This is necessary because the normal TFormula constructor call indirectly; *-* the virtual member functions A",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TFormula.html:21611,Clear,Clear,21611,root/html532/TFormula.html,https://root.cern,https://root.cern/root/html532/TFormula.html,1,['Clear'],['Clear']
Usability,"har * GetTitle () const override;  Returns command description. ;  ; TQConnection * GetUndo () const;  ; Long_t * GetUndoArgs () const;  Returns a pointer to array of undo arguments. ;  ; const char * GetUndoName () const;  Returns the name of undo command. ;  ; Bool_t IsEqual (const TObject *obj) const override;  Equal comparison. ;  ; Bool_t IsExecuting () const;  Returns kTRUE if command execution is in progress. ;  ; Bool_t IsMacro () const;  Returns kTRUE if neither redo nor undo action specified. ;  ; Bool_t IsRedoing () const;  Redo action is in progress. ;  ; virtual Bool_t IsSetter () const;  Returns kTRUE is command if Redo is the same as Undo function and is the setter action. ;  ; Bool_t IsUndoing () const;  Undo action is in progress. ;  ; virtual Long64_t Merge (TCollection *, TFileMergeInfo *);  Merge a collection of TQCommand. ;  ; virtual void Merge (TQCommand *c);  Add command to the list of merged commands. ;  ; virtual void SetArgs (Int_t nargs,...);  Set do/redo and undo parameters. ;  ; virtual void SetName (const char *name);  Sets name of the command. ;  ; virtual void SetRedoArgs (Int_t nargs,...);  Set redo parameters. ;  ; virtual void SetTitle (const char *title);  Sets description of the command. ;  ; virtual void SetUndoArgs (Int_t nargs,...);  Set undo parameters. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TList;  TList ();  ; The argument is ignored Use the default constructor TList ()."") ;  ;  TList (TObject *) R__DEPRECATED(6;  ; virtual ~TList ();  Delete the list. ;  ; void AddAfter (const TObject *after, TObject *obj) override;  Insert object after object after in the list. ;  ; virtual void AddAfter (TObjLink *after, TObject *obj);  Insert object after the specified ObjLink object. ;  ; void AddAt (TObject *obj, Int_t idx) override;  Insert object at position idx in the list. ;  ; void AddBefore (const TObject *before, TObject *obj) override;  Insert object befor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQUndoManager.html:4330,undo,undo,4330,doc/master/classTQUndoManager.html,https://root.cern,https://root.cern/doc/master/classTQUndoManager.html,1,['undo'],['undo']
Usability,"har* method) const; virtual voidTH1::Add(const TH1* h1, Double_t c1 = 1); virtual voidTH1::Add(TF1* h1, Double_t c1 = 1, Option_t* option = """"); virtual voidTH1::Add(const TH1* h, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1)MENU ; voidTArrayC::AddAt(Char_t c, Int_t i); virtual voidAddBinContent(Int_t bin); virtual voidAddBinContent(Int_t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDirectoryStatus(); voidTArrayC::Adopt(Int_t n, Char_t* array); virtual voidTObject::AppendPad(Option_t* option = """"); Char_tTArrayC::At(Int_t i) const; virtual voidTH1::Browse(TBrowser* b); virtual Int_tTH1::BufferEmpty(Int_t action = 0); virtual Double_tTH1::Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(); virtual voidCopy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TH1C.html:1732,Clear,Clear,1732,root/html532/TH1C.html,https://root.cern,https://root.cern/root/html532/TH1C.html,1,['Clear'],['Clear']
Usability,"har* method) const; virtual voidTH1::Add(const TH1* h1, Double_t c1 = 1); virtual voidTH1::Add(TF1* h1, Double_t c1 = 1, Option_t* option = """"); virtual voidTH1::Add(const TH1* h, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1)MENU ; voidTArrayC::AddAt(Char_t c, Int_t i); virtual voidAddBinContent(Int_t bin); virtual voidAddBinContent(Int_t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDirectoryStatus(); voidTArrayC::Adopt(Int_t n, Char_t* array); virtual voidTObject::AppendPad(Option_t* option = """"); Char_tTArrayC::At(Int_t i) const; virtual voidTH1::Browse(TBrowser* b); virtual Int_tTH2::BufferEmpty(Int_t action = 0); virtual Double_tTH1::Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(); virtual voidCopy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TH2C.html:2074,Clear,Clear,2074,root/html532/TH2C.html,https://root.cern,https://root.cern/root/html532/TH2C.html,1,['Clear'],['Clear']
Usability,"har* method) const; virtual voidTH1::Add(const TH1* h1, Double_t c1 = 1); virtual voidTH1::Add(TF1* h1, Double_t c1 = 1, Option_t* option = """"); virtual voidTH1::Add(const TH1* h, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1)MENU ; voidTArrayC::AddAt(Char_t c, Int_t i); virtual voidAddBinContent(Int_t bin); virtual voidAddBinContent(Int_t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDirectoryStatus(); voidTArrayC::Adopt(Int_t n, Char_t* array); virtual voidTObject::AppendPad(Option_t* option = """"); Char_tTArrayC::At(Int_t i) const; virtual voidTH1::Browse(TBrowser* b); virtual Int_tTH3::BufferEmpty(Int_t action = 0); virtual Double_tTH1::Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(); virtual voidCopy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TH3C.html:1944,Clear,Clear,1944,root/html532/TH3C.html,https://root.cern,https://root.cern/root/html532/TH3C.html,1,['Clear'],['Clear']
Usability,"har* name = 0, const TGWindow* p = 0, UInt_t w = 10, UInt_t h = 10, UInt_t options = kSunkenFrame|kDoubleBorder, Pixel_t back = GetDefaultFrameBackground()); virtual~TRootEmbeddedCanvas(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCanvas::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); voidAdoptCanvas(TCanvas* c); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual voidTGCanvas::ClearViewPort(); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()SIGNAL ; virtual voidTGWindow::DestroySubwindows(); virtual voidTGWindow::DestroyWindow(); Bool_tTQObject::Disconnect(const char* signal = 0, void* receiver = 0, con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TRootEmbeddedCanvas.html:1506,Clear,ClearViewPort,1506,root/html532/TRootEmbeddedCanvas.html,https://root.cern,https://root.cern/root/html532/TRootEmbeddedCanvas.html,2,['Clear'],['ClearViewPort']
Usability,"har* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); TBranch*TTree::Branch<const char>(const char* name, const char* classname, const char* obj, Int_t bufsize = 32000, Int_t splitlevel = 99); TBranch*TTree::Branch<void>(const char* name, void* obj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual TBranch*TTree::BranchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); virtual TBranch*TTree::BranchRef(); virtual TBranch*TTree::Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual voidTTree::Browse(TBrowser*); virtual Int_tTTree::BuildIndex(const char* majorname, const char* minorname = ""0""); TStreamerInfo*TTree::BuildStreamerInfo(TClass* cl, void* pointer = 0, Bool_t canOptimize = kTRUE); virtual TFile*TTree::ChangeFile(TFile* file); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TTree*TTree::CloneTree(Long64_t nentries = -1, Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTTree::CopyAddresses(TTree*, Bool_t undo = kFALSE); virtual Long64_tTTree::CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); virtual TTree*TTree::CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual TBasket*TTree::CreateBasket(TBranch*); Int_tTTree::Debug() const; virtual voidTTree::Delete(Option_t* option = """")MENU ; virtual voidTTree::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTree::Draw(Option_t* opt); virtual Long64_tTTree::Draw(const char* vare",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THbookTree.html:3693,Clear,Clear,3693,root/html602/THbookTree.html,https://root.cern,https://root.cern/root/html602/THbookTree.html,2,['Clear'],['Clear']
Usability,"har* string); virtual voidTGTextView::AddLineFast(const char* string); virtual voidTGTextView::AddText(TGText* text); virtual voidTGTextView::AdjustWidth(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); boolbasic_ios<char,char_traits<char> >::bad() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGView::ChangeBackground(Pixel_t); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); voidbasic_ios<char,char_traits<char> >::clear(ios_base::iostate __state = goodbit); virtual voidTGTextView::Clear(Option_t* = """"); virtual voidTGTextView::Clicked(const char* word)SIGNAL ; virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual Bool_tTGTextView::Copy(); basic_ios<char,char_traits<char> >&basic_ios<char,char_traits<char> >::copyfmt(const basic_ios<char,char_traits<char> >& __rhs); virtual voidTGTextView::DataChanged()SIGNAL ; virtual voidTGTextView::DataDropped(const char* fname",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGTextViewostream.html:2184,Clear,Clear,2184,root/html604/TGTextViewostream.html,https://root.cern,https://root.cern/root/html604/TGTextViewostream.html,1,['Clear'],['Clear']
Usability,"har* title = """", Int_t compress = 1, Int_t netopt = 0, Bool_t parallelopen = kFALSE); virtual~TNetXNGFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidTDirectoryFile::Append(TObject* obj, Bool_t replace = kFALSE); virtual Int_tTDirectoryFile::AppendKey(TKey* key); virtual voidTObject::AppendPad(Option_t* option = """"); static TFileOpenHandle*TFile::AsyncOpen(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); virtual voidTDirectoryFile::Browse(TBrowser* b); virtual voidTDirectoryFile::Build(TFile* motherFile = 0, TDirectory* motherDir = 0); virtual Bool_tTDirectoryFile::cd(const char* path = 0); static Bool_tTDirectory::Cd(const char* path); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTDirectory::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TObject*TDirectoryFile::CloneObject(const TObject* obj, Bool_t autoadd = kTRUE); virtual voidClose(Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTFile::Copy(TObject&) const; virtual Bool_tTFile::Cp(const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); static Bool_tTFile::Cp(const char* src, const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); virtual TKey*TFile::CreateKey(TDirectory* mother, const TObject* obj, const char* name, Int_t bufsize); virtual TKey*TFile::CreateKey(TDirectory* mother, const void* obj, const TClass* cl, const char* name, Int_t bufsize); static TDirectory*&TDirectory::CurrentDirectory(); static TFile*&TFile::CurrentFile(); static voidTDirectory::DecodeNameCycle(const char* namecycle, char* name, Short_t& cycle, const size_t namesize = 0); virtual voidTFile::Delete(const char* na",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TNetXNGFile.html:1516,Clear,Clear,1516,root/html534/TNetXNGFile.html,https://root.cern,https://root.cern/root/html534/TNetXNGFile.html,1,['Clear'],['Clear']
Usability,"har_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTProofPlayerRemote::Feedback(TList* objs)SIGNAL ; voidTProofPlayer::FeedBackCanvas(const char* name, Bool_t create); virtual Long64_tFinalize(TQueryResult* qr); virtual Long64_tFinalize(Bool_t force = kFALSE, Bool_t sync = kFALSE); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Long64_tTProofPlayer::GetCacheSize(); virtual TQueryResult*TProofPlayer::GetCurrentQuery() const; virtual Int_tTProofPlayer::GetDrawArgs(const char* var, const char* sel, Option_t* opt, TString& selector, TString& objname); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tTProofPlayer::GetEventsProcessed() const; virtual TVirtualProofPlayer::EExitStatusTProofPlayer::GetExitStatus() const; virtual const char*TObject::GetIconName() const; virtual TList*TProofPlayer::GetInputList() const; virtual Int_tTProofPlayer::GetLearnEntries(); TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofPlayerLite.html:4622,Feedback,Feedback,4622,root/html532/TProofPlayerLite.html,https://root.cern,https://root.cern/root/html532/TProofPlayerLite.html,2,['Feedback'],['Feedback']
Usability,"har_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTProofPlayerRemote::Feedback(TList* objs)SIGNAL ; voidTProofPlayer::FeedBackCanvas(const char* name, Bool_t create); virtual Long64_tTProofPlayerRemote::Finalize(TQueryResult* qr); virtual Long64_tTProofPlayerRemote::Finalize(Bool_t force = kFALSE, Bool_t sync = kFALSE); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Long64_tTProofPlayer::GetCacheSize(); virtual TQueryResult*TProofPlayer::GetCurrentQuery() const; virtual Int_tTProofPlayer::GetDrawArgs(const char* var, const char* sel, Option_t* opt, TString& selector, TString& objname); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tTProofPlayer::GetEventsProcessed() const; virtual TVirtualProofPlayer::EExitStatusTProofPlayer::GetExitStatus() const; virtual const char*TObject::GetIconName() const; virtual TList*TProofPlayer::GetInputList() const; virtual Int_tTProofPlayer::GetLearnEntries(); TList*TQObject::GetListOfClassS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofPlayerSuperMaster.html:5155,Feedback,Feedback,5155,root/html532/TProofPlayerSuperMaster.html,https://root.cern,https://root.cern/root/html532/TProofPlayerSuperMaster.html,2,['Feedback'],['Feedback']
Usability,"harts. ROOT; » HIST; » HIST; » THnT<unsigned int>. class THnT<unsigned int>: public THn. Helper struct to hold one dimension's bin range for THnBinIter. Function Members (Methods); public:. virtual~THnT<unsigned int>(); voidTObject::AbstractMethod(const char* method) const; voidTHnBase::Add(const THnBase* h, Double_t c = 1.); voidTHnBase::Add(const TH1* hist, Double_t c = 1.); voidTHn::AddBinContent(const Int_t* idx, Double_t v = 1.); virtual voidTHn::AddBinContent(Long64_t bin, Double_t v = 1.); virtual voidTHn::AddBinError2(Long64_t bin, Double_t e2); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTHnBase::Browse(TBrowser* b); voidTHnBase::CalculateErrors(Bool_t calc = kTRUE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THn*THn::CreateHn(const char* name, const char* title, const TH1* h1); static THn*THn::CreateHn(const char* name, const char* title, const THnBase* hn); virtual ROOT::THnBaseBinIter*THn::CreateIter(Bool_t respectAxisRange) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THnT_unsigned_int_.html:1020,Clear,Clear,1020,root/html602/THnT_unsigned_int_.html,https://root.cern,https://root.cern/root/html602/THnT_unsigned_int_.html,2,['Clear'],['Clear']
Usability,"hashtable will be resized and refilled to reduce; the collision rate to about 1. The higher the collision rate, i.e. the; longer the linked lists, the longer lookup will take. If rehashlevel=0; the table will NOT automatically be rehashed. Use Rehash() for manual; rehashing. ~THashTable(); Delete a hashtable. Objects are not deleted unless the THashTable is the; owner (set via SetOwner()). void Add(TObject* obj); Add object to the hash table. Its position in the table will be; determined by the value returned by its Hash() function. void AddBefore(const TObject* before, TObject* obj); Add object to the hash table. Its position in the table will be; determined by the value returned by its Hash() function.; If and only if 'before' is in the same bucket as obj, obj is added; in front of 'before' within the bucket's list. void AddAll(const TCollection* col); Add all objects from collection col to this collection.; Implemented for more efficient rehashing. void Clear(Option_t* option = """"); Remove all objects from the table. Does not delete the objects; unless the THashTable is the owner (set via SetOwner()). Int_t Collisions(const char* name) const; Returns the number of collisions for an object with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* obj) const; Returns the number of collisions for an object (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all objects from the table AND delete all heap based objects. TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the TList corresponding to object's name based hash value.; One can iter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THashTable.html:9846,Clear,Clear,9846,root/html534/THashTable.html,https://root.cern,https://root.cern/root/html534/THashTable.html,3,['Clear'],['Clear']
Usability,"hat it has one daughter. Of course, the gas has some container also, but let us keeps it like that for the sake of simplicity. Since we did not supply the third argument, the wire will be positioned with an identity transformation inside the chamber.; Overlapping Volumes; Positioning volumes that does not overlap their neighbors nor extrude their container is sometimes quite strong constraint. Having a limited set of geometric shapes might force sometimes overlaps. Since overlapping is contradictory to containment, a point belonging to an overlapping region will naturally belong to all overlapping partners. The answer provided by the modeller to ""Where am I?"" is no longer deterministic if there is no priority assigned.; There are two ways out provided by the modeller in such cases and we will illustrate them by examples. Suppose we have 2 crossing tubes that we have to describe. Such a structure cannot be decomposed in a containment schema. This is a typical example of simple structure that can be handled by using composite shapes. What we have to do is to define as shapes the inner and outer parts of the tubes (tubes having Rmin=0,Rmax=inner/outer radius), then to make a composite:; C = (Tub1out+Tub2out)-(Tub1in+Tub2in); On the other hand, if we have an EM calorimeter having a honeycomb structure, Boolean combinations do not help anymore. Here the problem is that we usually have a very large number of cells that are naturally belonging to the same container. This result in a very flat and slow structure for that particular container, which we would very much want to avoid by introducing additional levels in depth. We can describe the basic cell as a hexahedron that we can represent by using a polygon primitive shape. Instead of putting one by one all cells in the same container, we can define rows of such elements, fitting in box-shaped containers. Then we can put row-beside-row inside the container, making life much easier for its navigation algorithms. The problem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:37632,simpl,simple,37632,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['simpl'],['simple']
Usability,"hat the; expression eprim2 is very close to 0 (rounding problems) or 0.; - The algorithm is modified/protected for the case; when a TProfile2D is projected (ProjectionX). The previous algorithm; generated a N^2 problem when projecting a TProfile2D with a large number of; bins (eg 100000).; - in version 3.10/02, a new static function TProfile::Approximate; is introduced to enable or disable (default) the approximation.; (see also comments in TProfile::GetBinError). Option_t * GetErrorOption() const; -*-*Return option to compute profile2D errors; *-* =========================================. void GetStats(Double_t* stats) const; fill the array stats from the contents of this profile; The array stats must be correctly dimensionned in the calling program.; stats[0] = sumw; stats[1] = sumw2; stats[2] = sumwx; stats[3] = sumwx2; stats[4] = sumwy; stats[5] = sumwy2; stats[6] = sumwxy; stats[7] = sumwz; stats[8] = sumwz2. If no axis-subrange is specified (via TAxis::SetRange), the array stats; is simply a copy of the statistics quantities computed at filling time.; If a sub-range is specified, the function recomputes these quantities; from the bin contents in the current axis range. void LabelsDeflate(Option_t* axis = ""X""); Reduce the number of bins for this axis to the number of bins having a label. void LabelsInflate(Option_t* axis = ""X""); Double the number of bins for axis.; Refill histogram; This function is called by TAxis::FindBin(const char *label). void LabelsOption(Option_t* option = ""h"", Option_t* axis = ""X""); Set option(s) to draw axis with labels; option = ""a"" sort by alphabetic order; = "">"" sort by decreasing values; = ""<"" sort by increasing values; = ""h"" draw labels horizonthal; = ""v"" draw labels vertical; = ""u"" draw labels up (end of label right adjusted); = ""d"" draw labels down (start of label left adjusted). Long64_t Merge(TCollection* list); Merge all histograms in the collection in this histogram.; This function computes the min/max for the axes,; compute",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProfile2D.html:37682,simpl,simply,37682,root/html528/TProfile2D.html,https://root.cern,https://root.cern/root/html528/TProfile2D.html,10,['simpl'],['simply']
Usability,"he 1st Leaf named name in any Branch of this Tree or any branch in the list of fri...Definition TTree.cxx:6098; TTree::fTotBytesLong64_t fTotBytesTotal number of bytes in all branches before compression.Definition TTree.h:86; TTree::FlushBasketsvirtual Int_t FlushBaskets(bool create_cluster=true) constWrite to disk all the basket that have not yet been individually written and create an event cluster ...Definition TTree.cxx:5129; TTree::GetDefaultEntryOffsetLenInt_t GetDefaultEntryOffsetLen() constDefinition TTree.h:459; TTree::fMaxClusterRangeInt_t fMaxClusterRange! Memory allocated for the cluster range.Definition TTree.h:96; TTree::Showvirtual void Show(Long64_t entry=-1, Int_t lenmax=20)Print values of all active leaves for entry.Definition TTree.cxx:9385; TTree::fEventListTEventList * fEventList! Pointer to event selection list (if one)Definition TTree.h:125; TTree::GetAutoSavevirtual Long64_t GetAutoSave() constDefinition TTree.h:448; TTree::StopCacheLearningPhasevirtual Int_t StopCacheLearningPhase()Stop the cache learning phase.Definition TTree.cxx:9474; TTree::GetEntryvirtual Int_t GetEntry(Long64_t entry, Int_t getall=0)Read all branches of entry and return total number of bytes read.Definition TTree.cxx:5638; TTree::fSortedBranchesstd::vector< std::pair< Long64_t, TBranch * > > fSortedBranches! Branches to be processed in parallel when IMT is on, sorted by average task timeDefinition TTree.h:144; TTree::SetCircularvirtual void SetCircular(Long64_t maxEntries)Enable/Disable circularity for this tree.Definition TTree.cxx:8892; TTree::GetEstimatevirtual Long64_t GetEstimate() constDefinition TTree.h:507; TTree::GetDebugMaxLong64_t GetDebugMax() constDefinition TTree.h:460; TTree::fSavedBytesLong64_t fSavedBytesNumber of autosaved bytes.Definition TTree.h:88; TTree::AddBranchToCachevirtual Int_t AddBranchToCache(const char *bname, bool subbranches=false)Add branch with name bname to the Tree cache.Definition TTree.cxx:1059; TTree::GetMedianClusterSizeLong64_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8h_source.html:56085,learn,learning,56085,doc/master/TTree_8h_source.html,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html,1,['learn'],['learning']
Usability,"he Brent method to minimize one-dimensional function. An interval containing the function minimum must be provided. Here is an example where we define the function to minimize as a lambda function (requires C++11). The function to minimize must be given to the class implementing the algorithm as a ROOT::Math::IBaseFunctionOneDim object.; ROOT::Math::Functor1D func( [](double x){ return 1 + -4*x + 1*x*x; } );. ROOT::Math::BrentMinimizer1D bm;; bm.SetFunction(func, -10,10);; bm.Minimize(10,0,0);; cout << ""Minimum: f("" << bm.XMinimum() << "") = "" <<bm.FValMinimum() << endl;; Note that when setting the function to minimize, one needs to provide the interval range to find the minimum. In the Minimize call, the maximum number of function calls, the relative and absolute tolerance must be provided.; 13.10.1.2 ROOT::Math::GSLMInimizer1D; This class wraps two different methods from the GSL. The algorithms which can be chosen at construction time are GOLDENSECTION, which is the simplest method but the slowest and BRENT (the default one) which combines the golden section with a parabolic interpolation. The algorithm can be chosen as a different enumeration in the constructor: * ROOT::Math::Minim1D::kBRENT for the Brent algorithm (default) * ROOT::Math::Minim1D::kGOLDENSECTION for the golden section algorithm; // this makes class with the default Brent algorithm; ROOT::Math::GSLMinimizer1D minBrent;; // this make the class with the Golden Section algorithm; ROOT::Math::GSLMinimizer1D minGold(ROOT::Math::Minim1D::kGOLDENSECTION);; The interface to set the function and to minimize is the same as in the case of the BrentMinimizer1D.; 13.10.1.3 Using the TF1 class; It is possible to perform the one-dimensional minimization/maximization of a function by using directly the function class in ROOT, TF1 of the Hist library. The minmization is implemented in TF1 using the BrentMInimizer1D and available with the class member functions * TF1::GetMinimum/TF1::GetMaximum to find the function ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:715971,simpl,simplest,715971,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simplest']
Usability,"he Double_t argument det is supplied, the matrix determinant is calculated. A.InvertFast(&det); TMatrixX; like Invert but for matrices i =(6x6)a faster but less accurate Cramer algorithm is used. A.Rank1Update(v,alpha); TMatrixX; Perform with vector v a rank 1 operation on the matrix: \(A = A + \alpha.\nu.\nu^T\). A.RandomizePD(alpha,beta,seed)`; TMatrixX; \(A_{ij} = (\beta-\alpha)\bigcup(0,1)+\alpha\) a random symmetric positive-definite matrix is generated with elements uniformly distributed between \(\alpha\) and \(\beta\). Output TMatrixX indicates that the returned matrix is of the same type as A, being TMatrixD, TMatrixDSym or TMatrixDSparse. Next table shows miscellaneous operations for TMatrixD. Format; Output; Description. A.Rank1Update(v1,v2,alpha); TMatrixD; Perform with vector v1 and v2, a rank 1 operation on the matrix: \(A = A + \alpha.\nu.\nu2^T\). 14.5 Matrix Views; Another way to access matrix elements is through the matrix-view classes, TMatrixDRow, TMatrixDColumn, TMatrixDDiag and TMatrixDSub (each has also a const version which is obtained by simply appending const to the class name). These classes create a reference to the underlying matrix, so no memory management is involved. The next table shows how the classes access different parts of the matrix:. class; view. TMatrixDRow const(X,i) TMatrixDRow(X,i); \[ \left(\begin{array}{ccccc}; x_{00} & & & & x_{0n} \\; & & & & \\; x_{i0} & ... & x_{ij} & ... & x_{in} \\; & & & & \\; x_{n0} & & & & x_{nn}; \end{array}\right)\]. TMatrixDColumn const(X,j) TMatrixDColumn(X,j); \[ \left(\begin{array}{ccccc}; x_{00} & & x_{0j} & & x_{0n} \\; & & ... & & \\; & & x_{ij} & & \\; & & ... & & \\; x_{n0} & & x_{nj} & & x_{nn}; \end{array}\right)\]. TMatrixDDiag const(X) TMatrixDDiag(X); \[ \left(\begin{array}{ccccc}; x_{00} & & & & x_{0n} \\; & ... & & & \\; & & ... & & \\; & & & ... & \\; x_{n0} & & & & x_{nn}; \end{array}\right)\]. TMatrixDSub const(X,i,l,j,k) TMatrixDSub(X,i,l,j,k); \[ \left(\begin{array}{ccccc}",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:783968,simpl,simply,783968,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simply']
Usability,"he RooStats::ConfInterval interface ;  CMCMCIntervalPlotThis class provides simple and straightforward utilities to plot a MCMCInterval object ;  CMetropolisHastingsThis class uses the Metropolis-Hastings algorithm to construct a Markov Chain of data points using Monte Carlo ;  CMinNLLTestStatMinNLLTestStat is an implementation of the TestStatistic interface that calculates the minimum value of the negative log likelihood function and returns it as a test statistic ;  CModelConfigModelConfig is a simple class that holds configuration information specifying how a model should be used in the context of various RooStats tools ;  CNeymanConstructionNeymanConstruction is a concrete implementation of the NeymanConstruction interface that, as the name suggests, performs a NeymanConstruction ;  CNuisanceParametersSamplerHelper class for ToyMCSampler ;  CNumberCountingPdfFactoryA factory for building PDFs and data for a number counting combination ;  CNumEventsTestStatNumEventsTestStat is a simple implementation of the TestStatistic interface used for simple number counting ;  CPdfProposalPdfProposal is a concrete implementation of the ProposalFunction interface ;  CPointSetIntervalPointSetInterval is a concrete implementation of the ConfInterval interface ;  CProfileInspectorUtility class to plot conditional MLE of nuisance parameters vs ;  CProfileLikelihoodCalculatorProfileLikelihoodCalculator is a concrete implementation of CombinedCalculator (the interface class for a tools which can produce both RooStats HypoTestResults and ConfIntervals) ;  CProfileLikelihoodTestStatProfileLikelihoodTestStat is an implementation of the TestStatistic interface that calculates the profile likelihood ratio at a particular parameter point given a dataset ;  CProofConfigHolds configuration options for proof and proof-lite ;  CProposalFunctionProposalFunction is an interface for all proposal functions that would be used with a Markov Chain Monte Carlo algorithm ;  CProposalHelper;  CRatioOfP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:7869,simpl,simple,7869,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,5,['simpl'],['simple']
Usability,"he STOP button; 114from the bottom-left; 115You can toggle recording of the current command in the history file by; 116checking the Rec button from the top-right; 117 ; 118### Context menus; 119 ; 120 You can activate context menus by right-clicking on items or inside the; 121right panel.; 122 ; 123Context menus for mapped items from the left tree-type list :; 124 The items from the left that are provided with context menus are tree and; 125branch items. You can directly activate the *MENU* marked methods of TTree; 126from this menu.; 127 ; 128Context menu for the right panel:; 129 ; 130 A general context menu is activated if the user right-clicks the right panel.; 131 ; 132 Commands are :; 133 - EmptyAll : clears the content of all expressions;; 134 - ExecuteCommand : execute a ROOT command;; 135 - MakeSelector : equivalent of TTree::MakeSelector();; 136 - NewExpression : add an expression item in the right panel;; 137 - Process : equivalent of TTree::Process();; 138 - SaveSource : save the current session as a C++ macro;; 139 - SetScanFileName : define a name for the file where TTree::Scan command; 140 is redirected when the `<Scan>` button is checked;; 141 - SetTreeName : open a new tree with this name in the viewer;; 142 ; 143 A specific context menu is activated if expressions/leaves are right-clicked.; 144 ; 145 Commands are :; 146 - Draw : draw a histogram for this item;; 147 - EditExpression : pops-up the expression editor;; 148 - Empty : empty the name and alias of this item;; 149 - RemoveItem : removes clicked item from the list;; 150 - Scan : scan this expression;; 151 - SetExpression : edit name and alias for this item by hand;; 152 ; 153Starting the viewer; 154 ; 155 1. From the TBrowser: Select a tree in the TBrowser, then call the; 156 StartViewer() method from its context menu (right-click on the tree).; 157 2. From the command line: Start a ROOT session in the directory where you have; 158 your tree. You will need first to load the library for TTree",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeViewer_8cxx_source.html:6927,clear,clears,6927,doc/master/TTreeViewer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html,1,['clear'],['clears']
Usability,"he axis, to set the min/max in z.; 3.8.2.14 The SPEC Option; The “SPEC” option offers a large set of options/attributes to visualize 2D histograms thanks to “operators” following the “SPEC” keyword. For example, to draw the 2-D histogram h2 using all default attributes except the viewing angles, one can do:; h2->Draw(""SPEC a(30,30,0)"");; The operators’ names are case insensitive (i.e. one can use “a” or “A”) and their parameters are separated by coma “,”. Operators can be put in any order in the option and must be separated by a space "" "". No space characters should be put in an operator. All the available operators are described below.; The way how a 2D histogram will be painted is controlled by two parameters: the “Display modes groups” and the “Display Modes”. “Display modes groups” can take the following values:. 0 = Simple - simple display modes using one color only; 1 = Light - the shading is carried out according to the position of the fictive light source; 2 = Height - the shading is carried out according to the channel contents; 3 = LightHeight - combination of two previous shading algorithms (one can control the weight between both algorithms). “Display modes” can take the following values:. 1 = Points; 2 = Grid; 3 = Contours; 4 = Bars; 5 = LinesX; 6 = LinesY; 7 = BarsX; 8 = BarsY; 9 = Needles; 10 = Surface; 11 = Triangles. These parameters can be set by using the “dm” operator in the option.; h2->Draw(""SPEC dm(1,2)"");; The above example draws the histogram using the “Light Display mode group” and the “Grid Display mode”. The following tables summarize all the possible combinations of both groups:. Points; Grid; Contours; Bars; LinesX; LinesY. Simple; x; x; x; x; x; x. Light; x; x. x; x. Height; x; x; x; x; x; x. LightHeight; x; x. x; x. BarsX; BarsY; Needles; Surface; Triangles. Simple; x; x; x. x. Light. x; x. Height; x; x. x; x. LightHeight. x; x. The “Pen Attributes” can be changed using pa(color,style,width). Next example sets line color to 2, line ty",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:101666,simpl,simple,101666,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,3,"['Simpl', 'simpl']","['Simple', 'simple']"
Usability,"he cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. TTree * GetOwner() const; return the owner of this cache. TTree * GetTree() const; return Tree in the cache. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreeCache.html:21853,Learn,Learn,21853,root/html532/TTreeCache.html,https://root.cern,https://root.cern/root/html532/TTreeCache.html,1,['Learn'],['Learn']
Usability,"he clip current to see the effect.; 9.13.2.6 Manipulators; Manipulators are GUI ‘widgets’ or controls attached to a 3D object in the viewer, allowing a direct manipulation of the object’s geometry. There are three manipulators for the three basic geometries transformations. In each case, the manipulator consists of three components, one for each local axis of the object, shown in standard colors: red (X), green (Y) and blue (Z). GL Viewer object manipulators. Activate the manipulator by moving the mouse over one of these components (which turns yellow to indicate active state). Click with left mouse and drag this active component to perform the manipulation. Toggle between the manipulator types using the ‘x’, ‘c’, ‘v’ keys while the mouse cursor is above the manipulator. Note: Manipulators cannot be controlled via the API at present.; 9.13.2.7 Guides; Guides are visual aids drawn into the viewer world. Controls for these are under the “Guides” tab:; Viewer Controls Pane Guides Tab; Axes show the world (global) frame coordinatedirections: X (red), Y (green) and Z (blue). The negative portion of the axis line is shown in dark color, the positive in bright. The axis name and minimum / maximum values are labeled in the same color. There are three options for axes drawing - selected by radio buttons:. None - not drawn (default).; Edge - draw axes on the (minimum) edge of the scene extents box.; Origin - drawn axes through the origin. For edge axes, the zero value for each axis is marked on the axis line with a colored sphere. For origin axes, a single white sphere is shown at the origin.; Edge axes are depth clipped - i.e. are obscured by 3D objects in front of them. Origin axes (which generally pass through the middle of the 3D scene) are not depth clipped - so always visible.; A single orange sphere of fixed view port (window) size can be shown at any arbitrary position. Enable / disable the drawing with ‘Show’ checkbox. Enter X/Y/Z position in the edit boxes to set pos",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:396736,Guid,Guides,396736,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['Guid'],['Guides']
Usability,"he constructor for the complete description of learning methods and parameters) ;  ; void SetEpsilon (Double_t eps);  Sets Epsilon - used in stochastic minimisation (look at the constructor for the complete description of learning methods and parameters) ;  ; void SetEta (Double_t eta);  Sets Eta - used in stochastic minimisation (look at the constructor for the complete description of learning methods and parameters) ;  ; void SetEtaDecay (Double_t ed);  Sets EtaDecay - Eta *= EtaDecay at each epoch (look at the constructor for the complete description of learning methods and parameters) ;  ; void SetEventWeight (const char *);  Set the event weight. ;  ; void SetLearningMethod (TMultiLayerPerceptron::ELearningMethod method);  Sets the learning method. ;  ; void SetReset (Int_t reset);  Sets number of epochs between two resets of the search direction to the steepest descent. ;  ; void SetTau (Double_t tau);  Sets Tau - used in line search (look at the constructor for the complete description of learning methods and parameters) ;  ; void SetTestDataSet (const char *test);  Sets the Test dataset. ;  ; void SetTestDataSet (TEventList *test);  Sets the Test dataset. ;  ; void SetTrainingDataSet (const char *train);  Sets the Training dataset. ;  ; void SetTrainingDataSet (TEventList *train);  Sets the Training dataset. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Train (Int_t nEpoch, Option_t *option=""text"", Double_t minE=0);  Train the network. ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to cur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiLayerPerceptron.html:14384,learn,learning,14384,doc/master/classTMultiLayerPerceptron.html,https://root.cern,https://root.cern/doc/master/classTMultiLayerPerceptron.html,1,['learn'],['learning']
Usability,"he current Tree; static Int_tfgLearnEntriesnumber of entries used for learning mode. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeCache(); Default Constructor. TTreeCache(TTree* tree, Int_t buffersize = 0); Constructor. ~TTreeCache(); destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subgbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); Add a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expressions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. void DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:22051,learn,learning,22051,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,2,['learn'],['learning']
Usability,"he deletion ot update the list itself.; 1107 ; 1108 static TObject harmless;; 1109 TObjLink *cursor = files->FirstLink();; 1110 while (cursor) {; 1111 Content *dir = static_cast<Content*>( cursor->GetObject() );; 1112 if (dir) {; 1113 // In order for the iterator to stay valid, we must; 1114 // prevent the removal of the object (dir) from the list; 1115 // (which is done in TFile::Close). We can also can not; 1116 // just move to the next iterator since the Close might; 1117 // also (indirectly) remove that file.; 1118 // So we SetObject to a harmless value, so that 'dir'; 1119 // is not seen as part of the list.; 1120 // We will later, remove all the object (see files->Clear(); 1121 cursor->SetObject(&harmless); // this must not be zero otherwise things go wrong.; 1122 // See related comment at the files->Clear(""nodelete"");; 1123 dir->Close(""nodelete"");; 1124 // Put it back; 1125 cursor->SetObject(dir);; 1126 }; 1127 cursor = cursor->Next();; 1128 };; 1129 // Now were done, clear the list but do not delete the objects as; 1130 // they have been moved to the list of closed objects and must be; 1131 // deleted from there in order to avoid a double delete from a; 1132 // use objects (on the interpreter stack).; 1133 files->Clear(""nodelete"");; 1134 }; 1135 ; 1136 static void R__ListSlowDeleteContent(TList *files); 1137 {; 1138 // Routine to delete the content of list of files using the 'slow' techniques; 1139 ; 1140 static TObject harmless;; 1141 TObjLink *cursor = files->FirstLink();; 1142 while (cursor) {; 1143 TDirectory *dir = dynamic_cast<TDirectory*>( cursor->GetObject() );; 1144 if (dir) {; 1145 // In order for the iterator to stay valid, we must; 1146 // prevent the removal of the object (dir) from the list; 1147 // (which is done in TFile::Close). We can also can not; 1148 // just move to the next iterator since the Close might; 1149 // also (indirectly) remove that file.; 1150 // So we SetObject to a harmless value, so that 'dir'; 1151 // is not seen as part o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:44026,clear,clear,44026,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['clear'],['clear']
Usability,"he entry.; If not cached just call DirectDraw() for normal non DL cached drawing. void DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; Draw the logical shape in highlight mode.; If lvl argument is less than 0 (-1 by default), the index into color-set; is taken from the physical shape itself. void ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); Virtual method called-back after a secondary selection hit; is recorded (see TGLViewer::HandleButton(), Ctrl-Button1).; The ptr argument holds the GL pick-record of the closest hit. This base-class implementation simply prints out the result. void InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; Invoke popup menu or our bound external TObject (if any), using passed; 'menu' object, at location 'x' 'y'. Bool_t IgnoreSizeForOfInterest() const; Return true if size of this shape should be ignored when determining if; the object should be drawn. In this base-class we simply return state of; static flag fgIgnoreSizeForCameraInterest. Several sub-classes override this virtual function. Bool_t GetIgnoreSizeForCameraInterest(); Get state of static fgIgnoreSizeForCameraInterest flag.; When this is true all objects, also very small, will be drawn by GL. void SetIgnoreSizeForCameraInterest(Bool_t isfci); Set state of static fgIgnoreSizeForCameraInterest flag. TGLLogicalShape& operator=(const TGLLogicalShape& ). UInt_t Ref() const; Physical shape reference-counting, replica management. { return fRef; }. void StrongRef(Bool_t strong) const; { fRefStrong = strong; }. const TGLPhysicalShape* GetFirstPhysical() const; { return fFirstPhysical; }. TObject* ID() const; { return fExternalObj; }. TObject* GetExternal() const; { return fExternalObj; }. TGLScene* GetScene() const; { return fScene; }. void UpdateBoundingBox(); {}. UInt_t DLOffset(Short_t ) const; { return 0; }. ELODAxes SupportedLODAxes() const; { return kLODAxesNone; }. void DirectDraw(TGLRnrCtx& rnrCtx) const. Bool_t Kee",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLLogicalShape.html:8176,simpl,simply,8176,root/html534/TGLLogicalShape.html,https://root.cern,https://root.cern/root/html534/TGLLogicalShape.html,2,['simpl'],['simply']
Usability,"he entry.; If not cached just call DirectDraw() for normal non DL cached drawing. void DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; Draw the logical shape in highlight mode.; If lvl argument is less than 0 (-1 by default), the index into color-set; is taken from the physical shape itself. void ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); Virtual method called-back after a secondary selection hit; is recorded (see TGLViewer::HandleButton(), Ctrl-Button1).; The ptr argument holds the GL pick-record of the closest hit. This base-class implementation simply prints out the result. void InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; Invoke popup menu or our bound external TObject (if any), using passed; 'menu' object, at location 'x' 'y'. Bool_t IgnoreSizeForOfInterest() const; Return true if size of this shape should be ignored when determining if; the object should be drawn. In this base-class we simply return state of; static flag fgIgnoreSizeForCameraInterest. Several sub-classes override this virtual function. Bool_t GetIgnoreSizeForCameraInterest(); Get state of static fgIgnoreSizeForCameraInterest flag.; When this is true all objects, also very small, will be drawn by GL. void SetIgnoreSizeForCameraInterest(Bool_t isfci); Set state of static fgIgnoreSizeForCameraInterest flag. TGLLogicalShape(const TGLLogicalShape& ). TGLLogicalShape& operator=(const TGLLogicalShape& ). UInt_t Ref() const; Physical shape reference-counting, replica management. { return fRef; }. void StrongRef(Bool_t strong) const; { fRefStrong = strong; }. const TGLPhysicalShape* GetFirstPhysical() const; { return fFirstPhysical; }. TObject* ID() const; { return fExternalObj; }. TObject* GetExternal() const; { return fExternalObj; }. TGLScene* GetScene() const; { return fScene; }. void UpdateBoundingBox(); {}. UInt_t DLOffset(Short_t ) const; { return 0; }. ELODAxes SupportedLODAxes() const; { return kLODAxesNone; }. void Direc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLLogicalShape.html:8627,simpl,simply,8627,root/html602/TGLLogicalShape.html,https://root.cern,https://root.cern/root/html602/TGLLogicalShape.html,4,['simpl'],['simply']
Usability,he filters applied ;  tdf004_cutFlowReport.pyThis tutorial shows how to get information about the efficiency of the filters applied ;  tdf005_fillAnyObject.C This tutorial shows how to fill any object the class of which exposes a Fill method ;  tdf006_ranges.C This tutorial shows how to express the concept of ranges when working with the TDataFrame ;  tdf006_ranges.py This tutorial shows how to express the concept of ranges when working with the TDataFrame ;  tdf007_snapshot.C This tutorial shows how to write out datasets in ROOT formatusing the TDataFrame ;  tdf007_snapshot.py This tutorial shows how to write out datasets in ROOT formatusing the TDataFrame ;  tdf008_createDataSetFromScratch.C This tutorial shows how to create a dataset from scratch with TDataFrame ;  tdf008_createDataSetFromScratch.py This tutorial shows how to create a dataset from scratch with TDataFrame ;  tdf009_FromScratchVSTTree.C This tutorial illustrates how simpler it can be to use a TDataFrame to create a dataset with respect to the usage of the TTree interfaces ;  tdf010_trivialDataSource.C This tutorial illustrates how use the TDataFrame in combination with a TDataSource ;  tdf010_trivialDataSource.py This tutorial illustrates how use the TDataFrame in combination with a TDataSource ;  tdf011_ROOTDataSource.C This tutorial illustrates how use the TDataFrame in combination with a TDataSource ;  tdf011_ROOTDataSource.py This tutorial illustrates how use the TDataFrame in combination with a TDataSource ;  tdf012_DefinesAndFiltersAsStrings.C ;  tdf012_DefinesAndFiltersAsStrings.py ;  tdf013_InspectAnalysis.C Showcase registration of callback functions that act on partial results while the event-loop is running using OnPartialResult and OnPartialResultSlot ;  tdf014_CSVDataSource.C This tutorial illustrates how use the TDataFrame in combination with a TDataSource ;  tdf014_CSVDataSource.py This tutorial illustrates how use the TDataFrame in combination with a TDataSource ;  tdf101_h1Analysis,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:97912,simpl,simpler,97912,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,1,['simpl'],['simpler']
Usability,"he first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table; Note: This is a base class. If one fears it is not safe; ----- to allow ""void *"" one may potect the end-user code; providing a derived class with the appropriated type; of the parameters. void BuildSorter(TString& colName, Int_t firstRow, Int_t numberRows). BuildSorter backs TTableSorter ctor. - colName - may be followed by the square brackets with integer number inside,; if that columm is an array (for example ""phys[3]"").; NO expression inside of [], only a single integer number allowed !; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Float_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the size of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Double_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the size of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Long_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the sie of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows fr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTableSorter.html:16398,simpl,simpleArray,16398,root/html528/TTableSorter.html,https://root.cern,https://root.cern/root/html528/TTableSorter.html,10,['simpl'],['simpleArray']
Usability,"he fit data Set the constant and slope a...Definition HFitInterface.cxx:267; ROOT::Fit::InitGausvoid InitGaus(const ROOT::Fit::BinData &data, TF1 *f1)compute initial parameter for gaussian function given the fit data Set the sigma limits for zero top ...Definition HFitInterface.cxx:306; ROOT::Fit::DoFillDatavoid DoFillData(BinData &dv, const TGraph *gr, BinData::ErrorType type, TF1 *func)Definition HFitInterface.cxx:576; ROOT::Fit::GetDataTypeBinData::ErrorType GetDataType(const TGraph *gr, DataOptions &fitOpt)Definition HFitInterface.cxx:476; ROOT::Fit::GetConfidenceIntervalsbool GetConfidenceIntervals(const TH1 *h1, const ROOT::Fit::FitResult &r, TGraphErrors *gr, double cl=0.95)compute confidence intervals at level cl for a fitted histogram h1 in a TGraphErrors grDefinition HFitInterface.cxx:965; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::Fit::DataOptionsDataOptions : simple structure holding the options on how the data are filled.Definition DataOptions.h:28; ROOT::Fit::DataOptions::fErrors1bool fErrors1use all errors equal to 1, i.e. fit without errors (default is false)Definition DataOptions.h:52; ROOT::Fit::DataOptions::fAsymErrorsbool fAsymErrorsuse asymmetric errors in the value when available, selecting them according to the on sign of residua...Definition DataOptions.h:55; ROOT::Fit::DataOptions::fNormBinVolumebool fNormBinVolumenormalize data by a normalized the bin volume (bin volume divided by a reference value)Definition DataOptions.h:49; ROOT::Fit::DataOptions::fIntegralbool fIntegraluse integral of bin content instead of bin center (default is false)Definition DataOptions.h:47; ROOT::Fit::DataOptions::fBinVolumebool fBinVolumenormalize data by the bin volume (it is used in the Poisson likelihood fits)Definition DataOptions.h:48; ROOT::Fit::DataOptions::fCoordErrorsbool fCoordErrorsuse errors on the x coordinates when available (default is true)Def",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/HFitInterface_8cxx_source.html:45469,simpl,simple,45469,doc/master/HFitInterface_8cxx_source.html,https://root.cern,https://root.cern/doc/master/HFitInterface_8cxx_source.html,1,['simpl'],['simple']
Usability,"he full entry per each packet ; TH1D*fNodeHist!histogram of slaves per file serving node; Long64_tfNumEvents!total number of events to be processed; TList*fOutput!Saved pointer to the output list ; TH1D*fPacketsHist!histogram of packets processed per slave; TPerfEvent*fPerfEvent!TPerfEvent used to fill tree; TH2D*fProcTimeHist!histogram of real time spent processing packets; Int_tfSlaves!number of active slaves; Long64_tfTotBytesRead!total bytes read on all slaves; Double_tfTotCpuTime!total cpu time of all slaves; Long64_tfTotEvents!total number of events processed; TTree*fTrace!TTree with trace events; TTimeStampfTzero!start time of this run; static Long_tfgResMemMax! Max resident memory used by this process; static Long_tfgVirtMemMax! Max virtual memory used by this process. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPerfStats(TList* input, TList* output); Normal constructor. ~TPerfStats(); Destructor. void SimpleEvent(TVirtualPerfStats::EEventType type); Simple event. void PacketEvent(const char* slave, const char* slavename, const char* filename, Long64_t eventsprocessed, Double_t latency, Double_t proctime, Double_t cputime, Long64_t bytesRead); Packet event.; See WriteQueryLog for the descripition of the structure sent for monitoring; when fMonitorPerPacket is kTRUE. void FileEvent(const char* slave, const char* slavename, const char* nodename, const char* filename, Bool_t isStart); File event. void FileOpenEvent(TFile* file, const char* filename, Double_t start); Open file event. void FileReadEvent(TFile* file, Int_t len, Double_t start); Read file event. void FileUnzipEvent(TFile* file, Long64_t pos, Double_t start, Int_t complen, Int_t objlen); Record TTree file unzip event.; start is the TimeStamp before unzip; pos is where in the file the compressed buffer came from; complen is the length of the compressed buffer; objlen is the length of the de-compressed buffer. void RateEvent(Double_t proctime, Double_t d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TPerfStats.html:8222,Simpl,SimpleEvent,8222,root/html532/TPerfStats.html,https://root.cern,https://root.cern/root/html532/TPerfStats.html,2,['Simpl'],"['Simple', 'SimpleEvent']"
Usability,"he histogram along x, y or z axis.; For axis = 11, 12 or 13 returns the approximate standard error of skewness; of the histogram along x, y or z axis; Note, that since third and fourth moment are not calculated; at the fill time, skewness and its standard error are computed bin by bin. Double_t GetKurtosis(Int_t axis = 1) const; For axis =1, 2 or 3 returns kurtosis of the histogram along x, y or z axis.; Kurtosis(gaussian(0, 1)) = 0.; For axis =11, 12 or 13 returns the approximate standard error of kurtosis; of the histogram along x, y or z axis; Note, that since third and fourth moment are not calculated; at the fill time, kurtosis and its standard error are computed bin by bin. void GetStats(Double_t* stats) const; fill the array stats from the contents of this histogram; The array stats must be correctly dimensionned in the calling program.; stats[0] = sumw; stats[1] = sumw2; stats[2] = sumwx; stats[3] = sumwx2. If no axis-subrange is specified (via TAxis::SetRange), the array stats; is simply a copy of the statistics quantities computed at filling time.; If a sub-range is specified, the function recomputes these quantities; from the bin contents in the current axis range. Note that the mean value/RMS is computed using the bins in the currently; defined range (see TAxis::SetRange). By default the range includes; all bins from 1 to nbins included, excluding underflows and overflows.; To force the underflows and overflows in the computation, one must; call the static function TH1::StatOverflows(kTRUE) before filling; the histogram. void PutStats(Double_t* stats); Replace current statistics with the values in array stats. void ResetStats(); Reset the statistics including the number of entries; and replace with values calculates from bin content; The number of entries is set to the total bin content or (in case of weighted histogram); to number of effective entries. Double_t GetSumOfWeights() const; -*-*-*-*-*-*Return the sum of weights excluding under/overflows*-*-*-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:104796,simpl,simply,104796,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,2,['simpl'],['simply']
Usability,"he hot key is an underlined character in a button label that shows the assigned keyboard mnemonic for its choice. A button that prompts more information for users has the label generally followed by ellipsis (…). As we saw the hot strings “&Draw” and “&Exit” define the text labels “Draw” and “Exit” and keyboard mnemonics Alt+D, Alt+E for their selection. The letter D and E appear underlined on the screen. All text buttons should have a unique shortcut key with the exception of OK and Cancel.; These buttons are usually placed within a window to provide fast access to frequently used or critical commands. They help in situations where a command is not available through the menu bar. You already know that a command string can be passed in the text button via the constructor:; TGTextButton(const TGWindow *p, const char *s, const char *cmd,; Int_t id, GContext_t norm, FontStruct_t font,; UInt_t options);; A button label can be changed by SetText(new_label). There are important guidelines to be followed about a button label. The text has to provide a meaningful description of the performed action. The single-word label should be used whenever possible, only two-three words for clarity, if necessary. Do not number labels. Always follow all platform presentation and usage guidelines for standard button functions. Let’s remember a few standard names and definitions of well known buttons:; OK - any changed information in a window is accepted and the window is closed;; Cancel - closes window without implementing submitted changes;; Reset- resets defaults and cancels any changed information that has not be submitted;; Apply - any changed information is accepted and again displayed in the window that remains open;; Close - closes the window;; Help - opens online Help.; Below are examples of text buttons. Note the two placement methods. The first example should be used when there are one to three command buttons; the second one when there are more than three buttons. Picture butt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1178102,guid,guidelines,1178102,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['guid'],['guidelines']
Usability,"he map; This function is called by TObject::Streamer or TStreamerInfo::WriteBuffer. Int_t AddInternalIdxForPID(TProcessID* procid); Add the internal index for fProcessIDs, fAllocSize, etc given a PID. void Clear(Option_t* = """"); Clear all entries in the table. Int_t Expand(Int_t pid, Int_t newsize); Expand fParentIDs to newsize for ProcessID pid. Int_t ExpandForIID(Int_t iid, Int_t newsize); Expand fParentIDs to newsize for internel ProcessID index iid. void ExpandPIDs(Int_t numpids); Expand the arrays of managed PIDs. void FillBuffer(TBuffer& b); Fill buffer b with the fN elements in fParentdIDs.; This function is called by TBranchRef::FillLeaves. Int_t FindPIDGUID(const char* guid) const; Get fProcessGUIDs' index of the TProcessID with GUID guid. TObject * GetParent(Int_t uid, TProcessID* context = 0) const; Return object corresponding to uid. Int_t GetInternalIdxForPID(TProcessID* procid) const; Get the index for fProcessIDs, fAllocSize, etc given a PID.; Uses fMapPIDtoInternal and the pid's GUID / fProcessGUID. Int_t GetInternalIdxForPID(Int_t pid) const; Get the index for fProcessIDs, fAllocSize, etc given a PID.; Uses fMapPIDtoInternal and the pid's GUID / fProcessGUID. TRefTable * GetRefTable(); Static function returning the current TRefTable. Bool_t Notify(); This function is called by TRef::Streamer or TStreamerInfo::ReadBuffer; when reading a reference.; This function, in turns, notifies the TRefTable owner for action.; eg, when the owner is a TBranchRef, TBranchRef::Notify is called; to read the branch containing the referenced object. void ReadBuffer(TBuffer& b); Fill buffer b with the fN elements in fParentdIDs.; This function is called by TBranchRef::ReadLeaves. void Reset(Option_t* = """"); Clear all entries in the table. Int_t SetParent(const TObject* parent, Int_t branchID); -- Set current parent object, typically a branch of a tree. This function is called by TBranchElement::Fill() and by; TBranchElement::GetEntry(). void SetRefTable(TRefTable* table)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TRefTable.html:9563,GUID,GUID,9563,root/html532/TRefTable.html,https://root.cern,https://root.cern/root/html532/TRefTable.html,4,['GUID'],['GUID']
Usability,"he misses; When this mode is enabled, the memory dedicated to the cache can increase by at most a factor two in the case of cache miss. Additionally, on the first miss of an event, we must iterate through all the ""active branches"" for the miss cache and find the correct basket. This can be potentially a CPU-expensive operation compared to, e.g., the latency of a SSD. This is why the miss cache is currently disabled by default. Example usages of TTreeCache; A few use cases are discussed below. A cache may be created with automatic sizing when a TTree is used:; In some applications, e.g. central processing workflows of experiments, the list of branches to read is known a priori. For these cases, the TTreeCache can be instructed about the branches which will be read via explicit calls to the TTree or TTreeCache interfaces. In less streamlined applications such as analysis, predicting the branches which will be read can be difficult. In such cases, ROOT I/O flags used branches automatically when a branch buffer is read during the learning phase.; In the examples below, portions of analysis code are shown. The few statements involving the TreeCache are marked with //<<<. ROOT::RDataFrame and TTreeReader Examples; If you use RDataFrame or TTreeReader, the system will automatically cache the best set of branches: no action is required by the user. TTree::Draw Example; The TreeCache is automatically used by TTree::Draw. The method knows which branches are used in the query and it puts automatically these branches in the cache. The entry range is also inferred automatically. TTree::Process and TSelectors Examples; The user must enable the cache and tell the system which branches to cache and also specify the entry range. It is important to specify the entry range in case only a subset of the events is processed to avoid wasteful caching.; Reading all branches; TTree *T;; f->GetObject(T, ""mytree"");; auto nentries = T->GetEntries();; auto cachesize = 10000000U; // 10 MBytes; T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:6097,learn,learning,6097,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,['learn'],['learning']
Usability,"he next are some rules to remember:. name = * means all, but don’t remove the subdirectories; cycle =* means all cycles (memory and file); cycle ="""" means apply to a memory object; cycle = 9999 also means apply to a memory object; namecycle = """" means the same as namecycle =“T*”; namecycle = T* delete subdirectories. For example to delete a directory from a file, you must specify the directory cycle:; root[] f->Delete(""Wed011003;1""); Some other examples of namecycle format are:. foo:delete the object named foo from memory; foo;1: delete the cycle 1 of the object named foo from the file; foo;*: delete all cycles of foo from the file and also from memory; *;2: delete all objects with cycle number 2 from the file; *;*: delete all objects from memory and from the file; T*;*: delete all objects from memory and from the file including all subdirectories. 11.3 Streamers; To follow the discussion on Streamers, you need to know what a simple data type is. A variable is of a simple data type if it cannot be decomposed into other types. Examples of simple data types are longs, shorts, floats, and chars. In contrast, a variable is of a composite data type if it can be decomposed. For example, classes, structures, and arrays are composite types. Simple types are also called primitive types, basic types, and Cling sometimes calls them fundamental types.; When we say, “writing an object to a file”, we actually mean writing the current values of the data members. The most common way to do this is to decompose (also called the serialization of) the object into its data members and write them to disk. The decomposition is the job of the Streamer. Every class with ambitions to be stored in a file has a Streamerthat decomposes it and “streams” its members into a buffer.; The methods of the class are not written to the file, it contains only the persistent data members. To decompose the parent classes, the Streamercalls the Streamerof the parent classes. It moves up the inheritance tree ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:465569,simpl,simple,465569,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"he nominal_hx; 1013ROOT::RDF::Experimental::RResultMap<TH1D> hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);; 1014 ; 1015// the event loop runs here, upon first access to any of the results or varied results:; 1016hx[""nominal""].Draw(); // same effect as nominal_hx->Draw(); 1017hx[""pt:down""].Draw(""SAME"");; 1018hx[""pt:up""].Draw(""SAME"");; 1019~~~; 1020 ; 1021A list of variation ""tags"" is passed as the last argument to Vary(). The tags give names to the varied values that are returned; 1022as elements of an RVec of the appropriate C++ type. The number of variation tags must correspond to the number of elements of; 1023this RVec (2 in the example above: the first element will correspond to the tag ""down"", the second; 1024to the tag ""up""). The _full_ variation name will be composed of the varied column name and the variation tags (e.g.; 1025""pt:down"", ""pt:up"" in this example). Python usage looks similar.; 1026 ; 1027Note how we use the ""pt"" column as usual in the Filter() and Define() calls and we simply use ""x"" as the value to fill; 1028the resulting histogram. To produce the varied results, RDataFrame will automatically execute the Filter and Define; 1029calls for each variation and fill the histogram with values and cuts that depend on the variation.; 1030 ; 1031There is no limitation to the complexity of a Vary() expression. Just like for the Define() and Filter() calls, users are; 1032not limited to string expressions but they can also pass any valid C++ callable, including lambda functions and; 1033complex functors. The callable can be applied to zero or more existing columns and it will always receive their; 1034_nominal_ value in input.; 1035 ; 1036#### Varying multiple columns in lockstep; 1037 ; 1038In the following Python snippet we use the Vary() signature that allows varying multiple columns simultaneously or; 1039""in lockstep"":; 1040 ; 1041~~~{.python}; 1042df.Vary([""pt"", ""eta""],; 1043 ""RVec<RVecF>{{pt*0.9, pt*1.1}, {eta*0.9, eta*1.1}}"",; 1044 variat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:60509,simpl,simply,60509,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['simpl'],['simply']
Usability,"he nominal_hx; 1053ROOT::RDF::Experimental::RResultMap<TH1D> hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);; 1054 ; 1055// the event loop runs here, upon first access to any of the results or varied results:; 1056hx[""nominal""].Draw(); // same effect as nominal_hx->Draw(); 1057hx[""pt:down""].Draw(""SAME"");; 1058hx[""pt:up""].Draw(""SAME"");; 1059~~~; 1060 ; 1061A list of variation ""tags"" is passed as the last argument to Vary(). The tags give names to the varied values that are returned; 1062as elements of an RVec of the appropriate C++ type. The number of variation tags must correspond to the number of elements of; 1063this RVec (2 in the example above: the first element will correspond to the tag ""down"", the second; 1064to the tag ""up""). The _full_ variation name will be composed of the varied column name and the variation tags (e.g.; 1065""pt:down"", ""pt:up"" in this example). Python usage looks similar.; 1066 ; 1067Note how we use the ""pt"" column as usual in the Filter() and Define() calls and we simply use ""x"" as the value to fill; 1068the resulting histogram. To produce the varied results, RDataFrame will automatically execute the Filter and Define; 1069calls for each variation and fill the histogram with values and cuts that depend on the variation.; 1070 ; 1071There is no limitation to the complexity of a Vary() expression. Just like for the Define() and Filter() calls, users are; 1072not limited to string expressions but they can also pass any valid C++ callable, including lambda functions and; 1073complex functors. The callable can be applied to zero or more existing columns and it will always receive their; 1074_nominal_ value in input.; 1075 ; 1076#### Varying multiple columns in lockstep; 1077 ; 1078In the following Python snippet we use the Vary() signature that allows varying multiple columns simultaneously or; 1079""in lockstep"":; 1080 ; 1081~~~{.python}; 1082df.Vary([""pt"", ""eta""],; 1083 ""RVec<RVecF>{{pt*0.9, pt*1.1}, {eta*0.9, eta*1.1}}"",; 1084 variat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:62189,simpl,simply,62189,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['simpl'],['simply']
Usability,"he number of neurons. The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be normalized. The output can be followed by '!' to use Softmax neurons for the output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument. training and test are two cuts (see TTreeFormula) defining events to be used during the neural net training and testing.; Example: ""Entry$%2"", ""(Entry$+1)%2"".; Both the TTree and the cut can be defined in the constructor, or later with the suited setter method. ; Definition at line 524 of file TMultiLayerPerceptron.cxx. ◆ TMultiLayerPerceptron() [4/6]. TMultiLayerPerceptron::TMultiLayerPerceptron ; (; const char * ; layout, . TTree * ; data, . TEventList * ; training, . TEventList * ; test, . TNeuron::ENeuronType ; type = TNeuron::kSigmoid, . const char * ; extF = """", . const char * ; extD = """" . ). The network is described by a simple string: The input/output layers are defined by giving the branch names separated by comas. ; Hidden layers are just described by the number of neurons. The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be normalized. The output can be followed by '!' to use Softmax neurons for the output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument. training and test are the two TEventLists defining events to be used during the neural net training. Both the TTree and the TEventLists can be defined in the constructor, or later with the suited setter method. ; Definition at line 318 of file TMultiLayerPerceptron.cxx. ◆ TMultiLayerPerceptron() [5/6]. TMultiLayerPerceptron::TMultiLayerPerceptron ; (; const char * ; layout, . const char * ; weight, . TTree * ; data, . TEventList * ; training, . TEventList * ; test, . TNeuron::ENeuronType ; type = TNeuron::kSigmoid, . const char * ; extF = """", . const char * ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiLayerPerceptron.html:31610,simpl,simple,31610,doc/master/classTMultiLayerPerceptron.html,https://root.cern,https://root.cern/doc/master/classTMultiLayerPerceptron.html,1,['simpl'],['simple']
Usability,"he number of sunctions set in the class.; The number must be equal to the dimension of the functions. { return fFunctions.size(); }. void Clear(); clear list of functions. const double * X() const; return the root X values solving the system. const double * FVal() const; return the function values f(X) solving the system; i.e. they must be close to zero at the solution. const double * Dx() const; return the last step size. bool Solve(const double* x, int maxIter = 0, double absTol = 0, double relTol = 0). Find the root starting from the point X;; Use the number of iteration and tolerance if given otherwise use; default parameter values which can be defined by; the static method SetDefault... int Iterations() const; Return number of iterations. int Status() const; Return the status of last root finding. { return fStatus; }. const char * Name() const; Return the algorithm name. void SetPrintLevel(int level). set print level; level = 0 quiet (no messages print); = 1 print only the result; = 3 max debug. Print result at each iteration. { fPrintLevel = level; }. int PrintLevel() const; return the print level. { return fPrintLevel; }. void SetDefaultTolerance(double abstol, double reltol = 0); -- static methods to set configurations; set tolerance (absolute and relative); relative tolerance is only use to verify the convergence; do it is a minor parameter. void SetDefaultMaxIterations(int maxiter); set maximum number of iterations. void PrintState(ostream& os = std::cout); print iteration state. std::pair<bool,int> GetType(const char* name); return type given a name. void ClearFunctions(); clear list of functions. » Author: L. Moneta 03/2011 » Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: GSLMultiRootFinder.h 38726 2011-04-04 14:05:51Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__GSLMultiRootFinder.html:7347,clear,clear,7347,root/html530/ROOT__Math__GSLMultiRootFinder.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLMultiRootFinder.html,1,['clear'],['clear']
Usability,"he number of sunctions set in the class.; The number must be equal to the dimension of the functions. { return fFunctions.size(); }. void Clear(); clear list of functions. const double * X() const; return the root X values solving the system. const double * FVal() const; return the function values f(X) solving the system; i.e. they must be close to zero at the solution. const double * Dx() const; return the last step size. bool Solve(const double* x, int maxIter = 0, double absTol = 0, double relTol = 0). Find the root starting from the point X;; Use the number of iteration and tolerance if given otherwise use; default parameter values which can be defined by; the static method SetDefault... int Iterations() const; Return number of iterations. int Status() const; Return the status of last root finding. { return fStatus; }. const char * Name() const; Return the algorithm name. void SetPrintLevel(int level). set print level; level = 0 quiet (no messages print); = 1 print only the result; = 3 max debug. Print result at each iteration. { fPrintLevel = level; }. int PrintLevel() const; return the print level. { return fPrintLevel; }. void SetDefaultTolerance(double abstol, double reltol = 0); -- static methods to set configurations; set tolerance (absolute and relative); relative tolerance is only use to verify the convergence; do it is a minor parameter. void SetDefaultMaxIterations(int maxiter); set maximum number of iterations. void PrintState(ostream& os = std::cout); print iteration state. std::pair<bool,int> GetType(const char* name); return type given a name. void ClearFunctions(); clear list of functions. » Author: L. Moneta 03/2011 » Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: GSLMultiRootFinder.h 38726 2011-04-04 14:05:51Z moneta $ » Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__GSLMultiRootFinder.html:7347,clear,clear,7347,root/html532/ROOT__Math__GSLMultiRootFinder.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLMultiRootFinder.html,3,"['Clear', 'clear']","['ClearFunctions', 'clear']"
Usability,"he number of times deny-destroy has been requested on the element. ;  ; Bool_t GetDestroyOnZeroRefCnt () const;  Returns state of flag determining if the element will be destroyed when reference count reaches zero. ;  ; virtual TObject * GetEditorObject (const TEveException &eh) const;  ; virtual TString GetHighlightTooltip ();  ; virtual const TGPicture * GetListTreeCheckBoxIcon ();  Returns list-tree-item check-box picture appropriate for given rendering state. ;  ; virtual Color_t GetMainColor () const;  ; Color_t * GetMainColorPtr () const;  ; virtual Char_t GetMainTransparency () const;  ; TEveElement * GetMaster ();  Returns the master element - that is: ;  ; virtual Int_t GetNItems () const;  ; Int_t GetParentIgnoreCnt () const;  Get number of parents that should be ignored in doing reference-counting. ;  ; virtual TObject * GetRenderObject (const TEveException &eh) const;  ; virtual Bool_t GetRnrAnything () const;  ; virtual Bool_t GetRnrChildren () const;  ; virtual Bool_t GetRnrSelf () const;  ; virtual Bool_t GetRnrState () const;  ; virtual UChar_t GetSelectedLevel () const;  Get selection level, needed for rendering selection and highlight feedback. ;  ; TRef & GetSource ();  ; TObject * GetSourceObject () const;  ; void * GetUserData () const;  ; TEveElement * GetVizModel () const;  ; const TString & GetVizTag () const;  ; virtual Bool_t HandleElementPaste (TEveElement *el);  React to element being pasted or dnd-ed. ;  ; Bool_t HasChild (TEveElement *el);  Check if element el is a child of this element. ;  ; Bool_t HasChildren () const;  ; virtual Bool_t HasMainColor () const;  ; virtual Bool_t HasMainTrans () const;  ; Bool_t HasParents () const;  ; virtual void HighlightElement (Bool_t state);  Set element's highlight state. Stamp appropriately. ;  ; void IncDenyDestroy ();  Increases the deny-destroy count of the element. ;  ; virtual void IncImpliedHighlighted ();  Increase element's implied-highlight count. Stamp appropriately. ;  ; virtual void I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveLine.html:13273,feedback,feedback,13273,doc/master/classTEveLine.html,https://root.cern,https://root.cern/doc/master/classTEveLine.html,7,['feedback'],['feedback']
Usability,"he remote player. Returns kFALSE. Bool_t CheckMemUsage(Long64_t& mfreq, Bool_t& w80r, Bool_t& w80v, TString& wmsg); Check the memory usage, if requested.; Return kTRUE if OK, kFALSE if above 95% of at least one between virtual or; resident limits are depassed. Long64_t Finalize(Bool_t force = kFALSE, Bool_t sync = kFALSE); Finalize query (may not be used in this class). Long64_t Finalize(TQueryResult* qr); Finalize query (may not be used in this class). void MergeOutput(Bool_t savememvalues = kFALSE); Merge output (may not be used in this class). void MapOutputListToDataMembers() const. void UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); Update automatic binning parameters for given object ""name"". TDSetElement * GetNextPacket(TSlave* slave, TMessage* r); Get next packet (may not be used in this class). void SetupFeedback(); Set up feedback (may not be used in this class). void StopFeedback(); Stop feedback (may not be used in this class). Long64_t DrawSelect(TDSet* set, const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Draw (may not be used in this class). void HandleGetTreeHeader(TMessage* mess); Handle tree header request. void HandleRecvHisto(TMessage* mess); Receive histo from slave. Int_t DrawCanvas(TObject* obj); Draw the object if it is a canvas.; Return 0 in case of success, 1 if it is not a canvas or libProofDraw; is not available. Int_t GetDrawArgs(const char* var, const char* sel, Option_t* opt, TString& selector, TString& objname); Parse the arguments from var, sel and opt and fill the selector and; object name accordingly.; Return 0 in case of success, 1 if libProofDraw is not available. void FeedBackCanvas(const char* name, Bool_t create); Create/destroy a named canvas for feedback. Long64_t GetCacheSize(); Return the size in bytes of the cache. Int_t GetLearnEntries(); Return the number of entries in the l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofPlayer.html:20973,feedback,feedback,20973,root/html534/TProofPlayer.html,https://root.cern,https://root.cern/root/html534/TProofPlayer.html,4,['feedback'],['feedback']
Usability,"he screen. The global visible level put a limitation on the maximum applied depth. Combined with visibility settings per volume, these can tune quite well what should appear on the screen. However, there are situations when users want to see a volume branch displayed down to the maximum depth, keeping at the same time a limitation or even suppressing others. In order to accomplish that, one should use the volume attribute: ""Visible daughters"". By default, all daughters of all volumes are displayed if there is no limitation related with their level depth with respect to the top drawn volume. Ray Tracing; Ray tracing is a quite known drawing technique based on tracking rays from the eye position through all pixels of a view port device. The pixel color is derived from the properties of the first crossed surface, according some illumination model and material optical properties. While there are currently existing quite sophisticated ray tracing models, TGeo is currently using a very simple approach where the light source is matching the eye position (no shadows or back-tracing of the reflected ray). In future we are considering providing a base class in order to be able to derive more complex models.; Due to the fact that the number of rays that have to be tracked matches the size in pixels of the pad, the time required by this algorithm is proportional to the pad size. On the other hand, the speed is quite acceptable for the default ROOT pad size and the images produced by using this technique have high quality. Since the algorithm is practically using all navigation features, producing ray-traced pictures is also a geometry validation check. Ray tracing can be activated at volume level as the normal Draw(). Ray-traced view in a pad; myVolume->Raytrace(); Once ray-tracing a view, this can be zoomed or rotated as a usual one. Objects on the screen are no longer highlighted when picking the vertices but the corresponding volumes is still accessible.; Clipping Ray-traced ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:112599,simpl,simple,112599,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['simpl'],['simple']
Usability,"he sink in a RPageSinkBuf.; 83 static std::unique_ptr<RNTupleWriter> Create(std::unique_ptr<RNTupleModel> model,; 84 std::unique_ptr<Internal::RPageSink> sink,; 85 const RNTupleWriteOptions &options);; 86 ; 87public:; 88 /// Throws an exception if the model is null.; 89 static std::unique_ptr<RNTupleWriter> Recreate(std::unique_ptr<RNTupleModel> model, std::string_view ntupleName,; 90 std::string_view storage,; 91 const RNTupleWriteOptions &options = RNTupleWriteOptions());; 92 static std::unique_ptr<RNTupleWriter>; 93 Recreate(std::initializer_list<std::pair<std::string_view, std::string_view>> fields, std::string_view ntupleName,; 94 std::string_view storage, const RNTupleWriteOptions &options = RNTupleWriteOptions());; 95 /// Throws an exception if the model is null.; 96 static std::unique_ptr<RNTupleWriter> Append(std::unique_ptr<RNTupleModel> model, std::string_view ntupleName,; 97 TFile &file,; 98 const RNTupleWriteOptions &options = RNTupleWriteOptions());; 99 RNTupleWriter(const RNTupleWriter &) = delete;; 100 RNTupleWriter &operator=(const RNTupleWriter &) = delete;; 101 ~RNTupleWriter();; 102 ; 103 /// The simplest user interface if the default entry that comes with the ntuple model is used.; 104 /// \return The number of uncompressed bytes written.; 105 std::size_t Fill() { return fFillContext.Fill(fFillContext.fModel->GetDefaultEntry()); }; 106 /// Multiple entries can have been instantiated from the ntuple model. This method will perform; 107 /// a light check whether the entry comes from the ntuple's own model.; 108 /// \return The number of uncompressed bytes written.; 109 std::size_t Fill(REntry &entry) { return fFillContext.Fill(entry); }; 110 /// Fill an entry into this ntuple, but don't commit the cluster. The calling code must pass an RNTupleFillStatus; 111 /// and check RNTupleFillStatus::ShouldFlushCluster.; 112 void FillNoFlush(REntry &entry, RNTupleFillStatus &status) { fFillContext.FillNoFlush(entry, status); }; 113 /// Flush column data, pr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RNTupleWriter_8hxx_source.html:4603,simpl,simplest,4603,doc/master/RNTupleWriter_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RNTupleWriter_8hxx_source.html,1,['simpl'],['simplest']
Usability,"he subdirectories; cycle =* means all cycles (memory and file); cycle ="""" means apply to a memory object; cycle = 9999 also means apply to a memory object; namecycle = """" means the same as namecycle =“T*”; namecycle = T* delete subdirectories. For example to delete a directory from a file, you must specify the directory cycle:; root[] f->Delete(""Wed011003;1""); Some other examples of namecycle format are:. foo:delete the object named foo from memory; foo;1: delete the cycle 1 of the object named foo from the file; foo;*: delete all cycles of foo from the file and also from memory; *;2: delete all objects with cycle number 2 from the file; *;*: delete all objects from memory and from the file; T*;*: delete all objects from memory and from the file including all subdirectories. 11.3 Streamers; To follow the discussion on Streamers, you need to know what a simple data type is. A variable is of a simple data type if it cannot be decomposed into other types. Examples of simple data types are longs, shorts, floats, and chars. In contrast, a variable is of a composite data type if it can be decomposed. For example, classes, structures, and arrays are composite types. Simple types are also called primitive types, basic types, and Cling sometimes calls them fundamental types.; When we say, “writing an object to a file”, we actually mean writing the current values of the data members. The most common way to do this is to decompose (also called the serialization of) the object into its data members and write them to disk. The decomposition is the job of the Streamer. Every class with ambitions to be stored in a file has a Streamerthat decomposes it and “streams” its members into a buffer.; The methods of the class are not written to the file, it contains only the persistent data members. To decompose the parent classes, the Streamercalls the Streamerof the parent classes. It moves up the inheritance tree until it reaches an ancestor without a parent. To serialize the object dat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:465643,simpl,simple,465643,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"he time offset is the one that will be used by all graphs.; // If one changes it, it will be changed even on the graphs already defined; gStyle->SetTimeOffset(script_time);; ; auto ct = new TCanvas(""ct"",""Time on axis"",10,10,700,900);; ct->Divide(1,3);; ; int i;; ; //### Build a signal: noisy damped sine; // Time interval: 30 minutes; ; gStyle->SetTitleH(0.08);; float noise;; auto ht = new TH1F(""ht"",""Love at first sight"",3000,0.,2000.);; for (i=1;i<3000;i++) {; noise = gRandom->Gaus(0,120);; if (i>700) {; noise += 1000*sin((i-700)*6.28/30)*exp((double)(700-i)/300);; }; ht->SetBinContent(i,noise);; }; ct->cd(1);; ht->SetLineColor(2);; ht->GetXaxis()->SetLabelSize(0.05);; ht->Draw();; // Sets time on the X axis; // The time used is the one set as time offset added to the value; // of the axis. This is converted into day/month/year hour:min:sec and; // a reasonable tick interval value is chosen.; ht->GetXaxis()->SetTimeDisplay(1);; ; //### Build a simple graph beginning at a different time; // Time interval: 5 seconds; ; float x[100], t[100];; for (i=0;i<100;i++) {; x[i] = sin(i*4*3.1415926/50)*exp(-(double)i/20);; t[i] = 6000+(double)i/20;; }; auto gt = new TGraph(100,t,x);; gt->SetTitle(""Politics"");; ct->cd(2);; gt->SetLineColor(5);; gt->SetLineWidth(2);; gt->Draw(""AL"");; gt->GetXaxis()->SetLabelSize(0.05);; // Sets time on the X axis; gt->GetXaxis()->SetTimeDisplay(1);; gPad->Modified();; ; //### Build a second simple graph for a very long time interval; // Time interval: a few years; ; auto gt2 = new TGraph();; TDatime dateBegin(2000,1,1,0,0,0);; for (i=0;i<10;i++) {; TDatime datePnt(2000 + i,1,1,0,0,0);; gt2->AddPoint(datePnt.Convert() - dateBegin.Convert(), 100 + gRandom->Gaus(500,100)*i);; }; gt2->SetTitle(""Number of monkeys on the moon"");; ct->cd(3);; gt2->SetMarkerColor(4);; gt2->SetMarkerStyle(29);; gt2->SetMarkerSize(1.3);; gt2->Draw(""AP"");; gt2->GetXaxis()->SetLabelSize(0.04);; gt2->GetXaxis()->SetNdivisions(10);; // Sets time on the X axis; gt2->GetXaxis()-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/timeonaxis_8C.html:2014,simpl,simple,2014,doc/master/timeonaxis_8C.html,https://root.cern,https://root.cern/doc/master/timeonaxis_8C.html,2,['simpl'],['simple']
Usability,"he titles of the internal histograms are set to ""title + (total)""; or ""title + (passed)"" respectively.; - It is possible to label the axis of the histograms as usual (see; TH1::SetTitle). Example: Setting the title to ""My Efficiency"" and label the axis. pEff->SetTitle(""My Efficiency;x label;eff"");. Bool_t SetTotalEvents(Int_t bin, Int_t events); sets the number of total events in the given global bin. returns ""true"" if the number of total events has been updated; otherwise ""false"" ist returned. Note: - requires: fPassedHistogram->GetBinContent(bin) <= events. Bool_t SetTotalHistogram(const TH1& rTotal, Option_t* opt); sets the histogram containing all events. The given histogram is cloned and stored internally as histogram containing; all events. The given histogram has to be consistent with the current; fPassedHistogram (see CheckConsistency(const TH1&,const TH1&)).; The method returns whether the fTotalHistogram has been replaced (true) or; not (false). Note: The list of associated functions fFunctions is cleared. Option: - ""f"": force the replacement without checking the consistency; This can lead to inconsistent histograms and useless results; or unexpected behaviour. But sometimes it might be the only; way to change the histograms. If you use this option, you; should ensure that the fPassedHistogram is replaced by a; consistent one (with respect to rTotal) as well. void SetUseWeightedEvents(). void SetWeight(Double_t weight); sets the global weight for this TEfficiency object. Note: - weight has to be positive ( > 0). Double_t Wilson(Int_t total, Int_t passed, Double_t level, Bool_t bUpper); calculates the boundaries for the frequentist Wilson interval. Input: - total : number of total events; - passed: 0 <= number of passed events <= total; - level : confidence level; - bUpper: true - upper boundary is returned; false - lower boundary is returned. calculation:. void Add(const TEfficiency& rEff). {*this += rEff;}. Double_t GetBetaAlpha(Int_t bin = -1) const; use",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEfficiency.html:65601,clear,cleared,65601,root/html532/TEfficiency.html,https://root.cern,https://root.cern/root/html532/TEfficiency.html,2,['clear'],['cleared']
Usability,"he titles of the internal histograms are set to ""title + (total)""; or ""title + (passed)"" respectively.; - It is possible to label the axis of the histograms as usual (see; TH1::SetTitle). Example: Setting the title to ""My Efficiency"" and label the axis. pEff->SetTitle(""My Efficiency;x label;eff"");. Bool_t SetTotalEvents(Int_t bin, Int_t events); sets the number of total events in the given global bin. returns ""true"" if the number of total events has been updated; otherwise ""false"" ist returned. Note: - requires: fPassedHistogram->GetBinContent(bin) <= events. Bool_t SetTotalHistogram(const TH1& rTotal, Option_t* opt); sets the histogram containing all events. The given histogram is cloned and stored internally as histogram containing; all events. The given histogram has to be consistent with the current; fPassedHistogram (see CheckConsistency(const TH1&,const TH1&)).; The method returns whether the fTotalHistogram has been replaced (true) or; not (false). Note: The list of associated functions fFunctions is cleared. Option: - ""f"": force the replacement without checking the consistency; This can lead to inconsistent histograms and useless results; or unexpected behaviour. But sometimes it might be the only; way to change the histograms. If you use this option, you; should ensure that the fPassedHistogram is replaced by a; consistent one (with respect to rTotal) as well. void SetUseWeightedEvents(). void SetWeight(Double_t weight); sets the global weight for this TEfficiency object. Note: - weight has to be positive ( > 0). Double_t Wilson(Int_t total, Int_t passed, Double_t level, Bool_t bUpper); calculates the boundaries for the frequentist Wilson interval. Input: - total : number of total events; - passed: 0 <= number of passed events <= total; - level : confidence level; - bUpper: true - upper boundary is returned; false - lower boundary is returned. calculation:. void Add(const TEfficiency& rEff); {*this += rEff;}. Double_t GetBetaAlpha(Int_t bin = -1) const; use",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEfficiency.html:69482,clear,cleared,69482,root/html534/TEfficiency.html,https://root.cern,https://root.cern/root/html534/TEfficiency.html,4,['clear'],['cleared']
Usability,"he titles of the internal histograms are set to ""title + (total)""; or ""title + (passed)"" respectively.; - It is possible to label the axis of the histograms as usual (see; TH1::SetTitle). Example: Setting the title to ""My Efficiency"" and label the axis. pEff->SetTitle(""My Efficiency;x label;eff"");. Bool_t SetTotalEvents(Int_t bin, Int_t events); sets the number of total events in the given global bin. returns ""true"" if the number of total events has been updated; otherwise ""false"" ist returned. Note: - requires: fPassedHistogram->GetBinContent(bin) <= events. Bool_t SetTotalHistogram(const TH1& rTotal, Option_t* opt); sets the histogram containing all events. The given histogram is cloned and stored internally as histogram containing; all events. The given histogram has to be consistent with the current; fPassedHistogram (see CheckConsistency(const TH1&,const TH1&)).; The method returns whether the fTotalHistogram has been replaced (true) or; not (false). Note: The list of associated functions fFunctions is cleared. Option: - ""f"": force the replacement without checking the consistency; This can lead to inconsistent histograms and useless results; or unexpected behaviour. But sometimes it might be the only; way to change the histograms. If you use this option, you; should ensure that the fPassedHistogram is replaced by a; consistent one (with respect to rTotal) as well. void SetUseWeightedEvents(). void SetWeight(Double_t weight); sets the global weight for this TEfficiency object. Note: - weight has to be positive ( > 0). Double_t Wilson(Int_t total, Int_t passed, Double_t level, Bool_t bUpper); calculates the boundaries for the frequentist Wilson interval. Input: - total : number of total events; - passed: 0 <= number of passed events <= total; - level : confidence level; - bUpper: true - upper boundary is returned; false - lower boundary is returned. calculation:. void Add(const TEfficiency& rEff); {*this += rEff;}. void Browse(TBrowser* ); {Draw();}. Double_t Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TEfficiency.html:70472,clear,cleared,70472,root/html604/TEfficiency.html,https://root.cern,https://root.cern/root/html604/TEfficiency.html,2,['clear'],['cleared']
Usability,"he titles of the internal histograms are set to ""title + (total)""; or ""title + (passed)"" respectively.; - It is possible to label the axis of the histograms as usual (see; TH1::SetTitle). Example: Setting the title to ""My Efficiency"" and label the axis. pEff->SetTitle(""My Efficiency;x label;eff"");. Bool_t SetTotalEvents(Int_t bin, Int_t events); sets the number of total events in the given global bin. returns ""true"" if the number of total events has been updated; otherwise ""false"" ist returned. Note: - requires: fPassedHistogram->GetBinContent(bin) <= events. Bool_t SetTotalHistogram(const TH1& rTotal, Option_t* opt); sets the histogram containing all events. The given histogram is cloned and stored internally as histogram containing; all events. The given histogram has to be consistent with the current; fPassedHistogram (see CheckConsistency(const TH1&,const TH1&)).; The method returns whether the fTotalHistogram has been replaced (true) or; not (false). Note: The list of associated functions fFunctions is cleared. Option: - ""f"": force the replacement without checking the consistency; This can lead to inconsistent histograms and useless results; or unexpected behaviour. But sometimes it might be the only; way to change the histograms. If you use this option, you; should ensure that the fPassedHistogram is replaced by a; consistent one (with respect to rTotal) as well. void SetWeight(Double_t weight); sets the global weight for this TEfficiency object. Note: - weight has to be positive ( > 0). Double_t Wilson(Int_t total, Int_t passed, Double_t level, Bool_t bUpper); calculates the boundaries for the frequentist Wilson interval. Input: - total : number of total events; - passed: 0 <= number of passed events <= total; - level : confidence level; - bUpper: true - upper boundary is returned; false - lower boundary is returned. calculation:. void Add(const TEfficiency& rEff). {*this += rEff;}. Double_t GetBetaAlpha(Int_t bin = -1) const; use trick of -1 to return global",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEfficiency.html:63189,clear,cleared,63189,root/html528/TEfficiency.html,https://root.cern,https://root.cern/root/html528/TEfficiency.html,2,['clear'],['cleared']
Usability,"he tree to find the node matching ""event"". TMVA::BinarySearchTreeNode* Search(TMVA::Event* , TMVA::Node* ) const; Private, recursive, function for searching. Double_t GetSumOfWeights(Int_t theType) const; return the sum of event (node) weights. Double_t GetSumOfWeights(Int_t theType) const; return the sum of event (node) weights. Double_t Fill(const vector<TMVA::Event*>& events, const vector<Int_t>& theVars, Int_t theType = -1); create the search tree from the event collection; using ONLY the variables specified in ""theVars"". Double_t Fill(const vector<TMVA::Event*>& events, Int_t theType = -1); create the search tree from the events in a TTree; using ALL the variables specified included in the Event. void NormalizeTree(vector<pair<double,const TMVA::Event*>,allocator<pair<double,const TMVA::Event*> > >::iterator , vector<pair<double,const TMVA::Event*>,allocator<pair<double,const TMVA::Event*> > >::iterator , UInt_t ). void NormalizeTree(); Normalisation of tree. void Clear(TMVA::Node* n = 0); clear nodes. Double_t SearchVolume(TMVA::Volume* , vector<const TMVA::BinarySearchTreeNode*>* events = 0); search the whole tree and add up all weigths of events that; lie within the given voluem. Double_t SearchVolume(TMVA::Node* , TMVA::Volume* , Int_t , vector<const TMVA::BinarySearchTreeNode*>* events); recursively walk through the daughter nodes and add up all weigths of events that; lie within the given volume. Bool_t InVolume(const vector<Float_t>& , TMVA::Volume* ) const; test if the data points are in the given volume. void CalcStatistics(TMVA::Node* n = 0); calculate basic statistics (mean, rms for each variable). Int_t SearchVolumeWithMaxLimit(TMVA::Volume* , vector<const TMVA::BinarySearchTreeNode*>* events = 0, Int_t = -1); recursively walk through the daughter nodes and add up all weigths of events that; lie within the given volume a maximum number of events can be given. Node * CreateNode(UInt_t ) const; { return new BinarySearchTreeNode(); }. BinaryTree* Creat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__BinarySearchTree.html:6515,clear,clear,6515,root/html528/TMVA__BinarySearchTree.html,https://root.cern,https://root.cern/root/html528/TMVA__BinarySearchTree.html,4,"['Clear', 'clear']","['Clear', 'clear']"
Usability,"he tree to find the node matching ""event"". TMVA::BinarySearchTreeNode* Search(TMVA::Event* , TMVA::Node* ) const; Private, recursive, function for searching. Double_t GetSumOfWeights(Int_t theType) const; return the sum of event (node) weights. Double_t GetSumOfWeights(Int_t theType) const; return the sum of event (node) weights. Double_t Fill(const vector<TMVA::Event*>& events, const vector<Int_t>& theVars, Int_t theType = -1); create the search tree from the event collection; using ONLY the variables specified in ""theVars"". Double_t Fill(const vector<TMVA::Event*>& events, Int_t theType = -1); create the search tree from the events in a TTree; using ALL the variables specified included in the Event. void NormalizeTree(vector<pair<double,const TMVA::Event*>,allocator<pair<double,const TMVA::Event*> > >::iterator , vector<pair<double,const TMVA::Event*>,allocator<pair<double,const TMVA::Event*> > >::iterator , UInt_t ). void NormalizeTree(); Normalisation of tree. void Clear(TMVA::Node* n = 0); clear nodes. Double_t SearchVolume(TMVA::Volume* , vector<const TMVA::BinarySearchTreeNode*>* events = 0); search the whole tree and add up all weigths of events that; lie within the given voluem. Double_t SearchVolume(TMVA::Node* , TMVA::Volume* , Int_t , vector<const TMVA::BinarySearchTreeNode*>* events); recursively walk through the daughter nodes and add up all weigths of events that; lie within the given volume. Bool_t InVolume(const vector<Float_t>& , TMVA::Volume* ) const; test if the data points are in the given volume. void CalcStatistics(TMVA::Node* n = 0, Int_t signalClass = 0); calculate basic statistics (mean, rms for each variable). Int_t SearchVolumeWithMaxLimit(TMVA::Volume* , vector<const TMVA::BinarySearchTreeNode*>* events = 0, Int_t = -1); recursively walk through the daughter nodes and add up all weigths of events that; lie within the given volume a maximum number of events can be given. Node * CreateNode(UInt_t ) const; { return new BinarySearchTreeNode(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__BinarySearchTree.html:6538,clear,clear,6538,root/html530/TMVA__BinarySearchTree.html,https://root.cern,https://root.cern/root/html530/TMVA__BinarySearchTree.html,4,"['Clear', 'clear']","['Clear', 'clear']"
Usability,"he two data members of this class contain important information about X11/Win32 window identifier and the connection to the host’s graphics system. Every GUI element, which derives from TGObject has access to the TGClient via the data member fClient of TGObject. TGClient creates the connection with the host’s graphics system and sets up the complete graphics system for all widgets.; 25.5.2 TGWidget; The widgets base class TGWidget is typically used as a mix-in class via multiple inheritances. Its properties are available for all deriving widgets: TGButton, TGComboBox, TGTab, TGColorPalette, TGColorPick, TGDoubleSlider, TGListTree, TGNumberEntry, TGScrollBar, TGShutterItem, TGTextEntry, TGSlider, TGListBox, TGView.; This class has four data members keeping information about the widget id - important for event processing, the window which handles the widget’s events, the widget status flags and the assigned command (if there is any). The general properties of TGWidget are specified by SetFlags(Int_t flags) and ClearFlags(Int_t flags) methods. The status flags are: kWidgetWantFocus, kWidgetHasFocus, and kWidgetIsEnabled. The method Associate(const TGWindow* w) - sets the window which handles the widget events. SetCommand(const char* command) - sets the command to be executed. The command string can be gathering via GetCommand() method. For example, the third parameter in TGTextButton constructor can be omitted and set later in your program, i.e. instead of:; TGTextButton *exit = new TGTextButton(hframe,""&Exit"",; ""gApplication->Terminate()"");; You will have the following the two lines:; TGTextButton *exit = new TGTextButton(hframe,""&Exit"");; exit->SetCommand(""gApplication->Terminate()"");; The method IsEnabled() - returns kTRUE if the widget has flag kWidgetIsEnabled and it accepts user events. This method is very important for creating a good user interface because it allows you to disable or enable a widget depending on the situation of your application. As a standard a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1148240,Clear,ClearFlags,1148240,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Clear'],['ClearFlags']
Usability,"he type of the rule. ; Definition at line 764 of file TSchemaRule.cxx. ◆ GetSource(). const TObjArray * TSchemaRule::GetSource ; (; ); const. Get the list of source members as a TObjArray of TNamed object, with the name being the member name and the title being its type. ; Definition at line 560 of file TSchemaRule.cxx. ◆ GetSourceClass(). const char * TSchemaRule::GetSourceClass ; (; ); const. Get the source class of this rule (i.e. the onfile class). ; Definition at line 466 of file TSchemaRule.cxx. ◆ GetTarget(). const TObjArray * TSchemaRule::GetTarget ; (; ); const. Get the target data members of this rule (i.e. the in memory data member). ; Definition at line 520 of file TSchemaRule.cxx. ◆ GetTargetClass(). const char * TSchemaRule::GetTargetClass ; (; ); const. Get the targte class of this rule (i.e. the in memory class). ; Definition at line 484 of file TSchemaRule.cxx. ◆ GetTargetString(). const char * TSchemaRule::GetTargetString ; (; ); const. Get the target data members of this rule as a simple string (i.e. the in memory data member). ; Definition at line 512 of file TSchemaRule.cxx. ◆ GetVersion(). const char * TSchemaRule::GetVersion ; (; ); const. Get the version string. ; Definition at line 393 of file TSchemaRule.cxx. ◆ HasSource(). Bool_t TSchemaRule::HasSource ; (; const TString & ; source); const. Return true if one of the rule's data member source is 'source'. ; Definition at line 690 of file TSchemaRule.cxx. ◆ HasTarget(). Bool_t TSchemaRule::HasTarget ; (; const TString & ; target); const. Return true if one of the rule's data member target is 'target'. ; Definition at line 672 of file TSchemaRule.cxx. ◆ IsA(). TClass * ROOT::TSchemaRule::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 120 of file TSchemaRule.h. ◆ IsAliasRule(). Bool_t TSchemaRule::IsAliasRule ; (; ); const. Return kTRUE if the rule is a strict renaming of one of the data member of the class. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TSchemaRule.html:20667,simpl,simple,20667,doc/v632/classROOT_1_1TSchemaRule.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TSchemaRule.html,2,['simpl'],['simple']
Usability,"heManager<RooAbsCacheElement>::wireCache(). Data Members; protected:. Bool_t_allowOptimize; static Bool_t_clearObsListClear obslist on sterilize?; Bool_t_clearOnRedirect; Int_tRooCacheManager<RooAbsCacheElement>::_lastIndex! Last slot accessed; Int_tRooCacheManager<RooAbsCacheElement>::_maxSize! Maximum size; vector<RooNormSetCache>RooCacheManager<RooAbsCacheElement>::_nsetCache! Normalization/Integration set manager; vector<RooAbsCacheElement*>RooCacheManager<RooAbsCacheElement>::_object! Payload; Bool_t_optCacheModeSeen!; RooArgSet*_optCacheObservables! current optCacheObservables; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_tRooCacheManager<RooAbsCacheElement>::_size! Actual use; Bool_tRooCacheManager<RooAbsCacheElement>::_wired! In wired mode, there is a single payload which is returned always. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooObjCacheManager(RooAbsArg* owner = 0, Int_t maxSize = 2, Bool_t clearCacheOnServerRedirect = kTRUE, Bool_t allowOptimize = kFALSE); Constructor of object cache manager for given owner. If clearCacheOnServerRedirect is true; all cache elements will be cleared when a server redirect is intercepted by the cache manager.; This is the default strategy and should only be overridden when you really understand; what you're doing as properly implementing server redirect in cache elements can get very; complicated, especially if there are (cyclical) reference back to the owning object. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); Copy constructor. ~RooObjCacheManager(); Destructor. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Intercept server redirect calls. If clearOnRedirect was set, sterilize; the cache (i.e. keep the structure but delete all contents). If not; forward serverRedirect to cache elements. void operModeHook(); Intercept changes to cache operation mode and forward to cache elements. void opti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooObjCacheManager.html:4115,clear,clearCacheOnServerRedirect,4115,root/html602/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html602/RooObjCacheManager.html,4,['clear'],['clearCacheOnServerRedirect']
Usability,"heck if name is in the list of Tree/Branch leaves. ; This member function redefines the function in ROOT::v5::TFormula If a leaf has a name corresponding to the argument name, then returns a new code.; A TTreeFormula may contain more than one variable. For each variable referenced, the pointers to the corresponding branch and leaf is stored in the object arrays fBranches and fLeaves.; name can be :; Leaf_Name (simple variable or data member of a ClonesArray); Branch_Name.Leaf_Name; Branch_Name.Method_Name; Leaf_Name[index]; Branch_Name.Leaf_Name[index]; Branch_Name.Leaf_Name[index1]; Branch_Name.Leaf_Name[][index2]; Branch_Name.Leaf_Name[index1][index2]. New additions:; Branch_Name.Leaf_Name[OtherLeaf_Name]; Branch_Name.Datamember_Name; '.' can be replaced by '->'; and. Branch_Name[index1].Leaf_Name[index2]; Leaf_name[index].Action().OtherAction(param); Leaf_name[index].Action()[val].OtherAction(param). The expected returned values are; -2 : the name has been recognized but won't be usable; -1 : the name has not been recognized, or is too long, or tree does not exist.; >=0 : the name has been recognized, return the internal code for this name. . Reimplemented from ROOT::v5::TFormula.; Definition at line 2698 of file TTreeFormula.cxx. ◆ EvalClass() [1/2]. TClass * TTreeFormula::EvalClass ; (; ); const. virtual . Evaluate the class of this treeformula. ; If the 'value' of this formula is a simple pointer to an object, this function returns the TClass corresponding to its type. ; Definition at line 3597 of file TTreeFormula.cxx. ◆ EvalClass() [2/2]. TClass * TTreeFormula::EvalClass ; (; Int_t ; oper); const. protectedvirtual . Evaluate the class of the operation oper. ; If the 'value' in the requested operation is a simple pointer to an object, this function returns the TClass corresponding to its type. ; Definition at line 3610 of file TTreeFormula.cxx. ◆ EvalInstance() [1/2]. template<typename T > . T TTreeFormula::EvalInstance ; (; Int_t ; instance = 0, . const char",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeFormula.html:36343,usab,usable,36343,doc/master/classTTreeFormula.html,https://root.cern,https://root.cern/doc/master/classTTreeFormula.html,1,['usab'],['usable']
Usability,"heckMemUsage ; (; Long64_t & ; mfreq, . Bool_t & ; w80r, . Bool_t & ; w80v, . TString & ; wmsg . ). protected . Check the memory usage, if requested. ; Return kTRUE if OK, kFALSE if above 95% of at least one between virtual or resident limits are depassed. ; Definition at line 1512 of file TProofPlayer.cxx. ◆ Class(). static TClass * TProofPlayer::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TProofPlayer::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TProofPlayer::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 228 of file TProofPlayer.h. ◆ ClearInput(). void TProofPlayer::ClearInput ; (; ). overridevirtual . Clear input list. ; Implements TVirtualProofPlayer.; Definition at line 468 of file TProofPlayer.cxx. ◆ CreateDrawFeedback(). TDrawFeedback * TProofPlayer::CreateDrawFeedback ; (; TProof * ; p). overridevirtual . Draw feedback creation proxy. ; When accessed via TProof avoids link dependency on libProofPlayer. ; Implements TVirtualProofPlayer.; Definition at line 733 of file TProofPlayer.cxx. ◆ DeclFileName(). static const char * TProofPlayer::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 228 of file TProofPlayer.h. ◆ DeleteDrawFeedback(). void TProofPlayer::DeleteDrawFeedback ; (; TDrawFeedback * ; f). overridevirtual . Delete draw feedback object. ; Implements TVirtualProofPlayer.; Definition at line 750 of file TProofPlayer.cxx. ◆ DrawCanvas(). Int_t TProofPlayer::DrawCanvas ; (; TObject * ; obj). protectedvirtual . Draw the object if it is a canvas. ; Return 0 in case of success, 1 if it is not a canvas or libProofDraw is not available. ; Definition at line 1696 of file TProofPlayer.cxx. ◆ DrawSelect(). Long64_t TProofPlayer::DrawSelect ; (; TDSet * ; set, . const char * ; varexp, . const char * ; selection, . Option_t * ; option = """", .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayer.html:27087,feedback,feedback,27087,doc/master/classTProofPlayer.html,https://root.cern,https://root.cern/doc/master/classTProofPlayer.html,1,['feedback'],['feedback']
Usability,"heckObject(UInt_t offset, const TClass* cl, Bool_t readClass = kFALSE); voidCheckVersionBuf(); voidCreateElemNode(const TStreamerElement* elem); XMLNodePointer_tCreateItemNode(const char* name); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Bool_tExtractPointer(XMLNodePointer_t node, void*& ptr, TClass*& cl); voidExtractReference(XMLNodePointer_t node, const void* ptr, const TClass* cl); Int_tGetCompressionAlgorithm() const; Int_tGetCompressionLevel() const; Int_tGetCompressionSettings() const; const char*TXMLSetup::GetElItemName(TStreamerElement* el); Bool_tTXMLSetup::IsValidXmlSetup(const char* setupstr); voidTObject::MakeZombie(); voidTBufferFile::operator=(const TBufferFile&); voidPerformPostProcessing(); voidPerformPreProcessing(const TStreamerElement* elem, XMLNodePointer_t elemnode); TXMLStackObj*PopStack(); Bool_tProcessPointer(const void* ptr, XMLNodePointer_t node); TXMLStackObj*PushStack(XMLNodePointer_t current, Bool_t simple = kFALSE); virtual Int_tTBuffer::Read(const char* name); Bool_tTXMLSetup::ReadSetupFromStr(const char* setupstr); voidRegisterPointer(const void* ptr, XMLNodePointer_t node); voidSetCompressionAlgorithm(Int_t algorithm = 0); voidSetCompressionLevel(Int_t level = 1); voidSetCompressionSettings(Int_t settings = 1); voidSetXML(TXMLEngine* xml); voidShiftStack(const char* info = 0); TXMLStackObj*Stack(Int_t depth = 0); XMLNodePointer_tStackNode(); Bool_tVerifyAttr(XMLNodePointer_t node, const char* name, const char* value, const char* errinfo = 0); Bool_tVerifyElemNode(const TStreamerElement* elem); Bool_tVerifyItemNode(const char* name, const char* errinfo = 0); Bool_tVerifyNode(XMLNodePointer_t node, const char* name, const char* errinfo = 0); Bool_tVerifyStackAttr(const char* name, const char* value, const char* errinfo = 0); Bool_tVerifyStackNode(const char* name, const char* errinfo = 0); voidWorkWithClass(TStreamerInfo* info, const TClass* cl = 0); voidWorkWithElement(TStreamerEle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TBufferXML.html:19134,simpl,simple,19134,root/html530/TBufferXML.html,https://root.cern,https://root.cern/root/html530/TBufferXML.html,5,['simpl'],['simple']
Usability,"heckcrossings = kTRUE, Int_t nrays = 10000, const Double_t* vertex = NULL); Geometry checking method (see: TGeoManager::CheckGeometry()). void CheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const; Geometry checking method (see TGeoChecker). void CheckOverlaps(const TGeoVolume* vol, Double_t ovlp = 0.1, Option_t* option = """") const; Check overlaps for the top volume of the geometry, within a limit OVLP. void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); check current point in the geometry. void CheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); Test for shape navigation methods. Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2). void ClearVisibleVolumes(); Clear the list of visible volumes; reset the kVisOnScreen bit for volumes previously in the list. void DefineColors() const; Define 100 colors with increasing light intensities for each basic color (1-7); Register these colors at indexes starting with 1000. Int_t GetColor(Int_t base, Float_t light) const; Get index of a base color with given light intensity (0,1). TGeoVolume * GetDrawnVolume() const; Get currently drawn volume. Int_t DistanceToPrimitiveVol(TGeoVolume* vol, Int_t px, Int_t py); compute the closest distance of approach from point px,py to a volume. void DefaultAngles(); Set default angles for the current view. void DefaultColors(); Set default volume colors according to tracking media. Int_t CountNodes(TGeoVolume* vol, Int_t level) const; Count number of visible nodes down to a given level. Int_t CountVisibleNodes(); Count total number of visible nodes. void CheckEdit(); Check if Ged library is loaded and load geometry editor classe. void EditGeometry(Option_t* option = """"); Start the geometry editor. vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoPainter.html:14664,Clear,ClearVisibleVolumes,14664,root/html532/TGeoPainter.html,https://root.cern,https://root.cern/root/html532/TGeoPainter.html,4,['Clear'],"['Clear', 'ClearVisibleVolumes']"
Usability,"hed covariance matrix (NxN); shared_ptr<ROOT::Fit::FitData>fFitData! data of the fit; shared_ptr<ROOT::Fit::Fitter>fFitter! pointer to fitter object; ROOT::Math::Minimizer*fMinimizer; ROOT::Math::IParamMultiFunction*fModelFunc; ROOT::Math::IMultiGenFunction*fObjFunc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBackCompFitter(); Constructur needed by TVirtualFitter interface. Same behavior as default constructor.; initialize setting name and the global pointer. TBackCompFitter(const shared_ptr<ROOT::Fit::Fitter>& fitter, const shared_ptr<ROOT::Fit::FitData>& data); constructor used after having fit using directly ROOT::Fit::Fitter; will create a dummy fitter copying configuration and parameter settings. ~TBackCompFitter(); destructor - delete the managed objects. Double_t Chisquare(Int_t npar, Double_t* params) const; do chisquare calculations in case of likelihood fits; do evaluation a the minimum only. void Clear(Option_t* option = """"); clear resources for consecutive fits. Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs); execute the command (Fortran Minuit compatible interface). bool ValidParameterIndex(int ipar) const; check if ipar is a valid parameter index. void FixParameter(Int_t ipar); fix the paramter; std::cout<<""FixParameter""<<std::endl;. void GetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.94999999999999996); Computes point-by-point confidence intervals for the fitted function; Parameters:; n - number of points; ndim - dimensions of points; x - points, at which to compute the intervals, for ndim > 1; should be in order: (x0,y0, x1, y1, ... xn, yn); ci - computed intervals are returned in this array; cl - confidence level, default=0.95; NOTE, that the intervals are approximate for nonlinear(in parameters) models. void GetConfidenceIntervals(TObject* obj, Double_t cl = 0.94999999999999996); Computes confidence intervals at level cl. Default is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TBackCompFitter.html:13381,clear,clear,13381,root/html604/TBackCompFitter.html,https://root.cern,https://root.cern/root/html604/TBackCompFitter.html,3,"['Clear', 'clear']","['Clear', 'clear']"
Usability,"hen used to display the final difference between background and signal events. The figure “The neural net output” shows this plot. The neural net output. As it can be seen, this is a quite efficient technique. As mentioned earlier, neural networks are also used for fitting function. For some application with a cylindrical symmetry, a magnetic field simulation gives as output the angular component of the potential vector A, as well as the radial and z components of the B field.; One wants to fit those distributions with a function in order to plug them into the Geant simulation code. Polynomial fits could be tried, but it seems difficult to reach the desired precision over the full range. One could also use a spline interpolation between known points. In all cases, the resulting field would not be C-infinite.; An example of output (for Br) is shown. First the initial function can be seen as the target. Then, the resulting (normalized) neural net output. In order to ease the learning, the “normalize output” was used here. The initial amplitude can be recovered by multiplying by the original RMS and then shifting by the original mean. The original and the neural net for Br. 6 A Little C++. This chapter introduces you to some useful insights into C++, to allow you to use some of the most advanced features in ROOT. It is in no case a full course in C++.; 6.1 Classes, Methods and Constructors; C++ extends C with the notion of a class. If you’re used to structures in C, a class is a struct that is a group of related variables, which is extended with functions and routines specific to this structure (class). What is the interest? Consider a struct that is defined this way:; struct Line {; float x1;; float y1;; float x2;; float y2;; }; This structure represents a line to be drawn in a graphical window. (x1,y1) are the coordinates of the first point, (x2,y2) the coordinates of the second point. In the standard C, if you want to draw effectively such a line, you first have to d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:241395,learn,learning,241395,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['learn'],['learning']
Usability,"her with the passed value (if > 0) or with; the current time. Double_t GetCurrentRate() const; Get current rate. Rteunr the average rate if the current is not defined. TProofProgressStatus(Long64_t fEntries = 0, Long64_t fBytesRead = 0, Long64_t fReadCalls = 0, Double_t fProcTime = 0, Double_t fCPUTime = 0). Long64_t GetEntries() const; { return fEntries; }. Long64_t GetBytesRead() const; { return fBytesRead; }. Long64_t GetReadCalls() const; { return fReadCalls; }. Double_t GetLearnTime() const; { return fLearnTime; }. Double_t GetProcTime() const; { return fProcTime; }. Double_t GetCPUTime() const; { return fCPUTime; }. Double_t GetLastUpdate() const; { return fLastUpdate; }. Double_t GetRate() const; { return ((fProcTime > 0) ? fEntries/fProcTime : 0); }. void SetLastEntries(Long64_t entries); { fLastEntries = entries; }. void SetEntries(Long64_t entries); { fEntries = entries; }. void IncEntries(Long64_t entries = 1); { fLastEntries = entries; fEntries += entries; }. void IncBytesRead(Long64_t bytesRead); { fBytesRead += bytesRead; }. void SetBytesRead(Long64_t bytesRead); { fBytesRead = bytesRead; }. void IncReadCalls(Long64_t readCalls); { fReadCalls += readCalls; }. void SetReadCalls(Long64_t readCalls); { fReadCalls = readCalls; }. void SetLearnTime(Double_t learnTime); { fLearnTime = learnTime; }. void SetLastProcTime(Double_t procTime); { fLastProcTime = procTime; }. void SetProcTime(Double_t procTime); { fProcTime = procTime; }. void IncProcTime(Double_t procTime); { fLastProcTime = procTime; fProcTime += procTime; }. void SetCPUTime(Double_t procTime); { fCPUTime = procTime; }. void IncCPUTime(Double_t procTime); { fCPUTime += procTime; }. » Author: Jan Iwaszkiewicz 08/08/08 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id$ » Last generated: 2015-03-14 16:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofProgressStatus.html:8595,learn,learnTime,8595,root/html534/TProofProgressStatus.html,https://root.cern,https://root.cern/root/html534/TProofProgressStatus.html,4,['learn'],['learnTime']
Usability,"her with the passed value (if > 0) or with; the current time. Double_t GetCurrentRate() const; Get current rate. Rteunr the average rate if the current is not defined. TProofProgressStatus(Long64_t fEntries = 0, Long64_t fBytesRead = 0, Long64_t fReadCalls = 0, Double_t fProcTime = 0, Double_t fCPUTime = 0). Long64_t GetEntries() const; { return fEntries; }. Long64_t GetBytesRead() const; { return fBytesRead; }. Long64_t GetReadCalls() const; { return fReadCalls; }. Double_t GetLearnTime() const; { return fLearnTime; }. Double_t GetProcTime() const; { return fProcTime; }. Double_t GetCPUTime() const; { return fCPUTime; }. Double_t GetLastUpdate() const; { return fLastUpdate; }. Double_t GetRate() const; { return ((fProcTime > 0) ? fEntries/fProcTime : 0); }. void SetLastEntries(Long64_t entries); { fLastEntries = entries; }. void SetEntries(Long64_t entries); { fEntries = entries; }. void IncEntries(Long64_t entries = 1); { fLastEntries = entries; fEntries += entries; }. void IncBytesRead(Long64_t bytesRead); { fBytesRead += bytesRead; }. void SetBytesRead(Long64_t bytesRead); { fBytesRead = bytesRead; }. void IncReadCalls(Long64_t readCalls); { fReadCalls += readCalls; }. void SetReadCalls(Long64_t readCalls); { fReadCalls = readCalls; }. void SetLearnTime(Double_t learnTime); { fLearnTime = learnTime; }. void SetLastProcTime(Double_t procTime); { fLastProcTime = procTime; }. void SetProcTime(Double_t procTime); { fProcTime = procTime; }. void IncProcTime(Double_t procTime); { fLastProcTime = procTime; fProcTime += procTime; }. void SetCPUTime(Double_t procTime); { fCPUTime = procTime; }. void IncCPUTime(Double_t procTime); { fCPUTime += procTime; }. » Author: Jan Iwaszkiewicz 08/08/08 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id$ » Last generated: 2015-06-02 16:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofProgressStatus.html:9222,learn,learnTime,9222,root/html604/TProofProgressStatus.html,https://root.cern,https://root.cern/root/html604/TProofProgressStatus.html,4,['learn'],['learnTime']
Usability,"her with the passed value (if > 0) or with; the current time. Double_t GetCurrentRate() const; Get current rate. Rteunr the average rate if the current is not defined. TProofProgressStatus(Long64_t fEntries = 0, Long64_t fBytesRead = 0, Long64_t fReadCalls = 0, Double_t fProcTime = 0, Double_t fCPUTime = 0). Long64_t GetEntries() const; { return fEntries; }. Long64_t GetBytesRead() const; { return fBytesRead; }. Long64_t GetReadCalls() const; { return fReadCalls; }. Double_t GetLearnTime() const; { return fLearnTime; }. Double_t GetProcTime() const; { return fProcTime; }. Double_t GetCPUTime() const; { return fCPUTime; }. Double_t GetLastUpdate() const; { return fLastUpdate; }. Double_t GetRate() const; { return ((fProcTime > 0) ? fEntries/fProcTime : 0); }. void SetLastEntries(Long64_t entries); { fLastEntries = entries; }. void SetEntries(Long64_t entries); { fEntries = entries; }. void IncEntries(Long64_t entries = 1); { fLastEntries = entries; fEntries += entries; }. void IncBytesRead(Long64_t bytesRead); { fBytesRead += bytesRead; }. void SetBytesRead(Long64_t bytesRead); { fBytesRead = bytesRead; }. void IncReadCalls(Long64_t readCalls); { fReadCalls += readCalls; }. void SetReadCalls(Long64_t readCalls); { fReadCalls = readCalls; }. void SetLearnTime(Double_t learnTime); { fLearnTime = learnTime; }. void SetLastProcTime(Double_t procTime); { fLastProcTime = procTime; }. void SetProcTime(Double_t procTime); { fProcTime = procTime; }. void IncProcTime(Double_t procTime); { fLastProcTime = procTime; fProcTime += procTime; }. void SetCPUTime(Double_t procTime); { fCPUTime = procTime; }. void IncCPUTime(Double_t procTime); { fCPUTime += procTime; }. » Author: Jan Iwaszkiewicz 08/08/08 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id$ » Last generated: 2015-06-30 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofProgressStatus.html:9222,learn,learnTime,9222,root/html602/TProofProgressStatus.html,https://root.cern,https://root.cern/root/html602/TProofProgressStatus.html,4,['learn'],['learnTime']
Usability,"her. They interact and allow method calls of other object’s methods. The idea is simple: any object can send out (emit) a signal in certain situations saying that something happened. This is all it does to communicate and it does not know whether anything is interested in this information. On the other side there might be an object waiting for that signal and ready to react to it. This object disposes of special instruments to listen to the sent out signals. To have a communication we need a message transmission between the objects. In this simple example we use signals and slots. The code of the method TGButton::Clicked() is:; virtual void Clicked() { Emit(""Clicked()""); } // *SIGNAL*; I.e. any button emits the signal Clicked() any time someone clicks on it. As you can see this method is virtual and could be overridden if you need to. In our simple example we call the Connect() method to connect the Clicked() signal of Draw button with MyMainFrame::DoDraw():; draw->Connect(""Clicked()"",""MyMainFrame"",this,""DoDraw()"");; In the same way we can connect to the signal Clicked() of the Exit button with the system call gApplication->Terminate(0). We declare a new slot DoExit(), implement it to invoke the termination call and associate this slot with the signal Clicked() of the Exit button.; The code of example.C can be changed as follows:; public:; ...; void DoExit(); // a new slot is added; }; void MyMainFrame::DoExit() {; gApplication->Terminate(0);; }; MyMainFrame::MyMainFrame(const TGWindow *p,UInt_t w,UInt_t h) {; ...; TGTextButton *exit = new TGTextButton(hframe,""&Exit "");; // connects signal Clicked() with slot DoExit(); exit->Connect(""Clicked()"",""MyMainFrame"",this,""DoExit()"");; ...; }; Here is an abstract view of the signal/slots connections in example.C:. To benefit from this mechanism your classes must inherit from TQObject or otherwise the class definition must start with RQ_OBJECT(""ClassName"")macro. This macro allows the signals/slots communication mechanism to be",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1164378,simpl,simple,1164378,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"herited Members; Includes; Libraries. Function documentation; TGeoManager(); Default constructor. TGeoManager(const char* name, const char* title); Constructor. void Init(); Initialize manager class. TGeoManager(const TGeoManager& ); copy constructor. TGeoManager& operator=(const TGeoManager& ); assignment operator. ~TGeoManager(); Destructor. Int_t AddMaterial(const TGeoMaterial* material); Add a material to the list. Returns index of the material in list. Int_t AddOverlap(const TNamed* ovlp); Add an illegal overlap/extrusion to the list. Int_t AddTransformation(const TGeoMatrix* matrix); Add a matrix to the list. Returns index of the matrix in list. Int_t AddShape(const TGeoShape* shape); Add a shape to the list. Returns index of the shape in list. Int_t AddTrack(Int_t id, Int_t pdgcode, TObject* particle = 0); Add a track to the list of tracks. Use this for primaries only. For secondaries,; add them to the parent track. The method create objects that are registered; to the analysis manager but have to be cleaned-up by the user via ClearTracks(). Int_t AddTrack(TVirtualGeoTrack* track); Add a track to the list of tracks. TVirtualGeoTrack * MakeTrack(Int_t id, Int_t pdgcode, TObject* particle); Makes a primary track but do not attach it to the list of tracks. The track; can be attached as daughter to another one with TVirtualGeoTrack::AddTrack. Int_t AddVolume(TGeoVolume* volume); Add a volume to the list. Returns index of the volume in list. TGeoNavigator * AddNavigator(); Add a navigator in the list of navigators. If it is the first one make it; current navigator. TGeoNavigator * GetCurrentNavigator() const; Returns current navigator for the calling thread. TGeoNavigatorArray * GetListOfNavigators() const; Get list of navigators for the calling thread. Bool_t SetCurrentNavigator(Int_t index); Switch to another existing navigator for the calling thread. void SetNavigatorsLock(Bool_t flag); Set the lock for navigators. void ClearNavigators(); Clear all navigators. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoManager.html:37994,Clear,ClearTracks,37994,root/html534/TGeoManager.html,https://root.cern,https://root.cern/root/html534/TGeoManager.html,3,['Clear'],['ClearTracks']
Usability,"hether the event has passed the selection (true) or not (false). It should perform ""read-only"" operations on the columns, and should not have side-effects (e.g. modification of an external or static variable) to ensure correctness when implicit multi-threading is active. The second overload takes a string with a valid C++ expression in which column names are used as variable names (e.g. Filter(""x[0] + x[1] > 0"")). This is a convenience feature that comes with a certain runtime overhead: C++ code has to be generated on the fly from this expression before using it in the event loop. See the paragraph about ""Just-in-time compilation"" below for more information.; RDataFrame only evaluates filters when necessary: if multiple filters are chained one after another, they are executed in order and the first one returning false causes the event to be discarded and triggers the processing of the next entry. If multiple actions or transformations depend on the same filter, that filter is not executed multiple times for each entry: after the first access it simply serves a cached result.; Named filters and cutflow reports; An optional string parameter name can be passed to the Filter() method to create a named filter. Named filters work as usual, but also keep track of how many entries they accept and reject.; Statistics are retrieved through a call to the Report() method:. when Report() is called on the main RDataFrame object, it returns a ROOT::RDF::RResultPtr<RCutFlowReport> relative to all named filters declared up to that point; when called on a specific node (e.g. the result of a Define() or Filter()), it returns a ROOT::RDF::RResultPtr<RCutFlowReport> relative all named filters in the section of the chain between the main RDataFrame and that node (included). Stats are stored in the same order as named filters have been added to the graph, and refer to the latest event-loop that has been run using the relevant RDataFrame. Ranges; When RDataFrame is not being used in a mult",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:28370,simpl,simply,28370,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['simpl'],['simply']
Usability,"hi2Sys(); Bool_tGetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0); Bool_tGetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); Bool_tGetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTUnfold::GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; voidGetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysBackgroundUncorr(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); Double_tTUnfold::GetEpsMatrix() const; voidTUnfold::GetFoldedOutput(TH1* folded, const Int_t* binMap = 0) const; virtual const char*TObject::GetIconName() const; voidTUnfold::GetInput(TH1* inputData, const Int_t* binMap = 0) const; voidTUnfold::GetInputInverseEmatrix(TH2* ematrix); voidTUnfold::GetL(TH2* l) const; virtual Double_tTUnfold::GetLcurveX() const; virtual Double_tTUnfold::GetLcurveY() const; voidTUnfold::GetLsquared(TH2* lsquared) const; virtual const char*TObject::GetName() const; Int_tTUnfold::GetNdf() const; voidTUnfold::GetNormalisationVector(TH1* s, const Int_t* binMap = 0) const; Int_tTUnfold::GetNpar() const; Int_tTUnfold::GetNr() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; voidTUnfold::GetOutput(TH1* output, const Int_t* binMap = 0) const; voidTUnfold::GetProbabilityMatrix(TH2* A, TUnf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnfoldSys.html:6454,clear,clearEmat,6454,root/html534/TUnfoldSys.html,https://root.cern,https://root.cern/root/html534/TUnfoldSys.html,6,['clear'],['clearEmat']
Usability,"hich has to be used for starting dialog. ;  . Private Attributes; std::thread::id fCallbacksThrdId;  ! thread id where callbacks should be invoked ;  ; bool fCallbacksThrdIdSet {false};  ! flag indicating that thread id is assigned ;  ; std::shared_ptr< void > fClearOnClose;  ! entry which is cleared when last connection is closed ;  ; std::string fClientVersion;  ! configured client version, used as prefix in scripts URL ;  ; ConnectionsList_t fConn;  ! list of all accepted connections ;  ; WebWindowConnectCallback_t fConnCallback;  ! callback for connect event ;  ; unsigned fConnCnt {0};  ! counter of new connections to assign ids ;  ; unsigned fConnLimit {1};  ! number of allowed active connections ;  ; std::mutex fConnMutex;  ! mutex used to protect connection list ;  ; std::string fConnToken;  ! value of ""token"" URL parameter which should be provided for connecting window ;  ; WebWindowDataCallback_t fDataCallback;  ! main callback when data over channel 1 is arrived ;  ; std::string fDefaultPage;  ! HTML page (or file name) returned when window URL is opened ;  ; WebWindowConnectCallback_t fDisconnCallback;  ! callback for disconnect event ;  ; bool fHasWindowThrd {false};  ! indicate if special window thread was started ;  ; unsigned fHeight {0};  ! initial window width and height when displayed, zeros are ignored ;  ; unsigned fId {0};  ! unique identifier ;  ; std::queue< QueueEntry > fInputQueue;  ! input queue for all callbacks ;  ; std::mutex fInputQueueMutex;  ! mutex to protect input queue ;  ; std::shared_ptr< RWebWindow > fMaster;  ! master window where this window is embedded ;  ; std::vector< MasterConn > fMasterConns;  ! master connections ;  ; unsigned fMaxQueueLength {10};  ! maximal number of queue entries ;  ; std::shared_ptr< RWebWindowsManager > fMgr;  ! display manager ;  ; bool fNativeOnlyConn {false};  ! only native connection are allowed, created by Show() method ;  ; float fOperationTmout {50.};  ! timeout in seconds to perform synchrono",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:18160,clear,cleared,18160,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,2,['clear'],['cleared']
Usability,"hifts of each source). unfold.GetDeltaSysBackgroundScale(bgr1shifts,""bgr1"");; unfold.GetDeltaSysBackgroundScale(bgr2shifts,""bgr2"");; unfold.GetDeltaSysSource(sys1shifts,""syserror1"");; unfold.GetDeltaSysSource(sys2shifts,""syserror2"");. retreive errors from uncorrelated sources; In the example, there are four sources of uncorrelated error; * the input vector (statistical errors of the data); * the input matrix histA (Monte Carlo statistical errors); * the errors on bgr1 (Monte Carlo statistical errors); * the errors on bgr2 (Monte Carlo statistical errors); These errors are returned as error matrices. unfold.GetEmatrixInput(stat_error);; unfold.GetEmatrixSysUncorr(uncorr_sys);; unfold.GetEmatrixSysBackgroundUncorr(bgr1uncorr,""bgr1"");; unfold.GetEmatrixSysBackgroundUncorr(bgr2uncorr,""bgr2"");. Error matrices can be added to existing histograms.; This is useful to retreive the sum of several error matrices.; If the last argument of the .GetEmatrixXXX methods is set to kFALSE, the; histogram is not cleared, but the error matrix is simply added.; Example: add all errors from background subtraction. unfold.GetEmatrixSysBackgroundUncorr(bgrerror,""bgr1"",0,kTRUE);; unfold.GetEmatrixSysBackgroundCorr(bgrerror,""bgr1"",0,kFALSE);; unfold.GetEmatrixSysBackgroundUncorr(bgrerror,""bgr2"",0,kFALSE);; unfold.GetEmatrixSysBackgroundCorr(bgrerror,""bgr2"",0,kFALSE);. There is a special function to get the total error:; unfold.GetEmatrixTotal(err_total);. Function Members (Methods); public:. TUnfoldSys(const TUnfoldSys&); TUnfoldSys(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintNone); virtual~TUnfoldSys(); voidTObject::AbstractMethod(const char* method) const; voidAddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnfoldSys.html:5065,clear,cleared,5065,root/html528/TUnfoldSys.html,https://root.cern,https://root.cern/root/html528/TUnfoldSys.html,8,"['clear', 'simpl']","['cleared', 'simply']"
Usability,"hild, Int_t x, Int_t y, Int_t& fx, Int_t& fy); virtual voidTGFrame::UnmapWindow(); virtual voidTObject::UseCurrentStyle(); Bool_tTGWidget::WantFocus() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidChangeTab(Int_t tabIndex, Bool_t emit = kTRUE); static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidTGFrame::DoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTObject::MakeZombie(); Int_tTGWidget::SetFlags(Int_t flags); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE). private:. TGTab(const TGTab&); TGTab&operator=(const TGTab&). Data Members; public:. enum TGFrame::[unnamed] { kDeleteWindowCalled; };; enum TGWindow::EEditMode { kEditEnable; kEditDisable; kEditDisableEvents; kEditDisableGrab; kEditDisableLayout; kEditDisableResize; kEditDisableHeight; kEditDisableWidth; kEditDisableBtnEnable; kEditDisableKeyEnable; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGTab.html:16768,Clear,ClearFlags,16768,root/html532/TGTab.html,https://root.cern,https://root.cern/root/html532/TGTab.html,2,['Clear'],['ClearFlags']
Usability,"hildFrame, Pixel_t back = GetDefaultFrameBackground()); TGLabel(const TGWindow* p = 0, const char* text = 0, GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); virtual~TGLabel(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); virtual voidChangeText(const char* newText)MENU ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()SIGNAL ; virtual voidTGWindow::DestroySubwindows(); virtual voidTGWindow::DestroyWindow(); virtual voidDisable(Bool_t on = kTRUE)TOGGLE GETTER ; Bool_tTQOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGLabel.html:1496,Clear,Clear,1496,root/html532/TGLabel.html,https://root.cern,https://root.cern/root/html532/TGLabel.html,2,['Clear'],['Clear']
Usability,"hing...; No Matches. List of all members |; Public Types |; Public Member Functions |; Private Member Functions |; Private Attributes |; List of all members ; ROOT::TMetaUtils::TClingLookupHelper Class Reference. . Definition at line 160 of file TClingUtils.h. Public Types; typedef bool(* AutoParse_t) (const char *name);  ; typedef bool(* ExistingTypeCheck_t) (const std::string &tname, std::string &result);  . Public Member Functions;  TClingLookupHelper (cling::Interpreter &interpreter, TNormalizedCtxt &normCtxt, ExistingTypeCheck_t existingTypeCheck, AutoParse_t autoParse, bool *shuttingDownPtr, const int *pgDebug=nullptr);  ; virtual ~TClingLookupHelper ();  ; bool ExistingTypeCheck (const std::string &tname, std::string &result) override;  Helper routine to ry hard to avoid looking up in the Cling database as this could enduce an unwanted autoparsing. ;  ; void GetPartiallyDesugaredName (std::string &nameLong) override;  ; bool GetPartiallyDesugaredNameWithScopeHandling (const std::string &tname, std::string &result, bool dropstd=true) override;  We assume that we have a simple type: [const] typename[*&][const]. ;  ; bool IsAlreadyPartiallyDesugaredName (const std::string &nondef, const std::string &nameLong) override;  ; bool IsDeclaredScope (const std::string &base, bool &isInlined) override;  ; void ShuttingDownSignal () override;  ;  Public Member Functions inherited from TClassEdit::TInterpreterLookupHelper;  TInterpreterLookupHelper ();  ; virtual ~TInterpreterLookupHelper ();  . Private Member Functions; bool WantDiags () const;  . Private Attributes; AutoParse_t fAutoParse;  ; ExistingTypeCheck_t fExistingTypeCheck;  ; cling::Interpreter * fInterpreter;  ; bool * fInterpreterIsShuttingDownPtr;  ; TNormalizedCtxt * fNormalizedCtxt;  ; const int * fPDebug;  . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/core/clingutils/res/TClingUtils.h>. Inheritance diagram for ROOT::TMetaUtils::TClingLookupHelper:. This browser is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1TMetaUtils_1_1TClingLookupHelper.html:1214,simpl,simple,1214,doc/master/classROOT_1_1TMetaUtils_1_1TClingLookupHelper.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1TMetaUtils_1_1TClingLookupHelper.html,1,['simpl'],['simple']
Usability,"his class). void AddOutput(TList* out); Incorporate output list (may not be used in this class). void StoreOutput(TList* out); Store output list (may not be used in this class). void StoreFeedback(TObject* slave, TList* out); Store feedback list (may not be used in this class). void Progress(Long64_t total, Long64_t processed); Report progress (may not be used in this class). void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Report progress (may not be used in this class). void Progress(TProofProgressInfo* pi); Report progress (may not be used in this class). void Feedback(TList* objs); Set feedback list (may not be used in this class). TDrawFeedback * CreateDrawFeedback(TProof* p); Draw feedback creation proxy. When accessed via TProof avoids; link dependency on libProofPlayer. void SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); Set draw feedback option. void DeleteDrawFeedback(TDrawFeedback* f); Delete draw feedback object. Int_t SavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); Save the partial results of this query to a dedicated file under the user; data directory. The file name has the form; <session_tag>.q<query_seq_num>.root; The file pat and the file are created if not existing already.; Only objects in the outputlist not being TProofOutputFile are saved.; The packets list 'packets' is saved if given.; Trees not attached to any file are attached to the open file.; If 'queryend' is kTRUE evrything is written out (TTrees included).; The actual saving action is controlled by 'force' and by fSavePartialResults; fSaveResultsPerPacket:. fSavePartialResults = kFALSE/kTRUE no-saving/saving; fSaveResultsPerPacket = kFALSE/kTRUE save-per-query/save-per-packet. The function CheckMemUsage sets fSavePartialResults = 1 if fSaveMemThreshold > 0 and; ProcInfo_t::fMemResident >= fSaveMemThreshold: from that point on partial results; are always saved and expens",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofPlayer.html:17841,feedback,feedback,17841,root/html534/TProofPlayer.html,https://root.cern,https://root.cern/root/html534/TProofPlayer.html,6,['feedback'],['feedback']
Usability,"his class). void AddOutput(TList* out); Incorporate output list (may not be used in this class). void StoreOutput(TList* out); Store output list (may not be used in this class). void StoreFeedback(TObject* slave, TList* out); Store feedback list (may not be used in this class). void Progress(Long64_t total, Long64_t processed); Report progress (may not be used in this class). void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Report progress (may not be used in this class). void Progress(TProofProgressInfo* pi); Report progress (may not be used in this class). void Feedback(TList* objs); Set feedback list (may not be used in this class). TDrawFeedback * CreateDrawFeedback(TProof* p); Draw feedback creation proxy. When accessed via TProof avoids; link dependency on libProofPlayer. void SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); Set draw feedback option. void DeleteDrawFeedback(TDrawFeedback* f); Delete draw feedback object. Long64_t Process(TDSet* set, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Process specified TDSet on PROOF worker.; The return value is -1 in case of error and TSelector::GetStatus(); in case of success. Bool_t CheckMemUsage(Long64_t& mfreq, Bool_t& w80r, Bool_t& w80v, TString& wmsg); Check the memory usage, if requested.; Return kTRUE if OK, kFALSE if above 95% of at least one between virtual or; resident limits are depassed. Long64_t Finalize(Bool_t force = kFALSE, Bool_t sync = kFALSE); Finalize query (may not be used in this class). Long64_t Finalize(TQueryResult* qr); Finalize query (may not be used in this class). void MergeOutput(); Merge output (may not be used in this class). void MapOutputListToDataMembers() const. void UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); Update automatic binning parameters for give",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofPlayer.html:16482,feedback,feedback,16482,root/html528/TProofPlayer.html,https://root.cern,https://root.cern/root/html528/TProofPlayer.html,4,['feedback'],['feedback']
Usability,"his class)THnC, THnT<Char_t>. Function Members (Methods); public:. THnT<char>(); THnT<char>(const char* name, const char* title, Int_t dim, const Int_t* nbins, const Double_t* xmin, const Double_t* xmax); ~THnT<char>(); voidTObject::AbstractMethod(const char* method) const; voidTHnBase::Add(const THnBase* h, Double_t c = 1.); voidTHnBase::Add(const TH1* hist, Double_t c = 1.); voidTHn::AddBinContent(const Int_t* idx, Double_t v = 1.); virtual voidTHn::AddBinContent(Long64_t bin, Double_t v = 1.); virtual voidTHn::AddBinError2(Long64_t bin, Double_t e2); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTHnBase::Browse(TBrowser* b); voidTHnBase::CalculateErrors(Bool_t calc = kTRUE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THn*THn::CreateHn(const char* name, const char* title, const TH1* h1); static THn*THn::CreateHn(const char* name, const char* title, const THnBase* hn); virtual ROOT::THnBaseBinIter*THn::CreateIter(Bool_t respectAxisRange) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THnT_char_.html:2219,Clear,Clear,2219,root/html534/THnT_char_.html,https://root.cern,https://root.cern/root/html534/THnT_char_.html,1,['Clear'],['Clear']
Usability,"his class)THnL, THnT<Long_t>. Function Members (Methods); public:. THnT<long>(); THnT<long>(const char* name, const char* title, Int_t dim, const Int_t* nbins, const Double_t* xmin, const Double_t* xmax); ~THnT<long>(); voidTObject::AbstractMethod(const char* method) const; voidTHnBase::Add(const THnBase* h, Double_t c = 1.); voidTHnBase::Add(const TH1* hist, Double_t c = 1.); voidTHn::AddBinContent(const Int_t* idx, Double_t v = 1.); virtual voidTHn::AddBinContent(Long64_t bin, Double_t v = 1.); virtual voidTHn::AddBinError2(Long64_t bin, Double_t e2); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTHnBase::Browse(TBrowser* b); voidTHnBase::CalculateErrors(Bool_t calc = kTRUE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THn*THn::CreateHn(const char* name, const char* title, const TH1* h1); static THn*THn::CreateHn(const char* name, const char* title, const THnBase* hn); virtual ROOT::THnBaseBinIter*THn::CreateIter(Bool_t respectAxisRange) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THnT_long_.html:2219,Clear,Clear,2219,root/html534/THnT_long_.html,https://root.cern,https://root.cern/root/html534/THnT_long_.html,1,['Clear'],['Clear']
Usability,"his complication is to use template functions and/or C++14 auto return types: template <typename RDF>; auto ApplySomeFilters(RDF df); {; return df.Filter(""x > 0"").Filter([](int y) { return y < 0; }, {""y""});; }; A possibly simpler, C++11-compatible alternative is to take advantage of the fact that any dataframe node can be converted (implicitly or via an explicit cast) to the common type ROOT::RDF::RNode: // a function that conditionally adds a Range to an RDataFrame node.; RNode MaybeAddRange(RNode df, bool mustAddRange); {; return mustAddRange ? df.Range(1) : df;; }; // use as :; ROOT::RDataFrame df(10);; auto maybeRangedDF = MaybeAddRange(df, true);; The conversion to ROOT::RDF::RNode is cheap, but it will introduce an extra virtual call during the RDataFrame event loop (in most cases, the resulting performance impact should be negligible). Python users can perform the conversion with the helper function ROOT.RDF.AsRNode. Storing RDataFrame objects in collections; ROOT::RDF::RNode also makes it simple to store RDataFrame nodes in collections, e.g. a std::vector<RNode> or a std::map<std::string, RNode>:; std::vector<ROOT::RDF::RNode> dfs;; dfs.emplace_back(ROOT::RDataFrame(10));; dfs.emplace_back(dfs[0].Define(""x"", ""42.f""));. Executing callbacks every N events; It's possible to schedule execution of arbitrary functions (callbacks) during the event loop. Callbacks can be used e.g. to inspect partial results of the analysis while the event loop is running, drawing a partially-filled histogram every time a certain number of new entries is processed, or displaying a progress bar while the event loop runs.; For example one can draw an up-to-date version of a result histogram every 100 entries like this: auto h = df.Histo1D(""x"");; TCanvas c(""c"",""x hist"");; h.OnPartialResult(100, [&c](TH1D &h_) { c.cd(); h_.Draw(); c.Update(); });; // event loop runs here, this final `Draw` is executed after the event loop is finished; h->Draw();; TCanvasThe Canvas class.Definition TCanva",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:59534,simpl,simple,59534,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['simpl'],['simple']
Usability,"his object to the current directory. ;  ;  Public Member Functions inherited from RooPrintable;  RooPrintable ();  ; virtual ~RooPrintable ();  ; virtual StyleOption defaultPrintStyle (Option_t *opt) const;  ; virtual void printExtras (std::ostream &os) const;  Interface to print extras of object. ;  ; virtual void printStream (std::ostream &os, Int_t contents, StyleOption style, TString indent="""") const;  Print description of object on ostream, printing contents set by contents integer, which is interpreted as an OR of 'enum ContentsOptions' values and in the style given by 'enum StyleOption'. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from RooAbsMoment; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current erro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFirstMoment.html:45581,clear,clearEvalErrorLog,45581,doc/master/classRooFirstMoment.html,https://root.cern,https://root.cern/doc/master/classRooFirstMoment.html,3,['clear'],['clearEvalErrorLog']
Usability,"his point you can use the mouse to click on the contour of; the histogram hpx. When the mouse is clicked, the bin number and its; contents are printed.; Example2 of use of exec1.C. Root > TFile f(""hsimple.root""); Root > hpxpy.Draw(); Root > c1.AddExec(""ex2"","".x exec2.C""); When moving the mouse in the canvas, a second canvas shows the; projection along X of the bin corresponding to the Y position; of the mouse. The resulting histogram is fitted with a gaussian.; A ""dynamic"" line shows the current bin position in Y.; This more elaborated example can be used as a starting point; to develop more powerful interactive applications exploiting CINT; as a development engine. void AutoExec(); Execute the list of Execs when a pad event occurs. void Browse(TBrowser* b); Browse pad. TLegend * BuildLegend(Double_t x1 = 0.5, Double_t y1 = 0.67, Double_t x2 = 0.88, Double_t y2 = 0.88, const char* title = """"); Build a legend from the graphical objects in the pad. A simple method to build automatically a TLegend from the; primitives in a TPad. Only those deriving from TAttLine,; TAttMarker and TAttFill are added, excluding TPave and TFrame; derived classes. x1, y1, x2, y2 are the TLegend coordinates.; title is the legend title. By default it is "" "". The caller; program owns the returned TLegend. If the pad contains some TMultiGraph or THStack the individual; graphs or histograms in them are added to the TLegend. TVirtualPad * cd(Int_t subpadnumber = 0); Set Current pad.; When a canvas/pad is divided via TPad::Divide, one can directly; set the current path to one of the subdivisions.; See TPad::Divide for the convention to number subpads.; Returns the new current pad, or 0 in case of failure.; For example:; c1.Divide(2,3); // create 6 pads (2 divisions along x, 3 along y).; To set the current pad to the bottom right pad, do; c1.cd(6);; Note1: c1.cd() is equivalent to c1.cd(0) and sets the current pad; to c1 itself.; Note2: after a statement like c1.cd(6), the global variable gPad; poin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPad.html:32283,simpl,simple,32283,root/html534/TPad.html,https://root.cern,https://root.cern/root/html534/TPad.html,2,['simpl'],['simple']
Usability,"histogram. * * *. lp(x,y,z) set the light position.; In Light and LightHeight display modes groups the color palette is; calculated according to the fictive light source position in 3-d space.; Using this function one can change the position of the source and thus; to achieve various graphical effects. This function does not apply for; Simple and Height display modes groups. Default is:; lp(1000,1000,100). * * *. s(shading,shadow) allows to set the shading.; The picture's surface is composed of triangles. If desired the edges of; the neighboring triangles can be smoothed (shaded). If desired the; display of the shadow can be painted as well. The function does not apply; for Simple display modes group. The possible values for shading are:. 0 = Not Shaded; 1 = Shaded. The possible values for shadow are:. 0 = Shadows are not painted; 1 = Shadows are painted. Default values: s(1,0). * * *. b(bezier) set the Bezier smoothing.; For Simple display modes group and for Grid, LinesX and LinesY display; modes one can smooth data using Bezier smoothing algorithm. The function; does not apply for other display modes groups and display modes. Possible; values are:. 0 = No bezier smoothing; 1 = Bezier smoothing. Default value is: b(0). * * *. cw(width) set the contour width.; This function applies only for the Contours display mode. One can change; the width between horizontal slices and thus their density.; Default value: cw(50). * * *. lhw(weight) set the light height weight.; For LightHeight display modes group one can change the weight between; both shading algorithms. The function does not apply for other display; modes groups. Default value is lhw(0.5). * * *. cm(enable,color,width,height,style) allows to draw a marker on each node.; In addition to the surface drawn using any above given algorithm one can; display channel marks. One can control the color as well as the width,; height (in pixels) and the style of the marks. The parameter enable can; be set to. 0 = Channel mark",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSpectrum2Painter.html:42281,Simpl,Simple,42281,root/html532/TSpectrum2Painter.html,https://root.cern,https://root.cern/root/html532/TSpectrum2Painter.html,4,['Simpl'],['Simple']
Usability,"hitecture_t >::SetInputDepth ; (; size_t ; inputDepth). inline . Definition at line 218 of file GeneralLayer.h. ◆ SetInputHeight(). template<typename Architecture_t > . void TMVA::DNN::VGeneralLayer< Architecture_t >::SetInputHeight ; (; size_t ; inputHeight). inline . Definition at line 219 of file GeneralLayer.h. ◆ SetInputWidth(). template<typename Architecture_t > . void TMVA::DNN::VGeneralLayer< Architecture_t >::SetInputWidth ; (; size_t ; inputWidth). inline . Definition at line 220 of file GeneralLayer.h. ◆ SetIsTraining(). template<typename Architecture_t > . void TMVA::DNN::VGeneralLayer< Architecture_t >::SetIsTraining ; (; bool ; isTraining). inline . Definition at line 224 of file GeneralLayer.h. ◆ SetWidth(). template<typename Architecture_t > . void TMVA::DNN::VGeneralLayer< Architecture_t >::SetWidth ; (; size_t ; width). inline . Definition at line 223 of file GeneralLayer.h. ◆ Update(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::Update ; (; const Scalar_t ; learningRate). Updates the weights and biases, given the learning rate. ; Definition at line 410 of file GeneralLayer.h. ◆ UpdateBiases(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateBiases ; (; const std::vector< Matrix_t > & ; biasGradients, . const Scalar_t ; learningRate . ). Updates the biases, given the gradients and the learning rate. ; Definition at line 428 of file GeneralLayer.h. ◆ UpdateBiasGradients(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateBiasGradients ; (; const std::vector< Matrix_t > & ; biasGradients, . const Scalar_t ; learningRate . ). Updates the bias gradients, given some other weight gradients and learning rate. ; Definition at line 448 of file GeneralLayer.h. ◆ UpdateWeightGradients(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateWeightGradients ; (; const std::vector< Matrix_t > & ; w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html:25278,learn,learningRate,25278,doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html,1,['learn'],['learningRate']
Usability,"hm . Definition at line 7347 of file TSpectrum2Painter.cxx. ◆ GetColorIncrements(). void TSpectrum2Painter::GetColorIncrements ; (; Double_t & ; r, . Double_t & ; g, . Double_t & ; b . ). Gets color increments between two color levels for r, g, b components: . r, g, b - color increments between two color levels . Definition at line 7357 of file TSpectrum2Painter.cxx. ◆ GetContourWidth(). void TSpectrum2Painter::GetContourWidth ; (; Int_t & ; width). Gets width between horizontal slices: . width - width between contours, applies only for contours display mode . Definition at line 7403 of file TSpectrum2Painter.cxx. ◆ GetDisplayMode(). void TSpectrum2Painter::GetDisplayMode ; (; Int_t & ; modeGroup, . Int_t & ; displayMode . ). Gets display group mode and display mode: -modeGroup - the following group modes might have been set: simple modes-kPicture2ModeGroupSimple, modes with shading according to light-kPicture2ModeGroupLight, modes with shading according to channels counts-kPicture2ModeGroupHeight, modes of combination of shading according to light and to channels counts-kPicture2ModeGroupLightHeight -displayMode - display modes that might have been set: points, grid, contours, bars, x_lines, y_lines, bars_x, bars_y, needles, surface, triangles. ; Definition at line 7287 of file TSpectrum2Painter.cxx. ◆ GetLightHeightWeight(). void TSpectrum2Painter::GetLightHeightWeight ; (; Double_t & ; weight). Gets weight between shading according to fictive light source and according to channels counts: . weight - weight between shading according to fictive light source and according to channels counts, applies only for kPicture2ModeGroupLightHeight modes group . Definition at line 7413 of file TSpectrum2Painter.cxx. ◆ GetLightPosition(). void TSpectrum2Painter::GetLightPosition ; (; Int_t & ; x, . Int_t & ; y, . Int_t & ; z . ). Gets position of fictive light source in 3D space: . x, y, z . Definition at line 7369 of file TSpectrum2Painter.cxx. ◆ GetNodes(). void TSpectrum2Pai",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrum2Painter.html:28532,simpl,simple,28532,doc/master/classTSpectrum2Painter.html,https://root.cern,https://root.cern/doc/master/classTSpectrum2Painter.html,1,['simpl'],['simple']
Usability,"hod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); voidvector<long>::assign(initializer_list<vector<long>::value_type> __l); voidvector<long>::assign(vector<unsigned int>::size_type __n, const vector<long>::value_type& __val); vector<long>::referencevector<long>::at(vector<unsigned int>::size_type __n); vector<long>::const_referencevector<long>::at(vector<unsigned int>::size_type __n) const; vector<long>::referencevector<long>::back(); vector<long>::const_referencevector<long>::back() const; TTable::iteratorBegin(); TTable::iteratorBegin() const; vector<long>::iteratorvector<long>::begin(); vector<long>::const_iteratorvector<long>::begin() const; virtual voidTObject::Browse(TBrowser* b); vector<unsigned int>::size_typevector<long>::capacity() const; vector<long>::const_iteratorvector<long>::cbegin() const; vector<long>::const_iteratorvector<long>::cend() const; static TClass*Class(); virtual const char*TObject::ClassName() const; voidvector<long>::clear(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; vector<long>::const_reverse_iteratorvector<long>::crbegin() const; vector<long>::const_reverse_iteratorvector<long>::crend() const; long*vector<long>::data(); const long*vector<long>::data() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; boolvector<long>::empty() const; TTable::iteratorEnd(); TTable::iteratorEnd() const; vector<long>::iteratorvector<long>::end(); vector<long>::const_iteratorvector<long>::end() const; vector<long>::iteratorvector<long>::erase(vector<long>::iterator __positi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTableMap.html:2474,clear,clear,2474,root/html604/TTableMap.html,https://root.cern,https://root.cern/root/html604/TTableMap.html,2,['clear'],['clear']
Usability,"hoodInterval object ;  CMarkovChainStores the steps in a Markov Chain of points ;  CMaxLikelihoodEstimateTestStatMaxLikelihoodEstimateTestStat: TestStatistic that returns maximum likelihood estimate of a specified parameter ;  CMCMCCalculatorBayesian Calculator estimating an interval or a credible region using the Markov-Chain Monte Carlo method to integrate the likelihood function with the prior to obtain the posterior function ;  CMCMCIntervalMCMCInterval is a concrete implementation of the RooStats::ConfInterval interface ;  CMCMCIntervalPlotThis class provides simple and straightforward utilities to plot a MCMCInterval object ;  CMetropolisHastingsThis class uses the Metropolis-Hastings algorithm to construct a Markov Chain of data points using Monte Carlo ;  CMinNLLTestStatMinNLLTestStat is an implementation of the TestStatistic interface that calculates the minimum value of the negative log likelihood function and returns it as a test statistic ;  CModelConfigModelConfig is a simple class that holds configuration information specifying how a model should be used in the context of various RooStats tools ;  CNeymanConstructionNeymanConstruction is a concrete implementation of the NeymanConstruction interface that, as the name suggests, performs a NeymanConstruction ;  CNuisanceParametersSamplerHelper class for ToyMCSampler ;  CNumberCountingPdfFactory;  CNumEventsTestStatNumEventsTestStat is a simple implementation of the TestStatistic interface used for simple number counting ;  CPdfProposalPdfProposal is a concrete implementation of the ProposalFunction interface ;  CPointSetIntervalPointSetInterval is a concrete implementation of the ConfInterval interface ;  CProfileInspector;  CProfileLikelihoodCalculatorProfileLikelihoodCalculator is a concrete implementation of CombinedCalculator (the interface class for a tools which can produce both RooStats HypoTestResults and ConfIntervals) ;  CProfileLikelihoodTestStatProfileLikelihoodTestStat is an implementation of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:7157,simpl,simple,7157,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,1,['simpl'],['simple']
Usability,"hoodInterval object ;  CMarkovChainStores the steps in a Markov Chain of points ;  CMaxLikelihoodEstimateTestStatMaxLikelihoodEstimateTestStat: TestStatistic that returns maximum likelihood estimate of a specified parameter ;  CMCMCCalculatorBayesian Calculator estimating an interval or a credible region using the Markov-Chain Monte Carlo method to integrate the likelihood function with the prior to obtain the posterior function ;  CMCMCIntervalMCMCInterval is a concrete implementation of the RooStats::ConfInterval interface ;  CMCMCIntervalPlotThis class provides simple and straightforward utilities to plot a MCMCInterval object ;  CMetropolisHastingsThis class uses the Metropolis-Hastings algorithm to construct a Markov Chain of data points using Monte Carlo ;  CMinNLLTestStatMinNLLTestStat is an implementation of the TestStatistic interface that calculates the minimum value of the negative log likelihood function and returns it as a test statistic ;  CModelConfigModelConfig is a simple class that holds configuration information specifying how a model should be used in the context of various RooStats tools ;  CNeymanConstructionNeymanConstruction is a concrete implementation of the NeymanConstruction interface that, as the name suggests, performs a NeymanConstruction ;  CNuisanceParametersSamplerHelper class for ToyMCSampler ;  CNumberCountingPdfFactoryA factory for building PDFs and data for a number counting combination ;  CNumEventsTestStatNumEventsTestStat is a simple implementation of the TestStatistic interface used for simple number counting ;  CPdfProposalPdfProposal is a concrete implementation of the ProposalFunction interface ;  CPointSetIntervalPointSetInterval is a concrete implementation of the ConfInterval interface ;  CProfileInspectorUtility class to plot conditional MLE of nuisance parameters vs ;  CProfileLikelihoodCalculatorProfileLikelihoodCalculator is a concrete implementation of CombinedCalculator (the interface class for a tools which can p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:7374,simpl,simple,7374,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,5,['simpl'],['simple']
Usability,"hr_calc = ROOT.RooFormulaVar(""lhr_calc"", ""x[0] / x[1]"", [ws[""gauss""], ws[""uniform""]]); ; # Define the 'analytical' negative logarithmic likelihood ratio; nll_gauss = ws[""gauss""].createNLL(ws[""obs_data""]); ; # Create the learned pdf and NLL sum based on the learned likelihood ratio; pdf_learned = ROOT.RooWrapperPdf(""learned_pdf"", ""learned_pdf"", lhr_learned, True); ; nllr_learned = pdf_learned.createNLL(ws[""obs_data""]); ; # Plot the learned and analytical summed negativelogarithmic likelihood; frame1 = mu_vars[0].frame(; Title=""NLL of SBI vs. Morphing;#mu_{1};NLL"",; Range=(mu_observed[0] - 1, mu_observed[0] + 1),; ); nll_gauss.plotOn(frame1, ShiftToZero=True, LineColor=""kP6Blue+1"", Name=""gauss""); ROOT.RooAbsReal.setEvalErrorLoggingMode(""Ignore"") # Silence some warnings; nll_morph.plotOn(frame1, ShiftToZero=True, LineColor=""kP6Blue+2"", Name=""morph""); ROOT.RooAbsReal.setEvalErrorLoggingMode(""PrintErrors""); nllr_learned.plotOn(frame1, LineColor=""kP6Blue"", ShiftToZero=True, Name=""learned""); ; ; # Declare a helper function in ROOT to dereference unique_ptr; ROOT.gInterpreter.Declare(; """"""; RooAbsArg &my_deref(std::unique_ptr<RooAbsArg> const& ptr) { return *ptr; }; """"""; ); ; # Choose normalization set for lhr_calc to plot over; norm_set = ROOT.RooArgSet(x_vars); lhr_calc_final_ptr = ROOT.RooFit.Detail.compileForNormSet(lhr_calc, norm_set); lhr_calc_final = ROOT.my_deref(lhr_calc_final_ptr); lhr_calc_final.recursiveRedirectServers(norm_set); ; # Plot the likelihood ratio functions; frame2 = x_vars[0].frame(Title=""Likelihood ratio r(x_{1}|#mu_{1}=2.5);x_{1};p_{gauss}/p_{uniform}""); lhr_learned.plotOn(frame2, LineColor=""kP6Blue"", Name=""learned_ratio""); lhr_calc_final.plotOn(frame2, LineColor=""kP6Blue+1"", Name=""exact""); ; # Write the plots into one canvas to show, or into separate canvases for saving.; single_canvas = True; ; c = ROOT.TCanvas("""", """", 1200 if single_canvas else 600, 600); if single_canvas:; c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf617__simulation__based__inference__multidimensional_8py.html:9681,learn,learned,9681,doc/master/rf617__simulation__based__inference__multidimensional_8py.html,https://root.cern,https://root.cern/doc/master/rf617__simulation__based__inference__multidimensional_8py.html,1,['learn'],['learned']
Usability,"hrough an entire window. This is nothing else than the notion of inheritance. The TPad class is the parent of the TCanvas class. In ROOT, most objects derive from a base class TObject. This class has a virtual method Draw() such as all objects are supposed to be able to be “drawn”. If several canvases are defined, there is only one active at a time. One draws an object in the active canvas by using the statement:; object.Draw(); This instructs the object “object” to draw itself. If no canvas is opened, a default one (named “c1”) is created. In the next example, the first statement defines a function and the second one draws it. A default canvas is created since there was no opened one. You should see the picture as shown in the next figure.; root[] TF1 f1(""func1"",""sin(x)/x"",0,10); root[] f1.Draw(); <TCanvas::MakeDefCanvas>: created default TCanvas with name c1. A canvas with drawing. The following components comprise the canvas window:. Menu bar - contains main menus for global operations with files, print, clear canvas, inspect, etc.; Tool bar - has buttons for global and drawing operations; such as arrow, ellipse, latex, pad, etc.; Canvas - an area to draw objects.; Status bar - displays descriptive messages about the selected object.; Editor frame - responds dynamically and presents the user interface according to the selected object in the canvas. 2.3.1 Main Menus and Toolbar; At the top of the canvas window are File, Edit, View, Options, Inspect, Classes and Help menus.; 2.3.1.1 File Menu. New Canvas: creates a new canvas window in the current ROOT session.; Open…: popup a dialog to open a file.; Close Canvas: close the canvas window.; Save: save the drawing of the current canvas in a format selectable from the submenu. The current canvas name is used as a file name for various formats such as PostScript, GIF, JPEG, C macro file, root file.; Save As…: popup a dialog for saving the current canvas drawing in a new filename.; Print: popup a dialog to print the cur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:36764,clear,clear,36764,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['clear'],['clear']
Usability,"hs.%s[i];\n"",element->GetArrayLength(),ename,ename);; 3489 } else if (element->GetArrayDim() >= 2) {; 3490 fprintf(file,"" for (Int_t i=0;i<%d;i++) reinterpret_cast<%s *>(%s"", element->GetArrayLength(), element->GetTypeName(), ename);; 3491 fprintf(file,"")[i] = reinterpret_cast<%s const *>(rhs.%s)[i];\n"", element->GetTypeName(), ename);; 3492 }; 3493 } else if (element->GetType() == TVirtualStreamerInfo::kSTLp) {; 3494 if (!defMod) { fprintf(file,"" %s &modrhs = const_cast<%s &>( rhs );\n"",protoname.Data(),protoname.Data()); defMod = kTRUE; };; 3495 fprintf(file,"" modrhs.%s = 0;\n"",ename);; 3496 } else if (element->GetType() == TVirtualStreamerInfo::kSTL) {; 3497 if (!defMod) {; 3498 fprintf(file,"" %s &modrhs = const_cast<%s &>( rhs );\n"",protoname.Data(),protoname.Data()); defMod = kTRUE;; 3499 }; 3500 TClass *cle = element->GetClassPointer();; 3501 TVirtualCollectionProxy *proxy = cle ? element->GetClassPointer()->GetCollectionProxy() : 0;; 3502 std::string method_name = ""clear"";; 3503 if (!element->TestBit(TStreamerElement::kDoNotDelete) && proxy && (((TStreamerSTL*)element)->GetSTLtype() == ROOT::kSTLbitset)) {; 3504 method_name = ""reset"";; 3505 }; 3506 if (element->IsBase()) {; 3507 fprintf(file,"" modrhs.%s();\n"", method_name.c_str());; 3508 } else {; 3509 fprintf(file,"" modrhs.%s.%s();\n"",ename, method_name.c_str());; 3510 }; 3511 }; 3512 }; 3513 }; 3514}; 3515 ; 3516////////////////////////////////////////////////////////////////////////////////; 3517/// Write down the body of the 'move' constructor.; 3518 ; 3519static void R__WriteMoveConstructorBody(FILE *file, const TString &protoname, TIter &next); 3520{; 3521 TStreamerElement *element = 0;; 3522 next.Reset();; 3523 Bool_t atstart = kTRUE;; 3524 while ((element = (TStreamerElement*)next())) {; 3525 if (element->IsBase()) {; 3526 if (atstart) { fprintf(file,"" : ""); atstart = kFALSE; }; 3527 else fprintf(file,"" , "");; 3528 fprintf(file, ""%s(const_cast<%s &>( rhs ))\n"", element->GetName(),protoname.Data());; 35",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:141953,clear,clear,141953,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['clear'],['clear']
Usability,"i);; TBranch::GetEntryvirtual Int_t GetEntry(Long64_t entry=0, Int_t getall=0)Read all leaves of entry and return total number of bytes read.Definition TBranch.cxx:1706; If found is not 0, the number of branch(es) found matching the regular expression is returned in *found AND the error message 'unknown branch' is suppressed. ; Reimplemented in TChain.; Definition at line 8529 of file TTree.cxx. ◆ SetBranchStyle(). void TTree::SetBranchStyle ; (; Int_t ; style = 1). static . Set the current branch style. ; (static function). style = 0 old Branch; style = 1 new Bronch . Definition at line 8660 of file TTree.cxx. ◆ SetCacheEntryRange(). Int_t TTree::SetCacheEntryRange ; (; Long64_t ; first, . Long64_t ; last . ). virtual . interface to TTreeCache to set the cache entry range ; Returns:; 0 entry range set; -1 on error . Definition at line 8821 of file TTree.cxx. ◆ SetCacheLearnEntries(). void TTree::SetCacheLearnEntries ; (; Int_t ; n = 10). virtual . Interface to TTreeCache to set the number of entries for the learning phase. ; Definition at line 8855 of file TTree.cxx. ◆ SetCacheSize(). Int_t TTree::SetCacheSize ; (; Long64_t ; cacheSize = -1). virtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented in TChain.; Definition at line 8676 of file TTree.cxx. ◆ SetCacheSizeAux(). Int_t TTree::SetCacheSizeAux ; (; bool ; autocache = true, . Long64_t ; cacheSize = 0 . ). protected . Set the size of the file cache and create it if possible. ; If autocache is true: this may be an autocreated cache, possibly enlarging an existing autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false: th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:207483,learn,learning,207483,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,1,['learn'],['learning']
Usability,"i);; TBranch::GetEntryvirtual Int_t GetEntry(Long64_t entry=0, Int_t getall=0)Read all leaves of entry and return total number of bytes read.Definition TBranch.cxx:1706; If found is not 0, the number of branch(es) found matching the regular expression is returned in *found AND the error message 'unknown branch' is suppressed. ; Reimplemented in TChain.; Definition at line 8534 of file TTree.cxx. ◆ SetBranchStyle(). void TTree::SetBranchStyle ; (; Int_t ; style = 1). static . Set the current branch style. ; (static function). style = 0 old Branch; style = 1 new Bronch . Definition at line 8665 of file TTree.cxx. ◆ SetCacheEntryRange(). Int_t TTree::SetCacheEntryRange ; (; Long64_t ; first, . Long64_t ; last . ). virtual . interface to TTreeCache to set the cache entry range ; Returns:; 0 entry range set; -1 on error . Definition at line 8831 of file TTree.cxx. ◆ SetCacheLearnEntries(). void TTree::SetCacheLearnEntries ; (; Int_t ; n = 10). virtual . Interface to TTreeCache to set the number of entries for the learning phase. ; Definition at line 8865 of file TTree.cxx. ◆ SetCacheSize(). Int_t TTree::SetCacheSize ; (; Long64_t ; cacheSize = -1). virtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented in TChain.; Definition at line 8683 of file TTree.cxx. ◆ SetCacheSizeAux(). Int_t TTree::SetCacheSizeAux ; (; bool ; autocache = true, . Long64_t ; cacheSize = 0 . ). protected . Set the size of the file cache and create it if possible. ; If autocache is true: this may be an autocreated cache, possibly enlarging an existing autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:209974,learn,learning,209974,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,1,['learn'],['learning']
Usability,"i, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ EDataSet. enum TMultiLayerPerceptron::EDataSet. EnumeratorkTraining ; kTest . Definition at line 32 of file TMultiLayerPerceptron.h. ◆ ELearningMethod. enum TMultiLayerPerceptron::ELearningMethod. EnumeratorkStochastic ; kBatch ; kSteepestDescent ; kRibierePolak ; kFletcherReeves ; kBFGS . Definition at line 30 of file TMultiLayerPerceptron.h. Constructor & Destructor Documentation. ◆ TMultiLayerPerceptron() [1/6]. TMultiLayerPerceptron::TMultiLayerPerceptron ; (; ). Default constructor. ; Definition at line 264 of file TMultiLayerPerceptron.cxx. ◆ TMultiLayerPerceptron() [2/6]. TMultiLayerPerceptron::TMultiLayerPerceptron ; (; const char * ; layout, . TTree * ; data = nullptr, . const char * ; training = ""Entry$%2==0"", . const char * ; test = """", . TNeuron::ENeuronType ; type = TNeuron::kSigmoid, . const char * ; extF = """", . const char * ; extD = """" . ). The network is described by a simple string: The input/output layers are defined by giving the branch names separated by comas. ; Hidden layers are just described by the number of neurons. The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be normalized. The output can be followed by '!' to use Softmax neurons for the output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument. training and test are two cuts (see TTreeFormula) defining events to be used during the neural net training and testing.; Example: ""Entry$%2"", ""(Entry$+1)%2"".; Both the TTree and the cut can be defined in the constructor, or later with the suited setter method. ; Definition at line 446 of file TMultiLayerPerceptron.cxx. ◆ TMultiLayerPerceptron() [3/6]. TMultiLayerPerceptron::TMultiLayerPerceptron ; (; const char * ; layout, . const char * ; weight, . TTree * ; data = nullptr, . const char * ; training = ""Entry$%2==0"", . const char * ; test = """", . TNeuron::ENe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiLayerPerceptron.html:29346,simpl,simple,29346,doc/master/classTMultiLayerPerceptron.html,https://root.cern,https://root.cern/doc/master/classTMultiLayerPerceptron.html,1,['simpl'],['simple']
Usability,"i1) .... cos(fPhil+fDphi1); Float_tfDzhalf length in z; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TMaterial*TShape::fMaterialPointer to material; TStringTNamed::fNameobject identifier; Int_tfNdivnumber of segments (precision); Int_tTShape::fNumberShape number; Float_tfRmaxellipse semi-axis in X outside; Float_tfRminellipse semi-axis in X inside; Double_t*fSiTab! Table of sin(fPhi1) .... sin(fPhil+fDphi1); TStringTNamed::fTitleobject title; Int_tTShape::fVisibilityVisibility flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTUBE(); TUBE shape default constructor. TTUBE(const char* name, const char* title, const char* material, Float_t rmin, Float_t rmax, Float_t dz, Float_t aspect = 1); TUBE shape normal constructor. TTUBE(const char* name, const char* title, const char* material, Float_t rmax, Float_t dz); TUBE shape ""simplified"" constructor. TTUBE(const TTUBE& ); copy constructor. TTUBE& operator=(const TTUBE& ); assignement operator. void MakeTableOfCoSin() const; Make table of sine and cosine. ~TTUBE(); TUBE shape default destructor. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a TUBE. Compute the closest distance of approach from point px,py to each; computed outline point of the TUBE. void SetNumberOfDivisions(Int_t ndiv); Set number of divisions used to draw this tube. void SetPoints(Double_t* points) const; Create TUBE points. void SetSegsAndPols(TBuffer3D& buffer) const; Set segments and polygons. void Sizeof3D() const; Return total X3D needed by TNode::ls (when called with option ""x""). void Streamer(TBuffer& ); Stream an object of class TTUBE. const TBuffer3D & GetBuffer3D(Int_t reqSections) const; Get buffer 3d. Float_t GetRmin() const; {return fRmin;}. Float_t GetRmax() const; {return fRmax;}. Float_t GetDz() c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTUBE.html:9085,simpl,simplified,9085,root/html534/TTUBE.html,https://root.cern,https://root.cern/root/html534/TTUBE.html,2,['simpl'],['simplified']
Usability,"i1) .... cos(fPhil+fDphi1); Float_tfDzhalf length in z; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TMaterial*TShape::fMaterialPointer to material; TStringTNamed::fNameobject identifier; Int_tfNdivnumber of segments (precision); Int_tTShape::fNumberShape number; Float_tfRmaxellipse semi-axis in X outside; Float_tfRminellipse semi-axis in X inside; Double_t*fSiTab! Table of sin(fPhi1) .... sin(fPhil+fDphi1); TStringTNamed::fTitleobject title; Int_tTShape::fVisibilityVisibility flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTUBE(); TUBE shape default constructor. TTUBE(const char* name, const char* title, const char* material, Float_t rmin, Float_t rmax, Float_t dz, Float_t aspect = 1); TUBE shape normal constructor. TTUBE(const char* name, const char* title, const char* material, Float_t rmax, Float_t dz); TUBE shape ""simplified"" constructor. TTUBE(const TTUBE& ); copy constructor. TTUBE& operator=(const TTUBE& ); assignement operator. void MakeTableOfCoSin() const; Make table of sine and cosine. ~TTUBE(); TUBE shape default destructor. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a TUBE. Compute the closest distance of approach from point px,py to each; computed outline point of the TUBE. void SetNumberOfDivisions(Int_t ndiv); Set number of divisions used to draw this tube. void SetPoints(Double_t* points) const; Create TUBE points. void SetSegsAndPols(TBuffer3D& buffer) const; Set segments and polygons. void Sizeof3D() const; Return total X3D needed by TNode::ls (when called with option ""x""). void Streamer(TBuffer& b); Stream an object of class TTUBE. const TBuffer3D & GetBuffer3D(Int_t reqSections) const; Get buffer 3d. Float_t GetRmin() const; {return fRmin;}. Float_t GetRmax() const; {return fRmax;}. Float_t GetDz() ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTUBE.html:8851,simpl,simplified,8851,root/html528/TTUBE.html,https://root.cern,https://root.cern/root/html528/TTUBE.html,4,['simpl'],['simplified']
Usability,"i; Float_tfRmaxmaximum radius; Float_tfRminminimum radius; Float_tfThemaxmaximum theta; Float_tfTheminminimum theta; TStringTNamed::fTitleobject title; Int_tTShape::fVisibilityVisibility flag; Float_tfaXCoeff along Ox; Float_tfaYCoeff along Oy; Float_tfaZCoeff along Oz. private:. Float_tfAspectRatioRelation between asumth and grid size (by default 1.0); Double_t*fCoTab! Table of cos(fPhimin) .... cos(Phi); Double_t*fCoThetaTab! Table of sin(gThemin) .... cos(Theta); Int_tfNdivnumber of divisions; Int_tfNz! number of sections; Double_t*fSiTab! Table of sin(fPhimin) .... sin(Phi). Class Charts. Inheritance Chart:. TObject. ←; TNamed. TAttLine. TAttFill. TAtt3D. ←; TShape. ←; TSPHE. Function documentation; TSPHE(); SPHE shape default constructor. TSPHE(const char* name, const char* title, const char* material, Float_t rmin, Float_t rmax, Float_t themin, Float_t themax, Float_t phimin, Float_t phimax); SPHE shape normal constructor. TSPHE(const char* name, const char* title, const char* material, Float_t rmax); SPHE shape ""simplified"" constructor. ~TSPHE(); SPHE shape default destructor. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a PSPHE. Compute the closest distance of approach from point px,py to each; computed outline point of the PSPHE (stolen from PCON). void SetEllipse(const Float_t* factors); Set ellipse. void SetNumberOfDivisions(Int_t p); Set number of divisions. void SetPoints(Double_t* points) const; Create SPHE points. void Sizeof3D() const; Return total X3D needed by TNode::ls (when called with option ""x""). void MakeTableOfCoSin() const; Make table of sine and cosine. void Streamer(TBuffer& ); Stream a class object. const TBuffer3D & GetBuffer3D(Int_t reqSections) const; Get buffer 3d. TSPHE(). Float_t GetRmin() const; {return fRmin;}. Float_t GetRmax() const; {return fRmax;}. Float_t GetThemin() const; {return fThemin;}. Float_t GetThemax() const; {return fThemax;}. Float_t GetPhimin() const; {return fPhimin;}. Float",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSPHE.html:9967,simpl,simplified,9967,root/html602/TSPHE.html,https://root.cern,https://root.cern/root/html602/TSPHE.html,4,['simpl'],['simplified']
Usability,"iVarGaussian(const char* name, const char* title, const RooArgList& xvec, const RooFitResult& fr, Bool_t reduceToConditional = kTRUE). RooMultiVarGaussian(const char* name, const char* title, const RooArgList& xvec, const TVectorD& mu, const TMatrixDSym& covMatrix). RooMultiVarGaussian(const char* name, const char* title, const RooArgList& xvec, const TMatrixDSym& covMatrix). RooMultiVarGaussian(const RooMultiVarGaussian& other, const char* name = 0). void syncMuVec() const. Double_t evaluate() const; Represent observables as vector. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Analytical integral known over all observables. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Handle full integral here. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; Special case: generate all observables. void initGenerator(Int_t code); Clear the GenData cache as its content is not invariant under changes in; the mu vector. void generateEvent(Int_t code); Retrieve generator config from cache. void decodeCode(Int_t code, vector<int>& map1, vector<int>& map2) const; Decode analytical integration/generation code into index map of integrated/generated (map2); and non-integrated/generated observables (map1). void blockDecompose(const TMatrixD& input, const vector<int>& map1, const vector<int>& map2, TMatrixDSym& S11, TMatrixD& S12, TMatrixD& S21, TMatrixDSym& S22); Block decomposition of covI according to given maps of observables. RooMultiVarGaussian(); {}. void setAnaIntZ(Double_t z); { _z = z ; }. TObject* clone(const char* newname) const; { return new RooMultiVarGaussian(*this,newname); }. virtual ~RooMultiVarGaussian(); { }. const TMatrixDSym& covarianceMatrix() const; { return _cov ; }. AnaIntData& anaIntData(Int_t code) const. GenData& genData(Int_t code) const. » Last changed: Fri Dec 2 14:26:53 2011 » Last generated: 2011-12-02 14:26; This p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooMultiVarGaussian.html:43751,Clear,Clear,43751,root/html532/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html532/RooMultiVarGaussian.html,1,['Clear'],['Clear']
Usability,"iableInfo(i).GetExpression());; 333 firstArrayVar = kFALSE;; 334 firstArrayVarIndex = i;; 335 ; 336 Log() << kINFO << ""Using variable "" << dsi.GetVariableInfo(i).GetInternalName() <<; 337 "" from array expression "" << dsi.GetVariableInfo(i).GetExpression() << "" of size "" << arraySize << Endl;; 338 }; 339 fInputTableFormulas.push_back(std::make_pair(ttf, (Int_t) i-firstArrayVarIndex));; 340 if (int(i)-firstArrayVarIndex == arraySize-1 ) {; 341 // I am the last element of the array; 342 firstArrayVar = kTRUE;; 343 firstArrayVarIndex = -1;; 344 Log() << kDEBUG << ""Using Last variable from array : "" << dsi.GetVariableInfo(i).GetInternalName() << Endl;; 345 }; 346 }; 347 ; 348 }; 349 ; 350 //; 351 // targets; 352 //; 353 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName()) << ""transform regression targets"" << Endl;; 354 for (formIt = fTargetFormulas.begin(), formItEnd = fTargetFormulas.end(); formIt!=formItEnd; ++formIt) if (*formIt) delete *formIt;; 355 fTargetFormulas.clear();; 356 for (UInt_t i=0; i<dsi.GetNTargets(); i++) {; 357 ttf = new TTreeFormula( TString::Format( ""Formula%s"", dsi.GetTargetInfo(i).GetInternalName().Data() ),; 358 dsi.GetTargetInfo(i).GetExpression().Data(), tr );; 359 CheckTTreeFormula( ttf, dsi.GetTargetInfo(i).GetExpression(), hasDollar );; 360 fTargetFormulas.push_back( ttf );; 361 }; 362 ; 363 //; 364 // spectators; 365 //; 366 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName()) << ""transform spectator variables"" << Endl;; 367 for (formIt = fSpectatorFormulas.begin(), formItEnd = fSpectatorFormulas.end(); formIt!=formItEnd; ++formIt) if (*formIt) delete *formIt;; 368 fSpectatorFormulas.clear();; 369 for (UInt_t i=0; i<dsi.GetNSpectators(); i++) {; 370 ttf = new TTreeFormula( TString::Format( ""Formula%s"", dsi.GetSpectatorInfo(i).GetInternalName().Data() ),; 371 dsi.GetSpectatorInfo(i).GetExpression().Data(), tr );; 372 CheckTTreeFormula( ttf, dsi.GetSpectatorInfo(i).GetExpression(), hasDollar );; 373 fSpectatorFormulas.push_back( ttf );;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataSetFactory_8cxx_source.html:14248,clear,clear,14248,doc/master/DataSetFactory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html,1,['clear'],['clear']
Usability,"iagrams. More...;  ; class  TCurlyLine;  Implements curly or wavy polylines used to draw Feynman diagrams. More...;  ; class  TCutG;  Graphical cut class. More...;  ; class  TDiamond;  Draw a Diamond. More...;  ; class  TEllipse;  Draw Ellipses. More...;  ; class  TFrame;  Define a Frame. More...;  ; class  TGaxis;  The axis painter class. More...;  ; class  TGraphPolar;  To draw a polar graph. More...;  ; class  TGraphPolargram;  To draw polar axis. More...;  ; class  TGraphQQ;  This class allows to draw quantile-quantile plots. More...;  ; class  TImage;  An abstract interface to image processing library. More...;  ; class  TImagePalette;  A class to define a conversion from pixel values to pixel color. More...;  ; class  TLatex;  To draw Mathematical Formula. More...;  ; class  TLegend;  This class displays a legend box (TPaveText) containing several legend entries. More...;  ; class  TLegendEntry;  Storage class for one entry of a TLegend. More...;  ; class  TLine;  Use the TLine constructor to create a simple line. More...;  ; class  TLink;  Special TText object used to show hyperlinks. More...;  ; class  TMarker;  Manages Markers. More...;  ; class  TMathText;  To draw TeX Mathematical Formula. More...;  ; class  TPaletteEditor;  Edit the palette via a GUI. More...;  ; class  TPave;  A TBox with a bordersize and a shadow option. More...;  ; class  TPaveLabel;  A Pave (see TPave) with a text centered in the Pave. More...;  ; class  TPaveStats;  The histogram statistics painter class. More...;  ; class  TPavesText;  A PaveText (see TPaveText) with several stacked paves. More...;  ; class  TPaveText;  A Pave (see TPave) with text, lines or/and boxes inside. More...;  ; class  TPie;  Draw a Pie Chart,. More...;  ; class  TPieSlice;  A slice of a piechart, see the TPie class. More...;  ; class  TPoints;  2-D graphics point (world coordinates). More...;  ; class  TPolyLine;  Defined by an array on N points in a 2-D space. More...;  ; class  TText;  Base class for se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__BasicGraphics.html:1669,simpl,simple,1669,doc/master/group__BasicGraphics.html,https://root.cern,https://root.cern/doc/master/group__BasicGraphics.html,1,['simpl'],['simple']
Usability,"ialize the graphics environment. ;  ; TObjArray * InputFiles () const;  ; virtual Bool_t IsCmdThread ();  ; Bool_t IsRunning () const;  ; virtual void KeyPressed (Int_t key);  Emit signal when console keyboard key was pressed. ;  ; virtual void LineProcessed (const char *line);  Emit signal when a line has been processed. ;  ; virtual void Lower ();  ; void ls (Option_t *option="""") const override;  Show available sessions. ;  ; Bool_t NoLogoOpt () const;  ; Bool_t NoLogOpt () const;  ; virtual void Open ();  ; void OpenForumTopic (const TString &type);  It opens a Forum topic in a web browser with prefilled ROOT version. ;  ; void OpenGitHubIssue (const TString &type);  It opens a GitHub issue in a web browser with prefilled ROOT version. ;  ; void OpenInBrowser (const TString &url);  The function generates and executes a command that loads the Doxygen URL in a browser. ;  ; void OpenReferenceGuideFor (const TString &strippedClass);  It opens the online reference guide, generated with Doxygen, for the chosen scope (class/namespace/struct) or member (method/function/ data member/enumeration/enumerator. ;  ; virtual Longptr_t ProcessFile (const char *file, Int_t *error=nullptr, Bool_t keep=kFALSE);  Process a file containing a C++ macro. ;  ; Bool_t QuitOpt () const;  ; virtual void Raise ();  ; virtual void RemoveIdleTimer ();  Remove idle timer. Normally called via TROOT::Idle(0). ;  ; Bool_t ReturnFromRun () const;  ; virtual void ReturnPressed (char *text);  Emit signal when return key was pressed. ;  ; virtual void Run (Bool_t retrn=kFALSE);  Main application eventloop. Calls system dependent eventloop via gSystem. ;  ; virtual void SetEchoMode (Bool_t mode);  Set console echo mode: ;  ; virtual void SetIdleTimer (UInt_t idleTimeInSec, const char *command);  Set the command to be executed after the system has been idle for idleTimeInSec seconds. ;  ; void SetReturnFromRun (Bool_t ret);  ; virtual void Show ();  ; virtual void StartIdleing ();  Called when system ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTApplicationRemote.html:5270,guid,guide,5270,doc/master/classTApplicationRemote.html,https://root.cern,https://root.cern/doc/master/classTApplicationRemote.html,1,['guid'],['guide']
Usability,"ialize the graphics environment. ;  ; TObjArray * InputFiles () const;  ; virtual Bool_t IsCmdThread ();  ; Bool_t IsRunning () const;  ; virtual void KeyPressed (Int_t key);  Emit signal when console keyboard key was pressed. ;  ; virtual void LineProcessed (const char *line);  Emit signal when a line has been processed. ;  ; virtual void Lower ();  ; void ls (Option_t *option="""") const override;  Show available sessions. ;  ; Bool_t NoLogoOpt () const;  ; Bool_t NoLogOpt () const;  ; virtual void Open ();  ; void OpenForumTopic (const TString &type);  It opens a Forum topic in a web browser with prefilled ROOT version. ;  ; void OpenGitHubIssue (const TString &type);  It opens a GitHub issue in a web browser with prefilled ROOT version. ;  ; void OpenInBrowser (const TString &url);  The function generates and executes a command that loads the Doxygen URL in a browser. ;  ; void OpenReferenceGuideFor (const TString &strippedClass);  It opens the online reference guide, generated with Doxygen, for the chosen scope (class/namespace/struct) or member (method/function/ data member/enumeration/enumerator. ;  ; virtual Longptr_t ProcessFile (const char *file, Int_t *error=nullptr, Bool_t keep=kFALSE);  Process a file containing a C++ macro. ;  ; Bool_t QuitOpt () const;  ; virtual void Raise ();  ; virtual void RemoveIdleTimer ();  Remove idle timer. Normally called via TROOT::Idle(0). ;  ; Bool_t ReturnFromRun () const;  ; virtual void ReturnPressed (char *text);  Emit signal when return key was pressed. ;  ; virtual void SetEchoMode (Bool_t mode);  Set console echo mode: ;  ; virtual void SetIdleTimer (UInt_t idleTimeInSec, const char *command);  Set the command to be executed after the system has been idle for idleTimeInSec seconds. ;  ; void SetReturnFromRun (Bool_t ret);  ; virtual void Show ();  ; virtual void StartIdleing ();  Called when system starts idleing. ;  ; virtual void StopIdleing ();  Called when system stops idleing. ;  ; void StreamerNVirtual (TBuffer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTApplicationServer.html:4627,guid,guide,4627,doc/master/classTApplicationServer.html,https://root.cern,https://root.cern/doc/master/classTApplicationServer.html,1,['guid'],['guide']
Usability,"ialize the graphics environment. ;  ; TObjArray * InputFiles () const;  ; virtual Bool_t IsCmdThread ();  ; Bool_t IsRunning () const;  ; virtual void KeyPressed (Int_t key);  Emit signal when console keyboard key was pressed. ;  ; virtual void LineProcessed (const char *line);  Emit signal when a line has been processed. ;  ; virtual void Lower ();  ; void ls (Option_t *option="""") const override;  Show available sessions. ;  ; Bool_t NoLogoOpt () const;  ; Bool_t NoLogOpt () const;  ; virtual void Open ();  ; void OpenForumTopic (const TString &type);  It opens a Forum topic in a web browser with prefilled ROOT version. ;  ; void OpenGitHubIssue (const TString &type);  It opens a GitHub issue in a web browser with prefilled ROOT version. ;  ; void OpenInBrowser (const TString &url);  The function generates and executes a command that loads the Doxygen URL in a browser. ;  ; void OpenReferenceGuideFor (const TString &strippedClass);  It opens the online reference guide, generated with Doxygen, for the chosen scope (class/namespace/struct) or member (method/function/ data member/enumeration/enumerator. ;  ; virtual Longptr_t ProcessFile (const char *file, Int_t *error=nullptr, Bool_t keep=kFALSE);  Process a file containing a C++ macro. ;  ; virtual Longptr_t ProcessLine (const char *line, Bool_t sync=kFALSE, Int_t *error=nullptr);  Process a single command line, either a C++ statement or an interpreter command starting with a ""."". ;  ; Bool_t QuitOpt () const;  ; virtual void Raise ();  ; virtual void RemoveIdleTimer ();  Remove idle timer. Normally called via TROOT::Idle(0). ;  ; Bool_t ReturnFromRun () const;  ; virtual void ReturnPressed (char *text);  Emit signal when return key was pressed. ;  ; virtual void Run (Bool_t retrn=kFALSE);  Main application eventloop. Calls system dependent eventloop via gSystem. ;  ; virtual void SetEchoMode (Bool_t mode);  Set console echo mode: ;  ; virtual void SetIdleTimer (UInt_t idleTimeInSec, const char *command);  Set the c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGApplication.html:3264,guid,guide,3264,doc/master/classTGApplication.html,https://root.cern,https://root.cern/doc/master/classTGApplication.html,1,['guid'],['guide']
Usability,"ialize the graphics environment. ;  ; TObjArray * InputFiles () const;  ; virtual Bool_t IsCmdThread ();  ; Bool_t IsRunning () const;  ; virtual void KeyPressed (Int_t key);  Emit signal when console keyboard key was pressed. ;  ; virtual void LineProcessed (const char *line);  Emit signal when a line has been processed. ;  ; virtual void Lower ();  ; void ls (Option_t *option="""") const override;  Show available sessions. ;  ; Bool_t NoLogoOpt () const;  ; Bool_t NoLogOpt () const;  ; virtual void Open ();  ; void OpenForumTopic (const TString &type);  It opens a Forum topic in a web browser with prefilled ROOT version. ;  ; void OpenGitHubIssue (const TString &type);  It opens a GitHub issue in a web browser with prefilled ROOT version. ;  ; void OpenInBrowser (const TString &url);  The function generates and executes a command that loads the Doxygen URL in a browser. ;  ; void OpenReferenceGuideFor (const TString &strippedClass);  It opens the online reference guide, generated with Doxygen, for the chosen scope (class/namespace/struct) or member (method/function/ data member/enumeration/enumerator. ;  ; virtual Longptr_t ProcessFile (const char *file, Int_t *error=nullptr, Bool_t keep=kFALSE);  Process a file containing a C++ macro. ;  ; virtual Longptr_t ProcessLine (const char *line, Bool_t sync=kFALSE, Int_t *error=nullptr);  Process a single command line, either a C++ statement or an interpreter command starting with a ""."". ;  ; Bool_t QuitOpt () const;  ; virtual void Raise ();  ; virtual void RemoveIdleTimer ();  Remove idle timer. Normally called via TROOT::Idle(0). ;  ; Bool_t ReturnFromRun () const;  ; virtual void ReturnPressed (char *text);  Emit signal when return key was pressed. ;  ; virtual void SetEchoMode (Bool_t mode);  Set console echo mode: ;  ; virtual void SetIdleTimer (UInt_t idleTimeInSec, const char *command);  Set the command to be executed after the system has been idle for idleTimeInSec seconds. ;  ; void SetReturnFromRun (Bool_t ret);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofServ.html:7897,guid,guide,7897,doc/master/classTProofServ.html,https://root.cern,https://root.cern/doc/master/classTProofServ.html,2,['guid'],['guide']
Usability,"ialize the graphics environment. ;  ; TObjArray * InputFiles () const;  ; virtual Bool_t IsCmdThread ();  ; Bool_t IsRunning () const;  ; virtual void KeyPressed (Int_t key);  Emit signal when console keyboard key was pressed. ;  ; virtual void LineProcessed (const char *line);  Emit signal when a line has been processed. ;  ; virtual void Lower ();  ; void ls (Option_t *option="""") const override;  Show available sessions. ;  ; Bool_t NoLogoOpt () const;  ; Bool_t NoLogOpt () const;  ; virtual void Open ();  ; void OpenForumTopic (const TString &type);  It opens a Forum topic in a web browser with prefilled ROOT version. ;  ; void OpenGitHubIssue (const TString &type);  It opens a GitHub issue in a web browser with prefilled ROOT version. ;  ; void OpenInBrowser (const TString &url);  The function generates and executes a command that loads the Doxygen URL in a browser. ;  ; void OpenReferenceGuideFor (const TString &strippedClass);  It opens the online reference guide, generated with Doxygen, for the chosen scope (class/namespace/struct) or member (method/function/ data member/enumeration/enumerator. ;  ; virtual Longptr_t ProcessFile (const char *file, Int_t *error=nullptr, Bool_t keep=kFALSE);  Process a file containing a C++ macro. ;  ; virtual Longptr_t ProcessLine (const char *line, Bool_t sync=kFALSE, Int_t *error=nullptr);  Process a single command line, either a C++ statement or an interpreter command starting with a ""."". ;  ; Bool_t QuitOpt () const;  ; virtual void Raise ();  ; virtual void RemoveIdleTimer ();  Remove idle timer. Normally called via TROOT::Idle(0). ;  ; Bool_t ReturnFromRun () const;  ; virtual void ReturnPressed (char *text);  Emit signal when return key was pressed. ;  ; virtual void SetIdleTimer (UInt_t idleTimeInSec, const char *command);  Set the command to be executed after the system has been idle for idleTimeInSec seconds. ;  ; void SetReturnFromRun (Bool_t ret);  ; virtual void Show ();  ; virtual void StartIdleing ();  Called wh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRint.html:3856,guid,guide,3856,doc/master/classTRint.html,https://root.cern,https://root.cern/doc/master/classTRint.html,1,['guid'],['guide']
Usability,"iance method"" and the implementation is provided in the function FitUtil::EvaluateChi2Effective. Linear fitting:; When the fitting function is linear (contains the ++ sign) or the fitting function is a polynomial, a linear fitter is initialised. To create a linear function, use the following syntax: linear parts separated by ++ sign. Example: to fit the parameters of the function p0*x + p1*sin(x), you can create a TF1 object as TF1 *f1 = new TF1(""f1"", ""x++sin(x)"", xmin, xmax);; For such a TF1 you don't have to set the initial conditions and the linear fitter is used. Going via the linear fitter for functions, linear in parameters, gives a considerable advantage in speed. When using the linear fitting it is also possible to perform a robust fitting with the Least Trimmed Square (LTS) regression algorithm, by using the fit option ROB. See the tutorial fitLinearRobust.C. Notes on TGraph/TGraphErrors Fitting:. By using the ""effective variance"" method a simple linear regression becomes a non-linear case, which takes several iterations instead of 0 as in the linear case.; The effective variance technique assumes that there is no correlation between the x and y coordinate.; The standard chi2 (least square) method without error in the coordinates (x) can be forced by using option ""EX0""; The linear fitter doesn't take into account the errors in x. When fitting a TGraphErrors with a linear functions the errors in x will not be considered. If errors in x are important, use option ""F"" for linear function fitting.; When fitting a TGraph (i.e. no errors associated with each point), a correction is applied to the errors on the parameters with the following formula: parameter_error *= sqrt(chisquare/(ndf-1)). General Fitting documentation; See in TH1::Fit for the documentation of; Fit Result; Fit Status; Fit Statistics Box; Fitting in a Range; Setting Initial Conditions . Definition at line 1231 of file TGraph.cxx. ◆ FitPanel(). void TGraph::FitPanel ; (; ). virtual . Display a GUI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraph.html:51827,simpl,simple,51827,doc/master/classTGraph.html,https://root.cern,https://root.cern/doc/master/classTGraph.html,1,['simpl'],['simple']
Usability,"iated parameters with given values in cache.; The cache will take _ownership_of_object_ and is indexed under the given name (which does not; need to be the name of cacheObject and with given set of dependent parameters with validity for the; current values of those parameters. It can be retrieved later by callin retrieveObject(). Bool_t registerObject(const char* ownerName, const char* objectName, TObject& cacheObject, TIterator* paramIter); Register object associated with given name and given associated parameters with given values in cache.; The cache will take _ownership_of_object_ and is indexed under the given name (which does not; need to be the name of cacheObject and with given set of dependent parameters with validity for the; current values of those parameters. It can be retrieved later by callin retrieveObject(). const TObject* retrieveObject(const char* name, TClass* tclass, const RooArgSet& params); Retrieve object from cache that was registered under given name with given parameters, _if_; current parameter values match those that were stored in the registry for this object.; The return object is owned by the cache instance. const TObject* getObj(Int_t uniqueID); Retrieve payload object of cache element with given unique ID. Bool_t clearObj(Int_t uniqueID); Clear cache element with given unique ID; Retrieve payload object of cache element with given unique ID. Bool_t setObj(Int_t uniqueID, TObject* obj); Place new payload object in cache element with given unique ID. Cache; will take ownership of provided object!. void clearAll(); Clear all cache elements. void print() const. void importCacheObjects(RooExpensiveObjectCache& other, const char* ownerName, Bool_t verbose = kFALSE). Int_t size() const; { return _map.size() ; }. » Last changed: Thu Sep 23 19:59:34 2010 » Last generated: 2010-09-23 19:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooExpensiveObjectCache.html:8054,clear,clearObj,8054,root/html528/RooExpensiveObjectCache.html,https://root.cern,https://root.cern/root/html528/RooExpensiveObjectCache.html,2,['clear'],"['clearAll', 'clearObj']"
Usability,"iated parameters with given values in cache.; The cache will take _ownership_of_object_ and is indexed under the given name (which does not; need to be the name of cacheObject and with given set of dependent parameters with validity for the; current values of those parameters. It can be retrieved later by callin retrieveObject(). Bool_t registerObject(const char* ownerName, const char* objectName, TObject& cacheObject, TIterator* paramIter); Register object associated with given name and given associated parameters with given values in cache.; The cache will take _ownership_of_object_ and is indexed under the given name (which does not; need to be the name of cacheObject and with given set of dependent parameters with validity for the; current values of those parameters. It can be retrieved later by callin retrieveObject(). const TObject* retrieveObject(const char* name, TClass* tclass, const RooArgSet& params); Retrieve object from cache that was registered under given name with given parameters, _if_; current parameter values match those that were stored in the registry for this object.; The return object is owned by the cache instance. const TObject* getObj(Int_t uniqueID); Retrieve payload object of cache element with given unique ID. Bool_t clearObj(Int_t uniqueID); Clear cache element with given unique ID; Retrieve payload object of cache element with given unique ID. Bool_t setObj(Int_t uniqueID, TObject* obj); Place new payload object in cache element with given unique ID. Cache; will take ownership of provided object!. void clearAll(); Clear all cache elements. void print() const. void importCacheObjects(RooExpensiveObjectCache& other, const char* ownerName, Bool_t verbose = kFALSE). Int_t size() const; { return _map.size() ; }. » Last changed: Tue Jun 30 14:32:46 2015 » Last generated: 2015-06-30 14:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooExpensiveObjectCache.html:8628,clear,clearObj,8628,root/html602/RooExpensiveObjectCache.html,https://root.cern,https://root.cern/root/html602/RooExpensiveObjectCache.html,6,"['Clear', 'clear']","['Clear', 'clearAll', 'clearObj']"
Usability,"iated parameters with given values in cache.; The cache will take _ownership_of_object_ and is indexed under the given name (which does not; need to be the name of cacheObject and with given set of dependent parameters with validity for the; current values of those parameters. It can be retrieved later by callin retrieveObject(). Bool_t registerObject(const char* ownerName, const char* objectName, TObject& cacheObject, TIterator* paramIter); Register object associated with given name and given associated parameters with given values in cache.; The cache will take _ownership_of_object_ and is indexed under the given name (which does not; need to be the name of cacheObject and with given set of dependent parameters with validity for the; current values of those parameters. It can be retrieved later by callin retrieveObject(). const TObject* retrieveObject(const char* name, TClass* tclass, const RooArgSet& params); Retrieve object from cache that was registered under given name with given parameters, _if_; current parameter values match those that were stored in the registry for this object.; The return object is owned by the cache instance. const TObject* getObj(Int_t uniqueID); Retrieve payload object of cache element with given unique ID. Bool_t clearObj(Int_t uniqueID); Clear cache element with given unique ID; Retrieve payload object of cache element with given unique ID. Bool_t setObj(Int_t uniqueID, TObject* obj); Place new payload object in cache element with given unique ID. Cache; will take ownership of provided object!. void clearAll(); Clear all cache elements. void print() const. void importCacheObjects(RooExpensiveObjectCache& other, const char* ownerName, Bool_t verbose = kFALSE). Int_t size() const; { return _map.size() ; }. » Last changed: Tue Mar 10 17:16:31 2015 » Last generated: 2015-03-10 17:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooExpensiveObjectCache.html:8142,clear,clearObj,8142,root/html534/RooExpensiveObjectCache.html,https://root.cern,https://root.cern/root/html534/RooExpensiveObjectCache.html,6,"['Clear', 'clear']","['Clear', 'clearAll', 'clearObj']"
Usability,"ibly with different arguments every time. More...;  ; class  TGenericClassInfo;  ; class  TIOFeatures;  TIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TTree. More...;  ; class  TModuleGenerator;  ; class  TProcessExecutor;  This class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time. More...;  ; class  TReadLockGuard;  ; class  TReentrantRWLock;  ; class  TRWMutexImp;  ; class  TRWSpinLock;  ; class  TRWSpinLockReadGuard;  ; class  TRWSpinLockWriteGuard;  ; class  TSchemaRule;  ; class  TSeq;  A pseudo container class which is a generator of indices. More...;  ; class  TSequentialExecutor;  ; class  TSpinMutex;  A spin mutex class which respects the STL interface for mutexes. More...;  ; class  TThreadedObject;  A wrapper to make object instances thread private, lazily. More...;  ; class  TThreadExecutor;  This class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time. More...;  ; class  TTreeProcessorMP;  This class provides an interface to process a TTree dataset in parallel with multi-process technology. More...;  ; class  TTreeProcessorMT;  A class to process the entries of a TTree in parallel. More...;  ; class  TVirtualRWMutex;  ; class  TWriteLockGuard;  . Typedefs; using ColumnNames_t = ROOT::Detail::RDF::ColumnNames_t;  ; using ColumnNamesPtr_t = std::shared_ptr< const ColumnNames_t >;  ; typedef void(* DelArrFunc_t) (void *);  ; typedef void(* DelFunc_t) (void *);  ; typedef void(* DesFunc_t) (void *);  ; typedef void(* DirAutoAdd_t) (void *, TDirectory *);  ; using Double_v = Double_t;  ; using Float_v = Float_t;  ; using Int32_v = Int_t;  ; using Int_v = Int_t;  ; typedef std::map< std::string, ROOT::Internal::TSchemaType > MembersTypeMap_t;  ; typedef Long64_t(* MergeFunc_t) (void *, TCollection *, TFileMergeInfo *);  ; typedef void *(* NewArrFunc_t) (Lon",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v618/namespaceROOT.html:2561,simpl,simple,2561,doc/v618/namespaceROOT.html,https://root.cern,https://root.cern/doc/v618/namespaceROOT.html,2,['simpl'],['simple']
Usability,"ibraries. In this case we want to be helpful and output a; 2802/// list of the unresolved symbols. So if the loading of the created shared; 2803/// library fails, we will try to build a executable that contains the; 2804/// script. The linker should then output a list of missing symbols.; 2805///; 2806/// To support this we provide a TSystem::SetMakeExe() function, that sets the; 2807/// directive telling how to create an executable. The loader will need; 2808/// to be informed of all the libraries available. The information about; 2809/// the libraries that has been loaded by .L and TSystem::Load() is accessible; 2810/// to the script compiler. However, the information about; 2811/// the libraries that have been selected at link time by the application; 2812/// builder (like the root libraries for root.exe) are not available and need; 2813/// to be explicitly listed in fLinkedLibs (either by default or by a call to; 2814/// TSystem::SetLinkedLibs()).; 2815///; 2816/// To simplify customization we could also add to the .rootrc support for the; 2817/// variables; 2818/// ~~~ {.cpp}; 2819/// Unix.*.Root.IncludePath: -I$ROOTSYS/include; 2820/// WinNT.*.Root.IncludePath: -I%ROOTSYS%/include; 2821///; 2822/// Unix.*.Root.LinkedLibs: -L$ROOTSYS/lib -lBase ....; 2823/// WinNT.*.Root.LinkedLibs: %ROOTSYS%/lib/*.lib msvcrt.lib ....; 2824/// ~~~; 2825/// And also support for MakeSharedLibs() and MakeExe().; 2826///; 2827/// (the ... have to be replaced by the actual values and are here only to; 2828/// shorten this comment).; 2829///; 2830/// Note that the default behavior is to remove libraries when closing ROOT,; 2831/// ie TSystem::CleanCompiledMacros() is called in the TROOT destructor.; 2832/// The default behavior of .L script.C+ is the opposite one, leaving things; 2833/// after closing, without removing. In other words, .L always passes the 'k'; 2834/// option behind the scenes.; 2835 ; 2836int TSystem::CompileMacro(const char *filename, Option_t *opt,; 2837 const char",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:93069,simpl,simplify,93069,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['simpl'],['simplify']
Usability,"ic Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCachedPdf.html:44124,clear,clearCacheObject,44124,root/html532/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsCachedPdf.html,3,['clear'],['clearCacheObject']
Usability,"ic Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; Float_t*TAttBBox::AssertBBox(); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElement*TEveElement::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Conne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveStraightLineSet.html:2977,Clear,Clear,2977,root/html532/TEveStraightLineSet.html,https://root.cern,https://root.cern/root/html532/TEveStraightLineSet.html,4,['Clear'],['Clear']
Usability,"ic Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; Float_t*TAttBBox::AssertBBox(); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElement*TEveElement::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTEveStraightLineSet::ComputeBBox(); Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveScalableStraightLineSet.html:3078,Clear,Clear,3078,root/html532/TEveScalableStraightLineSet.html,https://root.cern,https://root.cern/root/html532/TEveScalableStraightLineSet.html,8,['Clear'],['Clear']
Usability,"ic Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoNodeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for node editor. ~TGeoNodeEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to a editable object. void DoSelectMother(); Select the mother volume. void DoSelectVolume(); Select the volume. void DoSelectMatrix(); Select the matrix. void DoEditMother(); Edit the mother volume. void DoEditVolume(); Edit selected volume. void DoEditMatrix(); Edit selected material. void DoNodeName(); Change node name. void DoNodeNumber(); Change node copy number. void DoApply(); Slot for applying modifications. void DoUndo(); Slot for undoing last operation. TGeoNodeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-02 16:02; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoNodeEditor.html:22708,undo,undoing,22708,root/html604/TGeoNodeEditor.html,https://root.cern,https://root.cern/root/html604/TGeoNodeEditor.html,2,['undo'],['undoing']
Usability,"ic Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoNodeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for node editor. ~TGeoNodeEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to a editable object. void DoSelectMother(); Select the mother volume. void DoSelectVolume(); Select the volume. void DoSelectMatrix(); Select the matrix. void DoEditMother(); Edit the mother volume. void DoEditVolume(); Edit selected volume. void DoEditMatrix(); Edit selected material. void DoNodeName(); Change node name. void DoNodeNumber(); Change node copy number. void DoApply(); Slot for applying modifications. void DoUndo(); Slot for undoing last operation. TGeoNodeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:02; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoNodeEditor.html:22708,undo,undoing,22708,root/html602/TGeoNodeEditor.html,https://root.cern,https://root.cern/root/html602/TGeoNodeEditor.html,2,['undo'],['undoing']
Usability,"ic Member Functions |; Protected Member Functions |; Private Attributes |; List of all members ; TMVA::VariableImportance Class ReferenceTMVA. . Definition at line 44 of file VariableImportance.h. Public Member Functions;  VariableImportance (DataLoader *loader);  ;  ~VariableImportance ();  ; virtual void Evaluate ();  Virtual method to be implemented with your algorithm. ;  ; const VariableImportanceResult & GetResults () const;  ; VIType GetType ();  ; virtual TClass * IsA () const;  ; void SetType (VIType type);  ; virtual void Streamer (TBuffer &);  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TMVA::Envelope;  ~Envelope ();  Default destructor. ;  ; virtual void BookMethod (TString methodname, TString methodtitle, TString options="""");  Method to book the machine learning method to perform the algorithm. ;  ; virtual void BookMethod (Types::EMVA method, TString methodtitle, TString options="""");  Method to book the machine learning method to perform the algorithm. ;  ; DataLoader * GetDataLoader ();  Method to get the pointer to TMVA::DataLoader object. ;  ; TFile * GetFile ();  Method to get the pointer to TFile object. ;  ; std::vector< OptionMap > & GetMethods ();  Method get the Booked methods in a option map object. ;  ; Bool_t HasMethod (TString methodname, TString methodtitle);  function to check methods booked ;  ; Bool_t IsModelPersistence ();  Method to see if the algorithm model is saved in xml or serialized files. ;  ; Bool_t IsSilentFile ();  Method to see if a file is available to save results. ;  ; Bool_t IsVerbose ();  Method to see if the algorithm should print extra information. ;  ; virtual void ParseOptions ();  Method to parse the internal option string. ;  ; void SetDataLoader (DataLoader *dalaloader);  Method to set the pointer to TMVA::DataLoader object. ;  ; void SetFile (TFile *file);  Method to set the pointer to TFile object, with a writ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1VariableImportance.html:1232,learn,learning,1232,doc/master/classTMVA_1_1VariableImportance.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1VariableImportance.html,1,['learn'],['learning']
Usability,"ic Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static std::unique_ptr< RooAbsPdf > create (RooAbsPdf &pdf, RooAbsData const &data, double precision);  Creates a wrapping RooBinSamplingPdf if appropriate. ;  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from RooAbsPdf; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static RooNumGenConfig * defaultGeneratorConfig ();  Returns the default numeric MC generator configuration for all RooAbsReals. ;  ; static int verboseEval ();  Return global level of verbosity for p.d.f. evaluations. ;  ; static void verboseEval (Int_t stat);  Change global level of verbosity for p.d.f. evaluations. ;  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinSamplingPdf.html:59875,clear,clearEvalErrorLog,59875,doc/master/classRooBinSamplingPdf.html,https://root.cern,https://root.cern/doc/master/classRooBinSamplingPdf.html,1,['clear'],['clearEvalErrorLog']
Usability,"ic Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoCombiTransEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for combi matrix editor. ~TGeoCombiTransEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected combi matrix. void DoName(); Slot for name. void DoRotPhi(); Slot for phi (Euler X convention). void DoRotTheta(); Slot for theta (Euler X convention). void DoRotPsi(); Slot for psi (Euler X convention). void DoRotAngle(); Slot for additional rotation about one axis. Bool_t DoParameters(); Slot for checking parameters. void DoApply(); Slot for applying modifications. void DoCancel(); Slot for cancelling last un-applied operations. void DoModified(); Slot for notifying changes. void DoUndo(); Slot for undoing last changes. void DoDx(); Slot for X. void DoDy(); Slot for Y. void DoDz(); Slot for Z. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoCombiTransEditor.html:22298,undo,undoing,22298,root/html534/TGeoCombiTransEditor.html,https://root.cern,https://root.cern/root/html534/TGeoCombiTransEditor.html,2,['undo'],['undoing']
Usability,"ic TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Private Member Functions; MsgLogger & Log () const;  ; TString SecToText (Double_t, Bool_t) const;  pretty string output ;  . Private Attributes; Bool_t fColourfulOutput;  flag for use of colors ;  ; MsgLogger * fLogger;  ! the output logger ;  ; Int_t fNcounts;  reference number of ""counts"" ;  ; Bool_t fOutputToFile;  ; TString fPrefix;  prefix for outputs ;  ; Int_t fPreviousProgress;  ; TString fPreviousTimeEstimate;  ; Int_t fProgressBarStringLength;  . Static Private Attributes; static const TString fgClassName = ""Timer"";  used for output ;  ; static const Int_t fgNbins = 16;  number of bins in progress bar ;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to Error",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Timer.html:12506,progress bar,progress bar,12506,doc/master/classTMVA_1_1Timer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Timer.html,1,['progress bar'],['progress bar']
Usability,"ic TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SimpleInterval(const char* name = 0); Default constructor. SimpleInterval(const RooStats::SimpleInterval& other, const char* name); fParameters.add( other.fParameters );. operator=(const RooStats::SimpleInterval& other). SimpleInterval(const char* name, const RooRealVar& var, Double_t lower, Double_t upper, Double_t cl); Alternate constructor. ~SimpleInterval(); Destructor. Bool_t IsInInterval(const RooArgSet& ) const. RooArgSet* GetParameters() const; return cloned list of parameters. Bool_t CheckParameters(const RooArgSet& ) const. explicit SimpleInterval(const char* name = 0); default constructors. void SetConfidenceLevel(Double_t ); set the confidence level for the interval. Simple interval is defined at construction time so this function; has no effect. {}. Double_t ConfidenceLevel() const; return the confidence interval. {return fConfidenceLevel;}. Double_t LowerLimit(); return the interval lower limit. {return fLowerLimit;}. Double_t UpperLimit(); return the interval upper limit. {return fUpperLimit;}. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id$ » Last generated: 2015-06-02 15:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooStats__SimpleInterval.html:7788,Simpl,SimpleInterval,7788,root/html604/RooStats__SimpleInterval.html,https://root.cern,https://root.cern/root/html604/RooStats__SimpleInterval.html,2,['Simpl'],"['Simple', 'SimpleInterval']"
Usability,"ic TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SimpleInterval(const char* name = 0); Default constructor. SimpleInterval(const RooStats::SimpleInterval& other, const char* name); fParameters.add( other.fParameters );. operator=(const RooStats::SimpleInterval& other). SimpleInterval(const char* name, const RooRealVar& var, Double_t lower, Double_t upper, Double_t cl); Alternate constructor. ~SimpleInterval(); Destructor. Bool_t IsInInterval(const RooArgSet& ) const. RooArgSet* GetParameters() const; return cloned list of parameters. Bool_t CheckParameters(const RooArgSet& ) const. explicit SimpleInterval(const char* name = 0); default constructors. void SetConfidenceLevel(Double_t ); set the confidence level for the interval. Simple interval is defined at construction time so this function; has no effect. {}. Double_t ConfidenceLevel() const; return the confidence interval. {return fConfidenceLevel;}. Double_t LowerLimit(); return the interval lower limit. {return fLowerLimit;}. Double_t UpperLimit(); return the interval upper limit. {return fUpperLimit;}. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id$ » Last generated: 2015-06-30 14:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__SimpleInterval.html:7788,Simpl,SimpleInterval,7788,root/html602/RooStats__SimpleInterval.html,https://root.cern,https://root.cern/root/html602/RooStats__SimpleInterval.html,2,['Simpl'],"['Simple', 'SimpleInterval']"
Usability,"ic Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*TGProgressBar::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGGC*TGProgressBar::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGVProgressBar(const TGWindow* p = 0, UInt_t w = kProgressBarTextWidth, UInt_t h = 4, Pixel_t back = GetWhitePixel(), Pixel_t barcolor = GetDefaultSelectedBackground(), GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t options = kDoubleBorder|kSunkenFrame); cconstructor. TGVProgressBar(const TGWindow* p, TGProgressBar::EBarType type, UInt_t h); Simple constructor allow you to create either a standard progress; bar, or a more fancy progress bar (fancy means: double sized border,; white background and a bit wider to allow for text to be printed; in the bar. void DoRedraw(); Draw vertical progress bar. void SavePrimitive(ostream& out, Option_t* option = """"); Save a vertical progress bar as a C++ statement(s) on output stream out. void Percent(Bool_t ); { fPercent = on; fClient->NeedRedraw(this); }. void ShowPos(Bool_t ); { fShowPos = on; fClient->NeedRedraw(this); }. TGDimension GetDefaultSize() const; { return TGDimension(fWidth, fBarWidth); }. virtual ~TGVProgressBar(); { }. » Author: Fons Rademakers 10/10/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-03-14 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGVProgressBar.html:20540,progress bar,progress bar,20540,root/html534/TGVProgressBar.html,https://root.cern,https://root.cern/root/html534/TGVProgressBar.html,7,"['Simpl', 'progress bar']","['Simple', 'progress bar']"
Usability,"ic cache and greater than 0.0 to enable cache. This value can be overridden by the environment variable ROOT_TTREECACHE_SIZE.; The resource variable TTreeCache.Prefill sets the default TTreeCache prefilling type. The prefill type may be: 0 for no prefilling and 1 to prefill all the branches. It can be overridden by the environment variable ROOT_TTREECACHE_PREFILL; In particular the default can be set back to the same as in version 5 by setting TTreeCache.Size (or ROOT_TTREECACHE_SIZE) and TTreeCache.Prefill (or ROOT_TTREECACHE_PREFILL) both to zero.; TTree methods which are expected to modify a cache, like AddBranchToCache, will attempt to setup a cache of default size if one does not exist, irrespective of whether the auto cache creation is enabled. Additionally several methods giving control of the cache have changed return type from void to Int_t, to be able to return a code to indicate if there was an error.; Usually TTree::SetCacheSize will no longer reset the list of branches to be cached (either set or previously learnt) nor restart the learning phase. The learning phase is restarted when a new cache is created, e.g. after having removed a cache with SetCacheSize(0).; TSelectorDraw; The axis titles in case of a x:y:z plot with the option COLZ were not correct.; TParallelCoordVar; Change the format used to print the variables limit for ||-Coord to %g. It was %6.4f before.; Histogram Libraries; TFormula. New version of the TFormula class based on Cling. Formula expressions are now used to create functions which are passed to Cling to be Just In Time compiled. The expression is therefore compiled using Clang/LLVVM which will give execution time as compiled code and in addition correctness of the result obtained.; This class is not 100% backward compatible with the old TFormula class, which is still available in ROOT as =ROOT::v5::TFormula=. Some of the TFormula member funtions available in version 5, such as =Analyze= and =AnalyzeFunction= are not available in t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:14010,learn,learnt,14010,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,2,['learn'],"['learning', 'learnt']"
Usability,"ic player, using ROOT geometry class ;  na49.CThis file has been generated automatically via the root utility toroot from an interactive version of GEANT (see ROOT class TGeometry header for an example of use) This shows an example of the old geometry package (now obsolete) ;  na49geomfile.CBefore executing this macro, the file makegeometry.C must have been executed ;  na49view.CThis macro generates with 2 views of the NA49 detector using the old obsolete geometry package ;  parallel_world.CMisaligning geometry generate in many cases overlaps, due to the idealization of the design and the fact that in real life movements of the geometry volumes have constraints and are correlated ;  RadioNuclides.CMacro that demonstrates usage of radioactive elements/materials/mixtures with TGeo package ;  robot.CDrawing a famous Korean robot, TaekwonV, using ROOT geometry class ;  rootgeom.CDefinition of a simple geometry (the 4 ROOT characters) ;  runplugin.CCreates and runs a simple iterator plugin connected to TGeoPainter iterator ;  shapes.CThe old geometry shapes (see script geodemo.C) ;  shapesAnim.CMacro illustrating how to animate a geometry picture using a Timer ;  south_gate.CDrawing a famous Korean gate, the South gate, called Namdeamoon in Korean, using ROOT geometry class ;  station1.CDrawing a space station, using ROOT geometry class ;  station2.CDrawing a space station (version 2), using ROOT geometry class ;  tank.CDrawing a fine tank, using ROOT geometry class ;  xtruDraw.CDraw a ""representative"" TXTRU shape ;  xtruSamples.CDraw a sample of TXTRU shapes some convex, concave (and possibly malformed) ;  ► gl;  customcolorgl.h;  glbox.CDisplay a 3D histogram using GL (box option) ;  gldemos.CMenu for running GL demos ;  glh3c.CDisplay a 3D histogram using GL (box option) ;  glparametric.CShow rendering of parametric surfaces ;  glparametrics2.CShow rendering of parametric surfaces ;  glrose.CRender a TF2 looking like a rose ;  glsurfaces.CVarious surfaces rendered with",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:110263,simpl,simple,110263,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,5,['simpl'],['simple']
Usability,"ic:. virtual~TF2(); voidTObject::AbstractMethod(const char* method) const; static voidTF1::AbsValue(Bool_t reject = kTRUE); virtual voidTFormula::Analyze(const char* schain, Int_t& err, Int_t offset = 0); virtual Bool_tTFormula::AnalyzeFunction(TString& chaine, Int_t& err, Int_t offset = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTF1::Browse(TBrowser* b); static voidTF1::CalcGaussLegendreSamplingPoints(Int_t num, Double_t* x, Double_t* w, Double_t eps = 3.0E-11); virtual Double_tTF1::CentralMoment(Double_t n, Double_t a, Double_t b, const Double_t* params = 0, Double_t epsilon = 9.9999999999999995E-7); virtual Double_tCentralMoment2(Double_t nx, Double_t ax, Double_t bx, Double_t ny, Double_t ay, Double_t by, Double_t epsilon = 9.9999999999999995E-7); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTFormula::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Int_tTFormula::Compile(const char* expression = """"); virtual voidCopy(TObject& f2) const; virtual Double_tCovariance2XY(Double_t ax, Double_t bx, Double_t ay, Double_t by, Double_t epsilon = 9.9999999999999995E-7); virtual TH1*CreateHistogram(); virtual char*TFormula::DefinedString(Int_t code); virtual Double_tTFormula::DefinedValue(Int_t code); virtual Int_tTFormula::DefinedVariable(TString& variable, Int_t& action); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tTF1::Derivative(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; virtual Double_tTF1::Derivative2(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; virtual Double_tTF1::Derivative3(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; static Double_tTF1::DerivativeError(); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TF2.html:1419,Clear,Clear,1419,root/html602/TF2.html,https://root.cern,https://root.cern/root/html602/TF2.html,1,['Clear'],['Clear']
Usability,"ical User Interface; 10 Folders and Tasks; 11 Input/Output; 12 Trees; 13 Math Libraries in ROOT; 14 Linear Algebra in ROOT; 15 Adding a Class; 16 Collection Classes; 17 Physics Vectors; 18 The Geometry Package; 19 Python Interface; 20 The Tutorials and Tests; 21 Example Analysis; 22 Networking; 23 Threads; 24 PROOF: Parallel Processing; 25 Writing a Graphical User Interface; 26 The Signal/Slot Communication Mechanism; 27 Automatic HTML Documentation; 28 Appendix A: Install and Build ROOT. WARNING: This documentation is not maintained anymore. Some part might be obsolete or wrong, some part might be missing but still some valuable information can be found there. Instead please refer to the ROOT Reference Guide and the ROOT Manual. If you think some information should be imported in the ROOT Reference Guide or in the ROOT Manual, please post your request to the ROOT Forum or via a Github Issue. Preface; In late 1994, we decided to learn and investigate Object Oriented programming and C++ to better judge the suitability of these relatively new techniques for scientific programming. We knew that there is no better way to learn a new programming environment than to use it to write a program that can solve a real problem. After a few weeks, we had our first histogramming package in C++. A few weeks later we had a rewrite of the same package using the, at that time, very new template features of C++. Again, a few weeks later we had another rewrite of the package without templates since we could only compile the version with templates on one single platform using a specific compiler. Finally, after about four months we had a histogramming package that was faster and more efficient than the well-known FORTRAN based HBOOK histogramming package. This gave us enough confidence in the new technologies to decide to continue the development. Thus was born ROOT. Since its first public release at the end of 1995, ROOT has enjoyed an ever-increasing popularity. Currently it is being ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1164,learn,learn,1164,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['learn'],['learn']
Usability,"ically sets 'mvf=1'; it is still possible to set 'mvf=11'; to save results after each packet. The separator from the next option is either a ' ' or a ';'. All recognized settings are removed from the input string opt.; If action == 0, set up the output file accordingly, if action == 1 clean related; output file settings.; If the final target file is local then 'target' is set to the final local path; when action == 0 and used to retrieve the file with TFile::Cp when action == 1. Output file settings are in the form. <previous_option>of=name <next_option>; <previous_option>outfile=name,...;<next_option>. The separator from the next option is either a ' ' or a ';'; Called interanally by TProof::Process. Returns 0 on success, -1 on error. void SetFeedback(TString& opt, TString& optfb, Int_t action); Extract from opt in optfb information about wanted feedback settings.; Feedback are removed from the input string opt.; If action == 0, set up feedback accordingly, if action == 1 clean related; feedback settings (using info in optfb, if available, or reparsing opt). Feedback requirements are in the form. <previous_option>fb=name1,name2,name3,... <next_option>; <previous_option>feedback=name1,name2,name3,...;<next_option>. The special name 'stats' triggers feedback about events and packets.; The separator from the next option is either a ' ' or a ';'.; Called interanally by TProof::Process. Long64_t Process(TDSet* dset, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Process a data set (TDSet) using the specified selector (.C) file or; Tselector object; Entry- or event-lists should be set in the data set object using; TDSet::SetEntryList.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. Long64_t Process(TFileCollection* fc, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Process a data set (TFileCollection) using the specified selector (.C)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:51063,feedback,feedback,51063,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,12,['feedback'],['feedback']
Usability,"ically the; baskets from the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - TTree::SetCacheSize is called for the first time.; - TTree::SetCacheSize is called a second time with a different size.; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of Trees with several; hundred or thousand",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCache.html:1365,learn,learning,1365,root/html528/TTreeCache.html,https://root.cern,https://root.cern/root/html528/TTreeCache.html,4,['learn'],['learning']
Usability,ication of ntuple1.C example ;  sqlcreatedb.CCreate a runcatalog table in a MySQL test database ;  sqlfilldb.CFill run catalog with nfiles entries ;  sqlselect.C;  sqltables.CThis is an example illustrating how the TSQLFile class can be used ;  ► thread;  stressThreadPool.CUsage: ;  threadPool.CUsage: ;  threads.CExample of a simple script creating 3 threads ;  threadsh1.CExample of a simple script creating 3 threads ;  threadsh2.CExample of a simple script creating 2 threads each with one canvas ;  ► tmva;  ► envelope;  classification.C;  ► keras;  ApplicationClassificationKeras.py;  ApplicationRegressionKeras.py;  ClassificationKeras.py;  GenerateModel.py;  LaunchClasGUI.C;  LaunchMultiGUI.C;  LaunchRegGUI.C;  MulticlassKeras.py;  RegressionKeras.py;  createData.CPlot the variables ;  TMVAClassification.C This macro provides examples for the training and testing of the TMVA classifiers ;  TMVAClassificationApplication.C This macro provides a simple example on how to use the trained classifiers within an analysis module ;  TMVAClassificationCategory.C This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode ;  TMVAClassificationCategoryApplication.C This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ;  TMVACrossValidation.C This example explains how to use the cross-validation feature of TMVA ;  TMVAGAexample.C This exectutable gives an example of a very simple use of the genetic algorithm of TMVA ;  TMVAGAexample2.C This exectutable gives an example of a very simple use of the genetic algorithm of TMVA ;  TMVAMulticlass.C This macro provides a simple example for the training and testing of the TMVA multiclass classification ;  TMVAMulticlassApplication.C This macro provides a simple example on how to use the trained multiclass classifiers within an analysis module ;  TMVAMultipleBackgroundExample.C This example shows the training of signal with three ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:155769,simpl,simple,155769,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,1,['simpl'],['simple']
Usability,"ics to freeze choice of observables; for interpretation of fraction coefficients. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of range; for interpretation of fraction coefficients. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Return specialized context to efficiently generate toy events from RooAddPdfs. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Direct generation is safe if all components say so. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; Return pseud-code that indicates if all components can do internal generation (1) or not (0). void generateEvent(Int_t code); This function should never be called as RooAddModel implements a custom generator context. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooAddModel to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooAddModel(*this,newname) ; }. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force RooRealIntegral to offer all observables for internal integration. Bool_t selfNormalized() const; Model is self normalized when used as p.d.f. ExtendMode extendMode() const; Return extended mode capabilities. Double_t expectedEvents(const RooArgSet* nset). const RooArgList& pdfList() const; Return list of component p.d.fs. const RooArgList& coefList() const; Return list of coefficients of component p.d.f.s. CacheElem* getProjCache(const RooArgSet* nset, const RooArgSet* iset = 0, const char* rangeName = 0) const. » Last changed: Mon Dec 7 13:45:55 2009 » Last generated: 2009-12-07 13:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAddModel.html:47558,intuit,intuitively,47558,root/html526/RooAddModel.html,https://root.cern,https://root.cern/root/html526/RooAddModel.html,1,['intuit'],['intuitively']
Usability,"ictionary-like syntax, you can also get objects with names that don’t qualify as a Python variable. Here is a short demo:; import ROOT. with ROOT.TFile.Open(""my_file.root"", ""RECREATE"") as my_file:. # Populate the TFile with simple objects.; my_file.WriteObject(ROOT.std.string(""hello world""), ""my_string""); my_file.WriteObject(ROOT.vector[""int""]([1, 2, 3]), ""my vector""). print(my_file[""my_string""]) # new syntax; print(my_file.my_string) # old deprecated syntax. # With the dictionary syntax, you can also use names that don't qualify as; # a Python variable:; print(my_file[""my vector""]); # print(my_file.my vector) # the old syntax would not work here!; The old pythonization with the __getattr__ syntax still works, but emits a deprecation warning and will be removed from ROOT 6.34.; Removal of Python 2 support; ROOT does no longer support Python 2. The minimum Python version necessary to use ROOT in a Python application is 3.8. As a consequence, any reference to Python 2 in ROOT code was removed and certain configuration options are no longer usable, e.g. root-config --python2-version; cmake -Dpyroot-python2. The cmake build system now looks for the standard Python3 package and previously custom Python-related cmake variables are now just the ones automatically produced by cmake (see https://cmake.org/cmake/help/latest/module/FindPython.html).; More usage of the public cppyy API; Many implementation details of the ROOT pythonizations were moved from C++ functions to pure Python bindings using the public cppyy API. This helps in the integration with the tool but also improves code efficiency and memory usage.; Class Reference Guide. Define missing doxygen groups.; Fix a few typos in the THStack documentation.; Small fixes in the THistPainter documentation.; Improve the TColor documentation: use modern C++ in the examples.; Make sure the python examples do not generate wrong namespaces in the documentation.; The dataframe tutorials json spec files were not displayed proper",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:22703,usab,usable,22703,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,1,['usab'],['usable']
Usability,"icular case where volume families are used is when we want; that a volume positioned inside a container to match one ore more container; limits. Suppose we want to position the same box inside 2 different volumes; and we want the Z size to match the one of each container:. TGeoVolume *container1 = gGeoManager->MakeBox(""C1"", imed, 10,10,30);; TGeoVolume *container2 = gGeoManager->MakeBox(""C2"", imed, 10,10,20);; TGeoVolume *pvol = gGeoManager->MakeBox(""PVOL"", jmed, 3,3,-1);; container1->AddNode(pvol, 1);; container2->AddNode(pvol, 1);. Note that the third parameter of PVOL is negative, which does not make sense; as half-length on Z. This is interpreted as: when positioned, create a box; replacing all invalid parameters with the corresponding dimensions of the; container. This is also internally handled by the TGeoVolumeMulti class, which; does not need to be instantiated by users. Dividing volumes. Volumes can be divided according a pattern. The most simple division can; be done along one axis, that can be: X, Y, Z, Phi, Rxy or Rxyz. Let's take; the most simple case: we would like to divide a box in N equal slices along X; coordinate, representing a new volume family. Supposing we already have created; the initial box, this can be done like:. TGeoVolume *slicex = box->Divide(""SLICEX"", 1, N);. where SLICE is the name of the new family representing all slices and 1 is the; slicing axis. The meaning of the axis index is the following: for all volumes; having shapes like box, trd1, trd2, trap, gtra or para - 1,2,3 means X,Y,Z; for; tube, tubs, cone, cons - 1 means Rxy, 2 means phi and 3 means Z; for pcon and; pgon - 2 means phi and 3 means Z; for spheres 1 means R and 2 means phi.; In fact, the division operation has the same effect as positioning volumes; in a given order inside the divided container - the advantage being that the; navigation in such a structure is much faster. When a volume is divided, a; volume family corresponding to the slices is created. In case all",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoVolume.html:13029,simpl,simple,13029,root/html534/TGeoVolume.html,https://root.cern,https://root.cern/root/html534/TGeoVolume.html,18,['simpl'],['simple']
Usability,"icular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - A TTree automatically creates a cache; - TTree::SetCacheSize is called for the first time.; - TTree::SetCacheSize is called a second time with a different size.; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of Trees with several; hundred or thousand branches.; When writing, this does not generate a performance problem because branch; buffers are always written sequentially and the OS is in general clever enough; to flush the data to the output file when a few MBytes of data have to be writ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:1672,learn,learning,1672,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,4,['learn'],['learning']
Usability,"id *parent)=0Read the information and the weights about the layer from XML node.; TMVA::DNN::VGeneralLayer::UpdateBiasGradientsvoid UpdateBiasGradients(const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate)Updates the bias gradients, given some other weight gradients and learning rate.Definition GeneralLayer.h:448; TMVA::DNN::VGeneralLayer::SetBatchSizevoid SetBatchSize(size_t batchSize)Setters.Definition GeneralLayer.h:217; TMVA::DNN::VGeneralLayer::CopyWeightsvoid CopyWeights(const std::vector< Matrix_t > &otherWeights)Copies the weights provided as an input.Definition GeneralLayer.h:458; TMVA::DNN::VGeneralLayer::fBatchSizesize_t fBatchSizeBatch size used for training and evaluation.Definition GeneralLayer.h:59; TMVA::DNN::VGeneralLayer::AddWeightsXMLTovirtual void AddWeightsXMLTo(void *parent)=0Writes the information and the weights about the layer in an XML node.; TMVA::DNN::VGeneralLayer::UpdateWeightsvoid UpdateWeights(const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate)Updates the weights, given the gradients and the learning rate,.Definition GeneralLayer.h:418; TMVA::DNN::VGeneralLayer::Matrix_ttypename Architecture_t::Matrix_t Matrix_tDefinition GeneralLayer.h:54; TMVA::DNN::VGeneralLayer::GetBiasGradientsconst std::vector< Matrix_t > & GetBiasGradients() constDefinition GeneralLayer.h:190; TMVA::DNN::VGeneralLayer::SetInputDepthvoid SetInputDepth(size_t inputDepth)Definition GeneralLayer.h:218; TMVA::DNN::VGeneralLayer::GetWeightsconst std::vector< Matrix_t > & GetWeights() constDefinition GeneralLayer.h:172; TMVA::DNN::VGeneralLayer::GetDepthsize_t GetDepth() constDefinition GeneralLayer.h:167; TMVA::DNN::VGeneralLayer::GetWeightsstd::vector< Matrix_t > & GetWeights()Definition GeneralLayer.h:173; TMVA::DNN::VGeneralLayer::fWidthsize_t fWidthThe width of this layer.Definition GeneralLayer.h:67; TMVA::DNN::VGeneralLayer::fInitEInitialization fInitThe initialization method.Definition GeneralLayer.h:80; TMVA::DNN:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GeneralLayer_8h_source.html:30194,learn,learningRate,30194,doc/master/GeneralLayer_8h_source.html,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html,2,['learn'],"['learning', 'learningRate']"
Usability,"id *receiver, const char *slot);  Create connection between sender and receiver. ;  ;  Static Protected Attributes inherited from TQObject; static Bool_t fgAllSignalsBlocked = kFALSE;  flag used for suppression of signals ;  . #include <TQCommand.h>. Inheritance diagram for TQCommand:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TQCommand() [1/3]. TQCommand::TQCommand ; (; const char * ; clname = nullptr, . void * ; obj = nullptr, . const char * ; redo = nullptr, . const char * ; undo = nullptr . ). Constructor. ; Input parameters:; clname - class name.; obj - an object; redo - method or function to do/redo operation; undo - method or function to undo operation. Comments:; if either clname or obj is NULL that means that redo/undo is function; to specify default arguments for redo/undo method/function '=' must precede to argument value. Example: TQCommand(""TPad"", gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");; undo method can be same as redo one. In that case undo parameter can be omitted.; Example: TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. Definition at line 168 of file TQCommand.cxx. ◆ TQCommand() [2/3]. TQCommand::TQCommand ; (; TObject * ; obj, . const char * ; redo = nullptr, . const char * ; undo = nullptr . ). Constructor. ; Input parameters:; obj - an object; redo - method or function to do/redo operation; undo - method or function to undo operation. Comments: to specify default arguments for redo/undo method/function '=' must precede to argument value.; Example: TQCommand(gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");; undo method can be same as redo one. In that case ""undo"" can parameter be omitted.; Example: TQCommand(gPad, ""SetFillStyle(Style_t)"");. Definition at line 199 of file TQCommand.cxx. ◆ TQCommand() [3/3]. TQCommand::TQCommand ; (; const TQCommand & ; com). Copy constructor. ; Definition at line 209 of file TQCommand.cxx. ◆ ~TQComma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:32405,undo,undo,32405,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['undo'],['undo']
Usability,"id * ; wghtnode). virtual . Implements TMVA::MethodBase.; Definition at line 551 of file MethodKNN.cxx. ◆ Streamer(). virtual void TMVA::MethodKNN::Streamer ; (; TBuffer & ; ). virtual . Reimplemented from TMVA::MethodBase. ◆ StreamerNVirtual(). void TMVA::MethodKNN::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 143 of file MethodKNN.h. ◆ Train(). void TMVA::MethodKNN::Train ; (; void ; ). virtual . kNN training ; Implements TMVA::MethodBase.; Definition at line 234 of file MethodKNN.cxx. ◆ WriteWeightsToStream(). void TMVA::MethodKNN::WriteWeightsToStream ; (; TFile & ; rf); const. save weights to ROOT file ; Definition at line 678 of file MethodKNN.cxx. Member Data Documentation. ◆ fBalanceDepth. Int_t TMVA::MethodKNN::fBalanceDepth. private . number of binary tree levels used for balancing tree ; Definition at line 124 of file MethodKNN.h. ◆ fEvent. kNN::EventVec TMVA::MethodKNN::fEvent. private . ! (untouched) events used for learning ; Definition at line 136 of file MethodKNN.h. ◆ fKernel. TString TMVA::MethodKNN::fKernel. private . =""Gaus"",""Poln"" - kernel type for smoothing ; Definition at line 129 of file MethodKNN.h. ◆ fLDA. LDA TMVA::MethodKNN::fLDA. private . ! Experimental feature for local knn analysis ; Definition at line 138 of file MethodKNN.h. ◆ fModule. kNN::ModulekNN* TMVA::MethodKNN::fModule. private . ! module where all work is done ; Definition at line 121 of file MethodKNN.h. ◆ fnkNN. Int_t TMVA::MethodKNN::fnkNN. private . number of k-nearest neighbors ; Definition at line 123 of file MethodKNN.h. ◆ fScaleFrac. Float_t TMVA::MethodKNN::fScaleFrac. private . fraction of events used to compute variable width ; Definition at line 126 of file MethodKNN.h. ◆ fSigmaFact. Float_t TMVA::MethodKNN::fSigmaFact. private . scale factor for Gaussian sigma in Gaus. kernel ; Definition at line 127 of file MethodKNN.h. ◆ fSumOfWeightsB. Double_t TMVA::MethodKNN::fSumOfWeightsB. private . sum-of-weights for backgrou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodKNN.html:36982,learn,learning,36982,doc/master/classTMVA_1_1MethodKNN.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodKNN.html,1,['learn'],['learning']
Usability,"id DrawEventStatus(Int_t event, Int_t x, Int_t y, TObject* selected); Report name and title of primitive below the cursor. This function is called when the option ""Event Status""; in the canvas menu ""Options"" is selected. void EditorBar(); Get editor bar. void EmbedInto(Int_t winid, Int_t ww, Int_t wh); Embedded a canvas into a TRootEmbeddedCanvas. This method is only called; via TRootEmbeddedCanvas::AdoptCanvas. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); Generate kMouseEnter and kMouseLeave events depending on the previously; selected object and the currently selected object. Does nothing if the; selected object does not change. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function must be implemented to realize the action; corresponding to the mouse click on the object in the canvas. Only handle mouse motion events in TCanvas, all other events are; ignored for the time being. void FeedbackMode(Bool_t set); Turn rubberband feedback mode on or off. void Flush(); Flush canvas buffers. void UseCurrentStyle(); Force a copy of current style for all objects in canvas. Int_t GetWindowTopX(); Returns current top x position of window on screen. Int_t GetWindowTopY(); Returns current top y position of window on screen. void HandleInput(EEventType button, Int_t x, Int_t y); Handle Input Events. Handle input events, like button up/down in current canvas. Bool_t IsFolder() const; Is folder ?. void ls(Option_t* option = """") const; List all pads. TCanvas * MakeDefCanvas(); Static function to build a default canvas. void MoveOpaque(Int_t set = 1); Set option to move objects/pads in a canvas. if set = 1 (default) graphics objects are moved in opaque mode; = 0 only the outline of objects is drawn when moving them; The option opaque produces the best effect. It requires however a; a reasonably fast workstation or response time. void Paint(Option_t* option = """"); Paint canvas. TPad * Pick(Int_t px, Int_t py, TOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TCanvas.html:39591,feedback,feedback,39591,root/html526/TCanvas.html,https://root.cern,https://root.cern/root/html526/TCanvas.html,15,"['Feedback', 'feedback']","['FeedbackMode', 'feedback']"
Usability,"id RGeomDescription::ProduceDrawData(); 1359{; 1360 auto json = ProduceJson();; 1361 ; 1362 TLockGuard lock(fMutex);; 1363 ; 1364 fDrawJson = ""GDRAW:""s + json;; 1365}; 1366 ; 1367/////////////////////////////////////////////////////////////////////; 1368/// Clear raw data. Will be rebuild when next connection will be established; 1369 ; 1370void RGeomDescription::ClearDrawData(); 1371{; 1372 TLockGuard lock(fMutex);; 1373 ; 1374 fDrawJson.clear();; 1375 fSearchJson.clear();; 1376}; 1377 ; 1378/////////////////////////////////////////////////////////////////////; 1379/// Clear cached data, need to be clear when connection broken; 1380 ; 1381void RGeomDescription::ClearCache(); 1382{; 1383 ClearDrawData();; 1384 ; 1385 TLockGuard lock(fMutex);; 1386 fShapes.clear();; 1387 fSearch.clear();; 1388}; 1389 ; 1390/////////////////////////////////////////////////////////////////////; 1391/// return true when node used in main geometry drawing and does not have childs; 1392/// for such nodes one could provide optimize toggling of visibility flags; 1393 ; 1394bool RGeomDescription::IsPrincipalEndNode(int nodeid); 1395{; 1396 TLockGuard lock(fMutex);; 1397 ; 1398 if ((nodeid < 0) || (nodeid >= (int)fDesc.size())); 1399 return false;; 1400 ; 1401 auto &desc = fDesc[nodeid];; 1402 ; 1403 return (desc.sortid < fDrawIdCut) && desc.IsVisible() && desc.CanDisplay() && (desc.chlds.empty());; 1404}; 1405 ; 1406/////////////////////////////////////////////////////////////////////; 1407/// Search visible nodes for provided name; 1408/// If number of found elements less than 100, create description and shapes for them; 1409/// Returns number of match elements; 1410 ; 1411int RGeomDescription::SearchVisibles(const std::string &find, std::string &hjson, std::string &json); 1412{; 1413 TLockGuard lock(fMutex);; 1414 ; 1415 hjson.clear();; 1416 json.clear();; 1417 ; 1418 if (find.empty()) {; 1419 hjson = ""FOUND:RESET"";; 1420 return 0;; 1421 }; 1422 ; 1423 std::vector<int> nodescnt(fDesc.size()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RGeomData_8cxx_source.html:41969,clear,clear,41969,doc/master/RGeomData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RGeomData_8cxx_source.html,2,['clear'],['clear']
Usability,"id RooMinimizer::setRecoverFromNaNStrength ; (; double ; strength). Try to recover from invalid function values. ; When invalid function values are encountered, a penalty term is returned to the minimiser to make it back off. This sets the strength of this penalty. NoteA strength of zero is equivalent to a constant penalty (= the gradient vanishes, ROOT < 6.24). Positive values lead to a gradient pointing away from the undefined regions. Use ~10 to force the minimiser away from invalid function values. ; Definition at line 802 of file RooMinimizer.cxx. ◆ setStrategy(). void RooMinimizer::setStrategy ; (; int ; istrat). Change MINUIT strategy to istrat. ; Accepted codes are 0,1,2 and represent MINUIT strategies for dealing most efficiently with fast FCNs (0), expensive FCNs (2) and 'intermediate' FCNs (1) ; Definition at line 189 of file RooMinimizer.cxx. ◆ setVerbose(). void RooMinimizer::setVerbose ; (; bool ; flag = true). inline . Definition at line 153 of file RooMinimizer.h. ◆ simplex(). int RooMinimizer::simplex ; (; ). Execute SIMPLEX. ; Changes in parameter values and calculated errors are automatically propagated back the RooRealVars representing the floating parameters in the MINUIT operation. ; Definition at line 453 of file RooMinimizer.cxx. ◆ Streamer(). void RooMinimizer::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void RooMinimizer::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 247 of file RooMinimizer.h. ◆ update(). bool RooMinimizer::update ; (; bool ; isValid). private . Definition at line 1100 of file RooMinimizer.cxx. ◆ updateErrors(). void RooMinimizer::updateErrors ; (; ). private . Definition at line 1129 of file RooMinimizer.cxx. ◆ updateFitConfig(). void RooMinimizer::updateFitConfig ; (; ). private . Definition at line 1013 of file RooMinimizer.cxx. ◆ updateMinimizerOptions(). bool RooMinimizer::updateMi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMinimizer.html:29552,simpl,simplex,29552,doc/master/classRooMinimizer.html,https://root.cern,https://root.cern/doc/master/classRooMinimizer.html,1,['simpl'],['simplex']
Usability,id TMVA::TSynapse::SetLearningRate ; (; Double_t ; rate). inline . Definition at line 56 of file TSynapse.h. ◆ SetPostNeuron(). void TMVA::TSynapse::SetPostNeuron ; (; TNeuron * ; post). inline . Definition at line 68 of file TSynapse.h. ◆ SetPreNeuron(). void TMVA::TSynapse::SetPreNeuron ; (; TNeuron * ; pre). inline . Definition at line 65 of file TSynapse.h. ◆ SetWeight(). void TMVA::TSynapse::SetWeight ; (; Double_t ; weight). set synapse weight ; Definition at line 68 of file TSynapse.cxx. ◆ Streamer(). virtual void TMVA::TSynapse::Streamer ; (; TBuffer & ; R__b). virtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TMVA::TSynapse::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 101 of file TSynapse.h. Member Data Documentation. ◆ fCount. Int_t TMVA::TSynapse::fCount. private . number of updates contributing to error field ; Definition at line 95 of file TSynapse.h. ◆ fDEDw. Double_t TMVA::TSynapse::fDEDw. private . sum of deltas ; Definition at line 94 of file TSynapse.h. ◆ fDelta. Double_t TMVA::TSynapse::fDelta. private . local error field ; Definition at line 93 of file TSynapse.h. ◆ fLearnRate. Double_t TMVA::TSynapse::fLearnRate. private . learning rate parameter ; Definition at line 92 of file TSynapse.h. ◆ fPostNeuron. TNeuron* TMVA::TSynapse::fPostNeuron. private . pointer to post-neuron ; Definition at line 97 of file TSynapse.h. ◆ fPreNeuron. TNeuron* TMVA::TSynapse::fPreNeuron. private . pointer to pre-neuron ; Definition at line 96 of file TSynapse.h. ◆ fWeight. Double_t TMVA::TSynapse::fWeight. private . weight of the synapse ; Definition at line 91 of file TSynapse.h. Libraries for TMVA::TSynapse:. [legend]; The documentation for this class was generated from the following files:; tmva/tmva/inc/TMVA/TSynapse.h; tmva/tmva/src/TSynapse.cxx. TMVATSynapse. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:44 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1TSynapse.html:15216,learn,learning,15216,doc/master/classTMVA_1_1TSynapse.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1TSynapse.html,1,['learn'],['learning']
Usability,"id TQCommand::SetArgs ; (; Int_t ; narg, .  ; ... . ). virtual . Set do/redo and undo parameters. ; The format is SetArgs(number_of_params, redo_params, undo_params); Example: move_command->SetArgs(2, 100, 100, 200, 200);; 2 params, (100,100) - do/redo position, (200,200) - undo position ; Definition at line 465 of file TQCommand.cxx. ◆ SetName(). void TQCommand::SetName ; (; const char * ; name). virtual . Sets name of the command. ; Definition at line 832 of file TQCommand.cxx. ◆ SetRedoArgs(). void TQCommand::SetRedoArgs ; (; Int_t ; narg, .  ; ... . ). virtual . Set redo parameters. ; The format is SetRedoArgs(number_of_params, params); Example: move_command->SetRedoArgs(2, 100, 100);. Definition at line 508 of file TQCommand.cxx. ◆ SetTitle(). void TQCommand::SetTitle ; (; const char * ; title). virtual . Sets description of the command. ; Definition at line 840 of file TQCommand.cxx. ◆ SetUndoArgs(). void TQCommand::SetUndoArgs ; (; Int_t ; narg, .  ; ... . ). virtual . Set undo parameters. ; The format is SetUndoArgs(number_of_params, params); Example: move_command->SetUndoArgs(2, 200, 200);. Definition at line 542 of file TQCommand.cxx. ◆ Streamer(). void TQCommand::Streamer ; (; TBuffer & ; b). overridevirtual . Stream all objects in the collection to or from the I/O buffer. ; Reimplemented from TList.; Reimplemented in TQUndoManager. ◆ StreamerNVirtual(). void TQCommand::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 98 of file TQCommand.h. ◆ Undo(). void TQCommand::Undo ; (; Option_t * ; option = """"). virtual . Un-execute all merged commands and the command. ; Merged commands are executed in reverse order. ; Reimplemented in TQUndoManager.; Definition at line 626 of file TQCommand.cxx. Friends And Related Symbol Documentation. ◆ TQUndoManager. friend class TQUndoManager. friend . Definition at line 29 of file TQCommand.h. Member Data Documentation. ◆ fName. TString TQCommand::fName. protected . Definition at lin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:43522,undo,undo,43522,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['undo'],['undo']
Usability,"id);; 2004 Int_t ind = pidslist->IndexOf(pid);; 2005 pid->SetUniqueID((UInt_t)ind);; 2006 }; 2007 ; 2008 return pid;; 2009}; 2010 ; 2011 ; 2012////////////////////////////////////////////////////////////////////////////////; 2013/// Attempt to recover file if not correctly closed; 2014///; 2015/// The function returns the number of keys that have been recovered.; 2016/// If no keys can be recovered, the file will be declared Zombie by; 2017/// the calling function. This function is automatically called when; 2018/// opening a file.; 2019/// If the file is open in read only mode, the file is not modified.; 2020/// If open in update mode and the function finds something to recover,; 2021/// a new directory header is written to the file. When opening the file gain; 2022/// no message from Recover will be reported.; 2023/// If keys have been recovered, the file is usable and you can safely; 2024/// read the corresponding objects.; 2025/// If the file is not usable (a zombie), you can test for this case; 2026/// with code like:; 2027///; 2028/// ~~~{.cpp}; 2029/// TFile f(""myfile.root"");; 2030/// if (f.IsZombie()) {<actions to take if file is unusable>}; 2031/// ~~~; 2032///; 2033/// If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; 2034/// You can test if the file has been recovered with; 2035///; 2036/// if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; 2037///; 2038/// When writing TTrees to a file, it is important to save the Tree header; 2039/// at regular intervals (see TTree::AutoSave). If a file containing a Tree; 2040/// is recovered, the last Tree header written to the file will be used.; 2041/// In this case all the entries in all the branches written before writing; 2042/// the header are valid entries.; 2043/// One can disable the automatic recovery procedure by setting; 2044///; 2045/// TFile.Recover 0; 2046///; 2047/// in the <em>system.rootrc</em> file.; 2048 ; 2049Int_t TFile::Recover(); 2050{; 20",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:72383,usab,usable,72383,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['usab'],['usable']
Usability,"idRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsSelfCachedPdf.html:3140,clear,clearEvalErrorLog,3140,root/html532/RooAbsSelfCachedPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsSelfCachedPdf.html,1,['clear'],['clearEvalErrorLog']
Usability,"idRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tRooAbsAnaConvPdf::coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*RooAbsAnaConvPdf::coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooDecay.html:2629,clear,clearEvalErrorLog,2629,root/html532/RooDecay.html,https://root.cern,https://root.cern/root/html532/RooDecay.html,2,['clear'],['clearEvalErrorLog']
Usability,"idRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*RooAbsAnaConvPdf::coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooBCPEffDecay.html:2931,clear,clearEvalErrorLog,2931,root/html532/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html532/RooBCPEffDecay.html,5,['clear'],['clearEvalErrorLog']
Usability,"idRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& ar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooBDecay.html:2829,clear,clearEvalErrorLog,2829,root/html532/RooBDecay.html,https://root.cern,https://root.cern/root/html532/RooBDecay.html,1,['clear'],['clearEvalErrorLog']
Usability,"idRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooArgusBG.html:2653,clear,clearEvalErrorLog,2653,root/html532/RooArgusBG.html,https://root.cern,https://root.cern/root/html532/RooArgusBG.html,74,['clear'],['clearEvalErrorLog']
Usability,"idRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsAnaConvPdf.html:4125,clear,clearEvalErrorLog,4125,root/html528/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsAnaConvPdf.html,2,['clear'],['clearEvalErrorLog']
Usability,"idRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg::none(), const RooCmdArg arg6 =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCachedPdf.html:3225,clear,clearEvalErrorLog,3225,root/html528/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsCachedPdf.html,2,['clear'],['clearEvalErrorLog']
Usability,"idRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsCachedPdf.html:3225,clear,clearEvalErrorLog,3225,root/html530/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html,2,['clear'],['clearEvalErrorLog']
Usability,"idRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tRooAbsAnaConvPdf::coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*RooAbsAnaConvPdf::coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooDecay.html:2629,clear,clearEvalErrorLog,2629,root/html528/RooDecay.html,https://root.cern,https://root.cern/root/html528/RooDecay.html,2,['clear'],['clearEvalErrorLog']
Usability,"idRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*RooAbsAnaConvPdf::coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooBCPEffDecay.html:2931,clear,clearEvalErrorLog,2931,root/html528/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html528/RooBCPEffDecay.html,8,['clear'],['clearEvalErrorLog']
Usability,"idRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooBDecay.html:2829,clear,clearEvalErrorLog,2829,root/html528/RooBDecay.html,https://root.cern,https://root.cern/root/html528/RooBDecay.html,1,['clear'],['clearEvalErrorLog']
Usability,"idRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooBDecay.html:2829,clear,clearEvalErrorLog,2829,root/html530/RooBDecay.html,https://root.cern,https://root.cern/root/html530/RooBDecay.html,1,['clear'],['clearEvalErrorLog']
Usability,"idRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg::none(), const RooCmdArg arg6 = RooCmdArg:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooArgusBG.html:2653,clear,clearEvalErrorLog,2653,root/html528/RooArgusBG.html,https://root.cern,https://root.cern/root/html528/RooArgusBG.html,46,['clear'],['clearEvalErrorLog']
Usability,"idRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooExtendPdf.html:3178,clear,clearEvalErrorLog,3178,root/html528/RooExtendPdf.html,https://root.cern,https://root.cern/root/html528/RooExtendPdf.html,60,['clear'],['clearEvalErrorLog']
Usability,"idTEveProjectable::AnnihilateProjecteds(); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTEveElement::ApplyVizTag(const TString& tag, const TString& fallback_tag = """"); Float_t*TAttBBox::AssertBBox(); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tCanEditMainTransparency() const; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElementList*TEveElementList::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTEveElement::CopyVizParams(const TEveElement* el); virtual voidTEveElement::CopyVizParamsFromDB(); voidTEveElement::CSCApplyMainColorToAllChildren(); voidTEveElement::CSCApplyMainColorToMatchingChildren(); voidTEveElement::CSCApplyMainTransparencyToAllChildren(); voidTEveElement::CSCApplyMainTransparencyToMatchingChildren(); voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveTriangleSet.html:2500,Clear,ClearProjectedList,2500,root/html532/TEveTriangleSet.html,https://root.cern,https://root.cern/root/html532/TEveTriangleSet.html,4,['Clear'],['ClearProjectedList']
Usability,"idTGFrame::UnmapWindow(); virtual voidTObject::UseCurrentStyle(); Bool_tTGWidget::WantFocus() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidTGFrame::DoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); voidTGMdiWinResizer::DrawBox(Int_t x, Int_t y, UInt_t width, UInt_t height); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTObject::MakeZombie(); voidTGMdiWinResizer::MoveResizeIt(); TGWindow&TGWindow::operator=(const TGWindow& tgw); Int_tTGWidget::SetFlags(Int_t flags); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE). Data Members; public:. enum TGFrame::[unnamed] { kDeleteWindowCalled; };; enum TGWindow::EEditMode { kEditEnable; kEditDisable; kEditDisableEvents; kEditDisableGrab; kEditDisableLayout; kEditDisableResize; kEditDisableHeight; kEditDisableWidth; kEditDisableBtnEnable; kEditDisableKeyEnable; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; k",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGMdiCornerWinResizer.html:14079,Clear,ClearFlags,14079,root/html532/TGMdiCornerWinResizer.html,https://root.cern,https://root.cern/root/html532/TGMdiCornerWinResizer.html,6,['Clear'],['ClearFlags']
Usability,"idTGLVContainer::AddItem(TGLVEntry* item); virtual TGFileItem*AddRemoteFile(TObject* obj, const TGPicture* ipic = 0, const TGPicture* ilpic = 0); virtual voidTGContainer::AdjustPosition(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGContainer::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidChangeDirectory(const char* path); virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual voidTGContainer::ClearViewPort(); virtual voidTGContainer::Clicked(TGFrame* f, Int_t btn)SIGNAL ; virtual voidTGContainer::Clicked(TGFrame* f, Int_t btn, Int_t x, Int_t y)SIGNAL ; virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGContainer::CurrentChanged(TGFrame* f)SIGNAL ; virtual voidTGContainer::CurrentChanged(Int_t x, Int_t y)SIGNAL ; virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGFileContainer.html:2015,Clear,ClearViewPort,2015,root/html532/TGFileContainer.html,https://root.cern,https://root.cern/root/html532/TGFileContainer.html,4,['Clear'],['ClearViewPort']
Usability,"idTObject::AppendPad(Option_t* option = """"); Bool_tTEveElement::ApplyVizTag(const TString& tag, const TString& fallback_tag = """"); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual Bool_tCanMakeNewSlots() const; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidTEveWindow::ClearEveFrame(); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElementList*TEveElementList::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTEveElement::CopyVizParams(const TEveElement* el); virtual voidTEveElement::CopyVizParamsFromDB(); static TEveWindowSlot*TEveWindow::CreateDefaultWindowSlot(); static TEveWindowSlot*TEveWindow::CreateWindowInTab(TGTab* tab, TEveWindow* eve_parent = 0); static TEveWindowSlot*TEveWindow::CreateWindowMainFrame(TEveWindow* eve_parent = 0); voidTEveElement::CS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveWindowPack.html:2345,Clear,ClearProjectedList,2345,root/html532/TEveWindowPack.html,https://root.cern,https://root.cern/root/html532/TEveWindowPack.html,8,['Clear'],['ClearProjectedList']
Usability,"idateto validate the parse context; TStringfValidateErrorparse error; TStringfValidateWarningparse warning; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TXMLParser(); Cleanup. void SetValidate(Bool_t val = kTRUE); The parser will validate the xml file if val = true. void SetReplaceEntities(Bool_t val = kTRUE); The parser will replace/expand entities. void ReleaseUnderlying(); To release any existing document. void OnValidateError(const TString& message); This function is called when an error from the parser has occured.; Message is the parse error. void OnValidateWarning(const TString& message); This function is called when a warning from the parser has occured.; Message is the parse error. const char * GetParseCodeMessage(Int_t parseCode) const; Returns the parse code message. void InitializeContext(); Initialize parser parameters, such as, disactivate non-standards libxml1; features, on/off validation, clear error and warning messages. void StopParser(); Stops parsing. void SetParseCode(Int_t code); Set the parse code:; 0: Parse succesfull; -1: Attempt to parse a second file while a parse is in progress; -2: Parse context is not created; -3: An error occured while parsing file; -4: A fatal error occured while parsing file; -5: Document is not well-formed. void SetStopOnError(Bool_t stop = kTRUE); Set parser stops in case of error:; stop = true, stops on error; stop = false, continue parsing on error... TXMLParser& operator=(const TXMLParser& ). Bool_t GetValidate() const; { return fValidate; }. Bool_t GetReplaceEntities() const; { return fReplaceEntities; }. Int_t ParseFile(const char* filename). Int_t ParseBuffer(const char* contents, Int_t len). Int_t GetParseCode() const; { return fParseCode; }. Bool_t GetStopOnError() const; { return fStopError; }. const char * GetValidateError() const; { return fValidateError; }. const char * GetVa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXMLParser.html:10894,clear,clear,10894,root/html528/TXMLParser.html,https://root.cern,https://root.cern/root/html528/TXMLParser.html,4,['clear'],['clear']
Usability,"idateto validate the parse context; TStringfValidateErrorparse error; TStringfValidateWarningparse warning; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TXMLParser(); Cleanup. void SetValidate(Bool_t val = kTRUE); The parser will validate the xml file if val = true. void SetReplaceEntities(Bool_t val = kTRUE); The parser will replace/expand entities. void ReleaseUnderlying(); To release any existing document. void OnValidateError(const TString& message); This function is called when an error from the parser has occured.; Message is the parse error. void OnValidateWarning(const TString& message); This function is called when a warning from the parser has occured.; Message is the parse error. const char * GetParseCodeMessage(Int_t parseCode) const; Returns the parse code message. void InitializeContext(); Initialize parser parameters, such as, disactivate non-standards libxml1; features, on/off validation, clear error and warning messages. void StopParser(); Stops parsing. void SetParseCode(Int_t code); Set the parse code:; 0: Parse successful; -1: Attempt to parse a second file while a parse is in progress; -2: Parse context is not created; -3: An error occured while parsing file; -4: A fatal error occured while parsing file; -5: Document is not well-formed. void SetStopOnError(Bool_t stop = kTRUE); Set parser stops in case of error:; stop = true, stops on error; stop = false, continue parsing on error... TXMLParser& operator=(const TXMLParser& ). Bool_t GetValidate() const; { return fValidate; }. Bool_t GetReplaceEntities() const; { return fReplaceEntities; }. Int_t ParseFile(const char* filename). Int_t ParseBuffer(const char* contents, Int_t len). Int_t GetParseCode() const; { return fParseCode; }. Bool_t GetStopOnError() const; { return fStopError; }. const char * GetValidateError() const; { return fValidateError; }. const char * GetVa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TXMLParser.html:10982,clear,clear,10982,root/html534/TXMLParser.html,https://root.cern,https://root.cern/root/html534/TXMLParser.html,2,['clear'],['clear']
Usability,"ide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Protected Member Functions |; Protected Attributes |; List of all members ; TProofProgressMemoryPlot Class ReferenceGUI » Session Viewer. ; This class implements a dialog, used to display the memory footprint on the proof workers and master. ; For the workers, memory is plotted as a function of number of events processed. For the master, it is plotted as a function of number of objects merged ; Definition at line 28 of file TProofProgressMemoryPlot.h. Public Member Functions;  TProofProgressMemoryPlot (TProofProgressDialog *d, Int_t w=700, Int_t h=300);  Main constructor. ;  ;  ~TProofProgressMemoryPlot () override;  Destructor. ;  ; void Clear (Option_t *=nullptr) override;  Clear the canvases. ;  ; void DoPlot ();  Draw the plot from the logs. ;  ; void Select (Int_t id);  actions of select all/clear all button ;  ;  Public Member Functions inherited from TGTransientFrame;  TGTransientFrame (const TGWindow *p=nullptr, const TGWindow *main=nullptr, UInt_t w=1, UInt_t h=1, UInt_t options=kVerticalFrame);  Create a transient window. ;  ; virtual void CenterOnParent (Bool_t croot=kTRUE, EPlacement pos=kCenter);  Position transient frame centered relative to the parent frame. ;  ; const TGWindow * GetMain () const;  ; TClass * IsA () const override;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a transient frame widget as a C++ statement(s) on output stream out. ;  ; void SaveSource (const char *filename=""Rootdlog.C"", Option_t *option="""") override;  Save the GUI transient frame widget in a C++ macro file. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGMainFrame;  TGMainFrame (const TGWindow *p=nullptr, UInt_t w=1, UInt_t h=1, UInt_t options=kVerticalFrame);  Create a top level main frame. ;  ;  ~TGMa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofProgressMemoryPlot.html:989,clear,clear,989,doc/master/classTProofProgressMemoryPlot.html,https://root.cern,https://root.cern/doc/master/classTProofProgressMemoryPlot.html,1,['clear'],['clear']
Usability,"ide ; .  . Loading...; Searching...; No Matches. hsimpleReader.C File ReferenceTutorials » Tree tutorials. Detailed Description; TTreeReader simplest example. ; Read data from hsimple.root (written by hsimple.C); ; #include ""TFile.h""; #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h""; ; void hsimpleReader() {; // Create a histogram for the values we read.; auto myHist = new TH1F(""h1"",""ntuple"",100,-4,4);; ; // Open the file containing the tree.; auto myFile = TFile::Open(""hsimple.root"");; if (!myFile || myFile->IsZombie()) {; return;; }; // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);; ; // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");; ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; }; ; myHist->Draw();; }; TFile.h; TH1F.h; TTreeReaderValue.h; TTreeReader.h; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TTreeReaderValueAn interface for reading values stored in ROOT columnar datasets.Definition TTreeReaderValue.h:174; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:46; AuthorAnders Eie, 2013 ; Definition in file hsimpleReader.C. tutorialstreehsimpleReader.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/hsimpleReader_8C.html:1769,simpl,simple,1769,doc/master/hsimpleReader_8C.html,https://root.cern,https://root.cern/doc/master/hsimpleReader_8C.html,1,['simpl'],['simple']
Usability,"ideEmit signals.Definition TGButton.cxx:1262; TGCheckButton::SetStatevoid SetState(EButtonState state, Bool_t emit=kFALSE) overrideSet check button state.Definition TGButton.cxx:1250; TGCheckButton::fPrevStateEButtonState fPrevStateprevious check button stateDefinition TGButton.h:272; TGCheckButton::DoRedrawvoid DoRedraw() overrideDraw the check button widget.Definition TGButton.cxx:1437; TGCheckButton::fDisOffconst TGPicture * fDisOffbutton disabled and was OFF pictureDefinition TGButton.h:276; TGCheckButton::fDisOnconst TGPicture * fDisOnbutton disabled and was ON pictureDefinition TGButton.h:275; TGCheckButton::GetDefaultSizeTGDimension GetDefaultSize() const overridedefault sizeDefinition TGButton.cxx:1236; TGCheckButton::PSetStatevoid PSetState(EButtonState state, Bool_t emit)Set check button state.Definition TGButton.cxx:1273; TGDimensionDefinition TGDimension.h:18; TGFontEncapsulate fonts used in the GUI system.Definition TGFont.h:140; TGFrameA subclasses of TGWindow, and is used as base class for some simple widgets (buttons,...Definition TGFrame.h:80; TGGCEncapsulate a graphics context used in the low level graphics.Definition TGGC.h:22; TGHotStringTGHotString is a string with a ""hot"" character underlined.Definition TGString.h:42; TGPictureButtonYield an action as soon as it is clicked.Definition TGButton.h:228; TGPictureButton::SetPicturevirtual void SetPicture(const TGPicture *new_pic)Change a picture in a picture button.Definition TGButton.cxx:1040; TGPictureButton::CreateDisabledPicturevirtual void CreateDisabledPicture()Creates disabled picture.Definition TGButton.cxx:1108; TGPictureButton::GetDisabledPictureconst TGPicture * GetDisabledPicture() constDefinition TGButton.h:257; TGPictureButton::SetDisabledPicturevirtual void SetDisabledPicture(const TGPicture *pic)Changes disabled picture.Definition TGButton.cxx:1135; TGPictureButton::GetPictureconst TGPicture * GetPicture() constDefinition TGButton.h:256; TGPictureButton::SavePrimitivevoid SavePrimiti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGButton_8h_source.html:28090,simpl,simple,28090,doc/master/TGButton_8h_source.html,https://root.cern,https://root.cern/doc/master/TGButton_8h_source.html,1,['simpl'],['simple']
Usability,"idget::WantFocus() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static TStringTQObject::CompressName(const char* method_name); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidDoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); voidTGedSelect::DrawTriangle(GContext_t gc, Int_t x, Int_t y); virtual voidTGCheckButton::EmitSignals(Bool_t wasUp = kTRUE); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTGCheckButton::Init(); voidTObject::MakeZombie(); voidTGCheckButton::PSetState(EButtonState state, Bool_t emit); Int_tTGWidget::SetFlags(Int_t flags); virtual voidTGButton::SetToggleButton(Bool_t); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TGWindow::EEditModeTGWindow::kEditDisable; static TGWindow::EEditModeTGWindow::kEditDisableBtnEnable; static TGWindow::EEditModeTGWindow::kEditDisableEven",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGedMarkerSelect.html:17237,Clear,ClearFlags,17237,root/html602/TGedMarkerSelect.html,https://root.cern,https://root.cern/root/html602/TGedMarkerSelect.html,4,['Clear'],['ClearFlags']
Usability,"idth increments; Int_tTGMainFrame::fWMXWM x position; Int_tTGMainFrame::fWMYWM y position; UInt_tTGFrame::fWidthframe width; TStringTGMainFrame::fWindowNamewindow name; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGUndockedFrame(const TGWindow* p = 0, TGDockableFrame* dockable = 0); Create the undocked (transient) frame. ~TGUndockedFrame(); Delete undocked frame. Puts back dockable frame in its original container. void FixSize(); Fix the size of the undocked frame so it cannot be changed via the WM. void CloseWindow(); Close undocked frame (called via WM close button). TGUndockedFrame(const TGUndockedFrame& ). TGUndockedFrame& operator=(const TGUndockedFrame& ). » Author: Abdelhalim Ssadik 07/07/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGDockableFrame.h 23256 2008-04-16 14:13:50Z antcheva $ » Last generated: 2010-09-23 20:08; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGUndockedFrame.html:22162,undo,undocked,22162,root/html528/TGUndockedFrame.html,https://root.cern,https://root.cern/root/html528/TGUndockedFrame.html,4,['undo'],['undocked']
Usability,"idth increments; Int_tTGMainFrame::fWMXWM x position; Int_tTGMainFrame::fWMYWM y position; UInt_tTGFrame::fWidthframe width; TStringTGMainFrame::fWindowNamewindow name; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGUndockedFrame(const TGWindow* p = 0, TGDockableFrame* dockable = 0); Create the undocked (transient) frame. ~TGUndockedFrame(); Delete undocked frame. Puts back dockable frame in its original container. void FixSize(); Fix the size of the undocked frame so it cannot be changed via the WM. void CloseWindow(); Close undocked frame (called via WM close button). TGUndockedFrame(const TGUndockedFrame& ). TGUndockedFrame& operator=(const TGUndockedFrame& ). » Author: Abdelhalim Ssadik 07/07/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGDockableFrame.h 23256 2008-04-16 14:13:50Z antcheva $ » Last generated: 2011-07-04 15:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGUndockedFrame.html:22315,undo,undocked,22315,root/html530/TGUndockedFrame.html,https://root.cern,https://root.cern/root/html530/TGUndockedFrame.html,4,['undo'],['undocked']
Usability,"idth increments; Int_tTGMainFrame::fWMXWM x position; Int_tTGMainFrame::fWMYWM y position; UInt_tTGFrame::fWidthframe width; TStringTGMainFrame::fWindowNamewindow name; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGUndockedFrame(const TGWindow* p = 0, TGDockableFrame* dockable = 0); Create the undocked (transient) frame. ~TGUndockedFrame(); Delete undocked frame. Puts back dockable frame in its original container. void FixSize(); Fix the size of the undocked frame so it cannot be changed via the WM. void CloseWindow(); Close undocked frame (called via WM close button). TGUndockedFrame(const TGUndockedFrame& ). TGUndockedFrame& operator=(const TGUndockedFrame& ). » Author: Abdelhalim Ssadik 07/07/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGDockableFrame.h 23256 2008-04-16 14:13:50Z antcheva $ » Last generated: 2011-11-03 20:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGUndockedFrame.html:22315,undo,undocked,22315,root/html532/TGUndockedFrame.html,https://root.cern,https://root.cern/root/html532/TGUndockedFrame.html,8,['undo'],['undocked']
Usability,"iduals"" of at least ""improvement"" ; this gives a simple measure of if the estimator of the MLP is converging and no major improvement is to be expected. ; Definition at line 66 of file ConvergenceTest.cxx. ◆ Progress(). Float_t TMVA::ConvergenceTest::Progress ; (; ). returns a float from 0 (just started) to 1 (finished) ; Definition at line 91 of file ConvergenceTest.cxx. ◆ ResetConvergenceCounter(). void TMVA::ConvergenceTest::ResetConvergenceCounter ; (; ). inline . Definition at line 58 of file ConvergenceTest.h. ◆ SetConvergenceParameters(). void TMVA::ConvergenceTest::SetConvergenceParameters ; (; Int_t ; steps, . Double_t ; improvement . ). inline . Definition at line 54 of file ConvergenceTest.h. ◆ SetCurrentValue(). void TMVA::ConvergenceTest::SetCurrentValue ; (; Float_t ; value). inline . Definition at line 56 of file ConvergenceTest.h. ◆ SpeedControl(). Float_t TMVA::ConvergenceTest::SpeedControl ; (; UInt_t ; ofSteps). this function provides the ability to change the learning rate according to the success of the last generations. ; Parameters:. int ofSteps : = if OF the number of STEPS given in this variable (ofSteps) the rate of improvement has to be calculated. using this function one can increase the stepSize of the mutation when we have good success (to pass fast through the easy phase-space) and reduce the learning rate if we are in a difficult ""territory"" of the phase-space. ; Definition at line 112 of file ConvergenceTest.cxx. Member Data Documentation. ◆ fBestResult. Float_t TMVA::ConvergenceTest::fBestResult. private . Definition at line 81 of file ConvergenceTest.h. ◆ fConvValue. Float_t TMVA::ConvergenceTest::fConvValue. private . ! the best ""fitness"" value ; Definition at line 76 of file ConvergenceTest.h. ◆ fCounter. Int_t TMVA::ConvergenceTest::fCounter. private . ! counts the number of steps without improvement ; Definition at line 75 of file ConvergenceTest.h. ◆ fCurrentValue. Float_t TMVA::ConvergenceTest::fCurrentValue. protected . ! cur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1ConvergenceTest.html:3498,learn,learning,3498,doc/master/classTMVA_1_1ConvergenceTest.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1ConvergenceTest.html,1,['learn'],['learning']
Usability,"id SetNotify (TObject *obj);  Sets the address of the object to be notified when the tree is loaded. ;  ; virtual void SetObject (const char *name, const char *title);  Change the name and title of this tree. ;  ; virtual void SetParallelUnzip (bool opt=true, Float_t RelSize=-1);  Enable or disable parallel unzipping of Tree buffers. ;  ; virtual void SetPerfStats (TVirtualPerfStats *perf);  Set perf stats. ;  ; virtual void SetScanField (Int_t n=50);  ; void SetTargetMemoryRatio (Float_t ratio);  ; virtual void SetTimerInterval (Int_t msec=333);  ; virtual void SetTreeIndex (TVirtualIndex *index);  The current TreeIndex is replaced by the new index. ;  ; virtual void SetUpdate (Int_t freq=0);  ; virtual void SetWeight (Double_t w=1, Option_t *option="""");  Set tree weight. ;  ; virtual void Show (Long64_t entry=-1, Int_t lenmax=20);  Print values of all active leaves for entry. ;  ; virtual void StartViewer ();  Start the TTreeViewer on this tree. ;  ; virtual Int_t StopCacheLearningPhase ();  Stop the cache learning phase. ;  ; void Streamer (TBuffer &) override;  Stream a class object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual Int_t UnbinnedFit (const char *funcname, const char *varexp, const char *selection="""", Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Unbinned fit of one or more variable(s) from a tree. ;  ; void UseCurrentStyle () override;  Replace current attributes by current style. ;  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const override;  Write this object to the current directory. ;  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) override;  Write this object to the current directory. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:41636,learn,learning,41636,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,1,['learn'],['learning']
Usability,"ied TDSet on PROOF.; This method is called on client and on the PROOF master.; The return value is -1 in case of an error and TSelector::GetStatus() in; in case of success. Bool_t MergeOutputFiles(); Merge output in files. void SetSelectorDataMembersFromOutputList(); Set the selector's data members:; find the mapping of data members to otuput list entries in the output list; and apply it. Long64_t Finalize(Bool_t force = kFALSE, Bool_t sync = kFALSE). Long64_t Finalize(TQueryResult* qr); Finalize the results of a query already processed. Bool_t SendSelector(const char* selector_file); Send the selector file(s) to master or worker nodes. void MergeOutput(); Merge objects in output the lists. void Progress(Long64_t total, Long64_t processed); Progress signal. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Progress signal. void Progress(TProofProgressInfo* pi); Progress signal. void Feedback(TList* objs); Feedback signal. void StopProcess(Bool_t abort, Int_t timeout = -1); Stop process after this event. Int_t AddOutputObject(TObject* obj); Incorporate the received object 'obj' into the output list fOutput.; The latter is created if not existing.; This method short cuts 'StoreOutput + MergeOutput' optimizing the memory; consumption.; Returns -1 in case of error, 1 if the object has been merged into another; one (so that its ownership has not been taken and can be deleted), and 0; otherwise. void RedirectOutput(Bool_t on = kTRUE); Control output redirection to TProof::fLogFileW. void AddOutput(TList* out); Incorporate the content of the received output list 'out' into the final; output list fOutput. The latter is created if not existing.; This method short cuts 'StoreOutput + MergeOutput' limiting the memory; consumption. void NotifyMemory(TObject* obj); Printout the memory record after merging object 'obj'; This record is used by the memory monitor. void SetLastMergingMsg(TObject* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofPlayerRemote.html:17199,Feedback,Feedback,17199,root/html532/TProofPlayerRemote.html,https://root.cern,https://root.cern/root/html532/TProofPlayerRemote.html,2,['Feedback'],['Feedback']
Usability,"ied entries; *-* ===========================================. This function accepts TCut objects as arguments.; Useful to use the string operator +; example:; table.Draw(""x"",cut1+cut2+cut3);. TCutG object with ""CUTG"" name can be created via the graphics editor. TH1 * Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); *-*-*-*-*-*Draw expression varexp for specified entries; *-* ===========================================. varexp is an expression of the general form e1:e2:e3; where e1,etc is a C++ expression referencing a combination of the TTable columns; One can use two extra meta variable ""i$"" and ""n$"" along with the table; column names.; i$ is to involve the current row number; n$ refers the total num,ber of rows of this table provided by TTable::GetNRows(). Example:; varexp = x simplest case: draw a 1-Dim distribution of column named x; = sqrt(x) : draw distribution of sqrt(x); = x*y/z; = y:sqrt(x) 2-Dim dsitribution of y versus sqrt(x); = i$:sqrt(x) 2-Dim dsitribution of i versus sqrt(x[i]); = phep[0]:sqrt(phep[3]) 2-Dim dsitribution of phep[0] versus sqrt(phep[3]). Note that the variables e1, e2 or e3 may contain a boolean expression as well.; example, if e1= x*(y<0), the value histogrammed will be x if y<0; and will be 0 otherwise. selection is a C++ expression with a combination of the columns.; The value corresponding to the selection expression is used as a weight; to fill the histogram.; If the expression includes only boolean operations, the result; is 0 or 1. If the result is 0, the histogram is not filled.; In general, the expression may be of the form:. value*(boolean expression). if boolean expression is true, the histogram is filled with; a weight = value.; Examples:; selection1 = ""x<y && sqrt(z)>3.2 && 6 < i$ && i$ < n$""; selection2 = ""(x+y)*(sqrt(z)>3.2""; selection3 = ""signal*(log(signal)>1.2)""; selection1 returns a weigth = 0 or 1; selection2 returns a weight = x+y if sqrt(z)>",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTable.html:20233,simpl,simplest,20233,root/html528/TTable.html,https://root.cern,https://root.cern/root/html528/TTable.html,10,['simpl'],['simplest']
Usability,"ied with the fraction that; is in the current range w.r.t the reference range. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of observables; for interpretation of fraction coefficients. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of range; for interpretation of fraction coefficients. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Return specialized context to efficiently generate toy events from RooAddPdfs; return RooAbsPdf::genContext(vars,prototype,auxProto,verbose) ; // WVE DEBUG. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Loop over components for plot sampling hints and merge them if there are multiple. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooAddPdf to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooAddPdf(*this,newname) ; }. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force RooRealIntegral to offer all observables for internal integration. Bool_t selfNormalized() const; P.d.f is self normalized. ExtendMode extendMode() const; Return extended mode capabilities. Double_t expectedEvents(const RooArgSet* nset). const RooArgList& pdfList() const; Return list of component p.d.fs. const RooArgList& coefList() const; Return list of coefficients of component p.d.f.s. CacheElem* getProjCache(const RooArgSet* nset, const RooArgSet* iset = 0, const char* rangeName = 0) const. » Last changed: Mon Dec 7 13:45:56 2009 » Last generated: 2009-12-07 13:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAddPdf.html:47043,intuit,intuitively,47043,root/html526/RooAddPdf.html,https://root.cern,https://root.cern/root/html526/RooAddPdf.html,1,['intuit'],['intuitively']
Usability,"ied. Once the apply button is pressed, the changes are applied to the edited shape and drawn. The ""Undo"" button becomes active after the first modification has been applied. It allows restoring the initial parameters of the shape.; NOTE: In this version the ""Undo"" does not allow restoring an intermediate state of the parameters that was applied - it will always restore the parameters at the moment the shape was edited.; All material properties changes are undoable. The mixture editor currently allows adding elements one by one in the mixture composition. This can be done either by element weight fraction or by number of atoms. Once an element was added using one method the other method is not selectable anymore. Summing component fractions up to 1 in the final mixture is the user responsibility. Adding materials as components of a mixture is not supported in this version.; The elements that were added to the mixture appear in the bottom of the mixture editor. The operations performed on mixture are not undoable. Creation of New Objects; As described above, all geometry object creators are accessible within the geometry manager editor frame. Generally, if the new object that needs to be created does not depend on other objects, it will be built with a set of default parameters. This is the case for all shapes (except composite shapes) and matrices. For all the other objects the interface forces the selection of components before creating the object. Editing Volumes; Volumes are hierarchical components in the geometry, therefore their editor is more complex. It provides the following functionalities:. General. This category allows changing the name of the volume and selecting other shape or medium among existing ones.; Daughters. The category allows removing existing daughter nodes or adding new ones. The button ""Position"" allows editing the positioning matrix of a given node. Setting volume properties and modifying volume hierarchy. Visualization. This category allow",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:141881,undo,undoable,141881,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['undo'],['undoable']
Usability,"ied. Once the apply button is pressed, the changes are applied to the edited shape and drawn. The “Undo” button becomes active after the first modification has been applied. It allows restoring the initial parameters of the shape.; NOTE: In this version the “Undo” does not allow restoring an intermediate state of the parameters that was applied - it will always restore the parameters at the moment the shape was edited.; All material properties changes are undoable. The mixture editor currently allows adding elements one by one in the mixture composition. This can be done either by element weight fraction or by number of atoms. Once an element was added using one method the other method is not selectable anymore. Summing component fractions up to 1 in the final mixture is the user responsibility. Adding materials as components of a mixture is not supported in this version.; The elements that were added to the mixture appear in the bottom of the mixture editor. The operations performed on mixture are not undoable.; 18.11.4 Creation of New Objects; As described above, all geometry object creators are accessible within the geometry manager editor frame. Generally, if the new object that needs to be created does not depend on other objects, it will be built with a set of default parameters. This is the case for all shapes (except composite shapes) and matrices. For all the other objects the interface forces the selection of components before creating the object.; 18.11.5 Editing Volumes; Volumes are hierarchical components in the geometry, therefore their editor is more complex. It provides the following functionalities:. General. This category allows changing the name of the volume and selecting other shape or medium among existing ones.; Daughters. The category allows removing existing daughter nodes or adding new ones. The button “Position” allows editing the positioning matrix of a given node. . Visualization. This category allows changing the visibility of the edite",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1037458,undo,undoable,1037458,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['undo'],['undoable']
Usability,iency of the filters applied ;  df004_cutFlowReport.pyThis tutorial shows how to get information about the efficiency of the filters applied ;  df005_fillAnyObject.C This tutorial shows how to fill any object the class of which exposes a Fill method ;  df006_ranges.C This tutorial shows how to express the concept of ranges when working with the RDataFrame ;  df006_ranges.py This tutorial shows how to express the concept of ranges when working with the RDataFrame ;  df007_snapshot.C This tutorial shows how to write out datasets in ROOT formatusing the RDataFrame ;  df007_snapshot.py This tutorial shows how to write out datasets in ROOT formatusing the RDataFrame ;  df008_createDataSetFromScratch.C This tutorial shows how to create a dataset from scratch with RDataFrame ;  df008_createDataSetFromScratch.py This tutorial shows how to create a dataset from scratch with RDataFrame ;  df009_FromScratchVSTTree.C This tutorial illustrates how simpler it can be to use a RDataFrame to create a dataset with respect to the usage of the TTree interfaces ;  df010_trivialDataSource.C This tutorial illustrates how use the RDataFrame in combination with a RDataSource ;  df010_trivialDataSource.py This tutorial illustrates how use the RDataFrame in combination with a RDataSource ;  df011_ROOTDataSource.C This tutorial illustrates how use the RDataFrame in combination with a RDataSource ;  df011_ROOTDataSource.py This tutorial illustrates how use the RDataFrame in combination with a RDataSource ;  df012_DefinesAndFiltersAsStrings.C ;  df012_DefinesAndFiltersAsStrings.py ;  df013_InspectAnalysis.C Showcase registration of callback functions that act on partial results while the event-loop is running using OnPartialResult and OnPartialResultSlot ;  df014_CSVDataSource.C This tutorial illustrates how use the RDataFrame in combination with a RDataSource ;  df014_CSVDataSource.py This tutorial illustrates how use the RDataFrame in combination with a RDataSource ;  df015_LazyDataSource.C Thi,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/files.html:99030,simpl,simpler,99030,doc/v614/files.html,https://root.cern,https://root.cern/doc/v614/files.html,1,['simpl'],['simpler']
